<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 9 1007 Rikka with Travels]]></title>
    <url>%2F2019%2F08%2F19%2F2019-Multi-University-Training-Contest-9-1007%2F</url>
    <content type="text"><![CDATA[HDU 6686 Rikka with Travels题意: 在一颗树上选择两条不相交的路径的可能性有多少，路径长度定义为路径的顶点数。题解:初步思考，观察样例可以发现，求的是两条路径的有序对，[2,1],[1,2]不是同一种。我们假设已经知道你选择的一条路径长度为l,只需要找到把这条路径在树中移除，余下的森林的最长路径是多少，假设是$r$,对于长度为$l$的路径有多条，然后分别求出对应的$r$就是贡献，然后将所有的$l$的贡献，求和就是答案。很显然这么求就对超时，而且也无从下手。那么我们继续优化，对于一颗树，我们每次拆一条边。求出左边的最长直径为L,右边的最长直径为R,可以发现左边这颗子树的路径可能有$1,2,\cdots,L$，右边有$1,2,\cdots,R$, 我们可以知道，把区间$l=[1,L]$的贡献跟新为$R$,$l=[1,R]$ 更新为$L$，写出暴力修改就是 f[i]=max(f[i],R),1]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第八场)Just Jump]]></title>
    <url>%2F2019%2F08%2F14%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5(%E7%AC%AC%E5%85%AB%E5%9C%BA)J.Just-Jump%2F</url>
    <content type="text"><![CDATA[题意： 终点位置为$L$，中间点是$1,2,\cdots,L-1$ ，开始位置在$0$，每次必须走至少$d$步,在第$ti$步不能出现在$p_i$这个位置，问从$0$到$L$，有多少种走法。 题解：解法挺简单的，先算出没有$m$个约束的情况下，求一个值，这个$f[i] =\sum{j=0}^{i-d}f[i]$。然后容斥搞一下，$m$个限制，那么问题来了，怎么求刚好走$t_i$步到$p_i$。 这篇博客的意义就在这了,先推荐个基神博客。 这个求一个最后应该就等于$C(p_i-d t_i+t_i-1,t_i-1)$。 我们现在应该是对应这种情况 用插板法，就是从$n+m$个空隙里面，选出$m-1$个位置出来，现在这就是多了个要求，相邻两个间隙不能小于$d$ …,抽象理解下 你把这$m$个$d$全部推前面去，不久相当于直接在后面$n-m d-(m-1)$选$m-1$个 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 998244353;const int maxn = (int) 1e7 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;//typedef __int128 LLL;template&lt;typename T&gt;void read(T &amp;w) &#123;//读入 char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125;template&lt;typename T&gt;void output(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125;LL L, d, m;P p[3005];LL qz[maxn], l[maxn];const int Comb_Maxn = 1e7 + 10;LL Fac_inv[Comb_Maxn];LL Fac[Comb_Maxn];inline void Comb_init() &#123; Fac_inv[0] = Fac[0] = 1; Fac_inv[1] = 1; for (int i = 1; i &lt; Comb_Maxn; i++) Fac[i] = Fac[i - 1] * (LL) i % mod; for (int i = 2; i &lt; Comb_Maxn; i++) Fac_inv[i] = (LL) (mod - mod / i) * Fac_inv[mod % i] % mod; for (int i = 1; i &lt; Comb_Maxn; i++) Fac_inv[i] = (LL) Fac_inv[i - 1] * Fac_inv[i] % mod;&#125;LL Comb(LL n, LL m) &#123; if (n &lt; 0 || m &lt; 0)return 0; if (n &lt; m)return 0; assert(n &lt; Comb_Maxn &amp;&amp; n &gt;= m); assert(m &lt; Comb_Maxn); return Fac[n] * Fac_inv[m] % mod * Fac_inv[n - m] % mod;&#125;LL dp[maxn];int main() &#123; f(); read(L); read(d); read(m); Comb_init(); for (int i = 0; i &lt; m; i++) &#123; read(p[i].first); read(p[i].second); &#125; sort(p, p + m); l[0] = 1; qz[0] = 1; for (int i = 1; i &lt;= L; i++) &#123; if (i &gt;= d) &#123; l[i] = qz[i - d]; &#125; qz[i] = (qz[i - 1] + l[i]) % mod; &#125; for (int i = 0; i &lt; m; i++) &#123; dp[i] = Comb(p[i].second - d * p[i].first + p[i].first - 1, p[i].first - 1); if (dp[i] != 0) &#123; for (int j = 0; j &lt; i; j++) &#123; dp[i] = (dp[i] - Comb(p[i].second - p[j].second - d * (p[i].first - p[j].first) + (p[i].first - p[j].first) - 1, (p[i].first - p[j].first) - 1) * dp[j] % mod + mod) % mod; &#125; &#125; &#125; LL ans = l[L]; for (int i = 0; i &lt; m; i++) &#123; ans = (ans - dp[i] * l[L - p[i].second] % mod + mod) % mod; &#125; printf("%lld\n", ans);#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>牛客暑期多校训练营</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第八场)Flower Dance(有坑)]]></title>
    <url>%2F2019%2F08%2F13%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5(%E7%AC%AC%E5%85%AB%E5%9C%BA)Flower%20Dance%2F</url>
    <content type="text"><![CDATA[2019牛客暑期多校训练营(第八场)Flower Dance 题意: 给$n$个点 $m$条边，每条边有一个权值区间，表示能通过这个区间的 值的范围，问从$1$到$n$可以通过的权值有多少个。 题解: 1.DFS线段树+离散化+并查集这个线段树，其实也不能算是个正常的线段树，他build 的之后就没啥用了，没有更新和查询.。。直接在线段树上dfs,首先把权值离散化，然后存入线段树中，线段树每个节点表示，区间[l,r]，中有哪些边，这样每次深搜下去，经过的边用并查集维护起来，表示哪些点是联通的，然后如果，1和n联通的话就更新权值。这题有回溯，就有拆边，所以并查集要保存路径，而且要加按秩合并的优化,不然会超时。 写离散化线段树尽量保存 (l,r] 左开右闭的区间值，保存[l,r] 的区间会出问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;//typedef __int128 LLL;template&lt;typename T&gt;void read(T &amp;w) &#123;//读入 char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125;template&lt;typename T&gt;void output(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125;struct edge &#123; int u, v, l, r;&#125; eg[maxn];vector&lt;int&gt; v;int get(int x) &#123; return lower_bound(v.begin(), v.end(), x) - v.begin() + 1;&#125;int n, m;vector&lt;int&gt; dat[maxn];void build(int l, int r, int k, int a, int b, int x) &#123; if (l == a &amp;&amp; b == r) &#123; dat[k].emplace_back(x); return; &#125; if (b &lt;= mid) &#123; build(lson, a, b, x); &#125; else if (a &gt;= mid) &#123; build(rson, a, b, x); &#125; else &#123; build(lson, a, mid, x); build(rson, mid, b, x); &#125;&#125;vector&lt;int&gt; d[maxn];int ans = 0;int par[maxn];int find(int x) &#123; return (par[x] == x) ? x : find(par[x]);&#125;int rk[maxn];void unit(int x, int y, int dep) &#123; x = find(x); y = find(y); if (x != y) &#123; if (rk[x] &lt; rk[y])swap(x, y); par[y] = x; d[dep].emplace_back(y); if (rk[x] == rk[y])rk[x]++; &#125;&#125;void dfs(int l, int r, int k, int dep) &#123; d[dep].clear(); for (auto au:dat[k]) &#123; unit(eg[au].u, eg[au].v, dep); &#125; if (find(1) == find(n)) &#123; ans += v[r - 1] - v[l - 1]; &#125; else if (r != l + 1) &#123; dfs(lson, dep + 1); dfs(rson, dep + 1); &#125; for (auto au:d[dep]) &#123; par[au] = au; &#125;&#125;int main() &#123; f(); read(n); read(m); for (int i = 0; i &lt;= n; i++)par[i] = i; for (int i = 0; i &lt; m; i++) &#123; read(eg[i].u); read(eg[i].v); read(eg[i].l); read(eg[i].r); v.emplace_back(eg[i].l); v.emplace_back(eg[i].r + 1); &#125; sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); int mx = v.size(); for (int i = 0; i &lt; m; i++) &#123; build(1, mx, 1, get(eg[i].l), get(eg[i].r + 1), i); &#125; dfs(1, mx, 1, 0); output(ans); puts("");#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; endl;#endif return 0;&#125; LCT+最小生成树 挖个坑，懒得学splay]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>牛客暑期多校训练营</tag>
        <tag>离散化</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第八场) Distance]]></title>
    <url>%2F2019%2F08%2F13%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5(%E7%AC%AC%E5%85%AB%E5%9C%BA)Distance%2F</url>
    <content type="text"><![CDATA[2019牛客暑期多校训练营(第八场) Distance题意: 给你一个 $n m h$ 的空间，每次插入一个点，或者询问空间中点到这一点的最小曼哈顿距离。题解: 1.HASH+三维BIT三维BIT，对于这种写法，太巨了，$n m h &lt; 1e5$ 特么直接用三维BIT 存一下就可以了，枚举八个方向，把绝对值去掉，然后最牛的还是hash处理，把三维压缩成一维，削常数，我特么卡常卡成这样也是少见。这种hash将维度，枚举八个方向去绝对值，数组数组模拟空间，还是挺6的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;//typedef __int128 LLL;template&lt;typename T&gt;void read(T &amp;w) &#123;//读入 char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125;template&lt;typename T&gt;void output(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125;typedef vector&lt;int&gt; VI;typedef vector&lt;VI&gt; VVI;typedef vector&lt;VVI&gt; VVVI;struct BIT &#123; int n, m, h; int a[maxn]; void init(int n, int m, int h) &#123; this-&gt;n = n; this-&gt;m = m; this-&gt;h = h; mem(a, -inf); &#125; int get(int x, int y, int z) &#123; return x * h * m + y * h + z; &#125; int lowbit(int &amp;x) &#123; return x &amp; (-x); &#125; void add(int x, int y, int z, int t) &#123; for (int i = x; i &lt;= n; i += lowbit(i)) for (int j = y; j &lt;= m; j += lowbit(j)) for (int k = z; k &lt;= h; k += lowbit(k)) a[get(i, j, k)] = max(a[get(i, j, k)], t); &#125; int sum(int x, int y, int z) &#123; int res = -inf; for (int i = x; i; i -= lowbit(i)) for (int j = y; j; j -= lowbit(j)) for (int k = z; k; k -= lowbit(k)) res = max(a[get(i, j, k)], res); return res; &#125;&#125; b[8];int get_pos(int x, int pos) &#123; return (x &gt;&gt; pos) &amp; 1;&#125;int main() &#123; f(); int n, m, h, q; int op; read(n); read(m); read(h); read(q); for (int i = 0; i &lt; 8; i++) &#123; b[i].init(n, m, h); &#125; int d[] = &#123;n + 1, m + 1, h + 1&#125;; int a[3], c[3]; while (q--) &#123; read(op); read(a[0]); read(a[1]); read(a[2]); if (op == 1) &#123; for (int i = 0; i &lt; 8; i++) &#123; c[0] = get_pos(i, 0) ? d[0] - a[0] : a[0]; c[1] = get_pos(i, 1) ? d[1] - a[1] : a[1]; c[2] = get_pos(i, 2) ? d[2] - a[2] : a[2]; b[i].add(c[0], c[1], c[2], c[1] + c[2] + c[0]); &#125; &#125; else &#123; int ans = inf; for (int i = 0; i &lt; 8; i++) &#123; c[0] = get_pos(i, 0) ? d[0] - a[0] : a[0]; c[1] = get_pos(i, 1) ? d[1] - a[1] : a[1]; c[2] = get_pos(i, 2) ? d[2] - a[2] : a[2]; ans = min(ans, c[0] + c[1] + c[2] - b[i].sum(c[0], c[1], c[2])); &#125; output(ans); puts(""); &#125; &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; " s" &lt;&lt; endl;#endif return 0;&#125; 2.分块+bfs第二种写法就更骚了Orz,对于 $1e5$ 组查询，分成$\sqrt{(1e5)}$ 块，每次插入一个点，先判断有没有$\sqrt{(1e5)}$个，少于这个数量，直接暴力找，假设就算每次都是满的都是 $\sqrt{(1e5)} 1e5$ 的复杂度，然后如果满了，直接空间中bfs,比如说你插入了两个点,0,0,1 0,0,2,直接暴力bfs,枚举6个方向,找离这个点最近的距离是多少。暴力枚举空间复杂度是$O(n m h)$.总复杂度就是 $q\sqrt{q}+\sqrt{n m h} q$.* 这种分块更新的操作，学不来，学不来，根本学不来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include "bits/stdc++.h" using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a)); const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8; #ifndef ONLINE_JUDGEclock_t prostart = clock();#endif void f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125; //typedef __int128 LLL; template&lt;typename T&gt;void read(T &amp;w) &#123;//读入 char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125; template&lt;typename T&gt;void output(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125; int a[maxn]; int dir[6][3] = &#123;&#123;1, 0, 0&#125;, &#123;-1, 0, 0&#125;, &#123;0, 1, 0&#125;, &#123;0, -1, 0&#125;, &#123;0, 0, 1&#125;, &#123;0, 0, -1&#125;&#125;;int X[maxn], Y[maxn], Z[maxn];int lx, ly, lz;int n, m, h, q; int get(int x, int y, int z) &#123; return x * h * m + y * h + z;&#125; struct node &#123; int k, x, y, z; node(int x, int y, int z) &#123; this-&gt;x = x; this-&gt;y = y; this-&gt;z = z; this-&gt;k = get(x, y, z); &#125;&#125;; void rebuild() &#123; queue&lt;node&gt; que; for (int i = 0; i &lt; lx; i++) &#123; que.push(node(X[i], Y[i], Z[i])); a[get(X[i], Y[i], Z[i])] = 0; &#125; while (que.size()) &#123; node t = que.front(); que.pop(); for (int i = 0; i &lt; 6; i++) &#123; int tox = t.x + dir[i][0], toy = t.y + dir[i][1], toz = t.z + dir[i][2]; if (tox &lt; 0 || tox &gt;= n || toy &lt; 0 || toy &gt;= m || toz &lt; 0 || toz &gt;= h) continue; int k = get(tox, toy, toz); if (a[k] &gt; a[t.k] + 1) &#123; a[k] = a[t.k] + 1; que.push(node(tox, toy, toz)); &#125; &#125; &#125; lx = 0; ly = 0; lz = 0;&#125; int op, x, y, z; int main() &#123; f(); mem(a, inf); read(n); read(m); read(h); read(q); while (q--) &#123; read(op); read(x); read(y); read(z); --x, --y, --z; if (op == 1) &#123; X[lx++] = x; Y[ly++] = y; Z[lz++] = z; &#125; else &#123; int k = get(x, y, z); int ans = a[k]; for (int i = 0; i &lt; lx; i++) &#123; ans = min(ans, abs(x - X[i]) + abs(z - Z[i]) + abs(y - Y[i])); &#125; output(ans); puts(""); &#125; if (lx == 300) &#123; rebuild(); &#125; &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; " s" &lt;&lt; endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>牛客暑期多校训练营</tag>
        <tag>树状数组</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第七场) E Find the median]]></title>
    <url>%2F2019%2F08%2F09%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5(%E7%AC%AC%E4%B8%83%E5%9C%BA)E.Find-the-median%2F</url>
    <content type="text"><![CDATA[2019牛客暑期多校训练营(第七场)Find the median 题意: 先把输入处理一下，没啥问题吧。处理完后应该相当于每次在一个集合里面加入l,r之间所有的数，问中位数是多少。题解： 这题很有意思，离散化+线段树 就能做，就相当于在线段树上求第sum/2个数在哪。比较朴素的就是先把所有的l,r保存下来，然后把他离散化，然后对离散化后的值做插入删除操作，我根据线段树动态开点的操作，写了个在线段树上直接离散化的操作，有点像把动态开点和离散化结合起来的感觉。总体来说：就是需要哪个区间我就把线段树的下一个节点开什么样的l,r，不一定是刚好分一半。这样写很容易被卡掉，因为可能退化到$n^2$的复杂度。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;const LL mod = (LL) 1e9 + 7;const int maxn = (int) 4e7 + 5;const int MX = 4e5 + 10;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;LL n;LL x1, x2, a1, b1, c1, m1, Y1, y2, a2, b2, c2, m2;LL ls[MX], rs[MX], xs[MX], ys[MX];struct node &#123; int l; int r; int num; LL sum; int ls, rs;&#125; dat[maxn];int cnt;int init(int l, int r, int k) &#123; dat[k].l = l; dat[k].r = r; dat[k].sum = 0; dat[k].num = 0; dat[k].ls = -1; dat[k].rs = -1; return k;&#125;void build(int l, int r, int k) &#123; cnt = 0; init(l, r, cnt++);&#125;void add(int k, int num) &#123; dat[k].num += num; dat[k].sum += 1LL * (dat[k].r - dat[k].l + 1) * num;&#125;void pushdown(int k) &#123; add(dat[k].ls, dat[k].num); add(dat[k].rs, dat[k].num); dat[k].num = 0; dat[k].sum = dat[dat[k].ls].sum + dat[dat[k].rs].sum;&#125;void update(int a, int b, int k) &#123; if (b &lt; dat[k].l || a &gt; dat[k].r)return; if (a &lt;= dat[k].l &amp;&amp; dat[k].r &lt;= b) &#123; dat[k].num++; dat[k].sum += dat[k].r - dat[k].l + 1; &#125; else &#123; if (dat[k].ls == -1) &#123; int mid; if (b &lt;= dat[k].r) &#123; mid = b; &#125; else mid = a; if (mid == dat[k].l) &#123; //需要什么点，开什么点 dat[k].ls = init(dat[k].l, mid, cnt++); dat[k].rs = init(mid + 1, dat[k].r, cnt++); &#125; else &#123; dat[k].ls = init(dat[k].l, mid - 1, cnt++); dat[k].rs = init(mid, dat[k].r, cnt++); &#125; &#125; pushdown(k); update(a, b, dat[k].ls); update(a, b, dat[k].rs); dat[k].sum = dat[dat[k].ls].sum + dat[dat[k].rs].sum; &#125;&#125;int querry(int k, LL x) &#123; if (dat[k].ls == -1) &#123; return dat[k].l + (x + dat[k].num - 1) / dat[k].num - 1; &#125; else &#123; pushdown(k); if (dat[dat[k].ls].sum &gt;= x) &#123; return querry(dat[k].ls, x); &#125; else return querry(dat[k].rs, x - dat[dat[k].ls].sum); &#125;&#125;int main() &#123; f(); scanf("%lld", &amp;n); scanf("%lld%lld%lld%lld%lld%lld", &amp;x1, &amp;x2, &amp;a1, &amp;b1, &amp;c1, &amp;m1); scanf("%lld%lld%lld%lld%lld%lld", &amp;Y1, &amp;y2, &amp;a2, &amp;b2, &amp;c2, &amp;m2); ls[1] = min(x1, Y1) + 1, rs[1] = max(x1, Y1) + 1; ls[2] = min(x2, y2) + 1, rs[2] = max(x2, y2) + 1; xs[1] = x1, ys[1] = Y1; xs[2] = x2, ys[2] = y2; for (int i = 3; i &lt;= n; ++i) &#123; xs[i] = (1LL * a1 * xs[i - 1] + 1LL * b1 * xs[i - 2] + c1) % m1; ys[i] = (1LL * a2 * ys[i - 1] + 1LL * b2 * ys[i - 2] + c2) % m2; ls[i] = min(xs[i], ys[i]) + 1; rs[i] = max(xs[i], ys[i]) + 1; &#125; LL mi = 1e9 + 1, mx = -1; for (int i = 1; i &lt;= n; ++i) &#123; mx = max(mx, rs[i]); mi = min(mi, ls[i]); &#125; LL S = 0; build(mi, mx, 0); for (LL i = 1; i &lt;= n; i++) &#123; S += rs[i] - ls[i] + 1; update(ls[i], rs[i], 0); printf("%d\n", querry(0, (S+1) / 2)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>牛客暑期多校训练营</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 5 1002 three arrays]]></title>
    <url>%2F2019%2F08%2F09%2F2019-Multi-University-Training-Contest-5-1002-three-arrays%2F</url>
    <content type="text"><![CDATA[HDU 6625 three arrays题意： 给两个数组，求两个数组两两异或后最小字典序。题解： 求字典序最小，也就是求值最小，如果是求一个数和另一个数组里面的一个值异或最小，很显然就是字典树，就是在字典树上优先取同位相同，没有再取同位相反。求两个数组异或之后字典序最小，其实也可以按照同样的方法求解。对两个数组分别做成一颗字典树，求两颗线段树异或之后字典序最小，就是两颗树异或值尽可能小。一开始我想到这个写法的时候，队友说如果0 0，和1 1 异或都等于0 先选哪一个，仔细思考一下，其实没有什么影响，统计一下两颗树当前节点下方，0 1 的个数，优先把 0 0 1 1 匹配掉，然后再把0 1 1 0两种匹配掉。有点像在字典树上贪心.复杂度两颗树最多有n*31个节点，最差就是每个树都跑一次，所以复杂度是$O(nlog(n))$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;int n;inline int getpos(int x, int pos) &#123; return ((x &gt;&gt; pos) &amp; 1);&#125;struct tree &#123; int a[maxn * 10][3]; int num[maxn * 10][3]; int root = 0; int cnt = 1; void init() &#123; cnt = 1; &#125; void insert(int x) &#123; int p = root, dep = 30; while (dep &gt;= 0) &#123; int nx = getpos(x, dep); if (num[p][nx] == 0) &#123; a[p][nx] = cnt++; num[p][nx] = 1; &#125; else &#123; num[p][nx]++; &#125; p = a[p][nx]; dep--; &#125; &#125;&#125; t1, t2;vector&lt;int&gt; v;template&lt;class T&gt;inline T min(T t1, T t2, T t3) &#123; return min(t1, min(t2, t3));&#125;void dfs(int now1, int now2, int num, int val, int dep) &#123; if (dep == -1) &#123; for (int i = 0; i &lt; num; i++) v.emplace_back(val); return; &#125; if (t1.num[now1][0] &gt; 0 &amp;&amp; t2.num[now2][0] &gt; 0 &amp;&amp; num &gt; 0) &#123; int ct = min(t2.num[now2][0], t1.num[now1][0], num); dfs(t1.a[now1][0], t2.a[now2][0], ct, val, dep - 1); t1.num[now1][0] -= ct; t2.num[now2][0] -= ct; num -= ct; &#125; if (t1.num[now1][1] &gt; 0 &amp;&amp; t2.num[now2][1] &gt; 0 &amp;&amp; num &gt; 0) &#123; int ct = min(t1.num[now1][1], t2.num[now2][1], num); dfs(t1.a[now1][1], t2.a[now2][1], ct, val, dep - 1); t1.num[now1][1] -= ct; t2.num[now2][1] -= ct; num -= ct; &#125; if (t1.num[now1][0] &gt; 0 &amp;&amp; t2.num[now2][1] &gt; 0 &amp;&amp; num &gt; 0) &#123; int ct = min(t2.num[now2][1], t1.num[now1][0], num); dfs(t1.a[now1][0], t2.a[now2][1], ct, val | (1 &lt;&lt; dep), dep - 1); t1.num[now1][0] -= ct; t2.num[now2][1] -= ct; num -= ct; &#125; if (t1.num[now1][1] &gt; 0 &amp;&amp; t2.num[now2][0] &gt; 0 &amp;&amp; num &gt; 0) &#123; int ct = min(t1.num[now1][1], t2.num[now2][0], num); dfs(t1.a[now1][1], t2.a[now2][0], ct, val | (1 &lt;&lt; dep), dep - 1); t1.num[now1][1] -= ct; t2.num[now2][0] -= ct; num -= ct; &#125;&#125;int main() &#123; f(); int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); t1.init(); t2.init(); for (int i = 0; i &lt; n; i++) &#123; int a; scanf("%d", &amp;a); t1.insert(a); &#125; for (int j = 0; j &lt; n; j++) &#123; int a; scanf("%d", &amp;a); t2.insert(a); &#125; v.clear();// debug(t2.num[29][1]); dfs(0, 0, n, 0, 30); sort(v.begin(), v.end()); for (int i = 0; i &lt; n; i++) &#123; printf("%d%c", v[i], i == n - 1 ? '\n' : ' '); &#125; &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回文树]]></title>
    <url>%2F2019%2F08%2F07%2F%E5%9B%9E%E6%96%87%E6%A0%91%2F</url>
    <content type="text"><![CDATA[这个东西学会了AC自动机 理解这个应该不难，AC自动fail指针保存了一个最长匹配后缀，这个也差不多。这个保存了最长匹配后缀回文串。举个例子老子找了半天没找到原本看过的博客，只找到了这张图片。随便写几句混一混就过去了。回文树里面的next 和字典树差不多的意义，只不过字典树里面的一个节点是表示在一个节点后面加上一个字符，但next是前后各加一个字符,就是t变成tc 和t变成ctc的区别，前后各加一个字符肯定是回文串。那么问题来了奇数的回文串怎么办，所以出现啊了两个根节点，一个0,一个-1，连在-1的表示是个奇数个数的回文串，看代码里面的x-len[p]+1刚好也是自己，所以自己和自己一定是回文串没啥毛病。再给个图fail差不多就是上图的意思.解释下例子怎么构造的开始的时候建立两个根节点,两个根节点一个长度为0,一个-1，将fail[0]=1,0表示长度为0,1号节点长度为-1,一开始加入a肯定是没有任何后缀，直接连上-1根节点，fail肯定是连上0，此时当前节点的回文后缀有a，空串和-1，然后添加b,a节点前面很显然没有b，所以无法匹配，然后匹配空串，空串前面是a所以还是没法匹配，又匹配-1，很显然这个一定是可以的，因为和自己肯定是相同的.也就是构建了这一部分。然后下一个字符串还是b,此时后缀有b,空串和-1，匹配后缀b前一个是a很显然不匹配，匹配空串,前一个刚好是b所以此时，将bb连到0节点下面，fail指向父亲节点失陪的第一个能够匹配b的位置，这个有点难理解。在代码中是这一行。下一个字符是a，此时字符串最长回文后缀有bb,b,空串和-1,显然bb就直接匹配了，然后再更新fail,差不多就是这么个过程。多余的不解释看别人博客去吧。想深入了解，去看看 国家集训队2017年的论文 吧12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061namespace Palindromic_Tree &#123;const int MAXN = 1000010;const int N = 26;int next[MAXN][N];//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成int fail[MAXN];//fail指针，失配后跳转到fail指针指向的节点int cnt[MAXN];int num[MAXN];int len[MAXN];//len[i]表示节点i表示的回文串的长度int S[MAXN];//存放添加的字符int last;//指向上一个字符所在的节点，方便下一次addint n;//字符数组指针int p;//节点指针int newnode(int l) &#123;//新建节点 for (int i = 0; i &lt; N; ++i) next[p][i] = 0; cnt[p] = 0; num[p] = 0; len[p] = l; return p++;&#125;void init() &#123;//初始化 p = 0; newnode(0); newnode(-1); last = 0; n = 0; S[n] = -1;//开头放一个字符集中没有的字符，减少特判 fail[0] = 1;&#125;int get_fail(int x) &#123;//和KMP一样，失配后找一个尽量最长的 while (S[n - len[x] - 1] != S[n]) x = fail[x]; return x;&#125;int add(int c) &#123; c -= 'a'; S[++n] = c; int ct = 0; int cur = get_fail(last);//通过上一个回文串找这个回文串的匹配位置 if (!next[cur][c]) &#123;//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串 int now = newnode(len[cur] + 2);//新建节点 fail[now] = next[get_fail(fail[cur])][c];//和AC自动机一样建立fail指针，以便失配后跳转 next[cur][c] = now; num[now] = num[fail[now]] + 1; ct = num[now]; &#125; last = next[cur][c]; cnt[last]++; return num[last];&#125;void count() &#123; for (int i = p - 1; i &gt;= 0; --i) cnt[fail[i]] += cnt[i]; //父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！&#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>回文树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AC自动机]]></title>
    <url>%2F2019%2F08%2F07%2FAC%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[AC自动机用途给多个字符串t，再询问一个字符串s，问有多少个字符串t出现在询问的字符串s中。 前置技能学AC自动机之前，先学会什么是字典树，什么是kmp。kmp我写过一篇博客，就不讲了，就是next 数组保存一个最长匹配前缀。字典树就更简单了，每个节点从根节点开始，出现一个字符就在父亲节点上连上下一个节点，也不多说。有需要再写一篇博客。 AC自动机对于这个玩意，都说是字典树上跑KMP,到也没错。朴素KMP是在一个串上面跑next,而AC自动机只是变成了在字典树节点上跑fail指针，每个fail指针保存是最长匹配后缀。推荐一名大佬博客，讲的挺不错的。朴素的写法，每一个字符串t对s做一次kmp算法或者 对所有的t字符串建一颗字典树，然后每个位置匹配一下，很显然$O(n^2)$的复杂度，绝对超时。仔细思考一下，字典树里面，每次匹配都要从下一个位置开始跑一次匹配，类比一下没有kmp的朴素字符串匹配。是不是有点相似。普通单个字符串匹配，是不是枚举每一个位置，然后做一次暴力匹配？然后kmp 做了什么，通过next找到最大匹配前缀。那么我们是否可以在字典树用fail保存最大匹配后缀呢？显然是可以的，不然AC自动机干啥.举个栗子： 假设有三个t asa aaa aas, 匹配aasab字典树建成这个样子，丑了点，别在意，重在思想。然后一开始吧aas匹配掉了没啥意见吧，然后继续匹配aasa，很显然这个时候没有这个字符串，那么肯定就要转移，转移到哪去呢？最长匹配后缀啊。如图是不是这样。然后匹配asa,再继续匹配b,很显然失配了啊，然后找最长匹配后缀，只有根节点了，然后根节点背后又没有b。所以啥都没了，匹配最长后缀为空串。好了，现在差不多理解这个算法的思想，接下来就是一些细节，不知道我还有没有没有考虑到的，如果有请在评论区提问。1.上诉所讲的例子很明显，aas向as跳转，如果后继没有a这个节点怎么办?asa 改成asb,asa要匹配谁呢？这个在kmp算法里面也有这个问题，很显然，继续找下去就能解决问题，假设 再加一个tsb，aasb适配，aas调转到as没有后继b,再跳转到匹配后缀s，有后继b就匹配sb，类推，如果还没有找到就继续想上找。ps: 这个地方可以优化，fail指针找到了最长匹配后缀，然后字典树的下一个节点可以直接跳到对应位置如例子 aas后继a可以直接跳到为asa这个节点，不过不优化也没啥影响，因为字符串长度是固定的，最多不会跳超过n次，不优化只是多了个常数2.多个匹配怎么办？没到一个节点把他的fail找下去记录个数，如图字典树匹配sa,的时候会找他的fail,找到a然后把a这个节点记录，同理找sab,不仅仅把自己匹配了，还要把b匹配掉3.怎么记录个数，如果一个字符串多次出现怎么办，看代码，记录一下就行了。 这个AC自动机的思想还是要学好，后面回文自动机要用到这个玩意的思想。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263namespace Aho_Corasick_Automaton &#123;int trie[maxn][27]; //字典树int cntword[maxn]; //记录单词出现次数，可以开一个vector记录是第几个单词int fail[maxn]; // 失败回溯int cnt=0; // 树的节点个数void init(int x) &#123; for(int i=0; i&lt;26; i++) &#123; trie[x][i]=0; &#125;&#125;void insertWords(char *s) &#123; int ls=strlen(s); int root=0; for(int i=0; i&lt;ls; i++) &#123; int next=s[i]-'a'; if(!trie[root][next]) &#123; init(++cnt); trie[root][next]=cnt; &#125; root=trie[root][next]; &#125; cntword[root]++;&#125;void getFial() &#123; queue&lt;int&gt; q; for(int i=0; i&lt;26; i++) &#123; if(trie[0][i]) &#123; fail[trie[0][i]]=0; q.push(trie[0][i]); &#125; &#125; while(q.size()) &#123; int now=q.front(); q.pop(); for(int i=0; i&lt;26; i++) &#123; if(trie[now][i]) &#123; fail[trie[now][i]]=trie[fail[now]][i]; q.push(trie[now][i]); &#125; else trie[now][i]=trie[fail[now]][i]; &#125; &#125;&#125;int query(char *s) &#123; int ls=strlen(s); int now =0,ans=0; for(int i=0; i&lt;ls; i++) &#123; now=trie[now][s[i]-'a']; for(int j=now; j&amp;&amp;cntword[j]!=-1; j=fail[j]) &#123; // 如果这种状态已经计算过了就不用继续找下去了 ans+=cntword[j];//统计个数，可以在这进行各种操作 cntword[j]=-1; &#125; &#125; return ans;&#125;&#125; 再贴一个大哥板子123456789101112131415161718192021222324252627282930313233343536373839queue&lt;int&gt;q;struct Aho_Corasick_Automaton &#123; int c[N][26],val[N],fail[N],cnt; void ins(char *s) &#123; int len=strlen(s); int now=0; for(int i=0; i&lt;len; i++) &#123; int v=s[i]-'a'; if(!c[now][v]) c[now][v]=++cnt; now=c[now][v]; &#125; val[now]++; &#125; void build() &#123; for(int i=0; i&lt;26; i++) if(c[0][i]) fail[c[0][i]]=0,q.push(c[0][i]); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=0; i&lt;26; i++) if(c[u][i]) fail[c[u][i]]=c[fail[u]][i],q.push(c[u][i]); else c[u][i]=c[fail[u]][i]; &#125; &#125; int query(char *s) &#123; int len=strlen(s); int now=0,ans=0; for(int i=0; i&lt;len; i++) &#123; now=c[now][s[i]-'a']; for(int t=now; t&amp;&amp;~val[t]; t=fail[t]) ans+=val[t],val[t]=-1; &#125; return ans; &#125;&#125; AC;]]></content>
      <categories>
        <category>ACM</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 4-1003 Divide the Stones]]></title>
    <url>%2F2019%2F07%2F31%2F2019-Multi-University-Training-Contest-4-1003%2F</url>
    <content type="text"><![CDATA[HDU 6616 Divide the Stones题意： 给一个n和一个k，将重量为[1,n]的石子分成k堆，每堆重量一样。题解： 先将石子分成n/k份，比如15 3，分成1 2 34 5 67 8 910 11 1213 14 15不难看出如果刚好偶数分，每两份组成一个，分配一定是刚好分配合理的，比如上述例子没有13 14 15,肯定是前两组分成 1 6,2 5 3 4 后两组7 12 8 11 9 10,这样一定是平分的。如果是奇数，&gt;3的份数，依旧一样的处理，1 2 3前三份再分成3等份。这个分法有很多，我找了一个比较辣鸡的。 画个图给你看下图给你了，看不看得懂就是你的悟性了，告辞.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;LL n, k;vector&lt;int&gt; v[maxn];vector&lt;LL&gt; ans[maxn];int main() &#123; int T; f(); scanf("%d", &amp;T); while (T--) &#123; scanf("%lld%lld", &amp;n, &amp;k); LL sum = n * (n + 1) / 2 / k; if (n == 1 &amp;&amp; k == 1) &#123; puts("yes\n1"); continue; &#125; if (n == k || n * (n + 1) / 2 % k != 0) &#123; puts("no"); &#125; else if (k == 1) &#123; puts("yes"); for (int i = 1; i &lt;= n; i++) &#123; printf("%d%c", i, i == n ? '\n' : ' '); &#125; &#125; else &#123; n /= k; int pos = 1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; k; j++) &#123; v[i].push_back(pos++); &#125; &#125; puts("yes"); if (n &amp; 1) &#123; for (int j = 4; j &lt;= n; j += 2) &#123; for (int i = 0; i &lt; k; i++) &#123; ans[i].push_back(v[j][i]); ans[i].push_back(v[j + 1][k - i - 1]); &#125; &#125; int j = k / 2 - 1; for (int i = 0; i &lt; k; i++) &#123; ans[i].push_back(v[3][i]); ans[i].push_back(v[2][(++j) % k]); &#125; for (int i = 0; i &lt; k; i++) &#123; LL temp = 0; for (int j = 0; j &lt; n; j++) &#123; if (j + 1 != n)temp += ans[i][j]; else ans[i].push_back(sum - temp); printf("%lld", ans[i][j]); if (j + 1 == n)printf("\n"); else printf(" "); &#125; ans[i].clear(); &#125; &#125; else &#123; for (int j = 1; j &lt;= n; j += 2) &#123; for (int i = 0; i &lt; k; i++) &#123; ans[i].push_back(v[j][i]); ans[i].push_back(v[j + 1][k - i - 1]); &#125; &#125; for (int i = 0; i &lt; k; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; printf("%lld", ans[i][j]); if (j + 1 == n)printf("\n"); else printf(" "); &#125; ans[i].clear(); &#125; &#125; &#125; for (int i = 0; i &lt;= n; i++) &#123; v[i].clear(); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>构造</category>
      </categories>
      <tags>
        <tag>杭电多校</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组和高度数组(LCP)学习笔记(有坑)]]></title>
    <url>%2F2019%2F07%2F30%2F%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%92%8C%E9%AB%98%E5%BA%A6%E6%95%B0%E7%BB%84(LCP)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[后缀数组字符串后缀，指从字符串某个位置开始到字符串末尾的字串，原串和空串也是后缀。反之前缀。用sa保存字符串开始的下标。字符串总共有n+1个,字符串比较大小是$O(n)$的,所以直接用sort直接排序是$O(n^2log(n))$,很显然不合理。 优化一 hash优化把字符串hash处理,修改sort排序方式，比较两个字符串，先二分最长前缀，比较两个字符串hash处理是$O(1)$的，然后比较第一个位置不同的地方就行了。复杂度$(O(nlog^2(n)))$,但是hash可能会有冲突. 优化二 倍增优化假设一个字符串abaca12345acaacabacaabaca 后缀如上一开始比较可以得出,a&lt;b&lt;c得到一个rank可以表示为字符大小,然后根据这个排序后缀数组。123456789a=0b=1c=2//字符串就是aaabc 然后开始倍增，比较长度2，由于已经知道了a,b,c，长度为1的大小所以可以直接比较，第一个长度1，的大小，再比较第二个长度为1的大小最终可以得出a&lt;ab&lt;ac&lt;ba&lt;ca1234567891011a=0ab=1ac=2ba=3ca=4//字符串aabacbaca 详细推断见 白书P378依次类推就行了，详情见代码这个地方排序可以用基数排序，将复杂度优化到$O(nlog(n))$ 优化三 SA-IS挖下坑以后填，另外还有DC3算法$O(n)$的复杂度，但是DC3常数太大. 高度数组这个处理也非常巧妙，我觉得字符串处理都很有意思。假设一个字符串abracadabra一开始处理出sa 数组你可以发现一个很有意思的事一开始匹配和sa[0] 最大的那一个，也就是原串。abracadabra 后缀排序后比他小的排序后比他小的第一个sa[7]就是abra不难看出来，前缀就是4个。sa[1] bracadabra 匹配 sa[8] bra发现了没有，刚好就是 前面的减去一个刚好3个。然后继续匹配sa[2] racadabra sa[9] ra刚好2个,然后继续sa[3] acadabra sa[0] abracadabra刚好1个。所以sa[i] 匹配sa[k],虽然下一个sa[i+1] 不一定匹配sa[k+1] ,但是匹配个数一定至少是$h_i-1$个，然后我们可以直接从$h_i-1$开始匹配就好了。最多增加不会超过n次，所以复杂度是$O(n)$的。详情见 白书382 推荐习题POJ 2217 SecretaryPOJ 3581 Sequencespoj spoj 694 Distinct Substrings 整理板子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748namespace My &#123; int Rank[maxn + 1], tmp[maxn + 1]; int k, n; bool compare_sa(const int &amp;i, const int &amp;j) &#123; if (Rank[i] != Rank[j])return Rank[i] &lt; Rank[j]; //这个地方很巧妙，比较前k else &#123; int ri = i + k &lt;= n ? Rank[i + k] : -1; //如果加上后半部分超过n，就直接算最小。 int rj = j + k &lt;= n ? Rank[j + k] : -1; return ri &lt; rj; &#125; &#125; template&lt;class T&gt; void construct_sa(T *S, int _n, int *sa) &#123; n = _n; for (int i = 0; i &lt;= n; i++) &#123; sa[i] = i; Rank[i] = i &lt; n ? S[i] : -1; &#125; for (k = 1; k &lt;= n; k *= 2) &#123; sort(sa, sa + n + 1, compare_sa); tmp[sa[0]] = 0; for (int i = 1; i &lt;= n; i++) &#123; tmp[sa[i]] = tmp[sa[i - 1]] + compare_sa(sa[i - 1], sa[i]); //如果两个相等说明前k相等，就像在同一个桶里一样。 &#125; for (int i = 0; i &lt;= n; i++) &#123; Rank[i] = tmp[i]; &#125; &#125; &#125; template&lt;class T&gt; void construct_lcp(T *S, int _n, int *sa, int *lcp) &#123; n = _n; for (int i = 0; i &lt;= n; i++)Rank[sa[i]] = i; int h = 0; lcp[0] = 0; for (int i = 0; i &lt; n; i++) &#123; int j = sa[Rank[i] - 1]; if (h &gt; 0)h--; for (; j + h &lt; n &amp;&amp; i + h &lt; n; h++) &#123; if (S[j + h] != S[i + h])break; &#125; lcp[Rank[i] - 1] = h; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 3 1011 Squrirrel]]></title>
    <url>%2F2019%2F07%2F30%2F2019-Multi-University-Training-Contest-3-1011%2F</url>
    <content type="text"><![CDATA[HDU 6613 Squrirrel题意： 可以合并树上两个点，合并两个点让某一个点到离他最远的距离最小，如果有多个答案输出字典序最小的。题解： 首先从叶子节点往根节点跑，保存每个到这个点的最大距离，和儿子节点删掉一条边之后最大距离的最小值。（肯定是从最大路径上删一条边）我为了保险全判断了 。然后再从根节点往儿子节点跑，每次保存一个，最大，次大，第三大，具体为什么看代码注释。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 2e5 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;int ans1;vector&lt;int&gt; G[maxn];vector&lt;int&gt; cost[maxn];int dp[maxn];int mi[maxn];int in[maxn];int used[maxn];int ans2 = inf;void dfs(int r, int p, int mx, int cmi, int c) &#123; cmi = min(cmi + c, mx); mx = mx + c; int temp = min(max(mx, mi[r]), max(cmi, dp[r])); if (ans2 &gt; temp) &#123; ans2 = temp; ans1 = r; &#125; if (ans2 == temp) &#123; ans2 = temp; ans1 = min(ans1, r); &#125;// cout &lt;&lt; "r=" &lt;&lt; r &lt;&lt; "mx=" &lt;&lt; mx &lt;&lt; "mi=" &lt;&lt; cmi &lt;&lt; endl;// int temp = min(max(dp[r], cmi), max(mi[r], mx));// if (ans2 &gt; temp) &#123;// ans2 = min(max(dp[r], cmi), max(mi[r], mx));// ans1 = r;// &#125; else if (ans2 == temp)ans1 = min(r, ans1); int mx1 = mx, mx2 = 0, mx3 = 0, mi2 = -1, mi1 = p, mi3 = -1, vmi1 = cmi, vmi2 = 0, vmi3 = 0; //记录最大，次大，第三大 for (int i = 0; i &lt; G[r].size(); i++) &#123; int au = G[r][i]; int c = dp[au] + cost[r][i]; if (au == p) continue; temp = min(dp[au], mi[au] + cost[r][i]); if (mx1 &lt;= c) &#123; swap(mx1, c); swap(mi1, au); swap(vmi1, temp); &#125; if (mx2 &lt;= c) &#123; swap(mx2, c); swap(mi2, au); swap(vmi2, temp); &#125; if (mx3 &lt;= c) &#123; swap(mx3, c); swap(mi3, au); swap(vmi3, temp); &#125; &#125; for (int i = 0; i &lt; G[r].size(); i++) &#123; int au = G[r][i]; int c = cost[r][i]; if (au == p)continue; if (au == mi1) &#123; if (mi3 == -1)dfs(au, r, mx2, vmi2, c); else dfs(au, r, mx2, max(vmi2, mx3), c); //如果是往最大的路径走，就是在次大的路上删一条边再和第三大比较 &#125; else if (au == mi2) &#123; if (mi3 == -1)dfs(au, r, mx1, vmi1, c); else dfs(au, r, mx1, max(vmi1, mx3), c); //如果是往第二大的，就是在最大路上删一条边再和第三大比较 &#125; else dfs(au, r, mx1, max(vmi1, mx2), c); // 其他的肯定都是删最大的路径一条边 再和第二大比较 &#125;&#125;int main() &#123; f(); int n; int t; scanf("%d", &amp;t); while (t--) &#123; scanf("%d", &amp;n); for (int i = 1; i &lt; n; i++) &#123; int u, v, c; scanf("%d%d%d", &amp;u, &amp;v, &amp;c); G[u].emplace_back(v); cost[u].emplace_back(c); G[v].emplace_back(u); cost[v].emplace_back(c); in[u]++; in[v]++; &#125; queue&lt;int&gt; q; for (int i = 1; i &lt;= n; i++) &#123; dp[i] = 0; if (in[i] == 1) &#123; q.push(i); mi[i] = 0; &#125; else mi[i] = inf; &#125; int r = -1; ans1 = 0; ans2 = inf; while (q.size()) &#123; int v = q.front(); q.pop(); r = v; if (used[v] == 0)used[v] = 1; else continue; int mx1 = 0, mx2 = 0; for (int i = 0; i &lt; G[r].size(); i++) &#123; int au = G[r][i]; int c = dp[au] + cost[r][i]; if (!used[au])continue; if (mx1 &lt; c)swap(mx1, c); if (mx2 &lt; c)swap(mx2, c); &#125; for (int i = 0; i &lt; G[r].size(); i++) &#123; int au = G[r][i]; int c = cost[r][i]; if (!used[au])continue; if (dp[au] + c == mx1) &#123; mi[r] = min(mi[r], max(min(dp[au], mi[au] + c), mx2)); //这个肯定就是最小的 &#125; else mi[r] = min(mi[r], max(min(dp[au], mi[au] + c), mx1)); //这个可以不要 &#125; for (int i = 0; i &lt; G[v].size(); i++) &#123; int &amp;au = G[v][i], &amp;c = cost[v][i]; in[au]--; if (used[au] == 0) &#123; dp[au] = max(dp[r] + c, dp[au]); if (in[au] == 1)q.push(au); &#125; &#125; &#125;// for (int i = 1; i &lt;= n; i++) &#123;// printf("[%d]= %d %d\n", i, dp[i], mi[i]);// &#125; if (n == 1 || n == 2)printf("%d %d\n", 1, 0); else &#123; dfs(r, -1, 0, 0, 0); printf("%d %d\n", ans1, ans2); for (int i = 1; i &lt;= n; i++) &#123; used[i] = 0; in[i] = 0; G[i].clear(); cost[i].clear(); &#125; &#125; &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>杭电多校</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 1 1001 Blank]]></title>
    <url>%2F2019%2F07%2F27%2F2019-Multi-University-Training-Contest-1-1001%2F</url>
    <content type="text"><![CDATA[HDU 6578 Blank题意： 给定1,N 的位置，每个位置可以填1,2,3,4其中一个，给m个区间[l,r] x ，限制[l,r]区间内只有x种不同的数。题解： n非常小，只有100，可以直接用数组枚举上一个数出现的位置，每个位置暴力填就行了。直接$O(n^4)$会T，。，必须要削常数。可以发现出现是什么数本身不重要，只和位置有关。然后最大的那个位置，一定是你要填的这个pos-1,所以dp空间可以优化一维，dp[i][j][k],代表排序后位置分别是i&lt;j&lt;k&lt;pos-1，然后枚举的状态也是i&lt;j&lt;k&lt;pos-1 ，对于限制条件，判断一下状态合不合法就行了。对于某个pos到了[l,r] x,r的位置,判断一下就行了，这个不影响复杂度。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;unordered_map&gt;#include&lt;unordered_set&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;(x)&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a, b) memset(a,b,sizeof(a));const long long mod = 998244353;const int maxn = 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif // ONLIN_JUDGE&#125;LL dp[105][105][105][2];struct node &#123; int l, r, x; bool operator&lt;(node &amp;t) const &#123; if (r == t.r)return l &lt; t.l; return r &lt; t.r; &#125;&#125; dat[maxn];int n, m;void check(LL &amp;x) &#123; x %= mod;&#125;int main() &#123; f(); int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d", &amp;dat[i].l, &amp;dat[i].r, &amp;dat[i].x); dat[i].l += 3; dat[i].r += 3; &#125; dp[0][1][2][1] = 1; sort(dat + 1, dat + m + 1); int l = 1, p = 0; for (int pos = 4; pos &lt;= n + 3; pos++, p = !p) &#123; for (int i = 0; i &lt;= pos - 4; i++) &#123; for (int j = i + 1; j &lt;= pos - 3; j++) &#123; for (int k = j + 1; k &lt;= pos - 2; ++k) &#123; int flag = 0, temp = l; while (temp &lt;= m &amp;&amp; pos - 1 == dat[temp].r) &#123; if (dat[temp].x == 1 &amp;&amp; dat[temp].l &lt;= k) &#123; flag = 1; &#125; if (dat[temp].x == 2 &amp;&amp; (dat[temp].l &lt;= j || dat[temp].l &gt; k)) &#123; flag = 1; &#125; if (dat[temp].x == 3 &amp;&amp; (dat[temp].l &lt;= i || dat[temp].l &gt; j))flag = 1; if (dat[temp].x == 4 &amp;&amp; dat[temp].l &gt; i)flag = 1; temp++; &#125; if (flag) &#123; dp[i][j][k][!p] = 0; continue; &#125; dp[j][k][pos - 1][p] += dp[i][j][k][!p]; check(dp[j][k][pos - 1][p]); dp[i][k][pos - 1][p] += dp[i][j][k][!p]; check(dp[i][j][pos - 1][p]); dp[i][j][pos - 1][p] += dp[i][j][k][!p]; check(dp[i][j][pos - 1][p]); dp[i][j][k][p] += dp[i][j][k][!p]; check(dp[i][j][k][p]); dp[i][j][k][!p] = 0; &#125; &#125; &#125; while (l &lt;= m &amp;&amp; dat[l].r == pos - 1)l++; &#125; LL ans = 0; for (int i = 0; i &lt;= n + 3; i++) &#123; for (int j = i + 1; j &lt;= n + 3; j++) &#123; for (int k = j + 1; k &lt;= n + 3; ++k) &#123; int flag = 0, temp = l; while (temp &lt;= m) &#123; if (dat[temp].x == 1 &amp;&amp; dat[temp].l &lt;= k) &#123; flag = 1; &#125; if (dat[temp].x == 2 &amp;&amp; (dat[temp].l &lt;= j || dat[temp].l &gt; k)) &#123; flag = 1; &#125; if (dat[temp].x == 3 &amp;&amp; (dat[temp].l &lt;= i || dat[temp].l &gt; j))flag = 1; if (dat[temp].x == 4 &amp;&amp; dat[temp].l &gt; i)flag = 1; temp++; &#125; if (flag) &#123; dp[i][j][k][!p] = 0; continue; &#125; ans = (ans + dp[i][j][k][!p] % mod) % mod; dp[i][j][k][!p] = 0; &#125; &#125; &#125; printf("%lld\n", ans); &#125; return 0;&#125;/*61 0410 0104857611 0419430420 044459512330 068215596540 0382013690 */]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>杭电多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单调栈和单调队列]]></title>
    <url>%2F2019%2F07%2F26%2F%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[理解单调栈和单单调队列之前，要明白一种技巧，叫做尺取法。 尺取法尺取法，两个位置，一个是l，一个r,r一位位的左移，l根据条件左移。比如POJ 3061求最大连续字串和不超过sl r初始化为0,r左移，总和加上r位置的值，如果总和一旦大于s,l开始左移，直到满足[l,r]区间的总和小于s，这种通过l,r反复推进的方法，就叫尺取法。 细心的人可以发现，这种方法，求结果一定要满足，右边一个位置跨过r到l一定是不合法的的情况。 单调栈其实这个和尺取法关系不大。。。。单调栈,用于求最左边（右边）的第一个满足某种具有单调性质条件（比如大于，小于）的位置。距离，求第一个大于的位置。求大于，将不大于的数全部加入单调栈里面，保证栈单调递减，（下面距离栈中存的是小标,注意区分值和下标）假设有1 3 5 2 1 4 7 6一开始栈为空，将第一个数位置加进去，此时栈中有下标1到第二个数 3 ，栈顶 位置的值 小于3弹出，赋值位置右边第一个大于他的数下标是2，然后栈为空，将2号位置加入栈，依次类推.到5 弹出下标2 加入下标3,到 2 因为栈顶位置的值大于2不弹出，直到4 弹出值2,1，不弹出5。当前值比栈顶的数大，弹出栈顶的值，并赋值，否则加入栈。 单调队列单调队列和尺取法用点像，和单调栈也差距不大。总结来说，位置尺取，队列单调，就想尺取法和单调栈的结合体。例子 HDU 3530按题目来讲： 查寻区间最大最小值之差在[m,k]之间的最大长度。现按照尺取的方法来：不断移动，l，r,虽然从在r右边跨过r 到l 最大最小值之差绝对是大于等于[r,l]之间的,但是最大最小不可能一直是端点，可能[r,l]之间存在比r,l大或者小的值。那么该如何处理呢，单调栈可以保存一个单调的子序列，我们是否能和他一样保存[l,r],的单增子序列呢？很显然是可以的。因为我们的[l,r]有两端，所以用栈是肯定不行的，那么就只能用双端队列。我们建立两个双端队列，一个保存[l,r]递增的子序列，一个保存[l,r]递减的子序列，那么递减队列中第一个值保存的就是[l,r]区间的最大值，递增的就是最小值。那么假设[l,r] 区间的最大值和最小值不满足条件了，要尺取就要移动l,怎么移动？我们要改变最大最小值。改变哪里一个？肯定是离r最远的那一个，我们单调队列保存的下标，直接把l移动到两个队列队首，最小的下标+1,然后弹出队首，就相当于找到了新[l,r]最大（最小）值 (因为我们队列是单调的，弹出了最大（最小）值就相当于找到了次大（次小）值，在新区间就没有比他小的了 ) 然后，一直循环直到满足条件为止。单增队列就是队尾进，每次和单调栈一样保证队列中是单调的，队首永远都是最小的或者最大的 HDU 3530 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;struct deq &#123; static const int start = maxn * 2; int dat[start * 2]; int l = start; int r = start; void push_front(int x) &#123; dat[l--] = x; &#125; void pop_front() &#123; l++; &#125; int front() &#123; return dat[l + 1]; &#125; void push_back(int x) &#123; dat[++r] = x; &#125; void pop_back() &#123; r--; &#125; int back() &#123; return dat[r]; &#125; int size() &#123; return r - l; &#125; void clear() &#123; r = l = start; &#125; bool empty() &#123; return r == l; &#125;&#125;;deque&lt;int&gt; dq, dq2;int n, m, k;int a[maxn];int main() &#123; f(); while (~scanf("%d%d%d", &amp;n, &amp;m, &amp;k)) &#123; int ans = 0; dq.clear(); dq2.clear(); int pos = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); // 大的弹出所以最前面是最小的 while (dq.size() &gt; 0 &amp;&amp; a[dq.back()] &gt; a[i]) &#123; dq.pop_back(); &#125; dq.push_back(i); while (dq2.size() &gt; 0 &amp;&amp; a[dq2.back()] &lt; a[i]) &#123; dq2.pop_back(); &#125; dq2.push_back(i); while (a[dq2.front()] - a[dq.front()] &gt; k) &#123; if (dq2.front() &lt; dq.front()) &#123; pos = dq2.front(); dq2.pop_front(); &#125; else &#123; pos = dq.front(); dq.pop_front(); &#125; &#125; if (dq2.size() &amp;&amp; dq.size() &amp;&amp; a[dq2.front()] - a[dq.front()] &gt;= m) &#123; ans = max(ans, i - pos); &#125; &#125; printf("%d\n", ans); &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125;/*54 */ 友情提示：最好别用 std 里面的栈和队列，太慢了进阶题：2019牛客暑期多校训练营（第三场）F Planting Trees题解 ： 2019牛客暑期多校训练营（第三场）F Planting Trees]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
        <tag>巧解</tag>
        <tag>笔记</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营（第三场）F Planting Trees]]></title>
    <url>%2F2019%2F07%2F26%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5(%E7%AC%AC%E4%B8%89%E5%9C%BA)F%2F</url>
    <content type="text"><![CDATA[2019牛客暑期多校训练营（第三场）F Planting Trees题意: 一个$N \ast N$ 的矩阵，问最大值和最小值大小差距不超过$M$的最大子矩阵多大。题解: 题目明示你要使用$O(N^3)$的杂度,暴力枚举子矩阵高度$x$，做一个预处理，把$a[i][j]$到$a[i+x][j]$的最大最小值处理出来，压缩成一行，然后做一次求区间最大值和最小值差值不超过$M$的区间最大长度。不懂单调队列的可以看看 单调栈和单调队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include "stdio.h"#include "ctype.h" #define max(a, b) a&gt;b?a:b#define min(a, b) a&lt;b?a:bconst int maxn = 5e2 + 5; struct deq &#123; static const int start = maxn * 2; int dat[start * 2]; int l = start; int r = start; void push_front(int x) &#123; dat[l--] = x; &#125; void pop_front() &#123; l++; &#125; int front() &#123; return dat[l + 1]; &#125; void push_back(int x) &#123; dat[++r] = x; &#125; void pop_back() &#123; r--; &#125; int back() &#123; return dat[r]; &#125; int size() &#123; return r - l; &#125; void clear() &#123; r = l = start; &#125; bool empty() &#123; return r == l; &#125;&#125;; deq dqmx, dqmi; template&lt;typename T&gt;void read(T &amp;w) &#123; //读入 char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar()))w = w * 10 + (c &amp; 15);&#125; int n, k;int a[maxn][maxn];int ans = 0;int mi[maxn][maxn];int mx[maxn][maxn]; int main() &#123; int T; read(T); while (T--) &#123; read(n); read(k); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; read(a[i][j]); &#125; &#125; ans = 0; for (int x = 1; x &lt;= n; x++) &#123; for (int i = n; i &gt;= x; i--) &#123; int pos = 0; dqmx.clear(); dqmi.clear(); for (int j = 1; j &lt;= n; j++) &#123; if (x == 1) &#123; mx[i][j] = a[i][j]; mi[i][j] = a[i][j]; &#125; else &#123; mx[i][j] = max(mx[i - 1][j], a[i][j]); mi[i][j] = min(mi[i - 1][j], a[i][j]); &#125; int tmi = mi[i][j], tmx = mx[i][j]; if (tmx - tmi &gt; k) &#123; dqmi.clear(); dqmx.clear(); pos = j; &#125; else &#123; while (dqmi.size() &amp;&amp; mi[i][dqmi.back()] &gt; tmi) &#123; dqmi.pop_back(); &#125; dqmi.push_back(j); while (dqmx.size() &amp;&amp; mx[i][dqmx.back()] &lt; tmx) &#123; dqmx.pop_back(); &#125; dqmx.push_back(j); while (mx[i][dqmx.front()] - mi[i][dqmi.front()] &gt; k) &#123; if (dqmx.front() &lt; dqmi.front()) &#123; pos = dqmx.front(); dqmx.pop_front(); &#125; else &#123; pos = dqmi.front(); dqmi.pop_front(); &#125; &#125; ans = max(ans, x * (j - pos)); &#125; &#125; &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>牛客暑期多校训练营</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 1 1012 Sequence]]></title>
    <url>%2F2019%2F07%2F25%2F2019-Multi-University-Training-Contest-1-1012%2F</url>
    <content type="text"><![CDATA[2019 Multi-University Training Contest 1HDU 6589 Sequence果然不看大佬博客不会写题。顺手把板子也扒了。题解: x 只有 1 2 3三种情况。直接观察前缀.可以发现当 x=1 的时候 $c_1$表示 1出现的个数 a[i]=\sum_{j=0}^{i}C_{c_1-1+j}^{j} * a[i-j]预理出 $C[j]=C_{c_1-1+j}^{j}$上式就变成了 a[i]=\sum_{j=0}^{i}C[j] * a[i-j]是不是绝对上述这个式子非常眼熟，就是卷积中的一项。。。发现了这个，就是一个组合数加个NTT当x=2的时候就把数组分奇数项和偶数项求一个上式当x=3的时候就求3个实际上，只要改一下$c[j]$把按照x=1的求一下x=2c[j]=j%2==0&gt;c[j/2]:0x=3``c[j]=j%3==0?c[j/3]:0123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 998244353;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;const double PI = acos(-1);#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;int t;int n, m;LL a[maxn];int c[maxn];LL b[maxn];const int Comb_Maxn = 1e6 + 10;LL Fac_inv[Comb_Maxn];LL Fac[Comb_Maxn];inline void Comb_init() &#123; Fac_inv[0] = Fac[0] = 1; Fac_inv[1] = 1; for (int i = 1; i &lt; Comb_Maxn; i++) Fac[i] = Fac[i - 1] * (LL) i % mod; for (int i = 2; i &lt; Comb_Maxn; i++) Fac_inv[i] = (LL) (mod - mod / i) * Fac_inv[mod % i] % mod; for (int i = 1; i &lt; Comb_Maxn; i++) Fac_inv[i] = Fac_inv[i - 1] * Fac_inv[i] % mod;&#125;LL Comb(int n, int m) &#123; if (m &gt; n || m &lt; 0 || n &lt; 0)return 0; return Fac[n] * Fac_inv[m] % mod * Fac_inv[n - m] % mod;&#125;typedef LL ll;const int N = maxn;struct NumberTheoreticTransform &#123; int pow2(int x) &#123; int res = 1; while (res &lt; x) res &lt;&lt;= 1; return res; &#125; inline LL pow_mod(ll x, int n) &#123; ll res; for (res = 1; n; n &gt;&gt;= 1, x = x * x % mod) if (n &amp; 1) res = res * x % mod; return res; &#125; inline int add_mod(int x, int y) &#123; x += y; return x &gt;= mod ? x - mod : x; &#125; inline int sub_mod(int x, int y) &#123; x -= y; return x &lt; 0 ? x + mod : x; &#125; void NTT(LL a[], int n, int op) &#123; for (int i = 1, j = n &gt;&gt; 1; i &lt; n - 1; ++i) &#123; if (i &lt; j) swap(a[i], a[j]); int k = n &gt;&gt; 1; while (k &lt;= j) &#123; j -= k; k &gt;&gt;= 1; &#125; j += k; &#125; for (int len = 2; len &lt;= n; len &lt;&lt;= 1) &#123; LL g = pow_mod(3, (mod - 1) / len); for (int i = 0; i &lt; n; i += len) &#123; LL w = 1; for (int j = i; j &lt; i + (len &gt;&gt; 1); ++j) &#123; LL u = a[j], t = 1ll * a[j + (len &gt;&gt; 1)] * w % mod; a[j] = (u + t) % mod, a[j + (len &gt;&gt; 1)] = (u - t + mod) % mod; w = 1ll * w * g % mod; &#125; &#125; &#125; if (op == -1) &#123; reverse(a + 1, a + n); LL inv = pow_mod(n, mod - 2); for (int i = 0; i &lt; n; ++i) a[i] = 1ll * a[i] * inv % mod; &#125; &#125; void mul(LL A[], LL B[], int Asize, int Bsize) &#123; int n = pow2(Asize + Bsize - 1); for (int i = Asize; i &lt; n; ++i) A[i] = 0; for (int i = Bsize; i &lt; n; ++i) B[i] = 0; NTT(A, n, 1); NTT(B, n, 1); for (int i = 0; i &lt; n; ++i) &#123; A[i] = 1ll * A[i] * B[i] % mod; B[i] = 0; &#125; NTT(A, n, -1); return; &#125;&#125; ntt;template&lt;typename T&gt;void read(T &amp;w) &#123; //读入 char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar()))w = w * 10 + (c &amp; 15);&#125;int main() &#123; f(); read(t); Comb_init(); while (t--) &#123; read(n); read(m); for (int i = 0; i &lt; n; i++) &#123; read(a[i]); &#125; c[0] = c[1] = c[2] = c[3] = 0; while (m--) &#123; int x; scanf("%d", &amp;x); c[x]++; &#125; if (c[1] &gt; 0) &#123; for (int i = 0; i &lt; n; i++) &#123; b[i] = Comb(c[1] + i - 1, i); &#125; ntt.mul(a, b, n, n); &#125; if (c[2] &gt; 0) &#123; for (int i = 0; i &lt; n; i += 2) &#123; b[i] += Comb(c[2] + i / 2 - 1, i / 2); b[i + 1] = 0; &#125; ntt.mul(a, b, n, n); &#125; if (c[3] &gt; 0) &#123; for (int i = 0; i &lt; n; i += 3) &#123; b[i] = Comb(c[3] + i / 3 - 1, i / 3); &#125; ntt.mul(a, b, n, n); &#125; LL ans = 0; for (int i = 0; i &lt; n; i++) &#123; ans ^= (i + 1LL) * a[i]; &#125; printf("%lld\n", ans); &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>杭电多校</tag>
        <tag>FFT/NTT/FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 2 1012 Longest Subarray]]></title>
    <url>%2F2019%2F07%2F24%2F2019-Multi-University-Training-Contest-2-1012%2F</url>
    <content type="text"><![CDATA[Longest Subarray HDU 6602题意: n个数，求区间内 数的个数要么为0个要么大于等于k个的长度最长是多少。题解：解法一： 不完美算法，每次枚举计算区间内所有数的个数有多少个，如果没有数的个数小于k的就更新答案,如果有就把这几个数标记，然后这些数会把原本的数组分成几段，然后在这几段中继续求。理论上这种写法会超时，实际上就是超时了，所以我们把分的次数限定一下，如果分了超过30次就直接跳出。这样理论上没有把所有可能性跑到，但是这种数据很难得，所以只要没有专门卡这种数据就能过。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;int n, c, k;int a[maxn];int b[maxn];int pos = 0;int v[maxn];int ans = 0;int de[maxn];int dfs(int l, int r, int dep) &#123; if (dep &gt; 30)return 0; if (r &lt; l)return 0; if (r - l + 1 &lt; k)return 0; for (int i = l; i &lt;= r; i++) &#123; b[a[i]] = 0; &#125; pos = 0; for (int i = l; i &lt;= r; i++) &#123; if (b[a[i]] == 0) &#123; v[pos++] = a[i]; &#125; b[a[i]]++; &#125; int flag = 0; for (int i = 0; i &lt; pos; i++) &#123; if (b[v[i]] &gt;= k) &#123; b[v[i]] = 1; &#125; else &#123; b[v[i]] = 0; flag = 1; &#125; &#125; for (int i = l; i &lt;= r; i++) &#123; if (b[a[i]] == 0)de[i] = 0; else de[i] = 1; &#125; if (flag == 0) &#123; ans = max(ans, r - l + 1); return 0; &#125; int L = -1, R = -1; for (int i = l; i &lt;= r; i++) &#123; if (de[i] &amp;&amp; L == -1) &#123; L = i; &#125; if (de[i] == 0 &amp;&amp; L != -1) &#123; R = i - 1; dfs(L, R, dep + 1); L = -1; &#125; &#125; if (L != -1 &amp;&amp; L &lt;= r) &#123; dfs(L, r, dep + 1); &#125;&#125;int main() &#123; f(); while (~scanf("%d%d%d", &amp;n, &amp;c, &amp;k)) &#123; ans = 0; for (int i = 1; i &lt;= n; i++)scanf("%d", &amp;a[i]); dfs(1, n, 0); printf("%d\n", ans); &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125; 题解二： 枚举区间r,线段树查找最小的l。能够选的位置一定是分成两段。然后把从 r到l 少于k个数字不合法 区间 -1，变成合法的时候+1，大于等于0的区间中最小下标就是答案。假设，k=3每个数字一定是这样，举个例子k=21 4 1 4 2 1 1首先到 r=1 a[r]=1 ,没有超过 k个, 把 最开始到 r 全部减 1 -1查询 [1,r] 没有大于等于0的位置，不更新答案r=2 a[r]=4 ,个数少于 k,[1,r] -1 -2 -1[1,r] 没有大于0 的位置 ,不更新r=3 a[r]=1 ,大于等于 k 个，把当前位置和前面a[r]位置之间 -1, 也就是 [2,3] -1 ,然后超过k个的位置 [1,1] +1-1 -2 -1还是没有0的位置 不更新r=4 a[r]=4，同上[3,4] -1 ，[1,2] +10 -1 -2 -1最小0位置为1 pos=1 更新答案 ans=max(ans,r-pos+1)后面依次类推123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;int n, c, k;int a[maxn];int ans = 0;int last[maxn];int b[maxn];int dat[maxn &lt;&lt; 2];int lazy[maxn &lt;&lt; 2];int lastk[maxn], pre[maxn], nxt[maxn];void build(int l, int r, int k) &#123; if (r == l) &#123; dat[k] = 0; lazy[k] = 0; &#125; else &#123; build(lson); build(rson); dat[k] = 0; lazy[k] = 0; &#125;&#125;void push_down(int l, int r, int k) &#123; if (r == l)dat[k] += lazy[k]; else &#123; lazy[chl] += lazy[k]; lazy[chr] += lazy[k]; &#125; lazy[k] = 0; if (r != l)dat[k] = max(dat[chl] + lazy[chl], dat[chr] + lazy[chr]);&#125;void update(int A, int B, int l, int r, int k, int x) &#123;// if (k == 0) &#123;// printf("[%d,%d] %d\n", A, B, x);// &#125; push_down(l, r, k); if (A &gt; r || B &lt; l)return; else if (A &lt;= l &amp;&amp; r &lt;= B) &#123; lazy[k] += x; &#125; else &#123; update(A, B, lson, x); update(A, B, rson, x); dat[k] = max(dat[chl] + lazy[chl], dat[chr] + lazy[chr]); &#125;&#125;int query(int A, int B, int l, int r, int k) &#123; push_down(l, r, k); if (A &gt; r || B &lt; l || dat[k] &lt; 0)return inf; else if (r == l &amp;&amp; A &lt;= l &amp;&amp; r &lt;= B) &#123; return l; &#125; else &#123; if (B &lt;= mid || dat[chl] + lazy[chl] &gt;= 0) &#123; return query(A, B, lson); &#125; else return query(A, B, rson); &#125;&#125;int queryval(int A, int B, int l, int r, int k) &#123; push_down(l, r, k); if (A &gt; r || B &lt; l)return -inf; else if (A &lt;= l &amp;&amp; r &lt;= B) &#123; return dat[k]; &#125; else &#123; return max(queryval(A, B, lson), queryval(A, B, rson)); &#125;&#125;int main() &#123; f(); while (~scanf("%d%d%d", &amp;n, &amp;c, &amp;k)) &#123; ans = 0; build(1, n, 0); for (int i = 0; i &lt;= c; i++)b[i] = last[i] = lastk[i] = pre[i] = nxt[i] = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); nxt[last[a[i]]] = i; pre[i] = last[a[i]]; if (b[a[i]] + 1 &gt;= k) &#123; update(pre[i] + 1, i, 1, n, 0, -1); update(pre[lastk[a[i]]] + 1, lastk[a[i]], 1, n, 0, 1); lastk[a[i]] = nxt[lastk[a[i]]]; &#125; else if (b[a[i]] == 0) &#123; update(1, i, 1, n, 0, -1); lastk[a[i]] = i; pre[i] = 0; &#125; else if (b[a[i]] + 1 &lt; k) &#123; update(last[a[i]] + 1, i, 1, n, 0, -1); &#125; last[a[i]] = i; ans = max(ans, i - query(1, i, 1, n, 0) + 1); b[a[i]]++; &#125; if (k == 1)ans = n; else if (k == 0)ans = 0; printf("%d\n", ans); &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>杭电多校</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营（第二场）J Subarray]]></title>
    <url>%2F2019%2F07%2F23%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5(%E7%AC%AC%E4%BA%8C%E5%9C%BA)J%2F</url>
    <content type="text"><![CDATA[2019牛客暑期多校训练营（第二场）J Subarray题意：长度为$1e9$的区间$A$下标为$[0,1e9-1]$,数输入$n$个区间，$[l_i,r_i]$区间类的值为1，其余为-1，问有多少区间和大于0.题解：看了来自大佬的博客，能够产生贡献的点最多只有$3e7$个,意思是先求一个前缀和，然后画成图应该是这样。最差就是这样了，能够有影响的就只有这$3e7$个点 (可能是分段的) ，那么问题来了，怎么求出这$3e7$个点。来自大佬的博客为什么呢？在大佬眼里很简单，我画了个图才理解。显然前面一个的$f[i]$加后面$g[i+1]$比两个区间之间的长度大就事连在一起的。(我果然太菜了)然后处理完之后，就相当于处理一个这样的前缀和，求所有位置有几个在他前面前缀比他小。如果范围小一点就用树状数组求一下就没了，$3e7log(3e7)$显然超时了。看到这个前缀和，前后项最大只差了$1$,上下界最大差值不超过$3e7$,这再做个前缀和 sum 。用一个数组表示一个数字出现的次数，然后$sum[m]=sum[m-1]+b[m]$,更新前缀和,答案就是$ans+=sum[m-1]$。中间有一些细节要处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;typedef long double ld;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;(x)&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define mem(a, b) memset(a,b,sizeof(a));const long long mod = 1e9 + 7;const int maxn = 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;void fin() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif // ONLINE_JUDGE&#125;#ifndef ONLINE_JUDGEclock_t start = clock();#endif // ONLINE_JUDGEint n;LL l[maxn], r[maxn];LL f[maxn], g[maxn];struct node &#123; LL l, r, x;&#125; dat[maxn * 5];LL sum[maxn * 30 + 20], b[maxn * 30 + 20];int main() &#123; fin(); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%lld%lld", &amp;l[i], &amp;r[i]); &#125; f[1] = r[1] - l[1] + 1; for (int i = 2; i &lt;= n; i++) &#123; f[i] = max(0LL, f[i - 1] - (l[i] - r[i - 1] - 1)) + r[i] - l[i] + 1; &#125; g[n] = r[n] - l[n] + 1; for (int i = n - 1; i &gt;= 1; --i) &#123; g[i] = max(0LL, g[i + 1] - (l[i + 1] - r[i] - 1)) + r[i] - l[i] + 1; &#125; int i = 1; LL ans = 0; while (i &lt;= n) &#123; int j = i + 1; LL mi = 0, mx = 0, pos = 0; //mi 下界,mx 上界 while (j &lt;= n &amp;&amp; g[j] + f[j - 1] &gt;= l[j] - r[j - 1] - 1) &#123; j++; &#125; j--; int t = i, num = 1; // [i,j] 区间是相互影响的 for (; t &lt;= j; t++) &#123; // 把每一段处理到 dat里面 if (num == 1)dat[num].l = 0; else if (l[t] - r[t - 1] == 1) dat[num].l = pos + 1; else dat[num].l = pos; pos += r[t] - l[t] + 1; dat[num].r = pos; dat[num++].x = 1; mx = max(mx, pos); if (t != j) &#123; dat[num].r = pos - 1; pos -= l[t + 1] - r[t] - 1; dat[num].l = pos + 1; dat[num++].x = 0; // 0 表示下降 ,1 表示上升 mi = min(pos, mi); &#125; else &#123; dat[num].r = pos - 1; dat[num].l = max(mi, pos - ((int) 1e9 - 1 - r[t])); dat[num++].x = 0; &#125; &#125; dat[0].r = min(mx, l[i]); dat[0].l = 1; dat[0].x = 0; for (int k = 0; k &lt;= mx - mi + 200; k++)b[k] = sum[k] = 0; assert(mx - mi &lt; maxn * 30); for (int k = 0; k &lt; num; ++k) &#123; dat[k].l += -mi; //全部向上移动一个下届，保证最小值等于0 dat[k].r += -mi; if (dat[k].x == 1) &#123; for (int m = dat[k].l; m &lt;= dat[k].r; ++m) &#123; b[m]++; sum[m] = sum[m - 1] + b[m]; if (m &gt;= 1)ans += sum[m - 1]; &#125; &#125; else &#123; LL tmp = 0; if (dat[k].l &gt; 0)tmp = sum[dat[k].l - 1]; for (int m = dat[k].l; m &lt;= dat[k].r; ++m) &#123; if (m &gt;= 1)ans += tmp; tmp = sum[m]; //如果是下降的 ，从小往上处理是不能把当前更新加进去因当前这个在他后面 b[m]++; sum[m] = sum[m - 1] + b[m]; &#125; &#125; &#125; i = j + 1; &#125; printf("%lld\n", ans);#ifndef ONLINE_JUDGE cout &lt;&lt; "RUNTIME:" &lt;&lt; (1.0 * clock() - start) / 1000 &lt;&lt; "ms" &lt;&lt; endl;#endif // ONLINE_JUDGE return 0;&#125; 给几组数据你去试试 1234567891011121314151625 912 1733 56 67 933 58 89 101999999998 999999999 123456720076494]]></content>
      <categories>
        <category>ACM</category>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>牛客暑期多校训练营</tag>
        <tag>巧解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客多校--待补]]></title>
    <url>%2F2019%2F07%2F22%2F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1--%E5%BE%85%E8%A1%A5%2F</url>
    <content type="text"><![CDATA[第一场 D Parity of Tuples \begin{aligned} Count(x)&=\sum_{i=1}^{n}\prod_{j=1}^{m}{[a_{i,j}\&x]}\\ &= \end{aligned}第一场 G Substrings 2第二场 G Polygons D Kth Minimum Clique]]></content>
  </entry>
  <entry>
    <title><![CDATA[NTT快速数论变换]]></title>
    <url>%2F2019%2F07%2F22%2FNTT%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[NTT理解了FFT的原理，NTT也差不多。FTT是用复数实现变换，而NTT是用取模意义实现。找出一个g,和开一个模数p,g是p的原根。 原根 $0&lt;i&lt;P,0&lt;j&lt;P,1&lt;g&lt;P\ g^i(mod\ p)\ne g^j(mod\ p)$ 这样在FTT里面的$w_n^1\equiv g^{\frac{p-1}{n}}$。显然:$(g^\frac{p-1}{n})^n=g^{p-1}=1(mod\ p)$$g^\frac{p-1}{n} * g^\frac{p-1}{n} = g^{2\frac{p-1}{n}}$同样的 FFT 里面用到的几个原根性质，他都有。你可以抽象为，把一个长度为 P 线段，每次走一格，走了N次回来了。 所以一开始要求的几个点值是${A(1),A(g^{\frac{p-1}{n}}),\cdots,A(g^{\frac {p-1}{n}{n-1}})}$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//ntt#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int N=(1&lt;&lt;18)+5, INF=1e9;const double PI=acos(-1);inline int read()&#123; char c=getchar();int x=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125; ll P=1004535809;ll Pow(ll a, ll b,ll P) &#123; ll ans=1; for(; b; b&gt;&gt;=1, a=a*a%P) if(b&amp;1) ans=ans*a%P; return ans;&#125;struct NumberTheoreticTransform &#123; int pow2(int x) &#123; int res = 1; while (res &lt; x) res &lt;&lt;= 1; return res; &#125; inline LL pow_mod(ll x, int n) &#123; ll res; for (res = 1; n; n &gt;&gt;= 1, x = x * x % mod) if (n &amp; 1) res = res * x % mod; return res; &#125; inline int add_mod(int x, int y) &#123; x += y; return x &gt;= mod ? x - mod : x; &#125; inline int sub_mod(int x, int y) &#123; x -= y; return x &lt; 0 ? x + mod : x; &#125; void NTT(LL a[], int n, int op) &#123; for (int i = 1, j = n &gt;&gt; 1; i &lt; n - 1; ++i) &#123; if (i &lt; j) swap(a[i], a[j]); int k = n &gt;&gt; 1; while (k &lt;= j) &#123; j -= k; k &gt;&gt;= 1; &#125; j += k; &#125; for (int len = 2; len &lt;= n; len &lt;&lt;= 1) &#123; LL g = pow_mod(3, (mod - 1) / len); for (int i = 0; i &lt; n; i += len) &#123; LL w = 1; for (int j = i; j &lt; i + (len &gt;&gt; 1); ++j) &#123; LL u = a[j], t = 1ll * a[j + (len &gt;&gt; 1)] * w % mod; a[j] = (u + t) % mod, a[j + (len &gt;&gt; 1)] = (u - t + mod) % mod; w = 1ll * w * g % mod; &#125; &#125; &#125; if (op == -1) &#123; reverse(a + 1, a + n); LL inv = pow_mod(n, mod - 2); for (int i = 0; i &lt; n; ++i) a[i] = 1ll * a[i] * inv % mod; &#125; &#125; void mul(LL A[], LL B[], int Asize, int Bsize) &#123; int n = pow2(Asize + Bsize - 1); for (int i = Asize; i &lt; n; ++i) A[i] = 0; for (int i = Bsize; i &lt; n; ++i) B[i] = 0; NTT(A, n, 1); NTT(B, n, 1); for (int i = 0; i &lt; n; ++i) &#123; A[i] = 1ll * A[i] * B[i] % mod; B[i] = 0; &#125; NTT(A, n, -1); return; &#125;&#125; f; int n1, n2, m, c[N];ll a[N], b[N];char s1[N], s2[N];int main() &#123; //freopen("in","r",stdin); scanf("%s%s",s1,s2); n1=strlen(s1); n2=strlen(s2); for(int i=0; i&lt;n1; i++) a[i] = s1[n1-i-1]-'0'; for(int i=0; i&lt;n2; i++) b[i] = s2[n2-i-1]-'0'; m=n1+n2-1; f.mul(a, b, m); for(int i=0; i&lt;m; i++) c[i]=a[i]; for(int i=0; i&lt;m; i++) c[i+1]+=c[i]/10, c[i]%=10; if(c[m]) m++; for(int i=m-1; i&gt;=0; i--) printf("%d",c[i]);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>FFT/NTT/FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFT快速傅里叶变换简解]]></title>
    <url>%2F2019%2F07%2F20%2FFFT%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E7%AE%80%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[概述FTT： 快速傅里叶变换。看起来挺难的，实际上确实挺难的。 用途A=a_0+a_1x+a_2x\cdots +a_nx^nB=b_0+b_1x+b_2x\cdots +b_nx^n求 C_k=\sum_{i+j=k}A_i * B_j也就是上面两个多项式相乘等于下面这个 C=c_0+c_1x+c_2x\cdots +c_{2n}x^{2n}朴素算法一个个乘 $O(n^2)$ 复杂度，FFT能在 $O(nlog(n)$ 的复杂度内解决。 点值这个是多项式 系数表达 A=a_0+a_1x+a_2x\cdots +a_nx^n下面这个是 点值表示法 \{ (x_0,y_0) , (x_1,y_1) , \cdots (x_n,y_n) \}不难看出能用下面这个n+1个不同的点值推出 系数表达式 FFT步骤 加倍次数界求值 将转A B系数表达式，找出 2n+1 个点值,(只需要n+1个点值就能推出一个最高次项为n的表达式，但是，A B相乘后有2n，所以要找出2n+1个值) 逐点相乘 将两个点值相乘获得C 的点值C=\{(x_0 ,A(x_0) * B(x_0)),\cdots,(x_{2n},A(x_{2n}) * B(x_{2n})\} 插值 再用逆变换将C的点值转换成 系数表达式 第一步叫离散傅里叶变换 (DFT) 正式讲解不难看出,如果直接用朴素算法，去求多项式乘积，第一步复杂度 $O(n^2)$,第二步$O(n)$，第三步$O(n^2)$FFT 作用就是优化第一步和第三步，都变成$O(nlog(n))$的复杂度。 在这之前需要知道一个东西叫单位复根 单位复根不具体讲了,讲了你也理解不了。 (其实我没理解)想要具体了解见黑书算法导论P532，我只做简介n次单位复根，$w^n=1$，这个数有恰好n个，具体是啥不重要，我说个简单的理解。复数大家都知道吧。假设有两个复数$z1=a+bi$$z2=c+di$把他们两个乘一下 z2z1=(ac-bd)+(ad+bc)i求一下$z1 z2$他们的长度和角，先求长度 [z1]=\sqrt{a^2+b^2}[z2]=\sqrt{b^2+c^2}[z1z2]=\sqrt{(ac-bd)^2+(ad+bc)^2}=\sqrt{a^2c^2+b^2d^2+a^2d^2+b^2c^2}=\sqrt{(a^2+b^2)(b^2+d^2)}是不是就等于$[z1] * [z2]$然后你代一个数放z1 z2里面 z1=cos(\alpha)+sin(\alpha)iz2=cos(\beta)+sin(\beta) i\begin{aligned} z1z2&=(cos(\alpha) cos(\beta)-sin(\alpha)sin(\beta))+(cos(\alpha)sin(\beta)+sin(\alpha)cos(\beta))i\\ &=cos(\alpha+\beta)+sin(\alpha+\beta)i \end{aligned}看到这应该懂了，复数的乘法性质。 (a_0,\theta_0) * (a_1,\theta_1)=(a_1 * a_0,\theta_0\theta_1)可能你还不知道这意味着啥，但是马上你就懂了假设一个复数，长度为1，角度为\frac{2\pi}{n}，$w_n^1=cos(\frac{2\pi}{n})+sin(\frac{2\pi}n{})i$把他画成成圆就是那么w_n^2=w_n^1 * w_n^1 就相当于在圆上转了一下如下图看到这，后面理解性质就贼简单，你全部想象成在圆上面旋转。但是这些都不重要接下来给你退公式了,假设 A有最高次项为 n-1 \begin{aligned} A&=a_0+a_1x+a_2x^2+\cdots+a_{n-1}x^{n-1}\\ &=(a_0+a_2x^2+\cdots+a_{n-2}x^{n-2})+x(a_1+a_3x^2+\cdots+a_{n-1}x^{n-2}) \end{aligned}可以发现前面一堆和后面一堆很像然后设这$A0 A1$ A0=a_0+a_2x+a_4x^2+\cdots+a_{n-2}x^{n-1}\\ A1=a_1+a_3x+a_5x^2+\cdots+a_{n-1}x^{n-1}这个地方注意，A0,A1 里面的次项是开根号所以是 A=A0(x^2)+xA1(x^2)假设你代入的是一个普通的数，假设是 \{1,x_0,\cdots,x_{n-1}\}，$A(X)=A0(X^2)+xA1(X^2)$ 你还需要求\{A0(1),A0(x_0^2),\cdots,A0(x_{n-1}^2),A1(1),A1(x_0^2),\cdots,A1(x_{n-1}^2)\} ,一共是2n个，两边同时求还是$O(n)$.当你带入复数 \{1,w_n^1,\cdots,w_n^{n-1}\},你可以发现一个神奇的事，要求的数量变少了 \begin{aligned} A&=A0((w_n^k)^2)+w_n^kA1((w_n^k)^2)\\ &=A0(w_n^{2k})+w_n^kA1(w_n^{2k})\\ &=A0(w_{\frac{n}{2}}^k)+w_n^kA1(w_{\frac{n}{2}}^k) \end{aligned}上述公式化简用上了一个公式 w_n^k=w_{\frac{n}{2}}^{\frac{k}{2}} 这个事很显然的事，在单位圆里面，改变这个比例，角度不变 你需要求的数就变成了\{1,w_{\frac{n}{2}}^1,\cdots,w_\frac{n}{2}^{n-1}\}看上去没有减少，实际上你可以发现，其中有一半其实是重复的，这又要立用到一个公式 $w_n^k=w_n^{k+n}$ 很显然，圆转了一圈，我又回来啦 所以就变成了求\{1,w_{\frac{n}{2}}^1,\cdots,w_\frac{n}{2}^{\frac{n-2}{2}}\}举个栗子 解释一下假设 一个 A长度为4 最高次项就是 3 A=a_0+a_1x+a_2x^2+a_3^3x^3求 4 个 点值 \{\{1,A(1)\},\{w_4^1,A(w_4^1)\},\{w_4^2,A(w_4^2)\},\{w_4^3,A(w_4^3)\}\}一开始要求的有 4 个点值 \{A(1),A(w_4^1),A(w_4^2),A(w_4^3)\}通过前面那个转换, 看不懂为啥有个1的 ，注意 $w_n^0=1$ \begin{aligned} A(1)&=A0(1)+1A1(1)\\ A(w_4^1)&=A0(w_2^1)+w_4^1A1(w_2^1)\\ A(w_4^2)&=A0(w_2^2)+w_4^2A1(w_2^2)=A0(1)+w_4^2A1(1)\\ A(w_4^3)&=A0(w_2^3)+w_4^3A1(w_2^3)=A0(w_2^1)+w_4^3A1(w_2^1) \end{aligned}要求的点值就变成了${A0(1),A0(w_2^1),A1(1),A1(w_2^1)}$ 同样是4个， 但是递归下去找每次分成两部分，就相当于折半了，(还是没有理解等会画个图给你看下) 另外还没完，上述还有一个特点: 前面一半和后面一半 很像，没错，还可以优化。这个地方又要用到一个性质. $w_n^{k+\frac{n}{2}}=-w_n^{k}$ 很显然,你在圆里面转了半圈，不就是个相反的了么。。。。 感觉我的证明都是显然证明法,不用在意这些细节由此可以再优化当$k&lt;\frac{n}{2}$ A(w_n^k)=A0(w_{\frac{n}{2}}^k)+w_n^kA1(w_{\frac{n}{2}}^k)当$k&gt;\frac{n}{2}$ A(w_n^k)=A0(w_{\frac{n}{2}}^k)-w_n^{k-\frac{n}{2}}A1(w_{\frac{n}{2}}^k)网上很多写的是A(w_n^{k+\frac{n}{2}})=A0(w_{\frac{n}{2}}^k)-w_n^{k}A1(w_{\frac{n}{2}}^k)，其实是一个意思，哪个好理解你看哪个吧。例子A(w_4^3)=A0(w_2^1)-w_4^1A1(w_2^1)对应上面举得那个具体的例子，你就可以再次优化了。 这个地方看不懂推荐一篇神级大佬的博客 从多项式乘法到快速傅里叶变换 最后再画个图助解一下: 至此算法核心原理全部解释完毕。逆运算从点值 转换成系数表达式 ，你把矩阵写出来，就相当于乘了一个逆矩阵。就相当于再求一次DFT ，只不过 $w_n^k$ 变成他的逆，w_n^k * w_n^{-k}=1，加个负号就行了。代码网上一大堆我这里贴个我的，测试题目51Nod 大数乘法2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;const double eps = 0.5;const double pi = acos(-1.0);struct complexx &#123; double x, y; complexx(double xx = 0, double yy = 0) &#123; x = xx, y = yy; &#125; void put() &#123; printf("[x=%f y=%f]\n", x, y); &#125;&#125; a[maxn], b[maxn];complexx operator+(complexx a, complexx b) &#123; return complexx(a.x + b.x, a.y + b.y); &#125;complexx operator-(complexx a, complexx b) &#123; return complexx(a.x - b.x, a.y - b.y); &#125;complexx operator*(complexx a, complexx b) &#123; return complexx(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y); &#125;void fft(int len, complexx *a, int o) &#123; if (len == 1) return; complexx a0[(len &gt;&gt; 1) + 3], a1[(len &gt;&gt; 1) + 3]; for (int i = 0; i &lt;= len; i += 2) a0[i &gt;&gt; 1] = a[i], a1[i &gt;&gt; 1] = a[i + 1]; fft(len &gt;&gt; 1, a0, o); fft(len &gt;&gt; 1, a1, o); complexx wn = complexx(cos(2 * pi / len), o * sin(2 * pi / len)), w0 = complexx(1, 0); for (int i = 0; i &lt; (len &gt;&gt; 1); i++, w0 = w0 * wn) &#123; a[i] = a0[i] + w0 * a1[i];// a[i + (len &gt;&gt; 1)] = a0[i] - w0 * a1[i]; //前面说的一个优化 &#125; //不加优化继续跑下去，直接枚举所有 for (int i = (len &gt;&gt; 1); i &lt; len; i++, w0 = w0 * wn) &#123; a[i] = a0[i - (len &gt;&gt; 1)] + w0 * a1[i - (len &gt;&gt; 1)]; &#125;&#125;char s[maxn];int ans[maxn];int main() &#123; f(); scanf("%s", s); int la = strlen(s); for (int i = la - 1; i &gt;= 0; i--)a[i].x = s[la - i - 1] - '0'; scanf("%s", s); int lb = strlen(s); for (int i = lb - 1; i &gt;= 0; i--)b[i].x = s[lb - i - 1] - '0'; int m = la + lb - 2; int len = 1; for (; len &lt;= m; len &lt;&lt;= 1); fft(len, a, 1);//DFT fft(len, b, 1);//DFT for (int i = 0; i &lt;= len; i++) a[i] = a[i] * b[i]; fft(len, a, -1);//IDFT for (int i = 0; i &lt;= m; i++) &#123; ans[i] = (int) (a[i].x / len + eps);//记得除len eps 用来消 浮点误差我用的 0.5 &#125; for (int i = 0; i &lt;= m; i++)ans[i + 1] += ans[i] / 10, ans[i] = ans[i] % 10; if (ans[m + 1])printf("%d", ans[m + 1]); for (int i = m; i &gt;= 0; i--) &#123; printf("%d", ans[i]); &#125; puts("");#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125; 你以为大结局了吗?没有 优化除了前面那个直接再表达式上的优化,，下面还有代码上的优化。递归太慢了，可以换成迭代。另外，这空间变成了nlog(n) ，那个辅助数组优化掉也可以不好.已经理解核心了，后面这个就不用我说了吧。。。。。。是我懒得写了，我18岁我好累 直接贴一个大哥的板子把，找的太多了都不知道是谁的了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//fft#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int N=(1&lt;&lt;18)+5, INF=1e9;const double PI=acos(-1);inline int read()&#123; char c=getchar();int x=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125; struct meow&#123; double x, y; meow(double a=0, double b=0):x(a), y(b)&#123;&#125;&#125;;meow operator +(meow a, meow b) &#123;return meow(a.x+b.x, a.y+b.y);&#125;meow operator -(meow a, meow b) &#123;return meow(a.x-b.x, a.y-b.y);&#125;meow operator *(meow a, meow b) &#123;return meow(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);&#125;meow conj(meow a) &#123;return meow(a.x, -a.y);&#125;typedef meow cd; struct FastFourierTransform &#123; int n, rev[N]; cd omega[N], omegaInv[N]; void ini(int lim) &#123; n=1; int k=0; while(n&lt;lim) n&lt;&lt;=1, k++; for(int i=0; i&lt;n; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1) | ((i&amp;1)&lt;&lt;(k-1)); for(int k=0; k&lt;n; k++) &#123; omega[k] = cd(cos(2*PI/n*k), sin(2*PI/n*k)); omegaInv[k] = conj(omega[k]); &#125; &#125; void fft(cd *a, cd *w) &#123; for(int i=0; i&lt;n; i++) if(i&lt;rev[i]) swap(a[i], a[rev[i]]); for(int l=2; l&lt;=n; l&lt;&lt;=1) &#123; int m=l&gt;&gt;1; for(cd *p=a; p!=a+n; p+=l) for(int k=0; k&lt;m; k++) &#123; cd t = w[n/l*k] * p[k+m]; p[k+m]=p[k]-t; p[k]=p[k]+t; &#125; &#125; &#125; void dft(cd *a, int flag) &#123; if(flag==1) fft(a, omega); else &#123; fft(a, omegaInv); for(int i=0; i&lt;n; i++) a[i].x/=n; &#125; &#125; void mul(cd *a, cd *b, int m) &#123; ini(m); dft(a, 1); dft(b, 1); for(int i=0; i&lt;n; i++) a[i]=a[i]*b[i]; dft(a, -1); &#125;&#125;f; int n1, n2, m, c[N];cd a[N], b[N];char s1[N], s2[N];int main() &#123; //freopen("in","r",stdin); scanf("%s%s",s1,s2); n1=strlen(s1); n2=strlen(s2); for(int i=0; i&lt;n1; i++) a[i].x = s1[n1-i-1]-'0'; for(int i=0; i&lt;n2; i++) b[i].x = s2[n2-i-1]-'0'; m=n1+n2-1; f.mul(a, b, m); for(int i=0; i&lt;m; i++) c[i]=floor(a[i].x+0.5); for(int i=0; i&lt;m; i++) c[i+1]+=c[i]/10, c[i]%=10; if(c[m]) m++; for(int i=m-1; i&gt;=0; i--) printf("%d",c[i]);&#125; 如有错误，望指出。]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>FFT/NTT/FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营（第二场）F MAZE]]></title>
    <url>%2F2019%2F07%2F20%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5(%E7%AC%AC%E4%BA%8C%E5%9C%BA)F%2F</url>
    <content type="text"><![CDATA[2019牛客暑期多校训练营（第二场）F MAZE世界上有种算法不叫做算法，那就是暴力。。。。 C_{2n}^n 是$4e7$，总状态是$4e7$种，然后转移,$O(n)$直接向相邻的状态转移。总复杂度$O(C_{2n}^{n} * n)$。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;(x)&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("dat.in", "r", stdin);#endif // ONLINE_JUDGE&#125;#ifndef ONLINE_JUDGEclock_t start=clock();#endif // ONLINE_JUDGEint n,m;int mp[30][30];LL sum,ans;int ar[15],br[15]; //a b 个表示一个集合int la,lb;void dfs(int num) &#123; //选n位 if(la&gt;n||lb&gt;n)return ; if(la==n&amp;&amp;lb==n) &#123; //如果各选了 n 位就更新答案 ans=max(sum,ans); return ; &#125; else &#123; if(la&lt;n) &#123; LL tmp=0; for(int i=0; i&lt;lb; i++) &#123; //选到 a 集合 tmp+=mp[num][br[i]]; &#125; sum+=tmp; ar[la++]=num; dfs(num+1); ar[--la]; sum-=tmp; &#125; if(lb&lt;n) &#123; LL tmp=0; for(int i=0; i&lt;la; i++) &#123; //选到 b 集合 tmp+=mp[num][ar[i]]; &#125; sum+=tmp; br[lb++]=num; dfs(num+1); br[lb--]; sum-=tmp; &#125; &#125;&#125;int main() &#123; f(); scanf("%d", &amp;n); m = 2 * n; for(int i = 0; i &lt; m; ++i) &#123; for(int j = 0; j &lt; m; ++j) &#123; scanf("%d", &amp;mp[i][j]); &#125; &#125; dfs(0); printf("%lld\n",ans);#ifndef ONLINE_JUDGE debug((1.0*(clock()-start)/1000));#endif // ONLINE_JUDGE return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>牛客暑期多校训练营</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第一场) C Euclidean Distance]]></title>
    <url>%2F2019%2F07%2F19%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%B8%80%E5%9C%BA%EF%BC%89C%2F</url>
    <content type="text"><![CDATA[2019牛客暑期多校训练营（第一场）C Euclidean Distance题解: 拉格朗日乘子法，首先引入拉格朗日乘子得出公式 f(x)=\sum_{i=1}^{n}(p_i-a_i)^2+2*\lambda(\sum_{i=0}^{n}p_i-1)这个应该看的懂，然后引入对偶变成成\max_\lambda f(\lambda)其中 f(\lambda)=\min_{p_i\geq0}\sum_{i=1}^{n}(p_i-a_i)^2+2*\lambda(\sum_{i=0}^{n}p_i-1)然后化成叉姐给的题解里面的公式就行了 f(\lambda)=\min_{p_i\geq0}\sum_{i=1}^{n}(p_i-(a_i-\lambda))^2+\lambda(\sum_{i=0}^{n}(a_i^2-(a_i-\lambda)^2)-2\lambda再然后，我就不会了qaq后来看了一下别的大佬的博客，突然感觉可以直接理解一下，假设所有的$p_i=0$,$f(x)$就等于$a_i^2$的和 题目要求的是 在 q_i\geq0,\quad \sum_{i=0}^{n}q_i=1条件下求 $f(x)=\sum_{i=1}^{n}(p_i-a_i)^2$ 。相当于分配$p_i$ 的值，去让 $(p_i-a_i)^2$ 变小。根据二次函数的性质，自变量 $x$ 越大因变量 $y$ 化越快。所以先分配给最大肯定更优啊，直接贪心下去啊。最后肯定是变成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("dat.in", "r", stdin);#endif // ONLIN_JUDGE&#125;LL a[maxn];int n;LL m;int main() &#123; while(~scanf("%d%lld",&amp;n,&amp;m)) &#123; for(int i=1; i&lt;=n; i++) &#123; scanf("%lld",&amp;a[i]); &#125; sort(a+1,a+n+1,greater&lt;int&gt;()); LL r=m; //p[i]的总分配价值是 1 也就是 m/m LL pos=1; // pos 标记能够分配p[i] 到第 pos 个 while(pos&lt;n) &#123; if(r&lt;(a[pos]-a[pos+1])*pos)break; r-=(a[pos]-a[pos+1])*pos; pos++; &#125; // 最终前pos个的值 都会是a[pos]-r/pos,将他扩大pos 倍, 然后再乘以 pos 个 LL ans=(a[pos]*pos-r)*(a[pos]*pos-r)*pos; //因为最后的值可能是 1/pos,所以把分子分母同时乘以pos个 LL b=m*m*pos*pos; // 因为求的是距离的平方 分母 就是 m*m*pos*pos for(int i=pos+1; i&lt;=n; i++) &#123; //分配不到的 a[i]，直接加上 ans+=a[i]*a[i]*pos*pos; &#125; LL g=__gcd(ans,b); if(ans%b==0)printf("%lld\n",ans/b); else printf("%lld/%lld\n",ans/g,b/g); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>拉格朗日</tag>
        <tag>牛客暑期多校训练营</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexoNext主题插入数学公式]]></title>
    <url>%2F2019%2F07%2F17%2FhexoNext%E4%B8%BB%E9%A2%98%E6%8F%92%E5%85%A5%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[开启mathjax先把这个打开，然后看到mathjax上面这一行了没有，要用hexo-rendering-pandoc 或者hexo-renderer-kramed这个渲染，第一个我试的时候发现和hexo-renderer-marked这个语法有点出入 (hexo默认使用 hexo-renderer-marked 渲染) ，如果换了前面写所有md文件的全都要改语法，所以我就用了第二个,先把hexo-renderer-marked的卸了，再装hexo-renderer-kramed。12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 用数学公式的时候记得打开 测试代码如下12345678$$P = \frac&#123;\sum_&#123;i=1&#125;^n (x_i- x)(y_i- y)&#125;&#123;\displaystyle \left[\sum_&#123;i=1&#125;^n (x_i-x)^2\sum_&#123;i=1&#125;^n (y_i-y)^2\right]^&#123;1/2&#125; &#125;$$ 效果如下: P = \frac {\sum_{i=1}^n (x_i- x)(y_i- y)} {\displaystyle \left[ \sum_{i=1}^n (x_i-x)^2 \sum_{i=1}^n (y_i-y)^2 \right]^{1/2} } HexoEditor 展示数学公式如果你用这个编辑器，想实时展示这个效果就打开TeX数学表达式。效果如下：]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HexoNext添加网易云音乐]]></title>
    <url>%2F2019%2F07%2F17%2FHexoNext%E6%B7%BB%E5%8A%A0%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%2F</url>
    <content type="text"><![CDATA[添加网易云音乐生成外链 修改模板文件就是这个themes\next\layout\_macro\sidebar.swig自己找个位置复制粘贴进去我是放在那个最下面]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HexoNext添加gitment评论]]></title>
    <url>%2F2019%2F07%2F17%2FHexoNext%E6%B7%BB%E5%8A%A0gitment%E8%AF%84%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[添加gitment评论区安装gitment1npm install gitment --save #安装gitment 创建应用再创建一个 OAuth application1234Application name:随便写Homepage URL:这个也可以随意写,就写你的博客地址就行Application description:描述,也可以随意写Authorization callback URL:这个必须写你的博客地址 申请好之后点注册,然后就可以看到两个东西ClientID和Client Secret,后面会用到. 创建完后这个等会要用上 配置123456789101112131415# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/gitment: enable: true mint: false # 如果要修改gitment.swig地址就改成false RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide &apos;Powered by ...&apos; on footer, and more language: # Force language, or auto switch by theme github_user: &#123;you github user id&#125; github_repo: 随便写一个你的公开的git仓库就行,到时候评论会作为那个项目的issue client_id: &#123;刚才申请的ClientID&#125; client_secret: &#123;刚才申请的Client Secret&#125; proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled 然后在 主题配置文件next config.yml中开启gitment因为某个服务器挂了，所以mint要为false才会执行你所修改的。 错误： object ProgressEventc 错误就是上面这个原因，把mint改成法false即可。 找到themes/next/layout/_third-party/comments/gitment.swig文件修改其中的css 和js ,注释掉的是一开始默认的，现在改成下方没有注释的。 (后面这个是汉化的)123456789101112&lt;!-- LOCAL: You can save these files to your site and update links --&gt;&#123;% if theme.gitment.mint %&#125; &#123;% set CommentsClass = 'Gitmint' %&#125; &lt;script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitmint.browser.js"&gt;&lt;/script&gt;&#123;% else %&#125; &#123;% set CommentsClass = 'Gitment' %&#125; &lt;!-- &lt;script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js"&gt;&lt;/script&gt; --&gt;&lt;script src="https://billts.site/js/gitment.js"&gt;&lt;/script&gt;&#123;% endif %&#125;&lt;!-- &lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css"/&gt; --&gt;&lt;link rel="stylesheet" href="https://billts.site/extra_css/gitment.css"&gt;&lt;!-- END LOCAL --&gt; 需要注意的是确保themes/next/_config.yml中theme.gitment.mint设置为false,才会走到我们改动的分支. 还有修改一下gitment模板，只需要修改id还是在上面那个文件, （我也不知道为啥要改，大佬门说要改，实际上我没改也没出现啥错误1234var gitment = new &#123;&#123;CommentsClass&#125;&#125;(&#123; id: &apos;&#123;&#123; page.date &#125;&#125;&apos;, owner: &apos;&#123;&#123; theme.gitment.github_user &#125;&#125;&apos;, repo: &apos;&#123;&#123; theme.gitment.github_repo &#125;&#125;&apos;,]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018CCPC吉林场重现赛]]></title>
    <url>%2F2019%2F07%2F16%2F2018CCPC%E5%90%89%E6%9E%97%E5%9C%BA%E9%87%8D%E7%8E%B0%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[2018CCPC吉林赛区（重现赛）传送门 A B这两题如果不会写，还是多去刷刷基础题，也没几个人为了这两题来吧。 C Justice题意： 给你N堆石子 ，每堆石子重量是1/(2^ki)的重量，然后问能不能把石子分成大于等于1/2重量的两堆石子。题解： 从大到小每次合并两堆一样的，如果只剩一个就直接丢掉，因为无论如何这个都没法合并成更大的一层的。一直这样合并下去如果能分成两堆一样的各大于1/2，那么最终合并的和一定能合成一个 0例子:1 3 3 4 4 5 2先按大小排序5 4 4 3 3 2 15没法合并，直接丢掉，合并两个4获得一个33 3 3 2 1合并两个3或得一个2 ，多出来的一个3没法合成2直接丢掉。2 2 1合并两个2再合并两个1最终获得0.能够获得0说明能分成两堆一样的1/2一开始没看到要记录状态，后来补救了一下，合并的时候加一个并查集就行了，不影响复杂度。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const long long mod = 1e9 + 7;const int maxn = 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;clock_t prostart;void f() &#123;#ifndef ONLINE_JUDGE prostart = clock(); freopen("../data.in", "r", stdin);#endif return;&#125;vector&lt;P&gt; v;int par[maxn];int find(int x) &#123; return x == par[x] ? x : par[x] = find(par[x]);&#125;priority_queue&lt;P, vector&lt;P&gt;, less&lt;P&gt; &gt; q;int main() &#123; f(); int T; int cas = 1; scanf("%d", &amp;T); while (T--) &#123; int n; scanf("%d", &amp;n); v.clear(); for (int i = 0; i &lt;= n; i++)par[i] = i; for (int i = 0; i &lt; n; i++) &#123; int a; scanf("%d", &amp;a); if (a &lt; n + 1) &#123; v.emplace_back(P(a, i + 1)); &#125; &#125; sort(v.begin(), v.end()); int flag = 0, ans = -1; for (int i = (int) v.size() - 1; i &gt;= 0; i--) &#123; while (q.size() &amp;&amp; v[i].first &lt; q.top().first)q.pop(); if (q.empty()) &#123; q.push(P(v[i].first, v[i].second)); if (v[i].first == 1)ans = v[i].second; &#125; else &#123; int l = v[i].first, y = v[i].second; while (q.size() &amp;&amp; q.top().first == l) &#123; if (l - 1 &gt;= 1) &#123; int x = find(q.top().second); par[x] = y; if (l - 1 == 1)ans = y; &#125; q.pop(); l = l - 1; &#125; if (l &lt;= 0)flag = y; q.push(P(l, y)); &#125; &#125; while (q.size()) &#123; int l = q.top().first, y = q.top().second; if (l == 1)ans = y; q.pop(); while (q.size() &amp;&amp; q.top().first == l) &#123; if (l - 1 &gt;= 1) &#123; int x = find(q.top().second); par[x] = y; if (l - 1 == 1)ans = y; &#125; q.pop(); l = l - 1;// if (l == 1)ans = y; &#125; if (l &lt;= 0)flag = 1; &#125; printf("Case %d: %s\n", cas++, flag ? "YES" : "NO"); if (flag) &#123;// debug(find(2)); for (int i = 1; i &lt;= n; i++) &#123; if (find(i) == ans)printf("1"); else printf("0"); &#125; puts(""); &#125; &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125; D The Moon题意： p的概率赢，初始获得包概率q为 2% 每次进行一次游戏，如果赢了q的概率获得包，如果没获得概率q变成min(100%，p),如果输了q变成min(100%，p),输入p问期望论数是多少.题解: p是一个整数，总共只有100个值，q最多只会出现0.5%，看到这些我有一个大胆的想法。期望等于 轮数*概率所以我暴力枚举1e6轮，用dp[i]表示q=i/2%的概率，然后直接把1e6轮的值加起来，因为到后面概率绝对越来越小1e6轮误差已经很小，然后暴力枚举p的1-100,把答案打印下来。。。。然后你懂的(注释掉的是暴力跑的代码)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const long long mod = 1e9 + 7;const int maxn = 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;clock_t prostart;void f() &#123;#ifndef ONLINE_JUDGE prostart = clock(); freopen("../data.in", "r", stdin);#endif return;&#125;bool cmp(double o1, double o2) &#123; return abs(o1 - o2) &lt; eps;&#125;struct point3 &#123; double x, y, z;&#125; s, t;double dp[maxn];double a[1000] = &#123;130.7530454000, 79.2053644503, 61.1640496589, 51.6033688156, 45.5020175987, 41.1756105103, 37.8950632978, 35.2908241865, 33.1540346125, 31.3568193706, 29.8159317728, 28.4744883082, 27.2920701057, 26.2390206161, 25.2929905666, 24.4367537696, 23.6567754479, 22.9422440770, 22.2843986720, 21.6760501176, 21.1112333591, 20.5849499398, 20.0929742362, 19.6317054554, 19.1980530697, 18.7893470611, 18.4032668302, 18.0377843270, 17.6911181415, 17.3616961332, 17.0481247749, 16.7491638265, 16.4637052733, 16.1907557033, 15.9294214771, 15.6788961816, 15.4384499618, 15.2074204071, 14.9852047313, 14.7712530335, 14.5650624685, 14.3661721843, 14.1741589106, 13.9886331012, 13.8092355497, 13.6356344123, 13.4675225797, 13.3046153516, 13.1466483734, 12.9933758002, 12.8445686601, 12.7000133904, 12.5595105271, 12.4228735274, 12.2899277111, 12.1605093052, 12.0344645825, 11.9116490803, 11.7919268935, 11.6751700320, 11.5612578361, 11.4500764445, 11.3415183077, 11.2354817448, 11.1318705365, 11.0305935527, 10.9315644109, 10.8347011617, 10.7399260000, 10.6471649983, 10.5563478614, 10.4674076992, 10.3802808172, 10.2949065219, 10.2112269412, 10.1291868575, 10.0487335524, 9.9698166630, 9.8923880479, 9.8164016621, 9.7418134409, 9.6685811914, 9.5966644912, 9.5260245936, 9.4566243391, 9.3884280725, 9.3214015652, 9.2555119427, 9.1907276158, 9.1270182166, 9.0643545388, 9.0027084802, 8.9420529899, 8.8823620181, 8.8236104686, 8.7657741544, 8.7088297556, 8.6527547795, 8.5975275235, 8.5431270393&#125;;int main() &#123;// f(); int T; int cas = 1;// T=100; scanf("%d", &amp;T); // int t=1; while (T--) &#123; int p;// p = t++; scanf("%d", &amp;p); printf("Case %d: %.10f\n", cas++, a[p - 1]);// p = p / 100;// double ans = 0;// memset(dp, 0, sizeof(dp + 300));// dp[4] = 1;// for (int i = 1; i &lt; maxn; i++) &#123;// for (int j = 200; j &gt;= 0; j--) &#123;//// debug(dp[j]);// if (dp[j] == 0)continue;// ans += i * dp[j] * j / 200.0 * p;// double t = dp[j];// dp[j] = 0;// dp[min(j + 4, 200)] += p * t * (1 - j / 200.0);// dp[min(200, j + 3)] += (1 - p) * t;// &#125;// &#125;// printf("%.10f\n", ans);// a[t - 1] = ans; &#125;// for (int i = 1; i &lt;= 100; i++)printf("%.10f\n", a[i]);#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125; E The Tower题意： 给一个圆锥的r,h 和一个点(x,y,z)，点的移动速度(vx,vy,vz)问这个点什么时候撞上去，保证直接从外面撞上去。题解： 线的方程:x=x0+vx*ty=y0+vy*tz=z0+vz*t圆锥方程: x^2 + y^2 = (h-z)^2 * r^2 / h^2解方程高中知识1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const long long mod = 1e9 + 7;const int maxn = 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif return;&#125;bool cmp(double o1, double o2) &#123; return abs(o1 - o2) &lt; eps;&#125;struct point3 &#123; double x, y, z;&#125; s, t;int main() &#123; f(); int T; double r, h; int cas = 0; scanf("%d", &amp;T); while (T--) &#123; scanf("%lf%lf%lf%lf%lf%lf%lf%lf", &amp;r, &amp;h, &amp;s.x, &amp;s.y, &amp;s.z, &amp;t.x, &amp;t.y, &amp;t.z); double tx, ty, tz; tx = t.x; ty = t.y; tz = t.z; double a, b, c; a = (tx * tx + ty * ty - tz * tz * r * r / h / h); b = 2 * (tx * s.x + ty * s.y + tz * (h - s.z) * r * r / h / h); c = s.x * s.x + s.y * s.y - (h - s.z) * (h - s.z) * r * r / h / h; double high = max((h - s.z) / tz, -s.z / tz), low = min((h - s.z) / tz, -s.z / tz); double a1 = (-b + sqrt(b * b - 4 * a * c)) / 2 / a, a2 = (-b - sqrt(b * b - 4 * a * c)) / 2 / a, ans; ans = inf; if (a1 &gt;= low &amp;&amp; a1 &lt;= high)ans = min(a1, ans); if (a2 &gt;= low &amp;&amp; a2 &lt;= high)ans = min(a2, ans); else ans = a2; cout &lt;&lt; "Case " &lt;&lt; ++cas &lt;&lt; ": " &lt;&lt; fixed &lt;&lt; setprecision(10) &lt;&lt; ans &lt;&lt; "\n"; &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125; F The Hermit题意: 太长了自己读吧.题解: 读题读懂了可以发现一个有趣的事，每个i对应的k都是连续的几个。为什么会这样呢？仔细分析每个站点的区域发现，后面的结束一定比前面的晚，前面的开始的一定比后面晚，所以导致了k是连续的，枚举i用set保存覆盖到i的j 用set的二分找到一个与i有k的起始位置，到set最后一个j的最后一个k的位置，这两个位置之间的站点都是i的k，然后异或就行了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;int n;set&lt;P&gt; s;int main() &#123; f(); int T, cas = 1; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int a; scanf("%d", &amp;a); int last = a + i - 1; if (s.size()) &#123; set&lt;P&gt;::iterator ite = s.lower_bound(P(i - (a - 1) / 2, 0)); if (ite != s.end()) &#123; int stat = max(i - a + 1, 2 * ite-&gt;first - ite-&gt;second); int end = 2 * (--s.end())-&gt;first - i; ans ^= end - stat + 1; &#125; &#125; s.insert(P(i, last)); while (s.size() &amp;&amp; s.begin()-&gt;second &lt;= i) &#123; s.erase(s.begin()); &#125; &#125; s.clear(); printf("Case %d: %d\n", cas++, ans); &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125; H Lovers题意： n 个字符串，m个操作，wrap操作在区间[l,r]的字符串前后各加一个数字,如3加入2112变成321123，一开始是个空字符串，值为0。query 查询[l,r]之间所有字符串的值的和模1e9+7。题解： 把字符串分成三段 前缀+原本的值+后缀，前缀和后缀就是一个相反的，我直接把他处理成数字，然后记录长度，原本的值也是一样，保存值和长度。然后线段树随便搞，lazy数组保存字符串加在前面的贡献，lazy2 后缀贡献,dat区间内添加一个数影响的总贡献，val区间和.每次更新值：val[k] =lazy[k]*dat[k] + val[k] * lenth(lazy[k]) + lazy2[k]dat[k] = dat[k] * lenth(lazy[k]) 具体见代码add() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;LL dat[maxn &lt;&lt; 2], lazy[maxn &lt;&lt; 2], val[maxn &lt;&lt; 2], lazy2[maxn &lt;&lt; 2];LL p10[maxn];int len[maxn &lt;&lt; 2];void up(int l, int r, int k) &#123; val[k] = (val[chl] + val[chr]) % mod; dat[k] = (dat[chl] + dat[chr]) % mod; len[k] = 0; lazy2[k] = lazy[k] = 0;&#125;void build(int l, int r, int k) &#123; if (r == l) &#123; dat[k] = 1; lazy2[k] = lazy[k] = 0; len[k] = 0; val[k] = 0; &#125; else &#123; build(lson); build(rson); up(l, r, k); &#125;&#125;LL re(LL x) &#123; LL res = 0; while (x &gt; 0) &#123; res = res * 10 + x % 10 % mod; x /= 10; &#125; return res;&#125;void add(int l, int r, int k, LL x, LL y, int lenx) &#123; if (r == l) &#123; lazy2[k] = lazy[k] = 0; val[k] = (1LL * y % mod + val[k] * p10[lenx] % mod + dat[k] * p10[lenx] % mod * x % mod) % mod; dat[k] = dat[k] * p10[2 * lenx] % mod; return; &#125; lazy[k] = (lazy[k] + x * p10[len[k]] % mod) % mod; lazy2[k] = (lazy2[k] * p10[lenx] % mod + y) % mod; len[k] += lenx; val[k] = (1LL * y * (r - l + 1) % mod + val[k] * p10[lenx] % mod + dat[k] * p10[lenx] % mod * x % mod) % mod; dat[k] = dat[k] * p10[2 * lenx] % mod;&#125;void pushdown(int l, int r, int k) &#123; if (len[k] == 0) &#123; return; &#125; else &#123; add(lson, lazy[k], lazy2[k], len[k]); add(rson, lazy[k], lazy2[k], len[k]); up(l, r, k); &#125;&#125;int t;int n, m;void update(int a, int b, int l, int r, int k, int x) &#123; pushdown(l, r, k); if (r &lt; a || l &gt; b)return; else if (a &lt;= l &amp;&amp; r &lt;= b) &#123; add(l, r, k, x, x, 1LL); &#125; else &#123; update(a, b, lson, x); update(a, b, rson, x); up(l, r, k); &#125;&#125;LL querry(int a, int b, int l, int r, int k) &#123; pushdown(l, r, k); if (r &lt; a || l &gt; b)return 0; else if (a &lt;= l &amp;&amp; r &lt;= b) &#123;// debug(val[k]); return val[k]; &#125; else &#123; return (querry(a, b, lson) + querry(a, b, rson)) % mod; &#125;&#125;int main() &#123; f(); p10[0] = 1; for (int i = 1; i &lt;= 400000; i++) &#123; p10[i] = p10[i - 1] * 10 % mod; &#125; int cas = 1; scanf("%d", &amp;t); while (t--) &#123; scanf("%d%d", &amp;n, &amp;m); build(1, n, 0); printf("Case %d:\n", cas++); while (m--) &#123; char s[10]; int l, r; scanf("%s%d%d", s, &amp;l, &amp;r); if (s[0] == 'q') &#123; LL ans = querry(l, r, 1, n, 0); printf("%lld\n", ans % mod); &#125; else &#123; int x; scanf("%d", &amp;x); update(l, r, 1, n, 0, x);// for (int i = 1; i &lt;= n; i++) &#123;// printf("%lld ", querry(i, i, 1, n, 0));// &#125;// puts(""); &#125; &#125; &#125; return 0;&#125; I Strength题意: 游戏王，我有n个怪 全都是战斗表示 ,对面有m个怪，0表示战斗表示，1防守表示,问我第一回合能造成多少点伤害。题解: 一个水题，其实和A B难度差距不大。枚举两种情况，一种是能把对面怪全部砍了，一种是不能。不能全砍死，直接用最大的砍对面攻击表示最小的，砍不过就算了不打了。能全砍死，本来这还有两种情况，就算我能全砍死对面的怪，但是我全砍死，和第一种情况一样，直接用最大的砍你最小的，另一种就是全砍死 (事实上数据就只有这一种情况，可能出题人有特殊癖好，要砍就全砍死) ，先把防御状态的用尽可能小的代价砍死，然后你想怎么砍就怎么砍，反正最后代价都是你怪攻击力总和减对面战斗力总和。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;struct node &#123; int x, op; bool operator&lt;(const node &amp;o) const &#123; if (op == o.op)return x &lt; o.x; return op &lt; o.op; &#125;&#125; k[maxn], d[maxn];bool cmp(node &amp;o1, node &amp;o2) &#123; return o1.x &gt; o2.x;&#125;int main() &#123; f(); int T, cas = 1; scanf("%d", &amp;T); while (T--) &#123; int n, m; multiset&lt;int&gt; s; priority_queue&lt;int&gt; q; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;k[i].x); s.insert(k[i].x); q.push(k[i].x); &#125; for (int i = 0; i &lt; m; i++) &#123; scanf("%d", &amp;d[i].x); &#125; for (int i = 0; i &lt; m; i++) &#123; scanf("%d", &amp;d[i].op); &#125; sort(k, k + n, cmp); sort(d, d + m, cmp); int flag = 0; if (n &lt; m)flag = 1; else &#123; for (int i = 0; i &lt; m; i++) &#123; if (k[i].x &lt; d[i].x) &#123; flag = 1; break; &#125; &#125; &#125; LL ans = 0; if (flag == 1) &#123; sort(d, d + m); for (int i = 0; i &lt; m; i++) &#123; if (d[i].op == 1)break; else &#123; if (q.top() &gt; d[i].x) &#123; ans += q.top() - d[i].x; q.pop(); &#125; &#125; &#125; &#125; else &#123; sort(d, d + m); for (int i = 0; i &lt; m; i++) &#123; if (d[i].op == 1)break; else &#123; if (k[i].x &gt; d[i].x) &#123; ans += k[i].x - d[i].x; &#125; else &#123; break; &#125; &#125; &#125; LL res = 0; for (int i = 0; i &lt; m; i++) &#123; if (d[i].op == 1) &#123; s.erase(s.lower_bound(d[i].x)); &#125; else &#123; res -= d[i].x; &#125; &#125; for (auto au:s) &#123; res += au; &#125; ans = max(res, ans); &#125; printf("Case %d: %lld\n", cas++, ans); &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>CCPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 573 Div 2]]></title>
    <url>%2F2019%2F07%2F13%2FCodeforces-Round-573-Div-2%2F</url>
    <content type="text"><![CDATA[A - Tokitsukaze and Enhancement简单题不与说明12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt; using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P; #define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a)); const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("dat.in", "r", stdin);#endif // ONLIN_JUDGE&#125; int main() &#123; f(); int x; cin&gt;&gt;x; x=x%4; if(x==0) &#123; printf("1 A\n"); &#125; else if(x==1) &#123; printf("0 A\n"); &#125; else if(x==2) &#123; printf("1 B\n"); &#125; else printf("2 A\n"); return 0;&#125; B - Tokitsukaze and Mahjong1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt; using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P; #define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a)); const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("dat.in", "r", stdin);#endif // ONLIN_JUDGE&#125;char s[20];vector&lt;int &gt;v[3],v2,v3; int f(int x) &#123; sort(v[x].begin(),v[x].end()); if(v[x].size()==0)return 3; if(v[x].size()==1)return 2; else if(v[x].size()==2) &#123; if(v[x][1]==v[x][0])return 1; if(v[x][1]==v[x][0]+1)return 1; if(v[x][1]==v[x][0]+2)return 1; return 2; &#125; else &#123; if(v[x][1]==v[x][0]&amp;&amp;v[x][1]==v[x][2])return 0; if(v[x][1]==v[x][0]+1&amp;&amp;v[x][1]==v[x][2]-1)return 0; if(v[x][1]==v[x][0]||v[x][1]==v[x][2])return 1; if(v[x][1]==v[x][0]+1||v[x][1]==v[x][0]+2||v[x][1]==v[x][2]-1||v[x][1]==v[x][2]-2)return 1; return 2; &#125;&#125;int main() &#123; int ans=2; for(int i=0; i&lt;3; i++) &#123; scanf("%s",s); if(s[1]=='s') &#123; v[0].push_back(s[0]); &#125; else if(s[1]=='p') &#123; v[1].push_back(s[0]); &#125; else v[2].push_back(s[0]); &#125; for(int i=0; i&lt;3; i++) &#123;// debug(i); ans=min(ans,f(i)); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; C - Tokitsukaze and Discard Items12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt; using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P; #define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a)); const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("dat.in", "r", stdin);#endif // ONLIN_JUDGE&#125; LL n,m,k;LL a[maxn];int main() &#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=0; i&lt;m; i++) &#123; scanf("%lld",&amp;a[i]); &#125; sort(a,a+m); LL sum=0,ans=0,num=0; LL page=1; for(int i=0; i&lt;m; i++) &#123; if(a[i]&lt;=page*k+sum) &#123; num++; &#125; else &#123; if(num==0) &#123; page=(a[i]-sum+k-1)/k; num++; &#125; else &#123; ans++; sum+=num; page=(a[i]-sum+k-1)/k; num=1; &#125; &#125; &#125; if(num!=0)ans++; printf("%lld\n",ans); return 0;&#125; D - Tokitsukaze, CSL and Stone Game首先这题是简单粗暴，因为选择到两个相同的就输了，说明每一个都不相同，最终状态肯定是 0 1 2 3 …. n-1这种状态肯定是必输，无法动弹。所以最终都会变成这个状态，判断一下到这个状态的奇偶就是答案。另外还有一开始就输了的状态，比如 3 4 4 两个一样的，只能选一样的，但是选了有一个和他相同，还有 0 0 一开始就有两个0 还有就是 5 5 5 三个一样的或者两对两个一样的，这四种状态绝对是直接输了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374By ET_BUBBLE, contest:Codeforces Round #573 (Div. 2), problem: (D) Tokitsukaze, CSL and Stone Game, Accepted, ##include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("dat.in", "r", stdin);#endif // ONLIN_JUDGE&#125;LL n;LL a[maxn];int flag=1,num;map&lt;LL,LL&gt; mp;LL sum=0;int main() &#123; cin&gt;&gt;n; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;a[i]; &#125; sort(a,a+n); for(int i=0; i&lt;n; i++) &#123; if(mp.find(a[i])!=mp.end()) &#123; num++; if(mp.find(a[i]-1)!=mp.end())flag=0; &#125; mp[a[i]]++; &#125; if(num&gt;1||mp[0]&gt;=2||flag==0) &#123; puts("cslnb"); return 0; &#125; if(n==1) &#123; puts((a[0]&amp;1)?"sjfnb":"cslnb"); &#125; else &#123; int flag=1; sum=0; for(int i=0; i&lt;n; i++) &#123; if(a[i]&lt;i) &#123; flag=0; &#125; else &#123; sum+=a[i]-i; &#125; &#125; if(flag==0) &#123; puts("cslnb"); return 0; &#125; puts(sum%2==1?"sjfnb":"cslnb"); &#125; return 0;&#125; F - Tokitsukaze and Strange Rectangle题意：自己读去题解：先按照,y从大到小排序在按照x从小到大排序，然后每次判断一层y。先判断第一层 1 2 6 7 10 （假设）y=10然后判断第二层 4 8 (假设) y = 9第一层能够出现的不同的选法是 5*(5-1)/2;第二层会受到第一层的影响 1 2 在 4 前面，所以要选 4 的矩形情况 是红色l到右边蓝色r的所有矩形，会选上4,同理选上8又不和前面的重复就只能是这样了。然后又可以发现，如果有第3层 ，前面两层对第3层的影响只与x的出现有关，每次判断一层只需要考虑上面出现的 x的影响。先离散化一下，然后用树状数组求一下这个点前面有多个点，后面有多少个点，然后乘一下就可以了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("dat.in", "r", stdin);#endif // ONLIN_JUDGE&#125;int bit[maxn+1],pos;int sum(int i) &#123; int s=0; while(i&gt;0) &#123; s +=bit[i]; i-=i&amp;-i; &#125; return s;&#125;void add(int i,int x) &#123; while(i&lt;=pos) &#123; bit[i]+=x; i+=i&amp;-i; &#125;&#125;int n;struct node &#123; int x,y;&#125; p[maxn];bool cmp(node &amp;o1,node &amp;o2) &#123; if(o1.y==o2.y)return o1.x&lt;o2.x; return o1.y&gt;o2.y;&#125;LL ans=0;unordered_map&lt;int,int&gt;mp;int a[maxn];int main() &#123; f(); scanf("%d",&amp;n); for(int i=0; i&lt;n; i++) &#123; scanf("%d%d",&amp;p[i].x,&amp;p[i].y); a[i]=(p[i].x); &#125; pos=1; sort(a,a+n); for(int i=0; i&lt;n; i++) &#123; if(i==0) &#123; mp[a[0]]=pos++; &#125; else if(a[i]!=a[i-1]) &#123; mp[a[i]]=pos++; &#125; &#125; for(int i=0; i&lt;n; i++) &#123; p[i].x=mp[p[i].x]; &#125; sort(p,p+n,cmp); int len=0; a[len++]=p[0].x; add(p[0].x,1); int mx=pos; for(int i=1; i&lt;n; i++) &#123; if(p[i].y==p[i-1].y) &#123; a[len++]=p[i].x; if(sum(p[i].x)-sum(p[i].x-1)==0)add(p[i].x,1); &#125; else &#123; int la=0; // sort(a,a+len); for(int j=0; j&lt;len; j++) &#123; int i=a[j]; ans+=1LL*(sum(i)-sum(la))*(sum(mx)-sum(i-1)); la=i; &#125; len=0; a[len++]=(p[i].x); if(sum(p[i].x)-sum(p[i].x-1)==0)add(p[i].x,1); &#125; &#125; int la=0; // sort(a,a+len); for(int j=0; j&lt;len; j++) &#123; int i=a[j]; ans+=1LL*(sum(i)-sum(la))*(sum(mx)-sum(i-1)); la=i; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拉格朗日插值和求多项式系数]]></title>
    <url>%2F2019%2F07%2F12%2F%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E5%92%8C%E6%B1%82%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%B3%BB%E6%95%B0%2F</url>
    <content type="text"><![CDATA[拉格朗日介绍先说说拉格朗日是啥吧首先 拉格朗日插值是给你 n+1 个点 $(x,y)$ 然后根据这n个点可以$O(n^2)$的求出多项式的系数。也就是解出这个多项式的答案。 假设给你一个多项式$y=a_0+a_1x+a_2x^2$然后给你3个解$(x1,y1)(x2,y2)(x3,y3)$你第一个想法是怎么解？解方程啊是不是代进去是不是这样 \begin{cases} y_1=a_0+a_1x_1+a_2x_1^2\\ y_2=a_0+a_1x_2+a_2x_2^2\\ y_3=a_0+a_1x_3+a_2x_3^2 \end{cases}然年后解这个方程？解这个方程复杂度多少,高斯消元O(n^3)很显然复杂度高了。拉格朗日就比较厉害了他能O(n^2)解决首先 假设一个多项式$f_1(x)= b_0 + b_1x+b_2x^2$当他$x=x_1$解是1,$x_2$ $x_3$ 解是 0同理再假设 $f_2(x)$ $f_3(x)$然后$L(x)=y_1f_1(x)+y_2f_2(x)+y_3f_3(x)$,这个就是最开始那个方程，不信?你把$x_1 x_2 x_3$ 带进去解绝对是 $y_1 y_2 y_3$。那么问题来了后面$f_1(x)$这个多项式怎么求出来？？？？这就是拉格朗日基本公式 f(x)=\sum_{i=0}^{n-1}y_i\prod_{j=0,j\neq i}^{n-1}\frac{x-x_i}{x_j-x_i}没错就是他哦！搞错了是下面这个，上面那个是乘上$y_i$的最终表达式再来一遍，这就是拉格朗日基本公式 l_j(x)=\prod_{j=0,j\neq i}^{n-1}\frac{x-x_i}{x_j-x_i}把这个多项式展开会发现非常神奇的事，当$x=x_j$的时候刚好等于1否则等于0,刚好满足了原来所需要的方程式。就是下面这样： l_j(x)=\prod_{j=0,j\neq i}^{k}\frac{x-x_i}{x_i-x_j}=\frac{x-x_0}{x_0-x_j}\cdots\frac{x-x_0}{x_j-x_{j-1}}\frac{x-x_{j+1}}{x_j-x_{j+1}}\cdots\frac{x-x_k}{x_j-x_k}怕你还是看不懂，举个例子给你看 $f(4)=10\ f(5)=5.25\ f(6)=1$ 求 $f(18)$ 首先写出拉格朗日基本多项式 l_0=\frac{(x-5)(x-6)}{(4-5)(5-6)}l_1=\frac{(x-4)(x-6)}{(5-4)(5-6)}l_2=\frac{(x-4)(x-5)}{(6-4)(6-5)}\begin{cases} p(x)&=f(4)l_0(x)+f(5)l_1(x)+f(6)l_2(x)\\ &=10\frac{(x-5)(x-6)}{(4-5)(5-6)}+5.25\frac{(x-4)(x-6)}{(5-4)(5-6)}+1*\frac{(x-4)(x-5)}{(6-4)(6-5)}\\ &=\frac{1}{4}(x^2-28x+136) \end{cases}此时代入18:$f(18)=p(18)=-11$还有一个问题你们肯定很想问。。。知道公式之后怎么解。。。对于这个问题分母 是不是每次算一下就行了，答案是固定的分子是不是一个大的多项式里面少了一个，就预处理出总的多项式然后，模拟除一下$(x+c)$的多项式 理论知识全部搞定，下面就给你贴模板了 板子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//这个是杜教的板子 我打了点注释/// 注意mod，使用前须调用一次 polysum::init(int M);/// 注意mod，使用前须调用一次 polysum::init(int M);namespace polysum &#123;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)typedef long long ll;const ll mod = 1e9 + 7; /// 取模值ll powmod(ll a, ll b) &#123; ll res = 1; a %= mod; assert(b &gt;= 0); for (; b; b &gt;&gt;= 1) &#123; if (b &amp; 1)res = res*a%mod; a = a*a%mod; &#125; return res;&#125;const int D = 1010000; /// 最高次限制ll a[D], f[D], g[D], p[D], p1[D], p2[D], b[D], h[D][2], C[D];ll calcn(int d, ll *a, ll n) &#123; //根据前 d 项 求 第n项 if (n &lt;= d) return a[n]; p1[0] = p2[0] = 1; rep(i, 0, d + 1) &#123; ll t = (n - i + mod) % mod; p1[i + 1] = p1[i] * t%mod; &#125; rep(i, 0, d + 1) &#123; ll t = (n - d + i + mod) % mod; p2[i + 1] = p2[i] * t%mod; &#125; ll ans = 0; rep(i, 0, d + 1) &#123; ll t = g[i] * g[d - i] % mod*p1[i] % mod*p2[d - i] % mod*a[i] % mod; if ((d - i) &amp; 1) ans = (ans - t + mod) % mod; else ans = (ans + t) % mod; &#125; return ans;&#125;void init(int M) &#123; /// M：最高次 f[0] = f[1] = g[0] = g[1] = 1; rep(i, 2, M + 5) f[i] = f[i - 1] * i%mod; g[M + 4] = powmod(f[M + 4], mod - 2); per(i, 1, M + 4) g[i] = g[i + 1] * (i + 1) % mod; //逆元&#125;ll polysum(ll n, ll *arr, ll m) &#123; /// a[0].. a[m] \sum_&#123;i=0&#125;^&#123;n-1&#125; a[i] for (int i = 0; i &lt;= m; i++) a[i] = arr[i]; a[m + 1] = calcn(m, a, m + 1); rep(i, 1, m + 2) a[i] = (a[i - 1] + a[i]) % mod; return calcn(m + 1, a, n - 1);&#125;ll qpolysum(ll R, ll n, ll *a, ll m) &#123; /// a[0].. a[m] \sum_&#123;i=0&#125;^&#123;n-1&#125; a[i]*R^i if (R == 1) return polysum(n, a, m); a[m + 1] = calcn(m, a, m + 1); ll r = powmod(R, mod - 2), p3 = 0, p4 = 0, c, ans; h[0][0] = 0; h[0][1] = 1; rep(i, 1, m + 2) &#123; h[i][0] = (h[i - 1][0] + a[i - 1])*r%mod; h[i][1] = h[i - 1][1] * r%mod; &#125; rep(i, 0, m + 2) &#123; ll t = g[i] * g[m + 1 - i] % mod; if (i &amp; 1) p3 = ((p3 - h[i][0] * t) % mod + mod) % mod, p4 = ((p4 - h[i][1] * t) % mod + mod) % mod; else p3 = (p3 + h[i][0] * t) % mod, p4 = (p4 + h[i][1] * t) % mod; &#125; c = powmod(p4, mod - 2)*(mod - p3) % mod; rep(i, 0, m + 2) h[i][0] = (h[i][0] + h[i][1] * c) % mod; rep(i, 0, m + 2) C[i] = h[i][0]; ans = (calcn(m, C, n)*powmod(R, n) - c) % mod; if (ans&lt;0) ans += mod; return ans;&#125;&#125; 然后下面这个是求多项式的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374LL temp[maxn];void mul(LL *f, int len, LL t) &#123; //len为多项式的次数+1，函数让多项式f变成f*(x+t) for(int i = len; i &gt; 0; --i) &#123; temp[i] = f[i]; f[i] = f[i-1]; &#125; temp[0] = f[0], f[0] = 0; for(int i = 0; i &lt;= len; ++i) &#123; f[i] = (f[i] + t*temp[i])%mod; &#125;&#125;void dev(LL *f, LL *r, LL t,int len) &#123; //f是被除多项式的系数，r保存f除以x+t的结果 len是最高次项 for(int i = 0; i &lt;= len; ++i) &#123; temp[i] = f[i]; &#125; for(int i = len; i &gt; 0; --i) &#123; r[i-1] = temp[i]; temp[i-1] = (temp[i-1] - t*temp[i])%mod; &#125; return;&#125;LL a[maxn], b[maxn], c[maxn];LL x[maxn], y[maxn]; //x,y输入从 1开始到nint n;void lglr() &#123; memset(a,0,sizeof a); b[1] = 1, b[0] = -x[1]; for(int i = 2; i &lt;= n; ++i) &#123; mul(b, i, -x[i]); &#125;//预处理(x-x1)*(x-x2)...*(x-xn) for(int i = 1; i &lt;= n; ++i) &#123; LL fz = 1; for(int j = 1; j &lt;= n; ++j) &#123; if(j == i) continue; fz = fz*(x[i] - x[j])%mod; &#125; fz = qm(fz, mod-2); fz = fz*y[i]%mod;//得到多项式系数 dev(b, c, -x[i],n);//得到多项式，保存在b数组 for(int j = 0; j &lt; n; ++j) a[j] = (a[j] + fz*c[j])%mod; &#125;&#125;LL cal(LL k) &#123; //计算第x=k值 LL ans = 0; LL res = 1; for(int i = 0; i &lt; n; ++i) &#123; ans = (ans + res*a[i])%mod; res = res*k%mod; &#125; ans = (ans + mod)%mod; return ans;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数素数判断及质因子分解]]></title>
    <url>%2F2019%2F07%2F11%2F%E5%A4%A7%E6%95%B0%E7%B4%A0%E6%95%B0%E5%88%A4%E6%96%AD%E5%8F%8A%E8%B4%A8%E5%9B%A0%E5%AD%90%E5%88%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[判断是否是素数几个常用的sqrt(n)复杂度的就不说了。对于一个 longlong 范围或者更大的数，怎么快速判断一个数是不是素数，就要用到Miller_Rabin算法.立用a^(n-1)=1(mod n) 怎么来的就不解释了，有兴趣的同学可以看看算法导论P566有详细推导。在这个的基础上用 随机数进行测试（直接用的话会有一些伪素数）。里面 a用随机数随机， (n-1) 写成 2^r*s 为啥这么写我也不知道，反正大家都是这么写的 qaq然后就根据上面那个判断就行了这个算法有时候会出错，出错的概率差不多是 2^-循环次数12345678910111213141516171819202122232425262728293031323334353637inline LL ksc(LL x,LL n,LL mod) &#123; LL res=0; while(n&gt;0) &#123; if(n&amp;1)res=(res+x)%mod; x=(x+x)%mod; n&gt;&gt;=1; &#125; return res%mod;&#125;inline LL ksm(LL x,LL n,LL mod) &#123; LL res=1; while(n&gt;0) &#123; if(n&amp;1)res=ksc(res,x,mod); x=ksc(x,x,mod); n&gt;&gt;=1; &#125; return res%mod;&#125;bool check(LL x) &#123; //Miller_Rabin算法，判断n是否为素数 for(int i=0; i&lt;50; i++) &#123; int a=rand()%(x-1)+1,k=0; LL t=x-1; if(ksm(a,x-1,x)!=1)return 0; while(t&amp;1==0) &#123; ++k; t&gt;&gt;=1; &#125; LL u=ksm(a,t,x),l=u; for(int i=1; i&lt;=k; i++) &#123; u=ksc(u,u,x); if(u==1&amp;&amp;l!=1&amp;&amp;l!=x-1)return 0; l=u; &#125; &#125; return 1;&#125; 质因子分解pollard_rho算法,这个算法十分玄学，找到一个数x0 ，然后用一个玄学递推得到 x1=x0*x0 + 一个随机数 然后用两个的差值去和 n做 gcd 然后得出来如果是1就继续找，如果不是1 不就是个因子吗？ （个人理解有点像直接随机一个数和他做GCD有没有公约数。。。。） 补充说明一下 x=(x*x +c)%n 是一个滚循环 像ρ所以称为pollard_rho算法，所以要判断循环结 用 floyd 判断。1234567891011121314151617181920212223242526272829303132333435363738LL pollard_rho(LL n, LL c) &#123; LL i = 1, k = 2; LL x = rand() % (n - 1) + 1; LL y = x; while (1) &#123; i++; x = (ksc(x, x, n) + c) % n; //玄学递推 LL d = __gcd((y - x + n) % n, n); if (1LL &lt; d &amp;&amp; d &lt; n) &#123; //如果有因子就直接返回 return d; &#125; if (y == x) &#123; //如果找到了循环节就跳出 return n; &#125; if (i == k) &#123; //空间 o1 判断循环节用的 ，看不懂你没救了 y = x; k &lt;&lt;= 1; &#125; &#125;&#125;LL fac[100],ct;void find(LL n, int c) &#123; if (n == 1) &#123; return; &#125; if (check(n)) &#123; fac[ct++] = n; //是个质因子 return; &#125; LL p = n; LL k = c; while (p &gt;= n) &#123; p = pollard_rho(p, c--); //如果是合数总会找到一个因子 &#125; find(p, k); //继续找 find(n / p, k);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何将本地项目传入github]]></title>
    <url>%2F2019%2F06%2F24%2F%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%BC%A0%E5%85%A5github%2F</url>
    <content type="text"><![CDATA[初始化文件夹在本地执行git init命令1git init 添加需要上传到github的代码到本地仓库git status查看哪些文件是没有加入到本地仓库的，红色的没有，绿色是已经添加了的。 1git add 可以把需要的文件加入本地仓库 将add的文件commit到仓库1git commit -m &quot;第一次提交&quot; 去github上创建自己的Repository这个不用教了吧 将本地的仓库关联到github上1git remote add origin +链接 上传代码到github远程仓库12git push #传上去git pull #拉回来 123git pull --rebase origin mastergit push -u origin master]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA连接myqsl数据库]]></title>
    <url>%2F2019%2F05%2F24%2FIDEA%E8%BF%9E%E6%8E%A5myqsl%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[第一步然后右边就会出现一个database 这个地方可能要更新一下驱动，idea 有自带更新，点一下下面那个 MySQL 就行添加连接数据库的Java包选择找到的包添加好后应该会在下面多一个这样的包连接数据库就成功了测试一下，具体测试根据你自己数据库来，后面我打有注释1234567891011121314151617181920212223242526272829303132package longpf;import java.sql.*;public class My &#123; public static void main(String[] args) &#123; Connection conn = null; //建立一个数据库连接 try &#123; Class.forName( "com.mysql.jdbc.Driver"); //加载驱动 System.out.println("数据库驱动加载成功"); long start=System.currentTimeMillis(); //记录开始时间 conn=DriverManager.getConnection("jdbc:mysql://localhost:3306/mygamedb","root","root"); //连接数据库，参数数据库位置，用户名 密码 long end=System.currentTimeMillis(); // 记录结束时间 System.out.println(conn); // 打印连接 System.out.println("建立用时："+(end-start)+"ms"); // 创建Statement对象 Statement stmt = conn.createStatement(); // 执行SQL语句 ResultSet rs = stmt.executeQuery("select * from users"); System.out.println("id\tusername\tpwd\t\tregTime"); while (rs.next()) &#123; System.out.println(rs.getInt(1) + "\t" + rs.getString(2) + "\t\t" + rs.getString(3)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return; &#125;&#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql学习笔记(三)]]></title>
    <url>%2F2019%2F05%2F19%2Fsql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[sql的特点SQL语言集数据查询（data query）、数据操纵（data manipulation）、数据定义（data definition）和数据控制（data control）功能于一体，充分体现了关系数据语言的特点和优点。其主要特点包括： 1.综合统一SQL语言集数据定义语言DDL、数据操纵语言DML、数据控制语言DCL的功能于一体，语言风格统一，可以独立完成数据库生命周期中的全部活动，包括定义关系模式、录入数据以建立数据库、查询、更新、维护、数据库重构、数据库安全性控制等一系列操作要求，这就为数据库应用系统开发提供了良好的环境，例如用户在数据库投入运行后，还可根据需要随时地逐步地修改模式，并不影响数据库的运行，从而使系统具有良好的可扩充性。 2.高度非过程化非关系数据模型的数据操纵语言是面向过程的语言，用其完成某项请求，必须指定存取路径。而用SQL语言进行数据操作，用户只需提出“做什么”，而不必指明“怎么做”，因此用户无需了解存取路径，存取路径的选择以及SQL语句的操作过程由系统自动完成。这不但大大减轻了用户负担，而且有利于提高数据独立性。 3.面向集合的操作方式SQL语言采用集合操作方式，不仅查找结果可以是元组的集合，而且一次插入、删除、更新操作的对象也可以是元组的集合。非关系数据模型采用的是面向记录的操作方式，任何一个操作其对象都是一条记录。例如查询所有平均成绩在80分以上的学生姓名，用户必须说明完成该请求的具体处理过程，即如何用循环结构按照某条路径一条一条地把满足条件的学生记录读出来。 4.以同一种语法结构提供两种使用方式SQL语言既是自含式语言，又是嵌入式语言。作为自含式语言，它能够独立地用于联机交互的使用方式，用户可以在终端键盘上直接键入SQL命令对数据库进行操作。作为嵌入式语言，SQL语句能够嵌入到高级语言（例如C、PB）程序中，供程序员设计程序时使用。而在两种不同的使用方式下，SQL语言的语法结构基本上是一致的。这种以统一的语法结构提供两种不同的使用方式的作法，为用户提供了极大的灵活性与方便性。 以上都是废话 前面说过三层结构，外模式，模式，内模式，外模式就对应sql 里面的视图 ，模式对应表，内模式就是对应储存文件了(这个并不需要管)后面说实用的了 SQL语法1.模式创建1create schema 模式名; 删除1drop schema 模式名; 定义一个基本表create table 表名(列名 数据类型 约束条件,列名 数据类型 约束条件,列名 数据类型 约束条件)1create table]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql学习笔记(二)关系数据库]]></title>
    <url>%2F2019%2F05%2F19%2Fsql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[关系关系模型的数据结构非常简单，只包含单一的数据结构，关系。在用户看来就是一张表。 1.域域是一组具有相同的数据类型的值的集合。比如性别{男,女} 2.笛卡尔积一堆域的乘积。D1*D2*D3*…*Dn = {d1,…,dn|di in Di};每个 (d1…dn) 叫元组，每个值叫分量。一个域的不同取值叫做这个域的基数 3.关系D1*D2...*Dn 的子集叫做在D1,…，Dn上的关系。n 被称做目或度n=1 单元关系，n=2 二元关系候选码某一属性组能够唯一地表示一个元组，而其子集不能。有多个候选码的时候选一个作为主码候选码的诸属性叫做主属性，其余被称为非主属性或非码属性 基本的关系操作查询操作(query),插入(insert)，删除(delete)，修改(update)查询其中又有 选择(select)、投影(project)、连接(join)、除(divide)、并(union)、差(except)、交(intersection);]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql学习笔记（一）基本介绍]]></title>
    <url>%2F2019%2F05%2F19%2Fsql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[数据库基本概念1.数据(Data): 例如 文本(text)、图形(graph)、图像(image)、音频(audio)、视频(video)等.2.数据库(Database) DB: 数据库指的是以一一定方式储存在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。它具有整体性、共享性。3.数据库管理系统(DataBase Management System)DBMS4.数据库系统(DataBase System) DBS 数据模型数据模型是对现实世界数据特征的抽象两类数据模型 概念模型 逻辑模型和物理模型 常用的数据模型 层次模型 网状模型 关系模型 面向对象数据模型 对象关系数据模型 半结构化数据模型 数据库三层模式两层映射 1.模式模式也称概念模式，是数据库中全部数据的逻辑结构和特征的描述，它由若干个概念记录类型组成，只涉及行的描述，不涉及具体的值。概念模式的一个具体值称为模式的一个实例，同一个模式可以有很多实例。概念模式反映的是数据库的结构及其联系，所以是相对稳定的；而实例反映的是数据库某一时刻的状态，所以是相对变动的。需要说明的是，概念模式不仅要描述概念记录类型，还要描述记录间的联系、操作、数据的完整性和安全性等要求。但是，概念模式不涉及存储结构、访问技术等细节。只有这样，概念模式才算做到了“物理数据独立性”。描述概念模式的数据定义语言称为“模式DDL” 2.外模式外模式也称用户模式或子模式，是用户与数据库系统的接口，是用户用到的那部分数据的描述。它由若干个外部记录类型组成。用户使用数据操纵语言对数据库进行操作，实际上是对外模式的外部记录进行操作。描述外模式的数据定义语言称为“外模式DDL”。有了外模式后，程序员不必关心概念模式，只与外模式发生联系，按外模式的结构存储和操作数据。 3.内模式内模式也称为存储模式，是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。需要定义所以的内部记录类型、索引和文件的组织方式，以及数据控制方面的细节。例如，记录的存储方式是顺序存储、B树结构存储还是Hash方法存储；索引按照什么方式组织；数据是否压缩存储，是否加密；数据的存储记录结构有何规定。需要说明的是，内部记录并不涉及物理记录，也不涉及设备的约束。比内模式更接近于物理存储和访问的那些软件机制是操作系统的一部分（即文件系统）。例如，从磁盘上读、写数据。描述内模式的数据定义语言称为“内模式DDL”。总之，数据按外模式的描述提供给用户；按内模式的描述存储在磁盘上；而概念模式提供了连接这两级模式的相对稳定的中间层，并使得两级中任意一级的改变都不受另一级的牵制 4.三级模式两级映像数据库系统在三级模式之间提供了两级映像：模式/内模式的映像、外模式/模式的映像。这两级映射保证了数据库中的数据具有较高的物理独立性和逻辑独立性。 模式/内模式的映像：实现概念模式到内模式之间的相互转换。 外模式/模式的映像：实现外模式到概念模式之间的相互转换。 数据的独立性是指数据与程序独立，将数据的定义从程序中分离出去，由DBMS负责数据的存储，从而简化应用程序，大大减少应用程序编制的工作量。数据的独立性是由DBMS的二级映像功能来保证的。数据的独立性包括数据的物理独立性和数据的逻辑独立性。数据的物理独立性是指当数据库的内模式发生改变时，数据的的逻辑结构不变。由于应用程序处理的只是数据的逻辑结构，这样物理独立性可以保证，当数据的物理结构改变了，应用程序不用改变。但是，为了保证应用程序能够正确执行，需要修改概念模式/内模式之间的映像。数据的逻辑独立性是指用户的应用程序与数据库结构是相互独立的。数据的逻辑结构发生变化后，用户程序也可以不修改。但是，为了保证应用程序能够正确执行，需要修改外模式/概念模式之间的映像。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EC-FINAL I Misunderstood Missing]]></title>
    <url>%2F2019%2F04%2F25%2FEC-FINAL-I%2F</url>
    <content type="text"><![CDATA[写此篇记录EC-FINAL 铁牌。I Misunderstood … Missing此题，是EC打铁的主要原因。在牛客的那个网站上此题出的比F题还要多，然而我在比赛中却没有写出来，如果这题写出来了，可能还有救。对于这题DP没写出来，感觉是真的傻逼。以后打比赛切记不可以慌张，慌张并不能解决问题，这题如果静下心来思考应该不难想出来。题意：t 组数据 n 个回合初始战力 A 为 0 后面有n 个回合，每个回合可以进行一个操作1可以造成A+a点伤害2每个回合战力加b3直接提升 c 点战斗力问最多能造成多少点伤害题解：DP求解 dp[i][j]为j 个回合进行了第一种操作，操作的下标和为j。如果把1 2 3 三种操作的伤害区分开来，1 操作就是直接造成 a 点伤害。 2 操作会对后面的A造成影响，仔细思考一下加入 2 操作是 第 i 个 后面进行了 j 次攻击 ,能够发现 2 操作 最终造成的伤害和是 （下标和 - i * j ） b 点伤害。举个例子：如果 你在 2 3 进行了攻击,你在第1个回合进行了2操作 那么贡献就 是 (2+3 - 1 * 2)*b。理解了这个 3 操作就更简单了，直接就是j*c的伤害。看到这里也差不多明白，这个DP是从后往前DP的。后面的状态永远都不会影响到前面。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &quot;bits/stdc++.h&quot;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout &lt;&lt; &quot;[&quot; &lt;&lt; x &lt;&lt; &quot;]&quot; &lt;&lt; endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const long long mod = 1e9 + 7;const int maxn = 6e3 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen(&quot;../data.in&quot;, &quot;r&quot;, stdin);#endif return;&#125;LL dp[maxn][105];LL a[105], b[105], c[105];int main() &#123; f(); int t, n; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%lld%lld%lld&quot;, &amp;a[i], &amp;b[i], &amp;c[i]); &#125; memset(dp, -1, sizeof(dp)); dp[n][1]=a[n]; for (int i = n - 1; i &gt;= 1; i--) &#123; for (int j = maxn-1; j&gt;=0; j--) &#123; for (int l = 0; l &lt;= n; l++) &#123; if(dp[j][l]==-1)continue; if(j+i&lt;maxn)dp[j+i][l+1]=max(dp[j+i][l+1],dp[j][l]+a[i]); dp[j][l]=max(dp[j][l]+c[i]*l,max(dp[j][l],dp[j][l]+b[i]*(j-l*i))); &#125; &#125; &#125; LL ans=0; for(int i=0; i&lt;=n; i++) &#123; for(int j=0; j&lt;maxn; j++) &#123; ans=max(dp[j][i],ans); &#125; &#125; printf(&quot;%lld\n&quot;,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ sock编程学习笔记]]></title>
    <url>%2F2019%2F04%2F19%2FC%2B%2B-sock%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[主机字节序和网络字节序CPU累加器一次能装载至少4个字节，即一个整数。字节序分为大端字节序和小端字节序。大端字节序高位字节（23-31bit）储存在内存的低处，低位字节储存在高地址初。小端字节序恰恰相反。大部分PC电脑电脑使用小端字节序，所以又被称为主机字节序。大端字节序被称为网络字节序。JAVA虚拟机使用的是大端字节序4个函数函数用来完成字节序转换。123456// #include&lt;netinet/in.h&gt; //linux 下头文件#include&lt;winsock2.h&gt; //window 下头文件unsigned long htonl(unsigned long); //host to net 转换IPunsigned long ntohl(unsigned long); //net to host 转换IPunsigned short htons(unsigned short); //host to net 转换端口unsigned short ntohs(unsigned short); //net to host 转换端口]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>笔记</tag>
        <tag>sock 编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选拔赛Tulip Festival及其进阶]]></title>
    <url>%2F2019%2F04%2F16%2F%E9%80%89%E6%8B%94%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[线段树动态开点，对于这题顺便挂个自己学校OJ Tulip Festival以及后面跟着的几个版本，用线段树动态开点都能过。题意：给 n 个数字,m个操作操作两种:1 把p修改成x2 查询 [l,r]区件类与 [l,r]区间异或和不相等的数字个数。 题解：把每个数字的下标放到一个数组，区间异或和直接用树状数组求出来(对于不会用树状数组求区间异或和的多去做做树状数组基础题)然后每次查询区间里面的有个数字和异或值相等即可。有一个版本只有200个相同值，这个直接用vector存，然后暴力查找就行了。但是后面出现了大量相同的数字，就不能暴力了。查询区间类有多少个值，可以用树状数组最简洁，但是明显1e6个数，每个数开一个树状数组，长度为1e6明显炸了。用线段树，如果直接开空间每个都要开nlogn个点，明显也会炸。但是自信一想，其中有很多点都是无用的，所有数加起来个数最多不到1e6个点，所以用线段树动态开点，最多不会超过nlogn个点。线段树动态开点其实和普通的线段树其实差距不大。动态开点，就是把没有用的节点就不给他分配内存，字节当作空，这样每个数字最多最多开logn个点。动态开点建议用结构体写，这样可以方便一点。结构体设置3个值一个是当前节点保存的值，左右儿子下标举个例子，加入线段树总长度是 1 - 8,你在 1 1 插入一个值。那么你就需要 1-8 1-4 1-2 1-1这几个点开空间，其他点直接不用管，查询的时候直接返回0123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define bug printf("*********\n");#define debug(x) cout &lt;&lt; "[" &lt;&lt; x &lt;&lt; "]" &lt;&lt; endl;#define mid (l + r) / 2#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const long long mod = 1e9 + 7;const int maxn = 1e6 + 5 + 1e5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("../1.in", "r", stdin); freopen("../data.out", "w", stdout);#endif return;&#125;int tot, n, m;int a[maxn], bit[maxn];unordered_map&lt;int, int&gt; mp;int sum(int i) &#123; int ans = 0; while (i &gt; 0) &#123; ans ^= bit[i]; // debug(i); i -= i &amp; -i; &#125; return ans;&#125;void add(int i, int x) &#123; while (i &lt;= n) &#123; bit[i] ^= x; // debug(i); i += i &amp; -i; &#125;&#125;struct node &#123; int x; int chl, chr;&#125; tree[maxn * 50];int tt;void update(int a, int b, int l, int r, int k, int bol) &#123; if (b &lt; l || a &gt; r)return; else if (a &lt;= l &amp;&amp; r &lt;= b) &#123; if (bol)tree[k].x = 1; else tree[k].x = 0; &#125; else &#123; if (b &lt;= mid) &#123; if (tree[k].chl == 0) &#123; tree[k].chl = tt++; &#125; update(a, b, l, mid, tree[k].chl, bol); &#125; else &#123; if (tree[k].chr == 0) &#123; tree[k].chr = tt++; &#125; update(a, b, mid + 1, r, tree[k].chr, bol); &#125; int sum = 0; if (tree[k].chl != 0) &#123; sum += tree[tree[k].chl].x; &#125; if (tree[k].chr != 0) &#123; sum += tree[tree[k].chr].x; &#125; tree[k].x = sum; return; &#125;&#125;int querry(int a, int b, int l, int r, int k) &#123; if (b &lt; l || a &gt; r) &#123; return 0; &#125; else if (a &lt;= l &amp;&amp; r &lt;= b) &#123; return tree[k].x; &#125; else &#123; int sum = 0; if (tree[k].chl != 0) &#123; sum += querry(a, b, l, mid, tree[k].chl); &#125; if (tree[k].chr != 0) &#123; sum += querry(a, b, mid + 1, r, tree[k].chr); &#125; return sum; &#125;&#125;int main() &#123; f(); scanf("%d%d", &amp;n, &amp;m); tt = n + m + 1; for (int i = 0; i &lt; n; i++) &#123; int t; scanf("%d", &amp;t); add(i + 1, t); if (mp[t] == 0) &#123; mp[t] = ++tot; update(i + 1, i + 1, 1, n, tot, 1); &#125; else &#123; update(i + 1, i + 1, 1, n, mp[t], 1); &#125; &#125; // debug(sum(1)); while (m--) &#123; int op; scanf("%d", &amp;op); if (op == 1) &#123; int p, x; scanf("%d%d", &amp;p, &amp;x); int t = sum(p) ^sum(p - 1); update(p, p, 1, n, mp[t], 0); add(p, t ^ x); if (mp[x] == 0)mp[x] = ++tot; update(p, p, 1, n, mp[x], 1); assert(tt &lt; 5e7); &#125; else &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); int t = sum(r) ^sum(l - 1); //debug(t); if (mp[t] == 0)printf("%d\n", r - l + 1); else printf("%d\n", r - l + 1 - querry(l, r, 1, n, mp[t])); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D触发器和碰撞器]]></title>
    <url>%2F2019%2F03%2F26%2FUnity3D%E8%A7%A6%E7%A2%B0%E5%99%A8%E5%92%8C%E7%A2%B0%E6%92%9E%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Unity3d碰撞检测中碰撞器与触发器的区别要产生碰撞必须为游戏对象添加刚体（Rigidbody）和碰撞器，刚体可以让物体在物理影响下运动。碰撞体是物理组件的一类，它要与刚体一起添加到游戏对象上才能触发碰撞。如果两个刚体相互撞在一起，除非两个对象有碰撞体时物理引擎才会计算碰撞，在物理模拟中，没有碰撞体的刚体会彼此相互穿过。 物体发生碰撞的必要条件 两个物体都必须带有碰撞器(Collider)，其中一个物体还必须带有Rigidbody刚体。 在unity3d中，能检测碰撞发生的方式有两种，一种是利用碰撞器，另一种则是利用触发器。 碰撞器：一群组件，它包含了很多种类，比如：Box Collider（盒碰撞体），Mesh Collider（网格碰撞体）等，这些碰撞器应用的场合不同，但都必须加到GameObjecet身上。 触发器，只需要在检视面板中的碰撞器组件中勾选IsTrigger属性选择框。勾选Is Trigger 后不会有碰撞物理现象触发信息检测： 1.MonoBehaviour.OnTriggerEnter(Collider collider)当进入触发器 2.MonoBehaviour.OnTriggerExit(Collider collider)当退出触发器 3.MonoBehaviour.OnTriggerStay(Collider collider)当逗留触发器 碰撞信息检测： 1.MonoBehaviour.OnCollisionEnter(Collision collision) 当进入碰撞器 2.MonoBehaviour.OnCollisionExit(Collision collision) 当退出碰撞器 3.MonoBehaviour.OnCollisionStay(Collision collision) 当逗留碰撞器 12345678void OnTriggerEnter(Collider collider)&#123; //进入触发器执行的代码&#125;void OnCollisionEnter(Collision collision) &#123; //进入碰撞器执行的代码&#125;]]></content>
      <categories>
        <category>游戏</category>
        <category>U3D</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中南多校第一场]]></title>
    <url>%2F2019%2F03%2F18%2F%E4%B8%AD%E5%8D%97%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%80%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[源题目 2018-2019 ACM-ICPC Nordic Collegiate Programming Contest (NCPC 2018)&lt;/br&gt; 写一篇博客表示自己把题补了. &lt;/br&gt; A.Altruistic Amphibians简单DP，每个青蛙的重量总和不会超过 1e8，每一次影响的状态最多只有 1e8复杂度最高只有1e8dp[j]表示能支撑重量j最大高度是多少。dp[j-w[i]]=max(dp[j-w[i]],dp[j]);1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;x&lt;&lt;"]" &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e8+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;int a[maxn/10];struct node &#123; int l,w,h; bool operator&lt;(const node &amp; t) &#123; return w&gt;t.w; &#125;&#125; dat[maxn/10];int dp[maxn*2];int main() &#123; int n,d; scanf("%d%d",&amp;n,&amp;d); int mx=0; for(int i=0; i&lt;n; i++) &#123; scanf("%d%d%d",&amp;dat[i].l,&amp;dat[i].w,&amp;dat[i].h); mx=max(mx,dat[i].w); &#125; sort(dat,dat+n); int ans=0; for(int i=0; i&lt;n; i++) &#123; if(dp[dat[i].w]+dat[i].l&gt;d)ans++; for(int j=dat[i].w+1; j&lt;min(2*dat[i].w,maxn); j++) &#123; dp[j-dat[i].w]=max(dp[j-dat[i].w],dp[j]+dat[i].h); &#125; &#125; printf("%d\n",ans); return 0;&#125; B. Baby Bites水题都不解释12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#define fi first#define se second#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1#define pb push_back#define MP make_pair#define LL long long#define FIN freopen("in.txt","r",stdin)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt;pii;int n;string s;int main()&#123;#ifndef ONLINE_JUDGE FIN;#endif // ONLINE_JUDGE while(cin&gt;&gt;n) &#123; int falg= 1; for(int i = 1; i&lt;=n; i++) &#123; cin&gt;&gt;s; if(s=="mumble") continue; else &#123; int tmp = stoi(s); if(tmp!=i) &#123; falg = 0; &#125; &#125; &#125; if(falg)&#123; cout&lt;&lt;"makes sense"&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;"something is fishy"&lt;&lt;endl; &#125; &#125; return 0;&#125; C. Code Cleanups12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#define fi first#define se second#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1#define pb push_back#define MP make_pair#define LL long long#define FIN freopen("in.txt","r",stdin)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt;pii;const int mod = 1e9+7;const int MX = 3e3+5;int n;int vis[MX];int main()&#123;#ifndef ONLINE_JUDGE FIN;#endif // ONLINE_JUDGE while(~scanf("%d",&amp;n))&#123; memset(vis,0,sizeof(vis)); for(int i = 1,x;i &lt;= n;i++) &#123; scanf("%d",&amp;x); vis[x] = 1; &#125; int ans = 0; int sum = 0,cnt = 0; for(int i = 1;i &lt;= 365;i++) &#123; sum += cnt; if(sum &gt;= 20) &#123; ans++; sum = 0; cnt = 0; i--; continue; &#125; if(vis[i]) cnt++; &#125; if(cnt) ans++; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; D. Delivery Delays这题也挺简单的，不过出了不少bug记录一下。首先预处理出所有点直接的最近距离，然后再预处理出送完第j个回到1点然后一直等到 i 第i个订单的需要的时间，和用户最大等待时间。然后dp[i]保存送完第 i 个订单回到 1 的最小时间，然后再二分最大等待时间。最后写二分出了点问题，二分的范围 ，l 初值应该是-1而不是0;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;LL, int&gt; P;#define bug printf("*********\n");#define debug(x) cout &lt;&lt; "[" &lt;&lt; x &lt;&lt; "]" &lt;&lt; endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const long long mod = 1e9 + 7;const int maxn = 1e3 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f3f3f3f3f;const double eps = 1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif return;&#125;int n, m;struct edge &#123; int to, next; LL w;&#125; eg[maxn * 10];int head[maxn], tot;LL cost[maxn];void init() &#123; memset(head, -1, sizeof(head)); tot = 0;&#125;void add(int u, int v, LL w) &#123; eg[tot].to = v; eg[tot].w = w; eg[tot].next = head[u]; head[u] = tot++;&#125;LL dis[maxn][maxn];void dij(int u) &#123; memset(cost, inf, sizeof(cost)); priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; q; cost[u] = 0; q.push(P(cost[u], u)); while (q.size()) &#123; int v = q.top().second; LL w = q.top().first; q.pop(); if (cost[v] &lt; w)continue; else &#123; for (int i = head[v]; i != -1; i = eg[i].next) &#123; edge &amp;e = eg[i]; if (cost[e.to] &gt; w + e.w) &#123; cost[e.to] = w + e.w; q.push(P(cost[e.to], e.to)); &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; dis[u][i] = cost[i]; &#125;&#125;int q;LL s[maxn], to[maxn], t[maxn];LL dp[maxn];LL k[maxn][maxn];LL mx[maxn][maxn];int solve(LL m) &#123; memset(dp, inf, sizeof(dp)); dp[0] = 0; for (int i = 1; i &lt;= q; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; LL ti = dp[j], flag = 1; ti = max(ti, t[i]); if(mx[j][i]+ti&gt;m)flag=0; ti+=k[j][i]; if (flag == 0)continue; else &#123; dp[i] = min(dp[i], ti + dis[to[i]][1]); &#125; &#125; &#125; for(int i=1;i&lt;=q;i++)&#123; if(dp[i]==dp[maxn-1])return 0; &#125; return 1;&#125;int main() &#123; f(); scanf("%d%d", &amp;n, &amp;m); init(); for (int i = 0; i &lt; m; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, w); &#125; for (int i = 1; i &lt;= n; i++) &#123; dij(i); &#125; scanf("%d", &amp;q); to[0] = 1; for (int i = 1; i &lt;= q; i++) &#123; scanf("%lld%lld%lld", &amp;s[i], &amp;to[i], &amp;t[i]); &#125; for (int i = 1; i &lt;= q; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; LL ti,m=-inf; ti=0; int pos = j + 1, lat = 1; while (pos &lt;= i) &#123; ti += dis[lat][to[pos]]; if (ti - s[pos] &gt; m ) &#123; m=ti - s[pos]; &#125; lat = to[pos]; pos++; &#125; k[j][i]=ti; mx[j][i]=m; &#125; &#125; LL l = -1, r =inf; while (r &gt; l + 1) &#123; if (solve(mid))r = mid; else l = mid; &#125; printf("%lld\n", r); return 0;&#125; E. Explosion Exploit这题竟然没想到用 类似状压DP了，还一直想怎么十维数组了，唉。直接用一个long long 整数，前5位保存自己小兵的值，后5位保存对面小兵的值。后来发现这样写复杂度过不去。就算是记忆化搜索还是错的。应该用6位来保存还剩多少点血的小兵的个数。因为 前面一种搜索，31300和 13300不是同一种状态，除非排一下序。而后面这一种保存方式，全部都是102。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;x&lt;&lt;"]" &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;map&lt;LL,double&gt;mp;int n,m,k;double dfs(LL a,int u) &#123; if(mp.count(a)) &#123; return mp[a]; &#125; LL b=a; LL ans=0,a1=0,a2=0; for(int i=0; i&lt;12; i++) &#123; if(i&gt;=6) &#123; if(b%10!=0)a2+=b%10; b/=10; continue; &#125; ans+=(b%10)*(6-i); if(b%10!=0)a1+=b%10; b/=10; &#125;// debug(ans&lt;&lt;"a="&lt;&lt;a2); if(ans==0) &#123; mp[a]=1; return 1; &#125; if(ans&gt;u) &#123; mp[a]=0; return 0; &#125; double tp=0; if(a2==0) &#123; mp[a]=1; return 1; &#125; else &#123; LL tk=1; b=a; for(int i=0; i&lt;12; i++) &#123; if(b%10!=0) &#123; if(i==11||i==5)&#123; tp+=dfs(a-tk,u-1)*(b%10)*1.0/(a1+a2); &#125; else if(i&lt;6)&#123; tp+=dfs(a-tk+tk*10,u-1)*(b%10)*1.0/(a1+a2); &#125; else tp+=dfs(a-tk+tk*10,u-1)*(b%10)*1.0/(a1+a2); &#125; b/=10; tk*=10; &#125; &#125; mp[a]=tp; return tp;&#125;LL a;int b[2][10];int main() &#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=0 ; i&lt;n; i++) &#123; int p; scanf("%d",&amp;p); b[0][p]++; &#125; for(int i=0; i&lt;m; i++) &#123; int p; scanf("%d",&amp;p); b[1][p]++; &#125; for(int i=1; i&lt;=6; i++) &#123; a=a*10+b[0][i]; &#125; for(int i=1; i&lt;=6; i++) &#123; a=a*10+b[1][i]; &#125; printf("%.10f\n",dfs(a,k)); return 0;&#125;/*2 2 31 11 2*/ F * G 这两题有点难，没写出来。。。空着。。 H. House Lawn队友写的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;typedef long long LL;typedef long double lb;typedef pair&lt;int, int&gt; P;#define debug(x) cout&lt;&lt;"["&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define bug cout&lt;&lt;"*******************"&lt;&lt;endl;#define mem(a,b) memset(a,b,sizeof(a));#define fi first#define se second#define pb(x) push_back(x)const LL mod = 1e9+7;const int inf=0x3f3f3f3f;const int INF=0x7fffffff;const double eps = 1e-7;const double pi = acos(-1);const int maxn=1e6+5;int n, sum;string s, name[106];int stak[106], top = 0;int minp;struct node &#123; int id; LL p, c, t, r;&#125; lawn[107];LL solve(LL tm, LL tp, LL c, LL t, LL r) &#123; return (c*t*(tp/(t+r)))/sum;&#125;int main() &#123; //scanf("%d%d", &amp;sum, &amp;n); cin &gt;&gt; sum &gt;&gt; n; int ans = inf; int p, c, t, r; minp = INF; getchar(); for(int i = 1, len; i &lt;= n; ++i) &#123; getline(cin, s); len = s.length(); int tmp = 0; for(; s[tmp] != ',';++tmp) ; name[i] = s.substr(0, tmp); //cout &lt;&lt; name[i] &lt;&lt; endl; p = c = t = r = 0; for(++tmp; s[tmp] != ',';++tmp) p = p*10+s[tmp]-'0'; for(++tmp; s[tmp] != ',';++tmp) c = c*10+s[tmp]-'0'; for(++tmp; s[tmp] != ',';++tmp) t = t*10+s[tmp]-'0'; for(++tmp; tmp &lt; len;++tmp) r = r*10+s[tmp]-'0'; //cout &lt;&lt; p &lt;&lt;" "&lt;&lt; c &lt;&lt;" "&lt;&lt; t &lt;&lt;" "&lt;&lt; r &lt;&lt; endl; //cin &gt;&gt; p &gt;&gt; c &gt;&gt; t &gt;&gt; r; //scanf("%d%d%d%d", &amp;p, &amp;c, &amp;t, &amp;r); lawn[i].id = i; lawn[i].p = p; lawn[i].c = c; lawn[i].t = t; lawn[i].r = r; &#125; for(int i = 1; i &lt;= n; ++i) &#123; LL tp = 10080LL * (lawn[i].t+lawn[i].r) / __gcd(10080LL , 1LL*(lawn[i].t+lawn[i].r)); LL T = tp / 10080; LL tot = sum * T; LL tt = solve(tot, tp, lawn[i].c, lawn[i].t, lawn[i].r); //printf("i: %d, T: %lld, tp: %lld, tt: %lld\n", i, T, tp, tt); if(tt &gt;= T) &#123; //printf("OK\n"); if(minp &gt; lawn[i].p) &#123; minp = lawn[i].p; top = 1; stak[top] = lawn[i].id; &#125; else if(minp == lawn[i].p) &#123; top ++; stak[top] = lawn[i].id; &#125; &#125; &#125; for(int i = 1; i &lt;= top; ++i) &#123; cout &lt;&lt; name[stak[i]] &lt;&lt; "\n"; &#125; if(top == 0) cout &lt;&lt; "no such mower\n"; //printf("%d\n", ans); return 0;&#125;/*7000 49999 10 120 120999 1 120 2405499 2 25 355499 3 25 3510000 3aaa,1,1,1,1bbb,1,10000,10080,1ccc,1,10000,10079,1*/ I. Intergalactic Bidding大数，排序,没了。。因为保证 一个值等于另一个值的2倍以上。所以有且只有一种情况。能选就一定要选上123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;typedef long long LL;typedef long double lb;typedef pair&lt;int, int&gt; P;#define debug(x) cout&lt;&lt;"["&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define bug cout&lt;&lt;"*******************"&lt;&lt;endl;#define mem(a,b) memset(a,b,sizeof(a));#define fi first#define se second#define pb(x) push_back(x)const LL mod = 1e9+7;const int inf=0x3f3f3f3f;const int INF=0x7fffffff;const double eps = 1e-7;const double pi = acos(-1);const int maxn=1e6+5;const int MAXL = 6e3+5;const int MAXN = 9999;const int DLEN = 4 ;class big &#123;public: int a[MAXN],len; big (const char *s) &#123; int t,k,index=0,L=strlen(s); memset(a,0,sizeof(a)); len=L/DLEN; if(L%DLEN) len++; for(int i = L-1; i&gt;=0; i-=DLEN) &#123; t=0; k=i-DLEN + 1; if(k&lt;0) k=0; for(int j = k; j &lt;=i ; j++) t=t*10+s[j]-'0'; a[index++]=t; &#125; &#125; bool operator&lt;(const big &amp;t) const &#123; int ln; if(len&gt;t.len) return false; else if(len==t.len) &#123; ln=len-1; while(a[ln]==t.a[ln]&amp;&amp;ln&gt;=0) ln--; if(ln&gt;=0&amp;&amp;a[ln]&gt;t.a[ln]) return false; else return true; &#125; else return true; &#125; big operator-(const big &amp;T)const &#123; bool flag; big t1=*this,t2=T; flag=0; int b=t1.len; for(int i=0,j; i&lt;b; i++) &#123; if(t1.a[i]&lt;t2.a[i]) &#123; if(j=i+1); while(t1.a[j]==0) j++; t1.a[j--]--; while(j&gt;i) t1.a[j--]+=MAXN; t1.a[i]+=MAXN+1-t2.a[i]; &#125; else t1.a[i]-=t2.a[i]; &#125; t1.len=b; while(t1.a[t1.len-1]==0&amp;&amp;t1.len&gt;1) t1.len--,b--; return t1; &#125; void print() &#123; printf("%d",a[len-1]); for(int i=len-2; i&gt;=0; i--) &#123; printf("%04d",a[i]); &#125; &#125;&#125;;typedef pair&lt;big,string&gt; PS;vector&lt;PS&gt; v;int main() &#123; int n; char s[1005]; scanf("%d%s",&amp;n,s); big mx(s);// debug((mx&lt;big("0")&amp;&amp;big("0")&lt;mx));// mx.print(); char nam[100]; for(int i=0; i&lt;n; i++) &#123; scanf("%s%s",nam,s); v.push_back(PS(s,nam)); &#125; sort(v.begin(),v.end()); int l=v.size(); vector&lt;string&gt; ans; while(l--&gt;0) &#123; big b=v[l].first; if(b&lt;mx) &#123; ans.pb(v[l].se); mx=mx-b; &#125; &#125; big temp("0"); if(!(temp&lt;mx&amp;&amp;mx&lt;temp)) &#123; printf("0\n"); return 0; &#125; printf("%d\n",ans.size()); for(auto i:ans) &#123; cout&lt;&lt;i&lt;&lt;"\n"; &#125; return 0;&#125; J. Jumbled String首先更具a,d算出有多少个0 和 1 特判一下只有一个1的情况。更具这个可以判断出 01 10 这两种字符串就是 0 在1前面和1在0前面又多少个，还可以发现0在1前面和1在0前面的总和是一样的，更具这个可以判断有没有这样的字符串。然后在随便构造一个字符串就行了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;typedef long long LL;typedef long double lb;typedef pair&lt;int, int&gt; P;#define debug(x) cout&lt;&lt;"["&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define bug cout&lt;&lt;"*******************"&lt;&lt;endl;#define mem(a,b) memset(a,b,sizeof(a));#define fi first#define se second#define pb(x) push_back(x)const LL mod = 1e9+7;const int inf=0x3f3f3f3f;const int INF=0x7fffffff;const double eps = 1e-7;const double pi = acos(-1);const int maxn=1e6+5;LL a,b,c,d;LL zn=-1,on=-1;int main() &#123; while(~scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;d)) &#123; for(LL i=0; i&lt;1e5; i++) &#123; if(i*(i-1)&gt;2*a) &#123; break; &#125; else if(i*(i-1)==2*a) &#123; zn=i; &#125; &#125; for(LL i=0; i&lt;1e5; i++) &#123; if(i*(i-1)&gt;2*d) &#123; break; &#125; else if(i*(i-1)==2*d) &#123; on=i; &#125; &#125; if(a==0) &#123; if(b!=0||c!=0) &#123; zn=1; &#125; else zn=0; &#125; if(d==0) &#123; if(b!=0||c!=0) &#123; on=1; &#125; else on=0; &#125;// debug(zn);// debug(on); if(((b+c)!=on*zn)||zn==-1||on==-1) &#123; puts("impossible"); &#125; else &#123; LL k=(on==0)?0:((on*zn)-b)/on,num=(on==0)?0:((on*zn)-b)%on;// debug(k);// debug(num); for(int i=0; i&lt;zn+on; i++) &#123; if(i&lt;zn-k-1) &#123; printf("0"); &#125; else if(i&gt;zn+on-k-1) &#123; printf("0"); &#125; else if(i==zn-k+num-1) &#123; printf("0"); &#125; else printf("1"); &#125; puts(""); &#125; &#125; return 0;&#125; K. King’s Colors队友写的。。。不过这题就是一个容斥，是一颗树，所以能够保证一个节点的染色只合一个节点有关。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;typedef long long LL;typedef long double lb;typedef pair&lt;int, int&gt; P;#define debug(x) cout&lt;&lt;"["&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define bug cout&lt;&lt;"*******************"&lt;&lt;endl;#define mem(a,b) memset(a,b,sizeof(a));#define fi first#define se second#define pb(x) push_back(x)const LL mod = 1e9+7;const int inf=0x3f3f3f3f;const int INF=0x7fffffff;const double eps = 1e-7;const double pi = acos(-1);const int maxn=1e6+5;char s[10];int rint(char* t) &#123; int l=strlen(t); if(t[0]&lt;'0'||t[0]&gt;'9') &#123; return -1; &#125; else &#123; int i=0,ans=0; while(i&lt;l)&#123; ans=ans*10+t[i]-'0'; i++; &#125; return ans; &#125;&#125;//int a[maxn];LL ksm(LL a, int b) &#123; LL res = 1; for(;b;b&gt;&gt;=1,a=a*a%mod) &#123; if(b&amp;1) res = res*a%mod; &#125; return res;&#125;LL C[3005][3005];int main() &#123; C[1][1] = 1; for(int i = 2; i &lt; 3000; ++i) &#123; for(int j = 1; j &lt;= i; ++j) &#123; C[i][j] = (C[i-1][j]+C[i-1][j-1])%mod; &#125; &#125; LL n, k; scanf("%lld%lld",&amp;n, &amp;k); for(int i = 1, x; i &lt; n; ++i) &#123; scanf("%d", &amp;x); &#125; LL ans = 0, tmp; for(LL i = k, j = 0; i &gt;= 2; --i, j = !j) &#123; tmp = C[k+1][i+1] * i % mod * ksm(i-1, n-1) % mod; if(j == 0) ans = (ans+tmp)%mod; else ans = (ans - tmp)%mod; &#125; printf("%lld\n", (ans+mod)%mod); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HexoNext一些操作]]></title>
    <url>%2F2019%2F03%2F16%2FHexoNext%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[更改头像1.在主题配置文件中搜索 avatar2.3.找到这个路径修改就行了。4. 添加个人cssthemes\next\source\css\_custom修改这个文件 12345678910111213141516171819202122232425262728293031323334353637// Custom styles.@media screen and (min-width:1200px) &#123; body &#123; background:url(https://i.loli.net/2019/03/01/5c7942720fc39.png); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%; background-size: cover; &#125; #footer a &#123; color:#eee; &#125; .main-inner &#123; margin-top: 10px; opacity: 0.8; &#125; .header-inner &#123; margin-top: 10px; position: absolute; top: auto; overflow: hidden; padding: 0; width: 240px; background: #fff; box-shadow: initial; border-radius: initial; opacity: 1; &#125; .post &#123; margin-bottom: 30px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125;&#125;]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>配置</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用VScode 调试的时候提示Unable to start debugging]]></title>
    <url>%2F2019%2F03%2F02%2F%E4%BD%BF%E7%94%A8VScode%20%E8%B0%83%E8%AF%95%E7%9A%84%E6%97%B6%E5%80%99%E6%8F%90%E7%A4%BAUnable%20to%20start%20debugging%2F</url>
    <content type="text"><![CDATA[使用VScode 调试的时候提示Unable to start debugging. Launch options string provided by the project system is invalid. Unable to determine path to debugger. Please specify the “MIDebuggerPath” option. 提示这个错误。 翻译过来就是 miDebuggerPath他出错了。 如果你是在linux 下按照官网的陪应该就是 这个地方陪错了，要先下载gdb 在终端输入 apt-get install gdb 然后把gdb的路径丢进去就行了。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Deepin VSCODE安装C++环境]]></title>
    <url>%2F2019%2F03%2F02%2FDeepin-VSCODE%E5%AE%89%E8%A3%85C%2B%2B%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[首先]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>配置</tag>
        <tag>VScode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime快捷键集合]]></title>
    <url>%2F2019%2F03%2F02%2Fsublime%E5%BF%AB%E6%8D%B7%E9%94%AE%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Sublime Text 3 快捷键列表：精华版 Ctrl+Shift+P：打开命令面板 Ctrl+P：搜索项目中的文件 Ctrl+G：跳转到第几行 Ctrl+W：关闭当前打开文件 Ctrl+Shift+W：关闭所有打开文件 Ctrl+Shift+V：粘贴并格式化 Ctrl+D：选择单词，重复可增加选择下一个相同的单词 Ctrl+L：选择行，重复可依次增加选择下一行 Ctrl+Shift+L：选择多行 Ctrl+Shift+Enter：在当前行前插入新行 Ctrl+X：删除当前行 Ctrl+M：跳转到对应括号 Ctrl+U：软撤销，撤销光标位置 Ctrl+J：选择标签内容 Ctrl+F：查找内容 Ctrl+Shift+F：查找并替换 Ctrl+H：替换 Ctrl+R：前往 method Ctrl+N：新建窗口 Ctrl+K+B：开关侧栏 Ctrl+Shift+M：选中当前括号内容，重复可选着括号本身 Ctrl+F2：设置/删除标记 Ctrl+/：注释当前行 Ctrl+Shift+/：当前位置插入注释 Ctrl+Alt+/：块注释，并Focus到首行，写注释说明用的 Ctrl+Shift+A：选择当前标签前后，修改标签用的 F11：全屏 Shift+F11：全屏免打扰模式，只编辑当前文件 Alt+F3：选择所有相同的词 Alt+.：闭合标签 Alt+Shift+数字：分屏显示 Alt+数字：切换打开第N个文件 Shift+右键拖动：光标多不，用来更改或插入列内容 鼠标的前进后退键可切换Tab文件 按Ctrl，依次点击或选取，可需要编辑的多个位置 按Ctrl+Shift+上下键，可替换行 选择类 Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。 Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。 Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。 Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。 Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。 Ctrl+M 光标移动至括号内结束或开始的位置。 Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。 Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。 Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。 Ctrl+Shift+] 选中代码，按下快捷键，展开代码。 Ctrl+K+0 展开所有折叠代码。 Ctrl+← 向左单位性地移动光标，快速移动光标。 Ctrl+→ 向右单位性地移动光标，快速移动光标。 shift+↑ 向上选中多行。 shift+↓ 向下选中多行。 Shift+← 向左选中文本。 Shift+→ 向右选中文本。 Ctrl+Shift+← 向左单位性地选中文本。 Ctrl+Shift+→ 向右单位性地选中文本。 Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。 Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。 Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。 Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。 编辑类 Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。 Ctrl+Shift+D 复制光标所在整行，插入到下一行。 Tab 向右缩进。 Shift+Tab 向左缩进。 Ctrl+K+K 从光标处开始删除代码至行尾。 Ctrl+Shift+K 删除整行。 Ctrl+/ 注释单行。 Ctrl+Shift+/ 注释多行。 Ctrl+K+U 转换大写。 Ctrl+K+L 转换小写。 Ctrl+Z 撤销。 Ctrl+Y 恢复撤销。 Ctrl+U 软撤销，感觉和 Gtrl+Z 一样。 Ctrl+F2 设置书签 Ctrl+T 左右字母互换。 F6 单词检测拼写 搜索类 Ctrl+F 打开底部搜索框，查找关键字。 Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。 Ctrl+P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。 Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。 Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。 Ctrl+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。 Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。 Esc 退出光标多行选择，退出搜索框，命令框等。 显示类 Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。 Ctrl+PageDown 向左切换当前窗口的标签页。 Ctrl+PageUp 向右切换当前窗口的标签页。 Alt+Shift+1 窗口分屏，恢复默认1屏（非小键盘的数字） Alt+Shift+2 左右分屏-2列 Alt+Shift+3 左右分屏-3列 Alt+Shift+4 左右分屏-4列 Alt+Shift+5 等分4屏 Alt+Shift+8 垂直分屏-2屏 Alt+Shift+9 垂直分屏-3屏 Ctrl+K+B 开启/关闭侧边栏。 F11 全屏模式 Shift+F11 免打扰模式]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2019%2F02%2F27%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[此片文章主要用于记录一些简单的Markdown语法&lt;/br&gt;&lt;/br&gt;&lt;/br&gt; 标题123# 标题1级## 标题2级### 标题3级 标题1级标题2级标题3级文本12345正常文本**加粗文本***斜体文本 ****斜体加粗文本***~~中间加线文本~~ 正常文本加粗文本斜体文本 斜体加粗文本中间加线文本 引用123456&gt;引用&gt;&gt;二级引用&gt;&gt;&gt;以此内推&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的 引用 二级引用 以此内推这是引用的内容这是引用的内容 这是引用的 分割线1234---分割线----- 分割线 1![图片](https://i.loli.net/2019/02/27/5c767c74660a3.png) 图插入1![图片名](images/Markdown语法/20190301060640743.png) 超链接1[超链接](http://baidu.com) 超链接 列表无序列表12345- 无序列表- 1- 1* 1* 2 无序列表 1 1 1 2有序列表 1231.列表12.列表23.有序列表 1.列表12.列表23.有序列表 列表嵌套123456- 列表1 1.列表嵌套 3.列表2 4.列表3- 列表2 1.列表 下一级前3个空格 列表1 1.列表嵌套 3.列表2 4.列表3 列表2 1.列表 表格1234表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容 第二行分割表头和内容。-有一个就行，为了对齐，多加了几个 文字默认居左-两边加：表示文字居中-右边加：表示文字居右 表头 表头 表头 内容 内容 内容 内容 内容 内容 代码块12345var num = 0;for (var i = 0; i &lt; 5; i++) &#123; num+=i;&#125;console.log(num); ``` (此处写代码语言)中间可写入代码 ``` ` 一个点小型分块]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA环境配置]]></title>
    <url>%2F2019%2F02%2F27%2FJAVA%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本篇文章用于记录JAVA配置。 JAVA安装，百度搜索JAVA官网，下载对应系统版本，下载安装好后应该有 JDK 和JDR 两个文件夹 配置系统环境(1)新建-&gt;变量名”JAVA_HOME”，变量值 C:\Java\jdk1.8.0_05(你的JDK路径)(2)新建-&gt;变量名“CLASSPATH”,变量值 .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;第三个变量，如果已经有了Path变量应该直接编辑，然后再在背后添加变量(3)编辑-&gt;变量名”Path”，在原变量值的最后面加上 ;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin这个变量没配置好会出现没有javac这个指令 变量值是以 ； 区分几个变量值。在win10情况下，点击编辑Path路径能够看见一个图表 里面存有各个变量值，点击编辑文本可以看见变量值文本形式，两者对照看应该就能明白怎么给Path添加一个新的变量。 window 在控制台输入三个指令 java，javac，java -version 如果显示没有这个指令说明配置错误。]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>配置</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next 6.0 以上版本背景动画Canvas_nest设置无效]]></title>
    <url>%2F2019%2F02%2F25%2FNext%206.0%20%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC%E8%83%8C%E6%99%AF%E5%8A%A8%E7%94%BBCanvas_nest%E8%AE%BE%E7%BD%AE%E6%97%A0%E6%95%88%2F</url>
    <content type="text"><![CDATA[把这个下载一下 见官方文档 https://github.com/theme-next/theme-next-canvas-nest 在你的博客目录下 1git clone https://github.com/theme-next/theme-next-canvas-nest themes/next/source/lib/canvas-nest 就可以了]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity安装好SDK JDK 还是无法打包app 2019版本问题]]></title>
    <url>%2F2019%2F02%2F22%2FUnity%E5%AE%89%E8%A3%85%E5%A5%BDSDK%20JDK%20%E8%BF%98%E6%98%AF%E6%97%A0%E6%B3%95%E6%89%93%E5%8C%85app%20%20%202019%E7%89%88%E6%9C%AC%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[安装好SDK，JDK，打爆安卓软件还是出错。出现版本小了 弹出错误 CommandInvokationFailure: Failed to create a raw.ap_ package 1234567891011121314151617181920212223242526272829303132333435363738 CommandInvokationFailure: Failed to create a raw.ap_ packageH:\Program Files\Unity\Editor\Data\PlaybackEngines\AndroidPlayer/Tools\OpenJDK\Windows\bin\java.exe -Xmx4096M -Dcom.android.sdkmanager.toolsdir=&quot;H:/Program Files/android-sdk-windows\tools&quot; -Dfile.encoding=UTF8 -jar &quot;H:\Program Files\Unity\Editor\Data\PlaybackEngines\AndroidPlayer/Tools\sdktools.jar&quot; -stderr[Exception in thread &quot;main&quot; java.lang.reflect.InvocationTargetException at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at SDKMain.main(SDKMain.java:136)Caused by: java.lang.NoSuchMethodError: com.google.common.util.concurrent.MoreExecutors.directExecutor()Ljava/util/concurrent/Executor; at com.android.apkzlib.zip.ZFile.createSources(ZFile.java:1586) at com.android.apkzlib.zip.ZFile.makeStoredEntry(ZFile.java:1546) at com.android.apkzlib.zip.ZFile.add(ZFile.java:1625) at com.android.apkzlib.zip.ZFile.add(ZFile.java:1499) at com.android.apkzlib.sign.ManifestGenerationExtension.updateManifest(ManifestGenerationExtension.java:241) at com.android.apkzlib.sign.ManifestGenerationExtension.access$000(ManifestGenerationExtension.java:52) at com.android.apkzlib.sign.ManifestGenerationExtension$1.lambda$beforeUpdate$0(ManifestGenerationExtension.java:168) at com.android.apkzlib.zip.ZFile.notify(ZFile.java:2099) at com.android.apkzlib.zip.ZFile.update(ZFile.java:871) at com.android.apkzlib.zip.ZFile.close(ZFile.java:1161) at com.android.apkzlib.zfile.ApkZFileCreator.close(ApkZFileCreator.java:189) at UnityPackageBuilder.CreatePackage(UnityPackageBuilder.java:136) at UnityPackageBuilder.&lt;init&gt;(UnityPackageBuilder.java:70) at UnityPackageBuilder.main(UnityPackageBuilder.java:27) ... 5 more]stdout[]exit code: 1UnityEditor.Android.AndroidSDKTools.RunCommand (System.String javaExe, System.String sdkToolsDir, System.String[] sdkToolCommand, System.String workingdir, System.String errorMsg, System.Int32 memoryMB) (at &lt;7cbc688ae1af4105929402a46c6a4414&gt;:0)UnityEditor.Android.AndroidSDKTools.RunSDKToolWithReadLock (System.String[] command, System.String workingdir, System.String errorMsg) (at &lt;7cbc688ae1af4105929402a46c6a4414&gt;:0)UnityEditor.Android.PostProcessor.Tasks.AAPTPackage.CreatePackage (UnityEditor.Android.PostProcessor.PostProcessorContext context, System.String package, System.String directory, System.Boolean compress) (at &lt;7cbc688ae1af4105929402a46c6a4414&gt;:0)UnityEditor.Android.PostProcessor.Tasks.AAPTPackage.Pack (UnityEditor.Android.PostProcessor.PostProcessorContext context, System.String package, System.String directory, System.Boolean compress, System.Boolean useAAPT) (at &lt;7cbc688ae1af4105929402a46c6a4414&gt;:0)UnityEditor.Android.PostProcessor.Tasks.AAPTPackage.Execute (UnityEditor.Android.PostProcessor.PostProcessorContext context) (at &lt;7cbc688ae1af4105929402a46c6a4414&gt;:0)UnityEditor.Android.PostProcessor.PostProcessRunner.RunAllTasks (UnityEditor.Android.PostProcessor.PostProcessorContext context) (at &lt;7cbc688ae1af4105929402a46c6a4414&gt;:0)UnityEngine.GUIUtility:ProcessEvent(Int32, IntPtr) 这个是版本跟不上结果，要么更新SDK ，要么就是unity有一个use legecy SDK tool 选上就可以了]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装JAVA环境 java能用javac不能用]]></title>
    <url>%2F2019%2F02%2F22%2F%E5%AE%89%E8%A3%85JAVA%E7%8E%AF%E5%A2%83%20java%E8%83%BD%E7%94%A8javac%E4%B8%8D%E8%83%BD%E7%94%A8%2F</url>
    <content type="text"><![CDATA[安装java环境就不说了，百度一下一大片。重点是安装那个安装好后javac不能用。 这个大部分都是因为没有主义一下环境设置细节。 我把这几个打成代码免得不知道引号和空格是不是要输入的。。。 新建环境变量 变量名 1CLASSPATH 变量值 1.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; 新建环境变量 变量名 1JAVA_HOME 变量值 //是你安装JDK的路径别直接复制粘贴 1H:\Program Files\Java\jdk 前面两个是新建路径，一般不会有啥问题。后面这个一般是编辑，因为系统自带一部分路径。编辑就比较容易出错。 编辑环境变量 变量名 1Path 变量值 1C:\ProgramData\Oracle\Java\javapath;%java_home%\bin;%java_home%\jre\bin; 编辑之后应该是这个样子，一开始有一部分。 一般就是出错在这，大部分人看不懂那个路径就直接复制粘贴上去。就会出现这种情况 解决办法，点击右下角的编辑文本,把下面两个引号删除就可以了 然后你重新点击编辑变量值，应该是下面这个样子。 出现这种情况是因，你直接复制粘贴的这一段里面有分号，分号是环境变量的分割符，你输入的文本里面有分号，结果系统自动给你加了引号。 把分号去掉一段一段的输入也是可以的。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity 点击UI与点击屏幕冲突]]></title>
    <url>%2F2019%2F02%2F20%2FUnity%20%E7%82%B9%E5%87%BBUI%E4%B8%8E%E7%82%B9%E5%87%BB%E5%B1%8F%E5%B9%95%E5%86%B2%E7%AA%81%2F</url>
    <content type="text"><![CDATA[Unity 有点击屏幕进行移动操作，通过Input.GetMouseButtonDown(0)。如果点击到了一些UI上面会触发点击屏幕事件。 引入UnityEngine.EventSystems，用函数判断一下即可 12345678910111213141516 using System.Collections;using System.Collections.Generic;using UnityEngine;using DG.Tweening;using UnityEngine.EventSystems;public class PlayerController : MonoBehaviour&#123; private void Update() &#123; if (EventSystem.current.IsPointerOverGameObject()) return; if (Input.GetMouseButtonDown(0)) &#123; Debug.Log(&quot;点击屏幕&quot;); &#125; &#125;&#125; 这个方法会将点击Text的时候也会当作点击UI 将raycast target 取消勾选可以避免。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用虚拟机CentOS7 做服务器 搭建个人博客 详细教程 2019.02]]></title>
    <url>%2F2019%2F02%2F11%2F%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BACentOS7%20%E5%81%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%20%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%202019.02%2F</url>
    <content type="text"><![CDATA[服务器用的是CentOS7 , 我建在虚拟机上，像腾讯云什么的其实也是一样的。 虚拟机的安装就不说了，不懂的自己去百度下，一百度一大堆。 准备工作 没有给出下载连接，都是些常见的东西，如果实在找不到或者有疑问留下评论。 安装 有CentOS 虚拟机的 VMware (安装CentOS7 的时候记得打开网卡，不然后面要用命令行打开挺麻烦的，这个自己去百度怎么打开。) Xshell 6 同类型的连接服务器软件也可以，腾讯云或自己的连接也行。 start （先登录。。。。） 查看自己虚拟机 IP 指令：ip add 1ip add 如上图 就是IP4 的地址，然后通过Xshell6 连接 (为了模拟服务器连接，所以虚拟机直接后台运行，实际上直接在虚拟机处理也是一样，这里说一下连接服务器的方法) 新建一个连接 然后连接就可以了 关闭防火墙，也可以开一个端口。 为了方便我直接关闭防火墙。 12 systemctl stop firewalld.service #停止firewallsystemctl disable firewalld.service #禁止firewall开机启动 然后直接安装，httpd即可也就是Apache 指令：yum install httpd 1yum install httpd 然后启动服务 指令:systemctl start httpd.service 1systemctl start httpd.service 输入IP应该就能看见这个玩意了。 说明已经安装好了 然后就是安装mysql 因为没有mysql 源 所以先装一个。 指令：sudo rpm -Uvh http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm yum install mysql mysql-server mysql-libs mysql-server 12 sudo rpm -Uvh http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpmyum install mysql mysql-server mysql-libs mysql-server 然后启动一下这个mysql服务 systemctl restart mysql.service 123 systemctl restart mysql.service #重启mysql服务systemctl start mysql.service #启动mysql服务systemctl stop mysql.service #停止mysql服务 为mysql设置登陆密码，然后登陆，在创建一个wordpress 的数据库。 1234 /usr/bin/mysqladmin -u root password &apos;123456&apos; #后面这两个引号里面的是密码mysql -uroot --password=&apos;123456&apos; #输入登陆密码CREATE DATABASE wordpress; #创建wordpress数据库exit #退出mysql 然后再安装PHP 指令：yum install php-fpm php-mysql -y 123 yum install php-fpm php-mysql -yyum install phpyum install php-gd php-imap php-ldap php-odbc php-pear php-xml php-xmlrpc 启动PHP服务 再把它设置为开机启动。 12 service php-fpm startchkconfig php-fpm on 然后再把，Apache 和 mysql 设置成开机自动启动再重启一下服务 1234 systemctl enable httpd.servicesystemctl enable mysqld.servicesystemctl restart httpd.servicesystemctl restart mysqld.service 然后创建一个 php文件试试是不是成功装好了PHP 指令：vi /var/www/html/info.php (如果直接修改不了就进入这个文件夹里面先创建再修改) 1vi /var/www/html/info.php 然后按 i 进入输入模式，再输入 123 &lt;?phpphpinfo();?&gt; 然后按ESC 按 : 输入 wq 确定 ，保存退出。 然后再去浏览器输入 网址 你原本的ip/info.php 应该就是这个样子，然后，就去自己电脑上找wordpress 的文件 然后获得这个安装包 wget 刚才那个连接 如果显示 没有wget 先 输入 yum install wegt 先安装 1wget https://wordpress.org/latest.zip 然后在 解压 unzip latest.zip 如果显示没有unzip 一样的先输入 yum insatll unzip 1unzip latest.zip #是什么文件名就是解压什么文件 然后再复制到html 文件里面去 1cp -rf wordpress/* /var/www/html/ 再修改一下文件权限。 1chmod -R 777 html/ 然后输入IP应该就可以进入安装界面了。 然后一路点下去就行了，输入数据库名，还有数据库登陆账户和密码，就是登陆mysql的。用户名一般就是root。 如果出现这个，把里面内容复制一遍，创建一个wp-config.php文件然后复制粘贴进去就行了。 然后按提示一路下去就行了，如果后面装插件出了点问题，要FTP协议的话就去装一下 yum install vsftpd useradd admin passwd 123456systemctl enable vsftpd.service systemctl restart vsftpd.service 123456789 yum install vsftpduseradd adminpasswd 123456systemctl enable vsftpd.service systemctl restart vsftpd.service]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wordpress Error establishing a database connection Mysql80建立数据库连接时出错]]></title>
    <url>%2F2019%2F02%2F07%2FWordpress%20Error%20establishing%20a%20database%20connection%20Mysql80%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%97%B6%E5%87%BA%E9%94%99%2F</url>
    <content type="text"><![CDATA[建立数据库连接时出错 这或者意味着文件中的用户名和密码信息 wp-config.php 不正确，或者我们无法联系数据库服务器 localhost 。这可能意味着主机的数据库服务器已关闭。 您确定拥有正确的用户名和密码吗？ 您确定已键入正确的主机名吗？ 您确定数据库服务器正在运行吗？ 如果您不确定这些术语的含义，您应该联系您的主人。如果您仍需要帮助，可以随时访问WordPress支持论坛。 出现这个问题有几种可能，最常见几种就是用户名密码或者数据库名打错了。 还有一种可能就是你的mysql加密方式不一样。 先输入 use mysql ; 再输入 select host,user,plugin from user; 12 use mysql;select host,user,plugin from user; 查看加密方式，就是 plugin 这个下面显示。 caching_sha2_password 是一种新的加密方式，wp和discuz 有些版本 是不支持的。 所以这个时候要修改一下 输入指令 update user set plugin=’mysql_native_password’ where user=’root’; 1update user set plugin=&apos;mysql_native_password&apos; where user=&apos;root&apos;; 输入指令之后就是下面这个样子。输入这个指令之后 你原本的密码加密方式变了，所以你的密码也变了，如果你技术好，可以研究一下你的密码变成了多少，如果算不出来就老老实实改密码。注意：改密码必须指明加密方式，不然又会变回去。 输入指令：ALTER USER ‘root’@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘你的密码’; 1ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;; 然后在输入前面那个指令看一下 select host,user,plugin from user; 最后输入最后一个更新权限指令： flush privileges; 1flush privileges; 然后退出重启就行了。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github搭建个人博客 2019.2 详细教程]]></title>
    <url>%2F2019%2F02%2F04%2Fhexo%2Bgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%202019.2%20%20%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[大过年的，就去试试搭一个自己的博客，看了别人的博客，照着搭了一个，中间因为各种bug，试了半天哎。不过也是个很好理解github,hexo的法子，毕竟不出错，怎么会理解。中间还有些东西还没搞明白，希望大佬前来解答一下。 下面就开始搭建了。 准备工作 node.js https://nodejs.org/en/ 链接：https://pan.baidu.com/s/1-I1ROA_2rq4MDG1BFe0BqA 提取码：cnsz GIT https://git-scm.com/downloads 百度云链接：https://pan.baidu.com/s/1-I1ROA_2rq4MDG1BFe0BqA 提取码：cnsz (不要问为啥给你们放个百度云链接 ，我特么官网下不了，还找了半天) 安装好后确认一下： 装好后，在cmd 或者 power shell 里面打出这几个指令，就可以显示版本，也就是有这几个软件。 first 注册个github,这个小孩子玩意我就不和你们BB，自己去注册。 注册好后应该是个这样的瞎J B样子，然后创建一个仓库 仓库名: yourname**.github.oi** 进入setting 这个是你的仓库名，然后向下滑动。 上面那个网址，就是你可以外网访问的，你的服务器就是这个了。我们现在就是要把博客放上去。 在这个地方遇到了几个错误 1cd ~/.ssh 这个指令进入ssh,如果显示没有这个文件夹，那就直接创建文件夹BLOG 后面就是用来放博客文件的 进入文件夹，右击，git bash，(通过cmd,power shell 命令行进入也是一样的) 在命令行中输入指令 hexo init 初始化。 1hexo init 输入npm install，安装所需要的组件 1npm install 然后输入 hexo -g 静态部署 1hexo g 差不多就是这个样子，这个时候 博客已经可以访问了。 要看一下的话输入 hexo s 服务器启动 1hexo s 然后你输入一下 http://localhost:4000/ 就可以看一下 localhost 是本机的地址 ，端口是 4000 如果 4000 端口被用了的话可以换一个端口。 hexo server -p 端口号 指令是这个，发生什么我就不截图了。 应该是这个样子。 看完之后ctrl +c 停止运行服务器。 。 下一步就是把这个网页传到github 上去。 为了方便我们建一个 ssh git使用https协议，每次pull,push都要输入密码，使用git协议，使用ssh秘钥，可以省去每次输密码 一、本地生成密钥对； 二、设置github上的公钥； cd ~/.ssh ssh-keygen -t rsa -C “你创建那个github的邮箱” 12 cd ~/.sshssh-keygen -t rsa -C &quot;3035536707@qq.com&quot; 连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh ）找不到就用搜索。 如果显示没有这个文件夹，就先创建，再进入，就是把两个指令换一下输入。 用记事本打开这个 然后把里面的东西复制一下，应该是一大堆看不懂的东西。 然后就放到github上。 测试： 在终端 ssh -T git@github.com 添加好后 重新回到你创建的文件夹。 文本编辑一下这个文件 1234deploy: type: git repository: git@github.com:ETBUBBLE/ETBUBBLE.github.io.git branch: master 你的仓库地址就是是这个 这个是你前面看过的那个玩意，如果没有设置会出啥问题自己去试试。 然后重新回到命令行，进入 BLOG 文件夹 在生成以及部署文章之前，需要安装一个扩展 然后输入 hexo clean hexo d -g 12 hexo cleanhexo d -g 传到仓库去就可以了。 然后就再也没有然后了。 hexo new post “你的博客内容” 就可以发送出去了。 一个博客就搭好了，是不是特别简单。 补充绑定域名 去域名解析上面添加解析。 然后再在自己的github仓库里面新建一个CNAME文件，没有后缀 里面写上你的域名。 1www.etbubble.xyz 再去source创建一个CNAME文件和上面一样]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeCraft-19 and Codeforces Round 537 (Div. 2)]]></title>
    <url>%2F2019%2F02%2F04%2FCodeCraft-19%20and%20Codeforces%20Round%20537%20(Div.%202)%2F</url>
    <content type="text"><![CDATA[对于这一场我是内心崩溃的0.0 A. Superhero Transformation 我特么醉了，没任何难度，但是我数组开小了，少打了一个0.。。。。。。。。。。。。。。被fst. 123456789101112131415161718192021222324252627 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;const int maxn=1e7+5;int k[1000];int main() &#123; k[&apos;a&apos;]=1; k[&apos;e&apos;]=1; k[&apos;i&apos;]=1; k[&apos;o&apos;]=1; k[&apos;u&apos;]=1; char s[2000],t[2000]; cin&gt;&gt;s&gt;&gt;t; int l=strlen(s),l2=strlen(t),flag=1; if(l==l2) &#123; for(int i=0; i&lt;l; i++) &#123; if(k[s[i]]!=k[t[i]])flag=0; &#125; &#125; else flag=0; puts(flag?&quot;YES&quot;:&quot;NO&quot;); return 0;&#125; B. Average Superhero Gang Power 直接算就行了，然而我还是错了。直接枚举删除最小的 m个。 12345678910111213141516171819202122232425 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;const int maxn=1e5+5;int kk[maxn];int main() &#123; LL n,k,m; LL ans=0; cin&gt;&gt;n&gt;&gt;k&gt;&gt;m; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d&quot;,&amp;kk[i]); ans+=kk[i]; &#125; sort(kk,kk+n); double res=0; for(int i=0; i&lt;=min(m,n-1); i++) &#123; res=max(res,(double)(min((n-i)*k,m-i)+ans)/(n-i)); ans-=kk[i]; &#125; printf(&quot;%.10f\n&quot;,res); return 0;&#125; C. Creative Snap 这题好了，终于没有fst了，然而这题才是最崩溃的，一开始就想到了dfs,想了一下复杂度不行，不行你妹啊，然后发现可以，然后计算在区间 [l,r]之间有多少个数，我第一个想到了暴力，我特么想把自己给拍死，二分不行吗，二分不行吗？？？？？我得回到今天凌晨去把自己拍死。 1234567891011121314151617181920212223242526272829303132 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; p;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;const int maxn=1e5+5;int n,k,a,b;LL d[maxn];LL dfs(LL l, LL r,LL i,LL j,LL cnt) &#123; if(cnt&lt;=0) &#123; return a; &#125; else &#123; LL mid=(l+r)/2; LL a1=cnt*(r-l+1)*b; LL pos=upper_bound(d+i,d+j+1,mid)-d; if(r-l==0)return a1; return min(a1,dfs(l,mid,i,pos-1,pos-i)+dfs(mid+1,r,pos,j,j-pos+1)); &#125;&#125;int main() &#123; scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;k,&amp;a,&amp;b); for(int i=0; i&lt;k; i++) &#123; scanf(&quot;%d&quot;,&amp;d[i]); &#125; sort(d,d+k); LL ans=0; ans=dfs(1LL,1&lt;&lt;n,0LL,k-1,k); printf(&quot;%lld\n&quot;,ans); return 0;&#125; 最终掉分。。。。。。。。。原谅我的菜。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCPC-Wannafly Winter Camp Day2 E]]></title>
    <url>%2F2019%2F02%2F01%2FCCPC-Wannafly%20Winter%20Camp%20Day2%20E%2F</url>
    <content type="text"><![CDATA[Power of Function 这个题重点是读题。看懂函数，函数最终表示的是 n 写成K进制，K进制的值的和加上长度 -2 就是m。 给你一个 ，k,l,r,求K进制下，[l,r]区间内m的最大值。然后输出当m最大时[l,r]区间最大值和最小值。 题解：把l,r转换成K进制， r&gt;l，如果r,l,高位相同，那么求得到最大值M高位肯定也是和这个值一样。然后从第一个位不同开始，想让M值最大，只有两种可能，一种是取r这个值二进制下位减一，然后后面位的全部取 k-1,或者这个位取最大值再继续讨论下一个位。写个DFS就可以，和数位DP有点像。 举个例子 ：k=10 ,l=1001,r=1179. 10进制下 l = 1 0 0 1 r = 1 1 7 9 最前面 1 和 1 是相同的所以要 m最大 肯定 最高位也是 1 b=1 0 0 0 然后从第3位开始dfs(3) 要么这个位取 1， 要么 取 0 后慢慢全取 9， 如果这个位 取 1 就会影响下一个位，所以再DFS（2） 然后发现 要么取7 ，（要么 取 6 后面全为9） 以此类推，最后发现 后面3为 179 099 取得 后面比较大，那么m取最大就是 1099； 还有一些细节要注意，比如 179 ，99是一样打的，因为99只有两位数。还有 0 是没有 比他小1这个数，如果要小1就要向高位借，所以这情况要排除。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;int t;LL k,l,r;vector&lt;LL&gt; v1,v2,mi,mx;LL p[2000];LL dfs(LL pos,bool limit) &#123; if(pos==-1)return 0; if(limit) &#123; LL m1,m2; m1=dfs(pos-1,1); m2=dfs(pos-1,0); m1+=v2[pos]; m2+=v2[pos]-1; if(v2[pos]==0)m2=-1; //排除 为 r pos位 为0情况 if(pos==v2.size()-1&amp;&amp;v2[pos]==1)m2--; // 最高位为 0 m2要减一 if(m1&gt;m2) &#123; mx[pos]=mi[pos]=v2[pos]; return m1; &#125; else if(m1==m2) &#123; mx[pos]=v2[pos]; mi[pos]=v2[pos]-1; for(int i=0; i&lt;pos; i++) &#123; mi[i]=k-1; &#125; return m2; &#125; else &#123; mx[pos]=mi[pos]=v2[pos]-1; for(int i=0; i&lt;pos; i++) &#123; mi[i]=mx[i]=k-1; &#125; return m2; &#125; &#125; else &#123; return (k-1)*(pos+1); &#125;&#125;int cas=1;int main() &#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%lld%lld%lld&quot;,&amp;k,&amp;l,&amp;r); v1.clear(); v2.clear(); LL x=r; while(x&gt;0) &#123; v2.push_back(x%k); x/=k; &#125; x=l; while(x&gt;0) &#123; v1.push_back(x%k); x/=k; &#125; while(v1.size()&lt;v2.size()) &#123; v1.push_back(0); &#125; p[0]=1; for(int i=1; i&lt;v2.size(); i++) &#123; p[i]=p[i-1]*k; &#125; int pos=v2.size()-1; mi.resize(v2.size()); mx.resize(v2.size()); while(pos&gt;=0) &#123; if(v1[pos]==v2[pos]) &#123; mi[pos]=mx[pos]=v2[pos]; &#125; else break; pos--; &#125; if(pos!=-1)dfs(pos,1); LL a=0,b=0,m=0,flag=1; for(int i=mx.size()-1; i&gt;=0; i--) &#123; m+=mx[i]; if(mx[i]!=0)flag=0; if(flag)m--; b+=mx[i]*p[i]; a+=mi[i]*p[i]; &#125; m=m+mx.size()-2; printf(&quot;Case #%d: %lld %lld %lld\n&quot;,cas++,m,a,b); &#125; return 0; //看不懂留言0.0，或者加Q3035536707&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 CCPC-Wannafly Winter Camp Day2（Div2）]]></title>
    <url>%2F2019%2F01%2F28%2F2019%20CCPC-Wannafly%20Winter%20Camp%20Day2%EF%BC%88Div2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Camp 的题是真的难，还好没去，不然要被血虐。 做了Day2的几道题。 A题，Erase Numbers II 这个挺简单的，就是范围炸了long long ,暴力枚举两个数就行了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;//typedef long long LL;typedef unsigned long long LL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=6e3+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;int t,n;LL a[maxn],m1=0,ans1,ans2;LL k(LL x,LL y)&#123; LL k=x; while(k&gt;0)&#123; k/=10; y*=10; &#125; return y+x;&#125;int main() &#123; scanf(&quot;%d&quot;,&amp;t); int cas=1; while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); m1=0; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;a[i]; &#125; ans1=ans2=0; for(int i=0;i&lt;n;i++)&#123; for(int j=i+1;j&lt;n;j++)ans1=max(ans1,k(a[j],a[i])); &#125; printf(&quot;Case #%d: &quot;,cas++); cout&lt;&lt;ans1&lt;&lt;endl; &#125; return 0;&#125; B题：Erase Numbers I 题意：删除两个数，最后连起来的数字结果最大。 这题暴力过了，实际上暴力是过不了，本来要预处理一下，删除一个长度为 L的数字串，第一个不同的数字的位置， 比如：12 55 58 删除第二个 字符串的时候， 会变成 1258，和原字符串 125558 字符是 5 和8 不同（这个地方只是举例说明删一个字符串） 但是出题人好像没有特意卡，就直接暴力过了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;//#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot;&lt;&lt;endl;const int maxn=6e3+5;int a[maxn],b[maxn],t,n,mi,a1,a2;char s[maxn*10];char c[maxn][15];bool pd(int pos) &#123; int pos2=pos+1,i=0,j=0; // 就是这个地方要本来是要预处理的，但是暴力每次比较也可以过 while(1) &#123; if(c[pos][i]&lt;c[pos2][j]) &#123; return 1; &#125; else if(c[pos][i]&gt;c[pos2][j]) &#123; return 0; &#125; i++; j++; if(i==b[pos]) &#123; pos++; i=0; &#125; if(j==b[pos2]) &#123; pos2++; j=0; &#125; if(pos2==n)return 1; &#125;&#125;bool pd2(int pos) &#123; int pos2=pos+1,i=0,j=0; while(1) &#123; if(pos==a1)pos++; if(pos2==a1)pos2++; if(c[pos][i]&lt;c[pos2][j]) &#123; return 1; &#125; else if(c[pos][i]&gt;c[pos2][j]) &#123; return 0; &#125; i++; j++; if(i==b[pos]) &#123; pos++; i=0; &#125; if(j==b[pos2]) &#123; pos2++; j=0; &#125; if(pos2==n)return 1; &#125;&#125;int main() &#123; scanf(&quot;%d&quot;,&amp;t); int cas=1; while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); mi=100; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%s&quot;,c[i]); b[i]=strlen(c[i]); a[i]=0; for(int j=0; j&lt;b[i]; j++) &#123; a[i]=a[i]*10+c[i][j]-&apos;0&apos;; &#125; mi=min(mi,b[i]); &#125; a1=-1; for(int i=0; i&lt;n; i++) &#123; if(b[i]==mi) &#123; if(pd(i)) &#123; a1=i; break; &#125; &#125; &#125; if(a1==-1) &#123; for(int i=n-1; i&gt;=0; i--) &#123; if(b[i]==mi) &#123; a1=i; break; &#125; &#125; &#125; mi=100; a2=-1; for(int i=0; i&lt;n; i++) &#123; if(i==a1)continue; mi=min(b[i],mi); &#125; for(int i=0; i&lt;n; i++) &#123; if(i==a1)continue;; if(b[i]==mi) &#123; if(pd2(i)) &#123; a2=i; break; &#125; &#125; &#125; if(a2==-1) &#123; for(int i=n-1; i&gt;=0; i--) &#123; if(i==a1)continue; if(b[i]==mi) &#123; a2=i; break; &#125; &#125; &#125; printf(&quot;Case #%d: &quot;,cas++); for(int i=0; i&lt;n; i++) &#123; if(i==a1||a2==i)continue; printf(&quot;%d&quot;,a[i]); &#125; puts(&quot;&quot;); &#125; return 0;&#125; H题：Cosmic Cleaner 题意：问删除的球和原来给的这些球相交的体积有多少。 贴个求球相交的体积板子就行了0.0. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889 #include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#define CLR(a,b) memset(a,b,sizeof(a));using namespace std;const double PI = acos(-1);const int maxn= 105;typedef struct point &#123; double x,y,z; point() &#123; &#125; point(double a, double b,double c) &#123; x = a; y = b; z = c; &#125; point operator -(const point &amp;b)const &#123; //返回减去后的新点 return point(x - b.x, y - b.y,z-b.z); &#125; point operator +(const point &amp;b)const &#123; //返回加上后的新点 return point(x + b.x, y + b.y,z+b.z); &#125; //数乘计算 point operator *(const double &amp;k)const &#123; //返回相乘后的新点 return point(x * k, y * k,z*k); &#125; point operator /(const double &amp;k)const &#123; //返回相除后的新点 return point(x / k, y / k,z/k); &#125; double operator *(const point &amp;b)const &#123; //点乘 return x*b.x + y*b.y+z*b.z; &#125;&#125; point;double dist(point p1, point p2) &#123; //返回平面上两点距离 return sqrt((p1 - p2)*(p1 - p2));&#125;typedef struct sphere &#123;//球 double r; point centre;&#125; sphere;sphere s,a[maxn];void SphereInterVS(sphere a, sphere b,double &amp;v,double &amp;s) &#123; double d = dist(a.centre, b.centre);//球心距 double t = (d*d + a.r*a.r - b.r*b.r) / (2.0 * d);// double h = sqrt((a.r*a.r) - (t*t)) * 2;//h1=h2，球冠的高 double angle_a = 2 * acos((a.r*a.r + d*d - b.r*b.r) / (2.0 * a.r*d)); //余弦公式计算r1对应圆心角，弧度 double angle_b = 2 * acos((b.r*b.r + d*d - a.r*a.r) / (2.0 * b.r*d)); //余弦公式计算r2对应圆心角，弧度 double l1 = ((a.r*a.r - b.r*b.r) / d + d) / 2; double l2 = d - l1; double x1 = a.r - l1, x2 = b.r - l2;//分别为两个球缺的高度 double v1 = PI*x1*x1*(a.r - x1 / 3);//相交部分r1圆所对应的球缺部分体积 double v2 = PI*x2*x2*(b.r - x2 / 3);//相交部分r2圆所对应的球缺部分体积 v = v1 + v2;//相交部分体积 double s1 = PI*a.r*x1; //r1对应球冠表面积 double s2 = PI*a.r*x2; //r2对应球冠表面积 s = 4 * PI*(a.r*a.r + b.r*b.r) - s1 - s2;//剩余部分表面积&#125;int t, n;double x, y, z, r;int cas = 1;int main() &#123; cin &gt;&gt; t; while(t--) &#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%lf%lf%lf%lf&quot;,&amp;x,&amp;y,&amp;z,&amp;a[i].r); //其他球 a[i].centre = &#123;x,y,z&#125;; &#125; scanf(&quot;%lf%lf%lf%lf&quot;,&amp;x,&amp;y,&amp;z,&amp;r); s.r = r; s.centre = &#123;x,y,z&#125;; //中心球 double ans = 0, v = 0; for(int i = 1; i &lt;= n; i++) &#123; double ss, dis = dist(s.centre, a[i].centre); if(dis &gt;= s.r + a[i].r)continue; //在外部 if(dis + min(s.r, a[i].r) &lt;= max(s.r, a[i].r)) &#123; //在内部 ans += 4.0 / 3.0 * PI * min(s.r,a[i].r) * min(s.r,a[i].r) * min(s.r,a[i].r); continue; &#125; SphereInterVS(s, a[i], v, ss); //相交部分 ans += v; &#125; printf(&quot;Case #%d: %.14f\n&quot;,cas++,ans); &#125;&#125;//搜索板子，搜到的一名大佬的，我改都没改就直接过了0.0 K题：Sticks 预处理出所有分组情况，一共是 C(3,12)C(3,9)C(3,6) /24种。 15400种 让后暴力求解 15400*6000竟然判断过了0.0 题目没说要怎么输出答案，然后我用SET 错了，用vector 过了。。。。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot;&lt;&lt;endl;const int maxn=369605;int a[20];struct th &#123; short x[4][3]; bool operator&lt;(const th&amp; t) const &#123; &#125;&#125; dat,pa[maxn];int u[20],k=0;void dfs(int p) &#123; if(p==4) &#123; pa[k]=dat; k++; return ; &#125; for(int i=0; i&lt;12; i++) &#123; if(u[i])continue; if(dat.x[p-1][0]&gt;i)continue; //这个是去重的，会有重复的情况 for(int i2=i+1; i2&lt;12; i2++) &#123; if(u[i2])continue; for(int i3=i2+1; i3&lt;12; i3++) &#123; if(u[i3])continue; dat.x[p][0]=i; dat.x[p][1]=i2; dat.x[p][2]=i3; u[i]=u[i2]=u[i3]=1; dfs(p+1); u[i]=u[i2]=u[i3]=0; &#125; &#125; &#125;&#125;int t,cas=1;int main() &#123; dfs(0); debug(k); scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; for(int i=0; i&lt;12; i++) scanf(&quot;%d&quot;,&amp;a[i]); int num=0,ans; for(int i=0;i&lt;k;i++) &#123; int tnum=0; for(int j=0; j&lt;4; j++) &#123; int m1=a[pa[i].x[j][0]],m2=a[pa[i].x[j][1]],m3=a[pa[i].x[j][2]]; if(m1+m2&gt;m3&amp;&amp;m2+m3&gt;m1&amp;&amp;m3+m1&gt;m2)tnum++; &#125; if(tnum&gt;num) &#123; num=tnum; ans=i; &#125; if(num==4)break; &#125; printf(&quot;Case #%d: %d\n&quot;,cas++,num); if(num==0)continue; for(int j=0; j&lt;4; j++) &#123; int m1=a[pa[ans].x[j][0]],m2=a[pa[ans].x[j][1]],m3=a[pa[ans].x[j][2]]; if(m1+m2&gt;m3&amp;&amp;m2+m3&gt;m1&amp;&amp;m3+m1&gt;m2)&#123; printf(&quot;%d %d %d\n&quot;,m1,m2,m3); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-2019 ACM-ICPC, Asia Nanjing Regional Contest M]]></title>
    <url>%2F2019%2F01%2F23%2F2018-2019%20ACM-ICPC%2C%20Asia%20Nanjing%20Regional%20Contest%20M%2F</url>
    <content type="text"><![CDATA[2018-2019 ACM-ICPC, Asia Nanjing Regional Contest M 扩展KMP+马拉车回文串 s:ababa t:aba 题意：将第一个字符串的一个字串，与第二个字符串从 (0-k)的字符连在一起可以成为回文字符串，且第一个字符串字串的长度比第二个字符串的长度要大。 要构成的的回文字符串 两部分构成 s’ 第一个字符串的字串，和第二个字符串的前缀t’，构成一个回文字符串。 那么如果把第一个字符串倒过来， 那就相当于，s’ 的一部分是和 t’是相同的，s’还有一部分是回文字符串。 那么s’与t’相同的长度 * 从当前位置能够产生的回文串数量，就相当能够构成的回文串个数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot;&lt;&lt;endl;const int maxn=1e6+5;int nxt[maxn*2],ex[maxn*2];void getnext(char * str) &#123; int i=0,j,po,len=strlen(str); nxt[0]=len; while(i+1&lt;len&amp;&amp;str[i]==str[i+1])i++; nxt[1]=i; po=1,j=0; for(i=2; i&lt;len; i++) &#123; int p=nxt[po]+po; if(nxt[i-po]+i&lt;p) &#123; nxt[i]=nxt[i-po]; &#125; else &#123; j=p-i; if(j&lt;0)j=0; while(i+j&lt;len&amp;&amp;str[j]==str[j+i]) j++; nxt[i]=j; po=i; &#125; &#125;&#125;void exkmp(char *s1,char *s2) &#123; int i=0,j,po,len=strlen(s1),l2=strlen(s2); getnext(s2); while(s1[i]==s2[i]&amp;&amp;i&lt;l2&amp;&amp;i&lt;len)i++; ex[0]=i; po=0; for(i=1; i&lt;len; i++) &#123; int p=ex[po]+po; if(nxt[i-po]+i&lt;p) &#123; ex[i]=nxt[i-po]; &#125; else &#123; j=max(0,p-i); while(i+j&lt;len&amp;&amp;j&lt;l2&amp;&amp;s1[i+j]==s2[j]) &#123; j++; &#125; ex[i]=j; po=i; &#125; &#125;&#125;char Ma[maxn*2];int Mp[maxn*2],pos[maxn*2];int dp[maxn*2],cnt[maxn];void Manacher(char s[],int len) &#123; //一名大佬的写法0.0 memset(pos,-1,sizeof(pos)); int l=0; Ma[l++]=&apos;$&apos;; Ma[l++]=&apos;#&apos;; for(int i=0; i&lt;len; i++) &#123; pos[l]=i; Ma[l++]=s[i]; Ma[l++]=&apos;#&apos;; &#125; Ma[l]=0; int mx=0,id=0; for(int i=0; i&lt;l; i++) &#123; Mp[i]=mx&gt;i?std::min(Mp[2*id-i],mx-i):1; while(i-Mp[i]&gt;=0&amp;&amp;Ma[i+Mp[i]]==Ma[i-Mp[i]]) Mp[i]++; if(i+Mp[i]&gt;mx) &#123; mx=i+Mp[i]; id=i; &#125; &#125; for(int i=0; i&lt;l; i++) &#123; dp[i+Mp[i]-1]++; if(i&gt;0) dp[i-1]--; &#125; for(int i=l-1; i&gt;=0; i--) &#123; dp[i]+=dp[i+1]; &#125; for(int i=0; i&lt;l; i++) &#123; if(pos[i]==-1) continue; cnt[pos[i]]=dp[i]; &#125;&#125;char s[maxn],c[maxn];int main() &#123; scanf(&quot;%s%s&quot;,s,c); int len=strlen(s); reverse(s,s+len); Manacher(s,len); exkmp(s,c); LL ans=0; for(int i=1; i&lt;len; i++) &#123; ans+=1LL*cnt[i-1]*ex[i]; &#125; printf(&quot;%lld\n&quot;,ans); return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF201812 JAVA]]></title>
    <url>%2F2019%2F01%2F16%2FCCF201812%20JAVA%2F</url>
    <content type="text"><![CDATA[发现JAVA比C++慢了不止一星半点 C++能直接过，这个JAVA卡极限过了 第一二题，随便写一下没啥难度，直接写第4题的代码 CCF201812-4123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner input=new Scanner(System.in); int n,m,r; n=input.nextInt(); m=input.nextInt(); r=input.nextInt(); Point arr[]=new Point[m]; for(int i=0;i&lt;m;i++) arr[i]=new Point(); for(int i=0;i&lt;m;i++)&#123; arr[i].x=input.nextInt(); arr[i].y=input.nextInt(); arr[i].c=input.nextInt(); &#125; Arrays.sort(arr, new MyComprator()); int ans=0; int k=0; int []par=new int[m+1]; for(int i=1;i&lt;=m;i++)par[i]=i; for(int i=0;i&lt;m;i++)&#123; int x=find(arr[i].x,par),y=find(arr[i].y,par); if(x!=y) &#123; par[x] = y; ans = arr[i].c; k++; &#125; if(k==n-1)break; &#125; System.out.println(ans); &#125; static int find(int x,int[] par)&#123; return x==par[x] ? x : (par[x]=find(par[x],par)); &#125;&#125;class Point&#123; int x,y,c;&#125;class MyComprator implements Comparator &#123; public int compare(Object arg0, Object arg1) &#123; Point t1=(Point)arg0; Point t2=(Point)arg1; return t1.c&gt;t2.c? 1:-1; &#125;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 528 (Div. 2, based on Technocup 2019 Elimination Round 4)]]></title>
    <url>%2F2018%2F12%2F24%2FCodeforces%20Round%20528%20(Div.%202%2C%20based%20on%20Technocup%202019%20Elimination%20Round%204)%2F</url>
    <content type="text"><![CDATA[随手写一篇博客吧0.0 A. Right-Left Cipher 直接模拟，偶数在左边，奇数在右边。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;char s[maxn],t[maxn];int main() &#123; cin&gt;&gt;t; int l=strlen(t); int k=l-1; if(l&amp;1)k++; for(int i=0; i&lt;(l+1)/2; i++) &#123; s[k]=t[i]; k-=2; &#125; k=2; for(int i=(l+1)/2; i&lt;l; i++) &#123; s[k]=t[i]; k+=2; &#125; for(int i=1; i&lt;=l; i++)printf(&quot;%c&quot;,s[i]); return 0;&#125; B. Div Times Mod 直接暴力枚举啊，不就是 a*k+b=x b=n/a,直接暴力枚举n的因子。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;LL n,k;int main() &#123; cin&gt;&gt;n&gt;&gt;k; LL ans=inf*inf; for(LL i=1; i&lt;=n; i++) &#123; if(n%i==0&amp;&amp;n/i&lt;k) &#123; ans=min(ans,k*i+n/i); &#125; &#125; cout&lt;&lt;ans&lt;&lt;&quot;\n&quot;; return 0;&#125; C. Connect Three 直接想象怎么走最近，随便瞎几把写，数据有点水，我数组开小了都过了，结果被fst了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e3+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;int a[3],b[3];pair&lt;int,int&gt;p[3];int x[maxn*100],y[maxn*1000];int mp[maxn][maxn];int main() &#123; for(int i=0; i&lt;3; i++) &#123; scanf(&quot;%d%d&quot;,&amp;a[i],&amp;b[i]); p[i].first=a[i]; p[i].second=b[i]; &#125; sort(a,a+3); sort(b,b+3); sort(p,p+3); printf(&quot;%d\n&quot;,a[2]-a[0]+b[2]-b[0]+1); int x1=p[0].first,y1=p[0].second,x2=p[1].first,x3=a[2];// debug(x1);// debug(x2);// debug(x3); int k=0; for(int i=0;i&lt;=x2-x1;k++,i++)&#123; x[k]=x1+i; y[k]=y1; mp[x[k]][y[k]]=1; &#125; for(int i=0;i&lt;=b[2]-b[0];i++)&#123; if(mp[x2][b[0]+i])continue; x[k]=x2; y[k]=b[0]+i; mp[x[k]][y[k]]=1; k++; &#125; for(int i=1;i&lt;=x3-x2;i++)&#123; if(mp[x2+i][p[2].second])continue;// debug(y[0]); x[k]=x2+i; y[k]=p[2].second; k++;// debug(k); &#125; k=a[2]-a[0]+b[2]-b[0]+1; for(int i=0;i&lt;k;i++) printf(&quot;%d %d\n&quot;,x[i],y[i]); return 0;&#125; D. Minimum Diameter Tree 直径是通过权值分配来搞定的，要直径最大值最小。直径最大值肯定是从每一个叶子走到另一个叶子，所以直接算有多少个叶子，答案就是s*2.0/(叶子数量)。任意两个叶子之间的距离相同，就是最小。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;vector&lt;int&gt; G[maxn];int pre[maxn],in[maxn];int k[maxn],u[maxn];int main() &#123; int n; double s; scanf(&quot;%d%lf&quot;,&amp;n,&amp;s); for(int i=0; i&lt;n-1; i++) &#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); in[a]++; in[b]++; G[a].push_back(b); G[b].push_back(a); &#125; double ans=0; for(int i=1; i&lt;=n; i++) &#123; if(in[i]==1) &#123; ans+=1; &#125; &#125; printf(&quot;%.10f&quot;,s*2.0/ans); return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 526 (Div. 2)]]></title>
    <url>%2F2018%2F12%2F13%2FCodeforces%20Round%20526%20(Div.%202)%2F</url>
    <content type="text"><![CDATA[很久没写代码了。随便刷了一下CF C. The Fair Nut and String 先统计一下被’b’分隔的‘a’有多少个，放到一个数组里面，比如说，ababaaba a[0]=1,a[1]=1,a[2]=2,a[3]=1; 然后算一下总方案数，这个有点难解释，就是取这个之前所有的方案数*这个里面的个数，再加上只取这个里面的个数。 差不多就是这么算的:sum[i]=sum[i-1]*a[i]+a[i]; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;char s[maxn];LL ans[maxn];long long n,k,num,sum,ct;int main() &#123; scanf(&quot;%s&quot;,s); int l = strlen(s); k=0; ct=1; for(int i = 0 ; i &lt; l ; i ++) &#123; if(s[i]==&apos;a&apos;)&#123; n++; ct=0; &#125; if(s[i]==&apos;b&apos;)&#123; if(ct==0)ans[k++]=n; ct=1; n=0; &#125; &#125; if(!ct)ans[k++]=n; for(int i = 0 ; i &lt; k ; i++)&#123; sum+=sum*ans[i]; sum%=mod; sum+=ans[i]; sum%=mod; &#125; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125; D. The Fair Nut and the Best Path 这题是个树形DP，每次选最边上的节点，如果一个节点周围的节点只有一个没走过了就把这个节点加到队列里面取判断。 如果你选的节点是最大的油量中的一个，那么，一定等于周围两个最大且大于零的节点想加，且加上自己的油量。具体看代码吧，然后dp每次保存到这个节点最大油量。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,in[maxn];LL w[maxn],ans,dp[maxn];int used[maxn];struct two &#123; LL to,c;&#125;;int k;vector&lt;two&gt; G[maxn];int main() &#123; scanf(&quot;%d&quot;,&amp;n); for(int i = 1 ; i &lt;= n ; i ++) &#123; scanf(&quot;%lld&quot;,&amp;w[i]); &#125; two t; for(int i = 0 ; i &lt; n-1; i++) &#123; int u,v,c; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;c); t.c=c; t.to=v; G[u].push_back(t); t.to=u; G[v].push_back(t); in[u]++; in[v]++; &#125; queue&lt;int&gt;q; for(int i = 1 ; i &lt;= n ; i++) &#123; if(in[i]&lt;=1) &#123; q.push(i); &#125; &#125; LL max1=0,max2=0; LL ans=0; while(q.size()) &#123; int node=q.front(); q.pop(); max1=max2=0; for(auto i:G[node]) &#123; if(used[i.to]==1) &#123; LL temp=dp[i.to]-i.c; if(temp&gt;max1) &#123; swap(max1,temp); &#125; if(temp&gt;max2) &#123; swap(max2,temp); &#125; &#125; else &#123; in[i.to]--; if(in[i.to]&lt;=1)&#123; q.push(i.to); &#125; &#125; &#125; used[node]=1; LL temp=max1+max2+w[node]; ans=max(ans,temp); dp[node]=temp-max2; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[camera.ScreenToWorldPoint使用出现引用错误]]></title>
    <url>%2F2018%2F12%2F06%2Fcamera.ScreenToWorldPoint%E4%BD%BF%E7%94%A8%E5%87%BA%E7%8E%B0%E5%BC%95%E7%94%A8%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[使用camera.ScreenToWorldPoint出现如下错误 NullReferenceException: Object reference not set to an instance of an object PlayerController.FixedUpdate () (at Assets/Scenes/PlayerController.cs:37) 没有设置主相机]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity 3D 粒子播放]]></title>
    <url>%2F2018%2F12%2F03%2FUnity%203D%20%E7%B2%92%E5%AD%90%E6%92%AD%E6%94%BE%2F</url>
    <content type="text"><![CDATA[gameObject.GetCompoment().Play();播放 gameObject.GetCompoment().Pause();暂停 gameObject.GetCompoment().Stop();停止]]></content>
      <categories>
        <category>游戏</category>
        <category>U3D</category>
      </categories>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity3d开发中，用VS打开脚本文件不自动补全]]></title>
    <url>%2F2018%2F12%2F03%2Funity3d%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8C%E7%94%A8VS%E6%89%93%E5%BC%80%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6%E4%B8%8D%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%2F</url>
    <content type="text"><![CDATA[设置一下默认代码软件，这个是因为文件不是默认用VS打开的。 进入Edit-&gt;Preferences External Tools 把VS设成编辑器就可以了。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言实验十进制2进制16进制转换输出]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E8%BF%9B%E5%88%B62%E8%BF%9B%E5%88%B616%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[从键盘输入一个0–255之间的整数，在屏幕上显示出该整数对应的二进制和十六进制数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178 DATA SEGMENTMEG DB &apos;Please input a number(0~255):&apos;,0DH,0AH,&apos;$&apos;ME2 DB 0DH,0AH,&apos;Input a invalid number,exit!&apos;,0DH,0AH,&apos;$&apos;X DB ?Y DB 0AHBUF DB 10 DB ? DB 10 DUP(?)BU2 DB &apos;0&apos;,&apos;$&apos; DB 8 DUP(?) DATA ENDSCODE SEGMENT ASSUME DS:DATA,CS:CODESTART: MOV AX,DATA MOV DS,AX MOV AH,09H MOV DX,OFFSET MEG INT 21H MOV AH,0AH MOV DX,OFFSET BUF INT 21H MOV DL,BUF[1] CMP DL,3 JA ER MOV DL,BUF[2] CMP DL,0DH JZ PD CMP DL,&apos;0&apos; JB ER CMP DL,&apos;9&apos; JA ER SUB DL,&apos;0&apos; MOV X,DL MOV DL,BUF[3] CMP DL,0DH JZ PD CMP DL,&apos;0&apos; JB ER CMP DL,&apos;9&apos; JA ER MOV AL,X MUL Y SUB DL,&apos;0&apos; ADD AL,DL MOV X,AL MOV DL,BUF[4] CMP DL,0DH JZ PD CMP DL,&apos;0&apos; JB ER CMP DL,&apos;9&apos; JA ER SUB DL,&apos;0&apos; MOV AL,X CMP AL,19H JA ER MUL Y MOV BL,0FFH SUB BL,DL CMP AL,BL JA ER ADD AL,DL MOV X,ALPD: CMP X,0 JB ER CMP X,255 JA ER MOV AL,X MOV Y,AL CMP AL,0 JE XS MOV BL,BUF[1] MOV DI,BX MOV BU2[DI],&apos;$&apos; MOV BL,0AH AND AX,00FFH DIV BL DEC DI ADD AH,&apos;0&apos; MOV BU2[DI],AH MOV BL,AL CMP BL,0 JE XS MOV AL,BL MOV BL,0AH AND AX,00FFH DIV BL ADD AH,&apos;0&apos; DEC DI MOV BU2[DI],AH MOV BL,AL CMP BL,0 JE XS DEC DI MOV AL,BL MOV BL,0AH AND AX,00FFH DIV BL ADD AH,&apos;0&apos; MOV BU2[DI],AHXS: MOV AH,09H MOV DX,OFFSET BU2 INT 21H MOV AH,02H MOV DL,&apos;=&apos; INT 21H MOV CX,8 MOV AL,X SEC: MOV AL,Y MOV DI,CX MOV CL,1 ROL AL,CL MOV Y,AL AND AL,01H MOV DL,AL MOV AH,02H ADD DL,&apos;0&apos; INT 21H MOV CX,DI LOOP SEC MOV AH,02H MOV DL,&apos;B&apos; INT 21H MOV AH,02H MOV DL,&apos;=&apos; INT 21H MOV DL,X MOV CL,4 SHR DL,CL OR DL,30H CMP DL,39H JBE AD1 ADD DL,7AD1: MOV AH,2 INT 21H MOV DL,X AND DL,0FH OR DL,30H CMP DL,39H JBE AD2 ADD DL,7AD2: MOV AH,2 INT 21H MOV AH,02H MOV DL,&apos;H&apos; INT 21H MOV AH,4CH INT 21HER: MOV AH,09H MOV DX,OFFSET ME2 INT 21H MOV AH,4CH INT 21HCODE ENDS END START]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言实现显示16进制数]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E6%98%BE%E7%A4%BA16%E8%BF%9B%E5%88%B6%E6%95%B0%2F</url>
    <content type="text"><![CDATA[将内存单元存储的8个两位16进制数：01H, 25H, 38H, 62H, 8DH, 9AH, BAH, CEH依次显示在屏幕上。 直接转换。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 DATA SEGMENTBUF DB 01H,25H,38H,62H,8DH,9AH,0BAH,0CEHN DW $-BUFX DW 0DATA ENDSCODE SEGMENT ASSUME CS:CODE,DS:DATASTART: MOV AX,DATA MOV DS,AX MOV CX,NBE: MOV N,CX MOV BX,X MOV DL,BUF[BX] INC BX MOV X,BX CALL DELY MOV CX,N CMP CX,1 JE FINISH MOV DL,&apos;,&apos; MOV AH,2 INT 21H LOOP BEFINISH:MOV AX,4C00H INT 21HDELY PROC NEAR MOV BL,DL MOV CL,4 SHR DL,CL OR DL,30H CMP DL,39H JBE AD1 ADD DL,7AD1: MOV AH,2 INT 21H MOV DL,BL AND DL,0FH OR DL,30H CMP DL,39H JBE AD2 ADD DL,7AD2: MOV AH,2 INT 21H MOV DL,&apos;H&apos; MOV AH,2 INT 21H RETDELY ENDPCODE ENDS END START 打表法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 DATA SEGMENTBUF DB 01H,25H,38H,62H,8DH,9AH,0BAH,0CEHN DW $-BUFASCII DB 30H,31H,32H,33H,34H,35H,36H,37H,38H,39H DB 41H,42H,43H,44H,45H,46HX DW 0Y DB 0DATA ENDSCODE SEGMENT ASSUME CS:CODE,DS:DATASTART: MOV AX,DATA MOV DS,AX MOV CX,NBE: MOV N,CX MOV BX,X MOV DL,BUF[BX] INC BX MOV X,BX MOV CX,N CMP CX,1 JE FINISH MOV DL,&apos;,&apos; MOV AH,2 INT 21H LOOP BEFINISH:MOV AX,4C00H INT 21HDELY PROC NEAR MOV Y,DL MOV CL,4 SHR DL,CL MOV BX,OFFSET ASCII MOV AL,DL AND AL,0FH XLAT MOV DL,AL MOV AH,2 INT 21H MOV AL,Y AND AL,0FH XLAT MOV DL,AL MOV AH,2 INT 21H MOV DL,&apos;H&apos; MOV AH,2 INT 21H RETDELY ENDPCODE ENDS END START]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言实现冒泡法排序]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%86%92%E6%B3%A1%E6%B3%95%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[利用冒泡法排序算法，将内存单元存储的数35H，78H，25H，13H，8H，D2H由大到小进行排序。 1234567891011121314151617181920212223242526272829303132333435363738394041 DATA SEGMENTDAT DB 35H,78H,25H,13H,8H,0D2HDATA ENDSCODE SEGMENT ASSUME CS:CODE,DS:DATASTART: MOV AX,DATA MOV DS,AX MOV CX,5A1: MOV DI,CX MOV BX,0A2: MOV AL,DAT[BX] CMP AL,DAT[BX+1] JGE A3 XCHG AL,DAT[BX+1] MOV DAT[BX],ALA3: ADD BX,1 LOOP A2 MOV CX,DI LOOP A1 MOV DL,DAT[0] MOV CL,4 SHR DL,CL OR DL,30H CMP DL,39H JBE AD1 ADD DL,7AD1: MOV AH,2 INT 21H MOV DL,DAT[0] AND DL,0FH OR DL,30H CMP DL,39H JBE AD2 ADD DL,7AD2: MOV AH,2 INT 21H MOV AH,4CH INT 21HCODE ENDS END START]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言实现文本浏览器]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E6%B5%8F%E8%A7%88%E5%99%A8%2F</url>
    <content type="text"><![CDATA[运行程序后，屏幕显示“input number (1-3)：” 键入“1”后，显示“chapter1: introduction” 键入“2”后，显示“chapter2: designing method” 键入“3”后，显示“chapter3: experiment” 键入其他数字后，返回屏幕提示状态 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 data segmentstr db &apos;please input number(1-3):&apos;,&apos;$&apos;str1 db &apos;chapter1: introduction&apos;,&apos;$&apos;str2 db &apos;chapter2: designing method&apos;,&apos;$&apos;str3 db &apos;chapter3:experimenr&apos;,&apos;$&apos;table dw A1,A2,A3 data endscode segment assume cs:code,ds:datastart: mov ax,data mov ds,ax begin:mov dx,offset str mov ah,9 int 21h mov ah,01h int 21h cmp al,&apos;1&apos; jb finish cmp al,&apos;3&apos; ja finish and ax,000FH dec ax shl ax,1 mov bx,ax jmp table[bx] A1: mov dx,offset str1 mov ah,9 int 21h jmp enter A2: mov dx,offset str2 mov ah,9 int 21h jmp enter A3: mov dx,offset str3 mov ah,9 int 21h jmp enter finish: mov dl,0dh mov ah,2 int 21h mov dl,0ah int 21h jmp begin enter: mov ax,4c00h int 21hcode ends end start]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言实验将内存单元存储的字节数据的16进制数的低位输出到显示器并显示。]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%B0%86%E5%86%85%E5%AD%98%E5%8D%95%E5%85%83%E5%AD%98%E5%82%A8%E7%9A%84%E5%AD%97%E8%8A%82%E6%95%B0%E6%8D%AE%E7%9A%8416%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E4%BD%8E%E4%BD%8D%E8%BE%93%E5%87%BA%E5%88%B0%E6%98%BE%E7%A4%BA%E5%99%A8%E5%B9%B6%E6%98%BE%E7%A4%BA%E3%80%82%2F</url>
    <content type="text"><![CDATA[打表法： 1234567891011121314151617181920 DATA SEGMENTASCII DB 30H,31H,32H,33H,34H,35H,36H,37H,38H,39H DB 41H,42H,43H,44H,45H,46HHEX DB 0BHDATA ENDSCODE SEGMENT ASSUME CS:CODE,DS:DATASTART: MOV AX,DATA MOV DS,AX MOV BX,OFFSET ASCII MOV AL,HEX AND AL,0FH XLAT MOV DL,AL MOV AH,2 INT 21H MOV AX,4C00H INT 21HCODE ENDS END START 直接转换： 12345678910111213141516171819 DATA SEGMENTHEX DB 0BHDATA ENDSCODE SEGMENT ASSUME CS:CODE,DS:DATASTART: MOV AX,DATA MOV DS,AX MOV DL,HEX AND DL,0FH OR DL,30H CMP DL,39H JBE AD1 ADD DL,7AD1: MOV AH,2 INT 21H MOV AX,4C00H INT 21HCODE ENDS END START]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编实现大小字母转换]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B1%87%E7%BC%96%E5%AE%9E%E7%8E%B0%E5%A4%A7%E5%B0%8F%E5%AD%97%E6%AF%8D%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[从键盘键入一个大写英文字母，存放到内存单元BUF1中，再转化为对应的小写字母，存放到内存单元BUF2中。 1234567891011121314151617181920 data segmentbuf1 db ?buf2 db ?data endscode segmentassume ds:data,cs:codebegin:mov ax,datamov ds,axmov ah,01int 21hmov buf1,aladd al,20hmov buf2,almov dl,almov ah,02int 21hmov ah,4chint 21hcode endsend begin]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编实现一个简单加法程序。]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B1%87%E7%BC%96%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E5%8A%A0%E6%B3%95%E7%A8%8B%E5%BA%8F%E3%80%82%2F</url>
    <content type="text"><![CDATA[汇编语言，写一个简单加法程序“3+5=8”，加数和结果分别存在内存单元NUM1、NUM2、NUM3中。 12345678910111213141516 data segment num1 db 3 num2 db 5 num3 db ?data endscode segmentassume cs:code,ds:data start:mov ax,data mov ds,ax mov al,num1 add al,num2 mov num3,al mov ax,4c00h int 21hcode endsend start]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-CCSP杭州]]></title>
    <url>%2F2018%2F10%2F30%2F2018-CCSP%E6%9D%AD%E5%B7%9E%2F</url>
    <content type="text"><![CDATA[作为一个只学了一年的菜鸡，没想到竟然在CCSP上拿了一块金。只能说运气不错。 https://git.thusaac.org/publish/CCSP2018]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF 2018-09 题解]]></title>
    <url>%2F2018%2F09%2F17%2FCCF%202018-09%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[CCF 201809 1.就是求平均值，第一个和最后一个特判一下。 2.这题两种思路：第一种，直接n*n的判断有没有交叉的区间，有就直接加上去。第二种直接模拟时间轴，时间轴最大只有1e6，那个区间如果有覆盖就直接+1，然后两个人的区间覆盖，如果两个人都有这个区间就是2，数组为2的个数加起来就行了。由于区间长度是S-T，其实这个相当于[s,t),有一个是开区间。 3.请见 政大佬 4.记忆化DFS，开一个vis[400][400][400]的数组，vis[pos][i][j],pos表示位置，i，表示当前位置的值，j,表示前一个位置的值。然后就暴力枚举所有的值，如果那个值和前面一个的值已经访问过了就直接返回0。从小往大搜索，这样就可以保证字典序最小。 这题可以用第一题对拍一下哈哈 主要考点: 1.平均值，知道a[pos],b[pos-1],b[pos]可以推出b[pos+1]只有3种取值(满足(b[pos-1]+b[pos]+b[pos+1])/3==a[pos])； 2 记忆化搜索，因为每种状态后面都有3种取值所以暴力是，3^100复杂度，明显超时。所以要剪枝，就是前面说的vis数组。这样所有状态最多跑一次，总复杂度300^3,（实际上没有这么大）可以过。 5.你能开这一题，可以直接跳过我博客了。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[长沙理工集训队-9.11日组队赛]]></title>
    <url>%2F2018%2F09%2F15%2F%E9%95%BF%E6%B2%99%E7%90%86%E5%B7%A5%E9%9B%86%E8%AE%AD%E9%98%9F-9.11%E6%97%A5%E7%BB%84%E9%98%9F%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[好久没写博客了，写篇博客放松一下。 外网OJ：http://csustacm.com:4803/ 1题我就不写了这题写了也没啥意义。 2.黄金矿工 Description 游戏中有n个宝石，每个宝石有一个价值vi，每次挖出这个宝石需要时间ti。因为有些宝石被另外一个宝石挡住了（两个宝石在同一直线上），一个宝石最多挡住一个宝石，一个宝石最多被一个宝石挡住。要先捡起挡路的宝石，才能捡起该宝石。每个宝石的挡路宝石为fi，如果没有挡路宝石fi = 0，即它自己(题目保证没有环，且不存在)。 游戏的时间限制是t秒，在t秒内你获得最大价值和是多少？ Input 第一行一个整数T，表示接下来有T组数据。（T &lt;= 50） 每组数据格式如下： 第一行两个整数n（1&lt;=n&lt;=200），t（1&lt;=t&lt;=100,000,000） 接下来n行，每行三个整数vi（1&lt;=vi&lt;=50），ti（1&lt;=ti&lt;=1000,000），（0&lt;=fi&lt;=n） Output 输出获得的最大价值和 Sample Input 1 11 5 10 2 1 0 5 3 1 3 2 0 1 4 3 4 6 4 Sample Output 1 111 题意：挖宝石，挖某个宝石前可能有一个宝石，一个宝石也只能阻难一个宝石，挖某个宝石要消耗时间ti获得价值vi，问T=t秒最多可以挖宝石的最大价值。 题解：看了下数据范围，肯定是以价值DP，求价值的最小时间，如果时间小于所给定的时间就可以挖到相应价值。 首先处理下，每个宝石前后最多只有一个，肯定是一条链，把每条链处理一下（假如一条链是1-&gt;2-&gt;3,那么这条链上就有3个节点分别保存2个值，挖到1，(v1,t1）挖到2，（v1+v2,t1+t2）挖到3,(v1+v2+v3,t1+t2+t3))。最多只有200条链，所以不用担心超时。 每条链保存 两个值，价值和所需要的时间。然后在DP就行了。因为每条链上只能选一个值所以DP肯定要开二维。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 #include&lt;bits/stdc++.h&gt;#define fi first#define se secondusing namespace std;#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot;&lt;&lt;endl;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;const int maxn=1e3+7;const int inf=0x3f3f3f3f;int n, m, tot;int son[maxn];int in[maxn], v[maxn], t[maxn], vis[maxn];vector&lt;P&gt; ar[maxn];int dp[205][10005];void dfs(int u,int val,int tim) &#123; //用DFS，一条链 vis[u] = 1; ar[tot].push_back(make_pair(val+v[u],tim+t[u])); if(son[u] == 0)return; dfs(son[u],val+v[u],tim+t[u]);&#125;int main() &#123; int tim; scanf(&quot;%d&quot;, &amp;tim); while(tim--) &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int sum = 0; for(int i = 0; i &lt;= n; ++i) &#123; son[i]=vis[i]=0; ar[i].clear(); &#125; for(int i = 1, u; i &lt;= n; ++i) &#123; scanf(&quot;%d%d%d&quot;, &amp;v[i], &amp;t[i], &amp;u); sum += v[i]; //if(u == 0)continue; son[u] = i; &#125; tot = 0; for(int i = 1; i &lt;= n; ++i) &#123; if(vis[i] == 0) &#123;//如果这个节点没有父亲，就说明这有一条链。 dfs(i, 0, 0); tot++; &#125; &#125; memset(dp, 0x3f, sizeof(dp)); for(int i = 0; i &lt; tot; ++i) &#123; 。 ar[i].push_back(make_pair(0, 0));//每个链肯定可以一个都不挖，所以0 ，0要加进去。 sort(ar[i].begin(),ar[i].end()); &#125; int sz = ar[0].size(); for(int i = 0; i &lt; sz; ++i) &#123;//dp初始化 dp[0][ar[0][i].fi] = ar[0][i].se; &#125; for(int i = 1; i &lt; tot; ++i) &#123; sz = ar[i].size(); for(int j = 0; j &lt; sz; ++j) &#123; for(int k = sum; k &gt;= ar[i][j].fi; --k) &#123; dp[i][k] = min(dp[i-1][k-ar[i][j].fi]+ar[i][j].se,dp[i][k]); &#125; &#125; &#125; int ans = 0; for(int i = sum; i &gt;= 0; --i) &#123; if(dp[tot-1][i]&lt;=m) &#123; //找第一个小于等于给定时间的价值 ans = i; break; &#125; &#125; printf(&quot;%d\n&quot;, ans); &#125; return 0;&#125; 3.精灵王国 Description 小J离开了神秘群岛之后，来到了繁华的精灵王国。 精灵王国中有n个城市，现在已知第 i 个城市和第 i + 1个城市之间有一条长度为d[i]的双向道路。（特别的，第n个城市和第1个城市之间有一条长度为d[n]的双向道路）。 随着经济的发展，精灵王国的城市之间建立了m条地铁，第i条地铁可以从城市u[i]前往v[i]，也可以从v[i]前往u[i]，同时地铁的长度为w[i]。 现在小J在各个城市之间旅游，小J想知道从城市x前往城市y旅游需要花费多长的时间？ Input 第一行为2个整数n、m。 第二行为n个正整数d[i]。 接下来m行每行三个正整数u[i]、v[i]、w[i]。 第m+3行为一个正整数Q，表示询问次数。 接下来Q行每行两个正整数x、y，表示一次从城市x到城市y的旅行。 数据范围：1&lt;=n,q&lt;=1e5,1&lt;=m&lt;=30,1&lt;=u[i],v[i],x,y&lt;=n,1&lt;=d[i],w[i]&lt;=1e9; Output 输出Q行每行一个正整数表示该次旅行的最短时间。 Sample Input 1 14 1 1 2 3 6 1 3 2 5 1 2 1 4 1 3 2 3 4 3 Sample Output 1 11 5 2 2 3 看起来挺难的，其实是到原题。。，把数据范围改了一下，见牛客第二场挑战赛。 看起来很难，实际上简单的一匹，只有30条铁路，直接把有铁路的60个点直接全部跑一次最短路，然后问两个点之间的最短距离，要么坐了地铁，那么就是到60个点中的一个最短路加上从这个有铁路的点到另一个点的最短路，要么就是不做地铁，不做地铁一个前缀和就行了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e5+5;const int inf=0x3f3f3f3f;int n,m;int d[maxn];LL dp[maxn];vector&lt;int&gt; v;bool u[maxn];struct edge &#123; int to,next; LL w;&#125; eg[maxn*3];int tot,head[maxn];void add(int u,int v,int w) &#123; eg[tot].to=v; eg[tot].w=w; eg[tot].next=head[u]; head[u]=tot++;&#125;LL dis[65][maxn];int main() &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); mem(head,-1); for(int i = 1; i &lt;= n ; i ++) &#123; scanf(&quot;%d&quot;,&amp;d[i]); dp[i]=dp[i-1]+d[i]; if(i==n) &#123; add(1,n,d[i]); add(n,1,d[i]); &#125; else &#123; add(i,i+1,d[i]); add(i+1,i,d[i]); &#125; &#125; while(m--) &#123; int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); if(u[a]==0) &#123; v.push_back(a); u[a]=1; &#125; if(u[b]==0) &#123; v.push_back(b); u[b]=1; &#125; add(a,b,c); add(b,a,c); &#125; mem(dis,inf); priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; q; for(int i = 0 ; i &lt; v.size(); i ++) &#123; dis[i][v[i]]=0; q.push(P(0,v[i])); while(q.size()) &#123; int u = q.top().second; q.pop(); for(int j = head[u]; j!=-1; j=eg[j].next) &#123; edge &amp;e=eg[j]; if(dis[i][e.to]&gt;dis[i][u]+e.w) &#123; dis[i][e.to]=dis[i][u]+e.w; q.push(P(dis[i][e.to],e.to)); &#125; &#125; &#125; &#125; int Q; scanf(&quot;%d&quot;,&amp;Q); while(Q--) &#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); if(a&gt;b)swap(a,b); LL ans=min(dp[b-1]-dp[a-1],dp[n]-(dp[b-1]-dp[a-1])); for(int i =0 ; i &lt;v.size(); i++) &#123;// debug(dis[i][a]+dis[i][b]); ans=min(ans,dis[i][a]+dis[i][b]); &#125; printf(&quot;%lld\n&quot;,ans); &#125; return 0;&#125; 5.zzq的数学教室2 Description zzq想保研，他的成绩单上有一排非递减顺序的成绩，面试时老师想知道他数学成绩的位置，zzq知道他的数学成绩是x分，他要找到第一个出现x的位置。 他想运用二分查找算法， 代码如下： 显然L就是最终的位置。 可是现在他的成绩全被lcy学姐打乱了（随机把数字乱放）。 他想知道最后找到的位置仍然是原来的位置的概率， 请你帮帮他。 概率是在模1e9 + 7意义下的， 即 p / q = p * inv(q) 。inv(q)是q在模1e9 + 7 意义下的逆元。 Input 输入第一行一个正整数N。 第二行N个正整数a[i]，代表的是原来的成绩单，呈非递减顺序。 第三行一个数字x，代表他的数学成绩。 1 &lt;= N &lt;= 1e5 1 &lt;= a[i] &lt;= 1e9 x保证是某一个a[i]。 Output 输出一个整数代表概率。 Sample Input 1 18 1 1 1 3 7 9 9 10 1 Sample Output 1 11 Sample Input 2 13 1 2 2 2 Sample Output 2 1333333336 Hint 对于第二个样例，lcy学姐可能打乱成这3种等概率的情况： 1 2 2 2 1 2 2 2 1 其中只有第一种会结果正确。 概率是1 / 3。 题解：水题，直接把小于x的个数，a，和大于x的个数算出来b，然后照这个二分写法一路把答案算下去就行了；具体看代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e5+5;const int inf=0x3f3f3f3f;int l,r;LL pow(LL x,LL n) &#123; LL ans=1; while(n) &#123; if(n&amp;1)ans=ans*x%mod; x=x*x%mod; n&gt;&gt;=1; &#125; return ans;&#125;int n,x;int a[maxn];int main() &#123; scanf(&quot;%d&quot;,&amp;n); for(int i = 1 ; i &lt;= n ; i ++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; scanf(&quot;%d&quot;,&amp;x); LL mx=0,mi=0; for(int i = 1; i&lt;=n; i++) &#123; if(a[i]&gt;=x) &#123; mx++;//大于等于x的个数 &#125; else &#123; mi++;//小于等于x的个数 &#125; &#125; int l=1,r=n; LL ans=1; while(l&lt;=r) &#123; int mid=(l+r)/2; if(a[mid]&gt;=x) &#123; ans=ans*mx%mod*pow(mi+mx,mod-2)%mod;//需要一个选一个大于等于x的数，选到的概率是(mx/(mi+mx)); mx--; r=mid-1; &#125; else &#123; ans=ans*mi%mod*pow(mi+mx,mod-2)%mod;//同上。 mi--; l=mid+1; &#125; &#125; printf(&quot;%lld\n&quot;,ans); return 0;&#125; 6.zzq的数学教室 Description 众所周知，摸鱼是qwb的一大爱好。即使是在zzq的数学课上，qwb也是在疯狂摸鱼。这被眼尖的zzq发现了，所以zzq决定考考摸鱼的qwb，如果qwb答不出来，他的平时分自然就归零了。 现在zzq把数字1~n从左至右排成一排（第i个数的值为i），接下来进行m轮操作，每次操作描述如下：将奇数位置的数字取出形成序列A，将偶数位置的数字取出形成序列B，将A序列拼接在B序列之后，构成新的序列。 现在问题来了：进行m次操作后，第k个位置的数字是多少呢？ Input 第一行，输入2个正整数n,q 接下来q行，每行2个整数m和k，表示zzq想知道在m次操作之后第k个位置上的数是多少。 数据范围： n&lt;=5000 q&lt;=1e6 m&lt;=1e6 k&lt;=n; Output 输出q行，每行输出第k个位置的数字。 Sample Input 1 15 2 1 2 2 3 Sample Output 1 14 2 水题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 #include&lt;bits/stdc++.h&gt;using namespace std;#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot;&lt;&lt;endl;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;const int maxn=5e3+7;const int inf=0x3f3f3f3f;int n,q;int ar[maxn], br[maxn];int ans[maxn][maxn];int main()&#123; while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;q))&#123; for(int i = 1; i &lt;= n; ++i)&#123; ar[i] = ans[0][i] = i; &#125; int tot, tim = 1; do&#123; tot = 1; for(int i = 2; i &lt;= n; i += 2)&#123; ans[tim][tot] = ans[tim-1][i]; //printf(&quot;%d &quot;, ans[tim][tot]); tot++; &#125; for(int i = 1; i &lt;= n; i += 2)&#123; ans[tim][tot] = ans[tim-1][i]; //printf(&quot;%d &quot;, ans[tim][tot]); tot++; &#125; int flag = 0; for(int i = 1; i &lt;= n; ++i)&#123; if(ans[tim][i] != ar[i])flag = 1; &#125; if(flag == 0)break; tim ++; &#125;while(1); //printf(&quot;*%d\n&quot;,tim); int m, k; while(q--)&#123; scanf(&quot;%d%d&quot;, &amp;m, &amp;k); m %= tim; if(m == 0)m = tim; printf(&quot;%d\n&quot;, ans[m][k]); &#125; &#125; return 0;&#125; 7.玩游戏 Description dr喜欢玩游戏，现在有n个游戏，每个游戏时间为[Li,Ri)，现在问题是，找出最长的一段游戏时间，使得该时间段被至少k个游戏完全覆盖(这k个区间要每一个都要完全覆盖你选出来的这个区间）。 Input 多组输入 第一行n,k(1&lt;=n,k&lt;1e6) 接下来n行，每行两个数l,r(1&lt;=l&lt;r&lt;=1e9) Output 输出这个区间的长度 Sample Input 1 13 2 1 5 1 4 1 3 Sample Output 1 13 贪心就好，每次从最先结束的一个线段开始选，然后找最小的k小于当前线段结束点的起点，然后满足条件的区间就是当前区间的终点减去k个起始点中最大值。找完这个线段的终点后把这个区间删掉，然后依次类推下去知道找完所有的线段。本来每次找k个小于当前线段的结束点起始点需要一个操作，但是因为数据有点水，被我水过去了。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 #include&lt;bits/stdc++.h&gt;using namespace std;#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot;&lt;&lt;endl;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;const int maxn=1e6+7;const int inf=0x3f3f3f3f;struct th &#123; int st,en,id; bool operator &lt;(const th a)const &#123; if(en==a.en) &#123; return st&lt;a.st; &#125; else return en&lt;a.en; &#125;&#125; a[maxn];bool u[maxn];priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt;q;int main() &#123; int n,m; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)) &#123; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d%d&quot;,&amp;a[i].st,&amp;a[i].en); a[i].id=i; q.push(P(a[i].st,i)); &#125; sort(a,a+n); int cnt=0,ans=0,L=0; memset(u,0,sizeof(u)); for(int i =0; i&lt;n; i++) &#123; if(!u[a[i].id])cnt++; u[a[i].id]=1; L=a[i].st; //本来这是要找最大值的，但是数据有点水，直接就过去了。。。 while(cnt&lt;m&amp;&amp;q.size()) &#123; if(u[q.top().second]==1) &#123; q.pop(); continue; &#125; else if(q.top().first&gt;=a[i].en) &#123; break; &#125; else &#123; cnt++; u[q.top().second]=1; L=max(L,q.top().first); q.pop(); &#125; &#125; if(cnt==m) &#123; ans=max(ans,a[i].en-L); &#125; cnt--; &#125; while(q.size())q.pop(); printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125; 9.签到题 Description “素数就是因子只包含1和它本身的数”zzq如是说道。 现在zzq的数学课下课了，他发现qwb在他的课摸鱼，于是要出一个题考qwb：N！的素因子有多少个？ 如果qwb做不出来就要被py交易！但是qwb完全不知道zzq上课讲了什么，于是向从来不摸鱼的你求助了（划重点：这是简单题）。 Input 第一行输入一个整数T（T \leq 10T≤10），表示有T组数据。 每组数据输入站一行，输入一个整数N（N \leq 10^5N≤105） Output 对于每组数据，输出N!有多少个素因子 Sample Input 1 12 1 4 Sample Output 1 10 4 如题目。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;const int maxn=1e5+7;const int inf=0x3f3f3f3f;int prim[maxn], p[maxn], pcnt;int sum[maxn];int main() &#123; int t; prim[0]=1; prim[1]=1; pcnt = 0; for(int i =2; i &lt; maxn; i++) &#123; if(!prim[i]) p[pcnt++] = i; for(int j = 0; j &lt; pcnt&amp;&amp;i*p[j]&lt;maxn; ++j) &#123; prim[i*p[j]] = 1; if(i%p[j] == 0)break; &#125; &#125; sum[0] = 0; sum[1] = 0; sum[2] = 1; for(int i = 3; i &lt; maxn; ++i) &#123; int tmp = i,cnt = 0; if(prim[i] == 0) &#123; sum[i]=sum[i-1]+1; continue; &#125; for(int j = 0; j &lt; pcnt; ++j) &#123; while(tmp % p[j] == 0) &#123; tmp /= p[j]; cnt++; &#125; if(tmp == 1)break; &#125; if(tmp!=1)cnt++; sum[i] = sum[i-1] + cnt; &#125; int n; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;, &amp;n); printf(&quot;%d\n&quot;, sum[n]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF傻逼题，201709-5-除法---暴力可以过？？？？？]]></title>
    <url>%2F2018%2F09%2F06%2FCCF%E5%82%BB%E9%80%BC%E9%A2%98%EF%BC%8C201709-5-%E9%99%A4%E6%B3%95---%E6%9A%B4%E5%8A%9B%E5%8F%AF%E4%BB%A5%E8%BF%87%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[这题特么无语，史上最无语没有之一，C++纯暴力过 90？？？？，JAVA纯暴力过了？？？？？？？？？？？？，tell me ，发生了什么，这题为什么能暴力。 CCF如果JAVA熟练，建议大家用JAVA。 http://118.190.20.162/view.page?gpid=T59 JAVA纯暴力AC代码。。。。。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 //import java.lang.reflect.Array;import java.math.*;import java.util.Arrays;import java.util.Scanner;//import om.sun.swing.internal.plaf.basic.resources.basic;public class Main &#123; static int[] a= new int[100005]; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int n = input.nextInt(),m = input.nextInt(); for(int i= 1 ; i &lt;= n ; i ++) &#123; a[i] = input.nextInt(); &#125; int op,l,r,v; for(int j=0;j&lt;m;j++) &#123;// op = input.nextInt(); l = input.nextInt(); r = input.nextInt(); if(op==1) &#123; v = input.nextInt(); if(v == 1)continue; for(int i = l ; i &lt;= r; i ++) &#123; if(a[i] &gt;= v &amp;&amp; a[i] % v == 0) &#123; a[i] /= v; &#125; &#125; &#125; else &#123;// l=input.nextInt();// r=input.nextInt(); long ans=0; for(int i=l;i&lt;=r;i++) &#123; ans += a[i]; &#125; System.out.println(ans); &#125; &#125;// System.out.println(ans); &#125;&#125; C++纯暴力，过 90%，这个可以理解。。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;const long long mod=1e9+7;const int maxn=1e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int A[maxn];int n,m;int main() &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;A[i]); &#125; while(m--) &#123; int op,l,r,v; scanf(&quot;%d%d%d&quot;,&amp;op,&amp;l,&amp;r); if(op==1) &#123; scanf(&quot;%d&quot;,&amp;v); if(v==1)continue; while(l&lt;=r) &#123; if(A[l]&gt;=v&amp;&amp;A[l]%v==0) &#123; A[l]/=v; &#125; l++; &#125; &#125; else &#123; long long ans=0; while(l&lt;=r) &#123; ans+=A[l++]; &#125; printf(&quot;%lld\n&quot;,ans); &#125; &#125; return 0;&#125; C++，AC代码。也是半个暴力。因为每个数去除最多只能除 32次，（因为数的最大值只有1e6,每次就算只除2，也不能除多少次，所以这个更新可以暴力，并不会超时。复杂度最高也只有 32 N logN,重点在于处理前缀和），不会再多，所以只需要用一个树状数组维护前缀和即可，每次更新值，直接暴力能不能除，然后再更新值即可。 考察两点：1.暴力更新值（注意特判除1），2.树状数组求前缀和。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;const long long mod=1e9+7;const int maxn=1e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int A[maxn];long long bit[maxn];int n,m;long long sum(int i) &#123; long long ans=0; while(i&gt;0) &#123; ans+=bit[i]; i-=i&amp;-i; &#125; return ans;&#125;void add( int i, int x) &#123; while(i&lt;=n) &#123; bit[i]+=x; i += i&amp;-i; &#125;&#125;int main() &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;A[i]); add(i,A[i]); &#125; while(m--) &#123; int op,l,r,v; scanf(&quot;%d%d%d&quot;,&amp;op,&amp;l,&amp;r); if(op==1) &#123; scanf(&quot;%d&quot;,&amp;v); if(v==1)continue; while(l&lt;=r) &#123; if(A[l]&gt;=v&amp;&amp;A[l]%v==0) &#123; add(l,0-A[l]+A[l]/v); A[l]/=v; &#125; l++; &#125; &#125; else &#123; printf(&quot;%lld\n&quot;,sum(r)-sum(l-1)); &#125; &#125; return 0;&#125; 细心的孩子，肯定一定发现了。。。。。。。。。，JAVA暴力，6s 。C++树状数组7s，我竟无言以对。暴力比树状数组快，这数据出的挺好的。。。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2013-2014 Summer Petrozavodsk Camp, Andrew Stankevich Contest 44 (ASC 44)]]></title>
    <url>%2F2018%2F08%2F31%2F2013-2014%20Summer%20Petrozavodsk%20Camp%2C%20Andrew%20Stankevich%20Contest%2044%20(ASC%2044)%2F</url>
    <content type="text"><![CDATA[暑训最后一场组队训练赛，特么故意的，把别人的WF练习题给我们写，写了半天才签到两题。靠！ B - Braess’s Paradox Gym - 100518B 题意：有几个点，每个点到下一个点之间有两条路。上面一条路的通过时间是 AK1+B,下面一条通过时间是CK2+D，要两条路通过的时间数尽量相同，K1+K2=1(K1,K2是经过的人流量占总人数的比例)。然后中间的点可以建驿站，如果中间的点不建驿站，就相当于直接从起点到终点，只有两条路，如果建了驿站，就相当于从起点到驿站，再从驿站到终点。 题解：前两个直接算出来就行，一个驿站都不建，就相当于两条路，把所有点上面那条路，ai.bi,加起来就是上面那一条路的A,B，同理，下面一条路就是所有的,ci,di加起来。每个都建就是相当于一个个点走过去，暴力啊，一个点到另一个点的时间，然后全加起来就行了。后面两个就是求最小通过时间的和最大通过时间，看似很难，其实就是一个很简单的DP，N^2的复杂度不会超时。首先预处理从起点到当前点的A,B,C,D。然后每个点的时间就是从前面某一个点建驿站的最小值，最大值转移过来。直接过来上面路的A，B就用两个前缀相减。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;ll,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e3+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;int a[maxn],b[maxn],c[maxn],d[maxn];double qza[maxn],qzb[maxn],qzc[maxn],qzd[maxn];double dp1[maxn],dp2[maxn];double ans1,ans2,ans3,ans4;int main() &#123; freopen(&quot;braess.in&quot;,&quot;r&quot;,stdin); freopen(&quot;braess.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d%d%d%d&quot;,&amp;a[i],&amp;b[i],&amp;c[i],&amp;d[i]); &#125; double A=0,B=0,C=0,D=0; for(int i=1; i&lt;=n; i++) &#123; //第一种结果都不建，A相当于所有点之间的a[i]相加 A+=a[i]; B+=b[i]; C+=c[i]; D+=d[i]; &#125; double k; if(A+C!=0) &#123; k=min(1.0,(D+C-B)/(A+C));//k1最大值不能超过1 ans1=k*A+B; if(k&lt;=0) &#123; //k1最小值不能小于0，如果小于等于0说明所有人都走下面一条路 ans1=C+D; &#125; &#125; else &#123; ans1=min(B,D); //如果AC都等于零，那就直接判断B，D大小 &#125; ans2=0; for(int i=1; i&lt;=n; i++) &#123; A=a[i]; //所有的点一个个算 B=b[i]; C=c[i]; D=d[i]; double temp; if(A+C!=0) &#123; k=min(1.0,(D+C-B)/(A+C)); temp=k*A+B; if(k&lt;=0) &#123; temp=C+D; &#125; &#125; else &#123; temp=min(B,D); &#125; ans2+=temp; &#125; for(int i=1; i&lt;=n; i++) &#123; //求前缀 qza[i]=qza[i-1]+a[i]; qzb[i]=qzb[i-1]+b[i]; qzc[i]=qzc[i-1]+c[i]; qzd[i]=qzd[i-1]+d[i]; dp1[i]=inf; &#125; dp1[0]=0; for(int i=1; i&lt;=n; i++) &#123; for(int j=0; j&lt;i; j++) &#123; A=qza[i]-qza[j]; B=qzb[i]-qzb[j]; //ABCD等于上一个状态和当前状态的差值， C=qzc[i]-qzc[j]; D=qzd[i]-qzd[j]; double temp; if(A+C!=0) &#123; k=min(1.0,(D+C-B)/(A+C)); temp=k*A+B; if(k&lt;=0) &#123; temp=C+D; &#125; &#125; else &#123; temp=min(B,D); &#125; dp1[i]=min(dp1[i],dp1[j]+temp); //dp1保留最小值，从j驿站转移到i驿站的最小值 dp2[i]=max(dp2[i],dp2[j]+temp); //最大值 &#125; &#125; ans3=dp1[n]; ans4=dp2[n]; printf(&quot;%.10f\n%.10f\n%.10f\n%.10f\n&quot;,ans1,ans2,ans3,ans4); return 0;&#125; I - Intelligent Tourist Gym - 100518I 题意：有N场考试，第i考试需要复习pi天，考试时间是di，考试的时间没法复习，如果没有复习多天那场考试就不会去，就会去复习其他考试，中间有些天有活动，活动时间是s-t活动时间不会去复习，问最多能通过机场考试。 题解：贪心，这题贼他妈傻逼，漏看了一个条件，DEBUG一个小时。。。，从后面往前面扫，每次选需要复习时间最少的一场考试，因为这个时间只能给后面的所以不用担心选的考试时间已经过了，至于考试时间不能复习，你直接把考试也当作复习的时间，不去考试就相当于少复习这种科目一天，去了就相当于多复习一天。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;ll,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,m;struct one &#123; ll d,p; int id; bool operator&lt;(const one a)const &#123; return d&lt;a.d; &#125;&#125; X;struct two &#123; ll st,en; bool operator&lt;(const two a)const &#123; return st&lt;a.st; &#125;&#125; H;priority_queue&lt;one&gt; q1;priority_queue&lt;two&gt; q2;priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt;q;int main() &#123; freopen(&quot;intelligent.in&quot;,&quot;r&quot;,stdin); freopen(&quot;intelligent.out&quot;,&quot;w&quot;,stdout); while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n) &#123; vector&lt;int&gt; v; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%I64d%I64d&quot;,&amp;X.d,&amp;X.p); X.p++; X.id=i+1; q1.push(X); &#125; scanf(&quot;%d&quot;,&amp;m); for(int i=0; i&lt;m; i++) &#123; scanf(&quot;%I64d%I64d&quot;,&amp;H.st,&amp;H.en); q2.push(H); &#125; while(q2.size()) &#123; if(q2.top().st&gt;q1.top().d) &#123; q2.pop(); &#125; else break; &#125; while(q1.size()) &#123; X=q1.top(); q1.pop(); ll temp; if(q1.size()==0)temp=0; else temp=q1.top().d; ll tim=0; tim=X.d-temp; while(q2.size()) &#123; H=q2.top(); if(H.st&gt;temp) &#123; q2.pop(); tim-=H.en-H.st+1; &#125; else break; &#125; if(X.p==0) &#123; v.push_back(X.id); &#125; else q.push(P(X.p,X.id)); while(tim&gt;0&amp;&amp;q.size()) &#123; P temp2=q.top(); q.pop(); if(tim&gt;=temp2.first) &#123; tim-=temp2.first; v.push_back(temp2.second); &#125; else &#123; temp2.first-=tim; tim=0; q.push(temp2); &#125; &#125; &#125; while(q1.size())q1.pop(); while(q2.size())q2.pop(); while(q.size())q.pop(); sort(v.begin(),v.end()); int ans=v.size(); printf(&quot;%d\n&quot;,ans); for(int i=0; i&lt;ans; i++) &#123; printf(&quot;%d&quot;,v[i]); if(ans==i+1)printf(&quot;\n&quot;); else printf(&quot; &quot;); &#125; if(ans==0)puts(&quot;&quot;); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[傻瓜级git命令理解]]></title>
    <url>%2F2018%2F08%2F27%2F%E5%82%BB%E7%93%9C%E7%BA%A7git%E5%91%BD%E4%BB%A4%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[git clone wangzhi.com —克隆对应网址仓库 git pull –更新仓库 git add -A 添加到缓冲区， git commit -m“your name” 更新本地仓 git push 提交上网络仓库 上面3个连着用就行了。 git config —global user.name “输入你的用户名” git config —global user.email “输入你的邮箱” 初始化下身份照着打就行了]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The 17th Zhejiang University Programming Contest Sponsored by TuSimple(浙江省赛)]]></title>
    <url>%2F2018%2F08%2F27%2FThe%2017th%20Zhejiang%20University%20Programming%20Contest%20Sponsored%20by%20TuSimple(%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9B)%2F</url>
    <content type="text"><![CDATA[A - Marjar Cola ZOJ - 3948 签到题，x,y,a,b,都很小直接暴力。判断INF，只要判断次数有没有过多就行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int main() &#123; int x,y,a,b; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; int ans=0; scanf(&quot;%d%d%d%d&quot;,&amp;x,&amp;y,&amp;a,&amp;b); if(x==1||y==1)puts(&quot;INF&quot;); else &#123; while(a&gt;=x||y&lt;=b) &#123; if(a&gt;=x) &#123; a-=x; a++; b++; ans++; &#125; else &#123; b-=y; b++; a++; ans++; &#125;// debug(a);// debug(b); if(ans&gt;3e5)&#123; break; &#125; &#125; if(ans&gt;3e5)&#123; puts(&quot;INF&quot;); &#125; else printf(&quot;%d\n&quot;,ans); &#125; &#125; return 0;&#125; C - How Many Nines ZOJ - 3950 打个表，比较考虑细节，真的难处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e4+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int Year[maxn], Mon[35], pre1[maxn], pre2[35];int hh[13], mon[13];bool leap(int y)&#123; if(y%400==0)return 1; if(y%100==0)return 0; if(y%4==0)return 1; return 0;&#125;int nine(int y)&#123; int cnt = 0; while(y)&#123; if(y%10==9)cnt++; y/=10; &#125; return cnt;&#125;void init()&#123; Mon[1]=Mon[3]=Mon[5]=Mon[7]=Mon[8]=Mon[10]=Mon[12]=3;///31 Mon[2]=2; Mon[4]=Mon[6]=Mon[9]=Mon[11] = 3;///30 Mon[9] += 30; hh[1]=hh[3]=hh[5]=hh[7]=hh[8]=hh[10]=hh[12]=31; hh[2] = 28; hh[4]=hh[6]=hh[9]=hh[11]=30; mon[0] = 0; for(int i = 1; i &lt;= 12; ++i)&#123; mon[i] = hh[i]+mon[i-1]; &#125; int sum = 0;pre1[1999]=pre2[0] = 0; for(int i = 1; i &lt;= 12; ++i)&#123; sum += Mon[i]; pre2[i] = pre2[i-1]+Mon[i]; &#125; for(int i = 2000; i &lt;= 9999; ++i)&#123; int tmp = nine(i); if(tmp)&#123; Year[i] = sum + tmp*365; if(leap(i))Year[i] += tmp + 1; &#125;else&#123; Year[i] = sum; if(leap(i))++Year[i]; &#125; pre1[i] = pre1[i-1]+Year[i]; &#125;&#125;int get(int d)&#123; if(d&lt;=9)return 3; if(d&lt;=19)return 2; if(d&lt;=29)return 1; return 0;&#125;int main()&#123;#ifndef ONLINE_JUDGE //freopen(&quot;E://ADpan//in.in&quot;, &quot;r&quot;, stdin); //freopen(&quot;E://ADpan//out.out&quot;, &quot;w&quot;, stdout); #endif init(); int tim;scanf(&quot;%d&quot;,&amp;tim); while(tim--)&#123; int y1,m1,d1,y2,m2,d2; scanf(&quot;%d%d%d%d%d%d&quot;,&amp;y1,&amp;m1,&amp;d1,&amp;y2,&amp;m2,&amp;d2); if(y1==y2)&#123; if(m1==m2)&#123; int ans = get(d1)-get(d2+1); if(m1==9)ans += d2-d1+1; int tmp = nine(y1); ans += tmp*(d2-d1+1); printf(&quot;%d\n&quot;, ans); continue; &#125; int ans = pre2[m2-1]-pre2[m1]; if(leap(y1)&amp;&amp;2&gt;m1&amp;&amp;2&lt;m2)ans++; ans += get(d1) + 3 - get(d2+1); if(m1==2&amp;&amp;leap(y1)==false)ans--; if(m1==9)&#123; ans+=30-d1+1; &#125; if(m2==9)&#123; ans += d2; &#125; int tmp = nine(y1); if(tmp)&#123; int day = mon[m2-1]-mon[m1] + (hh[m1] - d1 + 1) + d2; if(leap(y1)&amp;&amp;2&gt;m1&amp;&amp;2&lt;m2)day++; if(leap(y1)&amp;&amp;m1==2)day++; ans += day*tmp; &#125; printf(&quot;%d\n&quot;, ans); &#125;else&#123; int ans = pre1[y2-1]-pre1[y1]; int a = 0, b = 0, tmp = nine(y1),day; a = pre2[12]-pre2[m1]; a += get(d1); if(leap(y1)==0&amp;&amp;m1==2)a--; if(leap(y1)&amp;&amp;m1==1)a++; if(m1==9)a += 30-d1+1; b = pre2[m2-1]; b += 3-get(d2+1); if(leap(y2)&amp;&amp;m2&gt;2)b++; if(m2==9)b+=d2; if(tmp)&#123; day = mon[12]-mon[m1] + (hh[m1] - d1 + 1); if(leap(y1)&amp;&amp;m1&lt;=2)day++; a += tmp * day; &#125; tmp = nine(y2); if(tmp)&#123; day = mon[m2-1] + d2; if(leap(y2)&amp;&amp;m2&gt;2)day++; b += tmp * day; &#125; ans += a+b; printf(&quot;%d\n&quot;, ans); &#125; &#125; return 0;&#125; F - Knuth-Morris-Pratt Algorithm ZOJ - 3957 签到题，KMP，判断一下次数就行。暴力判断也没事 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;char ch1[]=&quot;dog&quot;,ch2[]=&quot;cat&quot;;int nex[2000];void get_next(char *t,int lent)&#123; nex[0] = -1; for(int i = 0,k = -1;i &lt; lent;)&#123; if(k==-1||t[i] == t[k])&#123; ++k;++i; nex[i]=k; &#125;else k = nex[k]; &#125;&#125;int kmp(char *s,int lens,char *t,int lent)&#123; if(lens&lt;lent)return 0; get_next(t,lent); int i = 0, j = 0; int cnt = 0; while(i &lt; lens&amp;&amp;j&lt;lent) &#123; if(j==-1||s[i] == t[j])&#123; i++;j++; if(j==lent)&#123; cnt++; j = nex[j]; &#125; &#125;else j=nex[j]; &#125; return cnt;&#125;int main() &#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; char s[2000]; scanf(&quot;%s&quot;,s); int l=strlen(s); int ans=0; ans+=kmp(s,l,ch1,3); ans+=kmp(s,l,ch2,3); printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125; G - Intervals ZOJ - 3953 贪心，真的贪的内心崩溃。贪心策略，按L排序，每次判断3个区间，如果出现3个重合，丢去 R最大的，因为影响最大。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;struct seg &#123; int st,en,id; bool operator &lt; (const seg a )const &#123; return en&lt;a.en; &#125;&#125; sg[maxn];bool cmp(seg a,seg b) &#123; if(a.st==b.st) &#123; return a.en&lt;b.en; &#125; return a.st&lt;b.st;&#125;int res[maxn];int main() &#123; int n,t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d%d&quot;,&amp;sg[i].st,&amp;sg[i].en); sg[i].id=i+1; &#125; sort(sg,sg+n,cmp); priority_queue&lt;seg&gt;q; int ans=0; for(int i=0; i&lt;n; i++) &#123; if(q.size()&lt;2) &#123; q.push(sg[i]); &#125; else &#123; q.push(sg[i]); seg s[3]; for(int i=0; i&lt;3; i++) &#123; s[i]=q.top(); q.pop(); &#125; if(s[0].st&lt;=s[2].en&amp;&amp;s[1].st&lt;=s[2].en) &#123; res[ans++]=s[0].id; q.push(s[1]); q.push(s[2]); &#125; else &#123; q.push(s[0]); q.push(s[1]); &#125; &#125; &#125; sort(res,res+ans); printf(&quot;%d\n&quot;,ans); for(int i=0; i&lt;ans; i++) &#123; printf(&quot;%d&quot;,res[i]); if(i+1==ans)printf(&quot;\n&quot;); else printf(&quot; &quot;); &#125; if(ans==0)puts(&quot;&quot;); &#125; return 0;&#125; H - Seven-Segment Display ZOJ - 3954 题意 ：1-9九个数，分别可以用后面7个0 1表示，下面给你n个数，每个数后面跟有7个01串，你可以交换n个数任意两列。如果可以通过交换表示出来输出YES 否则NO。 例子 : 17 0101011 1 1101011 把第2列和第5列交换，变成 11 1001111 7 0001111 与1 7 的表示匹配，所以输出YES 题解：这题只有9个数，暴力啊匹配，n^2都不会超时。。。；我是把每一列的状态用一个10进制数保存，每次能够从原来的数里面找与之匹配的状态，如果找不到，就输出NO； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int mp[10];int n;int k[10],v[10];int p[10];map&lt;int,int&gt; m;int main() &#123; mp[1]=1001111; mp[2]=10010; mp[3]=110; mp[4]=1001100; mp[5]=100100; mp[6]=100000; mp[7]=1111; mp[8]=0; mp[9]=100; int t; p[0]=1; for(int i=1; i&lt;10; i++) &#123; p[i]=p[i-1]*10; &#125; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d%d&quot;,&amp;k[i],&amp;v[i]); &#125; m.clear(); for(int i=0; i&lt;7; i++) &#123; int sum=0; for(int j=0; j&lt;n; j++) &#123; sum+=mp[k[j]]/p[i]%10*p[j]; &#125; m[sum]++; &#125; int flag=1; for(int i=0; i&lt;7; i++) &#123; int sum=0; for(int j=0; j&lt;n; j++) &#123; sum+=v[j]/p[i]%10*p[j]; &#125; m[sum]--; if(m[sum]&lt;0) &#123; flag=0; break; &#125; &#125; puts(flag?&quot;YES&quot;:&quot;NO&quot;); &#125; return 0;&#125; J - Course Selection System ZOJ - 3956 傻逼题,一开始还在想怎么推公式，结果发现，CI的和只有5e4，枚举所用能够到的状态H 的和最大不久行了，直接转换成了 0 1 背包。。。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e4+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;int a[maxn];int x[maxn],y[maxn];int main() &#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]); &#125; mem(a,-1); a[0]=0; for(int i=0; i&lt;n; i++) &#123; for(int j=5e4-y[i]; j&gt;=0; j--) &#123; if(a[j]!=-1) &#123; a[j+y[i]]=max(a[j+y[i]],a[j]+x[i]); &#125; &#125; &#125; ll ans=0; for(ll i=1;i&lt;=5e4;i++)&#123; if(a[i]!=-1) ans=max(ans,1LL*a[i]*a[i]-i*a[i]-i*i); &#125; printf(&quot;%lld\n&quot;,ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCPC2018中国大学生程序设计竞赛 - 网络选拔赛]]></title>
    <url>%2F2018%2F08%2F27%2FCCPC2018%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%20-%20%E7%BD%91%E7%BB%9C%E9%80%89%E6%8B%94%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[HDU 6438 1001 Buy and Resell Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 2282 Accepted Submission(s): 359 Problem Description The Power Cube is used as a stash of Exotic Power. There are n cities numbered 1,2,…,n where allowed to trade it. The trading price of the Power Cube in the i-th city is ai dollars per cube. Noswal is a foxy businessman and wants to quietly make a fortune by buying and reselling Power Cubes. To avoid being discovered by the police, Noswal will go to the i-th city and choose exactly one of the following three options on the i-th day: spend ai dollars to buy a Power Cube resell a Power Cube and get ai dollars if he has at least one Power Cube do nothing Obviously, Noswal can own more than one Power Cubes at the same time. After going to the n cities, he will go back home and stay away from the cops. He wants to know the maximum profit he can earn. In the meanwhile, to lower the risks, he wants to minimize the times of trading (include buy and sell) to get the maximum profit. Noswal is a foxy and successful businessman so you can assume that he has infinity money at the beginning. Input There are multiple test cases. The first line of input contains a positive integer T (T≤250), indicating the number of test cases. For each test case: The first line has an integer n. (1≤n≤105) The second line has n integers a1,a2,…,an where ai means the trading price (buy or sell) of the Power Cube in the i-th city. (1≤ai≤109) It is guaranteed that the sum of all n is no more than 5×105. Output For each case, print one line with two integers —— the maximum profit and the minimum times of trading to get the maximum profit. Sample Input 1 3 4 1 2 10 9 5 9 5 9 10 5 2 2 1 Sample Output 1 16 4 5 2 0 0 Hint In the first case, he will buy in 1, 2 and resell in 3, 4. profit = - 1 - 2 + 10 + 9 = 16 In the second case, he will buy in 2 and resell in 4. profit = - 5 + 10 = 5 In the third case, he will do nothing and earn nothing. profit = 0 贪心，每次保留买，和卖两种状态，如果一种买了，说明后面有一定有可以卖的，从前往后扫每次取前面最小的，如果遇见能从卖了的里面取，总次数不用+2，如果是从买了的里面取，总交易次数+2； 用，0，1分别代表买和卖。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int a[maxn];int n;priority_queue&lt;P&gt;q;ll sum=0,ans=0;int main() &#123; int t; cin&gt;&gt;t; while(t--) &#123; sum=0; ans=0; scanf(&quot;%d&quot;,&amp;n); while(q.size())q.pop(); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); q.push(P(-a[i],0)); q.push(P(-a[i],1)); int temp=a[i]+q.top().first; if(q.top().second==0) &#123; ans+=2; &#125; q.pop(); sum+=temp; &#125; printf(&quot;%lld %lld\n&quot;,sum,ans); &#125; return 0;&#125; HDU 6441 1004 Find Integer 更具费马大定理，n&gt;2 和等于 0误解，n=1，直接输出 1 a+1; n=2 的时候，就是一个勾股定理，a^2=cc-bb = (c-b)(c+b) 如果A为偶数 c-b=2 c+b=aa/2 ,如果a为奇数 c-b=1 c+b=a*a 解个方程就行了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int main() &#123; int t; cin&gt;&gt;t; while(t--) &#123; ll n,k; scanf(&quot;%lld%lld&quot;,&amp;k,&amp;n); if(k==0||k&gt;2)puts(&quot;-1 -1&quot;); else if(k==1) &#123; if(n==1e9)puts(&quot;-1 -1&quot;); else printf(&quot;%lld %lld\n&quot;,1,n+1); &#125; else &#123; ll temp=n; if(n==1||n==2)puts(&quot;-1 -1&quot;); else if(n&amp;1) &#123; ll c=(temp*temp+1)/2; ll b=c-1; if(c&gt;1e9)puts(&quot;-1 -1&quot;); else &#123; printf(&quot;%lld %lld\n&quot;,b,c); &#125; &#125; else &#123; ll c=n*n/4+1,b=c-2; if(c&gt;1e9)puts(&quot;-1 -1&quot;); else printf(&quot;%lld %lld\n&quot;,b,c); &#125; &#125; &#125; return 0;&#125; HDU 6446 1009 Tree and Permutation 直接算一条边左右两边点的个数，全排列种，每条边经过的次数等于 ，2C,(n-m)(m)*(n-1)！次，一个DFS求出他根节点的数量为m，前一条边 权值为C,求一下所有数的和，预处理阶乘。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;struct edge &#123; int to,cost,next;&#125; eg[maxn];int head[maxn],tot;void init() &#123; mem(head,-1); tot=0;&#125;void add(int u,int v,int c) &#123; eg[tot].to=v; eg[tot].cost=c; eg[tot].next=head[u]; head[u]=tot++;&#125;ll k[maxn];ll c[maxn],num[maxn];int dfs(int r,int p,int v) &#123; c[r]=v%mod; int ans=1; for(int i=head[r]; i!=-1; i=eg[i].next) &#123; if(eg[i].to!=p) &#123; ans+=dfs(eg[i].to,r,eg[i].cost); &#125; &#125; num[r]=ans%mod; return ans;&#125;int main() &#123; k[1]=1; for(int i=2; i&lt;=1e5; i++) &#123; k[i]=k[i-1]*i%mod; &#125; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; init(); for(int i=1; i&lt;n; i++) &#123; int u,v,c; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;c); add(u,v,c); add(v,u,c); &#125; dfs(1,-1,0); ll sum=0; for(int i=2; i&lt;=n; i++) &#123; sum+=2*c[i]*num[i]%mod*(n-num[i])%mod*k[n-1]%mod; sum%=mod; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第九届福建省大学生程序设计竞赛-重现赛（感谢承办泉州师范学院）]]></title>
    <url>%2F2018%2F08%2F26%2F%E7%AC%AC%E4%B9%9D%E5%B1%8A%E7%A6%8F%E5%BB%BA%E7%9C%81%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-%E9%87%8D%E7%8E%B0%E8%B5%9B%EF%BC%88%E6%84%9F%E8%B0%A2%E6%89%BF%E5%8A%9E%E6%B3%89%E5%B7%9E%E5%B8%88%E8%8C%83%E5%AD%A6%E9%99%A2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[A - Uint47 calculator FZU - 2294 水题，用unsigned long long,自带自动溢出，然后就可以随便写了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));ull mod=1;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;string s;map&lt;string,ull&gt; mp;int main() &#123; char op[100]; string tx,ty; ull x,y; for(int i=1;i&lt;48;i++)&#123; mod*=2; &#125; while(~scanf(&quot;%s&quot;,op)) &#123; if(op[0]==&apos;d&apos;&amp;&amp;op[1]==&apos;e&apos;) &#123; //def cin&gt;&gt;s&gt;&gt;x; mp[s]=x; cout&lt;&lt;s&lt;&lt;&quot; = &quot;&lt;&lt;x&lt;&lt;&apos;\n&apos;; &#125; else if(op[0]==&apos;s&apos;) &#123; //sub cin&gt;&gt;tx&gt;&gt;ty; x=mp[tx]; y=mp[ty]; mp[tx]=x=(x-y+mod)%mod; cout&lt;&lt;tx&lt;&lt;&quot; = &quot;&lt;&lt;x&lt;&lt;&apos;\n&apos;; &#125; else if(op[0]==&apos;a&apos;) &#123; cin&gt;&gt;tx&gt;&gt;ty; x=mp[tx]; y=mp[ty]; mp[tx]=x=(x+y)%mod; cout&lt;&lt;tx&lt;&lt;&quot; = &quot;&lt;&lt;x&lt;&lt;&apos;\n&apos;; &#125; else if(op[0]==&apos;m&apos;&amp;&amp;op[1]==&apos;u&apos;) &#123; cin&gt;&gt;tx&gt;&gt;ty; x=mp[tx]; y=mp[ty]; mp[tx]=x=(x*y)%mod; cout&lt;&lt;tx&lt;&lt;&quot; = &quot;&lt;&lt;x&lt;&lt;&apos;\n&apos;; &#125; else if(op[0]==&apos;d&apos;) &#123; cin&gt;&gt;tx&gt;&gt;ty; x=mp[tx]; y=mp[ty]; mp[tx]=x=(x/y)%mod; cout&lt;&lt;tx&lt;&lt;&quot; = &quot;&lt;&lt;x&lt;&lt;&apos;\n&apos;; &#125; else &#123; cin&gt;&gt;tx&gt;&gt;ty; x=mp[tx]; y=mp[ty]; mp[tx]=x=x%y; cout&lt;&lt;tx&lt;&lt;&quot; = &quot;&lt;&lt;x&lt;&lt;&apos;\n&apos;; &#125; &#125; return 0;&#125; B - Human life FZU - 2295 最大权闭合子图，k只有5暴力枚举所有状态。然后就是一个裸题了。 答案 是最大正权值-去最大流。如果有人想了解为啥，自行百度吧。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e3+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int v[maxn];int pre[maxn][maxn];int u[maxn];int n,m,K;int a[2][5];int ku[maxn];vector&lt;int&gt; tv[maxn];struct edge &#123; int to,cap,rev;&#125;;vector &lt;edge&gt; G[maxn];int level[maxn];int iter[maxn];void init(int _n) &#123; for(int i=0; i&lt;=_n; i++) &#123; G[i].clear(); tv[i].clear(); &#125; mem(pre,0); mem(u,0);&#125;void init()&#123; for(int i=0;i&lt;=n+m+1;i++)G[i].clear();&#125;void bfs(int s) &#123; memset(level,-1,sizeof(level)); queue&lt;int&gt; que; level[s]=0; que.push(s); while(!que.empty()) &#123; int v= que.front(); que.pop(); for(int i=0; i&lt;G[v].size(); i++) &#123; edge &amp; e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0) &#123; level[e.to]=level[v] + 1; que.push(e.to); &#125; &#125; &#125;&#125;void add(int from,int to,int cap) &#123; edge eg; eg.to=to; eg.cap=cap; eg.rev=G[to].size(); G[from].push_back(eg); eg.to=from; eg.cap=0; eg.rev=G[from].size()-1; G[to].push_back(eg);&#125;int dfs(int v,int t,int f) &#123; if(v == t)return f; for(int &amp;i = iter[v]; i &lt; G[v].size(); i++) &#123; edge &amp;e=G[v][i]; if(e.cap&gt;0 &amp;&amp; level[v]&lt;level[e.to]) &#123; int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0) &#123; e.cap-=d; G[e.to][e.rev].cap+=d; return d; &#125; &#125; &#125; return 0;&#125;int maxflow(int s,int t) &#123; int flow=0; for(;;) &#123; bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while((f = dfs(s,t,INF))&gt;0) &#123; flow +=f; &#125; &#125;&#125;void dfs(int r) &#123; u[r]=1; for(int i=1; i&lt;=n; i++) &#123; if(pre[r][i]) &#123; if(u[i]==0) &#123; dfs(i); &#125; for(int j=1; j&lt;=n; j++) &#123; pre[r][j]|=pre[i][j]; &#125; &#125; &#125;&#125;int main() &#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;K); init(n+m+1); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;v[i]); int k; scanf(&quot;%d&quot;,&amp;k); if(k==0)u[i]=1; for(int j=0; j&lt;k; j++) &#123; int x; scanf(&quot;%d&quot;,&amp;x); pre[i][x]=1; &#125; &#125; for(int i=1; i&lt;=n; i++) &#123; if(u[i]==0) &#123; dfs(i); &#125; &#125; for(int i=n+1; i&lt;=n+m; i++) &#123; scanf(&quot;%d&quot;,&amp;v[i]); int k; bool tu[maxn]= &#123;0&#125;; scanf(&quot;%d&quot;,&amp;k); for(int j=0; j&lt;k; j++) &#123; int x; scanf(&quot;%d&quot;,&amp;x); if(tu[x])continue; tu[x]=1; for(int l=1; l&lt;=n; l++) &#123; tu[l]|=pre[x][l]; &#125; &#125; for(int j=1; j&lt;=n; j++) &#123; if(tu[j]) &#123; tv[i].push_back(j); &#125; &#125; &#125; for(int i=0; i&lt;K; i++) &#123; scanf(&quot;%d%d&quot;,&amp;a[0][i],&amp;a[1][i]); &#125; int mx=0; for(int i=0; i&lt;1&lt;&lt;K; i++) &#123; mem(ku,0); init(); for(int j=0; j&lt;K; j++) &#123; ku[a[(i&gt;&gt;j)&amp;1][j]+n]=1;// debug(a[(i&gt;&gt;j)&amp;1][j]+n); &#125; int sum=0; for(int i=n+1; i&lt;=n+m; i++) &#123; if(ku[i]==1)continue;// debug(i); add(0,i,v[i]); for(int j=0; j&lt;tv[i].size(); j++) &#123; add(i,tv[i][j],inf); &#125; sum+=v[i]; &#125; for(int i=1; i&lt;=n; i++)add(i,n+m+1,v[i]); mx=max(sum-maxflow(0,n+m+1),mx); &#125; printf(&quot;%d\n&quot;,mx); &#125; return 0;&#125; D - Number theory FZU - 2297 一开始还以为是大数，java 了一发，大数了一发，全都TLE，正解就是一个线段树。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e3+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int c[maxn][maxn];int q[maxn][maxn];int b2[maxn];long long pow(long long x,long long n,long long mod=1e9+7) &#123; long long res=1; while(n&gt;0) &#123; if(n&amp;1)res=res*x%mod; x=x*x%mod; n&gt;&gt;=1; &#125; return res%mod;&#125;int main() &#123; c[1][1]=1; c[1][0]=1; for(int i=1; i&lt;1e3+1; i++) &#123; c[i+1][0]=1;// printf(&quot;%d &quot;,c[i+1][0]); for(int j=1; j&lt;=i+1; j++) &#123; c[i+1][j]=(c[i][j-1]+c[i][j])%mod;// printf(&quot;%d &quot;,c[i+1][j]); &#125; &#125; for(int i=1; i&lt;1e3+1; i++) &#123; for(int j=0; j&lt;=i; j++) &#123; q[i][j+1]=(q[i][j]+c[i][j])%mod; &#125; &#125; b2[0]=1; for(int i=1; i&lt;1e3+1; i++) &#123; b2[i]=(b2[i-1]*2)%mod; &#125; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); if(m&gt;n) &#123; puts(&quot;0&quot;); &#125; else &#123; cout&lt;&lt;(q[n][n+1]-q[n][m]+mod)%mod*pow(b2[n],mod-2,mod)%mod&lt;&lt;endl; &#125; &#125; return 0;&#125; E - Traffic jamFZU - 2298 最短路，处理下到某个点的情况，如果是红灯，时间变为到绿灯开始。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int a[maxn];int cost[maxn];int n,m;struct edge &#123; int to,c,next;&#125; eg[maxn*2];int head[maxn],tot,vis[maxn];void init() &#123; mem(head,-1); tot=0;&#125;void add(int u,int v,int c) &#123; eg[tot].to=v; eg[tot].c=c; eg[tot].next=head[u]; head[u]=tot++;&#125;int main() &#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; init(); for(int i=0; i&lt;m; i++) &#123; int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); add(a,b,c); add(b,a,c); &#125; int st,en; scanf(&quot;%d%d&quot;,&amp;st,&amp;en); queue&lt;int&gt; q; q.push(st); mem(cost,inf); mem(vis,0); cost[st]=0; while(q.size()) &#123; int v=q.front(); q.pop(); vis[v]=0; for(int i=head[v]; i!=-1; i=eg[i].next) &#123; int d=cost[v]+eg[i].c,to=eg[i].to; if(to!=en&amp;&amp;(d/a[to])&amp;1)d=(d/a[to]+1)*a[to]; if(d&lt;cost[to]) &#123; cost[to]=d; if(vis[to]==0) &#123; vis[to]=1; q.push(to); &#125; &#125; &#125; &#125; printf(&quot;%d\n&quot;,cost[en]); &#125; return 0;&#125; G - IoU FZU - 2300 签到题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));ull mod=1;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;string s;map&lt;string,ull&gt; mp;int T;struct node &#123; ll x,y,w,h;&#125;a[3];int main() &#123; scanf(&quot;%d&quot;, &amp;T); while (T --) &#123; scanf(&quot;%lld %lld %lld %lld&quot;, &amp;a[0].x,&amp;a[0].y,&amp;a[0].w,&amp;a[0].h); scanf(&quot;%lld %lld %lld %lld&quot;, &amp;a[1].x,&amp;a[1].y,&amp;a[1].w,&amp;a[1].h); ll wi = (min(a[0].x+a[0].w, a[1].x+a[1].w)-max(a[0].x, a[1].x)); ll hi = (min(a[0].y+a[0].h, a[1].y+a[1].h)-max(a[0].y, a[1].y)); ll un; if(wi &gt; 0 &amp;&amp; hi &gt; 0) un = wi*hi; else un = 0; //debug(un); ll sum = a[0].w*a[0].h+a[1].w*a[1].h-un; //debug(sum); printf(&quot;%.2f\n&quot;, 1.0*un/sum); &#125; return 0;&#125;/*61 1 1 11 1 2 21 1 2 11 1 1 21 1 2 22 0 1 10 3 3 32 2 2 10 3 3 32 4 5 51 1 1 1-100 -100 1 1*/ H - Chosen by god FZU - 2301 题意：n点伤害随机分配，求分配到敌人身上大于等于m，的期望，就是求C(M,N)+…+C(M,N); 题解：打个组合数的表，然后前缀处理一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e3+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int c[maxn][maxn];int q[maxn][maxn];int b2[maxn];long long pow(long long x,long long n,long long mod=1e9+7) &#123; long long res=1; while(n&gt;0) &#123; if(n&amp;1)res=res*x%mod; x=x*x%mod; n&gt;&gt;=1; &#125; return res%mod;&#125;int main() &#123; c[1][1]=1; c[1][0]=1; for(int i=1; i&lt;1e3+1; i++) &#123; c[i+1][0]=1;// printf(&quot;%d &quot;,c[i+1][0]); for(int j=1; j&lt;=i+1; j++) &#123; c[i+1][j]=(c[i][j-1]+c[i][j])%mod;// printf(&quot;%d &quot;,c[i+1][j]); &#125; &#125; for(int i=1; i&lt;1e3+1; i++) &#123; for(int j=0; j&lt;=i; j++) &#123; q[i][j+1]=(q[i][j]+c[i][j])%mod; &#125; &#125; b2[0]=1; for(int i=1; i&lt;1e3+1; i++) &#123; b2[i]=(b2[i-1]*2)%mod; &#125; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); if(m&gt;n) &#123; puts(&quot;0&quot;); &#125; else &#123; cout&lt;&lt;(q[n][n+1]-q[n][m]+mod)%mod*pow(b2[n],mod-2,mod)%mod&lt;&lt;endl; &#125; &#125; return 0;&#125; J - Mind control FZU - 2303 题意：n个人，m个蛋糕，你把蛋糕给一个人，他后面的人也会被选上，例如选1 ，2 3 4 5 ….等都会被选上，选 3 4 5 …都会被选上，求选上人数的期望。 题解：给蛋糕的总肯能是C（M,N），选的人最高为1 的选择种数是，C（M-1,N-1），选一个蛋糕给1，然后其他蛋糕给他后面的人，以此类推，最高为2 选择种数是 ,C(M-1,N-2)，最高为3 可能是 C（m-1,N-3）; 然后权值乘以概率就是期望 ，NC(M-1,N-1)+(N-1)C(M-1,N-2)+….+M*C(M-1,M-1)/C(M,N)； 看到权值是 N,N-1肯定要化进组合数 ，大答案m/m, 就可以化成MC(M,N)+M(M,N-1)+…..+MC(M,M)/C(M,N)； 在化简 MC(M+1,N+1)/C(M,N)最后化为M(N+1)/(M+1)； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;long long pow(long long x,long long n,long long mod=1e9+7) &#123; long long res=1; while(n&gt;0) &#123; if(n&amp;1)res=res*x%mod; x=x*x%mod; n&gt;&gt;=1; &#125; return res%mod;&#125;void read(ll &amp;sum) &#123; sum=0; int flag=0; char ch=getchar(); while(!(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)) &#123; if (ch == &apos;-&apos;) &#123; flag = 1; &#125; ch=getchar(); &#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)sum=sum*10+ch-48,ch=getchar(); if(flag)sum*=-1;&#125;int main() &#123; ll t; read(t); while(t--) &#123; ll n,m; read(n); read(m); cout&lt;&lt;m*(n+1)%mod*pow(m+1,mod-2,mod)%mod&lt;&lt;&quot;\n&quot;; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016CCPC东北地区大学生程序设计竞赛 - 重现赛]]></title>
    <url>%2F2018%2F08%2F23%2F2016CCPC%E4%B8%9C%E5%8C%97%E5%9C%B0%E5%8C%BA%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%20-%20%E9%87%8D%E7%8E%B0%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[A 题目连接：HDU 5922 Minimum’s Revenge 水题，每次连接上1就行，就是一个等差数列。 123456789101112131415161718192021222324252627282930313233343536373839404142434445 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int main() &#123; int n,t,cas=1; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d&quot;,&amp;n); ll res=n; printf(&quot;Case #%d: %lld\n&quot;,cas++,(res+2)*(res-1)/2); &#125; return 0;&#125; B 题目链接：HDU 5923 Prediction 题意：一棵树，每个点代表一条边，每次选择几个点，需要把他的祖先也选上，然后把图里面相应的边连接上，问连接后的图有多少个联通块。 题解：可持续化并查集，每个顶点开一个并查集，维护从根节点到当前节点已经连接的图，再把自己这条边连上。 查询，把所有点的并查集合并一下就可以，然后输出合并后并查集块的个数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 #include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=5e2+2;const int maxm=1e4+5;bool u[maxm];int par[maxm][maxn];struct node &#123; int x,y; int fa;&#125; tree[maxm];int n,m;int find(int y,int x) &#123; return par[y][x]==x?x:par[y][x]=find(y,par[y][x]);&#125;void dfs(int x) &#123; int fa=tree[x].fa; u[x]=1; if(u[fa]==0) &#123; dfs(fa); &#125; else &#123; if(x==1) &#123;// cout&lt;&lt;&quot;1asd&quot;&lt;&lt;endl; for(int i=0; i&lt;=n; i++)par[1][i]=i; par[1][tree[x].x]=tree[x].y; &#125; else &#123; for(int i=0; i&lt;=n; i++)par[x][i]=par[fa][i]; int X=find(x,tree[x].x),Y=find(x,tree[x].y); if(X!=Y) &#123; par[x][X]=par[x][Y]; &#125; &#125; &#125;&#125;int main() &#123; int t,cas=1; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=m; i++) &#123; if(i==1)tree[i].fa=1; else &#123; int x; scanf(&quot;%d&quot;,&amp;x); tree[i].fa=x; &#125; &#125; for(int i=1; i&lt;=m; i++) &#123; u[i]=0; scanf(&quot;%d%d&quot;,&amp;tree[i].x,&amp;tree[i].y); &#125; for(int i=1; i&lt;=m; i++) &#123; if(!u[i]) &#123; dfs(i); &#125; &#125; int q; scanf(&quot;%d&quot;,&amp;q); printf(&quot;Case #%d:\n&quot;,cas++); while(q--) &#123; int k,s; scanf(&quot;%d&quot;,&amp;k); int res=0; for(int i=0; i&lt;=n; i++)par[0][i]=i; while(k--) &#123; scanf(&quot;%d&quot;,&amp;s);// for(int i=1; i&lt;=n; i++)printf(&quot;%d &quot;,par[s][i]); for(int i=1; i&lt;=n; i++) &#123; int t1=find(0,i),t2=find(s,i); if(t1!=t2) &#123; int t3=find(0,t2); if(t3!=t1) &#123; res++; par[0][t1]=par[0][t3]; &#125; &#125; &#125; &#125; printf(&quot;%d\n&quot;,n-res); &#125; &#125; return 0;&#125; C 题目连接：HUD 5924 Mr. Frog’s Problem A/B+ B/A 只有在两个数最接近的时候最小，所以如果A&lt;=C&lt;D&lt;=B,C /D+D/C必定小于于等 A/B+B/A所以只有和A B相同的时候才会满足条件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;ll a,b,t,n;int main() &#123; int cas=1; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;a&gt;&gt;b; printf(&quot;Case #%d:\n&quot;,cas++); if(a==b) &#123; puts(&quot;1&quot;); cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl; &#125; else &#123; puts(&quot;2&quot;); cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl; cout&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;a&lt;&lt;endl; &#125; &#125; return 0;&#125; D 题目连接:HDU 5925 Coconuts 题意：给你一个R*C的矩阵中间有几个n个点，问分成了几个联通块，联通块的大小是多少。 题解：R，C范围是1e9肯定是要离散，离散之后变成了一个不到 2000*2000的矩阵，求联通块数量直接DFS一遍就可以了。 问题来了了，离散之后怎么求每个块的大小呢。 首先你是根据行和列分别离散，计算主要是把离散掉的重新算回来。 如下图加入黄色是你被覆盖的格子，你会把横着离散黑色的格子为一个格子，红色的竖着离散成一个格子。因此，你只要把这些离散的格子从新加回来就行了，另外还要加上中间那一块被离散掉的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=205;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;map&lt;int,int&gt; mpx,mpy;int x[maxn],y[maxn];int lx[maxn],ly[maxn];ll vx[maxn*10],vy[maxn*10];int mp[maxn*10][maxn*10],mx,my;int dx[]= &#123;-1,0,1,0&#125;,dy[]= &#123;0,-1,0,1&#125;;ll ans[maxn*10];void dfs(int tx,int ty,int pos) &#123; if(mp[tx][ty]!=0)return ; mp[tx][ty]=pos; ++ans[pos]; for(int i=0; i&lt;4; i++) &#123; int ttx=tx+dx[i],tty=ty+dy[i]; if(ttx&gt;0&amp;&amp;ttx&lt;=mx&amp;&amp;tty&gt;0&amp;&amp;tty&lt;=my) &#123; dfs(ttx,tty,pos); &#125; &#125;&#125;int main() &#123; int cas=1,t;// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); scanf(&quot;%d&quot;, &amp;t); while(t--) &#123; mpx.clear(); mpy.clear(); mem(ans,0); int r,c; scanf(&quot;%d%d&quot;,&amp;r,&amp;c); scanf(&quot;%d&quot;,&amp;n); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]); lx[i]=x[i]; ly[i]=y[i]; &#125; lx[n]=r; sort(lx,lx+n+1); int d=0; vx[d]=0; for(int i=0; i&lt;=n; i++) &#123; if(lx[i]==vx[d])continue; else if(lx[i]==vx[d]+1) &#123; vx[d+1]=vx[d]+1; mpx[lx[i]]=d+1; d+=1; &#125; else if(lx[i]-d==2) &#123; vx[d+1]=vx[d]+1; vx[d+2]=vx[d]+2; mpx[lx[i]]=d+2; d+=2; &#125; else &#123; vx[d+1]=vx[d]+1; vx[d+2]=lx[i]; mpx[lx[i]]=d+2; d+=2; &#125; &#125; ly[n]=c; sort(ly,ly+n+1); mx=d; d=0; vy[d]=0; for(int i=0; i&lt;=n; i++) &#123; if(ly[i]==vy[d])continue; else if(ly[i]==vy[d]+1) &#123; vy[d+1]=vy[d]+1; mpy[ly[i]]=d+1; d+=1; &#125; else if(ly[i]-d&gt;=2) &#123; vy[d+1]=vy[d]+1; vy[d+2]=ly[i]; mpy[ly[i]]=d+2; d+=2; &#125; &#125; my=d; mem(mp,0); for(int i=0; i&lt;n; i++) &#123; mp[mpx[x[i]]][mpy[y[i]]]=-1; &#125; int num=1; for(int i=1; i&lt;=mx; i++) &#123; for(int j=1; j&lt;=my; j++) &#123; if(mp[i][j]==0) &#123; dfs(i,j,num++); &#125; &#125; &#125; for(int j=1; j&lt;=my; j++) &#123; //把离散竖着的加起来 for(int i=1; i&lt;=mx; i++) &#123; if(mp[i][j]!=-1) &#123; ans[mp[i][j]]+=vx[i]-vx[i-1]-1; &#125; else if(mp[i-1][j]!=-1) &#123; ans[mp[i-1][j]]+=vx[i]-vx[i-1]-1; &#125; &#125; &#125; for(int i=1; i&lt;=mx; i++) &#123; //把横着离散掉的加起来 for(int j=1; j&lt;=my; j++) &#123; if(mp[i][j]!=-1) &#123; ans[mp[i][j]]+=vy[j]-vy[j-1]-1; &#125; else if(mp[i][j-1]!=-1) &#123; ans[mp[i][j-1]]+=vy[j]-vy[j-1]-1; &#125; &#125; &#125; for(int i=1; i&lt;=mx; i++) &#123; //把中间那块离散掉的加起来 for(int j=1; j&lt;=my; j++) &#123; if(mp[i][j]!=-1) &#123; ans[mp[i][j]]+=(vy[j]-vy[j-1]-1)*(vx[i]-vx[i-1]-1); &#125; else if(mp[i-1][j-1]!=-1) &#123; ans[mp[i-1][j-1]]+=(vy[j]-vy[j-1]-1)*(vx[i]-vx[i-1]-1); &#125; &#125; &#125; printf(&quot;Case #%d:\n%d\n&quot;,cas++,num-1); sort(ans+1,ans+num); for(int i=1; i&lt;num; i++) &#123; printf(&quot;%lld&quot;,ans[i]); if(i+1==num)printf(&quot;\n&quot;); else printf(&quot; &quot;); &#125; &#125; return 0;&#125;下面是2组数据，正确答案能手算出来/*2100 100201 501 511 551 602 502 542 562 603 503 513 553 604 514 524 534 544 564 574 584 59100 10081 22 1100 9999 10099 1100 21 992 100*/ E:题目链接 HDU 5926 Mr. Frog’s Game 水题不解释了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int ar[35][35];int n,m;int dir[4][2]=&#123;1,0,0,1,-1,0,0,-1&#125;;int main() &#123; int cas=1,t; scanf(&quot;%d&quot;, &amp;t); while(t--) &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=0;i&lt;n;++i)&#123; for(int j = 0; j &lt; m; ++j)&#123; scanf(&quot;%d&quot;, &amp;ar[i][j]); &#125; &#125; int flag = 0; for(int i=0;i&lt;n;++i)&#123; for(int j=0;j&lt;m;++j)&#123; for(int k=0;k&lt;4;++k)&#123; int px = i + dir[k][0],py = j + dir[k][1]; if(px&lt;0||py&lt;0||px&gt;=n||py&gt;=m)continue; if(ar[px][py]==ar[i][j])&#123; flag=1;break; &#125; &#125; if(flag)break; &#125; if(flag)break; &#125; for(int i=0;i&lt;n;++i)&#123; for(int j=i+1;j&lt;n;++j)&#123; if(ar[i][0]==ar[j][0]||ar[i][m-1]==ar[j][m-1])&#123; flag=1;break; &#125; &#125; if(flag)break; &#125; for(int i=0;i&lt;m;++i)&#123; for(int j=i+1;j&lt;m;++j)&#123; if(ar[0][i]==ar[0][j]||ar[n-1][i]==ar[n-1][j])&#123; flag=1;break; &#125; &#125; if(flag)break; &#125; printf(&quot;Case #%d: &quot;,cas++); if(flag)printf(&quot;Yes\n&quot;); else printf(&quot;No\n&quot;); &#125; return 0;&#125; F 题目链接：HDU 5927 Auxiliary Set 题意：随便选几个点作为不重要的点，其他的全是重要的点，然后把不重要的点中如果是两个不同节点的最近公共祖先就把他变为重要的点，问，选了几个不重要的点，最后重要的点总共有多少个。 题解：数据看的挺吓人的 1e3 组 1e5的数据那命去写啊，实际上没多少。。。。。直接按不重要的点深度排个序，如果是另外两个重要的点的LCA就变成重要的点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,m;struct edge &#123; int to,next;&#125; eg[maxn*2];int head[maxn],tot;void init() &#123; mem(head,-1); tot=0;&#125;void add(int u,int v) &#123; eg[tot].to=v; eg[tot].next=head[u]; head[u]=tot++;&#125;int dep[maxn],pre[maxn];int u[maxn];int res[maxn];int num[maxn];int dfs(int r,int p,int d) &#123; dep[r]=d; pre[r]=p; int ans=0; for(int i=head[r]; i!=-1; i=eg[i].next) &#123; if(eg[i].to!=p) &#123; ans+=dfs(eg[i].to,r,d+1); &#125; &#125; num[r]=ans; return ans;&#125;void read(int &amp;sum) &#123; scanf(&quot;%d&quot;,&amp;sum); return ; sum=0; int flag=0; char ch=getchar(); while(!(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)) &#123; if (ch == &apos;-&apos;) &#123; flag = 1; &#125; ch=getchar(); &#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)sum=sum*10+ch-48,ch=getchar(); if(flag)sum*=-1;&#125;bool cmp(int &amp;a,int &amp;b) &#123; return dep[a]&gt;dep[b];&#125;int main() &#123; int t,cas=1; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; read(n); read(m); init(); for(int i=0; i&lt;n-1; i++) &#123; int a,b; read(a); read(b); add(a,b); add(b,a); &#125; dfs(1,-1,1); printf(&quot;Case #%d:\n&quot;,cas++); while(m--) &#123; int k,d,ans=0; read(k); ans=n-k; for(int i=0; i&lt;k; i++) &#123; read(res[i]); u[res[i]]=-1; &#125; sort(res,res+k,cmp); for(int i=0; i&lt;k; i++) &#123; d=0; for(int j=head[res[i]]; j!=-1; j=eg[j].next) &#123; int to=eg[j].to; if(to==pre[res[i]]) &#123; continue; &#125; else &#123; if(u[to]&lt;0) &#123; continue; &#125; if(u[res[i]]==-1) &#123; u[res[i]]=1; &#125; else u[res[i]]++; if(u[res[i]]==2) &#123; ans++; break; &#125; &#125; &#125; &#125; for(int i=0; i&lt;k; i++)u[res[i]]=0; printf(&quot;%d\n&quot;,ans); &#125; &#125; return 0;&#125; H 题目连接：HDU 5929 Basic Data Structure 简单模拟一下就可以了，记录下一最后一个零的位置，因为到零除了是第一个位置之外全都必定是1. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int a[maxn];int l,r;int t,cas=1;int Q;char s[100];deque&lt;int&gt; q;int main() &#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;,&amp;Q); int x; bool b=1; l=r=2e5+5; printf(&quot;Case #%d:\n&quot;,cas++); q.clear(); while(Q--) &#123; scanf(&quot;%s&quot;,s); if(b) &#123; if(s[0]==&apos;P&apos;&amp;&amp;s[1]==&apos;U&apos;) &#123; scanf(&quot;%d&quot;,&amp;x); a[++r]=x; if(x==0)q.push_back(r); &#125; else if(s[0]==&apos;Q&apos;) &#123; if(r==l)printf(&quot;Invalid.\n&quot;); else if(r-l==1)printf(&quot;%d\n&quot;,a[r]); else &#123; if(q.size()==0) &#123; printf(&quot;%d\n&quot;,(r-l)&amp;1); &#125; else &#123; int k=q.front(); if(r==k)printf(&quot;%d\n&quot;,(k-l+1)&amp;1); else printf(&quot;%d\n&quot;,(k-l)&amp;1); &#125; &#125; &#125; else if(s[0]==&apos;R&apos;) &#123; b=0; &#125; else &#123; if(a[r]==0)q.pop_back(); --r; &#125; &#125; else &#123; if(s[0]==&apos;P&apos;&amp;&amp;s[1]==&apos;U&apos;) &#123; scanf(&quot;%d&quot;,&amp;x); a[l--]=x; if(x==0)q.push_front(l+1); &#125; else if(s[0]==&apos;Q&apos;) &#123; if(r==l)printf(&quot;Invalid.\n&quot;); else if(r-l==1)printf(&quot;%d\n&quot;,a[r]); else &#123; if(q.size()==0)printf(&quot;%d\n&quot;,(r-l)&amp;1); else &#123; int k=q.back(); if(k==l+1)printf(&quot;%d\n&quot;,(r-k)&amp;1); else printf(&quot;%d\n&quot;,(r-k+1)&amp;1); &#125; &#125; &#125; else if(s[0]==&apos;R&apos;) &#123; b=1; &#125; else &#123; if(a[l+1]==0)q.pop_front(); ++l; &#125; &#125; &#125; &#125; return 0;&#125; I -题目链接：HDU - 5930 GCD 这题是真的难理解.这题要是不用线段树大家都会写吧，首先暴力从前面的每个位置到当前位置的GCD ，然后记录每个GCD的个数，更新一个点就是删除一个点，然后再加一个点，就是暴力从前面所有位置到后面所有位置的GCD，减去这个值。把值更新再一次算从前面所有位置到后面所有位置的GCD，然后加上去。 竟然会这个这个，这题就是用线段树维护一下GCD的值，，，就像二分一样，因为会有很长一段的GCD值是一样的，每次不用一个个去找，直接找到前面GCD改变的位置，然后减去上一次GCD改变的位置。也是一种暴力。。。修改其实也是一样的就是把前面GCD和后面GCD求一个GCD，然后前后GCD 的数量相乘 比如 1 1 1 2 4 4 4 前面3个数的GCD是3 个 1 和后面3个数 是 2 那么GCD为 gcd(1,2) 数量就是 3 * 3; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int g[maxn&lt;&lt;4],c[maxn];int f[maxn&lt;&lt;4],a[maxn],aa[maxn],b[maxn],bb[maxn];int A,B,n,m;long long gcd(long long a,long long b) &#123; return b==0?a:gcd(b,a%b);&#125;void build(int l,int r,int k) &#123; if(r-l==1) &#123; g[k]=c[r]; &#125; else &#123; build(lson); build(rson); g[k]=gcd(g[chl],g[chr]); &#125;&#125;int findleft(int l,int r,int k,int u,int v) &#123; if(r&lt;=u) &#123; if(gcd(g[k],v)==v)return 0; if(l+1==r)return r; int x=findleft(rson,u,v); if(x)return x; else return findleft(lson,u,v); &#125; if(u&gt;mid) &#123; int x=findleft(rson,u,v); if(x)return x; &#125; return findleft(lson,u,v);&#125;void getleft(int x) &#123; A=0; for(int i=c[x],j=x,k; j!=0; j=k) &#123; k=findleft(0,n,0,j,i); a[A]=j-k; aa[A++]=i; if(k==0)return ; i=gcd(c[k],i); &#125; return ;&#125;int findright(int l,int r,int k,int u,int v) &#123; //这个是用线段树往左找GCD if(l+1&gt;=u) &#123; if(gcd(g[k],v)==v)return n+1; if(l+1==r)return r; int x = findright(lson,u,v); if(x&lt;=n)return x; else return findright(rson,u,v); &#125; if(u&lt;=mid) &#123; int x=findright(lson,u,v); if(x&lt;=n)return x; &#125; return findright(rson,u,v);&#125;void getright(int x) &#123; B=0; for(int i= c[x],j=x,k; j&lt;=n; j=k) &#123; //这个是暴力X所有左边的GCD k=findright(0,n,0,j,i); b[B]=k-j; bb[B++]=i; i=gcd(c[k],i); &#125; return ;&#125;void change(int l,int r,int k,int u,int v) &#123; if (l+1==r) &#123; g[k] = v; return; &#125; if (u&lt;=mid) change(lson,u,v); else change(rson,u,v); g[k]=gcd(g[chl],g[chr]);&#125;int main() &#123; int t,cas=1; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; printf(&quot;Case #%d:\n&quot;,cas++); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; ++i)scanf(&quot;%d&quot;,&amp;c[i]); build(0,n,0); //初始化线段树 memset(f,0,sizeof(f)); int ans=0; for(int i=1; i&lt;=n; i++) &#123; getleft(i); //初始化只要找所有i左边的GCD或者右边也可以，但是只能找一边不然会重复。 for(int j=0; j&lt;A; j++) &#123; if(!f[aa[j]])ans++; f[aa[j]]+=a[j]; &#125; &#125; while(m--) &#123; int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); getleft(x); //找到所有左边的GCD getright(x); //找到所有右边的GCD for(int j=0; j&lt;A; j++) &#123;//暴力所有左右两边GCD所有可能 for(int k=0; k&lt;B; k++) &#123; int t=gcd(aa[j],bb[k]); //左右两边的GCD的GCD f[t]-=1LL *a[j]*b[k]; // 暴力删除 if(!f[t])ans--; &#125; &#125; c[x]=y; change(0,n,0,x,y); getleft(x); getright(x); for(int j=0; j&lt;A; j++) &#123; for(int k=0; k&lt;B; k++) &#123; int t=gcd(aa[j],bb[k]);//暴力添加 if(!f[t])ans++; f[t]+=1LL*a[j]*b[k]; &#125; &#125; printf(&quot;%d\n&quot;,ans); // 得出结论 &#125; &#125; return 0;&#125; J 题目链接：HDU5931 - Mission Possible 暴力所有速度，推一下公式，发现要么是用初始血量去掉不加血，要么是加血等于掉血数量的时候是最优解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;ll D,A,GA,GB,GC;int main() &#123; int t,cas=1; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%lld%lld%lld%lld%lld&quot;,&amp;D,&amp;A,&amp;GA,&amp;GB,&amp;GC); ll v,r,h; ll ans=1e18,temp; for(v=1; v&lt;=D; v++) &#123; double t=1.0*D/v; temp=v*GB+A*GC+A*GA; ans=min(ans,temp); double tem2=t*A; temp=v*GB+floor(t*A-eps+1)*GA;// debug(temp-v*GB); ans=min(ans,temp); &#125; printf(&quot;Case #%d: %lld\n&quot;,cas++,ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第八届福建省大学生程序设计竞赛-FZU 2280 HASH处理+暴力搜索]]></title>
    <url>%2F2018%2F08%2F21%2F%E7%AC%AC%E5%85%AB%E5%B1%8A%E7%A6%8F%E5%BB%BA%E7%9C%81%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-FZU%202280%20HASH%E5%A4%84%E7%90%86%2B%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[题目：Problem 2280 Magic Problem Description Kim is a magician, he can use n kinds of magic, number from 1 to n. We use string Si to describe magic i. Magic Si will make Wi points of damage. Note that Wi may change over time. Kim obey the following rules to use magic: Each turn, he picks out one magic, suppose that is magic Sk, then Kim will use all the magic i satisfying the following condition: Wi&lt;=Wk Sk is a suffix of Si. Now Kim wondering how many magic will he use each turn. Note that all the strings are considered as a suffix of itself. Input First line the number of test case T. (T&lt;=6) For each case, first line an integer n (1&lt;=n&lt;=1000) stand for the number of magic. Next n lines, each line a string Si (Length of Si&lt;=1000) and an integer Wi (1&lt;=Wi&lt;=1000), stand for magic i and it’s damage Wi. Next line an integer Q (1&lt;=Q&lt;=80000), stand for there are Q operations. There are two kinds of operation. “1 x y” means Wx is changed to y. “2 x” means Kim has picked out magic x, and you should tell him how many magic he will use in this turn. Note that different Si can be the same. Output For each query, output the answer. Sample Input 1 5 abracadabra 2 adbra 1 bra 3 abr 3 br 2 5 2 3 2 5 1 2 5 2 3 2 2 Sample Output 3 1 2 1 Source 第八届福建省大学生程序设计竞赛-重现赛（感谢承办方厦门理工学院） 题目：给你n个字符串以及权值，两种操作 一种 更新字符串对应的权值 ，查询 输出所有以当前字符串为后缀且对应权值小于当前字符串权值的个数。 题解：首先hash 预处理所有能供以当前字符串为后缀的字符串，直接n^2暴力就行。。。 然后查询直接暴力搜索小于当前字符串权值的。 数据只有1000 的范围随便暴力啊。。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e3+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;const int seed=131;ull Hash[maxn][maxn];ull po[maxn];char ch[maxn][maxn];int t,n;int len[maxn];bool mp[maxn][maxn];int val[maxn];void init() &#123; mem(mp,0); po[0]=1; for(int i=1; i&lt;1002; i++) &#123; po[i]=po[i-1]*seed; &#125; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=len[i]; j++) &#123; Hash[i][j]=Hash[i][j-1]*seed+ch[i][j]; &#125; &#125; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=n; j++) &#123; if(len[j]&lt;len[i])continue; else &#123; int l=len[j]-len[i]; if(Hash[j][len[j]]-Hash[j][l]*po[len[i]]==Hash[i][len[i]]) &#123; mp[i][j]=1; &#125; &#125; &#125; &#125;&#125;void read(int &amp;sum) &#123; sum=0; int flag=0; char ch=getchar(); while(!(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)) &#123; if (ch == &apos;-&apos;) &#123; flag = 1; &#125; ch=getchar(); &#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)sum=sum*10+ch-48,ch=getchar(); if(flag)sum*=-1;&#125;int main() &#123; read(t); while(t--) &#123; read(n); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%s%d&quot;,ch[i]+1,&amp;val[i]); len[i]=strlen(ch[i]+1); &#125; init(); int q; read(q); while(q--) &#123; int op; read(op); int x,y; if(op==1) &#123; read(x); read(y); val[x]=y; &#125; else &#123; read(x); int ans=0; for(int i=1;i&lt;=n;i++)if(mp[x][i]&amp;&amp;val[x]&gt;=val[i])ans++; printf(&quot;%d\n&quot;,ans); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性排序算法 --- 计数排序，基数排序，桶排序]]></title>
    <url>%2F2018%2F08%2F21%2F%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%20---%20%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%8C%E6%A1%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[计数排序应用: J - Jeronimo’s List Gym - 101466J http://codeforces.com/gym/101466/problem/J 线性排序算法计数排序应该挺好理解的，每次把数字出现的次数记录下来，然后做成前缀，前缀就是小于等于当前数的个数。 比如 2,3,0,3,6,2,3,5，首先记录出现次数 0 1 2 3 4 5 6 1 0 2 3 0 1 1 然后对这个数组做一个前缀 c[0] c[1] c[2] c[3] c[4] c[5] c[6] 1 1 3 6 6 7 8 就是这样 ，然后排序的时候就 输出数字对应的地方 如 a[i]= 5 那么 b[c[a[i]]]=a[i]; 把b 数组里面 7的位置赋值为5.然后小于等于5的数量-1； 1234567891011121314151617181920212223242526272829303132 #include&lt;bits/stdc++.h&gt;using namespace std;int a[8]= &#123;2,3,0,3,6,2,3,5&#125;;int b[8];int c[7];int main() &#123; for(int i=0; i&lt;8; i++) &#123; c[a[i]]++; &#125; for(int i=1; i&lt;7; i++) &#123; //把这个for倒过来就是从大到小 c[i]=c[i-1]+c[i]; &#125; printf(&quot;C数组:\n&quot;); for(int i=0; i&lt;7; i++) &#123; printf(&quot;c[%d]\t&quot;,i); &#125; printf(&quot;\n&quot;); for(int i=0; i&lt;7; i++) &#123; printf(&quot; %d\t&quot;,c[i]); &#125; printf(&quot;\n&quot;); printf(&quot;排序过程\n&quot;); for(int i=7; i&gt;=0; i--) &#123; b[--c[a[i]]]=a[i]; for(int i=0; i&lt;7; i++) &#123; printf(&quot;%d &quot;,b[i]); &#125; printf(&quot;\n&quot;); &#125; return 0;&#125; 基数排序： 实际上和计数排序没啥太大的区别 ，计数排序如果数太大，你 C数组的就要浪费非常大的内存，或者根本开不了这么大的内存。 基数排序，就是把每个 位拆分出来，实际上和计数排序差距不大。 12,13,120,33,46,52,3,25 120 12 52 13 33 3 25 46 以最后一位递增 3 12 13 120 25 33 46 52 在最后一位为递增基础上倒数第2位递增 3 12 13 25 33 46 52 120 最后以 第一位 递增，就是排序好的 12345678910111213141516171819202122232425262728293031323334353637383940414243 #include&lt;bits/stdc++.h&gt;using namespace std;int a[8]= &#123;12,13,120,33,46,52,3,25&#125;;int b[8];int c[10];int main() &#123; int mx=0,pos=0,cot=1; for(int i=0; i&lt;8; i++) &#123; mx=max(mx,a[i]); &#125; while(mx/cot&gt;0) &#123; memset(c,0,sizeof(c)); for(int i=0; i&lt;8; i++) &#123; c[a[i]/cot%10]++; &#125; for(int i=1; i&lt;10; i++) &#123; //把这个for倒过来就是从大到小 c[i]=c[i-1]+c[i]; &#125; printf(&quot;计数数组:\n&quot;); for(int i=0; i&lt;10; i++) &#123; printf(&quot;c[%d]\t&quot;,i); &#125; printf(&quot;\n&quot;); for(int i=0; i&lt;10; i++) &#123; printf(&quot; %d\t&quot;,c[i]); &#125; printf(&quot;\n&quot;); printf(&quot;排序第%d位结果:\n&quot;,pos); for(int i=7; i&gt;=0; i--) &#123; b[--c[a[i]/cot%10]]=a[i]; &#125; for(int i=0; i&lt;8; i++) &#123; a[i]=b[i]; &#125; for(int i=0;i&lt;8;i++)&#123; printf(&quot;%d &quot;,a[i]); &#125; puts(&quot;&quot;); cot*=10; pos++; &#125; return 0;&#125; 桶排序，实际上和计数排序也差不多，但是到目前位置我还没用过。 计数排序就相当于 桶的大小为 1 的排序 。（基数排序实际上有点类似于以10 的桶里面套着一个10 的桶）个人理解 开一个桶的大小 b 然后把他一个数x丢到 x/b 那个桶里面去，然后把每个桶里面排序。把桶分成1不就是计数排序。。个人理解 理论上来说：在分布桶均匀的情况下，是O(n+n*(2-1/n)); 有些情况下可能退化成 普通排序一样的复杂度。 代码就不敲了，还没用过。。。。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第八届福建省大学生程序设计竞赛-FZU 2277 DFS +线段树+读入挂]]></title>
    <url>%2F2018%2F08%2F20%2F%E7%AC%AC%E5%85%AB%E5%B1%8A%E7%A6%8F%E5%BB%BA%E7%9C%81%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-FZU%202277%20%20DFS%20%2B%E7%BA%BF%E6%AE%B5%E6%A0%91%2B%E8%AF%BB%E5%85%A5%E6%8C%82%2F</url>
    <content type="text"><![CDATA[FZU 2277 Problem 2277 Change Accept: 245 Submit: 1186 Time Limit: 2000 mSec Memory Limit : 262144 KB Problem Description There is a rooted tree with n nodes, number from 1-n. Root’s number is 1.Each node has a value ai. Initially all the node’s value is 0. We have q operations. There are two kinds of operations. 1 v x k : a[v]+=x , a[v’]+=x-k (v’ is child of v) , a[v’’]+=x-2*k (v’’ is child of v’) and so on. 2 v : Output a[v] mod 1000000007(10^9 + 7). Input First line contains an integer T (1 ≤ T ≤ 3), represents there are T test cases. In each test case: The first line contains a number n. The second line contains n-1 number, p2,p3,…,pn . pi is the father of i. The third line contains a number q. Next q lines, each line contains an operation. (“1 v x k” or “2 v”) 1 ≤ n ≤ 3*10^5 1 ≤ pi &lt; i 1 ≤ q ≤ 3*10^5 1 ≤ v ≤ n; 0 ≤ x &lt; 10^9 + 7; 0 ≤ k &lt; 10^9 + 7 Output For each operation 2, outputs the answer. Sample Input 1 3 1 1 3 1 1 2 1 2 1 2 2 Sample Output 2 1 Source 题意：给你一棵树 有两种操作：查询节点的值，和将所有树节点及以下下所有的节点 + x - (子节点深度-当前深度)*k 的值 题解：首先肯定是DFS建序，然后根据dfs 序建一颗线段树，这题更新操作是更新一个区间，查询是单点。 这题只要用一个dep数组保存每个节点所包含区间里面的最小深度，然后向下更新的时候每次把，x，和k，更新下去； 更新的时候直接把，(子节点深度-当前深度)*k的值更新到 ，x,里面。 查询直接返回单点的x. 这题主要是卡取模和读入。。。读入特么就快超时了，最让我无语的还是超时给我返回一个WA加个读入挂就过了。。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef ll LL;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=3e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int e[maxn],s[maxn],tdep[maxn];int cnt=0;struct node &#123; ll x,k;&#125; lazy[maxn&lt;&lt;4];int dep[maxn&lt;&lt;4];struct edge &#123; int to,next;&#125; eg[maxn];int head[maxn],tot;void add(int u,int v) &#123; eg[tot].to=v; eg[tot].next=head[u]; head[u]=tot++;&#125;void init() &#123; tot=0; cnt=0; mem(head,-1);&#125;int dfs(int r,int dp) &#123; cnt++; s[r]=cnt; tdep[cnt]=dp; for(int i=head[r]; i!=-1; i=eg[i].next) &#123; int to=eg[i].to; dfs(to,dp+1); &#125; e[r]=cnt;&#125;void build(int l,int r,int k) &#123; if(r-l==1) &#123; dep[k]=tdep[r]; lazy[k].k=0; lazy[k].x=0; &#125; else &#123; build(lson); build(rson); dep[k]=min(dep[chl],dep[chr]); lazy[k].k=0; lazy[k].x=0; &#125;&#125;void pushdown(int l,int r,int k) &#123; if(lazy[k].k==0&amp;&amp;lazy[k].x==0) return ; lazy[chl].k+=lazy[k].k; lazy[chl].k%=mod; lazy[chr].k+=lazy[k].k; lazy[chr].k%=mod; lazy[chl].x+=(lazy[k].x-lazy[k].k%mod*(dep[chl]-dep[k])+mod)%mod; lazy[chl].x=(lazy[chl].x+mod)%mod; lazy[chr].x+=(lazy[k].x-lazy[k].k%mod*(dep[chr]-dep[k])+mod)%mod; lazy[chr].x=(lazy[chr].x+mod)%mod; lazy[k].x=0; lazy[k].k=0;&#125;void update(int a,int b,int l,int r,int k,ll x,ll y,ll dp) &#123; if(b&lt;=l||a&gt;=r) &#123; return ; &#125; else if(a&lt;=l&amp;&amp;r&lt;=b) &#123; lazy[k].x+=(x-y*(dep[k]-dp)%mod+mod)%mod; lazy[k].x%=mod; lazy[k].k+=y; lazy[k].k%=mod; return ; &#125; else &#123; pushdown(l,r,k); update(a,b,lson,x,y,dp); update(a,b,rson,x,y,dp); &#125;&#125;ll res=0;void query(int a,int b,int l,int r,int k) &#123; if(b&lt;=l||a&gt;=r) &#123; return ; &#125; else if(a&lt;=l&amp;&amp;r&lt;=b) &#123; res=lazy[k].x%mod; return ; &#125; else &#123; pushdown(l,r,k); query(a,b,lson); query(a,b,rson); &#125;&#125;void read(LL &amp;sum) &#123; sum=0; char ch=getchar(); while(!(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;))ch=getchar(); while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)sum=sum*10+ch-48,ch=getchar();&#125;void read(int &amp;sum) &#123; sum=0; char ch=getchar(); while(!(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;))ch=getchar(); while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)sum=sum*10+ch-48,ch=getchar();&#125;int main() &#123; int n,t; read(t); while(t--) &#123; init(); scanf(&quot;%d&quot;,&amp;n); for(int i=2; i&lt;=n; i++) &#123; int x; read(x); add(x,i); &#125; dfs(1,1); build(0,n,0); int q; read(q); while(q--) &#123; int op; read(op); ll a,b,c; if(op==1) &#123; read(a); read(b); read(c); update(s[a]-1,e[a],0,n,0,b,c,tdep[s[a]]); &#125; else &#123; scan_d&lt;LL&gt;(a); query(s[a]-1,s[a],0,n,0); printf(&quot;%lld\n&quot;,(res+mod)%mod); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A - Gaby And Addition Gym - 101466A --字典树 ，暴力+贪心]]></title>
    <url>%2F2018%2F08%2F19%2FA%20-%20Gaby%20And%20Addition%20Gym%20-%20101466A%20--%E5%AD%97%E5%85%B8%E6%A0%91%20%EF%BC%8C%E6%9A%B4%E5%8A%9B%2B%E8%B4%AA%E5%BF%83%2F</url>
    <content type="text"><![CDATA[题目链接 ：http://codeforces.com/gym/101466/problem/A A. Gaby And Addition time limit per test 6.0 s memory limit per test 1024 MB input standard input output standard output Gaby is a little baby who loves playing with numbers. Recently she has learned how to add 2 numbers using the standard addition algorithm which we summarize in 3 steps: Line up the numbers vertically matching digits places. Add together the numbers that share the same place value from right to left. Carry if necessary. it means when adding two numbers we will get something like this: Unfortunately as Gaby is too young she doesn’t know what the third step means so she just omitted this step using her own standard algorithm (Gaby’s addition algorithm). When adding two numbers without carrying when necessary she gets something like the following: Gaby loves playing with numbers so she wants to practice the algorithm she has just learned (in the way she learned it) with a list of numbers adding every possible pair looking for the pair which generates the largest value and the smallest one. She needs to check if she is doing it correctly so she asks for your help to find the largest and the smallest value generated from the list of numbers using Gaby’s addition algorithm. Input The input starts with an integer n (2 ≤ n ≤ 106) indicating the number of integers Gaby will be playing with. The next line contains n_numbers _n__i (0 ≤ n__i ≤ 1018) separated by a single space. Output Output the smallest and the largest number you can get from adding two numbers from the list using Gaby’s addition algorithm. Examples input Copy 12 617 5 11 0 42 99 output Copy 10 99 input Copy 12 7506823119072235413 991096248449924896 204242310783332529 778958050378192979 384042493592684633 942496553147499866 410043616343857825 output Copy 152990443860776502 972190360051424498 Note In the first sample input this is how you get the minimum and the maximum value 题意：给 n个数求不进位加法，两个数和的最大值，最小值。 题解：分别对每个数字拆分成 18个位，每个位是 0-9 的数字，然后用每个位建一个字典树。 就形成了一棵以0结点为根节点，然后每层分配0-9 儿子节点的字典树，然后每次查询和当前值相加最大值和最小值，分别每次从取模10最大的和最小的节点匹配。 例如 当前位是 5 最大值直接从当前位儿子节点 4开始找 如果存在直接求两个数的和，否则继续3 2 1.。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;int cnt=1;struct Trie &#123; int son[10]; void init() &#123; for(int i=0; i&lt;10; i++) &#123; son[i]=-1; &#125; &#125;&#125; tree[maxn*20];ll p[20];void insert(int r,int pos,ll val) &#123; if(pos==-1)return ; ll v=val/p[pos]%10; if(tree[r].son[v]==-1) &#123;// printf(&quot;%d&quot;,v); tree[cnt].init(); tree[r].son[v]=cnt++; &#125; insert(tree[r].son[v],pos-1,val);&#125;ll findmx(int r,int pos,ll val) &#123; if(pos==-1)return 0; ll v=val/p[pos]%10; for(int i=9-v; i&gt;=0; i--) &#123; if(tree[r].son[i]!=-1) &#123; return (p[pos]*((v+i)%10))+findmx(tree[r].son[i],pos-1,val); &#125; &#125; for(int i=9; i&gt;9-v; i--) if(tree[r].son[i]!=-1) return (p[pos]*((v+i)%10))+findmx(tree[r].son[i],pos-1,val);&#125;ll findmi(int r,int pos,ll val) &#123; if(pos==-1)return 0; int v=val/p[pos]%10; for(int i=10-v; i&lt;=9; i++) if(tree[r].son[i]!=-1) &#123; return (p[pos]*((v+i)%10))+findmi(tree[r].son[i],pos-1,val); &#125; for(int i=0; i&lt;10-v; i++) if(tree[r].son[i]!=-1) return (p[pos]*((v+i)%10))+findmi(tree[r].son[i],pos-1,val);&#125;int main() &#123; scanf(&quot;%d&quot;,&amp;n); p[0]=1; for(int i=1; i&lt;=18; i++) &#123; p[i]=p[i-1]*10; &#125; tree[0].init(); ll mx=-1e18,mi=1e18; for(int i=0; i&lt;n; i++) &#123; ll x; scanf(&quot;%lld&quot;,&amp;x); if(i!=0) &#123; mi=min(mi,findmi(0,18,x)); mx=max(mx,findmx(0,18,x)); &#125; insert(0,18,x);// puts(&quot;&quot;); &#125; printf(&quot;%lld %lld\n&quot;,mi,mx); return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K - Random Numbers Gym - 101466K ------线段树+DFS序]]></title>
    <url>%2F2018%2F08%2F19%2FK%20-%20Random%20Numbers%20Gym%20-%20101466K%20%20------%E7%BA%BF%E6%AE%B5%E6%A0%91%2BDFS%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[K. Random Numbers time limit per test 2.0 s memory limit per test 256 MB input standard input output standard output Tamref love random numbers, but he hates recurrent relations, Tamref thinks that mainstream random generators like the linear congruent generator suck. That’s why he decided to invent his own random generator. As any reasonable competitive programmer, he loves trees. His generator starts with a tree with numbers on each node. To compute a new random number, he picks a rooted subtree and multiply the values of each node on the subtree. He also needs to compute the number of divisors of the generated number (because of cryptographical applications). In order to modify the tree (and hence create different numbers on the future), Tamref decided to perform another query: pick a node, and multiply its value by a given number. Given a initial tree T, where T__u corresponds to the value on the node u, the operations can be summarized as follows: RAND: Given a node u compute and count its divisors, where T(u) is the set of nodes that belong to the subtree rooted at u. SEED: Given a node u and a number x, multiply T__u by x. Tamref is quite busy trying to prove that his method indeed gives integers uniformly distributed, in the meantime, he wants to test his method with a set of queries, and check which numbers are generated. He wants you to write a program that given the tree, and some queries, prints the generated numbers and count its divisors. Tamref has told you that the largest prime factor of both T__u and x is at most the Tamref’s favourite prime: 13. He also told you that the root of T is always node 0. The figure shows the sample test case. The numbers inside the squares are the values on each node of the tree. The subtree rooted at node 1 is colored. The RAND query for the subtree rooted at node 1 would generate 14400, which has 63 divisors. Input The first line is an integer n (1 ≤ n ≤ 105), the number of nodes in the tree T. Then there are n - 1 lines, each line contains two integers u_and _v (0 ≤ u, v &lt; n) separated by a single space, it represents that u is a parent of v in T. The next line contains n integers, where the i - th integer corresponds to T__i (1 ≤ T__i ≤ 109). The next line contains a number Q (1 ≤ Q ≤ 105), the number of queries. The final Q lines contain a query per line, in the form “RAND u“ or “SEED u x“ (0 ≤ u &lt; n, 1 ≤ x ≤ 109). Output For each RAND query, print one line with the generated number and its number of divisors separated by a space. As this number can be very long, the generated number and its divisors must be printed modulo 109 + 7. Example input Copy 12345678910111213 80 10 21 32 42 53 63 77 3 10 8 12 14 40 153RAND 1SEED 1 13RAND 1 output Copy 12 14400 63187200 126 题意：建一颗树，查询 所有以当前节点和所有儿子节点因子个数，更新，单点更新倍数。 题解：首先dfs把所有位置出现的序 排好。题目样例 dfs,进入的先后顺序 是 s[0]=1,s[1]=2,s[3]=2,s[6]=4,s[7]=5,s[2]=6,s[4]=7,s[5]=8; 然后保留每个节点最后一个所覆盖的最大范围如： e[0]=8, 因为 0节点覆盖了所有节点也就是 1-8 ，e[1]=5,1节点 覆盖了所有序从 s[1]-e[1]（2 - 5）的节点。 然后以序建一颗线段树： 查询： x 每次查询 [s[x],e[x]]; 更新： x 每次更新 [ s[x] ,s[x] ]; 我的线段树每次保存的是 (l,r] ,所以 l 每次要-1。 这题数据处理，每个节点保留所有素数因子个数，然后求的值就是所有素数的乘积，因子个数就是相应素数个数+1的乘积， 假如 素因子2有6个，素因子3有 2个 ，素因子5有2个，输出就是 2^63^25^2, 733 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=2e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;vector&lt;int&gt; G[maxn];int e[maxn],s[maxn];int val[maxn],val2[maxn];int cnt=0;int dfs(int r,int p) &#123; cnt++;// debug(r); val[cnt]=val2[r]; s[r]=cnt; for(int i=0; i&lt;G[r].size(); i++) &#123; int to=G[r][i]; if(to!=p) &#123; dfs(to,r); &#125; &#125; e[r]=cnt;&#125;int dat[maxn&lt;&lt;4][6];int prim[]= &#123;2,3,5,7,11,13&#125;;void init(int l,int r,int k) &#123; if(r-l==1) &#123; for(int i=0; i&lt;6; i++) &#123; while(val[r]%prim[i]==0) &#123; val[r]/=prim[i]; dat[k][i]++; &#125; &#125; &#125; else &#123; init(lson); init(rson); for(int i=0; i&lt;6; i++) &#123; dat[k][i]=dat[chl][i]+dat[chr][i]; &#125; &#125;&#125;void update(int a,int b,int l,int r,int k,ll x) &#123; if(b&lt;=l||a&gt;=r) &#123; return ; &#125; else if(a&lt;=l&amp;&amp;r&lt;=b) &#123; for(int i=0; i&lt;6; i++) &#123; while(x%prim[i]==0) &#123; x/=prim[i]; dat[k][i]++; &#125; &#125; return ; &#125; else &#123; update(a,b,lson,x); update(a,b,rson,x); for(int i=0; i&lt;6; i++) &#123; dat[k][i]=dat[chl][i]+dat[chr][i]; &#125; &#125;&#125;int res[6];void query(int a,int b,int l,int r,int k) &#123; if(b&lt;=l||a&gt;=r) &#123; return ; &#125; else if(a&lt;=l&amp;&amp;r&lt;=b) &#123; for(int i=0; i&lt;6; i++) &#123; res[i]+=dat[k][i]; &#125; &#125; else &#123; query(a,b,lson); query(a,b,rson); &#125;&#125;long long pow(long long x,long long n,long long mod=1e9+7) &#123; long long res=1; while(n&gt;0) &#123; if(n&amp;1)res=res*x%mod; x=x*x%mod; n&gt;&gt;=1; &#125; return res%mod;&#125;int main() &#123; int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;n; i++) &#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); G[a].push_back(b); G[b].push_back(a); &#125; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d&quot;,&amp;val2[i]); &#125; dfs(0,-1); init(0,n,0); int q; scanf(&quot;%d&quot;,&amp;q); while(q--) &#123; char ch[100]; scanf(&quot;%s&quot;,ch); if(ch[0]==&apos;R&apos;) &#123; int a; scanf(&quot;%d&quot;,&amp;a); mem(res,0); query(s[a]-1,e[a],0,n,0); ll ans=1,num=1; for(int i=0; i&lt;6; i++) &#123; ans*=pow(prim[i],res[i],mod); ans%=mod; num*=res[i]+1; num%=mod; &#125; printf(&quot;%lld %lld\n&quot;,ans%mod,num%mod); &#125; else &#123; int a; ll b; scanf(&quot;%d%lld&quot;,&amp;a,&amp;b); update(s[a]-1,s[a],0,n,0,b); &#125; &#125; return 0;&#125; 0]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[省赛选拔-单调队列]]></title>
    <url>%2F2018%2F08%2F12%2F%E7%9C%81%E8%B5%9B%E9%80%89%E6%8B%94-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[单调队列写法。 Py&amp;hyh想脱单 Description 总所周知,，py和hyh有十分浓烈的脱单意愿，但是非常不幸，在一个风和日丽的下午，他们穿越到一个没有妹子的世界，他必须回答一个问题才能回到本来的世界，这个问题是给出一个nm的矩阵，然后有q次操作，每一个操作，给出xi,yi,ti,表示在ti时刻摧毁(xi,yi)这个格子，然后他们要求出一个最早时刻，出现至少一个kk的矩阵被毁坏，注意：一个kk矩阵被毁坏的意思是某一个kk的矩阵中的每一个格子都被摧毁过一次或一次以上。聪明的acmer能帮他们回答这个问题吗（如果没人能ac这个题，就代表他们两个没有脱单的可能了哦） Input Input：采用多组输入第一行输入n,m,k,q,(1 ≤ n, m ≤ 500, 1 ≤ k ≤ min(n, m), 1 ≤ q ≤ n·m)分别代表nm的矩阵，kk的矩阵，和q次操作接下来q行每一行输入xi,yi,ti(1 ≤ xi ≤ n, 1 ≤ yi ≤ m, 0 ≤ t ≤ 1e6)，代表，在ti这个时刻，xi，yi这个位置会被摧毁 Output Out：输出一行，代表最早时刻出现至少一个k*k的矩阵被毁坏如果永远不存在这一个时刻，输出-1 Sample Input 1 2 3 2 5 2 1 8 2 2 8 1 2 1 1 3 4 2 3 2 Sample Output 1 8 Sample Input 2 3 3 2 5 1 2 2 2 2 1 2 3 5 3 2 10 2 1 100 Sample Output 2 -1 题意：自己看。 解法：标程是二分+二维前缀和，我个人觉得双向队列写法更优。 首先每行 记录 mp[i][ j-k , j ]区间的最大值，再在得到每行每个区间最大值的条件下再次记录 每列的最大值 mp[i-k,i][j]; 这中写法只要会用双向队列来维护单调队列，就很好些。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_backconst long long mod=998244353;const int maxn=5e3+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,m,k,q;deque&lt;int&gt; dq;int mp[maxn][maxn];int mp2[maxn][maxn]; //开个mp2记录下每行一个区间的最大值int main() &#123; while(~scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;k,&amp;q)) &#123; memset(mp,inf,sizeof(mp)); while(q--) &#123; int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); mp[a][b]=min(mp[a][b],c); &#125; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=m; j++) &#123; if(j&gt;k&amp;&amp;dq.back()==mp[i][j-k]) &#123; dq.pop_back(); &#125; while(dq.size()&gt;0&amp;&amp;dq.front()&lt;mp[i][j]) &#123; dq.pop_front(); &#125; if(dq.size()==0||dq.front()&gt;=mp[i][j]) &#123; dq.push_front(mp[i][j]); &#125; mp2[i][j]=dq.back(); &#125; dq.clear(); &#125; for(int i=k; i&lt;=m; i++) &#123; for(int j=1; j&lt;=n; j++) &#123; if(j&gt;k&amp;&amp;dq.back()==mp2[j-k][i]) &#123; dq.pop_back(); &#125; while(dq.size()&gt;0&amp;&amp;dq.front()&lt;mp2[j][i]) &#123; dq.pop_front(); &#125; if(dq.size()==0||dq.front()&gt;=mp2[j][i]) &#123; dq.push_front(mp2[j][i]); &#125; mp[j][i]=dq.back(); &#125; dq.clear(); &#125; int res=inf; for(int i=k; i&lt;=n; i++) &#123; for(int j=k; j&lt;=m; j++) &#123; res=min(res,mp[i][j]); &#125; &#125; if(res&gt;1e6+1)res=-1; printf(&quot;%d\n&quot;,res); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 2532 Internship(网络流求割边)]]></title>
    <url>%2F2018%2F08%2F02%2FZOJ%202532%20Internship(%E7%BD%91%E7%BB%9C%E6%B5%81%E6%B1%82%E5%89%B2%E8%BE%B9)%2F</url>
    <content type="text"><![CDATA[ZOJ2532 Internship Time Limit: 5 Seconds Memory Limit: 32768 KB CIA headquarter collects data from across the country through its classified network. They have been using optical fibres long before it’s been deployed on any civilian projects. However they are still under a lot pressure recently because the data are growing rapidly. As a result they are considering upgrading the network with new technologies that provide a few times wider bandwidth. In the experiemental stage, they would like to upgrade one segment of their original network in order to see how it performs. And as a CIA intern it’s your responsibility to investigate which segment could actually help increase the total bandwidth the headquarter receives, suppose that all the cities have infinite data to send and the routing algorithm is optimized. As they have prepared the data for you in a few minutes, you are told that they need the result immediately. Well, practically immediately. Input Input contains multiple test cases. First line of each test case contains three integers n, m and l, they represent the number of cities, the number of relay stations and the number of segments. Cities will be referred to as integers from 1 to n, while relay stations use integers from n+1 to n+m. You can saves assume that n + m &lt;= 100, l &lt;= 1000 (all of them are positive). The headquarter is identified by the integer 0. The next l lines hold a segment on each line in the form of a b c, where a is the source node and b is the target node, while c is its bandwidth. They are all integers where a and b are valid identifiers (from 0 to n+m). c is positive. For some reason the data links are all directional. The input is terminated by a test case with n = 0. You can safely assume that your calculation can be housed within 32-bit integers. Output For each test print the segment id’s that meets the criteria. The result is printed in a single line and sorted in ascending order, with a single space as the separator. If none of the segment meets the criteria, just print an empty line. The segment id is 1 based not 0 based. Sample Input 12 1 3 1 3 2 3 0 1 2 0 1 2 1 3 1 3 1 2 3 1 3 0 2 0 0 0 Sample Output 12 3 &lt;hey here is an invisible empty line&gt; 题意：就是给你几个点 然后全部要汇到 终点 0 问哪几条边流量上升可以直接增大流量。 题解： 首先用网络流跑一边，然后一个是起点的残余网络，一个是终点的残余网络，如果有一条变能从起点残余网络跑到终点的残余网络肯定 就是因为他限制了流量，所以这题就是找能连接两个残余网络的的边。 起点残余网络，就顺着你连的边流一次就行了。 终点残余网络是逆着流一遍，是用反向边跑，这一点需要注意下，因为这个残余网络是从别的点汇聚到终点，不是从重点流出去。把所有能连接两边点的且边的流量是0的边加入答案就行，最后排个序。 怕理解不了插个图 AC代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#define mem(a,b) memset(a,b,sizeof(a))using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;const long long mod=1e9+7;const int maxn=400+25;const int maxm=1e5+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,m,l,tot;struct edge &#123; int num,to,cap,rev;&#125;;vector &lt;edge&gt; G[maxn];int level[maxn];int iter[maxn];void init(int _n) &#123; for(int i=0; i&lt;=_n; i++) &#123; G[i].clear(); &#125;&#125;void bfs(int s) &#123; memset(level,-1,sizeof(level)); queue&lt;int&gt; que; level[s]=0; que.push(s); while(!que.empty()) &#123; int v= que.front(); que.pop(); for(int i=0; i&lt;G[v].size(); i++) &#123; edge &amp; e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0) &#123; level[e.to]=level[v] + 1; que.push(e.to); &#125; &#125; &#125;&#125;void add(int from,int to,int cap) &#123; edge eg; eg.to=to; eg.num=tot; eg.cap=cap; eg.rev=G[to].size(); G[from].push_back(eg); eg.num=2*n+m+1+l+tot++; eg.to=from; eg.cap=0; eg.rev=G[from].size()-1; G[to].push_back(eg);&#125;int dfs(int v,int t,int f) &#123; if(v == t)return f; for(int &amp;i = iter[v]; i &lt; G[v].size(); i++) &#123; edge &amp;e=G[v][i]; if(e.cap&gt;0 &amp;&amp; level[v]&lt;level[e.to]) &#123; int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0) &#123; e.cap-=d; G[e.to][e.rev].cap+=d; return d; &#125; &#125; &#125; return 0;&#125;int maxflow(int s,int t) &#123; int flow=0; for(;;) &#123; bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while((f = dfs(s,t,inf))&gt;0) &#123; flow +=f; &#125; &#125;&#125;int dis[maxn],dis2[maxn];void dfs1(int x) &#123; dis[x]=1; for(int i=0; i&lt;G[x].size(); i++) &#123; if(dis[G[x][i].to]==-1&amp;&amp;G[x][i].cap!=0) &#123; dfs1(G[x][i].to); &#125; &#125;&#125;void dfs2(int x) &#123; dis2[x]=1; for(int i=0; i&lt;G[x].size(); i++) &#123; if(dis2[G[x][i].to]==-1&amp;&amp;G[G[x][i].to][G[x][i].rev].cap!=0) &#123; dfs2(G[x][i].to); &#125; &#125;&#125;int main() &#123; while(~scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;l)&amp;&amp;(m+n+l)) &#123; init(n+m+1); tot=1; for(int i=0; i&lt;l; i++) &#123; int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); add(a,b,c); &#125; for(int i=1; i&lt;=n; i++) &#123; add(n+m+1,i,inf); &#125; maxflow(n+m+1,0); mem(dis,-1); mem(dis2,-1); dfs1(n+m+1); dfs2(0); vector&lt;int&gt; v; v.clear(); for(int i=1; i&lt;=n+m; i++) &#123; if(dis[i]==1) &#123; for(int j=0; j&lt;G[i].size(); j++) &#123; if(G[i][j].num&lt;=l&amp;&amp;dis2[G[i][j].to]==1&amp;&amp;G[i][j].cap==0) &#123; v.push_back(G[i][j].num); &#125; &#125; &#125; &#125; if(v.size()==0) &#123; puts(&quot;&quot;); &#125; else &#123; sort(v.begin(),v.end()); for(int i=0; i&lt;v.size(); i++) &#123; printf(&quot;%d%c&quot;,v[i],i+1==v.size()?&apos;\n&apos;:&apos; &apos;); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Multi-University Training Contest 2]]></title>
    <url>%2F2018%2F07%2F29%2F2018%20Multi-University%20Training%20Contest%202%201007%20Naive%20Operations%2F</url>
    <content type="text"><![CDATA[HDU 6135 Naive Operations Time Limit: 6000/3000 MS (Java/Others) Memory Limit: 502768/502768 K (Java/Others) Total Submission(s): 2438 Accepted Submission(s): 1074 Problem Description In a galaxy far, far away, there are two integer sequence a and b of length n. b is a static permutation of 1 to n. Initially a is filled with zeroes. There are two kind of operations: add l r: add one for al,al+1…ar query l r: query ∑ri=l⌊ai/bi⌋ Input There are multiple test cases, please read till the end of input file. For each test case, in the first line, two integers n,q, representing the length of a,b and the number of queries. In the second line, n integers separated by spaces, representing permutation b. In the following q lines, each line is either in the form ‘add l r’ or ‘query l r’, representing an operation.1≤n,q≤100000, 1≤l≤r≤n, there’re no more than 5 test cases. Output Output the answer for each ‘query’, each one line. Sample Input 5 12 1 5 2 4 3 add 1 4 query 1 4 add 2 5 query 2 5 add 3 5 query 1 5 add 2 4 query 1 4 add 2 5 query 2 5 add 2 2 query 1 5 Sample Output 1 1 2 4 4 6 Source 2018 Multi-University Training Contest 2 比赛的时候写了半天没写出来，结果发现是线段树板子敲错了-_-||| 给一段区间，区间的值全部加+1 查询 区间 a[i]/b[i]向下取整的和。 因为查询a[i]/b[i]向下取整，直接求有点难。 所以我们换个操作，我们每次区间加一，变成把每个值减一，每次减到0的时候ai/bi的值就会+1，我们记录这个+1，再把值重新更新为bi，查询的时候查询+1 的总和。 用线段树保留最小值，当出现最小值为0的时候把cnt++，值更新为b[r]，因为每次只会加+1所以总数不会太大 如： 1 2 3 4 5 add 1 4 区间值 0 1 2 3 5 ,出现最小值 0 所以区间 cnt++ 把零变为 b[i] 1 1 2 3 5 然后一直下去，查询直接查询cnt 总和就行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxn=1e5+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int b[4*maxn]; int n,q;int dat[4*maxn],lazy[4*maxn];//lazy保存区间所加的值 dat 为最小值。int res;int cnt[maxn*4]; // 保存每个区间里面的总个数void init(int l,int r,int k) &#123; //初始化 int chl=2*k+1,chr=2*k+2,mid=(l+r)&gt;&gt;1; if(r-l==1) &#123; lazy[k]=cnt[k]=0; dat[k]=b[r]; return ; &#125; else &#123; lazy[k]=cnt[k]=0; init(l,mid,chl); init(mid,r,chr); dat[k]=min(dat[chl],dat[chr]); &#125;&#125;int sum(int a,int c,int l,int r,int k) &#123;//查询总个数 int chl=2*k+1,chr=2*k+2,m=(l+r)/2; if(c&lt;=l||a&gt;=r) &#123; //不在区间内 return 0; &#125; else if(a&lt;=l&amp;&amp;r&lt;=c) &#123; //覆盖这个区间 return cnt[k]; &#125; else &#123; lazy[chl]+=lazy[k]; //把lazy 更新下去 lazy[chr]+=lazy[k]; lazy[k]=0; dat[k]=min(dat[chl]+lazy[chl],dat[chr]+lazy[chr]); return sum(a,c,l,(l+r)/2,k*2+1)+sum(a,c,(l+r)/2,r,k*2+2); &#125;&#125;void update(int a,int c,int l,int r,int k) &#123; int chl=2*k+1,chr=2*k+2,mid=(l+r)/2; if(c&lt;=l||a&gt;=r) &#123; return ; &#125; else if(a&lt;=l&amp;&amp;r&lt;=c) &#123; if(lazy[k]+dat[k]-1&lt;=0) &#123; //如果所覆盖的区间减一出现值小于等于0 就去找那个值 if(r-l==1) &#123; cnt[k]++; //找到后 cnt ++ dat[k]=b[r]; lazy[k]=0; //把当前结点的值重新更新为b[r] return ; &#125; lazy[chl]+=lazy[k]; //向下更新lazy lazy[chr]+=lazy[k]; lazy[k]=0; update(a,c,l,mid,chl); //向左右儿子结点找 update(a,c,mid,r,chr); if(r-l!=1) &#123; cnt[k]=cnt[chl]+cnt[chr]; dat[k]=min(dat[chl]+lazy[chl],dat[chr]+lazy[chr]); //更新值 &#125; return; &#125; lazy[k]--; //如果没有就直接把lazy减一 &#125; else &#123; // 大区间有一部分在小区间内 lazy[chl]+=lazy[k]; lazy[chr]+=lazy[k]; update(a,c,l,mid,chl); update(a,c,mid,r,chr); lazy[k]=0; dat[k]=min(dat[chl]+lazy[chl],dat[chr]+lazy[chr]); //更新 if(r-l!=1)cnt[k]=cnt[chl]+cnt[chr]; &#125;&#125;char ch[10];int l,r;int main() &#123; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;q)!=EOF) &#123; for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;b[i]); &#125; init(0,n,0); while(q--) &#123; scanf(&quot;%s%d%d&quot;,ch,&amp;l,&amp;r); if(ch[0]==&apos;a&apos;) &#123; update(l-1,r,0,n,0); //我写的线段是是(l,r] 所以要记得-1 &#125; else &#123; printf(&quot;%d\n&quot;,sum(l-1,r,0,n,0)); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-4389 X mod f(x) 数位DP]]></title>
    <url>%2F2018%2F07%2F29%2FHDU-4389%20X%20mod%20f(x)%20%20%E6%95%B0%E4%BD%8DDP%2F</url>
    <content type="text"><![CDATA[题目链接 ：HDU - 4389 X mod f(x) Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 3619 Accepted Submission(s): 1409 Problem Description Here is a function f(x): int f ( int x ) { if ( x == 0 ) return 0; return f ( x / 10 ) + x % 10; } Now, you want to know, in a given interval [A, B] (1 &lt;= A &lt;= B &lt;= 109), how many integer x that mod f(x) equal to 0. Input The first line has an integer T (1 &lt;= T &lt;= 50), indicate the number of test cases. Each test case has two integers A, B. Output For each test case, output only one line containing the case number and an integer indicated the number of x. Sample Input 2 1 10 11 20 Sample Output Case 1: 10 Case 2: 3 Author WHU Source 2012 Multi-University Training Contest 9 Recommend zhuyuanchen520 数位DP 所有数的和最大不超过82 dp[pos][sum][mod][res] ，pos 第几位，sum 到第几位每个位数加起来的和，mod， 取模多少 。余数是res ,状态下有多少个数。 然后直接用for暴力取模的数的所有情况。 套个数位DP的板子就行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 #include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;typedef int ll;int dp[10][82][82][82];// 所有数的和最大不超过82 dp[pos][sum][mod][res] ，pos 第几位，sum 到第几位每个位数加起来的和，mod， 取模多少 。余数是res ,状态下有多少个数。int a[25];ll dfs(int pos,ll sum,ll mod,ll res,bool limit) &#123; //状态 pos sum,mod,res, 上线情况limit if(sum&gt;mod)return 0; if(pos==-1) &#123; //当枚举完最后一位返回 if(sum==mod&amp;&amp;res==0)return 1; //满足条件返回1 else return 0; //不满足返回0 &#125; if(limit==0&amp;&amp;dp[pos][sum][mod][res]!=-1)return dp[pos][sum][mod][res];//如果当前状态是已经有过记录且当前没有限制就直接返回已经记录的值 ll up=limit?a[pos]:9,cnt=0;//最大可以枚举到up,如果当前没有上限就可以 0-9,否则只能到当前位的最大值，cnt 记录总共多少 for(int i=0; i&lt;=up; i++) &#123; //跳转状态，前一位，总和加上值，取模数不变，更新余数，如果当前有上限，切加入的值已经到达当前上限 下一种情况才有上线 cnt+=dfs(pos-1,sum+i,mod,(res*10+i)%mod,limit&amp;&amp;i==a[pos]); &#125; if(limit==0)dp[pos][sum][mod][res]=cnt; //当前状态是没有上限的情况下求的和，就可以记录当前状态 return cnt; &#125;ll n,m;ll solve(ll x) &#123; int pos=0; while(x&gt;0) &#123; a[pos++]=x%10; x/=10; &#125; ll ans=0; for(int i=1; i&lt;82; i++) &#123; ans+=dfs(pos-1,0,i,0,true); //直接用for暴力取模的数的所有情况。 &#125; return ans;&#125;int main() &#123; ios_base::sync_with_stdio(0); int t; memset(dp,-1,sizeof(dp)); cin&gt;&gt;t; int l=0; while(t--) &#123; l++; cin&gt;&gt;n&gt;&gt;m; cout&lt;&lt;&quot;Case &quot;&lt;&lt;l&lt;&lt;&quot;: &quot;; cout&lt;&lt;solve(m)-solve(n-1)&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习23]]></title>
    <url>%2F2018%2F07%2F28%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A023%2F</url>
    <content type="text"><![CDATA[牛客练习赛23 这次牛客练习赛，都考了一点小技巧。 A 随便模拟一下 链接：https://www.nowcoder.com/acm/contest/156/A 来源：牛客网 时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format: %lld 题目描述 紧张刺激的世界杯正在进行中(在托米的世界线里)，欧洲人托米沉迷于赌球无法自拔。 托米的口袋里有 100 元，50元，20元，10元，5元，2元，1元的纸币，50分，20分，10分，5分，2分，1分的硬币各无限个。 托米计划买下几注 a 元 b 分的彩票，他希望能支出的纸票数量和硬币数量之和最小，他希望你帮助他完成这个任务。同时由于彩票亭不支持找零，托米希望他的支出恰好等于 a 元 b 分 输入描述:1第一行输入一个正整数 T下面 T 行每行两个整数 a,b 输出描述:1每行输出 13 个正整数 n1 ...n13, 对应题面顺序给出最小化支出纸票数量和硬币数量之和的情况下，每种货币的使用次数，如果有多种方案，输出字典序最大的一种，注意这里字典序是依次比较n1到n13，而不是简单的把 13 个正整数拼接在一起 示例1 输入 复制 123 21 52 4 输出 复制 12 0 0 0 0 0 0 1 0 0 0 1 0 00 0 0 0 0 1 0 0 0 0 0 2 0 备注:1T=100,0≤ a≤ 109, 0≤ b&lt;100 12345678910111213141516171819202122232425262728 #include&lt;bits/stdc++.h&gt;using namespace std;int a[7]= &#123;100,50,20,10,5,2,1&#125;;int b[6]= &#123;50,20,10,5,2,1&#125;;int a1[7],b1[6];int main() &#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; int x,y; cin&gt;&gt;x&gt;&gt;y; for(int i=0; i&lt;7; i++) &#123; a1[i]=x/a[i]; x=x%a[i]; &#125; for(int i=0; i&lt;6; i++) &#123; b1[i]=y/b[i]; y%=b[i]; &#125; for(int i=0; i&lt;7; i++) &#123; printf(&quot;%d%c&quot;,a1[i],&apos; &apos;); &#125; for(int i=0; i&lt;6; i++) &#123; printf(&quot;%d%c&quot;,b1[i],i==5?&apos;\n&apos;:&apos; &apos;); &#125; &#125; return 0;&#125; B 链接：https://www.nowcoder.com/acm/contest/156/B 来源：牛客网 时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format: %lld 题目描述 欧洲人托米非常喜欢数字，他经常在空闲时玩下面的游戏 对于一个数字 n, 托米会随性选中一个数 p, (1 ＜ p &lt;= n), 将 n 拆分成 ,v=n-u,并对 u,v 重复这个过程，直到他有了 n 个 1 1317 为了挑战托米，在每次托米进行划分时，会给托米奖励 u * v 的分数，托米希望你能帮他最大化他的得分。 输入描述:1第一行一个正整数 T下面 T 行每行一个正整数 n 输出描述:1对于每组数据，输出托米的最大得分 示例1 输入 复制 11 5 输出 复制 110 备注:1T≤ 104, n≤ 109 推公式 2 = 1*1 3 =12 +11; 4=13 +12+1*1; 规律就是 Sn = (n*(n-1))/2; 12345678910111213 #include&lt;bits/stdc++.h&gt;using namespace std;long long n;int main() &#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%lld&quot;,&amp;n); printf(&quot;%lld\n&quot;,(n*(n-1))/2); &#125; return 0;&#125; C 链接：https://www.nowcoder.com/acm/contest/156/C 来源：牛客网 时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format: %lld 题目描述 托米完成了1317的上一个任务，十分高兴，可是考验还没有结束 说话间1317给了托米 n 个自然数 a1… an, 托米可以选出一些带回家，但是他选出的数需要满足一些条件 设托米选出来了k 个数 b1,b2… bk, 设这个数列 b 的给值为 b 中所有数按位与的结果，如果你能找到一个整除 b 的最大的 2v,(v≥ 0)， 则设定 v 为这个数列的给价，如果不存在这样的 v，则给价值为 -1, 1317 希望托米在最大化给价的情况下，最大化 k 输入描述:1第一行输入一个整数 n, 第二行输入 a1...an 输出描述:1第一行输出最大的整数 k, 第二行输出 k 个整数 b1... bk, 按原数列的相对顺序输出 (如果行末有额外空格可能会格式错误) 示例1 输入 复制 12 51 2 3 4 5 输出 复制 12 24 5 备注:1n≤ 105, a1... an &lt; 231 题目毒瘤读了半天 给你一个 n 个数 a1 …an,选几个数 b1…bk 然后全部&amp;后 b=b1&amp;b2…&amp;bk, b&amp;2^v==0, v最大就是当前选的这个b序列的值； 求 V最大的情况下K最大。 题解 ：从最高位为1 &amp;到最低位是1 一路下来就行。v 的值是按位于之后最后一位为 1的位置。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 #include&lt;bits/stdc++.h&gt;using namespace std;long long n;typedef long long ll;const int maxn=1e5+5;ll a[maxn],x[maxn];int main() &#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%lld&quot;,&amp;a[i]); &#125; for(int i=0; i&lt;=31; i++) &#123; //预处理下最高位位置的值 x[i]=1&lt;&lt;i; &#125; int k=0,flag=0,bi=0; ll v=0,m=-1; for(int i=31; i&gt;=0; i--) &#123;//从最高为处理到最低位 int t=0; flag=0; for(int j=0; j&lt;n; j++) &#123; if((a[j]&amp;x[i])==x[i]) &#123; //把高于最高位的值全部选上 if(t==0) &#123; flag=a[j]; &#125; else &#123; flag&amp;=a[j]; &#125; t++; &#125; &#125; int pos=0; while(flag&gt;0&amp;&amp;(flag&amp;1)==0) &#123; //判断v 的位置 pos++; flag&gt;&gt;=1; &#125; if(pos&gt;m||(pos==m&amp;&amp;t&gt;k)) &#123; //更新值 m=pos; v=flag&lt;&lt;pos; k=t; &#125; &#125; printf(&quot;%d\n&quot;,k); for(int i=0; i&lt;n; i++) &#123; if((a[i]&amp;v)==v) &#123; //把所有能按位于成 v 的全部输出。 k--; printf(&quot;%lld%c&quot;,a[i],k==0?&apos;\n&apos;:&apos; &apos;); &#125; &#125; return 0;&#125; 有点难懂，看不懂留言。 D 链接：https://www.nowcoder.com/acm/contest/156/D 来源：牛客网 时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format: %lld 题目描述 托米没有完成上一个任务，准备施展黑魔法推倒 1317 黑魔法咒语被描述为一个 长为 n 的，仅包含小写英文字母 ‘a’…’i’ 的字符串，在托米所在的星球，魔法造成的每次有效伤害都是来自他的一个子序列，对于每一个 ‘a’… ‘i’ 的排列(共 9! 种)，若作为咒语的子序列出现, 就会造成 1 的伤害 而咒语的总伤害为所有 ‘a’… ‘i’ 的排列造成的伤害值之和，托米能打出多少点的伤害，是否能击败 1317 呢？ 输入描述:1一行输入一个字符串 s 输出描述:1一行输出一个数，表示伤害值 示例1 输入 复制 1aabcdefghi 输出 复制 11 备注:1|s| ≤ 3000 优雅的暴力。 全排列所有情况，二分查找这种情况在字符串里面可不可行，然后一个个加上。 1234567891011121314151617181920212223242526272829303132333435363738394041 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=4e5+5;char ch[maxn];int n[maxn];vector&lt;int&gt; v[10];int dp[maxn][9];int main() &#123; int ans[9]= &#123;0,1,2,3,4,5,6,7,8&#125;; int k=0; do &#123; for(int i=0; i&lt;9; i++) &#123; dp[k][i]=ans[i]; &#125; k++; &#125; while(next_permutation(ans,ans+9)); cin&gt;&gt;ch; int l=strlen(ch); for(int i=0; i&lt;l; i++) &#123; n[i]=ch[i]-&apos;a&apos;; v[n[i]].push_back(i); &#125; int res=0; for(int i=0; i&lt;k; i++) &#123; int p=-1; for(int j=0; j&lt;9; j++) &#123; int num=dp[i][j]; if(upper_bound(v[num].begin(),v[num].end(),p)==v[num].end()) &#123; break; &#125; int t=upper_bound(v[num].begin(),v[num].end(),p)-v[num].begin(); p=v[num][t]; if(j==8) &#123; res++; &#125; &#125; &#125; cout&lt;&lt;res&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些函数要记的函数笔记]]></title>
    <url>%2F2018%2F07%2F25%2F%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%E8%A6%81%E8%AE%B0%E7%9A%84%E5%87%BD%E6%95%B0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[__builtin_popcount() 求二进制 1的个数。 double add(double a,double b) { if(abs(a+b)&lt;eps *(abs(a)+abs(b))) return 0; return a+b; } 一个 向量操作结构体。 const double eps =1e-8; struct P { double x,y; P() {} P(double x,double y):x(x),y(y) {} P operator + (P p) { return P(add(x,p.x),add(y,p.y)); } P operator - (P p) { return P(add(x,-p.x),add(y,-p.y)); } P operator (double d) { return P(xd,yd); } double dot (P p) { //向量积 return add(xp.x,yp.y); } double det(P p) { //数量积 return add(xp.y,-y*p.x); } }; double Distance(P a,P b) { return sqrt((a.x-b.x)(a.x-b.x)+(a.y-b.y)(a.y-b.y)); } double InterArea(P a,double R,P b,double r) { if(R=R+r) //两圆相离，相交面积为0 return 0; if(dis&lt;=R-r) //两圆内含，相交面积为小圆的面积 return PIrr; //两圆相交时 double angle1=acos((RR+disdis-rr)/(2.0Rdis)); //大圆的那个角 double angle2=acos((rr+disdis-RR)/(2.0rdis)); //小圆的那个角 double s=Rangle1R+rangle2r; s-=Rdissin(angle1); return s; } 全排列 一定要排序 #includeusing namespace std;typedef long long ll;const int maxn=4e5+5;int n[maxn];int dp[maxn][9];int main() {int ans[9]= {0,1,2,3,4,5,6,7,8};int k=0;do {for(int i=0; i&lt;9; i++) {dp[k][i]=ans[i];}k++;} while(next_permutation(ans,ans+9));return 0;} hypot() 求三角斜边]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018杭电多校第一场-2018 Multi-University Training Contest 1]]></title>
    <url>%2F2018%2F07%2F23%2F2018%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%80%E5%9C%BA-2018%20Multi-University%20Training%20Contest%201%2F</url>
    <content type="text"><![CDATA[因为去了躺上海，导致两场牛客多校没有打。这场杭电多校在努力也只能写5题，有了大佬讲题解我就过一下。 Maximum Multiple Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 0 Accepted Submission(s): 0 Problem Description Given an integer n, Chiaki would like to find three positive integers x, y and z such that: n=x+y+z, x∣n, y∣n, z∣n and xyz is maximum. Input There are multiple test cases. The first line of input contains an integer T (1≤T≤106), indicating the number of test cases. For each test case: The first line contains an integer n (1≤n≤106). Output For each test case, output an integer denoting the maximum xyz. If there no such integers, output −1 instead. Sample Input 1 3 1 2 3 Sample Output 1 -1 -1 1 n/s+n/t+n/k=n; 求得 s=3 t=3 k=3 /s=2 t=1 k=1;这两种情况最小，然后暴力就行了 我的写法是打了个表，数据范围不大。 100112345678910111213141516171819202122232425262728293031323334353637383940 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxn=1e6+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int t,n;long long a[maxn];int main() &#123; memset(a,-1,sizeof(a)); for(long long i=1;i*4&lt;=maxn;i++)&#123; a[i*4]=i*i*i*2; &#125; for(long long i=1;i*3&lt;=maxn;i++)&#123; a[i*3]=i*i*i; &#125; cin&gt;&gt;t; while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); printf(&quot;%lld\n&quot;,a[n]); &#125; return 0;&#125; 1002Balanced Sequence Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 0 Accepted Submission(s): 0 Problem Description Chiaki has n strings s1,s2,…,sn consisting of ‘(‘ and ‘)’. A string of this type is said to be balanced: if it is the empty string if A and B are balanced, AB is balanced, if A is balanced, (A) is balanced. Chiaki can reorder the strings and then concatenate them get a new string t. Let f(t) be the length of the longest balanced subsequence (not necessary continuous) of t. Chiaki would like to know the maximum value of f(t) for all possible t. Input There are multiple test cases. The first line of input contains an integer T, indicating the number of test cases. For each test case: The first line contains an integer n (1≤n≤105) — the number of strings. Each of the next n lines contains a string si (1≤|si|≤105) consisting of (&#39; and)’. It is guaranteed that the sum of all |si| does not exceeds 5×106. Output For each test case, output an integer denoting the answer. Sample Input 1 2 1 )()(()( 2 ) )( Sample Output 1 4 2 先处理字符串 把他简化最后所有字符串都会变成 )))((( 像这样的形式。 然后贪心一下每次选左边最长或者右边最长，都没有影响，反正是往两边添加，只要保证选的这个是一种的最大的就行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const int maxn=1e5+25;int t,n;stack&lt;char&gt; s;char ch[maxn];int dp1[maxn],dp2[maxn],ans;struct three &#123; int d1,d2,n;&#125; d[maxn];bool cmp(three &amp;a,three &amp;b)&#123; if(a.d1==b.d1)&#123; return a.d2&gt;b.d2; &#125; return a.d1&gt;b.d1;&#125;int main() &#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; ans=0; scanf(&quot;%d&quot;,&amp;n); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%s&quot;,ch); int pos=0; while(ch[pos]!=&apos;\0&apos;) &#123; if(ch[pos]==&apos;)&apos;) &#123; if(s.size()==0||s.top()==&apos;)&apos;) &#123; s.push(&apos;)&apos;); &#125; else &#123; ans+=2; s.pop(); &#125; &#125; else if(ch[pos]==&apos;(&apos;) &#123; s.push(&apos;(&apos;); &#125; pos++; &#125; int a1=0,a2=0; if(s.size()==0) &#123; i--; n--; &#125; else &#123; while(s.size()&gt;0) &#123; if(s.top()==&apos;)&apos;)a2++; else a1++; s.pop(); &#125; d[i].d1=a1; d[i].d2=a2; d[i].n=i; &#125; &#125; sort(d,d+n,cmp); int k1=d[0].d1,k2=d[0].d2; for(int i=1; i&lt;n; i++) &#123; int k=max(min(k1,d[i].d2),min(k2,d[i].d1)); ans+=2*k; k1=k1-k+d[i].d1; k2=k2-k+d[i].d2; &#125; printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125; 1003Triangle Partition Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 132768/132768 K (Java/Others) Total Submission(s): 0 Accepted Submission(s): 0Special Judge Problem Description Chiaki has 3n points p1,p2,…,p3n. It is guaranteed that no three points are collinear. Chiaki would like to construct n disjoint triangles where each vertex comes from the 3n points. Input There are multiple test cases. The first line of input contains an integer T, indicating the number of test cases. For each test case: The first line contains an integer n (1≤n≤1000) — the number of triangle to construct. Each of the next 3n lines contains two integers xi and yi (−109≤xi,yi≤109). It is guaranteed that the sum of all n does not exceed 10000. Output For each test case, output n lines contain three integers ai,bi,ci (1≤ai,bi,ci≤3n) each denoting the indices of points the i-th triangle use. If there are multiple solutions, you can output any of them. Sample Input 1 1 1 1 2 2 3 3 5 Sample Output 11 2 3 没啥好讲的，排个序从左到右反正不会交叉。 1234567891011121314151617181920212223242526272829303132333435363738394041424344 #include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;typedef pair&lt;char, int &gt; PCI;typedef pair&lt;int, int&gt; PII;typedef pair&lt;LL, LL&gt; PLL;const int MAX = 1e4+7;const int INF = 0x3f3f3f3f;const int mod=1e9+7;int N, M, K, T;struct node &#123; int x, y, id; bool operator&lt;(const node&amp; b) const &#123; return x &lt; b.x; &#125;&#125;;node a[MAX];vector&lt;int&gt; v[MAX];int main() &#123; scanf(&quot;%d&quot;,&amp;T); while(T--) &#123; scanf(&quot;%d&quot;,&amp;N); for(int i = 1; i &lt;= 3*N; i++) &#123; scanf(&quot;%d %d&quot;, &amp;a[i].x, &amp;a[i].y); a[i].id = i; &#125; sort(a+1, a+N*3+1); for(int i = 1; i &lt;= 3*N; i+=3) &#123; printf(&quot;%d %d %d\n&quot;,a[i].id, a[i+1].id, a[i+2].id); &#125; &#125; return 0;&#125; 1004 hiaki has an array of n positive integers. You are told some facts about the array: for every two elements ai and aj in the subarray al..r (l≤i&lt;j≤r), ai≠ajholds. Chiaki would like to find a lexicographically minimal array which meets the facts. Input There are multiple test cases. The first line of input contains an integer T, indicating the number of test cases. For each test case: The first line contains two integers n and m (1≤n,m≤105) — the length of the array and the number of facts. Each of the next m lines contains two integers li and ri (1≤li≤ri≤n). It is guaranteed that neither the sum of all n nor the sum of all m exceeds 106. Output For each test case, output n integers denoting the lexicographically minimal array. Integers should be separated by a single space, and no extra spaces are allowed at the end of lines. Sample Input 1 3 2 1 1 2 4 2 1 2 3 4 5 2 1 3 2 4 Sample Output 1 1 2 1 2 1 2 1 2 3 1 1 队友写的，看了一下，贪心，每次放最小的就行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 #include &lt;bits/stdc++.h&gt;#define fi first#define se second#define lson l,m,rt&lt;&lt;1#define rson m+1,r,rt&lt;&lt;1|1#define lowbit(x) x&amp;-x#define MP make_pair#define debug(x) cout&lt;&lt;x&lt;&lt;&quot;= &quot;&lt;&lt;x&lt;&lt;endl;#define FIN freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt;pii;typedef pair&lt;ll,ll&gt;pll;const int mod=1e9+7;const int inf=0x3f3f3f3f;const ll infll=0x3f3f3f3f3f3f3f3f;const int MX=1e5+7;int n,m;struct node &#123; int l,r; bool operator&lt;(const node&amp;A)const &#123; if(l==A.l) return r&lt;A.r; return l&lt;A.l; &#125;&#125; a[MX];int ans[MX];bool vis[MX];int main() &#123; int T; cin&gt;&gt;T; while(T--) &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=m; i++) &#123; scanf(&quot;%d%d&quot;,&amp;a[i].l,&amp;a[i].r); &#125; sort(a+1,a+m+1); priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q; for(int i=1; i&lt;=n; i++)&#123; ans[i]=1;vis[i]=0; q.push(i); &#125; int l=a[1].l,r=a[1].l; for(int i=1;i&lt;=m;i++)&#123; for(;l&lt;a[i].l;l++)&#123; if(vis[l]) q.push(ans[l]); &#125; for(;r&lt;=a[i].r;r++)&#123; if(r&gt;=a[i].l)&#123; ans[r]=q.top();q.pop(); vis[r]=1; &#125; &#125; &#125; for(int i=1; i&lt;=n; i++) &#123; printf(&quot;%d&quot;,ans[i]); if(i==n) printf(&quot;\n&quot;); else printf(&quot; &quot;); &#125; &#125; return 0;&#125; 1007Chiaki Sequence Revisited Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 428 Accepted Submission(s): 69 Problem Description Chiaki is interested in an infinite sequence a1,a2,a3,…, which is defined as follows: an={1an−an−1+an−1−an−2n=1,2n≥3 Chiaki would like to know the sum of the first n terms of the sequence, i.e. ∑i=1nai. As this number may be very large, Chiaki is only interested in its remainder modulo (109+7). Input There are multiple test cases. The first line of input contains an integer T (1≤T≤105), indicating the number of test cases. For each test case: The first line contains an integer n (1≤n≤1018). Output For each test case, output an integer denoting the answer. Sample Input 1 10 1 2 3 4 5 6 7 8 9 10 Sample Output 1 1 2 4 6 9 13 17 21 26 32 打个表找规律， 1 2 3 4 5 6 7 8 9 10 2 2 1 3 1 2 1 4 1 2 各个数出现的次数就是这样，然后就是lowbit（i）次，然后二分找 到哪个数出现的数次数总和为n 然后再看一下 每次找的的数，x,你会发现，x总是在n/2附近。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include &lt;complex&gt;#include &lt;functional&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxn=1e7+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;long long m,n;long long sum(ll x) &#123; ll ans=1,k=1; while(x&gt;0) &#123;// cout&lt;&lt;x&lt;&lt;endl; if(x%2==1)ans+=x/2*k+1*k; else &#123; ans+=x/2*k; &#125; k++; x/=2; &#125; return ans;&#125;long long js(ll x) &#123; ll res=0,k=1,ans,p=1; while(x&gt;0) &#123; if(x%2==1) &#123; ans=x/2+1; &#125; else &#123; ans=x/2; &#125; ans%=mod; res+=ans*ans%mod*p%mod*k%mod; res%=mod; k++; p=p*2%mod; x/=2; &#125; return res%mod;&#125;int main() &#123; int t; cin&gt;&gt;t; while(t--) &#123; scanf(&quot;%lld&quot;,&amp;n); ll l=0,r=n; if(n&gt;200)&#123; l=n/2-100; r=n/2+100; &#125; while(l&lt;r-1) &#123; ll mid=(l+r)/2; if(sum(mid)&gt;n) &#123; r=mid; &#125; else l=mid; &#125;// cout&lt;&lt;l&lt;&lt;endl; printf(&quot;%lld\n&quot;,(js(l)+(n-sum(l))*(l+1)%mod+1)%mod); &#125; return 0;&#125; 1011Time Zone Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 1646 Accepted Submission(s): 289 Problem Description Chiaki often participates in international competitive programming contests. The time zone becomes a big problem. Given a time in Beijing time (UTC +8), Chiaki would like to know the time in another time zone s. Input There are multiple test cases. The first line of input contains an integer T (1≤T≤106), indicating the number of test cases. For each test case: The first line contains two integers a, b (0≤a≤23,0≤b≤59) and a string s in the format of “UTC+X’’, “UTC-X’’, “UTC+X.Y’’, or “UTC-X.Y’’ (0≤X,X.Y≤14,0≤Y≤9). Output For each test, output the time in the format of hh:mm (24-hour clock). Sample Input 1 3 11 11 UTC+8 11 12 UTC+9 11 23 UTC+0 Sample Output 1 11:11 12:12 03:23 注意精度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxn=1e7+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int t;int main() &#123; cin&gt;&gt;t; int h,m; double ut; while(t--) &#123; scanf(&quot;%d%d UTC%lf&quot;,&amp;h,&amp;m,&amp;ut); int u=ut*100; int k=abs(u); if(k%10&gt;5)k=k/10+1; else k=k/10; if(u&gt;0)u=k; else u=-k;// cout&lt;&lt;u&lt;&lt;endl; m+=u%10*6; if(m&lt;0) &#123; m+=60; h--; &#125; h+=m/60; m=m%60;// cout&lt;&lt;h&lt;&lt;endl; m=m%60; u=u/10-8; h+=u; if(h&lt;0)h+=24; h=h%24; printf(&quot;%02d:%02d\n&quot;,h,m); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 496 (Div. 3) E2 - Median on Segments (General Case Edition)（思维+用bit 位求前缀合）]]></title>
    <url>%2F2018%2F07%2F16%2FCodeforces%20Round%20496%20(Div.%203)%20E2%20-%20Median%20on%20Segments%20(General%20Case%20Edition)%EF%BC%88%E6%80%9D%E7%BB%B4%2B%E7%94%A8bit%20%E4%BD%8D%E6%B1%82%E5%89%8D%E7%BC%80%E5%90%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这题看了别人的博客，看的我一脸懵逼。 思路：很巧秒的转换，我们把&lt;= m 数记为-1, &gt;m的数 记为1， 求其前缀和, 我们将问题转变成求以&gt; m 的数作为中位数的区间个数， 答案就变为ans(m-1) - ans(m )，我们可以用上面求得的前缀用bit就能求出答案。 我特么还不知道是这样写的么，我是不知道怎么用前缀。然后纠结了半天，是咱的基础不好。 所以重点是怎么用bit位来处理前缀和呢？ 只可意会不可言传 12 5 41 4 5 60 4 首先传个 当 k =4 时 就是 -1 -2 -1 0 -1 首先 知道 前缀和为负数的中卫肯定是&lt;=4为正数的一定是&gt;4 结点图如下，至于8以上的结点就不画了，画了也没用前缀合最大值不会超过8； 首先 0 +n+1=5 （初始值都为-1） 和这个以后的结点值 ++； 也就是 6 8结点 都加1； 下一个值 -1 把所有 -1+n=4 一下的结点 的值都加起来。 然后 把 小于 -1+n 的结点和都加一，也就是 4 8都加1； 后面的都是同样的道理 1234567891011121314151617181920212223242526272829303132333435363738394041424344 #include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+5;const int N=2*maxn;int n,m,a[maxn];int v[N];void jl(int x) &#123; for(int i=x; i&lt;N; i+=i&amp;-i) &#123; //这个是来保留的前缀和，假如 当前位置的前缀合 是 -1 ，因为可能出现负数的情况所以加上 n // 然后比 -1 + n 向上跳转的结点 都加上1 v[i]++; &#125;&#125;long long s(int x) &#123; long long sum=0; for(int i=x; i&gt;0; i-=i&amp;-i) &#123; sum+=v[i]; // 计算前缀和，从上往下加，这样会把小于当前结点的值都加起来。 &#125; return sum;&#125;long long cal(int k)&#123; memset(v,0,sizeof(v)); jl(n+1); int dp=0; long long sum=0; for(int i=0;i&lt;n;i++)&#123; if(a[i]&lt;=k)dp-=1; else dp+=1; sum+=s(dp+n); jl(dp+n+1); &#125; return sum;&#125;int main() &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0; i&lt;n; i++)scanf(&quot;%d&quot;,&amp;a[i]); cout&lt;&lt;cal(m-1)-cal(m)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 45 (Rated for Div. 2)]]></title>
    <url>%2F2018%2F06%2F10%2FEducational%20Codeforces%20Round%2045%20(Rated%20for%20Div.%202)%2F</url>
    <content type="text"><![CDATA[A ,B 两题就直接给代码了，没啥讲的 A: 123456789101112131415161718 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;using LL = long long;ll n,m,a,b;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;a&gt;&gt;b; ll k=n/m; if(n%m==0) &#123; cout&lt;&lt;0&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;min((n-k*m)*b,((k+1)*m-n)*a)&lt;&lt;endl; &#125; return 0;&#125; B: 1234567891011121314151617181920212223 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;using LL = long long;const int maxn=2e5+25;int n,a[maxn],k;int main() &#123; cin&gt;&gt;n&gt;&gt;k; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; sort(a, a+n); int mx=1e7+25,ans=0;; for(int i=n-2;i&gt;=0;i--) &#123; int *temp=upper_bound(a,a+n,a[i]); if(temp==a+n)ans++; else if(a[i]+k&lt;*temp||a[i]==*temp)ans++; &#125; cout&lt;&lt;ans+1&lt;&lt;endl;; return 0;&#125; http://codeforces.com/contest/990/problem/C 括号匹配。每个字符串保留前缀和 例如 ((() 前缀和 2 ())) 前缀和 -2； 每次只要把两个数前缀和加起来等于0的数量想成就是可以匹配的数量。 保留负数前缀和的时候一定要是这个前缀和的时候一定是最小的那个，不然本身就是错的。 例如 )))(( ())( 123456789101112131415161718192021222324252627282930 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;using LL = long long;const int maxn=3e5+25;ll n,mx=0;char ch[maxn];map&lt;ll,ll&gt; mp;int main() &#123; cin&gt;&gt;n; for(ll j=0; j&lt;n; j++) &#123; scanf(&quot;%s&quot;,ch); ll flag=0,k=0,l=strlen(ch); for(ll i=0; i&lt;l; i++) &#123; if(ch[i]==&apos;(&apos;)k++; else k--; if(k&lt;0)flag=min(k,flag); &#125; if(flag&lt;0&amp;&amp;k&gt;flag)continue; else &#123; mp[k]++; mx=max(k,mx); &#125; &#125; ll sum=0; for(int i=0; i&lt;=mx; i++) sum+=mp[i]*mp[-i]; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125; D:http://codeforces.com/contest/990/problem/D 题目意思是，给你N个顶点，然后怎么连让他可以有，a,个联通快，然后连的的矩阵的反矩阵 刚好有b个联通快。 例如 3 1 2 矩阵 是 001 001 110 他就是 这个样子 反矩阵就是 010 100 000 图就是 这个样子所以满足条件。 看起来挺难的，实际上就是个傻逼题，就是没连的边一定可以连上，所以无论你一种连成啥样另一种必然是全部联通 所以，a,b必须有一个是 1 ，如果没有就不可行，然后特判一下 2 3 两个 都是 1的情况，为什么要特判呢，自己画个图试试就知道了。 然后就简单了，矩阵其实只要吧 不是 1 的的那个联通快数量分成 1 1 1 1 n-a 这样的几个联通块就行了。 所以只要连 n-a条边。 1234567891011121314151617181920212223242526272829303132333435363738 #include &lt;bits/stdc++.h&gt;using namespace std;const int Maxn = 1005;int n, a, b;char B[Maxn][Maxn];int main() &#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;a, &amp;b); if(a!=1&amp;&amp;b!=1)printf(&quot;NO\n&quot;); else if((n==2||n==3)&amp;&amp;a==1&amp;&amp;b==1)printf(&quot;NO\n&quot;); else &#123; char ca=&apos;1&apos;,cb=&apos;0&apos;; if(a&lt;b) &#123; swap(a,b); swap(ca,cb); &#125; int k=n-a; for(int i=0; i&lt;n; i++) &#123; for(int j=0; j&lt;n; j++) &#123; if(i==j)B[i][j]=&apos;0&apos;; else B[i][j]=cb; &#125; &#125; for(int i=0; i&lt;k; i++) &#123; B[i][i+1]=B[i+1][i]=ca; &#125; printf(&quot;YES\n&quot;); for(int i=0; i&lt;n; i++) &#123; for(int j=0; j&lt;n; j++) printf(&quot;%c&quot;,B[i][j]); printf(&quot;\n&quot;); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中南多校赛八]]></title>
    <url>%2F2018%2F06%2F06%2F%E4%B8%AD%E5%8D%97%E5%A4%9A%E6%A0%A1%E8%B5%9B%E5%85%AB%2F</url>
    <content type="text"><![CDATA[CSU2128 2130 2135 2136 A题 CSU2128 2128: Wells’s Travel PlanSubmit Page Summary Time Limit: 3 Sec Memory Limit: 128 Mb Submitted: 39 Solved: 3 DescriptionWells来到了一个未知的梦幻国度，这个国度有 2N 个城市，分布为一个 2*N 的矩阵。有些城市是无法到达的。一个城市可以到达与之曼哈顿距离为 1 的城市。 大家都知道打acm没有太多的自由时间出去玩，但Wells仍然想知道，如果在从第 l 个城市出发到第 r 个城市的最少需要经过多少城市。 城市的分布如下图: 1, 2, 3, ….N N+1,N+2,N+3….N*2 Input第一行两个正整数 n，m，m 为询问数 接下来两行，每行是一个长度为 N 的字符串，表示城市能否经过。 若为 X，表示不能经过，若为 P，表示可以经过。 接下来 m 行，每行两个整数 l,r，描述一个询问。 Output对于每个询问输出一行，l 到 r 的需要经过的最少城市个数(不包括起点，但包括终点)，若无法到达输出-1。 Sample Input13 4 XPX PPP 1 4 4 2 6 5 6 4 Sample Output1-1 2 1 2 Hint对于所有数据,n, m &lt; =2 * 105. A题 本来应该是用倍增，但是暴力还是能卡极限过。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define pi acos(-1.0)#define e 2.718#define lowbit(x) (x&amp;(-x))using namespace std;typedef unsigned long long ull;typedef long long ll;const int N=4e5+9;const long long mod=1e9+7;const int maxn=2e5+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,m;int mp[3][maxn];char ch[maxn];set&lt;int&gt; s[3];int main() &#123; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)&amp;&amp;n&amp;&amp;m) &#123; scanf(&quot;%s&quot;,ch); s[0].clear(); s[1].clear(); for(int i=0; i&lt;n; i++) &#123; if(ch[i]==&apos;X&apos;) &#123; s[0].insert(i); mp[0][i]=-1; &#125; else mp[0][i]=0; &#125; scanf(&quot;%s&quot;,ch); for(int i=0; i&lt;n; i++) &#123; if(ch[i]==&apos;X&apos;) &#123; s[1].insert(i); mp[1][i]=-1; &#125; else mp[1][i]=0; &#125; for(int i=0; i&lt;m; i++) &#123; int a,b; int p=0,sum=0; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); a--; b--; if(a%n&gt;b%n)swap(a,b); int ka=a/n,va=a%n,kb=b/n,vb=b%n; if(mp[ka][va]==-1||mp[kb][vb]==-1)sum=-1; else &#123; set&lt;int&gt;::iterator ite; ite=s[ka].upper_bound(va); if(ite!=s[ka].end())p=*ite; else p=INF; while(p&lt;=vb) &#123; sum+=p-va; ka=!ka; va=p-1; if(mp[ka][va]==-1) &#123; sum=-1; break; &#125; ite=s[ka].lower_bound(p); if(ite!=s[ka].end())p=*ite; else p=INF; if(p-1==va) &#123; sum=-1; break; &#125; &#125; if(sum!=-1) &#123; sum+=vb-va; if(kb!=ka)sum+=1; &#125; &#125; printf(&quot;%d\n&quot;,sum); &#125; &#125; return 0;&#125; C 题 CSU 2130 C(2130):Permutations Submit Page Summary Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 57 Solved: 20 Description 给定两个1~n的排列A, B。每次可以把A的最后一个数取出，插入到A的任何一个位置（最前面或者任何两个数中间）。问最少几次可以把A转化为B。 Input 第一行为一个整数n。第二行为1~n的一个排列，表示A。第三行为1~n的一个排列，表示B。 Output 一个整数即最少操作次数。 Sample Input 5 1 5 2 3 4 1 2 3 4 5 Sample Output 3 Hint 30%：n &lt;=100 50%：n &lt;=1000 100%: n &lt;= 200000 最前面顺序正确的就是不用变换的，所以直接减去就行了。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define pi acos(-1.0)#define e 2.718#define lowbit(x) (x&amp;(-x))using namespace std;typedef unsigned long long ull;typedef long long ll;const int N=4e5+9;const long long mod=1e9+7;const int maxn=1e7+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;int a[maxn],b[maxn];map&lt;int,int &gt; m;int main() &#123; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; for(int i=0; i&lt;n; i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d&quot;,&amp;b[i]); m[b[i]]=i; &#125; int k=m[a[0]],ans=1; for(int i=1; i&lt;n; i++) &#123; if(m[a[i]]&gt;k) &#123; ans++; k=m[a[i]]; &#125; else break; &#125; cout&lt;&lt;n-ans&lt;&lt;endl; &#125; return 0;&#125; H 题 H(2135):Appositive BodySubmitPage Summary Time Limit: 10 Sec Memory Limit: 512 Mb Submitted: 29 Solved: 7 DescriptionYuki Nagato is an aliencreated by the Data Overmind, and possesses supernatural powers as a result.Two of her abilities are to observe the universe and to transcend time and space. As we know, it is unstable ofthe universe if there are more than one active bodies which are actually thesame individual at the same time. Nagato defines them as appositivebodies. Of course, Nagato can tell whether there are any appositivebodies of one as soon as she observes. Now, you become able totravel through time and space by some special chance. But before taking action,you have to make sure you won’t destabilize the universe, so you can ask Nagatofor some help, including whether there is an appositive body of you at yourdestination. However, it is inconvenient to make a request every time, so youdecide to study this method. At this time, you are able todescribe the universe abstractly, with several points in a 4-dimension vector,which are the space rectangular coordinates x, y and z,and the time t. After filtered, these points seem to bein alignment. What you need to do now is to check whether these points arecentrosymmetric in four dimensional space. If they are, it means there is yourappositive body at your destination. InputInput consists of severaltest cases, for each test case: First line: a integer n (1 ≤ n ≤ 107), the count ofpoints. Next n lines:each line has four integers x, y, z, t (−108 ≤ x, y, z, t ≤ 108), the coordinate of apoint. OutputFor each test case, output aline: if these points are centrosymmetric in four dimensional space, output”exist”. Otherwise, output “not exist”. Sample Input14 10 0 0 0 1-1 0 3 4 14 8 2 2 15 8 -1 -2 13 10 0 0 0 11 1 1 1 11 1 1 1 14 10 0 0 0 11 1 1 1 11 1 1 1 10 0 0 0 Sample Output1exist 1not exist 1exist 排个序，然后 判断 第 I 个 加上 N-I-1个的xyzt,是不是全部等于2背平均数就行 暴力。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define pi acos(-1.0)#define e 2.718#define lowbit(x) (x&amp;(-x))using namespace std;typedef unsigned long long ull;typedef long long ll;const int N=4e5+9;const long long mod=1e9+7;const int maxn=1e7+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;struct four &#123; double x,y,z,t;&#125; f[maxn];bool cmp(const four &amp;a,const four &amp;b) &#123; if(a.t==b.t) &#123; if(a.x==b.x) &#123; if(a.y==b.y) &#123; return a.z&lt;b.z; &#125; else return a.y&lt;b.y; &#125; else return a.x&lt;b.x; &#125; else return a.t&lt;b.t;&#125;long double cl(long double t)&#123; return t*2/n;&#125;int main() &#123; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; long double x,y,z,t; x=y=z=t=0; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%lf%lf%lf%lf&quot;,&amp;f[i].x,&amp;f[i].y,&amp;f[i].z,&amp;f[i].t); x+=f[i].x; y+=f[i].y; z+=f[i].z; t+=f[i].t; &#125; x=cl(x); y=cl(y); z=cl(z); t=cl(t);// cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;t&lt;&lt;endl; int flag=1; sort(f,f+n,cmp); for(int i=0; i&lt;=(n-1)/2; i++) &#123; if(abs(f[i].x+f[n-i-1].x-x)&gt;eps|| abs(f[i].y+f[n-i-1].y-y)&gt;eps|| abs(f[i].z+f[n-i-1].z-z)&gt;eps|| abs(f[i].t+f[n-i-1].t-t)&gt;eps)&#123; flag=0; &#125; &#125; puts(flag?&quot;exist&quot;:&quot;not exist&quot;); &#125; return 0;&#125; I题 I(2136):统帅三军! Submit Page Summary Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 7 Solved: 1 Description Wells最近迷上了一款攻城的策略游戏，点就去就能当大元帅统帅三军！ 游戏界面主要是一个平面(坐标可以为浮点数)，然而Wells发现这游戏是个骗局，其实只给了一个军队。 Wells初始有一个军队，仅包含n个士兵，每个士兵有一个初始位置（x,y）和一个劳累指数Wi，每个队员可以移动，显然对于每个队员的移动是需要消耗一些体力的，若第i个队员从位置（x1,y1）移动到（x2,y2）的体力消耗为Wi*(|x2-x1|+|y2-y1|)。 Wells希望先将队伍集合起来，且希望整个队伍一次集合的体力消耗越少越好。显然能量消耗的多少直接取决与Wells对于会和点（x,y）的选择，然而Wells太懒了，希望你帮他找出某个时刻的最佳会和点。 Input 对于每组数据： 第一行：一个整数N，表示士兵数目。 第二行：一共N个整数，其中的第i个数Wi表示第i个队员的劳累指数。(N&lt;=106)(N&lt;=106) 接下来N行：每一行两个整数X和Y，表示第i个士兵的当前的横坐标和纵坐标。(−109&lt;=X,Y&lt;=109)(−109&lt;=X,Y&lt;=109) Output 一个实数。表示所有队员集合到最佳攻击位置的体力消耗总和，答案保留两位小数。 Sample Input 1 1 0 0 Sample Output 0.00 I 这题比较毒瘤，写了半天三分发现精度有问题，后来仔细想了下，根本不可能是小数， 他求的是曼哈顿距离，可以把X，Y分开算。 从左往右走到某个点 左边的W &gt; 右边W的和就可以了，那个时候绝对就是临界值 因为再往左走一定是增的比减的少 Y轴也是同理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define pi acos(-1.0)#define e 2.718#define lowbit(x) (x&amp;(-x))using namespace std;typedef unsigned long long ull;typedef long long ll;const int N=4e5+9;const long long mod=1e9+7;const int maxn=1e7+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;struct P&#123; int x,w,y;&#125;p[maxn];bool cmp(const P &amp; a,const P &amp; b)&#123; return a.x&lt;b.x;&#125;bool cmp2(const P &amp;a,const P &amp; b)&#123; return a.y&lt;b.y;&#125;long long jsx(int l)&#123; long long s1=0,s2=0; for(int i=0;i&lt;n;i++) &#123; s1+=abs(p[i].w*(p[i].x-p[l].x)); &#125; for(int i=0;i&lt;n;i++) &#123; s2+=abs(p[i].w*(p[i].x-p[l-1].x)); &#125; return min(s1,s2);&#125;long long jsy(int l)&#123; long long s1=0,s2=0; for(int i=0;i&lt;n;i++) &#123; s1+=abs(p[i].w*(p[i].y-p[l].y)); &#125; for(int i=0;i&lt;n;i++) &#123; s2+=abs(p[i].w*(p[i].y-p[l-1].y)); &#125; return min(s1,s2);&#125;int main() &#123; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;p[i].w); long long aw=0; for(int i=0;i&lt;n;i++) &#123; scanf(&quot;%d%d&quot;,&amp;p[i].x,&amp;p[i].y); aw+=p[i].w; &#125; sort(p,p+n,cmp); long long l=0,r=aw-p[0].w,sum=0; for(int i=1;i&lt;n;i++) &#123; l+=p[i-1].w; r-=p[i].w; if(r&lt;=l) &#123; sum+=jsx(i); break; &#125; &#125; sort(p,p+n,cmp2); l=0;r=aw-p[0].w; for(int i=1;i&lt;n;i++) &#123; l+=p[i-1].w; r-=p[i].w; if(r&lt;=l) &#123; sum+=jsy(i); break; &#125; &#125; printf(&quot;%lld.00\n&quot;,sum); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小生成树Prim&&Kruskal 算法 详细笔记]]></title>
    <url>%2F2018%2F06%2F06%2F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91Prim%26%26Kruskal%20%E7%AE%97%E6%B3%95%20%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[POJ 1258 Agri-Net http://poj.org/problem?id=1258； 两种算法 Prim Kruskal. 先说Prim 初始化 权值，随便一个顶点做起点，为0 其它的为最大值。 找到权值最小的顶点，且没有加入集合。 把顶点权值加到结果，把定点加入集合。 暴力枚举 顶点连接的所有的边，更新所有能够连接上顶点的权值。 重复前3步，直到所有点全部加入集合。 以上图就是 首先找到的是 0节点 一开始权值是0，所以res +=0；然后暴力所有能够连接的点就是 1，和2， 然后更新 mincost[2]=min(INF,2)，结果等于2；同理 mincost[1]=10; 其它点的权值不变。 然后又开始找找到 2 顶点，然后暴力所有点，这次更新的就是3 4 5顶点。然后不断重复就行了 最后连接起来的树是这个样子的。 下面是代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxv=1e3+25; //最大顶点数const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int cost[maxv][maxv]; // cost[u][v] 表示 u 到 v 的权值如果没有边权值为无穷大（INF）;int mincost[maxv]; //每个点的最小权值，起点自己为0，其它为自己连接到集合最小权值；bool used[maxv]; //表示顶点 是否已经连接上；int V; //顶点数目；int prim() &#123; for(int i=0; i&lt;V; i++) &#123; mincost[i]=INF; //开始的时候全部初始化为无穷大。 used[i]=false; //初始化 ，全部没有连接。 &#125; mincost[0]=0; //以 0 节点为起点开始连接。 int res = 0; //权值和 while(1) &#123; int v=-1; //选择的节点，开始为-1，然后开始找已经确定是最小的距离 for(int u=0; u&lt;V; u++) &#123; if(!used[u]&amp;&amp; (v == -1 || mincost[u]&lt;mincost[v]))v=u; //如果 v==-1或者不是最小距离的时候更新v。 &#125; if(v==-1)break; //只有在所有的点都已经加入集合 v==-1。跳出循环。 used[v]=true; //把顶点加入集合。 res+=mincost[v]; //把边的长度加到结果里 for(int u=0; u&lt;V; u++) &#123; mincost[u]=min(mincost[u],cost[v][u]); //从当前点到其它点的距离如果比其他路短就更新。 &#125; &#125; return res;&#125;int main() &#123; int m; scanf(&quot;%d%d&quot;,&amp;V,&amp;m); //输入顶点数和边数。 注意定点是从 0 到V-1。 for(int i=0; i&lt;m; i++) &#123; int u,v,w; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); cost[u][v]=cost[v][u]=w; &#125; printf(&quot;%d\n&quot;,prim());//下面是POJ 1258 主程序代码。 /* while(cin&gt;&gt;V) &#123; for(int i=0; i&lt;V; i++) &#123; for(int j=0; j&lt;V; j++) &#123; cin&gt;&gt;cost[i][j]; &#125; &#125; printf(&quot;%d\n&quot;,prim()); &#125; */ return 0;&#125; 接下来是Kruskal 代码 这个算法其实和Prim 算法差距不大，这个是直接把边排序 找到最小的边 判断边的两个节点是不是连接到同一颗树上，是跳过，不是连接两个顶点的根节点，结果加上边。 重复上面两步，直到连接N-1条边，因为N个顶点要N-1条边就能连接起来。 对于这个图，首先就找到（2，3 ）这条边连起来，然后就是（4 5），然后（0 2），这时候有2棵树 （0 2 3 ）和（4 5）然后接着连 （2 5）（5 6 ）（1 4）就全部连接上了 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxv=1e3+25; //最大顶点数const int maxm=1e6+25; //最大边数const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int V,m; //顶点数目；struct edge &#123; int u,v,cost; //节点用来 保存每个边的情况&#125;;bool cmp(const edge &amp; a,const edge &amp; b) &#123; return a.cost&lt;b.cost; //用于排序，相当于重载小于号。&#125;edge es[maxm];int par[maxv]; // par[i]==j. i 的 根节点为 j;int find(int x) &#123; //寻找根节点 if(x==par[x])return x; //如果根节点就是自己直接返回自己 else return par[x]=find(par[x]); //如果根节点不是自己，继续寻找自己上一个节点的根节点。&#125;void unit(int x,int y) &#123; x=find(x); //找到 x 的根节点 y=find(y); par[x]=y; //把 x 的根节点 连接上 y.&#125;void init(int n) &#123; for(int i=0; i&lt;=n; i++)par[i]=i; //初始化的时候根节点都是自己；&#125;int Kruskal() &#123; sort(es,es+m,cmp); //按 边的权值排序； init(V); int res=0,se=0; //se 保存边数。 for(int i= 0; i&lt;m; i++) &#123; edge e =es[i]; if(find(e.u)!=find(e.v)) &#123; //如果根节点不相同就连接 unit(e.u,e.v); res+=e.cost; if(++se==V-1)return res; //如果连了V-1条边就跳出； &#125; &#125; return res;&#125;int main() &#123; scanf(&quot;%d%d&quot;,&amp;V,&amp;m); //输入顶点数和边数。 注意定点是从 0 到V-1。 for(int i=0; i&lt;m; i++) &#123; int u,v,w; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); es[i].u=u; es[i].v=v; es[i].cost=w; &#125; printf(&quot;%d\n&quot;,Kruskal()); // POJ 1285 AC 主程序代码 /* while(cin&gt;&gt;V) &#123; int k=0; for(int i=0; i&lt;V; i++) &#123; for(int j=0; j&lt;V; j++) &#123; cin&gt;&gt;es[k].cost; es[k].u=i; es[k].v=j; k++; &#125; &#125; m=k; printf(&quot;%d\n&quot;,Kruskal()); &#125;*/ return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛19]]></title>
    <url>%2F2018%2F06%2F04%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B19%2F</url>
    <content type="text"><![CDATA[链接：https://www.nowcoder.com/acm/contest/111/A来源：牛客网 时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 524288K，其他语言1048576K64bit IO Format: %lld 题目描述 作为故事主角的托米是一名老师。 一天，他正在为解析算术表达式的课程准备课件。 在课程的第一部分，他只想专注于解析括号。 他为他的学生发明了一个有趣的正确括号序列的几何表示，如下图所示: 几何表示的定义： 1. 对于一个括号序列A，我们定义g(A)是A的几何表示形式,则 “()”的表示是一个1*1的方块，高度为1; 2.对于一个括号序列A，”(A)”的表示是由一个比g(A)宽2个单位高1个单位的矩形包围g(A)，它的高度为A+1;3.对于两个括号序列A和B，A+B的几何表示形式为把g(B)放置在g(A)右边的一个单位，且高度为A和B的高度的较大值。其中+指的是字符串的连接符。 在完成课件后，托米老师开始玩他做好的图片。 他将图像的有限区域交替地涂成黑色和白色，使最外面的区域全部涂成黑色。 对于上面的例子，这个着色如下所示： 现在给你一个合法的括号序列。 请计算颜色为黑色的区域的面积。 输入描述: 输入的第一行包含一个整数T，表示指定测试用例的数量。每个测试用例前面都有一个空白行。每个测试用例由一个合法括号序列组成。 每行只包含字符’(‘和’)’。 输出描述: 对于每个测试用例，输出一行包含一个整数,表示相应几何表示的黑色部分的面积。 示例1 输入 复制 2 ((())) (())(()(())) 输出 复制 10 20 说明 第二个测试案例是上图中显示的案例。 备注: 1≤T≤10 一个合法括号序列长度≤4 x 105 这题主要是处理三个问题 一个是长方体的高度，一个长度，白色还是黑色。 首先预处理，颜色，和高度 颜色，判断是第几个奇偶就行了，第一个肯定是黑色，第二个就是白色。 注意处理的时候每匹配一个’)’ 数量就要减1； 长方体的高，用一棵树就行了，然后每个‘（’的度就是每个长方形的高度。 长度容易处理 直接找到匹配的括号直接距离 -1 就是长方体长度 我用栈来保存 ‘（’的位置。 遇见’(’压入栈 ，遇见‘)’弹出 ，计算距离。如果是白色就是减去这个长方形的面积，黑色就加上。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxn=1e7+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int a[maxn];int p[maxn],b[maxn];char ch[maxn];int n;stack&lt;int&gt; s;int main() &#123; scanf(&quot;%d&quot;,&amp;n); while(n--) &#123; scanf(&quot;%s&quot;,ch); int l=strlen(ch); a[0]=1; int x=1,y=0; p[0]=-1; b[0]=1; int k=0; for(int i=1; i&lt;l; i++) &#123; if(ch[i]==&apos;(&apos;) &#123; a[i]=a[i-1]+1; p[i]=k; k=i; b[k]=1; &#125; else &#123; b[p[k]]=max(b[p[k]],b[k]+1); k=p[k]; a[i]=a[i-1]-1; &#125; &#125;// for(int i=0;i&lt;l;i++)// printf(&quot;%d%c&quot;,b[i],i+1==l?&apos;\n&apos;:&apos; &apos;); long long flag=1,sum=0; for(int i=0; i&lt;l; i++) &#123; if(ch[i]==&apos;(&apos;) &#123; s.push(i); &#125; else &#123; int k=s.top(); s.pop(); if(a[k]%2==1)sum=sum+(i-k)*(b[k]); else sum-=(i-k)*(b[k]); &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125; D： 链接：https://www.nowcoder.com/acm/contest/111/D来源：牛客网 时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 524288K，其他语言1048576K 64bit IO Format: %lld 题目描述 此时的托米老师已经出任CEO，迎娶白富美，走向了人生巅峰！于是这个暑假，托米老师打算在北京一个偏僻的小农村里度过他的假期。 由于这里什么都没有，于是他去超市选了很多生活用品，更多的是吃的，然后推着堆满零食的购物车到柜台等待结账。 当然，我们都知道他的钱包里有很多钱。但是，作为一名为生活精打细算的男孩子，他更愿意使用其他支付方式如：饭券，礼券，不同类型的优惠券等。但是饭券只能用于购买食物，而礼券通常只限于某种类型的礼物。 现在给你托米购物车中物品的数量N和每件物品的价格。也会给出他钱包中的代金券数量M以及允许使用的信息 。 在为他的购物付款时，托米可能使用代金券的金额超过他所购物品的成本。也可以在多张代金券之间拆分商品的成本，并使用代金券支付多件商品。 请你计算托米需要为购物支付的额外现金的最小金额。 输入描述:1输入的第一行包含一个整数T，用于指定测试用例的数量。 每个测试用例前面都有一个空白行。 每个测试用例从包含两个正整数N(物品数量)和M(券数量)的行开始。 接下来一行包含N个数字，第i个数字表示托米购物车里第i件物品的价格。 接下来一行包含M个数字，第i个数字表示第i张券的金额。 接下来有M行，当中的第 i 行描述第 i 张卷可以买哪些商品。每行的第一个数字是 K,代表第 i 张卷可以为 K 件商品付款，接下来还有 K 个数，是这 K 件商品的编号 输出描述:1对于每个测试用例输出数字，表示托米需要支付多少现金。 最大流模板题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxn=2e2+25;const int maxm=4e3+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,m,T;int a[maxn],b[maxm];struct edge &#123; int to,cap,rev;&#125;;vector &lt;edge&gt; G[maxn+maxm];bool used[maxn+maxm];int level[maxn+maxm];int iter[maxn+maxm];void bfs(int s) &#123; memset(level,-1,sizeof(level)); queue&lt;int&gt; que; level[s]=0; que.push(s); while(!que.empty()) &#123; int v= que.front(); que.pop(); for(int i=0; i&lt;G[v].size(); i++) &#123; edge &amp; e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0) &#123; level[e.to]=level[v] + 1; que.push(e.to); &#125; &#125; &#125;&#125;void add(int from,int to,int cap) &#123; edge eg; eg.to=to; eg.cap=cap; eg.rev=G[to].size(); G[from].push_back(eg); eg.to=from; eg.cap=0; eg.rev=G[from].size()-1; G[to].push_back(eg);&#125;//int dfs(int v,int t,int f) &#123;// if(v == t)return f;// used[v]=true;// for(int i = 0; i &lt; G[v].size(); i++) &#123;// edge &amp;e=G[v][i];// if(!used[e.to]&amp;&amp;e.cap&gt;0) &#123;// int d=dfs(e.to,t,min(f,e.cap));// if(d&gt;0) &#123;// e.cap-=d;// G[e.to][e.rev].cap+=d;// return d;// &#125;// &#125;// &#125;// return 0;//&#125;int dfs(int v,int t,int f) &#123; if(v == t)return f; for(int &amp;i = iter[v]; i &lt; G[v].size(); i++) &#123; edge &amp;e=G[v][i]; if(e.cap&gt;0 &amp;&amp; level[v]&lt;level[e.to]) &#123; int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0) &#123; e.cap-=d; G[e.to][e.rev].cap+=d; return d; &#125; &#125; &#125; return 0;&#125;/*int maxflow(int s,int t) &#123; int flow=0; for(;;) &#123; memset(used,0,sizeof(used)); int f=dfs(s,t,INF); if(f==0)return flow; flow += f; &#125;&#125;*/int maxflow(int s,int t) &#123; int flow=0; for(;;) &#123; bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while((f = dfs(s,t,INF))&gt;0) &#123; flow +=f; &#125; &#125;&#125;int main() &#123; scanf(&quot;%d&quot;,&amp;T); while(T--) &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int sum=0; for(int i=0;i&lt;=m+n+1;i++)G[i].clear(); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); sum+=a[i]; add(i,n+m+1,a[i]); &#125; for(int j=1; j&lt;=m; j++) &#123; scanf(&quot;%d&quot;,&amp;b[j]); add(0,n+j,b[j]); &#125; for(int i=1; i&lt;=m; i++) &#123; int k; scanf(&quot;%d&quot;,&amp;k); for(int j=0; j&lt;k; j++) &#123; int x; scanf(&quot;%d&quot;,&amp;x); add(n+i,x,a[x]); &#125; &#125; cout&lt;&lt;sum-maxflow(0,n+m+1)&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP]]></title>
    <url>%2F2018%2F05%2F23%2FKMP%2F</url>
    <content type="text"><![CDATA[KMP算法，刚接触到这个算法本来一看是看一眼就会了，但是过了一段时间反而不会了，搞得我又重新回来学了一次。 其实KMP算法挺简单的，这个算法的核心我感觉就是在处理next 数组上。 我先讲一下一种处理方式吧， next [0]=-1,这个不用多说，第一个肯定是没有匹配好的。 k=-1; ,i=0两个初始化 ，k,表示的是匹配到的位置 ，i，表示的是你正在为那个位置标记next。 123456789101112131415161718192021222324252627282930313233343536 #include&lt;bits/stdc++.h&gt;using namespace std; void getnext(const char * str,int * next) &#123; next[0]=-1; int i=0,k=-1; while(str[i]!=&apos;\0&apos;) &#123; while(k!=-1&amp;&amp;str[i]!=str[k])k=next[k];// 在你匹配这个 i 之前首先寻找到前面一个最大匹配位置， //如果 不匹配就一直往前面回溯，直到能够匹配。 i++; k++; if(str[i]==str[k])next[i]=next[k]; //当前位置是相等的 这个不匹配 同样 K的位置也没法匹配，所以 next [i]可以直接等于next[k]. else next[i]=k; &#125;&#125;int kmp(const char *s,const char * c)&#123; int lc=strlen(c),ls=strlen(s); int *next=new int[lc+1]; getnext(c,next); int j=0,i=0; while(i&lt;ls) &#123; while(j!=-1&amp;&amp;s[i]!=c[j])j=next[j]; i++,j++; if(j==lc)return 1; &#125; return 0;&#125; int main() &#123; int next[1000]; char ch[]=&quot;abaabc&quot;,s[]=&quot;ababaababcb&quot;; cout&lt;&lt;kmp(s,ch)&lt;&lt;endl;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DP学习笔记，题目 Traveling by Stagecoach POJ 2686 题解]]></title>
    <url>%2F2018%2F05%2F19%2FDP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8C%E9%A2%98%E7%9B%AE%20Traveling%20by%20Stagecoach%20POJ%20%202686%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Traveling by Stagecoach POJ 2686，题解。 作为一名菜鸟，说状压DP，还是有点勉强，顶多做个学习笔记。 首先，什么是DP，状态转移，其实就是从已经确定的状态，到一个状态。 状压DP，我理解的就是 用 一个数的二进制表达状态。 1，表示 有 ，0 表示无 比如 4而进制表示 100 ， 说明 3号 位置表示 有 ，其它的都表示没有。 题目 Traveling by Stagecoach POJ 2686 开一个DP【S】[M]. S 是票的使用状况 ， M，是在哪一个城市。值就是最小花费。 把一个票都没有用的，起点 标记为0,也就是 DP[1&lt;&lt;n-1][a]==0. 暴力枚举 所有 可以用的票 ，(S&gt;&gt;i)&amp;1 表示第 I 张票可不可以用。 再暴力枚举 当前这个S下所有的 可以到的城市，dp[S][v]!=INF，当前S下v这个城市可不可以到达。 然后再暴力所有 v， 这个城市所有的路，然后使用第 i张票。d[v][u]&gt;=0。V 和u中间的路。 然如果用这张票，走这条路 到目的地的值小就覆盖前面的值S&amp;~(1&lt;&lt;i)使用第i张票后的状态，d[v][u],从 v城市到u城市的路。 dp[S&amp;~(1&lt;&lt;i)][u]=min(dp[S&amp;~(1&lt;&lt;i)][u],dp[S][v]+(double)d[v][u]*1.0/t[i])。 AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;stdio.h&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxn=9;const int maxm=31;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,m,a,b,p,u,v,c;int t[maxn];int d[maxm][maxm];double dp[1&lt;&lt;maxn][maxm];int main() &#123; ios_base::sync_with_stdio(false); cin.tie(0);// freopen(&quot;123.txt&quot;,&quot;r&quot;,stdin); while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;p&gt;&gt;a&gt;&gt;b) &#123; int k=(1&lt;&lt;n)-1; if(n==0&amp;&amp;m==0&amp;&amp;p==0&amp;&amp;a==0&amp;&amp;b==0)return 0; for(int i=0; i&lt;n; i++)cin&gt;&gt;t[i]; memset(d,-1,sizeof(d)); while(p--) &#123; cin&gt;&gt;u&gt;&gt;v&gt;&gt;c; d[u][v]=c; d[v][u]=c; &#125; for(int i=0; i&lt;=k; i++)fill(dp[i],dp[i]+m+1,INF); dp[k][a]=0; double res=INF; for(int S=k; S&gt;=0; S--) &#123; res=min(res,dp[S][b]); for(int i=0; i&lt;n; i++) &#123; if((S&gt;&gt;i)&amp;1) &#123; for(v =1; v&lt;=m; v++) &#123; if(dp[S][v]!=INF) &#123; for(u=1; u&lt;=m; u++) &#123; if(d[v][u]&gt;=0) &#123; dp[S&amp;~(1&lt;&lt;i)][u]=min(dp[S&amp;~(1&lt;&lt;i)][u],dp[S][v]+(double)d[v][u]*1.0/t[i]); &#125; &#125; &#125; &#125; &#125; &#125; &#125; if(res==INF) &#123; printf(&quot;Impossible\n&quot;); &#125; else &#123; printf(&quot;%.3f\n&quot;,res); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 湘潭邀请赛 部分题解]]></title>
    <url>%2F2018%2F05%2F14%2F2018%20%E6%B9%98%E6%BD%AD%E9%82%80%E8%AF%B7%E8%B5%9B%20%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[2018 湘潭邀请赛 题解 A C F G K .其它题解，后续添加 A 题 没啥好讲的，签到题 从后面往前面数，大于个数的时候直接输出就行了。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;const long long mod=1e9+7;const int maxn=2e5+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int main() &#123; int n,a[maxn]; long long sum=0; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) &#123; sum=0; for(int i=0; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; for(int i=n; i&gt;=0; i--) &#123; sum+=a[i]; if(sum&gt;=i) &#123; printf(&quot;%d\n&quot;,i); break; &#125; &#125; &#125; return 0;&#125; C题 题目的意思就是找一个区间比 一个数大的数的个数要不小于这个数。求这个数最大是多少。 这一题就是一个区域树（大佬们告诉我也叫主席树，然而我这个菜鸡不知道啥是主席树），一般线段树维护的是一个值。这题每个节点维护的是一个数组，这个题没有修改只有查询。 每次查询在包含这个区间就二分查找大于这个数的个数， 如果 不包含返回零。 如果有一部分在这个区间就继续往下找，然后返回两个儿子的个数和。 复杂度是（nlogn+m log^3 n）; AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;const long long mod=1e9+7;const int maxn=1e7+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;const int sz=(1&lt;&lt;18)-1;int n,m;int a[maxn];vector&lt;int&gt; dat[sz];void init(int k,int l,int r) &#123; dat[k].clear(); if(r-l==1)dat[k].push_back(a[l]); else &#123; int lch=k*2+1,rch=k*2+2,md=(l+r)/2; init(lch,l,md); init(rch,md,r); dat[k].resize(r-l); merge(dat[lch].begin(),dat[lch].end(),dat[rch].begin(),dat[rch].end(),dat[k].begin()); &#125;&#125;int query(int i,int j,int x,int k,int l,int r) &#123; if(j&lt;=l||r&lt;=i)return 0; else if(i&lt;=l&amp;&amp;r&lt;=j) &#123; return dat[k].end()-lower_bound(dat[k].begin(),dat[k].end(),x); &#125; else &#123; int lch=2*k+1,rch=2*k+2,md=(l+r)/2; return query(i,j,x,lch,l,md)+query(i,j,x,rch,md,r); &#125;&#125;int main() &#123; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)) &#123; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; init(0,0,n); int l,r,R,L,x; for(int i=0; i&lt;m; i++) &#123; scanf(&quot;%d%d&quot;,&amp;l,&amp;r); l--; L=1; R=n; while(R-L&gt;1) &#123; x=(R+L)/2; int c=query(l,r,x,0,0,n); if(c&gt;=x)L=x; else R=x; &#125; printf(&quot;%d\n&quot;,L); &#125; &#125; return 0;&#125; F题 一个sort 就过了没啥难的，就是注意值爆了double 要用long double。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;const long long mod=1e9+7;const int maxn=1e3+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;struct two &#123; long double val; int id;&#125; k[maxn];bool cmp(two &amp; a,two &amp;b) &#123; if(a.val==b.val)return a.id&lt;b.id; return a.val&lt;b.val;&#125;int main() &#123; int n; long long a,b,c,d; while(~scanf(&quot;%lld&quot;,&amp;n)) &#123; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c); long double t=0; t=a*1.0; t+=b*1.0; t=t/(t+c*1.0); k[i].id=i; k[i].val=t; &#125; sort(k,k+n,cmp); for(int i=0; i&lt;n; i++) &#123; printf(&quot;%d%c&quot;,k[i].id+1,i+1==n?&apos;\n&apos;:&apos; &apos;); &#125; &#125; return 0;&#125; G题 找规律，这个变化可以保证 两个a,b一定可以消去，a,b,的位置可以交换，所以题目就变成了找两个字符串对应的，c ,左右两边的a,b奇偶是不是一样的。 如果c个数不相等直接输出no； 相等 判断 ，以c为分隔符的区间 a,b,的奇偶相不相等。 AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;const long long mod=1e9+7;const int maxn=1e4+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;struct two &#123; int x,y;&#125; k[maxn],k2[maxn];int main() &#123; char a[maxn],b[maxn]; int flag,c; while(~scanf(&quot;%s%s&quot;,&amp;a,&amp;b)) &#123; int la=strlen(a),lb=strlen(b); memset(k,0,sizeof(k)); memset(k2,0,sizeof(k2)); c=0; flag=1; int pa,pb; pa=pb=0; for(int i=0; i&lt;la; i++) &#123; if(a[i]==&apos;a&apos;) &#123; k[pa].x=(k[pa].x+1)%2; &#125; if(a[i]==&apos;b&apos;) &#123; k[pa].y=(k[pa].y+1)%2; &#125; if(a[i]==&apos;c&apos;) &#123; pa++; c++; &#125; &#125; for(int i=0; i&lt;lb; i++) &#123; if(b[i]==&apos;a&apos;) &#123; k2[pb].x=(k2[pb].x+1)%2; &#125; if(b[i]==&apos;b&apos;) &#123; k2[pb].y=(k2[pb].y+1)%2; &#125; if(b[i]==&apos;c&apos;) &#123; pb++; c--; &#125; &#125; int l=max(pa,pb); if(c!=0)flag=0; for(int i=0; i&lt;=l; i++) &#123; if(k[i].x!=k2[i].x||k[i].y!=k2[i].y) &#123; flag=0; &#125; if(!flag)break; &#125; if(flag)printf(&quot;Yes\n&quot;); else printf(&quot;No\n&quot;); &#125; return 0;&#125; K题 就是一个找因子的题 2018 因子 1 ，2018 ，2 ，1009； 所以 所有的 奇数可以和所有的 2018的倍数匹配。 2018 可以和所有的数匹配， 偶数 可以和所有 1009 的倍数匹配 1009 可以和所有 偶数匹配； 注意一下，其中重复算的就行。 AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;const long long mod=1e9+7;const int maxn=2e5+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int main() &#123; long long sum=0,a,b,c,d; while(scanf(&quot;%lld%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c,&amp;d)!=EOF) &#123; sum=0; long long x1,x2,x1009,x2018,y1,y2,y1009,y2018; x2=x1=(b-a+1)/2; if((b-a)%2==0) &#123; if(a&amp;1)x1++; else x2++; &#125; x1009=(a%1009==0)+b/1009-a/1009; x2018=(a%2018==0)+b/2018-a/2018; y2=y1=(d-c+1)/2; if((d-c)%2==0) &#123; if(c&amp;1)y1++; else y2++; &#125; y1009=(c%1009==0)+d/1009-c/1009; y2018=(c%2018==0)+d/2018-c/2018; sum+=(x1-x1009+x2018)*y2018; sum+=x2018*(y1+y2); sum+=(x2-x2018)*(y1009); sum+=(x1009-x2018)*y2; printf(&quot;%lld\n&quot;,sum); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bit 位，树状数组学习笔记。]]></title>
    <url>%2F2018%2F04%2F25%2Fbit%20%E4%BD%8D%EF%BC%8C%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%82%2F</url>
    <content type="text"><![CDATA[给一个初始值全为0的数列a1,a2,…,an. 给定 i，求a1+a2+..+ai. 给定i,x 执行ai+x; 图不好看见谅： 如图所示，1节点维护的是a1本身的和 2节点维护的是 a1到a2 的和 3节点维护的是a3的和 4节点维护的是a1到a4 的和 为啥会有些节点维护的值的个数不同呢？ 很简单 ，就是看最后一个1的位置，2：二进制0010 最后一个1是第2个位置所以维护2的2-1次方个值。4：0100维护2的3-1次方个值。 加法，把有维护自己的值都加上X就行了 加法：例子在a3上+X就是在3节点上+X，4节点+X，8节点+X。看一眼上图，就知道，就是按箭头一个个向上节点转移。 怎么实现这种转移呢？ 3的二进制是0011.4是 0100，8是1000. 就是把加上最后一个1所在位置的值，0011 +0001（最后一个位置是最后一个）=0100； 0100+0100（最后一个1位置是第3个）=1000； 以此类推，在a5也是一样,0101+0001=0110(6); 0110+0010=1000(8); 怎么实现，就是i+=i&amp;-i; i&amp;-i可以把自己最后一个1的位置算出来，怎么来的就自己去百度吧。 求和：比如 前5个的和，就是（1到4）+5 也就是4节点加5节点的和。 前7个的和就是7+（5到6）+（1到4）的和，也就是4节点加6节点加7节点的和。 至于怎么实现呢如果细心的话不难发现，其实就是从最后一个1慢慢一个个变成0的节点全加上 如 7的二进制是0111 前7个的和就是 0111+ 0110+0100 前 5（0101）个的和 0101 +0100 按位运算就是 i-=i&amp;-i. 代码非常简单。 复杂度 O（log N）; includeusing namespace std;const int maxn=1&lt;0) { s +=bit[i]; i-=i&amp;-i; } return s;}void add(int i,int x){ while(i&lt;=n) { bit[i]+=x; i+=i&amp;-i; }}]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIT基本操作，和别人一起做项目]]></title>
    <url>%2F2018%2F04%2F16%2FGIT%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%92%8C%E5%88%AB%E4%BA%BA%E4%B8%80%E8%B5%B7%E5%81%9A%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[Git基本操作 GIT教程：https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 GIT下载： 在自己的电脑上，安装Git下载页面：https://git-scm.com/downloads下载安装，一路下一步即可。 GitHub Desktop下载地址：https://desktop.github.com GIT 简单的使用： 1、 注册码云： 码云注册页面：https://gitee.com/signup 应该不需要我多说 2、你需要访问仓库（是个网址）： 如果你需要创建自己有一个专门的分支还需要fork； 点击fork 后会让你选择自己，然后 点击确定 ，左上角变成你自己的名字就对了。 左上角变成你自己的名字就对了 左上角变成你自己的名字就对了 左上角变成你自己的名字就对了 一定要记住 ，那个红圈里面是自己的码云昵称。不然你就等着一直认证失败吧。 点击的【克隆/下载】，点击【复制】按钮复制下面的连接，我们把这个连接称为【连接①】 3、开始clone ： 第一种： 要打开的是Git Bash Here 不是 Git GUI here 上图指错了 然后开始克隆就行了，输入 命令 git clone 做完这些你就会发现你当前文件夹下面多了你clone出来的文件夹，也就是你的本地仓了。 第二种： 打开cmd窗口 按Win键+R，输入cmd，按【确定】 1在cmd窗口中切换文件夹 随便找一个文件夹 比如d盘中123文件夹，那么输入D: 敲回车，cd 123 敲回车即可切换 1这个是转换到你要转换到你要clone的目录下 然后输入 12 1git config --global user.name &quot;注册码云时用的昵称&quot; 12 1git config --global user.email &quot;注册码云时用的邮箱&quot; 这个是登录 特别提醒：转到的目录是仓库下，不是你原本clone的目录下，是到clone出来的那个文件夹目录下。别和前面clone的目录一样。 特别提醒：转到的目录是仓库下，不是你原本clone的目录下，是到clone出来的那个文件夹目录下。别和前面clone的目录一样。 特别提醒：转到的目录是仓库下，不是你原本clone的目录下，是到clone出来的那个文件夹目录下。别和前面clone的目录一样。 和第一种的区别是用的是自己电脑带的命令行。不是git给的。 4.上传 上去 一样的有两种操作我就之说一种，另一种自己照着上面两种进行操作。 先进行修改 修改后 进入命令行 操作 转到仓库位置也就是你clone出来的文件夹。这个是clone出来的文件夹位置（本地仓的位置），不是clone到的位置。git add -A .git commit -m “姓名”git push 第一次push 需要登陆 ，输入密码的时候 输入什么都看不见不用管，也有可能弹出一个窗口让你登陆。 告诉大家一种用GitHub Desktop 这个东西进行简单操作； 下载地址https://desktop.github.com 然后安装好就行。 安装好后 直接登陆，添加仓库 然后选中 你原本clone 的文件夹就可以了， 如果 你提交的是自己的，请注意 那个分支要提交对了 // 注意第一次提交 要登陆 ，登陆的用户名是那个个人主页 名称下面的那几个英文。 提交Pull Request 到仓库 然后就OK了，这样就可以愉快的和别人一起做项目了]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018湖南多校第三场]]></title>
    <url>%2F2018%2F04%2F16%2F2018%E6%B9%96%E5%8D%97%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%89%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[2018 中南多校 第三场 A(2063): Good Versus Evil SubmitPage Summary TimeLimit: 5 Sec MemoryLimit: 512 Mb Submitted: 85 Solved: 15 Description Middle Earth is about to go to war. The forces of goodwill have many battles with the forces of evil. Different races will certainlybe involved. Each race has a certain ‘worth’ when battling against others. Onthe side of good we have the following races, with their associated worth: Hobbits - 1 Men - 2 Elves - 3 Dwarves - 3 Eagles - 4 Wizards - 10 On the side of evil we have: Orcs - 1 Men - 2 Wargs - 2 Goblins - 2 Uruk Hai - 3 Trolls - 5 Wizards - 11 Although weather, location, supplies and valor play apart in any battle, if you add up the worth of the side of good and compare itwith the worth of the side of evil, the side with the larger worth will tend towin. Thus, given the count of each of the races on the side of good, followedby the count of each of the races on the side of evil, determine which sidewins. Input The first line of input will contain an integer greaterthan 0 signifying the number of battles to process. Information for each battlewill consist of two lines of data as follows. First, there will be a linecontaining the count of each race on the side of good. Each entry will beseparated by a single space. The values will be ordered as follows: Hobbits,Men, Elves, Dwarves, Eagles, Wizards. The next line will contain the count ofeach race on the side of evil in the following order: Orcs, Men, Wargs, Goblins,Uruk Hai, Trolls, Wizards. All values are non-negative integers. The resultingsum of the worth for each side will not exceed the limit of a 32-bit integer. Output For each battle, print “Battle” followed by a singlespace, followed by the battle number starting at 1, followed by a “:”, followedby a single space. Then print “Good triumphs over Evil” if good wins. Print“Evil eradicates all trace of Good” if evil wins. If there is a tie, then print“No victor on this battle field”. Sample Input 3 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 10 0 1 1 1 1 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 Sample Output Battle 1: Evileradicates all trace of Good Battle 2: Goodtriumphs over Evil Battle 3: Novictor on this battle field 这种简单题只要看懂题就能写出来，除了题面上是7个数的那个 权值 11 实际上是 10。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; int a[]= &#123;1,2,3,3,4,10&#125;,b[]= &#123;1,2,2,2,3,5,10&#125;; long long n,x; long sum1,sum2; cin&gt;&gt;n; for(int j=1; j&lt;=n; j++) &#123; sum1=sum2=0; for(int i=0; i&lt;6; i++) &#123; cin&gt;&gt;x; sum1+=x*a[i]; &#125; for(int i=0; i&lt;7; i++) &#123; cin&gt;&gt;x; sum2+=x*b[i]; &#125; printf(&quot;Battle %d: &quot;,j); if(sum1&gt;sum2) &#123; cout&lt;&lt;&quot;Good triumphs over Evil\n&quot;; &#125; else if(sum1&lt;sum2) &#123; cout&lt;&lt;&quot;Evil eradicates all trace of Good\n&quot;; &#125; else &#123; cout&lt;&lt;&quot;No victor on this battle field\n&quot;; &#125; &#125; return 0;&#125; B(2064): Magic Multiple SubmitPage Summary TimeLimit: 5 Sec MemoryLimit: 512 Mb Submitted: 28 Solved: 18 Description The Elvish races of Middle Earth believed that certainnumbers were more significant than others. When using a particular quantity nof metal to forge a particular sword, they believed that sword would be mostpowerful if the thickness k were chosen according to the following rule: Givena nonnegative integer n, what is the smallest k such that the decimalrepresentations of the integers in the sequence: n, 2n, 3n, 4n, 5n, …, kncontain all ten digits (0 through 9) at least once? Lord Elrond of Rivendell hascommissioned you with the task to develop an algorithm to find the optimalthickness (k) for any given quantity of metal (n). Input Input will consist of a single integer n per line. Theend of input will be signaled by end of file. The input integer will be between1 and 200,000,000, inclusive. Output The output will consist of a single integer per line,indicating the value of k needed such that every digit from 0 through 9 is seenat least once. Sample Input 1 10 123456789 3141592 Sample Output 10 9 3 5 一个数的1 到 K倍中 0-9全部出现过，暴力K倍就行了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int a[10];int l;void check(long long x)&#123; while(x&gt;0) &#123; if(a[x%10]==0) &#123; l++; a[x%10]=1; &#125; x/=10; &#125;&#125; int main()&#123; long long n; long sum1,sum2; while (cin&gt;&gt;n) &#123; l=0; memset(a,0,sizeof(a)); int i=1; for (; l!=10; i++) &#123; check(i*n); &#125; cout&lt;&lt;i-1&lt;&lt;endl; &#125; return 0;&#125; DescriptionSaruman’s army of orcs andother dark minions continuously mine and harvest lumber out of the landsurrounding his mighty tower for N continuous days. On day number i, Sarumaneither chooses to spend resources on mining coal and harvesting more lumber, oron raising the level (i.e., height) of his tower. He levels up his tower by oneunit only on days where the binary representation of i contains a total numberof 1’s that is an exact multiple of 3. Assume that the initial level of histower on day 0 is zero. For example, Saruman will level up his tower on day 7(binary 111), next on day 11 (binary 1011) and then day 13, day 14, day 19, andso on. Saruman would like to forecast the level of his tower after N days. Canyou write a program to help? InputThe input file will containmultiple input test cases, each on a single line. Each test case consists of apositive integer N &lt; 1016, as described above. The input ends on end offile. OutputFor each test case, outputone line: “Day N: Level = L”, where N is the input N, and L is the number oflevels after N days. Sample Input12 119 164 Sample Output1Day 2: Level = 0 1Day 19: Level = 5 1Day 64: Level = 21 这一题就是从2进制 第一个找，一个个往下找，找其中 1 的个数是3的倍数就行了。 还有一种本身就是 3的倍数要额外加一前面只是处理所有比N小的数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int l;long long gcd(long long a,long long b)&#123; return (b==0)?a:gcd(b,a%b);&#125;long long C(long long n,long long m)&#123; long long x=1,y=1; if(n-m&lt;m)m=n-m; for(int i=0; i&lt;m; i++) &#123; x*=(n-i); y*=1+i; int t=gcd(x,y); x/=t; y/=t; &#125; return x/y;&#125; int main()&#123; int a[1000]; long long n,k,sum; while (cin&gt;&gt;n) &#123; sum=0; k=n; long long l=1,t=0; while(n&gt;0) &#123; a[l++]=(n&amp;1); n&gt;&gt;=1; &#125; for(int i=l-1; i&gt;0; i--) &#123; if(a[i]) //如果当前位为1 &#123; for(int j=3; j-t&lt;=i-1;j+=3) //当前位数减1,还能找出是3的倍数个 1 if(j-t&gt;=0)sum+=C(i-1,j-t); t++; &#125; &#125; if(t&gt;0&amp;&amp;t%3==0)sum+=1; //处理本身就是3的倍数情况。 printf(&quot;Day %lld: Level = %lld\n&quot;,k,sum); &#125; return 0;&#125; H(2070): Seating Chart SubmitPage Summary TimeLimit: 10 Sec MemoryLimit: 512 Mb Submitted: 41 Solved: 15 Description Bilbo’s birthday is coming up, and Frodo and Sam are incharge of all the party planning! They have invited all the hobbits of MiddleEarth to the party, and everyone will be sitting in a single row at anextremely long dining table. However, due to poor communication, Frodo and Samhave each independently put together a seating chart for all the hobbits at thedining table. Help Frodo and Sam find out how similar their seating charts areby counting the total number of distinct pairs of hobbits who appear indifferent orders in the two charts. Input The input filewill contain multiple test cases. Each test case begins with a single linecontaining an integer N(1≤N≤100,000)N(1≤N≤100,000)indicating thenumber of hobbits. The next two lines represent Frodo’s and Sam’s seatingcharts, respectively. Each seating chart is specified as a single line of Nunique alphabetical strings; the set of strings in each line are guaranteed tobe identical. The end-of-input is denoted by a line containing the number 0. Output For each input test case, output a single integerdenoting, out of the N choose 2 distinct pairs of hobbits, how many pairsappear in different orders in Frodo’s and Sam’s seating arrangements. Sample Input 3 Frodo Sam Bilbo Sam Frodo Bilbo 5 A B C D E B A D E C 0 Sample Output 1 3 这一题就是一道求逆序数，逆序数怎么求就自己找模板吧，另外这个题超了int 要用longlong。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;map&gt;using namespace std;const int maxn=1e6+5;int a[maxn];map&lt;string,int&gt;m;long long n=0;//全局变量，用于统计逆序对数void merge(int a[],int first,int mid,intlast)&#123; int *temp = new int[last-first+1];//临时数组，用于临时存放比较后的数字 int i=first,j=mid+1,k=0; while(i&lt;=mid&amp;&amp;j&lt;=last)//遍历比较左右两个部分 &#123; if(a[i]&lt;=a[j]) temp[k++] = a[i++]; //左半部分元素小于右半部分的元素，将左边该元素存入临时数组 else &#123; temp[k++] = a[j++]; n=n+(mid-i+1);//统计左半边能和右半边该元素构成的逆序对数 &#125; &#125; while(i&lt;=mid) temp[k++]=a[i++]; while(j&lt;=last) temp[k++]=a[j++]; for(i=0; i &lt; k; i++) a[first + i] = temp[i];//从临时数组取出放回原数组&#125;void mergesort(int a[],int first,int last)&#123; if(first &lt; last) &#123; int mid = (first+last)/2; mergesort(a,first,mid);//递归排序左半部分 mergesort(a,mid+1,last);//递归排序右半部分 merge(a,first,mid,last);//将处理后的两个部分合并 &#125;&#125;int main()&#123; int N; string k; while (cin&gt;&gt;N&amp;&amp;N) &#123; m.clear(); for(int i=0;i&lt;N;i++) &#123; cin&gt;&gt;k; m[k]=i; &#125; for(int i=0;i&lt;N;i++) &#123; cin&gt;&gt;k; a[i]=m[k]; &#125; mergesort(a,0,N-1); cout&lt;&lt;n&lt;&lt;endl; n=0; &#125; return 0;&#125; J(2072): Temple Build SubmitPage Summary TimeLimit: 10 Sec MemoryLimit: 512 Mb Submitted: 8 Solved: 1 Description The Dwarves of Middle Earth are renowned for theirdelving and smithy ability, but they are also master builders. During the timeof the dragons, the dwarves found that above ground the buildings that weremost resistant to attack were truncated square pyramids (a square pyramid thatdoes not go all the way up to a point, but instead has a flat square on top).The dwarves knew what the ideal building shape should be based on the heightthey wanted and the size of the square base at the top and bottom. Theytypically had three different sizes of cubic bricks with which to work. Theirgoal was to maximize the volume of such a building based on the followingrules: The building is constructed of layers; each layer is asingle square of bricks of a single size. No part of any brick may extend outfrom the ideal shape, either to the sides or at the top. The resultingstructure will have jagged sides and may be shorter than the ideal shape, butit must fit completely within the ideal design. The picture at the right is avertical cross section of one such tower. There is no limit on how many bricksof each type can be used. Input Each line of input will contain six entries, eachseparated by a single space. The entries represent the ideal temple height, thesize of the square base at the bottom, the size of the square base at the top(all three as non-negative integers less than or equal to one million), thenthree sizes of cubic bricks (all three as non-negative integers less than orequal to ten thousand). Input is terminated upon reaching end of file. Output For each line of input, output the maximum possiblevolume based on the given rules, one output per line. Sample Input 500000 800000300000 6931 11315 5000 Sample Output 160293750000000000 这一题就是一个，dp，dp[0]=0.dp[i]=max(dp[i-a[j]]+V[a[j]])(0&lt;=j&lt;3); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt; using namespace std;const int maxn=1e7+5;long long dp[maxn];int main()&#123; long long h,d,t,a[3],ans; while(cin&gt;&gt;h&gt;&gt;d&gt;&gt;t&gt;&gt;a[0]&gt;&gt;a[1]&gt;&gt;a[2]) &#123; ans=0; memset(dp,-1,sizeof(dp)); dp[0]=0; for(int i=0;i&lt;=h;i++) &#123; if(dp[i]!=-1) &#123; for(int j=0;j&lt;3;j++) &#123; if(i+a[j]&lt;=h) &#123; doubleb=1.0*d-1.0*(i+a[j])/h*(d-t); int cnt=floor(b/a[j]); long longv=cnt*cnt*pow(a[j],3); if(dp[i+a[j]]==-1)dp[i+a[j]]=dp[i]+v; elsedp[i+a[j]]=max(dp[i+a[j]],dp[i]+v); // 我是从一个状态跳所有它可以跳到的状态。 ans=max(ans,dp[i+a[j]]); &#125; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; L(2074): Tongues SubmitPage Summary TimeLimit: 5 Sec MemoryLimit: 512 Mb Submitted: 44 Solved: 18 Description Gandalf’s writings have long been available for study,but no one has yet figured out what language they are written in. Recently, dueto programming work by a hacker known only by the code name ROT13, it has beendiscovered that Gandalf used nothing but a simple letter substitution scheme,and further, that it is its own inverse—the same operation scrambles themessage as unscrambles it. This operation is performed by replacing vowels inthe sequence (a i y e o u) with the vowel three advanced, cyclicly, whilepreserving case (i.e., lower or upper). Similarly, consonants are replaced fromthe sequence (b k x z n h d c w g p v j q t s r l m f) by advancing tenletters. So for instance the phrase One ring to rule them all. translates toIta dotf ni dyca nsaw ecc. The fascinating thing about this transformation isthat the resulting language yields pronounceable words. For this problem, youwill write code to translate Gandalf’s manuscripts into plain text. Input The input file will contain multiple test cases. Eachtest case consists of a single line containing up to 100 characters,representing some text written by Gandalf. All characters will be plain ASCII,in the range space (32) to tilde (126), plus a newline terminating each line.The end of the input is denoted by the end-of-file. Output For each input test case, print its translation intoplaintext. The output should contain exactly the same number of lines andcharacters as the input. Sample Input Ita dotf ni dycansaw ecc. Sample Output One ring to rulethem all. 字符串替换，XJB暴力就行,就是耗神。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt; using namespace std;const int maxn=1e2+5;char s[maxn];int main()&#123;//b k x z n h d c w g //p v j q t s r l m f char c1[]=&#123;&quot;bkxznhdcwg&quot;&#125;; char c2[]=&#123;&quot;pvjqtsrlmf&quot;&#125;; char a[500]=&#123;0&#125;; for(int i=0;i&lt;strlen(c1);i++) &#123; a[c1[i]]=c2[i]; a[c1[i]-(&apos;a&apos;-&apos;A&apos;)]=c2[i]-(&apos;a&apos;-&apos;A&apos;); &#125; for(int i=0;i&lt;strlen(c1);i++) &#123; a[c2[i]]=c1[i]; a[c2[i]-(&apos;a&apos;-&apos;A&apos;)]=c1[i]-(&apos;a&apos;-&apos;A&apos;); &#125; strcpy(c1,&quot;aiy&quot;); strcpy(c2,&quot;eou&quot;); for(int i=0;i&lt;strlen(c1);i++) &#123; a[c1[i]]=c2[i]; a[c1[i]-(&apos;a&apos;-&apos;A&apos;)]=c2[i]-(&apos;a&apos;-&apos;A&apos;); &#125; for(int i=0;i&lt;strlen(c1);i++) &#123; a[c2[i]]=c1[i]; a[c2[i]-(&apos;a&apos;-&apos;A&apos;)]=c1[i]-(&apos;a&apos;-&apos;A&apos;); &#125; while(~scanf(&quot;%c&quot;,&amp;s[0])) &#123; int i=0; while(s[i++]!=&apos;\n&apos;) &#123; scanf(&quot;%c&quot;,&amp;s[i]); &#125; i=0; do &#123; if(a[s[i]]==0) &#123; printf(&quot;%c&quot;,s[i]); &#125; else printf(&quot;%c&quot;,a[s[i]]); &#125;while(s[i++]!=&apos;\n&apos;); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心]]></title>
    <url>%2F2018%2F03%2F17%2F%E8%B4%AA%E5%BF%83%2F</url>
    <content type="text"><![CDATA[Problem B: 洗衣 Time Limit: 2 Sec Memory Limit: 128 MBSubmit: 148 Solved: 26 [Submit][Status][Web Board] Description durong有N件衣服要洗， 但是他的第i件衣服必须在[st, en) 时间洗， 同一洗衣机不能同时洗多件衣服，他想，要洗完N件衣服，至少需要多少个洗衣机呢？ Input 多组输入 第一行一个整数n（n &lt;= 100000）, 代表衣服的个数 接下来n行, 每行两个整数st, en（1 &lt;= st &lt; en &lt;= 1000000000），代表第i件衣服在st开始洗，en洗完 Output 输出一个整数和换行符，代表至少需要的洗衣机个数 Sample Input1234 31 23 42 8 Sample Output12 贪心，先排序，然后到一个时间点能加就加，如果过了一个减去一个就行了，每次跳跃一件衣服的时间长度就行了，复杂度只有排序的复杂度NlogN #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;queue&gt; using namespace std; const int maxn=1e5+10; int n; int main() { ` int`st[maxn],en[maxn],sz,ez,ans,cou; ` while`( scanf ( &quot;%d&quot; ,&amp;n)!=EOF) ` {` ` for`( int i=0;i&lt;n;i++){ ` scanf`( &quot;%d%d&quot; ,&amp;st[i],&amp;en[i]); ` }` ` sort(st,st+n);` ` sort(en,en+n);` ` ans=cou=ez=0;` ` for`( int i=0;i&lt;n;i++) ` {` ` cou++;` ` while`(en[ez]&lt;=st[i]) ` {` ` ez++;` ` cou—;` ` }` ` if`(cou&gt;ans)ans=cou; ` }` ` printf`( &quot;%d\n&quot; ,ans); ` }` ` return`0; }]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大生成树]]></title>
    <url>%2F2018%2F03%2F17%2F%E6%9C%80%E5%A4%A7%E7%94%9F%E6%88%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Problem A: 灾区重建Time Limit: 3 Sec Memory Limit: 128 MBSubmit: 123 Solved: 32[Submit][Status][Web Board] Description在一场地震之后，原本美丽的C国变成了一片废墟，但是这并没有击垮人们的意志，在各方的支持下救援队马上开始了灾区重建。已知C国一共由N个城市（编号从1~N）组成，在这N个城市之间有M条道路连通着各个城市，现在要将物资运往各个城市，但是每条道路都有其最大承重量W，也就是说如果一辆车所运载的货物重量大于W的话是无法通过这条路的。为了防止道路崩塌同时提高效率，我们都会去走承重量尽可能大的道路，现在救援队的队长想知道如果要将货物从任意一个城市运往其他N-1个城市，一次所能运输的最大重量是多少，你能告诉他吗？ Input输入第一行为一个整数T(T&lt;=10），表示有T组样例； 第二行为两个整数N(N&lt;=10^5)和M(M&lt;=10^6)，分别表示城市的数量和道路的数量； 接下来M行每行有三个整数,u,v,w，（u,v&lt;=N，w&lt;=10^9） 表示u和v之间有一条承重量为w的道路（道路是双向的，即可以从u走到v，也可以从v走到u，同时数据保证任意两个城市之间至多只会有一条道路）。 Output每组样例输出一行 Case #X: Y，X表示第几组样例，Y便是所要求的答案。 Sample Input11 4 6 1 2 2 1 3 1 1 4 9 2 4 8 2 3 10 3 4 4 Sample Output1Case #1: 8 HINT样例解释： 如果要将物资从1运输到2，那么走1-4-2这条路径所即能运输的最大重量为8； 如果要将物资从1运输到3，那么走1-4-2-3这条路径即所能运输的最大重量为8； 如果要将物资从1运输到4，那么走1-4这条路径即所能运输的最大重量为9； 如果要将物资从2运输到3，那么走2-3这条路径即所能运输的最大重量为10； 如果要将物资从2运输到4，那么走2-4这条路径即所能运输的最大重量为8； 如果要将物资从3运输到4，那么走3-2-4这条路径即所能运输的最大重量为8； 故答案为8。 很裸的一道最大生成树，求最大生成树的最大权边，注意跳出就不会超时。 #include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;int t,n,m,i,j;using namespace std; struct s{` int`a,b,c;}k[1000005]; const int maxn=1000005; bool bmp(s a, s b){` return`a.c&gt;b.c;} int par[maxn];void init(){` for`( int i=0;i&lt;=n;i++){` par[i]=i;` }}int find( int x){` if`(par[x]==x) return x;` else`{` return`par[x]=find(par[x]);` }`}void unite( int x, int y){` x=find(x);` y=find(y);` if`(x==y) return ;` else`{` par[y]=x;` }} int main(){` scanf`( &quot;%d&quot; ,&amp;t);` for`(i=0;i&lt;t;i++)` {` scanf ( &quot;%d%d&quot; ,&amp;n,&amp;m);` init();` for (j=0;j&lt;m;j++)` scanf`( &quot;%d%d%d&quot; ,&amp;k[j].a,&amp;k[j].b,&amp;k[j].c);` sort(k,k+m,bmp);` int res=0,l=0;` for`(j=0;j&lt;m;j++)` {` if (find(k[j].a)!=find(k[j].b))` {` unite(k[j].a,k[j].b);` res=k[j].c;` if (++l==n-1) break ;` }` if (l==n-1) break ;` }` printf ( &quot;Case #%d: %d\n&quot; ,i+1,res);` }` return 0;}]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
</search>

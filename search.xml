<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[FWTå¿«é€Ÿæ²ƒå°”ä»€å˜æ¢-ç®€è§£åŠè¯æ˜]]></title>
    <url>%2F2019%2F09%2F09%2FFWT%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2-%E7%AE%80%E8%A7%A3%E5%8F%8A%E8%AF%81%E6%98%8E%2F</url>
    <content type="text"><![CDATA[FWTç®€ä»‹FWT ç”¨æ¥æ±‚å·ç§¯ï¼Œå’ŒFFTå¾ˆåƒ.ä¸‰ä¸ªå…¬å¼ C_k=\sum_{i|j=k}A_i * B_j C_k=\sum_{i\&j=k}A_i * B_j C_k=\sum_{i\ xor\ j=k}A_i * B_jä¸‰ç§å·ç§¯ï¼Œå¯¹äºä¸‰ç§åªè¯¦è§£å…¶ä¸­ä¸€ç§ã€‚ 1.æˆ–(or)å·ç§¯æ ¹æ®å¯¹FTTçš„ç†è§£ï¼Œé¦–å…ˆç¬¬ä¸€æ­¥è½¬æ¢æˆç‚¹å€¼ï¼Œå¯¹$C_k=\sum_{i\ +\ j=k}A_i B_j$æ¥è¯´ï¼Œå°±æœ‰ç‚¹å€¼ç›¸åŒç›¸ä¹˜$y_c=y_a y_b$ y è¡¨ç¤ºåœ¨å–æŸä¸ªå€¼çš„æ—¶å€™å¤šé¡¹å¼çš„å–å€¼ã€‚ å¯¹äºä¸Šè¿°è¿™ä¸ªå·ç§¯æ˜æ˜¾ä¸åˆé€‚ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦æ„é€ ä¸€ä¸ªæ–°çš„å¼å­$FWT$æ»¡è¶³$FWT(C)=FWT(A) FWT(B)$ã€‚æ»¡è¶³æˆ–(or)å·ç§¯çš„å¼å­å°±æ˜¯$FWT(A)[i]=\sum_{j|i=i}A[j]$,å¦‚ä½•æ¥çš„å°±ä¸çŸ¥é“äº†ï¼Œä½†æ˜¯å¯ä»¥è¯æ˜è¿™ä¸ªæ˜¯å¯¹çš„ã€‚å°±ç›¸å½“äº$FWT(A|B)=FWT(A) FWT(B)$,å¯¹äºå…¬å¼è¯æ˜ï¼Œè¿˜ä¸æ¸…æ¥šï¼Œä½†æ˜¯æš´åŠ›æ‰“ä¸ªè¡¨ï¼Œç”¨æ•°å­¦å½’çº³æ³•è¯æ˜è§å¤§ä½¬åšå®¢ï¼Œå€’æ˜¯æ²¡æœ‰é”™. \sum_{i|k=k}C_i=\sum_{i|j=k}(\sum_{t|i=i}A_t*\sum_{p|j=j}B_p) \sum_{i|k=k}(\sum_{o|l=i}A_o * B_l)=\sum_{i|j=k}((\sum_{t|i=i}A_t) * (\sum_{p|j=j}B_p))ä¸Šå¼ä¸éš¾çœ‹å‡ºæ˜¯ç›¸åŒçš„,å¯ä»¥ç®€å•ç†è§£ä¸‹ï¼Œå³è¾¹æ‹†å¼€é‡Œé¢çš„$A_t * B_p$è‚¯å®šéƒ½æ˜¯åœ¨å·¦è¾¹çš„å­é›†å†…ã€‚ çŸ¥é“ä¸Šè¿°æ»¡è¶³äº†ï¼Œå°±ç®€å•äº†ã€‚å¯¹äºFFTå…ˆå˜æˆç‚¹é›†,ç„¶åé€†å˜æ¢å›æ¥ï¼Œä¸Šè¿°åŒFFTï¼Œå…ˆå˜æˆ$FWT$,ç„¶åé€†å˜æ¢å›æ¥ã€‚é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œæ±‚$FWT$,ä¸ä¹Ÿæ˜¯$O(n^2)$,è¿™ä¸ªæ—¶å€™å°±æ˜¯FWTçš„æ ¸å¿ƒäº†ã€‚å¯¹äºæˆ–å·ç§¯çš„$FWT$æœ‰å¦‚ä¸‹å¼å­ FWT(A) = \begin{cases} FWT(A_0,A_1+A_0) & [A]>1\\ A, & [A]=1 \end{cases}$A_0$ä¸ºå‰åŠæ®µï¼Œ$A_1$ä¸ºååŠæ®µã€‚è¿™ä¸ªå¾ˆå®¹æ˜“è¯æ˜ï¼Œå°±å‡è®¾æœ‰4é¡¹$\{a_0,a_1,a_2,a_3\}$,ç„¶åä½¿ç”¨åˆ†æ²»å¤„ç†ç¬¬ä¸€æ¬¡ï¼Œå¯ä»¥å¾—åˆ°$\{a_0,a_0+a_1,a_2,a_2+a_3\}$ï¼Œç„¶åç¬¬äºŒæ¬¡å°±æ˜¯$\{a_0,a_0+a_1,a_0+a_2,a_0+a_1+a_2+a_3\}$ï¼Œ$A$æ±‚å®Œäº†ï¼Œä¸¾äº†è¿™ä¸ªæ —å­åº”è¯¥å°±æ˜ç™½äº†ï¼Œè¿™ä¸ª$A$çš„é•¿åº¦è¦æ˜¯$2^k$,è¿™ä¸ªå¾ˆå®¹æ˜“è§£å†³ï¼Œä¸è¶³çš„åœ°æ–¹è¡¥0å°±è¡Œäº†ã€‚é€†å˜æ¢å°±æ˜¯æŠŠ+å˜æˆ-å°±å¥½äº†ã€‚ 2.å’Œ(and)å·ç§¯è¿™äº›éƒ½ç®€å•è¿‡ä¸€ä¸‹$FWT$å¼å­ä¸º$FWT(A)[i]=\sum_{j\&amp;i=i}A[j]$æœ‰å¦‚ä¸‹å¼å­ FWT(A)=\begin{cases}(FWT(A_0+A_1),FWT(A_1)) & [A]\gt1 \\ A & [A]=1\end{cases}3.å¼‚æˆ–(xor)å·ç§¯$FWT$å¼å­ä¸º$FWT(A)[i]=\sum_{j\ xor\ i=i}A[j]$ FWT(A)=\begin{cases}(FWT(A_0)+FWT(A_1),FWT(A_0)-FWT(A_1)) & n>1\\A & [A]=1\end{cases}å¯¹äºè¿™ä¸ªçš„é€†å˜æ¢æœ‰ç‚¹å·®åˆ« IFWT(A)=(\frac{IFWT(A_0)+IFWT(A_1)}{2},\frac{IFWT(A_0)-IFWT(A_1)}{2})ä¸ç”¨å˜ç¬¦å·ç›´æ¥é™¤2å°±è¡Œäº†ã€‚]]></content>
      <categories>
        <category>ACM</category>
        <category>æ•°è®º</category>
      </categories>
      <tags>
        <tag>FFT/NTT/FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ ‘é“¾å‰–åˆ†åŸç†å’Œå®ç°]]></title>
    <url>%2F2019%2F08%2F24%2F%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[è½¬è‡ªå¤§ä½¬: bananananaå¦ä¸€ä½å¤§ä½¬:ivanovcraft æ ‘é“¾å‰–åˆ†åŸç†å’Œå®ç°æ ‘é“¾å‰–åˆ†å°±æ˜¯å°†æ ‘åˆ†å‰²æˆå¤šæ¡é“¾ï¼Œç„¶ååˆ©ç”¨æ•°æ®ç»“æ„ï¼ˆçº¿æ®µæ ‘ã€æ ‘çŠ¶æ•°ç»„ç­‰ï¼‰æ¥ç»´æŠ¤è¿™äº›é“¾ã€‚ é¦–å…ˆå°±æ˜¯ä¸€äº›å¿…é¡»çŸ¥é“çš„æ¦‚å¿µï¼šé‡ç»“ç‚¹ï¼šå­æ ‘ç»“ç‚¹æ•°ç›®æœ€å¤šçš„ç»“ç‚¹ï¼›è½»èŠ‚ç‚¹ï¼šçˆ¶äº²èŠ‚ç‚¹ä¸­é™¤äº†é‡ç»“ç‚¹ä»¥å¤–çš„ç»“ç‚¹ï¼›é‡è¾¹ï¼šçˆ¶äº²ç»“ç‚¹å’Œé‡ç»“ç‚¹è¿æˆçš„è¾¹ï¼›è½»è¾¹ï¼šçˆ¶äº²èŠ‚ç‚¹å’Œè½»èŠ‚ç‚¹è¿æˆçš„è¾¹ï¼›é‡é“¾ï¼šç”±å¤šæ¡é‡è¾¹è¿æ¥è€Œæˆçš„è·¯å¾„ï¼›è½»é“¾ï¼šç”±å¤šæ¡è½»è¾¹è¿æ¥è€Œæˆçš„è·¯å¾„ï¼›æ ‘é“¾å‰–åˆ† æ¯”å¦‚ä¸Šé¢è¿™å¹…å›¾ä¸­ï¼Œç”¨é»‘çº¿è¿æ¥çš„ç»“ç‚¹éƒ½æ˜¯é‡ç»“ç‚¹ï¼Œå…¶ä½™å‡æ˜¯è½»ç»“ç‚¹ï¼Œ2-11å°±æ˜¯é‡é“¾ï¼Œ2-5å°±æ˜¯è½»é“¾ï¼Œç”¨çº¢ç‚¹æ ‡è®°çš„å°±æ˜¯è¯¥ç»“ç‚¹æ‰€åœ¨é“¾çš„èµ·ç‚¹ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬ğŸ‘‡æåˆ°çš„topç»“ç‚¹ï¼Œè¿˜æœ‰æ¯æ¡è¾¹çš„å€¼å…¶å®æ˜¯è¿›è¡Œdfsæ—¶çš„æ‰§è¡Œåºå·ã€‚ ç®—æ³•ä¸­å®šä¹‰äº†ä»¥ä¸‹çš„æ•°ç»„ç”¨æ¥å­˜å‚¨ä¸Šè¾¹æåˆ°çš„æ¦‚å¿µï¼š12345678åç§° è§£é‡Šsiz[u] ä¿å­˜ä»¥uä¸ºæ ¹çš„å­æ ‘èŠ‚ç‚¹ä¸ªæ•°top[u] ä¿å­˜å½“å‰èŠ‚ç‚¹æ‰€åœ¨é“¾çš„é¡¶ç«¯èŠ‚ç‚¹son[u] ä¿å­˜é‡å„¿å­dep[u] ä¿å­˜ç»“ç‚¹uçš„æ·±åº¦å€¼faz[u] ä¿å­˜ç»“ç‚¹uçš„çˆ¶äº²èŠ‚ç‚¹tid[u] ä¿å­˜æ ‘ä¸­æ¯ä¸ªèŠ‚ç‚¹å‰–åˆ†ä»¥åçš„æ–°ç¼–å·ï¼ˆDFSçš„æ‰§è¡Œé¡ºåºï¼‰rnk[u] ä¿å­˜å½“å‰èŠ‚ç‚¹åœ¨æ ‘ä¸­çš„ä½ç½® é™¤æ­¤ä¹‹å¤–ï¼Œè¿˜åŒ…æ‹¬ä¸¤ç§æ€§è´¨ï¼šå¦‚æœ(u, v)æ˜¯ä¸€æ¡è½»è¾¹ï¼Œé‚£ä¹ˆsize(v) &lt; size(u)/2ï¼›ä»æ ¹ç»“ç‚¹åˆ°ä»»æ„ç»“ç‚¹çš„è·¯æ‰€ç»è¿‡çš„è½»é‡é“¾çš„ä¸ªæ•°å¿…å®šéƒ½å°ä¸O(logn)ï¼›é¦–å…ˆå®šä¹‰ä»¥ä¸‹æ•°ç»„ï¼š123456789const int MAXN = (100000 &lt;&lt; 2) + 10;//Heavy-light Decomposition STARTS FORM HEREint siz[MAXN];//number of sonint top[MAXN];//top of the heavy linkint son[MAXN];//heavy son of the nodeint dep[MAXN];//depth of the nodeint faz[MAXN];//father of the nodeint tid[MAXN];//ID -&gt; DFSIDint rnk[MAXN];//DFSID -&gt; ID ç®—æ³•å¤§è‡´éœ€è¦è¿›è¡Œä¸¤æ¬¡çš„DFSï¼Œç¬¬ä¸€æ¬¡DFSå¯ä»¥å¾—åˆ°å½“å‰èŠ‚ç‚¹çš„çˆ¶äº²ç»“ç‚¹ï¼ˆfazæ•°ç»„ï¼‰ã€å½“å‰ç»“ç‚¹çš„æ·±åº¦å€¼ï¼ˆdepæ•°ç»„ï¼‰ã€å½“å‰ç»“ç‚¹çš„å­ç»“ç‚¹æ•°é‡ï¼ˆsizeæ•°ç»„ï¼‰ã€å½“å‰ç»“ç‚¹çš„é‡ç»“ç‚¹ï¼ˆsonæ•°ç»„ï¼‰12345678910111213141516171819202122232425void dfs1(int u, int father, int depth) &#123; /* * u: å½“å‰ç»“ç‚¹ * father: çˆ¶äº²ç»“ç‚¹ * depth: æ·±åº¦ */ // æ›´æ–°depã€fazã€sizæ•°ç»„ dep[u] = depth; faz[u] = father; siz[u] = 1; // éå†æ‰€æœ‰å’Œå½“å‰ç»“ç‚¹è¿æ¥çš„ç»“ç‚¹ for (int i = head[u]; i; i = edg[i].next) &#123; int v = edg[i].to; // å¦‚æœè¿æ¥çš„ç»“ç‚¹æ˜¯å½“å‰ç»“ç‚¹çš„çˆ¶äº²ç»“ç‚¹ï¼Œåˆ™ä¸å¤„ç† if (v != faz[u]) &#123; dfs1(v, u, depth + 1); // æ”¶æ•›çš„æ—¶å€™å°†å½“å‰ç»“ç‚¹çš„sizåŠ ä¸Šå­ç»“ç‚¹çš„siz siz[u] += siz[v]; // å¦‚æœæ²¡æœ‰è®¾ç½®è¿‡é‡ç»“ç‚¹sonæˆ–è€…å­ç»“ç‚¹vçš„sizå¤§äºä¹‹å‰è®°å½•çš„é‡ç»“ç‚¹sonï¼Œåˆ™è¿›è¡Œæ›´æ–° if (son[u] == -1 || siz[v] &gt; siz[son[u]]) &#123; son[u] = v; &#125; &#125; &#125;&#125; ç¬¬äºŒæ¬¡DFSçš„æ—¶å€™åˆ™å¯ä»¥å°†å„ä¸ªé‡ç»“ç‚¹è¿æ¥æˆé‡é“¾ï¼Œè½»èŠ‚ç‚¹è¿æ¥æˆè½»é“¾ï¼Œå¹¶ä¸”å°†é‡é“¾ï¼ˆå…¶å®å°±æ˜¯ä¸€æ®µåŒºé—´ï¼‰ç”¨æ•°æ®ç»“æ„ï¼ˆä¸€èˆ¬æ˜¯æ ‘çŠ¶æ•°ç»„æˆ–çº¿æ®µæ ‘ï¼‰æ¥è¿›è¡Œç»´æŠ¤ï¼Œå¹¶ä¸”ä¸ºæ¯ä¸ªèŠ‚ç‚¹è¿›è¡Œç¼–å·ï¼Œå…¶å®å°±æ˜¯DFSåœ¨æ‰§è¡Œæ—¶çš„é¡ºåºï¼ˆtidæ•°ç»„ï¼‰ï¼Œä»¥åŠå½“å‰èŠ‚ç‚¹æ‰€åœ¨é“¾çš„èµ·ç‚¹ï¼ˆtopæ•°ç»„ï¼‰ï¼Œè¿˜æœ‰å½“å‰èŠ‚ç‚¹åœ¨æ ‘ä¸­çš„ä½ç½®ï¼ˆrankæ•°ç»„ï¼‰ã€‚123456789101112131415161718192021222324void dfs2(int u, int t) &#123; /** * uï¼šå½“å‰ç»“ç‚¹ * tï¼šèµ·å§‹çš„é‡ç»“ç‚¹ */ top[u] = t; // è®¾ç½®å½“å‰ç»“ç‚¹çš„èµ·ç‚¹ä¸ºt tid[u] = cnt; // è®¾ç½®å½“å‰ç»“ç‚¹çš„dfsæ‰§è¡Œåºå· rnk[cnt] = u; // è®¾ç½®dfsåºå·å¯¹åº”æˆå½“å‰ç»“ç‚¹ cnt++; // å¦‚æœå½“å‰ç»“ç‚¹æ²¡æœ‰å¤„åœ¨é‡é“¾ä¸Šï¼Œåˆ™ä¸å¤„ç† if (son[u] == -1) &#123; return; &#125; // å°†è¿™æ¡é‡é“¾ä¸Šçš„æ‰€æœ‰çš„ç»“ç‚¹éƒ½è®¾ç½®æˆèµ·å§‹çš„é‡ç»“ç‚¹ dfs2(son[u], t); // éå†æ‰€æœ‰å’Œå½“å‰ç»“ç‚¹è¿æ¥çš„ç»“ç‚¹ for (int i = head[u]; i; i = edg[i].next) &#123; int v = edg[i].to; // å¦‚æœè¿æ¥ç»“ç‚¹ä¸æ˜¯å½“å‰ç»“ç‚¹çš„é‡å­ç»“ç‚¹å¹¶ä¸”ä¹Ÿä¸æ˜¯uçš„çˆ¶äº²ç»“ç‚¹ï¼Œåˆ™å°†å…¶çš„topè®¾ç½®æˆè‡ªå·±ï¼Œè¿›ä¸€æ­¥é€’å½’ if (v != son[u] &amp;&amp; v != faz[u])&#123; dfs2(v, v); &#125; &#125;&#125; è€Œä¿®æ”¹å’ŒæŸ¥è¯¢æ“ä½œåŸç†æ˜¯ç±»ä¼¼çš„ï¼Œä»¥æŸ¥è¯¢æ“ä½œä¸ºä¾‹ï¼Œå…¶å®å°±æ˜¯ä¸ªLCAï¼Œä¸è¿‡è¿™é‡Œä½¿ç”¨äº†topæ¥è¿›è¡ŒåŠ é€Ÿï¼Œå› ä¸ºtopå¯ä»¥ç›´æ¥è·³è½¬åˆ°è¯¥é‡é“¾çš„èµ·å§‹ç»“ç‚¹ï¼Œè½»é“¾æ²¡æœ‰èµ·å§‹ç»“ç‚¹ä¹‹è¯´ï¼Œä»–ä»¬çš„topå°±æ˜¯è‡ªå·±ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæ¯æ¬¡å¾ªç¯åªèƒ½è·³ä¸€æ¬¡ï¼Œå¹¶ä¸”è®©ç»“ç‚¹æ·±çš„é‚£ä¸ªæ¥è·³åˆ°topçš„ä½ç½®ï¼Œé¿å…ä¸¤ä¸ªä¸€èµ·è·³ä»è€Œæ’è‚©è€Œè¿‡ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657INT64 query_path(int x, int y) &#123; /** * xï¼šç»“ç‚¹x * yï¼šç»“ç‚¹y * æŸ¥è¯¢ç»“ç‚¹xåˆ°ç»“ç‚¹yçš„è·¯å¾„å’Œ */ INT64 ans = 0; int fx = top[x], fy = top[y]; // ç›´åˆ°xå’Œyä¸¤ä¸ªç»“ç‚¹æ‰€åœ¨é“¾çš„èµ·å§‹ç»“ç‚¹ç›¸ç­‰æ‰è¡¨æ˜æ‰¾åˆ°äº†LCA while (fx != fy) &#123; if (dep[fx] &gt;= dep[fy]) &#123; // å·²ç»è®¡ç®—äº†ä»xåˆ°å…¶é“¾ä¸­èµ·å§‹ç»“ç‚¹çš„è·¯å¾„å’Œ ans += query(1, tid[fx], tid[x]); // å°†xè®¾ç½®æˆèµ·å§‹ç»“ç‚¹çš„çˆ¶äº²ç»“ç‚¹ï¼Œèµ°è½»è¾¹ï¼Œç»§ç»­å¾ªç¯ x = faz[fx]; &#125; else &#123; ans += query(1, tid[fy], tid[y]); y = faz[fy]; &#125; fx = top[x], fy = top[y]; &#125; // å³ä¾¿æ‰¾åˆ°äº†LCAï¼Œä½†æ˜¯å‰é¢ä¹Ÿåªæ˜¯åˆ†åˆ«è®¡ç®—äº†ä»ä¸€å¼€å§‹åˆ°æœ€ç»ˆåœæ­¢çš„ä½ç½®å’Œè·¯å¾„å’Œ // å¦‚æœä¸¤ä¸ªç»“ç‚¹ä¸ä¸€æ ·ï¼Œè¡¨æ˜ä»ç„¶éœ€è¦è®¡ç®—ä¸¤ä¸ªç»“ç‚¹åˆ°LCAçš„è·¯å¾„å’Œ if (x != y) &#123; if (tid[x] &lt; tid[y]) &#123; ans += query(1, tid[x], tid[y]); &#125; else &#123; ans += query(1, tid[y], tid[x]); &#125; &#125; else ans += query(1, tid[x], tid[y]); return ans;&#125;void update_path(int x, int y, int z) &#123; /** * xï¼šç»“ç‚¹x * yï¼šç»“ç‚¹y * zï¼šéœ€è¦åŠ ä¸Šçš„å€¼ * æ›´æ–°ç»“ç‚¹xåˆ°ç»“ç‚¹yçš„å€¼ */ int fx = top[x], fy = top[y]; while(fx != fy) &#123; if (dep[fx] &gt; dep[fy]) &#123; update(1, tid[fx],tid[x], z); x = faz[fx]; &#125; else &#123; update(1, tid[fy], tid[y], z); y = faz[fy]; &#125; fx = top[x], fy = top[y]; &#125; if (x != y) if (tid[x] &lt; tid[y]) update(1, tid[x], tid[y], z); else update(1, tid[y], tid[x], z); else update(1, tid[x], tid[y], z);&#125; ä¸ªäººå†™æ³•123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172int n, m, r, rt, mod, v[maxn], head[maxn], cnt, fa[maxn], size[maxn], d[maxn], son[maxn], top[maxn], id[maxn], rk[maxn];//fa çˆ¶äº²èŠ‚ç‚¹ size å¤§å° d æ·±åº¦ son é‡å„¿å­ ï¼Œ top é“¾é¡¶ç«¯ id dfsåº rk dfsåºå¯¹åº”çš„èŠ‚ç‚¹vector&lt;int&gt; G[maxn];void add(int x, int y) &#123; G[x].emplace_back(y);&#125;void dfs1(int x) &#123; size[x] = 1; d[x] = d[fa[x]] + 1; for (auto u:G[x]) &#123; if (u != fa[x]) &#123; fa[u] = x; dfs1(u); size[x] += size[u]; if (size[son[x]] &lt; size[u]) &#123; son[x] = u; &#125; &#125; &#125;&#125;void dfs2(int x, int tp) &#123; top[x] = tp; id[x] = ++cnt; rk[cnt] = x; if (son[x]) &#123; dfs2(son[x], tp); &#125; for (auto u:G[x]) &#123; if (u != fa[x] &amp;&amp; u != son[x]) &#123; dfs2(u, u); &#125; &#125;&#125;inline int sum(int x, int y) &#123; int res = 0; while (top[x] != top[y]) &#123; if (d[top[x]] &lt; d[top[y]]) &#123; swap(x, y); &#125; //TODO res = (res + query(id[top[x]], id[x], rt)) % mod; x = fa[top[x]]; &#125; if (id[x] &gt; id[y]) &#123; swap(x, y); &#125; // TODO res = (res + query(id[x], id[y], rt)) % mod; return res;&#125;inline void updates(int x, int y, int c) &#123; while (top[x] != top[y]) &#123; if (d[top[x]] &lt; d[top[y]]) &#123; swap(x, y); &#125; //TODO update(id[top[x]], id[x], c, rt); x = fa[top[x]]; &#125; if (id[x] &gt; id[y]) &#123; swap(x, y); &#125; // TODO update(id[x], id[y], c, rt);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>æ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>æ ‘é“¾å‰–åˆ†</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥(ç¬¬ååœº) J Wood Processing]]></title>
    <url>%2F2019%2F08%2F23%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E5%8D%81%E5%9C%BA%EF%BC%89J%20Wood%20Processing%2F</url>
    <content type="text"><![CDATA[é¢˜æ„: $n$å¿«æœ¨æ¿ï¼Œåˆæˆ$k$å—æœ¨æ¿ã€‚ç›¸åŒé«˜åº¦å¯ä»¥åˆå¹¶ï¼Œä¸åŒé«˜åº¦ï¼Œéœ€è¦æŠŠé«˜çš„æœ¨æ¿ç æˆå’Œä½çš„æœ¨æ¿ä¸€æ ·é«˜ã€‚é—®åˆæˆ$k$å—æœ€å°‘æµªè´¹å¤šå¤§æœ¨æ¿é¢ç§¯ã€‚é¢˜è§£: dp[i][j] è¡¨ç¤ºå‰jä¸ªåˆæˆiä¸ªæœ¨æ¿æœ€å°èŠ±è´¹é¢ç§¯ã€‚è½¬ç§»æ–¹ç¨‹ä¸º dp[i][j]=min(dp[i-1][k]+sum[j]-sum[k]+h[k+1] * (w[j]-w[k]),dp[i][j])å…¶ä¸­$w$è¡¨ç¤ºè¡¨ç¤ºå®½åº¦å‰ç¼€å’Œï¼Œ$sum$è¡¨ç¤ºé¢ç§¯å‰ç¼€å’Œï¼Œè½¬ç§»çš„è´¡çŒ®å°±æ˜¯ï¼Œ å‡è®¾ä»$k$è½¬ç§»ä¼˜äº$l$ï¼Œæœ‰å¦‚ä¸‹: dp[i-1][k]+sum[j]-sum[k]-h[k+1] * (w[j]-[k])=dp[i-1][l]+sum[j]-sum[l]+h[l+1] * (w[j]-w[l])åˆå¹¶åŒç±»é¡¹åŒ–ç®€ï¼Œ \frac{(dp[i-1][k]-sum[k]+h[k+1] * w[k])-(dp[i-1][l]-sum[l]+h[l+1] * w[l])}{w[k]-w[l]}]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>æ–œç‡ä¼˜åŒ–DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ–œç‡ä¼˜åŒ–DP]]></title>
    <url>%2F2019%2F08%2F23%2F%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96DP%2F</url>
    <content type="text"><![CDATA[ä»€ä¹ˆæ˜¯æ–œç‡ä¼˜åŒ–DPï¼Ÿé¡¾åæ€ä¹‰ï¼Œç”¨æ–œç‡ä¼˜åŒ–çš„DPã€‚æ¨èä¸€æ³¢åšå®¢è¿™ä¸ªå¤§å“¥å°†çš„ä¸é”™ã€‚æ–œç‡ä¼˜åŒ–DPï¼Œä¸€å¼€å§‹ä¼šåŒ–æˆä¸€ä¸ªå¼å­ï¼Œåƒ \frac{f(j)-f(k)}{g(j)-g(k)}]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>æ–œç‡ä¼˜åŒ–DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å‡ºç¥å…¥åŒ–çš„åˆ†å— Educational Codeforces Round 71 (Rated for Div. 2) E Remainder Problem]]></title>
    <url>%2F2019%2F08%2F23%2F%E5%87%BA%E7%A5%9E%E5%85%A5%E5%8C%96%E7%9A%84%E5%88%86%E5%9D%97%2F</url>
    <content type="text"><![CDATA[Educational Codeforces Round 71 (Rated for Div. 2) E Remainder Problemé¢˜æ„: ä¸¤ç§æ“ä½œï¼Œä¸€ç§$a_x+y$,ç¬¬äºŒç§æŸ¥è¯¢ \sum_{i=y}^{5e5}a_i,(i\%x==y)æ‰€æœ‰æ¨¡$x$ç­‰äº$y$ä½ç½®çš„å’Œ.é¢˜è§£: $\%x=y$ è¿™ä¸å°±æ˜¯åˆ†å—ä¹ˆï¼Œå°±æ˜¯åˆ†å—çš„æ€§è´¨å•Šï¼Œç›´æ¥å¤„ç†ä¸å°±OKäº†ï¼Ÿï¼Ÿï¼Œæƒ³ä»€ä¹ˆçº¿æ®µæ ‘ã€‚çœŸ6.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include "bits/stdc++.h" using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a)); const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e3 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8; #ifndef ONLINE_JUDGEclock_t prostart = clock();#endif void f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125; //typedef __int128 LLL; template&lt;typename T&gt;void read(T &amp;w) &#123;//è¯»å…¥ char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125; template&lt;typename T&gt;void output(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125; int n, m; const int B = 1e3;LL q[maxn][maxn];LL a[maxn * 1000]; int main() &#123; f(); read(n); while (n--) &#123; int op, x, y; scanf("%d%d%d", &amp;op, &amp;x, &amp;y); if (op == 1) &#123; a[x] += y; for (int i = 1; i &lt;= B; i++) &#123; q[i][x % i] += y; &#125; &#125; else &#123; if (x &lt;= B) &#123; printf("%lld\n", q[x][y]); &#125; else &#123; LL res = 0; while (y &lt;= 500000) &#123; res += a[y]; y += x; &#125; printf("%lld\n", res); &#125; &#125; &#125; #ifndef ONLINE_JUDGE cout &lt;&lt; "è¿è¡Œæ—¶é—´:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>åˆ†å—</category>
      </categories>
      <tags>
        <tag>åˆ†å—</tag>
        <tag>å‡ºç¥å…¥åŒ–</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 10 1011 Make Rounddog Happy]]></title>
    <url>%2F2019%2F08%2F22%2F2019-Multi-University-Training-Contest-10-1011-Make-Rounddog-Happy%2F</url>
    <content type="text"><![CDATA[HDU 6701 Make Rounddog Happyé¢˜æ„ ï¼š ç»™ä½ $n$ä¸ªæ•°ï¼Œå’Œ$k$,æ‰¾åˆ°åŒºé—´[l,r] $max(a_l,\dots,a_r)-(r-l+1)&lt;=k$ çš„æ•°é‡ï¼ˆåŒºé—´å†…ä¸èƒ½å‡ºç°æœ‰ç›¸åŒæ•°å­—ï¼‰ã€‚é¢˜è§£ï¼š ç›¸å½“äºæ‰¾åŒºé—´é•¿åº¦å¤§äºåŒºé—´æœ€å¤§å€¼-k çš„åŒºé—´æ•°é‡ï¼Œç¬¬ä¸€ä¸ªæƒ³åˆ°å…¥æ‰‹çš„è‚¯å®šå°±æ˜¯åŒºé—´æœ€å¤§å€¼ï¼Œç„¶åæšä¸¾å·¦è¾¹æˆ–å³è¾¹çš„è¾¹ç•Œï¼Œç„¶åæ‰¾å¦å¤–ä¸€è¾¹çš„çš„ä¸Šç•Œã€‚å‡è®¾å¯»æ‰¾åŒºé—´æœ€å¤§å€¼ï¼Œstè¡¨èƒ½å¤Ÿå®ç°$O(1)$çš„æŸ¥æ‰¾ï¼Œå‡è®¾æˆ‘ä»¬æ‰¾åˆ°[l,r]åŒºé—´çš„æœ€å¤§å€¼ä¸‹æ ‡ä¸ºMIDï¼Œè¿™ä¸ªMIDå¾ˆæ˜¾ç„¶ä¸ä¼šæ°å¥½åœ¨æ­£ä¸­é—´ï¼Œé‚£ä¹ˆæˆ‘ä»¬è‚¯å®šæ˜¯å‘é‡Œè¾¹ç•Œè¿‘çš„æ–¹å‘æšä¸¾ï¼Œç„¶åæŸ¥è¯¢å¦ä¸€ç«¯çš„æƒ…å†µã€‚(è¿™ä¸ªå«å¯å‘å¼åˆ†æ²» é˜Ÿå‹å‘Šè¯‰æˆ‘æ˜¯$O(nlog(n))$) ã€‚å‡è®¾æšä¸¾å³ç«¯ä¸‹æ ‡ä¸ºå½“å‰ä¸‹æ ‡i,å¦ä¸€ç«¯çš„æƒ…å†µæ€ä¹ˆè·å–å‘¢ï¼Œ$O(n)$æ‰¾è‚¯å®šä¸è¡Œï¼Œå¦ä¸€ç«¯ä¸Šç•Œupè‚¯å®šæ˜¯$i-a[MID]-k$,ä¸‹å±Šå‘¢ï¼Ÿä»iå¼€å§‹ç¬¬ä¸€ä¸ªå‡ºç°ç›¸åŒæ•°å­—çš„ä½ç½®ã€‚è¿™ä¸ªå¯ä»¥$O(n)$ é¢„å¤„ç†å‡ºæ¥ï¼Œæ¯ä¸ªä½ç½®ä¸Šçš„æ•°ä¸Šä¸€æ¬¡å‡ºç°çš„ä½ç½®å¯ä»¥ç›´æ¥æ±‚å‡ºæ¥ï¼Œç„¶åä»æŸä¸€ä¸ªä½ç½®åˆ°ç¬¬ä¸€ä¸ªå‡ºç°ç›¸åŒå€¼çš„ä¸‹æ ‡è‚¯å®šæ˜¯å•è°ƒçš„ï¼Œæ‰€ä»¥èƒ½$O(n)$é¢„å¤„ç†å‡ºç¬¬ä¸€ä¸ªä»iä½ç½®å¾€å‰æœ€é•¿ä¸å‡ºç°ç›¸åŒå€¼çš„ä½ç½®ï¼Œå’Œå‘åæœ€é•¿ä¸å‡ºç°ç›¸åŒå€¼çš„ä½ç½® è¿™ä¸ªåœ°æ–¹å¡äº†ç‚¹å¸¸ï¼Œæˆ‘ç”¨2ä¸ªSTè¡¨å¡æé™æ—¶é—´è¿‡äº†ï¼Œå®é™…ä¸Šä¸¤ä¸ªæ•°ç»„å°±èƒ½è§£å†³ï¼Œæ‰¾åŒºé—´æœ€å¤§å€¼å®é™…ä¸Šä¹Ÿèƒ½ç”¨å•è°ƒæ ˆè§£å†³å¯ä»¥ä¸ç”¨STè¡¨ã€‚ç”»ä¸ªå›¾ç†è§£ä¸€ä¸‹å¦‚æœæ˜¯ï¼Œæšä¸¾å·¦è¾¹ä¸€æ ·çš„å¤„ç†ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 3e5 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;//typedef __int128 LLL;void read(int &amp;w) &#123;//è¯»å…¥ char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125;void output(LL x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125;const int MXN = 3e5 + 10;int a[maxn];int pre[maxn], nxt[maxn];int dp[MXN][20], pos[MXN][20];int lg[maxn];void init(int n) &#123; int LOG = lg[n] + 1; for (int j = 1; j &lt; LOG; ++j) &#123; if ((1 &lt;&lt; (j - 1)) &gt; n) break; for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) &#123; if (dp[i][j - 1] &gt;= dp[i + (1 &lt;&lt; (j - 1))][j - 1]) &#123; dp[i][j] = dp[i][j - 1]; pos[i][j] = pos[i][j - 1]; &#125; else &#123; dp[i][j] = dp[i + (1 &lt;&lt; (j - 1))][j - 1]; pos[i][j] = pos[i + (1 &lt;&lt; (j - 1))][j - 1]; &#125; &#125; &#125;&#125;inline int query(int l, int r) &#123; int k = lg[r - l + 1]; if (dp[l][k] &gt;= dp[r - (1 &lt;&lt; k) + 1][k]) return pos[l][k]; return pos[r - (1 &lt;&lt; k) + 1][k];&#125;inline int query1(int l, int r) &#123; return pre[r];&#125;inline int query2(int l, int r) &#123; return nxt[l];&#125;int n, k;LL ans = 0;void solve(int l, int r) &#123; if (l &gt; r) return; if (l == r) &#123; if (a[l] - 1 &lt;= k) ++ans; return; &#125; int MID = query(l, r);//æœ€å¤§å€¼çš„ä½ç½® if (r - MID &gt; MID - l) &#123; int up = min(query2(MID, r) - 1, r), low; for (int i = MID; i &gt;= l; --i) &#123;//æšä¸¾å·¦ç«¯ç‚¹ up = min(nxt[i] - 1, up); low = i + (a[MID] - k) - 1; low = max(low, MID); if (up &lt; MID)break; if (low &gt; up)continue; else &#123; ans += up - low + 1; &#125; &#125; &#125; else &#123; int up, low = max(query1(l, MID) + 1, l); for (int i = MID; i &lt;= r; ++i) &#123;//æšä¸¾å³ç«¯ç‚¹ low = max(pre[i] + 1, low); up = i - (a[MID] - k) + 1; up = min(up, MID); if (low &gt; MID)break; if (low &gt; up)continue; else &#123; ans += up - low + 1; &#125; &#125; &#125; solve(l, MID - 1); solve(MID + 1, r);&#125;int p[maxn];int main() &#123; f(); int T; read(T); for (int i = 1; i &lt;= 3e5; i++) &#123; lg[i] = log2(i); &#125; while (T--) &#123; read(n); read(k); for (int i = 1; i &lt;= n; i++) &#123; read(a[i]); dp[i][0] = a[i]; pos[i][0] = i; &#125; for (int i = 1; i &lt;= n; i++) &#123; p[i] = 0; &#125; for (int i = 1; i &lt;= n; i++) &#123; pre[i] = p[a[i]]; if (i != 1)pre[i] = max(pre[i], pre[i - 1]); p[a[i]] = i; &#125; for (int i = 1; i &lt;= n; i++) &#123; p[i] = n + 1; &#125; for (int i = n; i &gt;= 1; i--) &#123; nxt[i] = p[a[i]]; if (i != n)nxt[i] = min(nxt[i], nxt[i + 1]); p[a[i]] = i; &#125; for (int i = 1; i &lt;= n; ++i) &#123;// dp1[i][0] = pre[i];// dp2[i][0] = nxt[i]; &#125; init(n); ans = 0; solve(1, n); output(ans); puts(""); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>åˆ†æ²»</category>
      </categories>
      <tags>
        <tag>å¯å‘å¼åˆ†æ²»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[åˆ†æ²»ç®—æ³•]]></title>
    <url>%2F2019%2F08%2F22%2F%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[åˆ†æ²»ç®—æ³•ï¼Œé¡¾åæ€ä¹‰ï¼Œåˆ†è€Œæ²»ä¹‹ã€‚åˆ†æ²»ç®—æ³•ï¼Œæ¯æ¬¡å°†åŒºé—´å‡åŠï¼ŒåŒ–ä¸º[l,mid],[mid+1,r]åŒºé—´ï¼Œå†ç”¨è§£å†³çš„ä¸¤ä¸ªåŒºé—´æ¥è·Ÿæ–°[l,r],éå¸¸å…¸å‹çš„ä¾‹å­å°±æ˜¯å½’å¹¶æ’åºã€‚å½’å¹¶æ’åºï¼Œæ¯æ¬¡å¯¹[l,mid],[mid+1,r]å¤„ç†ï¼Œç„¶å$O(n)$åˆå¹¶ä¸¤ä¸ªæ•°ç»„ï¼Œå±‚æ•°$O(logn)$,æ¯å±‚åˆå¹¶$O(n)$å¤æ‚åº¦ç¨³å®š$O(nlog(n))$ã€‚ CDQåˆ†æ²»å…¸å‹ä¾‹é¢˜:æ´›è°· 3810 ä¸‰ç»´ååºæ´›è°· 3157 åŠ¨æ€é€†åºå¯¹æœ¬æ ¡OJçš„æŸä¸ªé¢˜ï¼Œé“¾æ¥å¤±æ•ˆå¾ˆæ­£å¸¸ ä¸‰ç»´ååºä¸‰ç»´é€†åºå¯¹æ˜¯ä¸ªå¾ˆè£¸çš„é¢˜ï¼Œç›´æ¥å¯¹$x$æ’åºï¼Œæ’åºä¹‹ååƒå½’å¹¶æ’åºä¸€æ ·ï¼Œåˆ†æ²»$y$ï¼Œç„¶åç”¨æ ‘çŠ¶æ•°ç»„æ›´æ–°$z$ã€‚å°±æ˜¯æŠŠå½’å¹¶æ’åºå¤„ç†é€†åºå¯¹çš„æ–¹æ³•ä»æšä¸¾å˜æˆäº†æ ‘çŠ¶æ•°ç»„ã€‚æ ‘çŠ¶æ•°ç»„æ›´æ–°zå…¶å®ä¹Ÿå¯ä»¥æ”¹æˆç”¨cdqåˆ†æ²»å¤„ç†ï¼Œæ¢æˆå…¶ä»–$O(nlog(n))$çš„ç®—æ³•éƒ½å¯ä»¥ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157// luogu-judger-enable-o2#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;//typedef __int128 LLL;template&lt;typename T&gt;void read(T &amp;w) &#123;//è¯»å…¥ char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125;template&lt;typename T&gt;void output(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125;LL bit[maxn + 1], n, k;LL sum(int i) &#123; LL s = 0; while (i &gt; 0) &#123; s += bit[i]; i -= i &amp; -i; &#125; return s;&#125;void add(int i, LL x) &#123; while (i &lt;= k) &#123; bit[i] += x; i += i &amp; -i; &#125;&#125;struct node &#123; int x, y, z, ans, cnt; bool operator==(const node t) const &#123; return x == t.x &amp;&amp; y == t.y &amp;&amp; z == t.z; &#125;&#125; dat[maxn];int ans[maxn];bool cmp1(node &amp;a, node &amp;b) &#123; if (a.x == b.x)return a.y == b.y ? a.z &lt; b.z : a.y &lt; b.y; return a.x &lt; b.x;&#125;bool cmp2(node &amp;a, node &amp;b) &#123; return a.y == b.y ? a.z &lt; b.z : a.y &lt; b.y;&#125;void cdq(int l, int r) &#123; if (r == l)return; cdq(l, mid); cdq(mid + 1, r); sort(dat + l, dat + mid + 1, cmp2); sort(dat + mid + 1, dat + r + 1, cmp2); int j = mid + 1; int i = l; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (dat[i].y &lt;= dat[j].y) &#123; add(dat[i].z, dat[i].cnt); i++; &#125; else &#123; dat[j].ans += sum(dat[j].z); j++; &#125; &#125; while (i &lt;= mid) &#123; add(dat[i].z, dat[i].cnt); i++; &#125; while (j &lt;= r) &#123; dat[j].ans += sum(dat[j].z); j++; &#125; for (i = l; i &lt;= mid; i++)add(dat[i].z, -dat[i].cnt);&#125;int main() &#123; f(); read(n); read(k); k++; for (int i = 1; i &lt;= n; i++) &#123; read(dat[i].x); read(dat[i].y); read(dat[i].z); &#125; sort(dat + 1, dat + n + 1, cmp1); int cnt = 0, num = 0; for (int i = 1; i &lt;= n; i++) &#123; cnt++; if (dat[i] == dat[i + 1])continue; ++num; dat[num].x = dat[i].x; dat[num].y = dat[i].y; dat[num].z = dat[i].z; dat[num].cnt = cnt; cnt = 0; &#125; cdq(1, num); for (int i = 1; i &lt;= num; i++) &#123; ans[dat[i].ans + dat[i].cnt - 1] += dat[i].cnt; &#125; for (int i = 0; i &lt; n; i++)printf("%d\n", ans[i]);#ifndef ONLINE_JUDGE cout &lt;&lt; "è¿è¡Œæ—¶é—´:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; endl;#endif return 0;&#125; åŠ¨æ€é€†åºå¯¹è§£æ³•1ï¼šå¯¹äºåŠ¨æ€é€†åºå¯¹ï¼Œå’Œä¸‰ç»´ååºæ˜¯ä¸€ä¸ªé—®é¢˜ã€‚å¯¹äºæ¯ä¸€ç§åˆ é™¤æ“ä½œï¼Œæˆ‘ä»¬æ·»åŠ ä¸€ä¸ªæ—¶é—´è½´$t$,ç„¶åæŠŠä¸‹æ ‡å½“ä½œä¸€ç»´åº¦ï¼Œå°±å˜æˆäº†ä¸‰ç»´ï¼Œå¦‚æ ·ä¾‹ ï¼š1 5 3 4 2 å˜æˆ1231 2 3 4 5 ä¸‹æ ‡1 5 3 4 2 å€¼1 1 1 1 1 æ—¶é—´ æ¯æ¬¡ä¿®æ”¹ï¼Œåœ¨$t$æ—¶é—´åˆ é™¤äº†å€¼a,é‚£ä¹ˆæŠŠä»–çš„æ—¶é—´å˜æˆå¯¹åº”ä¿®æ”¹æ—¶é—´ã€‚å¦‚æ ·ä¾‹åˆ é™¤é¡ºåº5 1 4 2ï¼Œæ²¡æœ‰åˆ é™¤åˆå§‹åŒ–ä¸ºä¸€ä¸ªæ¯”è¾ƒå¤§çš„å€¼ï¼Œè¦åœ¨æ ‘çŠ¶æ•°ç»„èŒƒå›´å†…ã€‚1231 2 3 4 5 1 5 3 4 23 2 inf 4 5 åˆ é™¤æ—¶é—´ ç„¶åä¸éš¾å‘ç°ï¼Œæ¯æ¬¡åˆ é™¤ä¸€ä¸ªæ•°çš„è´¡çŒ®ï¼Œå°±æ˜¯åŸäºŒç»´é€†åºå¯¹çš„åŸºç¡€ä¸Šï¼ŒåŠ ä¸Šä¸€ä¸ªçº¦æŸæ¡ä»¶ $t_i &lt; t_j$ ã€‚ç„¶åç”¨æ€»é€†åºå¯¹æ•°é‡å‡å»è¿™ä¸ªå½“å‰çš„æ—¶é—´çš„è´¡çŒ®å°±æ˜¯ç­”æ¡ˆã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193// luogu-judger-enable-o2#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;//typedef __int128 LLL;template&lt;typename T&gt;void read(T &amp;w) &#123;//è¯»å…¥ char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125;template&lt;typename T&gt;void output(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125;struct node &#123; int x, y, z;&#125; dat[maxn];bool cmp1(node &amp;o1, node &amp;o2) &#123; return o1.x == o2.x ? (o1.y == o2.y ? o1.z &lt; o2.z : o1.y &lt; o2.y) : o1.x &gt; o2.x;&#125;bool cmp2(node &amp;o1, node &amp;o2) &#123; return (o1.y == o2.y ? o1.z &lt; o2.z : o1.y &lt; o2.y);&#125;bool cmp3(node &amp;o1, node &amp;o2) &#123; return o1.y &gt; o2.y;&#125;int a[maxn];vector&lt;int&gt; v;LL bit[maxn + 1], n;LL sum(int i) &#123; LL s = 0; while (i &gt; 0) &#123; s += bit[i]; i -= i &amp; -i; &#125; return s;&#125;void add(int i, LL x) &#123; while (i &lt;= n) &#123; bit[i] += x; i += i &amp; -i; &#125;&#125;LL ans[maxn];void cdq(int l, int r) &#123; if (r == l)return; cdq(l, mid); cdq(mid + 1, r); sort(dat + l, dat + mid + 1, cmp2); sort(dat + mid + 1, dat + r + 1, cmp2); int i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (dat[i].y &lt; dat[j].y) &#123; add(dat[i].z, 1); i++; &#125; else &#123; ans[dat[j].z] += sum(dat[j].z); j++; &#125; &#125; while (i &lt;= mid) &#123; add(dat[i].z, 1); i++; &#125; while (j &lt;= r) &#123; ans[dat[j].z] += sum(dat[j].z); j++; &#125; for (i = l; i &lt;= mid; i++)add(dat[i].z, -1); i = l; j = mid + 1; sort(dat + l, dat + mid + 1, cmp3); sort(dat + mid + 1, dat + r + 1, cmp3); while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (dat[i].y &gt; dat[j].y) &#123; ans[dat[i].z] += sum(dat[i].z);// add(dat[i].z, 1); i++; &#125; else &#123;// ans[dat[j].z] += sum(dat[j].z); add(dat[j].z, 1); j++; &#125; &#125; while (j &lt;= r) &#123;// ans[dat[j].z] += sum(dat[j].z); add(dat[j].z, 1); j++; &#125; while (i &lt;= mid) &#123; ans[dat[i].z] += sum(dat[i].z);// add(dat[i].z, 1); i++; &#125; for (j = mid + 1; j &lt;= r; j++)add(dat[j].z, -1);&#125;int main() &#123; f(); int m; read(n); read(m); LL res = 0; for (int i = 1; i &lt;= n; i++) &#123; dat[i].x = i; read(dat[i].y);// res += sum(dat[i].y);// add(dat[i].y, 1); a[i] = 1; &#125;// mem(bit, 0); for (int j = 0; j &lt; m; ++j) &#123; int x; read(x); a[x] = m - j + 1; &#125; for (int i = 1; i &lt;= n; ++i) &#123; dat[i].z = a[dat[i].y]; &#125; sort(dat + 1, dat + n + 1, cmp1); for (int i = 1; i &lt;= n; i++) &#123;// dat[i].x = i;// read(dat[i].y); res += sum(dat[i].y); add(dat[i].y, 1);// a[i] = 1; &#125; mem(bit, 0); cdq(1, n); for (int i = 0; i &lt; m; i++) &#123; printf("%lld\n", res); res -= ans[m + 1 - i]; &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "è¿è¡Œæ—¶é—´:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; endl;#endif return 0;&#125; è§£æ³•2åŸæœ¬æˆ‘ä»¬è¿™ä¸ªå†™æ³•æ˜¯ç›´æ¥æ ‡è®°ä¿®æ”¹æ—¶é—´ï¼Œè¿™æ¬¡æˆ‘ä»¬å˜æˆæ·»åŠ ä¸€ä¸ªç›¸åçš„å€¼ã€‚åœ¨åŸæœ‰çš„èŠ‚ç‚¹ä¸Šï¼Œæˆ‘ä»¬æ·»åŠ ä¸€ä¸ªå€¼ï¼Œè®°å½•ä¸ªæ•°ï¼Œåˆ é™¤ä¹…ç›¸å½“äºæ·»åŠ ä¸€ä¸ªä¸ªæ•°ä¸º-1çš„èŠ‚ç‚¹ã€‚ä¾‹å­å°±å˜æˆäº†12341 1 2 2 3 4 4 5 5 1 1 5 5 3 4 4 2 21 3 1 2 inf 1 4 1 5 åˆ é™¤æ—¶é—´1 -1 1 -1 1 1 -1 1 -1 ä¸ªæ•° ç„¶åç®—è´¡çŒ®å°±å¯ä»¥ç›´æ¥ç®—è´¡çŒ®äº†ï¼Œå¾ˆæ˜¾ç„¶è¿™ç§å†™æ³•å¤šäº†ä¸€ä¸ªå¸¸æ•°ï¼Ÿé‚£ä¹ˆä¸ºä»€ä¹ˆä¹Ÿè¦è´´å‡ºæ¥å‘¢ï¼Ÿï¼Œå› ä¸ºè¿™ä¸ªå†™æ³•æ·»åŠ å’Œåˆ é™¤éƒ½å¯ä»¥ç›´æ¥åœ¨ä¸Šé¢åšä¿®æ”¹ï¼Œæ·»åŠ å°±ç›¸å½“äºåŠ äº†ä¸€ä¸ªä¸ªæ•°ä¸º1çš„èŠ‚ç‚¹ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189// luogu-judger-enable-o2#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;//typedef __int128 LLL;template&lt;typename T&gt;void read(T &amp;w) &#123;//è¯»å…¥ char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125;template&lt;typename T&gt;void output(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125;struct node &#123; int x, y, z, cnt;&#125; dat[maxn];bool cmp1(node &amp;o1, node &amp;o2) &#123; if (o1.x == o2.x)return o1.y == o2.y ? o1.z &gt; o2.z : o1.y &lt; o2.y; return o1.x &lt; o2.x;&#125;bool cmp2(node &amp;o1, node &amp;o2) &#123; return o1.y == o2.y ? o1.z &gt; o2.z : o1.y &gt; o2.y;&#125;bool cmp3(node &amp;o1, node &amp;o2) &#123; return o1.y == o2.y ? o1.z &lt; o2.z : o1.y &lt; o2.y;&#125;int pos[maxn];int bit[maxn];int n, m;LL sum2(int i) &#123; int s = 0; while (i &gt; 0) &#123; s += bit[i]; i -= i &amp; -i; &#125; return s;&#125;void add(int i, int x) &#123; while (i &lt;= m + 1) &#123; bit[i] += x; i += i &amp; -i; &#125;&#125;LL ans[maxn];void cdq(int l, int r) &#123; if (r == l)return; cdq(l, mid); cdq(mid + 1, r); sort(dat + l, dat + mid + 1, cmp2); sort(dat + mid + 1, dat + r + 1, cmp2); int i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (dat[i].y &gt;= dat[j].y) &#123; add(dat[i].z, dat[i].cnt); i++; &#125; else &#123; ans[dat[j].z] += sum2(dat[j].z) * dat[j].cnt; j++; &#125; &#125; while (i &lt;= mid) &#123; add(dat[i].z, dat[i].cnt); i++; &#125; while (j &lt;= r) &#123; ans[dat[j].z] += sum2(dat[j].z) * dat[j].cnt; j++; &#125; for (i = l; i &lt;= mid; i++)add(dat[i].z, -dat[i].cnt); sort(dat + l, dat + mid + 1, cmp3); sort(dat + mid + 1, dat + r + 1, cmp3); i = l; j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (dat[i].y &gt; dat[j].y) &#123; add(dat[j].z, dat[j].cnt); j++; &#125; else &#123;// if (dat[i].z == 2) &#123;// bug;// &#125; ans[dat[i].z] += sum2(dat[i].z) * dat[i].cnt; i++; &#125; &#125; while (i &lt;= mid) &#123;// if (dat[i].z == 2) &#123;// bug;// &#125; ans[dat[i].z] += sum2(dat[i].z) * dat[i].cnt; i++; &#125; while (j &lt;= r) &#123; add(dat[j].z, dat[j].cnt); j++; &#125; for (i = mid + 1; i &lt;= r; i++)add(dat[i].z, -dat[i].cnt);&#125;int main() &#123; f(); read(n); read(m); LL res = 0; for (int i = 1; i &lt;= n; i++) &#123; read(dat[i].y); dat[i].x = i; pos[dat[i].y] = i; dat[i].cnt = 1; dat[i].z = 1; &#125; for (int i = 1; i &lt;= m; i++) &#123; int x; read(x); dat[i + n].x = pos[x]; dat[i + n].y = dat[pos[x]].y; dat[i + n].z = i + 1; dat[i + n].cnt = -1; &#125; sort(dat + 1, dat + n + m + 1, cmp1); cdq(1, n + m); res = ans[1] / 2; for (int i = 2; i &lt;= m + 1; i++) &#123; printf("%lld\n", res); res += ans[i];// debug(ans[i]); &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "è¿è¡Œæ—¶é—´:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; endl;#endif return 0;&#125; æˆ‘æ ¡é‚£é¢˜åšç»ƒä¹ ï¼Œå¦‚æœå¤±æ•ˆäº†å°±åˆ«åšäº†ï¼Œæƒ³è¯•è¯•å¯ä»¥ç•™è¨€ã€‚å¯å‘å¼åˆ†æ²»æ•æˆ‘ç›´è¨€ï¼Œä¸è¯´è¯åˆ†æ²»å¾ˆå®¹æ˜“å‡ºç°ä¸€ç§æƒ…å†µï¼Œä½ éœ€è¦æ‰¾çš„midä¸æ˜¯åˆšå¥½åœ¨ä¸€åŠçš„ä½ç½®ï¼Œã€‚ã€‚ç„¶åä½ å°±å¾€ç¦»è¾¹ç•Œè¿‘çš„æ–¹å‘æšä¸¾ã€‚ç„¶åç¡®å®šå¦ä¸€åŠçš„ä¸´ç•Œå€¼ã€‚è¿™ä¸ªé˜Ÿå‹å‘Šè¯‰æˆ‘æ˜¯$O(nlog(n))$ä½†æ˜¯æˆ‘ä¸ç¡®å®šã€‚ä¾‹é¢˜ï¼Œå¯ä»¥å»æˆ‘çš„å¯å‘å¼åˆ†æ²»é¢˜æ ‡ç­¾é‡Œé¢æ‰¾]]></content>
      <categories>
        <category>ACM</category>
        <category>åˆ†æ²»</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 9 1007 Rikka with Travels]]></title>
    <url>%2F2019%2F08%2F19%2F2019-Multi-University-Training-Contest-9-1007%2F</url>
    <content type="text"><![CDATA[HDU 6686 Rikka with Travelsé¢˜æ„: åœ¨ä¸€é¢—æ ‘ä¸Šé€‰æ‹©ä¸¤æ¡ä¸ç›¸äº¤çš„è·¯å¾„çš„å¯èƒ½æ€§æœ‰å¤šå°‘ï¼Œè·¯å¾„é•¿åº¦å®šä¹‰ä¸ºè·¯å¾„çš„é¡¶ç‚¹æ•°ã€‚é¢˜è§£:åˆæ­¥æ€è€ƒï¼Œè§‚å¯Ÿæ ·ä¾‹å¯ä»¥å‘ç°ï¼Œæ±‚çš„æ˜¯ä¸¤æ¡è·¯å¾„çš„æœ‰åºå¯¹ï¼Œ[2,1],[1,2]ä¸æ˜¯åŒä¸€ç§ã€‚æˆ‘ä»¬å‡è®¾å·²ç»çŸ¥é“ä½ é€‰æ‹©çš„ä¸€æ¡è·¯å¾„é•¿åº¦ä¸ºl,åªéœ€è¦æ‰¾åˆ°æŠŠè¿™æ¡è·¯å¾„åœ¨æ ‘ä¸­ç§»é™¤ï¼Œä½™ä¸‹çš„æ£®æ—çš„æœ€é•¿è·¯å¾„æ˜¯å¤šå°‘ï¼Œå‡è®¾æ˜¯$r$,å¯¹äºé•¿åº¦ä¸º$l$çš„è·¯å¾„æœ‰å¤šæ¡ï¼Œç„¶ååˆ†åˆ«æ±‚å‡ºå¯¹åº”çš„$r$å°±æ˜¯è´¡çŒ®ï¼Œç„¶åå°†æ‰€æœ‰çš„$l$çš„è´¡çŒ®ï¼Œæ±‚å’Œå°±æ˜¯ç­”æ¡ˆã€‚å¾ˆæ˜¾ç„¶è¿™ä¹ˆæ±‚å°±å¯¹è¶…æ—¶ï¼Œè€Œä¸”ä¹Ÿæ— ä»ä¸‹æ‰‹ã€‚é‚£ä¹ˆæˆ‘ä»¬ç»§ç»­ä¼˜åŒ–ï¼Œå¯¹äºä¸€é¢—æ ‘ï¼Œæˆ‘ä»¬æ¯æ¬¡æ‹†ä¸€æ¡è¾¹ã€‚æ±‚å‡ºå·¦è¾¹çš„æœ€é•¿ç›´å¾„ä¸ºL,å³è¾¹çš„æœ€é•¿ç›´å¾„ä¸ºR,å¯ä»¥å‘ç°å·¦è¾¹è¿™é¢—å­æ ‘çš„è·¯å¾„å¯èƒ½æœ‰$1,2,\cdots,L$ï¼Œå³è¾¹æœ‰$1,2,\cdots,R$, æˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼ŒæŠŠåŒºé—´$l=[1,L]$çš„è´¡çŒ®è·Ÿæ–°ä¸º$R$,$l=[1,R]$ æ›´æ–°ä¸º$L$ï¼Œå†™å‡ºæš´åŠ›ä¿®æ”¹å°±æ˜¯ f[i]=max(f[i],R),1]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>æ­ç”µå¤šæ ¡</tag>
        <tag>æ ‘å½¢DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥(ç¬¬å…«åœº)Just Jump]]></title>
    <url>%2F2019%2F08%2F14%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5(%E7%AC%AC%E5%85%AB%E5%9C%BA)J.Just-Jump%2F</url>
    <content type="text"><![CDATA[2019ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥(ç¬¬å…«åœº)Just Jumpé¢˜æ„ï¼š ç»ˆç‚¹ä½ç½®ä¸º$L$ï¼Œä¸­é—´ç‚¹æ˜¯$1,2,\cdots,L-1$ ï¼Œå¼€å§‹ä½ç½®åœ¨$0$ï¼Œæ¯æ¬¡å¿…é¡»èµ°è‡³å°‘$d$æ­¥,åœ¨ç¬¬ã€‚$t_i$æ­¥ä¸èƒ½å‡ºç°åœ¨ $p_i$ è¿™ä¸ªä½ç½®ï¼Œé—®ä» $0$ åˆ° $L$ ï¼Œæœ‰å¤šå°‘ç§èµ°æ³•ã€‚ é¢˜è§£ï¼šè§£æ³•æŒºç®€å•çš„ï¼Œå…ˆç®—å‡ºæ²¡æœ‰$m$ä¸ªçº¦æŸçš„æƒ…å†µä¸‹ï¼Œæ±‚ä¸€ä¸ªå€¼ï¼Œè¿™ä¸ª $f[i] =\sum_{j=0}^{i-d}f[i]$ ã€‚ç„¶åå®¹æ–¥æä¸€ä¸‹ï¼Œ$m$ä¸ªé™åˆ¶ï¼Œé‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œæ€ä¹ˆæ±‚åˆšå¥½èµ° $t_i$ æ­¥åˆ° $p_i$ ã€‚ è¿™ç¯‡åšå®¢çš„æ„ä¹‰å°±åœ¨è¿™äº†,å…ˆæ¨èä¸ªåŸºç¥åšå®¢ã€‚ è¿™ä¸ªæ±‚ä¸€ä¸ªæœ€ååº”è¯¥å°±ç­‰äº$C_{p_i-dt_i+t_i-1}^{t_i-1}$ã€‚ æˆ‘ä»¬ç°åœ¨åº”è¯¥æ˜¯å¯¹åº”è¿™ç§æƒ…å†µ ç”¨æ’æ¿æ³•ï¼Œå°±æ˜¯ä»$n+m$ä¸ªç©ºéš™é‡Œé¢ï¼Œé€‰å‡º$m-1$ä¸ªä½ç½®å‡ºæ¥ï¼Œç°åœ¨è¿™å°±æ˜¯å¤šäº†ä¸ªè¦æ±‚ï¼Œç›¸é‚»ä¸¤ä¸ªé—´éš™ä¸èƒ½å°äº$d$ â€¦,æŠ½è±¡ç†è§£ä¸‹ ä½ æŠŠè¿™$m$ä¸ª$d$å…¨éƒ¨æ¨å‰é¢å»ï¼Œä¸ä¹…ç›¸å½“äºç›´æ¥åœ¨åé¢$n-m * d-(m-1)$é€‰$m-1$ä¸ª 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 998244353;const int maxn = (int) 1e7 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;//typedef __int128 LLL;template&lt;typename T&gt;void read(T &amp;w) &#123;//è¯»å…¥ char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125;template&lt;typename T&gt;void output(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125;LL L, d, m;P p[3005];LL qz[maxn], l[maxn];const int Comb_Maxn = 1e7 + 10;LL Fac_inv[Comb_Maxn];LL Fac[Comb_Maxn];inline void Comb_init() &#123; Fac_inv[0] = Fac[0] = 1; Fac_inv[1] = 1; for (int i = 1; i &lt; Comb_Maxn; i++) Fac[i] = Fac[i - 1] * (LL) i % mod; for (int i = 2; i &lt; Comb_Maxn; i++) Fac_inv[i] = (LL) (mod - mod / i) * Fac_inv[mod % i] % mod; for (int i = 1; i &lt; Comb_Maxn; i++) Fac_inv[i] = (LL) Fac_inv[i - 1] * Fac_inv[i] % mod;&#125;LL Comb(LL n, LL m) &#123; if (n &lt; 0 || m &lt; 0)return 0; if (n &lt; m)return 0; assert(n &lt; Comb_Maxn &amp;&amp; n &gt;= m); assert(m &lt; Comb_Maxn); return Fac[n] * Fac_inv[m] % mod * Fac_inv[n - m] % mod;&#125;LL dp[maxn];int main() &#123; f(); read(L); read(d); read(m); Comb_init(); for (int i = 0; i &lt; m; i++) &#123; read(p[i].first); read(p[i].second); &#125; sort(p, p + m); l[0] = 1; qz[0] = 1; for (int i = 1; i &lt;= L; i++) &#123; if (i &gt;= d) &#123; l[i] = qz[i - d]; &#125; qz[i] = (qz[i - 1] + l[i]) % mod; &#125; for (int i = 0; i &lt; m; i++) &#123; dp[i] = Comb(p[i].second - d * p[i].first + p[i].first - 1, p[i].first - 1); if (dp[i] != 0) &#123; for (int j = 0; j &lt; i; j++) &#123; dp[i] = (dp[i] - Comb(p[i].second - p[j].second - d * (p[i].first - p[j].first) + (p[i].first - p[j].first) - 1, (p[i].first - p[j].first) - 1) * dp[j] % mod + mod) % mod; &#125; &#125; &#125; LL ans = l[L]; for (int i = 0; i &lt; m; i++) &#123; ans = (ans - dp[i] * l[L - p[i].second] % mod + mod) % mod; &#125; printf("%lld\n", ans);#ifndef ONLINE_JUDGE cout &lt;&lt; "è¿è¡Œæ—¶é—´:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>æ•°è®º</category>
      </categories>
      <tags>
        <tag>ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥</tag>
        <tag>å®¹æ–¥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥(ç¬¬å…«åœº)Flower Dance(æœ‰å‘)]]></title>
    <url>%2F2019%2F08%2F13%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5(%E7%AC%AC%E5%85%AB%E5%9C%BA)Flower%20Dance%2F</url>
    <content type="text"><![CDATA[2019ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥(ç¬¬å…«åœº)Flower Dance é¢˜æ„: ç»™$n$ä¸ªç‚¹ $m$æ¡è¾¹ï¼Œæ¯æ¡è¾¹æœ‰ä¸€ä¸ªæƒå€¼åŒºé—´ï¼Œè¡¨ç¤ºèƒ½é€šè¿‡è¿™ä¸ªåŒºé—´çš„ å€¼çš„èŒƒå›´ï¼Œé—®ä»$1$åˆ°$n$å¯ä»¥é€šè¿‡çš„æƒå€¼æœ‰å¤šå°‘ä¸ªã€‚ é¢˜è§£: 1.DFSçº¿æ®µæ ‘+ç¦»æ•£åŒ–+å¹¶æŸ¥é›†è¿™ä¸ªçº¿æ®µæ ‘ï¼Œå…¶å®ä¹Ÿä¸èƒ½ç®—æ˜¯ä¸ªæ­£å¸¸çš„çº¿æ®µæ ‘ï¼Œä»–build çš„ä¹‹åå°±æ²¡å•¥ç”¨äº†ï¼Œæ²¡æœ‰æ›´æ–°å’ŒæŸ¥è¯¢.ã€‚ã€‚ç›´æ¥åœ¨çº¿æ®µæ ‘ä¸Šdfs,é¦–å…ˆæŠŠæƒå€¼ç¦»æ•£åŒ–ï¼Œç„¶åå­˜å…¥çº¿æ®µæ ‘ä¸­ï¼Œçº¿æ®µæ ‘æ¯ä¸ªèŠ‚ç‚¹è¡¨ç¤ºï¼ŒåŒºé—´[l,r]ï¼Œä¸­æœ‰å“ªäº›è¾¹ï¼Œè¿™æ ·æ¯æ¬¡æ·±æœä¸‹å»ï¼Œç»è¿‡çš„è¾¹ç”¨å¹¶æŸ¥é›†ç»´æŠ¤èµ·æ¥ï¼Œè¡¨ç¤ºå“ªäº›ç‚¹æ˜¯è”é€šçš„ï¼Œç„¶åå¦‚æœï¼Œ1å’Œnè”é€šçš„è¯å°±æ›´æ–°æƒå€¼ã€‚è¿™é¢˜æœ‰å›æº¯ï¼Œå°±æœ‰æ‹†è¾¹ï¼Œæ‰€ä»¥å¹¶æŸ¥é›†è¦ä¿å­˜è·¯å¾„ï¼Œè€Œä¸”è¦åŠ æŒ‰ç§©åˆå¹¶çš„ä¼˜åŒ–,ä¸ç„¶ä¼šè¶…æ—¶ã€‚ å†™ç¦»æ•£åŒ–çº¿æ®µæ ‘å°½é‡ä¿å­˜ (l,r] å·¦å¼€å³é—­çš„åŒºé—´å€¼ï¼Œä¿å­˜[l,r] çš„åŒºé—´ä¼šå‡ºé—®é¢˜ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;//typedef __int128 LLL;template&lt;typename T&gt;void read(T &amp;w) &#123;//è¯»å…¥ char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125;template&lt;typename T&gt;void output(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125;struct edge &#123; int u, v, l, r;&#125; eg[maxn];vector&lt;int&gt; v;int get(int x) &#123; return lower_bound(v.begin(), v.end(), x) - v.begin() + 1;&#125;int n, m;vector&lt;int&gt; dat[maxn];void build(int l, int r, int k, int a, int b, int x) &#123; if (l == a &amp;&amp; b == r) &#123; dat[k].emplace_back(x); return; &#125; if (b &lt;= mid) &#123; build(lson, a, b, x); &#125; else if (a &gt;= mid) &#123; build(rson, a, b, x); &#125; else &#123; build(lson, a, mid, x); build(rson, mid, b, x); &#125;&#125;vector&lt;int&gt; d[maxn];int ans = 0;int par[maxn];int find(int x) &#123; return (par[x] == x) ? x : find(par[x]);&#125;int rk[maxn];void unit(int x, int y, int dep) &#123; x = find(x); y = find(y); if (x != y) &#123; if (rk[x] &lt; rk[y])swap(x, y); par[y] = x; d[dep].emplace_back(y); if (rk[x] == rk[y])rk[x]++; &#125;&#125;void dfs(int l, int r, int k, int dep) &#123; d[dep].clear(); for (auto au:dat[k]) &#123; unit(eg[au].u, eg[au].v, dep); &#125; if (find(1) == find(n)) &#123; ans += v[r - 1] - v[l - 1]; &#125; else if (r != l + 1) &#123; dfs(lson, dep + 1); dfs(rson, dep + 1); &#125; for (auto au:d[dep]) &#123; par[au] = au; &#125;&#125;int main() &#123; f(); read(n); read(m); for (int i = 0; i &lt;= n; i++)par[i] = i; for (int i = 0; i &lt; m; i++) &#123; read(eg[i].u); read(eg[i].v); read(eg[i].l); read(eg[i].r); v.emplace_back(eg[i].l); v.emplace_back(eg[i].r + 1); &#125; sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); int mx = v.size(); for (int i = 0; i &lt; m; i++) &#123; build(1, mx, 1, get(eg[i].l), get(eg[i].r + 1), i); &#125; dfs(1, mx, 1, 0); output(ans); puts("");#ifndef ONLINE_JUDGE cout &lt;&lt; "è¿è¡Œæ—¶é—´:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; endl;#endif return 0;&#125; LCT+æœ€å°ç”Ÿæˆæ ‘ æŒ–ä¸ªå‘ï¼Œæ‡’å¾—å­¦splay]]></content>
      <categories>
        <category>ACM</category>
        <category>æ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>çº¿æ®µæ ‘</tag>
        <tag>ç¦»æ•£åŒ–</tag>
        <tag>ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥</tag>
        <tag>å¹¶æŸ¥é›†</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥(ç¬¬å…«åœº) Distance]]></title>
    <url>%2F2019%2F08%2F13%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5(%E7%AC%AC%E5%85%AB%E5%9C%BA)Distance%2F</url>
    <content type="text"><![CDATA[2019ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥(ç¬¬å…«åœº) Distanceé¢˜æ„: ç»™ä½ ä¸€ä¸ª $n* m* h$ çš„ç©ºé—´ï¼Œæ¯æ¬¡æ’å…¥ä¸€ä¸ªç‚¹ï¼Œæˆ–è€…è¯¢é—®ç©ºé—´ä¸­ç‚¹åˆ°è¿™ä¸€ç‚¹çš„æœ€å°æ›¼å“ˆé¡¿è·ç¦»ã€‚é¢˜è§£: 1.HASH+ä¸‰ç»´BITä¸‰ç»´BITï¼Œå¯¹äºè¿™ç§å†™æ³•ï¼Œå¤ªå·¨äº†ï¼Œ$n * m * h &lt; 1e5$ ç‰¹ä¹ˆç›´æ¥ç”¨ä¸‰ç»´BIT å­˜ä¸€ä¸‹å°±å¯ä»¥äº†ï¼Œæšä¸¾å…«ä¸ªæ–¹å‘ï¼ŒæŠŠç»å¯¹å€¼å»æ‰ï¼Œç„¶åæœ€ç‰›çš„è¿˜æ˜¯hashå¤„ç†ï¼ŒæŠŠä¸‰ç»´å‹ç¼©æˆä¸€ç»´ï¼Œå‰Šå¸¸æ•°ï¼Œæˆ‘ç‰¹ä¹ˆå¡å¸¸å¡æˆè¿™æ ·ä¹Ÿæ˜¯å°‘è§ã€‚è¿™ç§hashå°†ç»´åº¦ï¼Œæšä¸¾å…«ä¸ªæ–¹å‘å»ç»å¯¹å€¼ï¼Œæ•°ç»„æ•°ç»„æ¨¡æ‹Ÿç©ºé—´ï¼Œè¿˜æ˜¯æŒº6çš„123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;//typedef __int128 LLL;template&lt;typename T&gt;void read(T &amp;w) &#123;//è¯»å…¥ char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125;template&lt;typename T&gt;void output(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125;typedef vector&lt;int&gt; VI;typedef vector&lt;VI&gt; VVI;typedef vector&lt;VVI&gt; VVVI;struct BIT &#123; int n, m, h; int a[maxn]; void init(int n, int m, int h) &#123; this-&gt;n = n; this-&gt;m = m; this-&gt;h = h; mem(a, -inf); &#125; int get(int x, int y, int z) &#123; return x * h * m + y * h + z; &#125; int lowbit(int &amp;x) &#123; return x &amp; (-x); &#125; void add(int x, int y, int z, int t) &#123; for (int i = x; i &lt;= n; i += lowbit(i)) for (int j = y; j &lt;= m; j += lowbit(j)) for (int k = z; k &lt;= h; k += lowbit(k)) a[get(i, j, k)] = max(a[get(i, j, k)], t); &#125; int sum(int x, int y, int z) &#123; int res = -inf; for (int i = x; i; i -= lowbit(i)) for (int j = y; j; j -= lowbit(j)) for (int k = z; k; k -= lowbit(k)) res = max(a[get(i, j, k)], res); return res; &#125;&#125; b[8];int get_pos(int x, int pos) &#123; return (x &gt;&gt; pos) &amp; 1;&#125;int main() &#123; f(); int n, m, h, q; int op; read(n); read(m); read(h); read(q); for (int i = 0; i &lt; 8; i++) &#123; b[i].init(n, m, h); &#125; int d[] = &#123;n + 1, m + 1, h + 1&#125;; int a[3], c[3]; while (q--) &#123; read(op); read(a[0]); read(a[1]); read(a[2]); if (op == 1) &#123; for (int i = 0; i &lt; 8; i++) &#123; c[0] = get_pos(i, 0) ? d[0] - a[0] : a[0]; c[1] = get_pos(i, 1) ? d[1] - a[1] : a[1]; c[2] = get_pos(i, 2) ? d[2] - a[2] : a[2]; b[i].add(c[0], c[1], c[2], c[1] + c[2] + c[0]); &#125; &#125; else &#123; int ans = inf; for (int i = 0; i &lt; 8; i++) &#123; c[0] = get_pos(i, 0) ? d[0] - a[0] : a[0]; c[1] = get_pos(i, 1) ? d[1] - a[1] : a[1]; c[2] = get_pos(i, 2) ? d[2] - a[2] : a[2]; ans = min(ans, c[0] + c[1] + c[2] - b[i].sum(c[0], c[1], c[2])); &#125; output(ans); puts(""); &#125; &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "è¿è¡Œæ—¶é—´:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; " s" &lt;&lt; endl;#endif return 0;&#125; 2.åˆ†å—+bfsç¬¬äºŒç§å†™æ³•å°±æ›´éªšäº†Orz,å¯¹äº $1e5$ ç»„æŸ¥è¯¢ï¼Œåˆ†æˆ$\sqrt{(1e5)}$ å—ï¼Œæ¯æ¬¡æ’å…¥ä¸€ä¸ªç‚¹ï¼Œå…ˆåˆ¤æ–­æœ‰æ²¡æœ‰$\sqrt{(1e5)}$ä¸ªï¼Œå°‘äºè¿™ä¸ªæ•°é‡ï¼Œç›´æ¥æš´åŠ›æ‰¾ï¼Œå‡è®¾å°±ç®—æ¯æ¬¡éƒ½æ˜¯æ»¡çš„éƒ½æ˜¯ $\sqrt{(1e5)} * 1e5$ çš„å¤æ‚åº¦ï¼Œç„¶åå¦‚æœæ»¡äº†ï¼Œç›´æ¥ç©ºé—´ä¸­bfs,æ¯”å¦‚è¯´ä½ æ’å…¥äº†ä¸¤ä¸ªç‚¹,0,0,1 0,0,2,ç›´æ¥æš´åŠ›bfs,æšä¸¾6ä¸ªæ–¹å‘,æ‰¾ç¦»è¿™ä¸ªç‚¹æœ€è¿‘çš„è·ç¦»æ˜¯å¤šå°‘ã€‚æš´åŠ›æšä¸¾ç©ºé—´å¤æ‚åº¦æ˜¯$O(n * m * h)$.æ€»å¤æ‚åº¦å°±æ˜¯ $q*\sqrt{q}+\sqrt{n * m * h} * q$. è¿™ç§åˆ†å—æ›´æ–°çš„æ“ä½œï¼Œå­¦ä¸æ¥ï¼Œå­¦ä¸æ¥ï¼Œæ ¹æœ¬å­¦ä¸æ¥ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include "bits/stdc++.h" using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a)); const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8; #ifndef ONLINE_JUDGEclock_t prostart = clock();#endif void f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125; //typedef __int128 LLL; template&lt;typename T&gt;void read(T &amp;w) &#123;//è¯»å…¥ char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125; template&lt;typename T&gt;void output(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125; int a[maxn]; int dir[6][3] = &#123;&#123;1, 0, 0&#125;, &#123;-1, 0, 0&#125;, &#123;0, 1, 0&#125;, &#123;0, -1, 0&#125;, &#123;0, 0, 1&#125;, &#123;0, 0, -1&#125;&#125;;int X[maxn], Y[maxn], Z[maxn];int lx, ly, lz;int n, m, h, q; int get(int x, int y, int z) &#123; return x * h * m + y * h + z;&#125; struct node &#123; int k, x, y, z; node(int x, int y, int z) &#123; this-&gt;x = x; this-&gt;y = y; this-&gt;z = z; this-&gt;k = get(x, y, z); &#125;&#125;; void rebuild() &#123; queue&lt;node&gt; que; for (int i = 0; i &lt; lx; i++) &#123; que.push(node(X[i], Y[i], Z[i])); a[get(X[i], Y[i], Z[i])] = 0; &#125; while (que.size()) &#123; node t = que.front(); que.pop(); for (int i = 0; i &lt; 6; i++) &#123; int tox = t.x + dir[i][0], toy = t.y + dir[i][1], toz = t.z + dir[i][2]; if (tox &lt; 0 || tox &gt;= n || toy &lt; 0 || toy &gt;= m || toz &lt; 0 || toz &gt;= h) continue; int k = get(tox, toy, toz); if (a[k] &gt; a[t.k] + 1) &#123; a[k] = a[t.k] + 1; que.push(node(tox, toy, toz)); &#125; &#125; &#125; lx = 0; ly = 0; lz = 0;&#125; int op, x, y, z; int main() &#123; f(); mem(a, inf); read(n); read(m); read(h); read(q); while (q--) &#123; read(op); read(x); read(y); read(z); --x, --y, --z; if (op == 1) &#123; X[lx++] = x; Y[ly++] = y; Z[lz++] = z; &#125; else &#123; int k = get(x, y, z); int ans = a[k]; for (int i = 0; i &lt; lx; i++) &#123; ans = min(ans, abs(x - X[i]) + abs(z - Z[i]) + abs(y - Y[i])); &#125; output(ans); puts(""); &#125; if (lx == 300) &#123; rebuild(); &#125; &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "è¿è¡Œæ—¶é—´:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; " s" &lt;&lt; endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>æ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥</tag>
        <tag>æ ‘çŠ¶æ•°ç»„</tag>
        <tag>åˆ†å—</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥(ç¬¬ä¸ƒåœº) E Find the median]]></title>
    <url>%2F2019%2F08%2F09%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5(%E7%AC%AC%E4%B8%83%E5%9C%BA)E.Find-the-median%2F</url>
    <content type="text"><![CDATA[2019ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥(ç¬¬ä¸ƒåœº)Find the median é¢˜æ„: å…ˆæŠŠè¾“å…¥å¤„ç†ä¸€ä¸‹ï¼Œæ²¡å•¥é—®é¢˜å§ã€‚å¤„ç†å®Œååº”è¯¥ç›¸å½“äºæ¯æ¬¡åœ¨ä¸€ä¸ªé›†åˆé‡Œé¢åŠ å…¥l,rä¹‹é—´æ‰€æœ‰çš„æ•°ï¼Œé—®ä¸­ä½æ•°æ˜¯å¤šå°‘ã€‚é¢˜è§£ï¼š è¿™é¢˜å¾ˆæœ‰æ„æ€ï¼Œç¦»æ•£åŒ–+çº¿æ®µæ ‘ å°±èƒ½åšï¼Œå°±ç›¸å½“äºåœ¨çº¿æ®µæ ‘ä¸Šæ±‚ç¬¬sum/2ä¸ªæ•°åœ¨å“ªã€‚æ¯”è¾ƒæœ´ç´ çš„å°±æ˜¯å…ˆæŠŠæ‰€æœ‰çš„l,rä¿å­˜ä¸‹æ¥ï¼Œç„¶åæŠŠä»–ç¦»æ•£åŒ–ï¼Œç„¶åå¯¹ç¦»æ•£åŒ–åçš„å€¼åšæ’å…¥åˆ é™¤æ“ä½œï¼Œæˆ‘æ ¹æ®çº¿æ®µæ ‘åŠ¨æ€å¼€ç‚¹çš„æ“ä½œï¼Œå†™äº†ä¸ªåœ¨çº¿æ®µæ ‘ä¸Šç›´æ¥ç¦»æ•£åŒ–çš„æ“ä½œï¼Œæœ‰ç‚¹åƒæŠŠåŠ¨æ€å¼€ç‚¹å’Œç¦»æ•£åŒ–ç»“åˆèµ·æ¥çš„æ„Ÿè§‰ã€‚æ€»ä½“æ¥è¯´ï¼šå°±æ˜¯éœ€è¦å“ªä¸ªåŒºé—´æˆ‘å°±æŠŠçº¿æ®µæ ‘çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹å¼€ä»€ä¹ˆæ ·çš„l,rï¼Œä¸ä¸€å®šæ˜¯åˆšå¥½åˆ†ä¸€åŠã€‚è¿™æ ·å†™å¾ˆå®¹æ˜“è¢«å¡æ‰ï¼Œå› ä¸ºå¯èƒ½é€€åŒ–åˆ°$n^2$çš„å¤æ‚åº¦ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;const LL mod = (LL) 1e9 + 7;const int maxn = (int) 4e7 + 5;const int MX = 4e5 + 10;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;LL n;LL x1, x2, a1, b1, c1, m1, Y1, y2, a2, b2, c2, m2;LL ls[MX], rs[MX], xs[MX], ys[MX];struct node &#123; int l; int r; int num; LL sum; int ls, rs;&#125; dat[maxn];int cnt;int init(int l, int r, int k) &#123; dat[k].l = l; dat[k].r = r; dat[k].sum = 0; dat[k].num = 0; dat[k].ls = -1; dat[k].rs = -1; return k;&#125;void build(int l, int r, int k) &#123; cnt = 0; init(l, r, cnt++);&#125;void add(int k, int num) &#123; dat[k].num += num; dat[k].sum += 1LL * (dat[k].r - dat[k].l + 1) * num;&#125;void pushdown(int k) &#123; add(dat[k].ls, dat[k].num); add(dat[k].rs, dat[k].num); dat[k].num = 0; dat[k].sum = dat[dat[k].ls].sum + dat[dat[k].rs].sum;&#125;void update(int a, int b, int k) &#123; if (b &lt; dat[k].l || a &gt; dat[k].r)return; if (a &lt;= dat[k].l &amp;&amp; dat[k].r &lt;= b) &#123; dat[k].num++; dat[k].sum += dat[k].r - dat[k].l + 1; &#125; else &#123; if (dat[k].ls == -1) &#123; int mid; if (b &lt;= dat[k].r) &#123; mid = b; &#125; else mid = a; if (mid == dat[k].l) &#123; //éœ€è¦ä»€ä¹ˆç‚¹ï¼Œå¼€ä»€ä¹ˆç‚¹ dat[k].ls = init(dat[k].l, mid, cnt++); dat[k].rs = init(mid + 1, dat[k].r, cnt++); &#125; else &#123; dat[k].ls = init(dat[k].l, mid - 1, cnt++); dat[k].rs = init(mid, dat[k].r, cnt++); &#125; &#125; pushdown(k); update(a, b, dat[k].ls); update(a, b, dat[k].rs); dat[k].sum = dat[dat[k].ls].sum + dat[dat[k].rs].sum; &#125;&#125;int querry(int k, LL x) &#123; if (dat[k].ls == -1) &#123; return dat[k].l + (x + dat[k].num - 1) / dat[k].num - 1; &#125; else &#123; pushdown(k); if (dat[dat[k].ls].sum &gt;= x) &#123; return querry(dat[k].ls, x); &#125; else return querry(dat[k].rs, x - dat[dat[k].ls].sum); &#125;&#125;int main() &#123; f(); scanf("%lld", &amp;n); scanf("%lld%lld%lld%lld%lld%lld", &amp;x1, &amp;x2, &amp;a1, &amp;b1, &amp;c1, &amp;m1); scanf("%lld%lld%lld%lld%lld%lld", &amp;Y1, &amp;y2, &amp;a2, &amp;b2, &amp;c2, &amp;m2); ls[1] = min(x1, Y1) + 1, rs[1] = max(x1, Y1) + 1; ls[2] = min(x2, y2) + 1, rs[2] = max(x2, y2) + 1; xs[1] = x1, ys[1] = Y1; xs[2] = x2, ys[2] = y2; for (int i = 3; i &lt;= n; ++i) &#123; xs[i] = (1LL * a1 * xs[i - 1] + 1LL * b1 * xs[i - 2] + c1) % m1; ys[i] = (1LL * a2 * ys[i - 1] + 1LL * b2 * ys[i - 2] + c2) % m2; ls[i] = min(xs[i], ys[i]) + 1; rs[i] = max(xs[i], ys[i]) + 1; &#125; LL mi = 1e9 + 1, mx = -1; for (int i = 1; i &lt;= n; ++i) &#123; mx = max(mx, rs[i]); mi = min(mi, ls[i]); &#125; LL S = 0; build(mi, mx, 0); for (LL i = 1; i &lt;= n; i++) &#123; S += rs[i] - ls[i] + 1; update(ls[i], rs[i], 0); printf("%d\n", querry(0, (S+1) / 2)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>æ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>çº¿æ®µæ ‘</tag>
        <tag>ç¦»æ•£åŒ–</tag>
        <tag>ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 5 1002 three arrays]]></title>
    <url>%2F2019%2F08%2F09%2F2019-Multi-University-Training-Contest-5-1002-three-arrays%2F</url>
    <content type="text"><![CDATA[HDU 6625 three arraysé¢˜æ„ï¼š ç»™ä¸¤ä¸ªæ•°ç»„ï¼Œæ±‚ä¸¤ä¸ªæ•°ç»„ä¸¤ä¸¤å¼‚æˆ–åæœ€å°å­—å…¸åºã€‚é¢˜è§£ï¼š æ±‚å­—å…¸åºæœ€å°ï¼Œä¹Ÿå°±æ˜¯æ±‚å€¼æœ€å°ï¼Œå¦‚æœæ˜¯æ±‚ä¸€ä¸ªæ•°å’Œå¦ä¸€ä¸ªæ•°ç»„é‡Œé¢çš„ä¸€ä¸ªå€¼å¼‚æˆ–æœ€å°ï¼Œå¾ˆæ˜¾ç„¶å°±æ˜¯å­—å…¸æ ‘ï¼Œå°±æ˜¯åœ¨å­—å…¸æ ‘ä¸Šä¼˜å…ˆå–åŒä½ç›¸åŒï¼Œæ²¡æœ‰å†å–åŒä½ç›¸åã€‚æ±‚ä¸¤ä¸ªæ•°ç»„å¼‚æˆ–ä¹‹åå­—å…¸åºæœ€å°ï¼Œå…¶å®ä¹Ÿå¯ä»¥æŒ‰ç…§åŒæ ·çš„æ–¹æ³•æ±‚è§£ã€‚å¯¹ä¸¤ä¸ªæ•°ç»„åˆ†åˆ«åšæˆä¸€é¢—å­—å…¸æ ‘ï¼Œæ±‚ä¸¤é¢—çº¿æ®µæ ‘å¼‚æˆ–ä¹‹åå­—å…¸åºæœ€å°ï¼Œå°±æ˜¯ä¸¤é¢—æ ‘å¼‚æˆ–å€¼å°½å¯èƒ½å°ã€‚ä¸€å¼€å§‹æˆ‘æƒ³åˆ°è¿™ä¸ªå†™æ³•çš„æ—¶å€™ï¼Œé˜Ÿå‹è¯´å¦‚æœ0 0ï¼Œå’Œ1 1 å¼‚æˆ–éƒ½ç­‰äº0 å…ˆé€‰å“ªä¸€ä¸ªï¼Œä»”ç»†æ€è€ƒä¸€ä¸‹ï¼Œå…¶å®æ²¡æœ‰ä»€ä¹ˆå½±å“ï¼Œç»Ÿè®¡ä¸€ä¸‹ä¸¤é¢—æ ‘å½“å‰èŠ‚ç‚¹ä¸‹æ–¹ï¼Œ0 1 çš„ä¸ªæ•°ï¼Œä¼˜å…ˆæŠŠ 0 0 1 1 åŒ¹é…æ‰ï¼Œç„¶åå†æŠŠ0 1 1 0ä¸¤ç§åŒ¹é…æ‰ã€‚æœ‰ç‚¹åƒåœ¨å­—å…¸æ ‘ä¸Šè´ªå¿ƒ.å¤æ‚åº¦ä¸¤é¢—æ ‘æœ€å¤šæœ‰n*31ä¸ªèŠ‚ç‚¹ï¼Œæœ€å·®å°±æ˜¯æ¯ä¸ªæ ‘éƒ½è·‘ä¸€æ¬¡ï¼Œæ‰€ä»¥å¤æ‚åº¦æ˜¯$O(nlog(n))$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;int n;inline int getpos(int x, int pos) &#123; return ((x &gt;&gt; pos) &amp; 1);&#125;struct tree &#123; int a[maxn * 10][3]; int num[maxn * 10][3]; int root = 0; int cnt = 1; void init() &#123; cnt = 1; &#125; void insert(int x) &#123; int p = root, dep = 30; while (dep &gt;= 0) &#123; int nx = getpos(x, dep); if (num[p][nx] == 0) &#123; a[p][nx] = cnt++; num[p][nx] = 1; &#125; else &#123; num[p][nx]++; &#125; p = a[p][nx]; dep--; &#125; &#125;&#125; t1, t2;vector&lt;int&gt; v;template&lt;class T&gt;inline T min(T t1, T t2, T t3) &#123; return min(t1, min(t2, t3));&#125;void dfs(int now1, int now2, int num, int val, int dep) &#123; if (dep == -1) &#123; for (int i = 0; i &lt; num; i++) v.emplace_back(val); return; &#125; if (t1.num[now1][0] &gt; 0 &amp;&amp; t2.num[now2][0] &gt; 0 &amp;&amp; num &gt; 0) &#123; int ct = min(t2.num[now2][0], t1.num[now1][0], num); dfs(t1.a[now1][0], t2.a[now2][0], ct, val, dep - 1); t1.num[now1][0] -= ct; t2.num[now2][0] -= ct; num -= ct; &#125; if (t1.num[now1][1] &gt; 0 &amp;&amp; t2.num[now2][1] &gt; 0 &amp;&amp; num &gt; 0) &#123; int ct = min(t1.num[now1][1], t2.num[now2][1], num); dfs(t1.a[now1][1], t2.a[now2][1], ct, val, dep - 1); t1.num[now1][1] -= ct; t2.num[now2][1] -= ct; num -= ct; &#125; if (t1.num[now1][0] &gt; 0 &amp;&amp; t2.num[now2][1] &gt; 0 &amp;&amp; num &gt; 0) &#123; int ct = min(t2.num[now2][1], t1.num[now1][0], num); dfs(t1.a[now1][0], t2.a[now2][1], ct, val | (1 &lt;&lt; dep), dep - 1); t1.num[now1][0] -= ct; t2.num[now2][1] -= ct; num -= ct; &#125; if (t1.num[now1][1] &gt; 0 &amp;&amp; t2.num[now2][0] &gt; 0 &amp;&amp; num &gt; 0) &#123; int ct = min(t1.num[now1][1], t2.num[now2][0], num); dfs(t1.a[now1][1], t2.a[now2][0], ct, val | (1 &lt;&lt; dep), dep - 1); t1.num[now1][1] -= ct; t2.num[now2][0] -= ct; num -= ct; &#125;&#125;int main() &#123; f(); int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); t1.init(); t2.init(); for (int i = 0; i &lt; n; i++) &#123; int a; scanf("%d", &amp;a); t1.insert(a); &#125; for (int j = 0; j &lt; n; j++) &#123; int a; scanf("%d", &amp;a); t2.insert(a); &#125; v.clear();// debug(t2.num[29][1]); dfs(0, 0, n, 0, 30); sort(v.begin(), v.end()); for (int i = 0; i &lt; n; i++) &#123; printf("%d%c", v[i], i == n - 1 ? '\n' : ' '); &#125; &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "è¿è¡Œæ—¶é—´:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>æ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>æ­ç”µå¤šæ ¡</tag>
        <tag>å­—å…¸æ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å›æ–‡æ ‘]]></title>
    <url>%2F2019%2F08%2F07%2F%E5%9B%9E%E6%96%87%E6%A0%91%2F</url>
    <content type="text"><![CDATA[è¿™ä¸ªä¸œè¥¿å­¦ä¼šäº†ACè‡ªåŠ¨æœº ç†è§£è¿™ä¸ªåº”è¯¥ä¸éš¾ï¼ŒACè‡ªåŠ¨failæŒ‡é’ˆä¿å­˜äº†ä¸€ä¸ªæœ€é•¿åŒ¹é…åç¼€ï¼Œè¿™ä¸ªä¹Ÿå·®ä¸å¤šã€‚è¿™ä¸ªä¿å­˜äº†æœ€é•¿åŒ¹é…åç¼€å›æ–‡ä¸²ã€‚ä¸¾ä¸ªä¾‹å­è€å­æ‰¾äº†åŠå¤©æ²¡æ‰¾åˆ°åŸæœ¬çœ‹è¿‡çš„åšå®¢ï¼Œåªæ‰¾åˆ°äº†è¿™å¼ å›¾ç‰‡ã€‚éšä¾¿å†™å‡ å¥æ··ä¸€æ··å°±è¿‡å»äº†ã€‚å›æ–‡æ ‘é‡Œé¢çš„next å’Œå­—å…¸æ ‘å·®ä¸å¤šçš„æ„ä¹‰ï¼Œåªä¸è¿‡å­—å…¸æ ‘é‡Œé¢çš„ä¸€ä¸ªèŠ‚ç‚¹æ˜¯è¡¨ç¤ºåœ¨ä¸€ä¸ªèŠ‚ç‚¹åé¢åŠ ä¸Šä¸€ä¸ªå­—ç¬¦ï¼Œä½†nextæ˜¯å‰åå„åŠ ä¸€ä¸ªå­—ç¬¦,å°±æ˜¯tå˜æˆtc å’Œtå˜æˆctcçš„åŒºåˆ«ï¼Œå‰åå„åŠ ä¸€ä¸ªå­—ç¬¦è‚¯å®šæ˜¯å›æ–‡ä¸²ã€‚é‚£ä¹ˆé—®é¢˜æ¥äº†å¥‡æ•°çš„å›æ–‡ä¸²æ€ä¹ˆåŠï¼Œæ‰€ä»¥å‡ºç°å•Šäº†ä¸¤ä¸ªæ ¹èŠ‚ç‚¹ï¼Œä¸€ä¸ª0,ä¸€ä¸ª-1ï¼Œè¿åœ¨-1çš„è¡¨ç¤ºæ˜¯ä¸ªå¥‡æ•°ä¸ªæ•°çš„å›æ–‡ä¸²ï¼Œçœ‹ä»£ç é‡Œé¢çš„x-len[p]+1åˆšå¥½ä¹Ÿæ˜¯è‡ªå·±ï¼Œæ‰€ä»¥è‡ªå·±å’Œè‡ªå·±ä¸€å®šæ˜¯å›æ–‡ä¸²æ²¡å•¥æ¯›ç—…ã€‚å†ç»™ä¸ªå›¾failå·®ä¸å¤šå°±æ˜¯ä¸Šå›¾çš„æ„æ€.è§£é‡Šä¸‹ä¾‹å­æ€ä¹ˆæ„é€ çš„å¼€å§‹çš„æ—¶å€™å»ºç«‹ä¸¤ä¸ªæ ¹èŠ‚ç‚¹,ä¸¤ä¸ªæ ¹èŠ‚ç‚¹ä¸€ä¸ªé•¿åº¦ä¸º0,ä¸€ä¸ª-1ï¼Œå°†fail[0]=1,0è¡¨ç¤ºé•¿åº¦ä¸º0,1å·èŠ‚ç‚¹é•¿åº¦ä¸º-1,ä¸€å¼€å§‹åŠ å…¥aè‚¯å®šæ˜¯æ²¡æœ‰ä»»ä½•åç¼€ï¼Œç›´æ¥è¿ä¸Š-1æ ¹èŠ‚ç‚¹ï¼Œfailè‚¯å®šæ˜¯è¿ä¸Š0ï¼Œæ­¤æ—¶å½“å‰èŠ‚ç‚¹çš„å›æ–‡åç¼€æœ‰aï¼Œç©ºä¸²å’Œ-1ï¼Œç„¶åæ·»åŠ b,aèŠ‚ç‚¹å‰é¢å¾ˆæ˜¾ç„¶æ²¡æœ‰bï¼Œæ‰€ä»¥æ— æ³•åŒ¹é…ï¼Œç„¶ååŒ¹é…ç©ºä¸²ï¼Œç©ºä¸²å‰é¢æ˜¯aæ‰€ä»¥è¿˜æ˜¯æ²¡æ³•åŒ¹é…ï¼ŒåˆåŒ¹é…-1ï¼Œå¾ˆæ˜¾ç„¶è¿™ä¸ªä¸€å®šæ˜¯å¯ä»¥çš„ï¼Œå› ä¸ºå’Œè‡ªå·±è‚¯å®šæ˜¯ç›¸åŒçš„.ä¹Ÿå°±æ˜¯æ„å»ºäº†è¿™ä¸€éƒ¨åˆ†ã€‚ç„¶åä¸‹ä¸€ä¸ªå­—ç¬¦ä¸²è¿˜æ˜¯b,æ­¤æ—¶åç¼€æœ‰b,ç©ºä¸²å’Œ-1ï¼ŒåŒ¹é…åç¼€bå‰ä¸€ä¸ªæ˜¯aå¾ˆæ˜¾ç„¶ä¸åŒ¹é…ï¼ŒåŒ¹é…ç©ºä¸²,å‰ä¸€ä¸ªåˆšå¥½æ˜¯bæ‰€ä»¥æ­¤æ—¶ï¼Œå°†bbè¿åˆ°0èŠ‚ç‚¹ä¸‹é¢ï¼ŒfailæŒ‡å‘çˆ¶äº²èŠ‚ç‚¹å¤±é™ªçš„ç¬¬ä¸€ä¸ªèƒ½å¤ŸåŒ¹é…bçš„ä½ç½®ï¼Œè¿™ä¸ªæœ‰ç‚¹éš¾ç†è§£ã€‚åœ¨ä»£ç ä¸­æ˜¯è¿™ä¸€è¡Œã€‚ä¸‹ä¸€ä¸ªå­—ç¬¦æ˜¯aï¼Œæ­¤æ—¶å­—ç¬¦ä¸²æœ€é•¿å›æ–‡åç¼€æœ‰bb,b,ç©ºä¸²å’Œ-1,æ˜¾ç„¶bbå°±ç›´æ¥åŒ¹é…äº†ï¼Œç„¶åå†æ›´æ–°fail,å·®ä¸å¤šå°±æ˜¯è¿™ä¹ˆä¸ªè¿‡ç¨‹ã€‚å¤šä½™çš„ä¸è§£é‡Šçœ‹åˆ«äººåšå®¢å»å§ã€‚æƒ³æ·±å…¥äº†è§£ï¼Œå»çœ‹çœ‹ å›½å®¶é›†è®­é˜Ÿ2017å¹´çš„è®ºæ–‡ å§12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061namespace Palindromic_Tree &#123;const int MAXN = 1000010;const int N = 26;int next[MAXN][N];//nextæŒ‡é’ˆï¼ŒnextæŒ‡é’ˆå’Œå­—å…¸æ ‘ç±»ä¼¼ï¼ŒæŒ‡å‘çš„ä¸²ä¸ºå½“å‰ä¸²ä¸¤ç«¯åŠ ä¸ŠåŒä¸€ä¸ªå­—ç¬¦æ„æˆint fail[MAXN];//failæŒ‡é’ˆï¼Œå¤±é…åè·³è½¬åˆ°failæŒ‡é’ˆæŒ‡å‘çš„èŠ‚ç‚¹int cnt[MAXN];int num[MAXN];int len[MAXN];//len[i]è¡¨ç¤ºèŠ‚ç‚¹iè¡¨ç¤ºçš„å›æ–‡ä¸²çš„é•¿åº¦int S[MAXN];//å­˜æ”¾æ·»åŠ çš„å­—ç¬¦int last;//æŒ‡å‘ä¸Šä¸€ä¸ªå­—ç¬¦æ‰€åœ¨çš„èŠ‚ç‚¹ï¼Œæ–¹ä¾¿ä¸‹ä¸€æ¬¡addint n;//å­—ç¬¦æ•°ç»„æŒ‡é’ˆint p;//èŠ‚ç‚¹æŒ‡é’ˆint newnode(int l) &#123;//æ–°å»ºèŠ‚ç‚¹ for (int i = 0; i &lt; N; ++i) next[p][i] = 0; cnt[p] = 0; num[p] = 0; len[p] = l; return p++;&#125;void init() &#123;//åˆå§‹åŒ– p = 0; newnode(0); newnode(-1); last = 0; n = 0; S[n] = -1;//å¼€å¤´æ”¾ä¸€ä¸ªå­—ç¬¦é›†ä¸­æ²¡æœ‰çš„å­—ç¬¦ï¼Œå‡å°‘ç‰¹åˆ¤ fail[0] = 1;&#125;int get_fail(int x) &#123;//å’ŒKMPä¸€æ ·ï¼Œå¤±é…åæ‰¾ä¸€ä¸ªå°½é‡æœ€é•¿çš„ while (S[n - len[x] - 1] != S[n]) x = fail[x]; return x;&#125;int add(int c) &#123; c -= 'a'; S[++n] = c; int ct = 0; int cur = get_fail(last);//é€šè¿‡ä¸Šä¸€ä¸ªå›æ–‡ä¸²æ‰¾è¿™ä¸ªå›æ–‡ä¸²çš„åŒ¹é…ä½ç½® if (!next[cur][c]) &#123;//å¦‚æœè¿™ä¸ªå›æ–‡ä¸²æ²¡æœ‰å‡ºç°è¿‡ï¼Œè¯´æ˜å‡ºç°äº†ä¸€ä¸ªæ–°çš„æœ¬è´¨ä¸åŒçš„å›æ–‡ä¸² int now = newnode(len[cur] + 2);//æ–°å»ºèŠ‚ç‚¹ fail[now] = next[get_fail(fail[cur])][c];//å’ŒACè‡ªåŠ¨æœºä¸€æ ·å»ºç«‹failæŒ‡é’ˆï¼Œä»¥ä¾¿å¤±é…åè·³è½¬ next[cur][c] = now; num[now] = num[fail[now]] + 1; ct = num[now]; &#125; last = next[cur][c]; cnt[last]++; return num[last];&#125;void count() &#123; for (int i = p - 1; i &gt;= 0; --i) cnt[fail[i]] += cnt[i]; //çˆ¶äº²ç´¯åŠ å„¿å­çš„cntï¼Œå› ä¸ºå¦‚æœfail[v]=uï¼Œåˆ™uä¸€å®šæ˜¯vçš„å­å›æ–‡ä¸²ï¼&#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>å­—ç¬¦ä¸²</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>å›æ–‡æ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACè‡ªåŠ¨æœº]]></title>
    <url>%2F2019%2F08%2F07%2FAC%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[ACè‡ªåŠ¨æœºç”¨é€”ç»™å¤šä¸ªå­—ç¬¦ä¸²tï¼Œå†è¯¢é—®ä¸€ä¸ªå­—ç¬¦ä¸²sï¼Œé—®æœ‰å¤šå°‘ä¸ªå­—ç¬¦ä¸²tå‡ºç°åœ¨è¯¢é—®çš„å­—ç¬¦ä¸²sä¸­ã€‚ å‰ç½®æŠ€èƒ½å­¦ACè‡ªåŠ¨æœºä¹‹å‰ï¼Œå…ˆå­¦ä¼šä»€ä¹ˆæ˜¯å­—å…¸æ ‘ï¼Œä»€ä¹ˆæ˜¯kmpã€‚kmpæˆ‘å†™è¿‡ä¸€ç¯‡åšå®¢ï¼Œå°±ä¸è®²äº†ï¼Œå°±æ˜¯next æ•°ç»„ä¿å­˜ä¸€ä¸ªæœ€é•¿åŒ¹é…å‰ç¼€ã€‚å­—å…¸æ ‘å°±æ›´ç®€å•äº†ï¼Œæ¯ä¸ªèŠ‚ç‚¹ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œå‡ºç°ä¸€ä¸ªå­—ç¬¦å°±åœ¨çˆ¶äº²èŠ‚ç‚¹ä¸Šè¿ä¸Šä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä¹Ÿä¸å¤šè¯´ã€‚æœ‰éœ€è¦å†å†™ä¸€ç¯‡åšå®¢ã€‚ ACè‡ªåŠ¨æœºå¯¹äºè¿™ä¸ªç©æ„ï¼Œéƒ½è¯´æ˜¯å­—å…¸æ ‘ä¸Šè·‘KMP,åˆ°ä¹Ÿæ²¡é”™ã€‚æœ´ç´ KMPæ˜¯åœ¨ä¸€ä¸ªä¸²ä¸Šé¢è·‘next,è€ŒACè‡ªåŠ¨æœºåªæ˜¯å˜æˆäº†åœ¨å­—å…¸æ ‘èŠ‚ç‚¹ä¸Šè·‘failæŒ‡é’ˆï¼Œæ¯ä¸ªfailæŒ‡é’ˆä¿å­˜æ˜¯æœ€é•¿åŒ¹é…åç¼€ã€‚æ¨èä¸€åå¤§ä½¬åšå®¢ï¼Œè®²çš„æŒºä¸é”™çš„ã€‚æœ´ç´ çš„å†™æ³•ï¼Œæ¯ä¸€ä¸ªå­—ç¬¦ä¸²tå¯¹såšä¸€æ¬¡kmpç®—æ³•æˆ–è€… å¯¹æ‰€æœ‰çš„tå­—ç¬¦ä¸²å»ºä¸€é¢—å­—å…¸æ ‘ï¼Œç„¶åæ¯ä¸ªä½ç½®åŒ¹é…ä¸€ä¸‹ï¼Œå¾ˆæ˜¾ç„¶$O(n^2)$çš„å¤æ‚åº¦ï¼Œç»å¯¹è¶…æ—¶ã€‚ä»”ç»†æ€è€ƒä¸€ä¸‹ï¼Œå­—å…¸æ ‘é‡Œé¢ï¼Œæ¯æ¬¡åŒ¹é…éƒ½è¦ä»ä¸‹ä¸€ä¸ªä½ç½®å¼€å§‹è·‘ä¸€æ¬¡åŒ¹é…ï¼Œç±»æ¯”ä¸€ä¸‹æ²¡æœ‰kmpçš„æœ´ç´ å­—ç¬¦ä¸²åŒ¹é…ã€‚æ˜¯ä¸æ˜¯æœ‰ç‚¹ç›¸ä¼¼ã€‚æ™®é€šå•ä¸ªå­—ç¬¦ä¸²åŒ¹é…ï¼Œæ˜¯ä¸æ˜¯æšä¸¾æ¯ä¸€ä¸ªä½ç½®ï¼Œç„¶ååšä¸€æ¬¡æš´åŠ›åŒ¹é…ï¼Ÿç„¶åkmp åšäº†ä»€ä¹ˆï¼Œé€šè¿‡nextæ‰¾åˆ°æœ€å¤§åŒ¹é…å‰ç¼€ã€‚é‚£ä¹ˆæˆ‘ä»¬æ˜¯å¦å¯ä»¥åœ¨å­—å…¸æ ‘ç”¨failä¿å­˜æœ€å¤§åŒ¹é…åç¼€å‘¢ï¼Ÿæ˜¾ç„¶æ˜¯å¯ä»¥çš„ï¼Œä¸ç„¶ACè‡ªåŠ¨æœºå¹²å•¥.ä¸¾ä¸ªæ —å­ï¼š å‡è®¾æœ‰ä¸‰ä¸ªt asa aaa aas, åŒ¹é…aasabå­—å…¸æ ‘å»ºæˆè¿™ä¸ªæ ·å­ï¼Œä¸‘äº†ç‚¹ï¼Œåˆ«åœ¨æ„ï¼Œé‡åœ¨æ€æƒ³ã€‚ç„¶åä¸€å¼€å§‹å§aasåŒ¹é…æ‰äº†æ²¡å•¥æ„è§å§ï¼Œç„¶åç»§ç»­åŒ¹é…aasaï¼Œå¾ˆæ˜¾ç„¶è¿™ä¸ªæ—¶å€™æ²¡æœ‰è¿™ä¸ªå­—ç¬¦ä¸²ï¼Œé‚£ä¹ˆè‚¯å®šå°±è¦è½¬ç§»ï¼Œè½¬ç§»åˆ°å“ªå»å‘¢ï¼Ÿæœ€é•¿åŒ¹é…åç¼€å•Šã€‚å¦‚å›¾æ˜¯ä¸æ˜¯è¿™æ ·ã€‚ç„¶ååŒ¹é…asa,å†ç»§ç»­åŒ¹é…b,å¾ˆæ˜¾ç„¶å¤±é…äº†å•Šï¼Œç„¶åæ‰¾æœ€é•¿åŒ¹é…åç¼€ï¼Œåªæœ‰æ ¹èŠ‚ç‚¹äº†ï¼Œç„¶åæ ¹èŠ‚ç‚¹èƒŒååˆæ²¡æœ‰bã€‚æ‰€ä»¥å•¥éƒ½æ²¡äº†ï¼ŒåŒ¹é…æœ€é•¿åç¼€ä¸ºç©ºä¸²ã€‚å¥½äº†ï¼Œç°åœ¨å·®ä¸å¤šç†è§£è¿™ä¸ªç®—æ³•çš„æ€æƒ³ï¼Œæ¥ä¸‹æ¥å°±æ˜¯ä¸€äº›ç»†èŠ‚ï¼Œä¸çŸ¥é“æˆ‘è¿˜æœ‰æ²¡æœ‰æ²¡æœ‰è€ƒè™‘åˆ°çš„ï¼Œå¦‚æœæœ‰è¯·åœ¨è¯„è®ºåŒºæé—®ã€‚1.ä¸Šè¯‰æ‰€è®²çš„ä¾‹å­å¾ˆæ˜æ˜¾ï¼Œaaså‘asè·³è½¬ï¼Œå¦‚æœåç»§æ²¡æœ‰aè¿™ä¸ªèŠ‚ç‚¹æ€ä¹ˆåŠ?asa æ”¹æˆasb,asaè¦åŒ¹é…è°å‘¢ï¼Ÿè¿™ä¸ªåœ¨kmpç®—æ³•é‡Œé¢ä¹Ÿæœ‰è¿™ä¸ªé—®é¢˜ï¼Œå¾ˆæ˜¾ç„¶ï¼Œç»§ç»­æ‰¾ä¸‹å»å°±èƒ½è§£å†³é—®é¢˜ï¼Œå‡è®¾ å†åŠ ä¸€ä¸ªtsbï¼Œaasbé€‚é…ï¼Œaasè°ƒè½¬åˆ°asæ²¡æœ‰åç»§b,å†è·³è½¬åˆ°åŒ¹é…åç¼€sï¼Œæœ‰åç»§bå°±åŒ¹é…sbï¼Œç±»æ¨ï¼Œå¦‚æœè¿˜æ²¡æœ‰æ‰¾åˆ°å°±ç»§ç»­æƒ³ä¸Šæ‰¾ã€‚ps: è¿™ä¸ªåœ°æ–¹å¯ä»¥ä¼˜åŒ–ï¼ŒfailæŒ‡é’ˆæ‰¾åˆ°äº†æœ€é•¿åŒ¹é…åç¼€ï¼Œç„¶åå­—å…¸æ ‘çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹å¯ä»¥ç›´æ¥è·³åˆ°å¯¹åº”ä½ç½®å¦‚ä¾‹å­ aasåç»§aå¯ä»¥ç›´æ¥è·³åˆ°ä¸ºasaè¿™ä¸ªèŠ‚ç‚¹ï¼Œä¸è¿‡ä¸ä¼˜åŒ–ä¹Ÿæ²¡å•¥å½±å“ï¼Œå› ä¸ºå­—ç¬¦ä¸²é•¿åº¦æ˜¯å›ºå®šçš„ï¼Œæœ€å¤šä¸ä¼šè·³è¶…è¿‡næ¬¡ï¼Œä¸ä¼˜åŒ–åªæ˜¯å¤šäº†ä¸ªå¸¸æ•°2.å¤šä¸ªåŒ¹é…æ€ä¹ˆåŠï¼Ÿæ²¡åˆ°ä¸€ä¸ªèŠ‚ç‚¹æŠŠä»–çš„failæ‰¾ä¸‹å»è®°å½•ä¸ªæ•°ï¼Œå¦‚å›¾å­—å…¸æ ‘åŒ¹é…sa,çš„æ—¶å€™ä¼šæ‰¾ä»–çš„fail,æ‰¾åˆ°aç„¶åæŠŠaè¿™ä¸ªèŠ‚ç‚¹è®°å½•ï¼ŒåŒç†æ‰¾sab,ä¸ä»…ä»…æŠŠè‡ªå·±åŒ¹é…äº†ï¼Œè¿˜è¦æŠŠbåŒ¹é…æ‰3.æ€ä¹ˆè®°å½•ä¸ªæ•°ï¼Œå¦‚æœä¸€ä¸ªå­—ç¬¦ä¸²å¤šæ¬¡å‡ºç°æ€ä¹ˆåŠï¼Œçœ‹ä»£ç ï¼Œè®°å½•ä¸€ä¸‹å°±è¡Œäº†ã€‚ è¿™ä¸ªACè‡ªåŠ¨æœºçš„æ€æƒ³è¿˜æ˜¯è¦å­¦å¥½ï¼Œåé¢å›æ–‡è‡ªåŠ¨æœºè¦ç”¨åˆ°è¿™ä¸ªç©æ„çš„æ€æƒ³ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263namespace Aho_Corasick_Automaton &#123;int trie[maxn][27]; //å­—å…¸æ ‘int cntword[maxn]; //è®°å½•å•è¯å‡ºç°æ¬¡æ•°ï¼Œå¯ä»¥å¼€ä¸€ä¸ªvectorè®°å½•æ˜¯ç¬¬å‡ ä¸ªå•è¯int fail[maxn]; // å¤±è´¥å›æº¯int cnt=0; // æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°void init(int x) &#123; for(int i=0; i&lt;26; i++) &#123; trie[x][i]=0; &#125;&#125;void insertWords(char *s) &#123; int ls=strlen(s); int root=0; for(int i=0; i&lt;ls; i++) &#123; int next=s[i]-'a'; if(!trie[root][next]) &#123; init(++cnt); trie[root][next]=cnt; &#125; root=trie[root][next]; &#125; cntword[root]++;&#125;void getFial() &#123; queue&lt;int&gt; q; for(int i=0; i&lt;26; i++) &#123; if(trie[0][i]) &#123; fail[trie[0][i]]=0; q.push(trie[0][i]); &#125; &#125; while(q.size()) &#123; int now=q.front(); q.pop(); for(int i=0; i&lt;26; i++) &#123; if(trie[now][i]) &#123; fail[trie[now][i]]=trie[fail[now]][i]; q.push(trie[now][i]); &#125; else trie[now][i]=trie[fail[now]][i]; &#125; &#125;&#125;int query(char *s) &#123; int ls=strlen(s); int now =0,ans=0; for(int i=0; i&lt;ls; i++) &#123; now=trie[now][s[i]-'a']; for(int j=now; j&amp;&amp;cntword[j]!=-1; j=fail[j]) &#123; // å¦‚æœè¿™ç§çŠ¶æ€å·²ç»è®¡ç®—è¿‡äº†å°±ä¸ç”¨ç»§ç»­æ‰¾ä¸‹å»äº† ans+=cntword[j];//ç»Ÿè®¡ä¸ªæ•°ï¼Œå¯ä»¥åœ¨è¿™è¿›è¡Œå„ç§æ“ä½œ cntword[j]=-1; &#125; &#125; return ans;&#125;&#125; å†è´´ä¸€ä¸ªå¤§å“¥æ¿å­123456789101112131415161718192021222324252627282930313233343536373839queue&lt;int&gt;q;struct Aho_Corasick_Automaton &#123; int c[N][26],val[N],fail[N],cnt; void ins(char *s) &#123; int len=strlen(s); int now=0; for(int i=0; i&lt;len; i++) &#123; int v=s[i]-'a'; if(!c[now][v]) c[now][v]=++cnt; now=c[now][v]; &#125; val[now]++; &#125; void build() &#123; for(int i=0; i&lt;26; i++) if(c[0][i]) fail[c[0][i]]=0,q.push(c[0][i]); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=0; i&lt;26; i++) if(c[u][i]) fail[c[u][i]]=c[fail[u]][i],q.push(c[u][i]); else c[u][i]=c[fail[u]][i]; &#125; &#125; int query(char *s) &#123; int len=strlen(s); int now=0,ans=0; for(int i=0; i&lt;len; i++) &#123; now=c[now][s[i]-'a']; for(int t=now; t&amp;&amp;~val[t]; t=fail[t]) ans+=val[t],val[t]=-1; &#125; return ans; &#125;&#125; AC;]]></content>
      <categories>
        <category>ACM</category>
        <category>å­—ç¬¦ä¸²</category>
      </categories>
      <tags>
        <tag>ACè‡ªåŠ¨æœº</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 4-1003 Divide the Stones]]></title>
    <url>%2F2019%2F07%2F31%2F2019-Multi-University-Training-Contest-4-1003%2F</url>
    <content type="text"><![CDATA[HDU 6616 Divide the Stonesé¢˜æ„ï¼š ç»™ä¸€ä¸ªnå’Œä¸€ä¸ªkï¼Œå°†é‡é‡ä¸º[1,n]çš„çŸ³å­åˆ†æˆkå †ï¼Œæ¯å †é‡é‡ä¸€æ ·ã€‚é¢˜è§£ï¼š å…ˆå°†çŸ³å­åˆ†æˆn/kä»½ï¼Œæ¯”å¦‚15 3ï¼Œåˆ†æˆ1 2 34 5 67 8 910 11 1213 14 15ä¸éš¾çœ‹å‡ºå¦‚æœåˆšå¥½å¶æ•°åˆ†ï¼Œæ¯ä¸¤ä»½ç»„æˆä¸€ä¸ªï¼Œåˆ†é…ä¸€å®šæ˜¯åˆšå¥½åˆ†é…åˆç†çš„ï¼Œæ¯”å¦‚ä¸Šè¿°ä¾‹å­æ²¡æœ‰13 14 15,è‚¯å®šæ˜¯å‰ä¸¤ç»„åˆ†æˆ 1 6,2 5 3 4 åä¸¤ç»„7 12 8 11 9 10,è¿™æ ·ä¸€å®šæ˜¯å¹³åˆ†çš„ã€‚å¦‚æœæ˜¯å¥‡æ•°ï¼Œ&gt;3çš„ä»½æ•°ï¼Œä¾æ—§ä¸€æ ·çš„å¤„ç†ï¼Œ1 2 3å‰ä¸‰ä»½å†åˆ†æˆ3ç­‰ä»½ã€‚è¿™ä¸ªåˆ†æ³•æœ‰å¾ˆå¤šï¼Œæˆ‘æ‰¾äº†ä¸€ä¸ªæ¯”è¾ƒè¾£é¸¡çš„ã€‚ ç”»ä¸ªå›¾ç»™ä½ çœ‹ä¸‹å›¾ç»™ä½ äº†ï¼Œçœ‹ä¸çœ‹å¾—æ‡‚å°±æ˜¯ä½ çš„æ‚Ÿæ€§äº†ï¼Œå‘Šè¾.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;LL n, k;vector&lt;int&gt; v[maxn];vector&lt;LL&gt; ans[maxn];int main() &#123; int T; f(); scanf("%d", &amp;T); while (T--) &#123; scanf("%lld%lld", &amp;n, &amp;k); LL sum = n * (n + 1) / 2 / k; if (n == 1 &amp;&amp; k == 1) &#123; puts("yes\n1"); continue; &#125; if (n == k || n * (n + 1) / 2 % k != 0) &#123; puts("no"); &#125; else if (k == 1) &#123; puts("yes"); for (int i = 1; i &lt;= n; i++) &#123; printf("%d%c", i, i == n ? '\n' : ' '); &#125; &#125; else &#123; n /= k; int pos = 1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; k; j++) &#123; v[i].push_back(pos++); &#125; &#125; puts("yes"); if (n &amp; 1) &#123; for (int j = 4; j &lt;= n; j += 2) &#123; for (int i = 0; i &lt; k; i++) &#123; ans[i].push_back(v[j][i]); ans[i].push_back(v[j + 1][k - i - 1]); &#125; &#125; int j = k / 2 - 1; for (int i = 0; i &lt; k; i++) &#123; ans[i].push_back(v[3][i]); ans[i].push_back(v[2][(++j) % k]); &#125; for (int i = 0; i &lt; k; i++) &#123; LL temp = 0; for (int j = 0; j &lt; n; j++) &#123; if (j + 1 != n)temp += ans[i][j]; else ans[i].push_back(sum - temp); printf("%lld", ans[i][j]); if (j + 1 == n)printf("\n"); else printf(" "); &#125; ans[i].clear(); &#125; &#125; else &#123; for (int j = 1; j &lt;= n; j += 2) &#123; for (int i = 0; i &lt; k; i++) &#123; ans[i].push_back(v[j][i]); ans[i].push_back(v[j + 1][k - i - 1]); &#125; &#125; for (int i = 0; i &lt; k; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; printf("%lld", ans[i][j]); if (j + 1 == n)printf("\n"); else printf(" "); &#125; ans[i].clear(); &#125; &#125; &#125; for (int i = 0; i &lt;= n; i++) &#123; v[i].clear(); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>æ„é€ </category>
      </categories>
      <tags>
        <tag>æ­ç”µå¤šæ ¡</tag>
        <tag>æ„é€ </tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[åç¼€æ•°ç»„å’Œé«˜åº¦æ•°ç»„(LCP)å­¦ä¹ ç¬”è®°(æœ‰å‘)]]></title>
    <url>%2F2019%2F07%2F30%2F%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%92%8C%E9%AB%98%E5%BA%A6%E6%95%B0%E7%BB%84(LCP)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[åç¼€æ•°ç»„å­—ç¬¦ä¸²åç¼€ï¼ŒæŒ‡ä»å­—ç¬¦ä¸²æŸä¸ªä½ç½®å¼€å§‹åˆ°å­—ç¬¦ä¸²æœ«å°¾çš„å­—ä¸²ï¼ŒåŸä¸²å’Œç©ºä¸²ä¹Ÿæ˜¯åç¼€ã€‚åä¹‹å‰ç¼€ã€‚ç”¨saä¿å­˜å­—ç¬¦ä¸²å¼€å§‹çš„ä¸‹æ ‡ã€‚å­—ç¬¦ä¸²æ€»å…±æœ‰n+1ä¸ª,å­—ç¬¦ä¸²æ¯”è¾ƒå¤§å°æ˜¯$O(n)$çš„,æ‰€ä»¥ç›´æ¥ç”¨sortç›´æ¥æ’åºæ˜¯$O(n^2log(n))$,å¾ˆæ˜¾ç„¶ä¸åˆç†ã€‚ ä¼˜åŒ–ä¸€ hashä¼˜åŒ–æŠŠå­—ç¬¦ä¸²hashå¤„ç†,ä¿®æ”¹sortæ’åºæ–¹å¼ï¼Œæ¯”è¾ƒä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œå…ˆäºŒåˆ†æœ€é•¿å‰ç¼€ï¼Œæ¯”è¾ƒä¸¤ä¸ªå­—ç¬¦ä¸²hashå¤„ç†æ˜¯$O(1)$çš„ï¼Œç„¶åæ¯”è¾ƒç¬¬ä¸€ä¸ªä½ç½®ä¸åŒçš„åœ°æ–¹å°±è¡Œäº†ã€‚å¤æ‚åº¦$(O(nlog^2(n)))$,ä½†æ˜¯hashå¯èƒ½ä¼šæœ‰å†²çª. ä¼˜åŒ–äºŒ å€å¢ä¼˜åŒ–å‡è®¾ä¸€ä¸ªå­—ç¬¦ä¸²abaca12345acaacabacaabaca åç¼€å¦‚ä¸Šä¸€å¼€å§‹æ¯”è¾ƒå¯ä»¥å¾—å‡º,a&lt;b&lt;cå¾—åˆ°ä¸€ä¸ªrankå¯ä»¥è¡¨ç¤ºä¸ºå­—ç¬¦å¤§å°,ç„¶åæ ¹æ®è¿™ä¸ªæ’åºåç¼€æ•°ç»„ã€‚123456789a=0b=1c=2//å­—ç¬¦ä¸²å°±æ˜¯aaabc ç„¶åå¼€å§‹å€å¢ï¼Œæ¯”è¾ƒé•¿åº¦2ï¼Œç”±äºå·²ç»çŸ¥é“äº†a,b,cï¼Œé•¿åº¦ä¸º1çš„å¤§å°æ‰€ä»¥å¯ä»¥ç›´æ¥æ¯”è¾ƒï¼Œç¬¬ä¸€ä¸ªé•¿åº¦1ï¼Œçš„å¤§å°ï¼Œå†æ¯”è¾ƒç¬¬äºŒä¸ªé•¿åº¦ä¸º1çš„å¤§å°æœ€ç»ˆå¯ä»¥å¾—å‡ºa&lt;ab&lt;ac&lt;ba&lt;ca1234567891011a=0ab=1ac=2ba=3ca=4//å­—ç¬¦ä¸²aabacbaca è¯¦ç»†æ¨æ–­è§ ç™½ä¹¦P378ä¾æ¬¡ç±»æ¨å°±è¡Œäº†ï¼Œè¯¦æƒ…è§ä»£ç è¿™ä¸ªåœ°æ–¹æ’åºå¯ä»¥ç”¨åŸºæ•°æ’åºï¼Œå°†å¤æ‚åº¦ä¼˜åŒ–åˆ°$O(nlog(n))$ ä¼˜åŒ–ä¸‰ SA-ISæŒ–ä¸‹å‘ä»¥åå¡«ï¼Œå¦å¤–è¿˜æœ‰DC3ç®—æ³•$O(n)$çš„å¤æ‚åº¦ï¼Œä½†æ˜¯DC3å¸¸æ•°å¤ªå¤§. é«˜åº¦æ•°ç»„è¿™ä¸ªå¤„ç†ä¹Ÿéå¸¸å·§å¦™ï¼Œæˆ‘è§‰å¾—å­—ç¬¦ä¸²å¤„ç†éƒ½å¾ˆæœ‰æ„æ€ã€‚å‡è®¾ä¸€ä¸ªå­—ç¬¦ä¸²abracadabraä¸€å¼€å§‹å¤„ç†å‡ºsa æ•°ç»„ä½ å¯ä»¥å‘ç°ä¸€ä¸ªå¾ˆæœ‰æ„æ€çš„äº‹ä¸€å¼€å§‹åŒ¹é…å’Œsa[0] æœ€å¤§çš„é‚£ä¸€ä¸ªï¼Œä¹Ÿå°±æ˜¯åŸä¸²ã€‚abracadabra åç¼€æ’åºåæ¯”ä»–å°çš„æ’åºåæ¯”ä»–å°çš„ç¬¬ä¸€ä¸ªsa[7]å°±æ˜¯abraä¸éš¾çœ‹å‡ºæ¥ï¼Œå‰ç¼€å°±æ˜¯4ä¸ªã€‚sa[1] bracadabra åŒ¹é… sa[8] braå‘ç°äº†æ²¡æœ‰ï¼Œåˆšå¥½å°±æ˜¯ å‰é¢çš„å‡å»ä¸€ä¸ªåˆšå¥½3ä¸ªã€‚ç„¶åç»§ç»­åŒ¹é…sa[2] racadabra sa[9] raåˆšå¥½2ä¸ª,ç„¶åç»§ç»­sa[3] acadabra sa[0] abracadabraåˆšå¥½1ä¸ªã€‚æ‰€ä»¥sa[i] åŒ¹é…sa[k],è™½ç„¶ä¸‹ä¸€ä¸ªsa[i+1] ä¸ä¸€å®šåŒ¹é…sa[k+1] ,ä½†æ˜¯åŒ¹é…ä¸ªæ•°ä¸€å®šè‡³å°‘æ˜¯$h_i-1$ä¸ªï¼Œç„¶åæˆ‘ä»¬å¯ä»¥ç›´æ¥ä»$h_i-1$å¼€å§‹åŒ¹é…å°±å¥½äº†ã€‚æœ€å¤šå¢åŠ ä¸ä¼šè¶…è¿‡næ¬¡ï¼Œæ‰€ä»¥å¤æ‚åº¦æ˜¯$O(n)$çš„ã€‚è¯¦æƒ…è§ ç™½ä¹¦382 æ¨èä¹ é¢˜POJ 2217 SecretaryPOJ 3581 Sequencespoj spoj 694 Distinct Substrings æ•´ç†æ¿å­123456789101112131415161718192021222324252627282930313233343536373839404142434445464748namespace My &#123; int Rank[maxn + 1], tmp[maxn + 1]; int k, n; bool compare_sa(const int &amp;i, const int &amp;j) &#123; if (Rank[i] != Rank[j])return Rank[i] &lt; Rank[j]; //è¿™ä¸ªåœ°æ–¹å¾ˆå·§å¦™ï¼Œæ¯”è¾ƒå‰k else &#123; int ri = i + k &lt;= n ? Rank[i + k] : -1; //å¦‚æœåŠ ä¸ŠååŠéƒ¨åˆ†è¶…è¿‡nï¼Œå°±ç›´æ¥ç®—æœ€å°ã€‚ int rj = j + k &lt;= n ? Rank[j + k] : -1; return ri &lt; rj; &#125; &#125; template&lt;class T&gt; void construct_sa(T *S, int _n, int *sa) &#123; n = _n; for (int i = 0; i &lt;= n; i++) &#123; sa[i] = i; Rank[i] = i &lt; n ? S[i] : -1; &#125; for (k = 1; k &lt;= n; k *= 2) &#123; sort(sa, sa + n + 1, compare_sa); tmp[sa[0]] = 0; for (int i = 1; i &lt;= n; i++) &#123; tmp[sa[i]] = tmp[sa[i - 1]] + compare_sa(sa[i - 1], sa[i]); //å¦‚æœä¸¤ä¸ªç›¸ç­‰è¯´æ˜å‰kç›¸ç­‰ï¼Œå°±åƒåœ¨åŒä¸€ä¸ªæ¡¶é‡Œä¸€æ ·ã€‚ &#125; for (int i = 0; i &lt;= n; i++) &#123; Rank[i] = tmp[i]; &#125; &#125; &#125; template&lt;class T&gt; void construct_lcp(T *S, int _n, int *sa, int *lcp) &#123; n = _n; for (int i = 0; i &lt;= n; i++)Rank[sa[i]] = i; int h = 0; lcp[0] = 0; for (int i = 0; i &lt; n; i++) &#123; int j = sa[Rank[i] - 1]; if (h &gt; 0)h--; for (; j + h &lt; n &amp;&amp; i + h &lt; n; h++) &#123; if (S[j + h] != S[i + h])break; &#125; lcp[Rank[i] - 1] = h; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>å­—ç¬¦ä¸²</category>
      </categories>
      <tags>
        <tag>ç¬”è®°</tag>
        <tag>åç¼€æ•°ç»„</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 3 1011 Squrirrel]]></title>
    <url>%2F2019%2F07%2F30%2F2019-Multi-University-Training-Contest-3-1011%2F</url>
    <content type="text"><![CDATA[HDU 6613 Squrirrelé¢˜æ„ï¼š å¯ä»¥åˆå¹¶æ ‘ä¸Šä¸¤ä¸ªç‚¹ï¼Œåˆå¹¶ä¸¤ä¸ªç‚¹è®©æŸä¸€ä¸ªç‚¹åˆ°ç¦»ä»–æœ€è¿œçš„è·ç¦»æœ€å°ï¼Œå¦‚æœæœ‰å¤šä¸ªç­”æ¡ˆè¾“å‡ºå­—å…¸åºæœ€å°çš„ã€‚é¢˜è§£ï¼š é¦–å…ˆä»å¶å­èŠ‚ç‚¹å¾€æ ¹èŠ‚ç‚¹è·‘ï¼Œä¿å­˜æ¯ä¸ªåˆ°è¿™ä¸ªç‚¹çš„æœ€å¤§è·ç¦»ï¼Œå’Œå„¿å­èŠ‚ç‚¹åˆ æ‰ä¸€æ¡è¾¹ä¹‹åæœ€å¤§è·ç¦»çš„æœ€å°å€¼ã€‚ï¼ˆè‚¯å®šæ˜¯ä»æœ€å¤§è·¯å¾„ä¸Šåˆ ä¸€æ¡è¾¹ï¼‰æˆ‘ä¸ºäº†ä¿é™©å…¨åˆ¤æ–­äº† ã€‚ç„¶åå†ä»æ ¹èŠ‚ç‚¹å¾€å„¿å­èŠ‚ç‚¹è·‘ï¼Œæ¯æ¬¡ä¿å­˜ä¸€ä¸ªï¼Œæœ€å¤§ï¼Œæ¬¡å¤§ï¼Œç¬¬ä¸‰å¤§ï¼Œå…·ä½“ä¸ºä»€ä¹ˆçœ‹ä»£ç æ³¨é‡Šã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 2e5 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;int ans1;vector&lt;int&gt; G[maxn];vector&lt;int&gt; cost[maxn];int dp[maxn];int mi[maxn];int in[maxn];int used[maxn];int ans2 = inf;void dfs(int r, int p, int mx, int cmi, int c) &#123; cmi = min(cmi + c, mx); mx = mx + c; int temp = min(max(mx, mi[r]), max(cmi, dp[r])); if (ans2 &gt; temp) &#123; ans2 = temp; ans1 = r; &#125; if (ans2 == temp) &#123; ans2 = temp; ans1 = min(ans1, r); &#125;// cout &lt;&lt; "r=" &lt;&lt; r &lt;&lt; "mx=" &lt;&lt; mx &lt;&lt; "mi=" &lt;&lt; cmi &lt;&lt; endl;// int temp = min(max(dp[r], cmi), max(mi[r], mx));// if (ans2 &gt; temp) &#123;// ans2 = min(max(dp[r], cmi), max(mi[r], mx));// ans1 = r;// &#125; else if (ans2 == temp)ans1 = min(r, ans1); int mx1 = mx, mx2 = 0, mx3 = 0, mi2 = -1, mi1 = p, mi3 = -1, vmi1 = cmi, vmi2 = 0, vmi3 = 0; //è®°å½•æœ€å¤§ï¼Œæ¬¡å¤§ï¼Œç¬¬ä¸‰å¤§ for (int i = 0; i &lt; G[r].size(); i++) &#123; int au = G[r][i]; int c = dp[au] + cost[r][i]; if (au == p) continue; temp = min(dp[au], mi[au] + cost[r][i]); if (mx1 &lt;= c) &#123; swap(mx1, c); swap(mi1, au); swap(vmi1, temp); &#125; if (mx2 &lt;= c) &#123; swap(mx2, c); swap(mi2, au); swap(vmi2, temp); &#125; if (mx3 &lt;= c) &#123; swap(mx3, c); swap(mi3, au); swap(vmi3, temp); &#125; &#125; for (int i = 0; i &lt; G[r].size(); i++) &#123; int au = G[r][i]; int c = cost[r][i]; if (au == p)continue; if (au == mi1) &#123; if (mi3 == -1)dfs(au, r, mx2, vmi2, c); else dfs(au, r, mx2, max(vmi2, mx3), c); //å¦‚æœæ˜¯å¾€æœ€å¤§çš„è·¯å¾„èµ°ï¼Œå°±æ˜¯åœ¨æ¬¡å¤§çš„è·¯ä¸Šåˆ ä¸€æ¡è¾¹å†å’Œç¬¬ä¸‰å¤§æ¯”è¾ƒ &#125; else if (au == mi2) &#123; if (mi3 == -1)dfs(au, r, mx1, vmi1, c); else dfs(au, r, mx1, max(vmi1, mx3), c); //å¦‚æœæ˜¯å¾€ç¬¬äºŒå¤§çš„ï¼Œå°±æ˜¯åœ¨æœ€å¤§è·¯ä¸Šåˆ ä¸€æ¡è¾¹å†å’Œç¬¬ä¸‰å¤§æ¯”è¾ƒ &#125; else dfs(au, r, mx1, max(vmi1, mx2), c); // å…¶ä»–çš„è‚¯å®šéƒ½æ˜¯åˆ æœ€å¤§çš„è·¯å¾„ä¸€æ¡è¾¹ å†å’Œç¬¬äºŒå¤§æ¯”è¾ƒ &#125;&#125;int main() &#123; f(); int n; int t; scanf("%d", &amp;t); while (t--) &#123; scanf("%d", &amp;n); for (int i = 1; i &lt; n; i++) &#123; int u, v, c; scanf("%d%d%d", &amp;u, &amp;v, &amp;c); G[u].emplace_back(v); cost[u].emplace_back(c); G[v].emplace_back(u); cost[v].emplace_back(c); in[u]++; in[v]++; &#125; queue&lt;int&gt; q; for (int i = 1; i &lt;= n; i++) &#123; dp[i] = 0; if (in[i] == 1) &#123; q.push(i); mi[i] = 0; &#125; else mi[i] = inf; &#125; int r = -1; ans1 = 0; ans2 = inf; while (q.size()) &#123; int v = q.front(); q.pop(); r = v; if (used[v] == 0)used[v] = 1; else continue; int mx1 = 0, mx2 = 0; for (int i = 0; i &lt; G[r].size(); i++) &#123; int au = G[r][i]; int c = dp[au] + cost[r][i]; if (!used[au])continue; if (mx1 &lt; c)swap(mx1, c); if (mx2 &lt; c)swap(mx2, c); &#125; for (int i = 0; i &lt; G[r].size(); i++) &#123; int au = G[r][i]; int c = cost[r][i]; if (!used[au])continue; if (dp[au] + c == mx1) &#123; mi[r] = min(mi[r], max(min(dp[au], mi[au] + c), mx2)); //è¿™ä¸ªè‚¯å®šå°±æ˜¯æœ€å°çš„ &#125; else mi[r] = min(mi[r], max(min(dp[au], mi[au] + c), mx1)); //è¿™ä¸ªå¯ä»¥ä¸è¦ &#125; for (int i = 0; i &lt; G[v].size(); i++) &#123; int &amp;au = G[v][i], &amp;c = cost[v][i]; in[au]--; if (used[au] == 0) &#123; dp[au] = max(dp[r] + c, dp[au]); if (in[au] == 1)q.push(au); &#125; &#125; &#125;// for (int i = 1; i &lt;= n; i++) &#123;// printf("[%d]= %d %d\n", i, dp[i], mi[i]);// &#125; if (n == 1 || n == 2)printf("%d %d\n", 1, 0); else &#123; dfs(r, -1, 0, 0, 0); printf("%d %d\n", ans1, ans2); for (int i = 1; i &lt;= n; i++) &#123; used[i] = 0; in[i] = 0; G[i].clear(); cost[i].clear(); &#125; &#125; &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "è¿è¡Œæ—¶é—´:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>åŠ¨æ€è§„åˆ’</category>
      </categories>
      <tags>
        <tag>æ­ç”µå¤šæ ¡</tag>
        <tag>æ ‘å½¢DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 1 1001 Blank]]></title>
    <url>%2F2019%2F07%2F27%2F2019-Multi-University-Training-Contest-1-1001%2F</url>
    <content type="text"><![CDATA[HDU 6578 Blanké¢˜æ„ï¼š ç»™å®š1,N çš„ä½ç½®ï¼Œæ¯ä¸ªä½ç½®å¯ä»¥å¡«1,2,3,4å…¶ä¸­ä¸€ä¸ªï¼Œç»™mä¸ªåŒºé—´[l,r] x ï¼Œé™åˆ¶[l,r]åŒºé—´å†…åªæœ‰xç§ä¸åŒçš„æ•°ã€‚é¢˜è§£ï¼š néå¸¸å°ï¼Œåªæœ‰100ï¼Œå¯ä»¥ç›´æ¥ç”¨æ•°ç»„æšä¸¾ä¸Šä¸€ä¸ªæ•°å‡ºç°çš„ä½ç½®ï¼Œæ¯ä¸ªä½ç½®æš´åŠ›å¡«å°±è¡Œäº†ã€‚ç›´æ¥$O(n^4)$ä¼šTï¼Œã€‚ï¼Œå¿…é¡»è¦å‰Šå¸¸æ•°ã€‚å¯ä»¥å‘ç°å‡ºç°æ˜¯ä»€ä¹ˆæ•°æœ¬èº«ä¸é‡è¦ï¼Œåªå’Œä½ç½®æœ‰å…³ã€‚ç„¶åæœ€å¤§çš„é‚£ä¸ªä½ç½®ï¼Œä¸€å®šæ˜¯ä½ è¦å¡«çš„è¿™ä¸ªpos-1,æ‰€ä»¥dpç©ºé—´å¯ä»¥ä¼˜åŒ–ä¸€ç»´ï¼Œdp[i][j][k],ä»£è¡¨æ’åºåä½ç½®åˆ†åˆ«æ˜¯i&lt;j&lt;k&lt;pos-1ï¼Œç„¶åæšä¸¾çš„çŠ¶æ€ä¹Ÿæ˜¯i&lt;j&lt;k&lt;pos-1 ï¼Œå¯¹äºé™åˆ¶æ¡ä»¶ï¼Œåˆ¤æ–­ä¸€ä¸‹çŠ¶æ€åˆä¸åˆæ³•å°±è¡Œäº†ã€‚å¯¹äºæŸä¸ªposåˆ°äº†[l,r] x,rçš„ä½ç½®,åˆ¤æ–­ä¸€ä¸‹å°±è¡Œäº†ï¼Œè¿™ä¸ªä¸å½±å“å¤æ‚åº¦ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;unordered_map&gt;#include&lt;unordered_set&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;(x)&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a, b) memset(a,b,sizeof(a));const long long mod = 998244353;const int maxn = 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif // ONLIN_JUDGE&#125;LL dp[105][105][105][2];struct node &#123; int l, r, x; bool operator&lt;(node &amp;t) const &#123; if (r == t.r)return l &lt; t.l; return r &lt; t.r; &#125;&#125; dat[maxn];int n, m;void check(LL &amp;x) &#123; x %= mod;&#125;int main() &#123; f(); int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d", &amp;dat[i].l, &amp;dat[i].r, &amp;dat[i].x); dat[i].l += 3; dat[i].r += 3; &#125; dp[0][1][2][1] = 1; sort(dat + 1, dat + m + 1); int l = 1, p = 0; for (int pos = 4; pos &lt;= n + 3; pos++, p = !p) &#123; for (int i = 0; i &lt;= pos - 4; i++) &#123; for (int j = i + 1; j &lt;= pos - 3; j++) &#123; for (int k = j + 1; k &lt;= pos - 2; ++k) &#123; int flag = 0, temp = l; while (temp &lt;= m &amp;&amp; pos - 1 == dat[temp].r) &#123; if (dat[temp].x == 1 &amp;&amp; dat[temp].l &lt;= k) &#123; flag = 1; &#125; if (dat[temp].x == 2 &amp;&amp; (dat[temp].l &lt;= j || dat[temp].l &gt; k)) &#123; flag = 1; &#125; if (dat[temp].x == 3 &amp;&amp; (dat[temp].l &lt;= i || dat[temp].l &gt; j))flag = 1; if (dat[temp].x == 4 &amp;&amp; dat[temp].l &gt; i)flag = 1; temp++; &#125; if (flag) &#123; dp[i][j][k][!p] = 0; continue; &#125; dp[j][k][pos - 1][p] += dp[i][j][k][!p]; check(dp[j][k][pos - 1][p]); dp[i][k][pos - 1][p] += dp[i][j][k][!p]; check(dp[i][j][pos - 1][p]); dp[i][j][pos - 1][p] += dp[i][j][k][!p]; check(dp[i][j][pos - 1][p]); dp[i][j][k][p] += dp[i][j][k][!p]; check(dp[i][j][k][p]); dp[i][j][k][!p] = 0; &#125; &#125; &#125; while (l &lt;= m &amp;&amp; dat[l].r == pos - 1)l++; &#125; LL ans = 0; for (int i = 0; i &lt;= n + 3; i++) &#123; for (int j = i + 1; j &lt;= n + 3; j++) &#123; for (int k = j + 1; k &lt;= n + 3; ++k) &#123; int flag = 0, temp = l; while (temp &lt;= m) &#123; if (dat[temp].x == 1 &amp;&amp; dat[temp].l &lt;= k) &#123; flag = 1; &#125; if (dat[temp].x == 2 &amp;&amp; (dat[temp].l &lt;= j || dat[temp].l &gt; k)) &#123; flag = 1; &#125; if (dat[temp].x == 3 &amp;&amp; (dat[temp].l &lt;= i || dat[temp].l &gt; j))flag = 1; if (dat[temp].x == 4 &amp;&amp; dat[temp].l &gt; i)flag = 1; temp++; &#125; if (flag) &#123; dp[i][j][k][!p] = 0; continue; &#125; ans = (ans + dp[i][j][k][!p] % mod) % mod; dp[i][j][k][!p] = 0; &#125; &#125; &#125; printf("%lld\n", ans); &#125; return 0;&#125;/*61 0410 0104857611 0419430420 044459512330 068215596540 0382013690 */]]></content>
      <categories>
        <category>ACM</category>
        <category>åŠ¨æ€è§„åˆ’</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>æ­ç”µå¤šæ ¡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å•è°ƒæ ˆå’Œå•è°ƒé˜Ÿåˆ—]]></title>
    <url>%2F2019%2F07%2F26%2F%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[ç†è§£å•è°ƒæ ˆå’Œå•å•è°ƒé˜Ÿåˆ—ä¹‹å‰ï¼Œè¦æ˜ç™½ä¸€ç§æŠ€å·§ï¼Œå«åšå°ºå–æ³•ã€‚ å°ºå–æ³•å°ºå–æ³•ï¼Œä¸¤ä¸ªä½ç½®ï¼Œä¸€ä¸ªæ˜¯lï¼Œä¸€ä¸ªr,rä¸€ä½ä½çš„å·¦ç§»ï¼Œlæ ¹æ®æ¡ä»¶å·¦ç§»ã€‚æ¯”å¦‚POJ 3061æ±‚æœ€å¤§è¿ç»­å­—ä¸²å’Œä¸è¶…è¿‡sl råˆå§‹åŒ–ä¸º0,rå·¦ç§»ï¼Œæ€»å’ŒåŠ ä¸Šrä½ç½®çš„å€¼ï¼Œå¦‚æœæ€»å’Œä¸€æ—¦å¤§äºs,lå¼€å§‹å·¦ç§»ï¼Œç›´åˆ°æ»¡è¶³[l,r]åŒºé—´çš„æ€»å’Œå°äºsï¼Œè¿™ç§é€šè¿‡l,råå¤æ¨è¿›çš„æ–¹æ³•ï¼Œå°±å«å°ºå–æ³•ã€‚ ç»†å¿ƒçš„äººå¯ä»¥å‘ç°ï¼Œè¿™ç§æ–¹æ³•ï¼Œæ±‚ç»“æœä¸€å®šè¦æ»¡è¶³ï¼Œå³è¾¹ä¸€ä¸ªä½ç½®è·¨è¿‡råˆ°lä¸€å®šæ˜¯ä¸åˆæ³•çš„çš„æƒ…å†µã€‚ å•è°ƒæ ˆå…¶å®è¿™ä¸ªå’Œå°ºå–æ³•å…³ç³»ä¸å¤§ã€‚ã€‚ã€‚ã€‚å•è°ƒæ ˆ,ç”¨äºæ±‚æœ€å·¦è¾¹ï¼ˆå³è¾¹ï¼‰çš„ç¬¬ä¸€ä¸ªæ»¡è¶³æŸç§å…·æœ‰å•è°ƒæ€§è´¨æ¡ä»¶ï¼ˆæ¯”å¦‚å¤§äºï¼Œå°äºï¼‰çš„ä½ç½®ã€‚è·ç¦»ï¼Œæ±‚ç¬¬ä¸€ä¸ªå¤§äºçš„ä½ç½®ã€‚æ±‚å¤§äºï¼Œå°†ä¸å¤§äºçš„æ•°å…¨éƒ¨åŠ å…¥å•è°ƒæ ˆé‡Œé¢ï¼Œä¿è¯æ ˆå•è°ƒé€’å‡ï¼Œï¼ˆä¸‹é¢è·ç¦»æ ˆä¸­å­˜çš„æ˜¯å°æ ‡,æ³¨æ„åŒºåˆ†å€¼å’Œä¸‹æ ‡ï¼‰å‡è®¾æœ‰1 3 5 2 1 4 7 6ä¸€å¼€å§‹æ ˆä¸ºç©ºï¼Œå°†ç¬¬ä¸€ä¸ªæ•°ä½ç½®åŠ è¿›å»ï¼Œæ­¤æ—¶æ ˆä¸­æœ‰ä¸‹æ ‡1åˆ°ç¬¬äºŒä¸ªæ•° 3 ï¼Œæ ˆé¡¶ ä½ç½®çš„å€¼ å°äº3å¼¹å‡ºï¼Œèµ‹å€¼ä½ç½®å³è¾¹ç¬¬ä¸€ä¸ªå¤§äºä»–çš„æ•°ä¸‹æ ‡æ˜¯2ï¼Œç„¶åæ ˆä¸ºç©ºï¼Œå°†2å·ä½ç½®åŠ å…¥æ ˆï¼Œä¾æ¬¡ç±»æ¨.åˆ°5 å¼¹å‡ºä¸‹æ ‡2 åŠ å…¥ä¸‹æ ‡3,åˆ° 2 å› ä¸ºæ ˆé¡¶ä½ç½®çš„å€¼å¤§äº2ä¸å¼¹å‡ºï¼Œç›´åˆ°4 å¼¹å‡ºå€¼2,1ï¼Œä¸å¼¹å‡º5ã€‚å½“å‰å€¼æ¯”æ ˆé¡¶çš„æ•°å¤§ï¼Œå¼¹å‡ºæ ˆé¡¶çš„å€¼ï¼Œå¹¶èµ‹å€¼ï¼Œå¦åˆ™åŠ å…¥æ ˆã€‚ å•è°ƒé˜Ÿåˆ—å•è°ƒé˜Ÿåˆ—å’Œå°ºå–æ³•ç”¨ç‚¹åƒï¼Œå’Œå•è°ƒæ ˆä¹Ÿå·®è·ä¸å¤§ã€‚æ€»ç»“æ¥è¯´ï¼Œä½ç½®å°ºå–ï¼Œé˜Ÿåˆ—å•è°ƒï¼Œå°±æƒ³å°ºå–æ³•å’Œå•è°ƒæ ˆçš„ç»“åˆä½“ã€‚ä¾‹å­ HDU 3530æŒ‰é¢˜ç›®æ¥è®²ï¼š æŸ¥å¯»åŒºé—´æœ€å¤§æœ€å°å€¼ä¹‹å·®åœ¨[m,k]ä¹‹é—´çš„æœ€å¤§é•¿åº¦ã€‚ç°æŒ‰ç…§å°ºå–çš„æ–¹æ³•æ¥ï¼šä¸æ–­ç§»åŠ¨ï¼Œlï¼Œr,è™½ç„¶ä»åœ¨rå³è¾¹è·¨è¿‡r åˆ°l æœ€å¤§æœ€å°å€¼ä¹‹å·®ç»å¯¹æ˜¯å¤§äºç­‰äº[r,l]ä¹‹é—´çš„,ä½†æ˜¯æœ€å¤§æœ€å°ä¸å¯èƒ½ä¸€ç›´æ˜¯ç«¯ç‚¹ï¼Œå¯èƒ½[r,l]ä¹‹é—´å­˜åœ¨æ¯”r,lå¤§æˆ–è€…å°çš„å€¼ã€‚é‚£ä¹ˆè¯¥å¦‚ä½•å¤„ç†å‘¢ï¼Œå•è°ƒæ ˆå¯ä»¥ä¿å­˜ä¸€ä¸ªå•è°ƒçš„å­åºåˆ—ï¼Œæˆ‘ä»¬æ˜¯å¦èƒ½å’Œä»–ä¸€æ ·ä¿å­˜[l,r],çš„å•å¢å­åºåˆ—å‘¢ï¼Ÿå¾ˆæ˜¾ç„¶æ˜¯å¯ä»¥çš„ã€‚å› ä¸ºæˆ‘ä»¬çš„[l,r]æœ‰ä¸¤ç«¯ï¼Œæ‰€ä»¥ç”¨æ ˆæ˜¯è‚¯å®šä¸è¡Œçš„ï¼Œé‚£ä¹ˆå°±åªèƒ½ç”¨åŒç«¯é˜Ÿåˆ—ã€‚æˆ‘ä»¬å»ºç«‹ä¸¤ä¸ªåŒç«¯é˜Ÿåˆ—ï¼Œä¸€ä¸ªä¿å­˜[l,r]é€’å¢çš„å­åºåˆ—ï¼Œä¸€ä¸ªä¿å­˜[l,r]é€’å‡çš„å­åºåˆ—ï¼Œé‚£ä¹ˆé€’å‡é˜Ÿåˆ—ä¸­ç¬¬ä¸€ä¸ªå€¼ä¿å­˜çš„å°±æ˜¯[l,r]åŒºé—´çš„æœ€å¤§å€¼ï¼Œé€’å¢çš„å°±æ˜¯æœ€å°å€¼ã€‚é‚£ä¹ˆå‡è®¾[l,r] åŒºé—´çš„æœ€å¤§å€¼å’Œæœ€å°å€¼ä¸æ»¡è¶³æ¡ä»¶äº†ï¼Œè¦å°ºå–å°±è¦ç§»åŠ¨l,æ€ä¹ˆç§»åŠ¨ï¼Ÿæˆ‘ä»¬è¦æ”¹å˜æœ€å¤§æœ€å°å€¼ã€‚æ”¹å˜å“ªé‡Œä¸€ä¸ªï¼Ÿè‚¯å®šæ˜¯ç¦»ræœ€è¿œçš„é‚£ä¸€ä¸ªï¼Œæˆ‘ä»¬å•è°ƒé˜Ÿåˆ—ä¿å­˜çš„ä¸‹æ ‡ï¼Œç›´æ¥æŠŠlç§»åŠ¨åˆ°ä¸¤ä¸ªé˜Ÿåˆ—é˜Ÿé¦–ï¼Œæœ€å°çš„ä¸‹æ ‡+1,ç„¶åå¼¹å‡ºé˜Ÿé¦–ï¼Œå°±ç›¸å½“äºæ‰¾åˆ°äº†æ–°[l,r]æœ€å¤§ï¼ˆæœ€å°ï¼‰å€¼ (å› ä¸ºæˆ‘ä»¬é˜Ÿåˆ—æ˜¯å•è°ƒçš„ï¼Œå¼¹å‡ºäº†æœ€å¤§ï¼ˆæœ€å°ï¼‰å€¼å°±ç›¸å½“äºæ‰¾åˆ°äº†æ¬¡å¤§ï¼ˆæ¬¡å°ï¼‰å€¼ï¼Œåœ¨æ–°åŒºé—´å°±æ²¡æœ‰æ¯”ä»–å°çš„äº† ) ç„¶åï¼Œä¸€ç›´å¾ªç¯ç›´åˆ°æ»¡è¶³æ¡ä»¶ä¸ºæ­¢ã€‚å•å¢é˜Ÿåˆ—å°±æ˜¯é˜Ÿå°¾è¿›ï¼Œæ¯æ¬¡å’Œå•è°ƒæ ˆä¸€æ ·ä¿è¯é˜Ÿåˆ—ä¸­æ˜¯å•è°ƒçš„ï¼Œé˜Ÿé¦–æ°¸è¿œéƒ½æ˜¯æœ€å°çš„æˆ–è€…æœ€å¤§çš„ HDU 3530 ACä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;struct deq &#123; static const int start = maxn * 2; int dat[start * 2]; int l = start; int r = start; void push_front(int x) &#123; dat[l--] = x; &#125; void pop_front() &#123; l++; &#125; int front() &#123; return dat[l + 1]; &#125; void push_back(int x) &#123; dat[++r] = x; &#125; void pop_back() &#123; r--; &#125; int back() &#123; return dat[r]; &#125; int size() &#123; return r - l; &#125; void clear() &#123; r = l = start; &#125; bool empty() &#123; return r == l; &#125;&#125;;deque&lt;int&gt; dq, dq2;int n, m, k;int a[maxn];int main() &#123; f(); while (~scanf("%d%d%d", &amp;n, &amp;m, &amp;k)) &#123; int ans = 0; dq.clear(); dq2.clear(); int pos = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); // å¤§çš„å¼¹å‡ºæ‰€ä»¥æœ€å‰é¢æ˜¯æœ€å°çš„ while (dq.size() &gt; 0 &amp;&amp; a[dq.back()] &gt; a[i]) &#123; dq.pop_back(); &#125; dq.push_back(i); while (dq2.size() &gt; 0 &amp;&amp; a[dq2.back()] &lt; a[i]) &#123; dq2.pop_back(); &#125; dq2.push_back(i); while (a[dq2.front()] - a[dq.front()] &gt; k) &#123; if (dq2.front() &lt; dq.front()) &#123; pos = dq2.front(); dq2.pop_front(); &#125; else &#123; pos = dq.front(); dq.pop_front(); &#125; &#125; if (dq2.size() &amp;&amp; dq.size() &amp;&amp; a[dq2.front()] - a[dq.front()] &gt;= m) &#123; ans = max(ans, i - pos); &#125; &#125; printf("%d\n", ans); &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "è¿è¡Œæ—¶é—´:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125;/*54 */ å‹æƒ…æç¤ºï¼šæœ€å¥½åˆ«ç”¨ std é‡Œé¢çš„æ ˆå’Œé˜Ÿåˆ—ï¼Œå¤ªæ…¢äº†è¿›é˜¶é¢˜ï¼š2019ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥ï¼ˆç¬¬ä¸‰åœºï¼‰F Planting Treesé¢˜è§£ ï¼š 2019ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥ï¼ˆç¬¬ä¸‰åœºï¼‰F Planting Trees]]></content>
      <categories>
        <category>ACM</category>
        <category>æ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>å•è°ƒé˜Ÿåˆ—</tag>
        <tag>å·§è§£</tag>
        <tag>ç¬”è®°</tag>
        <tag>å•è°ƒæ ˆ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥ï¼ˆç¬¬ä¸‰åœºï¼‰F Planting Trees]]></title>
    <url>%2F2019%2F07%2F26%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5(%E7%AC%AC%E4%B8%89%E5%9C%BA)F%2F</url>
    <content type="text"><![CDATA[2019ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥ï¼ˆç¬¬ä¸‰åœºï¼‰F Planting Treesé¢˜æ„: ä¸€ä¸ª$N \ast N$ çš„çŸ©é˜µï¼Œé—®æœ€å¤§å€¼å’Œæœ€å°å€¼å¤§å°å·®è·ä¸è¶…è¿‡$M$çš„æœ€å¤§å­çŸ©é˜µå¤šå¤§ã€‚é¢˜è§£: é¢˜ç›®æ˜ç¤ºä½ è¦ä½¿ç”¨$O(N^3)$çš„æ‚åº¦,æš´åŠ›æšä¸¾å­çŸ©é˜µé«˜åº¦$x$ï¼Œåšä¸€ä¸ªé¢„å¤„ç†ï¼ŒæŠŠ$a[i][j]$åˆ°$a[i+x][j]$çš„æœ€å¤§æœ€å°å€¼å¤„ç†å‡ºæ¥ï¼Œå‹ç¼©æˆä¸€è¡Œï¼Œç„¶ååšä¸€æ¬¡æ±‚åŒºé—´æœ€å¤§å€¼å’Œæœ€å°å€¼å·®å€¼ä¸è¶…è¿‡$M$çš„åŒºé—´æœ€å¤§é•¿åº¦ã€‚ä¸æ‡‚å•è°ƒé˜Ÿåˆ—çš„å¯ä»¥çœ‹çœ‹ å•è°ƒæ ˆå’Œå•è°ƒé˜Ÿåˆ—123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include "stdio.h"#include "ctype.h" #define max(a, b) a&gt;b?a:b#define min(a, b) a&lt;b?a:bconst int maxn = 5e2 + 5; struct deq &#123; static const int start = maxn * 2; int dat[start * 2]; int l = start; int r = start; void push_front(int x) &#123; dat[l--] = x; &#125; void pop_front() &#123; l++; &#125; int front() &#123; return dat[l + 1]; &#125; void push_back(int x) &#123; dat[++r] = x; &#125; void pop_back() &#123; r--; &#125; int back() &#123; return dat[r]; &#125; int size() &#123; return r - l; &#125; void clear() &#123; r = l = start; &#125; bool empty() &#123; return r == l; &#125;&#125;; deq dqmx, dqmi; template&lt;typename T&gt;void read(T &amp;w) &#123; //è¯»å…¥ char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar()))w = w * 10 + (c &amp; 15);&#125; int n, k;int a[maxn][maxn];int ans = 0;int mi[maxn][maxn];int mx[maxn][maxn]; int main() &#123; int T; read(T); while (T--) &#123; read(n); read(k); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; read(a[i][j]); &#125; &#125; ans = 0; for (int x = 1; x &lt;= n; x++) &#123; for (int i = n; i &gt;= x; i--) &#123; int pos = 0; dqmx.clear(); dqmi.clear(); for (int j = 1; j &lt;= n; j++) &#123; if (x == 1) &#123; mx[i][j] = a[i][j]; mi[i][j] = a[i][j]; &#125; else &#123; mx[i][j] = max(mx[i - 1][j], a[i][j]); mi[i][j] = min(mi[i - 1][j], a[i][j]); &#125; int tmi = mi[i][j], tmx = mx[i][j]; if (tmx - tmi &gt; k) &#123; dqmi.clear(); dqmx.clear(); pos = j; &#125; else &#123; while (dqmi.size() &amp;&amp; mi[i][dqmi.back()] &gt; tmi) &#123; dqmi.pop_back(); &#125; dqmi.push_back(j); while (dqmx.size() &amp;&amp; mx[i][dqmx.back()] &lt; tmx) &#123; dqmx.pop_back(); &#125; dqmx.push_back(j); while (mx[i][dqmx.front()] - mi[i][dqmi.front()] &gt; k) &#123; if (dqmx.front() &lt; dqmi.front()) &#123; pos = dqmx.front(); dqmx.pop_front(); &#125; else &#123; pos = dqmi.front(); dqmi.pop_front(); &#125; &#125; ans = max(ans, x * (j - pos)); &#125; &#125; &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>æ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥</tag>
        <tag>å•è°ƒé˜Ÿåˆ—</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 1 1012 Sequence]]></title>
    <url>%2F2019%2F07%2F25%2F2019-Multi-University-Training-Contest-1-1012%2F</url>
    <content type="text"><![CDATA[2019 Multi-University Training Contest 1HDU 6589 Sequenceæœç„¶ä¸çœ‹å¤§ä½¬åšå®¢ä¸ä¼šå†™é¢˜ã€‚é¡ºæ‰‹æŠŠæ¿å­ä¹Ÿæ‰’äº†ã€‚é¢˜è§£: x åªæœ‰ 1 2 3ä¸‰ç§æƒ…å†µã€‚ç›´æ¥è§‚å¯Ÿå‰ç¼€.å¯ä»¥å‘ç°å½“ x=1 çš„æ—¶å€™ $c_1$è¡¨ç¤º 1å‡ºç°çš„ä¸ªæ•° a[i]=\sum_{j=0}^{i}C_{c_1-1+j}^{j} * a[i-j]é¢„ç†å‡º $C[j]=C_{c_1-1+j}^{j}$ä¸Šå¼å°±å˜æˆäº† a[i]=\sum_{j=0}^{i}C[j] * a[i-j]æ˜¯ä¸æ˜¯ç»å¯¹ä¸Šè¿°è¿™ä¸ªå¼å­éå¸¸çœ¼ç†Ÿï¼Œå°±æ˜¯å·ç§¯ä¸­çš„ä¸€é¡¹ã€‚ã€‚ã€‚å‘ç°äº†è¿™ä¸ªï¼Œå°±æ˜¯ä¸€ä¸ªç»„åˆæ•°åŠ ä¸ªNTTå½“x=2çš„æ—¶å€™å°±æŠŠæ•°ç»„åˆ†å¥‡æ•°é¡¹å’Œå¶æ•°é¡¹æ±‚ä¸€ä¸ªä¸Šå¼å½“x=3çš„æ—¶å€™å°±æ±‚3ä¸ªå®é™…ä¸Šï¼Œåªè¦æ”¹ä¸€ä¸‹$c[j]$æŠŠæŒ‰ç…§x=1çš„æ±‚ä¸€ä¸‹x=2c[j]=j%2==0&gt;c[j/2]:0x=3``c[j]=j%3==0?c[j/3]:0123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 998244353;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;const double PI = acos(-1);#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;int t;int n, m;LL a[maxn];int c[maxn];LL b[maxn];const int Comb_Maxn = 1e6 + 10;LL Fac_inv[Comb_Maxn];LL Fac[Comb_Maxn];inline void Comb_init() &#123; Fac_inv[0] = Fac[0] = 1; Fac_inv[1] = 1; for (int i = 1; i &lt; Comb_Maxn; i++) Fac[i] = Fac[i - 1] * (LL) i % mod; for (int i = 2; i &lt; Comb_Maxn; i++) Fac_inv[i] = (LL) (mod - mod / i) * Fac_inv[mod % i] % mod; for (int i = 1; i &lt; Comb_Maxn; i++) Fac_inv[i] = Fac_inv[i - 1] * Fac_inv[i] % mod;&#125;LL Comb(int n, int m) &#123; if (m &gt; n || m &lt; 0 || n &lt; 0)return 0; return Fac[n] * Fac_inv[m] % mod * Fac_inv[n - m] % mod;&#125;typedef LL ll;const int N = maxn;struct NumberTheoreticTransform &#123; int pow2(int x) &#123; int res = 1; while (res &lt; x) res &lt;&lt;= 1; return res; &#125; inline LL pow_mod(ll x, int n) &#123; ll res; for (res = 1; n; n &gt;&gt;= 1, x = x * x % mod) if (n &amp; 1) res = res * x % mod; return res; &#125; inline int add_mod(int x, int y) &#123; x += y; return x &gt;= mod ? x - mod : x; &#125; inline int sub_mod(int x, int y) &#123; x -= y; return x &lt; 0 ? x + mod : x; &#125; void NTT(LL a[], int n, int op) &#123; for (int i = 1, j = n &gt;&gt; 1; i &lt; n - 1; ++i) &#123; if (i &lt; j) swap(a[i], a[j]); int k = n &gt;&gt; 1; while (k &lt;= j) &#123; j -= k; k &gt;&gt;= 1; &#125; j += k; &#125; for (int len = 2; len &lt;= n; len &lt;&lt;= 1) &#123; LL g = pow_mod(3, (mod - 1) / len); for (int i = 0; i &lt; n; i += len) &#123; LL w = 1; for (int j = i; j &lt; i + (len &gt;&gt; 1); ++j) &#123; LL u = a[j], t = 1ll * a[j + (len &gt;&gt; 1)] * w % mod; a[j] = (u + t) % mod, a[j + (len &gt;&gt; 1)] = (u - t + mod) % mod; w = 1ll * w * g % mod; &#125; &#125; &#125; if (op == -1) &#123; reverse(a + 1, a + n); LL inv = pow_mod(n, mod - 2); for (int i = 0; i &lt; n; ++i) a[i] = 1ll * a[i] * inv % mod; &#125; &#125; void mul(LL A[], LL B[], int Asize, int Bsize) &#123; int n = pow2(Asize + Bsize - 1); for (int i = Asize; i &lt; n; ++i) A[i] = 0; for (int i = Bsize; i &lt; n; ++i) B[i] = 0; NTT(A, n, 1); NTT(B, n, 1); for (int i = 0; i &lt; n; ++i) &#123; A[i] = 1ll * A[i] * B[i] % mod; B[i] = 0; &#125; NTT(A, n, -1); return; &#125;&#125; ntt;template&lt;typename T&gt;void read(T &amp;w) &#123; //è¯»å…¥ char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar()))w = w * 10 + (c &amp; 15);&#125;int main() &#123; f(); read(t); Comb_init(); while (t--) &#123; read(n); read(m); for (int i = 0; i &lt; n; i++) &#123; read(a[i]); &#125; c[0] = c[1] = c[2] = c[3] = 0; while (m--) &#123; int x; scanf("%d", &amp;x); c[x]++; &#125; if (c[1] &gt; 0) &#123; for (int i = 0; i &lt; n; i++) &#123; b[i] = Comb(c[1] + i - 1, i); &#125; ntt.mul(a, b, n, n); &#125; if (c[2] &gt; 0) &#123; for (int i = 0; i &lt; n; i += 2) &#123; b[i] += Comb(c[2] + i / 2 - 1, i / 2); b[i + 1] = 0; &#125; ntt.mul(a, b, n, n); &#125; if (c[3] &gt; 0) &#123; for (int i = 0; i &lt; n; i += 3) &#123; b[i] = Comb(c[3] + i / 3 - 1, i / 3); &#125; ntt.mul(a, b, n, n); &#125; LL ans = 0; for (int i = 0; i &lt; n; i++) &#123; ans ^= (i + 1LL) * a[i]; &#125; printf("%lld\n", ans); &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "è¿è¡Œæ—¶é—´:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>æ•°è®º</category>
      </categories>
      <tags>
        <tag>æ­ç”µå¤šæ ¡</tag>
        <tag>FFT/NTT/FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 2 1012 Longest Subarray]]></title>
    <url>%2F2019%2F07%2F24%2F2019-Multi-University-Training-Contest-2-1012%2F</url>
    <content type="text"><![CDATA[Longest Subarray HDU 6602é¢˜æ„: nä¸ªæ•°ï¼Œæ±‚åŒºé—´å†… æ•°çš„ä¸ªæ•°è¦ä¹ˆä¸º0ä¸ªè¦ä¹ˆå¤§äºç­‰äºkä¸ªçš„é•¿åº¦æœ€é•¿æ˜¯å¤šå°‘ã€‚é¢˜è§£ï¼šè§£æ³•ä¸€ï¼š ä¸å®Œç¾ç®—æ³•ï¼Œæ¯æ¬¡æšä¸¾è®¡ç®—åŒºé—´å†…æ‰€æœ‰æ•°çš„ä¸ªæ•°æœ‰å¤šå°‘ä¸ªï¼Œå¦‚æœæ²¡æœ‰æ•°çš„ä¸ªæ•°å°äºkçš„å°±æ›´æ–°ç­”æ¡ˆ,å¦‚æœæœ‰å°±æŠŠè¿™å‡ ä¸ªæ•°æ ‡è®°ï¼Œç„¶åè¿™äº›æ•°ä¼šæŠŠåŸæœ¬çš„æ•°ç»„åˆ†æˆå‡ æ®µï¼Œç„¶ååœ¨è¿™å‡ æ®µä¸­ç»§ç»­æ±‚ã€‚ç†è®ºä¸Šè¿™ç§å†™æ³•ä¼šè¶…æ—¶ï¼Œå®é™…ä¸Šå°±æ˜¯è¶…æ—¶äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬æŠŠåˆ†çš„æ¬¡æ•°é™å®šä¸€ä¸‹ï¼Œå¦‚æœåˆ†äº†è¶…è¿‡30æ¬¡å°±ç›´æ¥è·³å‡ºã€‚è¿™æ ·ç†è®ºä¸Šæ²¡æœ‰æŠŠæ‰€æœ‰å¯èƒ½æ€§è·‘åˆ°ï¼Œä½†æ˜¯è¿™ç§æ•°æ®å¾ˆéš¾å¾—ï¼Œæ‰€ä»¥åªè¦æ²¡æœ‰ä¸“é—¨å¡è¿™ç§æ•°æ®å°±èƒ½è¿‡ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;int n, c, k;int a[maxn];int b[maxn];int pos = 0;int v[maxn];int ans = 0;int de[maxn];int dfs(int l, int r, int dep) &#123; if (dep &gt; 30)return 0; if (r &lt; l)return 0; if (r - l + 1 &lt; k)return 0; for (int i = l; i &lt;= r; i++) &#123; b[a[i]] = 0; &#125; pos = 0; for (int i = l; i &lt;= r; i++) &#123; if (b[a[i]] == 0) &#123; v[pos++] = a[i]; &#125; b[a[i]]++; &#125; int flag = 0; for (int i = 0; i &lt; pos; i++) &#123; if (b[v[i]] &gt;= k) &#123; b[v[i]] = 1; &#125; else &#123; b[v[i]] = 0; flag = 1; &#125; &#125; for (int i = l; i &lt;= r; i++) &#123; if (b[a[i]] == 0)de[i] = 0; else de[i] = 1; &#125; if (flag == 0) &#123; ans = max(ans, r - l + 1); return 0; &#125; int L = -1, R = -1; for (int i = l; i &lt;= r; i++) &#123; if (de[i] &amp;&amp; L == -1) &#123; L = i; &#125; if (de[i] == 0 &amp;&amp; L != -1) &#123; R = i - 1; dfs(L, R, dep + 1); L = -1; &#125; &#125; if (L != -1 &amp;&amp; L &lt;= r) &#123; dfs(L, r, dep + 1); &#125;&#125;int main() &#123; f(); while (~scanf("%d%d%d", &amp;n, &amp;c, &amp;k)) &#123; ans = 0; for (int i = 1; i &lt;= n; i++)scanf("%d", &amp;a[i]); dfs(1, n, 0); printf("%d\n", ans); &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "è¿è¡Œæ—¶é—´:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125; é¢˜è§£äºŒï¼š æšä¸¾åŒºé—´r,çº¿æ®µæ ‘æŸ¥æ‰¾æœ€å°çš„lã€‚èƒ½å¤Ÿé€‰çš„ä½ç½®ä¸€å®šæ˜¯åˆ†æˆä¸¤æ®µã€‚ç„¶åæŠŠä» råˆ°l å°‘äºkä¸ªæ•°å­—ä¸åˆæ³• åŒºé—´ -1ï¼Œå˜æˆåˆæ³•çš„æ—¶å€™+1ï¼Œå¤§äºç­‰äº0çš„åŒºé—´ä¸­æœ€å°ä¸‹æ ‡å°±æ˜¯ç­”æ¡ˆã€‚å‡è®¾ï¼Œk=3æ¯ä¸ªæ•°å­—ä¸€å®šæ˜¯è¿™æ ·ï¼Œä¸¾ä¸ªä¾‹å­k=21 4 1 4 2 1 1é¦–å…ˆåˆ° r=1 a[r]=1 ,æ²¡æœ‰è¶…è¿‡ kä¸ª, æŠŠ æœ€å¼€å§‹åˆ° r å…¨éƒ¨å‡ 1 -1æŸ¥è¯¢ [1,r] æ²¡æœ‰å¤§äºç­‰äº0çš„ä½ç½®ï¼Œä¸æ›´æ–°ç­”æ¡ˆr=2 a[r]=4 ,ä¸ªæ•°å°‘äº k,[1,r] -1 -2 -1[1,r] æ²¡æœ‰å¤§äº0 çš„ä½ç½® ,ä¸æ›´æ–°r=3 a[r]=1 ,å¤§äºç­‰äº k ä¸ªï¼ŒæŠŠå½“å‰ä½ç½®å’Œå‰é¢a[r]ä½ç½®ä¹‹é—´ -1, ä¹Ÿå°±æ˜¯ [2,3] -1 ,ç„¶åè¶…è¿‡kä¸ªçš„ä½ç½® [1,1] +1-1 -2 -1è¿˜æ˜¯æ²¡æœ‰0çš„ä½ç½® ä¸æ›´æ–°r=4 a[r]=4ï¼ŒåŒä¸Š[3,4] -1 ï¼Œ[1,2] +10 -1 -2 -1æœ€å°0ä½ç½®ä¸º1 pos=1 æ›´æ–°ç­”æ¡ˆ ans=max(ans,r-pos+1)åé¢ä¾æ¬¡ç±»æ¨123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;int n, c, k;int a[maxn];int ans = 0;int last[maxn];int b[maxn];int dat[maxn &lt;&lt; 2];int lazy[maxn &lt;&lt; 2];int lastk[maxn], pre[maxn], nxt[maxn];void build(int l, int r, int k) &#123; if (r == l) &#123; dat[k] = 0; lazy[k] = 0; &#125; else &#123; build(lson); build(rson); dat[k] = 0; lazy[k] = 0; &#125;&#125;void push_down(int l, int r, int k) &#123; if (r == l)dat[k] += lazy[k]; else &#123; lazy[chl] += lazy[k]; lazy[chr] += lazy[k]; &#125; lazy[k] = 0; if (r != l)dat[k] = max(dat[chl] + lazy[chl], dat[chr] + lazy[chr]);&#125;void update(int A, int B, int l, int r, int k, int x) &#123;// if (k == 0) &#123;// printf("[%d,%d] %d\n", A, B, x);// &#125; push_down(l, r, k); if (A &gt; r || B &lt; l)return; else if (A &lt;= l &amp;&amp; r &lt;= B) &#123; lazy[k] += x; &#125; else &#123; update(A, B, lson, x); update(A, B, rson, x); dat[k] = max(dat[chl] + lazy[chl], dat[chr] + lazy[chr]); &#125;&#125;int query(int A, int B, int l, int r, int k) &#123; push_down(l, r, k); if (A &gt; r || B &lt; l || dat[k] &lt; 0)return inf; else if (r == l &amp;&amp; A &lt;= l &amp;&amp; r &lt;= B) &#123; return l; &#125; else &#123; if (B &lt;= mid || dat[chl] + lazy[chl] &gt;= 0) &#123; return query(A, B, lson); &#125; else return query(A, B, rson); &#125;&#125;int queryval(int A, int B, int l, int r, int k) &#123; push_down(l, r, k); if (A &gt; r || B &lt; l)return -inf; else if (A &lt;= l &amp;&amp; r &lt;= B) &#123; return dat[k]; &#125; else &#123; return max(queryval(A, B, lson), queryval(A, B, rson)); &#125;&#125;int main() &#123; f(); while (~scanf("%d%d%d", &amp;n, &amp;c, &amp;k)) &#123; ans = 0; build(1, n, 0); for (int i = 0; i &lt;= c; i++)b[i] = last[i] = lastk[i] = pre[i] = nxt[i] = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); nxt[last[a[i]]] = i; pre[i] = last[a[i]]; if (b[a[i]] + 1 &gt;= k) &#123; update(pre[i] + 1, i, 1, n, 0, -1); update(pre[lastk[a[i]]] + 1, lastk[a[i]], 1, n, 0, 1); lastk[a[i]] = nxt[lastk[a[i]]]; &#125; else if (b[a[i]] == 0) &#123; update(1, i, 1, n, 0, -1); lastk[a[i]] = i; pre[i] = 0; &#125; else if (b[a[i]] + 1 &lt; k) &#123; update(last[a[i]] + 1, i, 1, n, 0, -1); &#125; last[a[i]] = i; ans = max(ans, i - query(1, i, 1, n, 0) + 1); b[a[i]]++; &#125; if (k == 1)ans = n; else if (k == 0)ans = 0; printf("%d\n", ans); &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "è¿è¡Œæ—¶é—´:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>æ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>æ­ç”µå¤šæ ¡</tag>
        <tag>çº¿æ®µæ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥ï¼ˆç¬¬äºŒåœºï¼‰J Subarray]]></title>
    <url>%2F2019%2F07%2F23%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5(%E7%AC%AC%E4%BA%8C%E5%9C%BA)J%2F</url>
    <content type="text"><![CDATA[2019ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥ï¼ˆç¬¬äºŒåœºï¼‰J Subarrayé¢˜æ„ï¼šé•¿åº¦ä¸º$1e9$çš„åŒºé—´$A$ä¸‹æ ‡ä¸º$[0,1e9-1]$,æ•°è¾“å…¥$n$ä¸ªåŒºé—´ï¼Œ$[l_i,r_i]$åŒºé—´ç±»çš„å€¼ä¸º1ï¼Œå…¶ä½™ä¸º-1ï¼Œé—®æœ‰å¤šå°‘åŒºé—´å’Œå¤§äº0.é¢˜è§£ï¼šçœ‹äº†æ¥è‡ªå¤§ä½¬çš„åšå®¢ï¼Œèƒ½å¤Ÿäº§ç”Ÿè´¡çŒ®çš„ç‚¹æœ€å¤šåªæœ‰$3e7$ä¸ª,æ„æ€æ˜¯å…ˆæ±‚ä¸€ä¸ªå‰ç¼€å’Œï¼Œç„¶åç”»æˆå›¾åº”è¯¥æ˜¯è¿™æ ·ã€‚æœ€å·®å°±æ˜¯è¿™æ ·äº†ï¼Œèƒ½å¤Ÿæœ‰å½±å“çš„å°±åªæœ‰è¿™$3e7$ä¸ªç‚¹ (å¯èƒ½æ˜¯åˆ†æ®µçš„) ï¼Œé‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œæ€ä¹ˆæ±‚å‡ºè¿™$3e7$ä¸ªç‚¹ã€‚æ¥è‡ªå¤§ä½¬çš„åšå®¢ä¸ºä»€ä¹ˆå‘¢ï¼Ÿåœ¨å¤§ä½¬çœ¼é‡Œå¾ˆç®€å•ï¼Œæˆ‘ç”»äº†ä¸ªå›¾æ‰ç†è§£ã€‚æ˜¾ç„¶å‰é¢ä¸€ä¸ªçš„$f[i]$åŠ åé¢$g[i+1]$æ¯”ä¸¤ä¸ªåŒºé—´ä¹‹é—´çš„é•¿åº¦å¤§å°±äº‹è¿åœ¨ä¸€èµ·çš„ã€‚(æˆ‘æœç„¶å¤ªèœäº†)ç„¶åå¤„ç†å®Œä¹‹åï¼Œå°±ç›¸å½“äºå¤„ç†ä¸€ä¸ªè¿™æ ·çš„å‰ç¼€å’Œï¼Œæ±‚æ‰€æœ‰ä½ç½®æœ‰å‡ ä¸ªåœ¨ä»–å‰é¢å‰ç¼€æ¯”ä»–å°ã€‚å¦‚æœèŒƒå›´å°ä¸€ç‚¹å°±ç”¨æ ‘çŠ¶æ•°ç»„æ±‚ä¸€ä¸‹å°±æ²¡äº†ï¼Œ$3e7log(3e7)$æ˜¾ç„¶è¶…æ—¶äº†ã€‚çœ‹åˆ°è¿™ä¸ªå‰ç¼€å’Œï¼Œå‰åé¡¹æœ€å¤§åªå·®äº†$1$,ä¸Šä¸‹ç•Œæœ€å¤§å·®å€¼ä¸è¶…è¿‡$3e7$,è¿™å†åšä¸ªå‰ç¼€å’Œ sum ã€‚ç”¨ä¸€ä¸ªæ•°ç»„è¡¨ç¤ºä¸€ä¸ªæ•°å­—å‡ºç°çš„æ¬¡æ•°ï¼Œç„¶å$sum[m]=sum[m-1]+b[m]$,æ›´æ–°å‰ç¼€å’Œ,ç­”æ¡ˆå°±æ˜¯$ans+=sum[m-1]$ã€‚ä¸­é—´æœ‰ä¸€äº›ç»†èŠ‚è¦å¤„ç†123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;typedef long double ld;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;(x)&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define mem(a, b) memset(a,b,sizeof(a));const long long mod = 1e9 + 7;const int maxn = 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;void fin() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif // ONLINE_JUDGE&#125;#ifndef ONLINE_JUDGEclock_t start = clock();#endif // ONLINE_JUDGEint n;LL l[maxn], r[maxn];LL f[maxn], g[maxn];struct node &#123; LL l, r, x;&#125; dat[maxn * 5];LL sum[maxn * 30 + 20], b[maxn * 30 + 20];int main() &#123; fin(); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%lld%lld", &amp;l[i], &amp;r[i]); &#125; f[1] = r[1] - l[1] + 1; for (int i = 2; i &lt;= n; i++) &#123; f[i] = max(0LL, f[i - 1] - (l[i] - r[i - 1] - 1)) + r[i] - l[i] + 1; &#125; g[n] = r[n] - l[n] + 1; for (int i = n - 1; i &gt;= 1; --i) &#123; g[i] = max(0LL, g[i + 1] - (l[i + 1] - r[i] - 1)) + r[i] - l[i] + 1; &#125; int i = 1; LL ans = 0; while (i &lt;= n) &#123; int j = i + 1; LL mi = 0, mx = 0, pos = 0; //mi ä¸‹ç•Œ,mx ä¸Šç•Œ while (j &lt;= n &amp;&amp; g[j] + f[j - 1] &gt;= l[j] - r[j - 1] - 1) &#123; j++; &#125; j--; int t = i, num = 1; // [i,j] åŒºé—´æ˜¯ç›¸äº’å½±å“çš„ for (; t &lt;= j; t++) &#123; // æŠŠæ¯ä¸€æ®µå¤„ç†åˆ° daté‡Œé¢ if (num == 1)dat[num].l = 0; else if (l[t] - r[t - 1] == 1) dat[num].l = pos + 1; else dat[num].l = pos; pos += r[t] - l[t] + 1; dat[num].r = pos; dat[num++].x = 1; mx = max(mx, pos); if (t != j) &#123; dat[num].r = pos - 1; pos -= l[t + 1] - r[t] - 1; dat[num].l = pos + 1; dat[num++].x = 0; // 0 è¡¨ç¤ºä¸‹é™ ,1 è¡¨ç¤ºä¸Šå‡ mi = min(pos, mi); &#125; else &#123; dat[num].r = pos - 1; dat[num].l = max(mi, pos - ((int) 1e9 - 1 - r[t])); dat[num++].x = 0; &#125; &#125; dat[0].r = min(mx, l[i]); dat[0].l = 1; dat[0].x = 0; for (int k = 0; k &lt;= mx - mi + 200; k++)b[k] = sum[k] = 0; assert(mx - mi &lt; maxn * 30); for (int k = 0; k &lt; num; ++k) &#123; dat[k].l += -mi; //å…¨éƒ¨å‘ä¸Šç§»åŠ¨ä¸€ä¸ªä¸‹å±Šï¼Œä¿è¯æœ€å°å€¼ç­‰äº0 dat[k].r += -mi; if (dat[k].x == 1) &#123; for (int m = dat[k].l; m &lt;= dat[k].r; ++m) &#123; b[m]++; sum[m] = sum[m - 1] + b[m]; if (m &gt;= 1)ans += sum[m - 1]; &#125; &#125; else &#123; LL tmp = 0; if (dat[k].l &gt; 0)tmp = sum[dat[k].l - 1]; for (int m = dat[k].l; m &lt;= dat[k].r; ++m) &#123; if (m &gt;= 1)ans += tmp; tmp = sum[m]; //å¦‚æœæ˜¯ä¸‹é™çš„ ï¼Œä»å°å¾€ä¸Šå¤„ç†æ˜¯ä¸èƒ½æŠŠå½“å‰æ›´æ–°åŠ è¿›å»å› å½“å‰è¿™ä¸ªåœ¨ä»–åé¢ b[m]++; sum[m] = sum[m - 1] + b[m]; &#125; &#125; &#125; i = j + 1; &#125; printf("%lld\n", ans);#ifndef ONLINE_JUDGE cout &lt;&lt; "RUNTIME:" &lt;&lt; (1.0 * clock() - start) / 1000 &lt;&lt; "ms" &lt;&lt; endl;#endif // ONLINE_JUDGE return 0;&#125; ç»™å‡ ç»„æ•°æ®ä½ å»è¯•è¯• 1234567891011121314151625 912 1733 56 67 933 58 89 101999999998 999999999 123456720076494]]></content>
      <categories>
        <category>ACM</category>
        <category>æ¯”èµ›</category>
      </categories>
      <tags>
        <tag>ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥</tag>
        <tag>å·§è§£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç‰›å®¢å¤šæ ¡--å¾…è¡¥]]></title>
    <url>%2F2019%2F07%2F22%2F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1--%E5%BE%85%E8%A1%A5%2F</url>
    <content type="text"><![CDATA[ç¬¬ä¸€åœº D Parity of Tuples \begin{aligned} Count(x)&=\sum_{i=1}^{n}\prod_{j=1}^{m}{[a_{i,j}\&x]}\\ &= \end{aligned}ç¬¬ä¸€åœº G Substrings 2ç¬¬äºŒåœº G Polygons D Kth Minimum Clique]]></content>
  </entry>
  <entry>
    <title><![CDATA[NTTå¿«é€Ÿæ•°è®ºå˜æ¢]]></title>
    <url>%2F2019%2F07%2F22%2FNTT%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[NTTç†è§£äº†FFTçš„åŸç†ï¼ŒNTTä¹Ÿå·®ä¸å¤šã€‚FTTæ˜¯ç”¨å¤æ•°å®ç°å˜æ¢ï¼Œè€ŒNTTæ˜¯ç”¨å–æ¨¡æ„ä¹‰å®ç°ã€‚æ‰¾å‡ºä¸€ä¸ªg,å’Œå¼€ä¸€ä¸ªæ¨¡æ•°p,gæ˜¯pçš„åŸæ ¹ã€‚ åŸæ ¹ $0&lt;i&lt;P,0&lt;j&lt;P,1&lt;g&lt;P\ g^i(mod\ p)\ne g^j(mod\ p)$ è¿™æ ·åœ¨FTTé‡Œé¢çš„$w_n^1\equiv g^{\frac{p-1}{n}}$ã€‚æ˜¾ç„¶:$(g^\frac{p-1}{n})^n=g^{p-1}=1(mod\ p)$$g^\frac{p-1}{n} * g^\frac{p-1}{n} = g^{2\frac{p-1}{n}}$åŒæ ·çš„ FFT é‡Œé¢ç”¨åˆ°çš„å‡ ä¸ªåŸæ ¹æ€§è´¨ï¼Œä»–éƒ½æœ‰ã€‚ä½ å¯ä»¥æŠ½è±¡ä¸ºï¼ŒæŠŠä¸€ä¸ªé•¿åº¦ä¸º P çº¿æ®µï¼Œæ¯æ¬¡èµ°ä¸€æ ¼ï¼Œèµ°äº†Næ¬¡å›æ¥äº†ã€‚ æ‰€ä»¥ä¸€å¼€å§‹è¦æ±‚çš„å‡ ä¸ªç‚¹å€¼æ˜¯$\{A(1),A(g^{\frac{p-1}{n}}),\cdots,A(g^{\frac {p-1}{n}{n-1}})\}$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//ntt#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int N=(1&lt;&lt;18)+5, INF=1e9;const double PI=acos(-1);inline int read()&#123; char c=getchar();int x=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125; ll P=1004535809;ll Pow(ll a, ll b,ll P) &#123; ll ans=1; for(; b; b&gt;&gt;=1, a=a*a%P) if(b&amp;1) ans=ans*a%P; return ans;&#125;struct NumberTheoreticTransform &#123; int pow2(int x) &#123; int res = 1; while (res &lt; x) res &lt;&lt;= 1; return res; &#125; inline LL pow_mod(ll x, int n) &#123; ll res; for (res = 1; n; n &gt;&gt;= 1, x = x * x % mod) if (n &amp; 1) res = res * x % mod; return res; &#125; inline int add_mod(int x, int y) &#123; x += y; return x &gt;= mod ? x - mod : x; &#125; inline int sub_mod(int x, int y) &#123; x -= y; return x &lt; 0 ? x + mod : x; &#125; void NTT(LL a[], int n, int op) &#123; for (int i = 1, j = n &gt;&gt; 1; i &lt; n - 1; ++i) &#123; if (i &lt; j) swap(a[i], a[j]); int k = n &gt;&gt; 1; while (k &lt;= j) &#123; j -= k; k &gt;&gt;= 1; &#125; j += k; &#125; for (int len = 2; len &lt;= n; len &lt;&lt;= 1) &#123; LL g = pow_mod(3, (mod - 1) / len); for (int i = 0; i &lt; n; i += len) &#123; LL w = 1; for (int j = i; j &lt; i + (len &gt;&gt; 1); ++j) &#123; LL u = a[j], t = 1ll * a[j + (len &gt;&gt; 1)] * w % mod; a[j] = (u + t) % mod, a[j + (len &gt;&gt; 1)] = (u - t + mod) % mod; w = 1ll * w * g % mod; &#125; &#125; &#125; if (op == -1) &#123; reverse(a + 1, a + n); LL inv = pow_mod(n, mod - 2); for (int i = 0; i &lt; n; ++i) a[i] = 1ll * a[i] * inv % mod; &#125; &#125; void mul(LL A[], LL B[], int Asize, int Bsize) &#123; int n = pow2(Asize + Bsize - 1); for (int i = Asize; i &lt; n; ++i) A[i] = 0; for (int i = Bsize; i &lt; n; ++i) B[i] = 0; NTT(A, n, 1); NTT(B, n, 1); for (int i = 0; i &lt; n; ++i) &#123; A[i] = 1ll * A[i] * B[i] % mod; B[i] = 0; &#125; NTT(A, n, -1); return; &#125;&#125; f; int n1, n2, m, c[N];ll a[N], b[N];char s1[N], s2[N];int main() &#123; //freopen("in","r",stdin); scanf("%s%s",s1,s2); n1=strlen(s1); n2=strlen(s2); for(int i=0; i&lt;n1; i++) a[i] = s1[n1-i-1]-'0'; for(int i=0; i&lt;n2; i++) b[i] = s2[n2-i-1]-'0'; m=n1+n2-1; f.mul(a, b, m); for(int i=0; i&lt;m; i++) c[i]=a[i]; for(int i=0; i&lt;m; i++) c[i+1]+=c[i]/10, c[i]%=10; if(c[m]) m++; for(int i=m-1; i&gt;=0; i--) printf("%d",c[i]);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>æ•°è®º</category>
      </categories>
      <tags>
        <tag>FFT/NTT/FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFTå¿«é€Ÿå‚…é‡Œå¶å˜æ¢ç®€è§£]]></title>
    <url>%2F2019%2F07%2F20%2FFFT%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E7%AE%80%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[æ¦‚è¿°FTTï¼š å¿«é€Ÿå‚…é‡Œå¶å˜æ¢ã€‚çœ‹èµ·æ¥æŒºéš¾çš„ï¼Œå®é™…ä¸Šç¡®å®æŒºéš¾çš„ã€‚ ç”¨é€”A=a_0+a_1x+a_2x\cdots +a_nx^nB=b_0+b_1x+b_2x\cdots +b_nx^næ±‚ C_k=\sum_{i+j=k}A_i * B_jä¹Ÿå°±æ˜¯ä¸Šé¢ä¸¤ä¸ªå¤šé¡¹å¼ç›¸ä¹˜ç­‰äºä¸‹é¢è¿™ä¸ª C=c_0+c_1x+c_2x\cdots +c_{2n}x^{2n}æœ´ç´ ç®—æ³•ä¸€ä¸ªä¸ªä¹˜ $O(n^2)$ å¤æ‚åº¦ï¼ŒFFTèƒ½åœ¨ $O(nlog(n)$ çš„å¤æ‚åº¦å†…è§£å†³ã€‚ ç‚¹å€¼è¿™ä¸ªæ˜¯å¤šé¡¹å¼ ç³»æ•°è¡¨è¾¾ A=a_0+a_1x+a_2x\cdots +a_nx^nä¸‹é¢è¿™ä¸ªæ˜¯ ç‚¹å€¼è¡¨ç¤ºæ³• \{ (x_0,y_0) , (x_1,y_1) , \cdots (x_n,y_n) \}ä¸éš¾çœ‹å‡ºèƒ½ç”¨ä¸‹é¢è¿™ä¸ªn+1ä¸ªä¸åŒçš„ç‚¹å€¼æ¨å‡º ç³»æ•°è¡¨è¾¾å¼ FFTæ­¥éª¤ åŠ å€æ¬¡æ•°ç•Œæ±‚å€¼ å°†è½¬A Bç³»æ•°è¡¨è¾¾å¼ï¼Œæ‰¾å‡º 2n+1 ä¸ªç‚¹å€¼,(åªéœ€è¦n+1ä¸ªç‚¹å€¼å°±èƒ½æ¨å‡ºä¸€ä¸ªæœ€é«˜æ¬¡é¡¹ä¸ºnçš„è¡¨è¾¾å¼ï¼Œä½†æ˜¯ï¼ŒA Bç›¸ä¹˜åæœ‰2nï¼Œæ‰€ä»¥è¦æ‰¾å‡º2n+1ä¸ªå€¼) é€ç‚¹ç›¸ä¹˜ å°†ä¸¤ä¸ªç‚¹å€¼ç›¸ä¹˜è·å¾—C çš„ç‚¹å€¼C=\{(x_0 ,A(x_0) * B(x_0)),\cdots,(x_{2n},A(x_{2n}) * B(x_{2n})\} æ’å€¼ å†ç”¨é€†å˜æ¢å°†Cçš„ç‚¹å€¼è½¬æ¢æˆ ç³»æ•°è¡¨è¾¾å¼ ç¬¬ä¸€æ­¥å«ç¦»æ•£å‚…é‡Œå¶å˜æ¢ (DFT) æ­£å¼è®²è§£ä¸éš¾çœ‹å‡º,å¦‚æœç›´æ¥ç”¨æœ´ç´ ç®—æ³•ï¼Œå»æ±‚å¤šé¡¹å¼ä¹˜ç§¯ï¼Œç¬¬ä¸€æ­¥å¤æ‚åº¦ $O(n^2)$,ç¬¬äºŒæ­¥$O(n)$ï¼Œç¬¬ä¸‰æ­¥$O(n^2)$FFT ä½œç”¨å°±æ˜¯ä¼˜åŒ–ç¬¬ä¸€æ­¥å’Œç¬¬ä¸‰æ­¥ï¼Œéƒ½å˜æˆ$O(nlog(n))$çš„å¤æ‚åº¦ã€‚ åœ¨è¿™ä¹‹å‰éœ€è¦çŸ¥é“ä¸€ä¸ªä¸œè¥¿å«å•ä½å¤æ ¹ å•ä½å¤æ ¹ä¸å…·ä½“è®²äº†,è®²äº†ä½ ä¹Ÿç†è§£ä¸äº†ã€‚ (å…¶å®æˆ‘æ²¡ç†è§£)æƒ³è¦å…·ä½“äº†è§£è§é»‘ä¹¦ç®—æ³•å¯¼è®ºP532ï¼Œæˆ‘åªåšç®€ä»‹næ¬¡å•ä½å¤æ ¹ï¼Œ$w^n=1$ï¼Œè¿™ä¸ªæ•°æœ‰æ°å¥½nä¸ªï¼Œå…·ä½“æ˜¯å•¥ä¸é‡è¦ï¼Œæˆ‘è¯´ä¸ªç®€å•çš„ç†è§£ã€‚å¤æ•°å¤§å®¶éƒ½çŸ¥é“å§ã€‚å‡è®¾æœ‰ä¸¤ä¸ªå¤æ•°$z1=a+bi$$z2=c+di$æŠŠä»–ä»¬ä¸¤ä¸ªä¹˜ä¸€ä¸‹ z2z1=(ac-bd)+(ad+bc)iæ±‚ä¸€ä¸‹$z1 z2$ä»–ä»¬çš„é•¿åº¦å’Œè§’ï¼Œå…ˆæ±‚é•¿åº¦ [z1]=\sqrt{a^2+b^2}[z2]=\sqrt{b^2+c^2}[z1z2]=\sqrt{(ac-bd)^2+(ad+bc)^2}=\sqrt{a^2c^2+b^2d^2+a^2d^2+b^2c^2}=\sqrt{(a^2+b^2)(b^2+d^2)}æ˜¯ä¸æ˜¯å°±ç­‰äº$[z1] * [z2]$ç„¶åä½ ä»£ä¸€ä¸ªæ•°æ”¾z1 z2é‡Œé¢ z1=cos(\alpha)+sin(\alpha)iz2=cos(\beta)+sin(\beta) i\begin{aligned} z1z2&=(cos(\alpha) cos(\beta)-sin(\alpha)sin(\beta))+(cos(\alpha)sin(\beta)+sin(\alpha)cos(\beta))i\\ &=cos(\alpha+\beta)+sin(\alpha+\beta)i \end{aligned}çœ‹åˆ°è¿™åº”è¯¥æ‡‚äº†ï¼Œå¤æ•°çš„ä¹˜æ³•æ€§è´¨ã€‚ (a_0,\theta_0) * (a_1,\theta_1)=(a_1 * a_0,\theta_0\theta_1)å¯èƒ½ä½ è¿˜ä¸çŸ¥é“è¿™æ„å‘³ç€å•¥ï¼Œä½†æ˜¯é©¬ä¸Šä½ å°±æ‡‚äº†å‡è®¾ä¸€ä¸ªå¤æ•°ï¼Œé•¿åº¦ä¸º1ï¼Œè§’åº¦ä¸º\frac{2\pi}{n}ï¼Œ$w_n^1=cos(\frac{2\pi}{n})+sin(\frac{2\pi}n{})i$æŠŠä»–ç”»æˆæˆåœ†å°±æ˜¯é‚£ä¹ˆw_n^2=w_n^1 * w_n^1 å°±ç›¸å½“äºåœ¨åœ†ä¸Šè½¬äº†ä¸€ä¸‹å¦‚ä¸‹å›¾çœ‹åˆ°è¿™ï¼Œåé¢ç†è§£æ€§è´¨å°±è´¼ç®€å•ï¼Œä½ å…¨éƒ¨æƒ³è±¡æˆåœ¨åœ†ä¸Šé¢æ—‹è½¬ã€‚ä½†æ˜¯è¿™äº›éƒ½ä¸é‡è¦æ¥ä¸‹æ¥ç»™ä½ é€€å…¬å¼äº†,å‡è®¾ Aæœ‰æœ€é«˜æ¬¡é¡¹ä¸º n-1 \begin{aligned} A&=a_0+a_1x+a_2x^2+\cdots+a_{n-1}x^{n-1}\\ &=(a_0+a_2x^2+\cdots+a_{n-2}x^{n-2})+x(a_1+a_3x^2+\cdots+a_{n-1}x^{n-2}) \end{aligned}å¯ä»¥å‘ç°å‰é¢ä¸€å †å’Œåé¢ä¸€å †å¾ˆåƒç„¶åè®¾è¿™$A0 A1$ A0=a_0+a_2x+a_4x^2+\cdots+a_{n-2}x^{n-1}\\ A1=a_1+a_3x+a_5x^2+\cdots+a_{n-1}x^{n-1}è¿™ä¸ªåœ°æ–¹æ³¨æ„ï¼ŒA0,A1 é‡Œé¢çš„æ¬¡é¡¹æ˜¯å¼€æ ¹å·æ‰€ä»¥æ˜¯ A=A0(x^2)+xA1(x^2)å‡è®¾ä½ ä»£å…¥çš„æ˜¯ä¸€ä¸ªæ™®é€šçš„æ•°ï¼Œå‡è®¾æ˜¯ \{1,x_0,\cdots,x_{n-1}\}ï¼Œ$A(X)=A0(X^2)+xA1(X^2)$ ä½ è¿˜éœ€è¦æ±‚\{A0(1),A0(x_0^2),\cdots,A0(x_{n-1}^2),A1(1),A1(x_0^2),\cdots,A1(x_{n-1}^2)\} ,ä¸€å…±æ˜¯2nä¸ªï¼Œä¸¤è¾¹åŒæ—¶æ±‚è¿˜æ˜¯$O(n)$.å½“ä½ å¸¦å…¥å¤æ•° \{1,w_n^1,\cdots,w_n^{n-1}\},ä½ å¯ä»¥å‘ç°ä¸€ä¸ªç¥å¥‡çš„äº‹ï¼Œè¦æ±‚çš„æ•°é‡å˜å°‘äº† \begin{aligned} A&=A0((w_n^k)^2)+w_n^kA1((w_n^k)^2)\\ &=A0(w_n^{2k})+w_n^kA1(w_n^{2k})\\ &=A0(w_{\frac{n}{2}}^k)+w_n^kA1(w_{\frac{n}{2}}^k) \end{aligned}ä¸Šè¿°å…¬å¼åŒ–ç®€ç”¨ä¸Šäº†ä¸€ä¸ªå…¬å¼ w_n^k=w_{\frac{n}{2}}^{\frac{k}{2}} è¿™ä¸ªäº‹å¾ˆæ˜¾ç„¶çš„äº‹ï¼Œåœ¨å•ä½åœ†é‡Œé¢ï¼Œæ”¹å˜è¿™ä¸ªæ¯”ä¾‹ï¼Œè§’åº¦ä¸å˜ ä½ éœ€è¦æ±‚çš„æ•°å°±å˜æˆäº†\{1,w_{\frac{n}{2}}^1,\cdots,w_\frac{n}{2}^{n-1}\}çœ‹ä¸Šå»æ²¡æœ‰å‡å°‘ï¼Œå®é™…ä¸Šä½ å¯ä»¥å‘ç°ï¼Œå…¶ä¸­æœ‰ä¸€åŠå…¶å®æ˜¯é‡å¤çš„ï¼Œè¿™åˆè¦ç«‹ç”¨åˆ°ä¸€ä¸ªå…¬å¼ $w_n^k=w_n^{k+n}$ å¾ˆæ˜¾ç„¶ï¼Œåœ†è½¬äº†ä¸€åœˆï¼Œæˆ‘åˆå›æ¥å•¦ æ‰€ä»¥å°±å˜æˆäº†æ±‚\{1,w_{\frac{n}{2}}^1,\cdots,w_\frac{n}{2}^{\frac{n-2}{2}}\}ä¸¾ä¸ªæ —å­ è§£é‡Šä¸€ä¸‹å‡è®¾ ä¸€ä¸ª Aé•¿åº¦ä¸º4 æœ€é«˜æ¬¡é¡¹å°±æ˜¯ 3 A=a_0+a_1x+a_2x^2+a_3^3x^3æ±‚ 4 ä¸ª ç‚¹å€¼ \{\{1,A(1)\},\{w_4^1,A(w_4^1)\},\{w_4^2,A(w_4^2)\},\{w_4^3,A(w_4^3)\}\}ä¸€å¼€å§‹è¦æ±‚çš„æœ‰ 4 ä¸ªç‚¹å€¼ \{A(1),A(w_4^1),A(w_4^2),A(w_4^3)\}é€šè¿‡å‰é¢é‚£ä¸ªè½¬æ¢, çœ‹ä¸æ‡‚ä¸ºå•¥æœ‰ä¸ª1çš„ ï¼Œæ³¨æ„ $w_n^0=1$ \begin{aligned} A(1)&=A0(1)+1A1(1)\\ A(w_4^1)&=A0(w_2^1)+w_4^1A1(w_2^1)\\ A(w_4^2)&=A0(w_2^2)+w_4^2A1(w_2^2)=A0(1)+w_4^2A1(1)\\ A(w_4^3)&=A0(w_2^3)+w_4^3A1(w_2^3)=A0(w_2^1)+w_4^3A1(w_2^1) \end{aligned}è¦æ±‚çš„ç‚¹å€¼å°±å˜æˆäº†$\{A0(1),A0(w_2^1),A1(1),A1(w_2^1)\}$ åŒæ ·æ˜¯4ä¸ªï¼Œ ä½†æ˜¯é€’å½’ä¸‹å»æ‰¾æ¯æ¬¡åˆ†æˆä¸¤éƒ¨åˆ†ï¼Œå°±ç›¸å½“äºæŠ˜åŠäº†ï¼Œ(è¿˜æ˜¯æ²¡æœ‰ç†è§£ç­‰ä¼šç”»ä¸ªå›¾ç»™ä½ çœ‹ä¸‹) å¦å¤–è¿˜æ²¡å®Œï¼Œä¸Šè¿°è¿˜æœ‰ä¸€ä¸ªç‰¹ç‚¹: å‰é¢ä¸€åŠå’Œåé¢ä¸€åŠ å¾ˆåƒï¼Œæ²¡é”™ï¼Œè¿˜å¯ä»¥ä¼˜åŒ–ã€‚è¿™ä¸ªåœ°æ–¹åˆè¦ç”¨åˆ°ä¸€ä¸ªæ€§è´¨. $w_n^{k+\frac{n}{2}}=-w_n^{k}$ å¾ˆæ˜¾ç„¶,ä½ åœ¨åœ†é‡Œé¢è½¬äº†åŠåœˆï¼Œä¸å°±æ˜¯ä¸ªç›¸åçš„äº†ä¹ˆã€‚ã€‚ã€‚ã€‚ æ„Ÿè§‰æˆ‘çš„è¯æ˜éƒ½æ˜¯æ˜¾ç„¶è¯æ˜æ³•,ä¸ç”¨åœ¨æ„è¿™äº›ç»†èŠ‚ç”±æ­¤å¯ä»¥å†ä¼˜åŒ–å½“$k&lt;\frac{n}{2}$ A(w_n^k)=A0(w_{\frac{n}{2}}^k)+w_n^kA1(w_{\frac{n}{2}}^k)å½“$k&gt;\frac{n}{2}$ A(w_n^k)=A0(w_{\frac{n}{2}}^k)-w_n^{k-\frac{n}{2}}A1(w_{\frac{n}{2}}^k)ç½‘ä¸Šå¾ˆå¤šå†™çš„æ˜¯A(w_n^{k+\frac{n}{2}})=A0(w_{\frac{n}{2}}^k)-w_n^{k}A1(w_{\frac{n}{2}}^k)ï¼Œå…¶å®æ˜¯ä¸€ä¸ªæ„æ€ï¼Œå“ªä¸ªå¥½ç†è§£ä½ çœ‹å“ªä¸ªå§ã€‚ä¾‹å­A(w_4^3)=A0(w_2^1)-w_4^1A1(w_2^1)å¯¹åº”ä¸Šé¢ä¸¾å¾—é‚£ä¸ªå…·ä½“çš„ä¾‹å­ï¼Œä½ å°±å¯ä»¥å†æ¬¡ä¼˜åŒ–äº†ã€‚ è¿™ä¸ªåœ°æ–¹çœ‹ä¸æ‡‚æ¨èä¸€ç¯‡ç¥çº§å¤§ä½¬çš„åšå®¢ ä»å¤šé¡¹å¼ä¹˜æ³•åˆ°å¿«é€Ÿå‚…é‡Œå¶å˜æ¢ æœ€åå†ç”»ä¸ªå›¾åŠ©è§£ä¸€ä¸‹: è‡³æ­¤ç®—æ³•æ ¸å¿ƒåŸç†å…¨éƒ¨è§£é‡Šå®Œæ¯•ã€‚é€†è¿ç®—ä»ç‚¹å€¼ è½¬æ¢æˆç³»æ•°è¡¨è¾¾å¼ ï¼Œä½ æŠŠçŸ©é˜µå†™å‡ºæ¥ï¼Œå°±ç›¸å½“äºä¹˜äº†ä¸€ä¸ªé€†çŸ©é˜µã€‚å°±ç›¸å½“äºå†æ±‚ä¸€æ¬¡DFT ï¼Œåªä¸è¿‡ $w_n^k$ å˜æˆä»–çš„é€†ï¼Œw_n^k * w_n^{-k}=1ï¼ŒåŠ ä¸ªè´Ÿå·å°±è¡Œäº†ã€‚ä»£ç ç½‘ä¸Šä¸€å¤§å †æˆ‘è¿™é‡Œè´´ä¸ªæˆ‘çš„ï¼Œæµ‹è¯•é¢˜ç›®51Nod å¤§æ•°ä¹˜æ³•2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;const double eps = 0.5;const double pi = acos(-1.0);struct complexx &#123; double x, y; complexx(double xx = 0, double yy = 0) &#123; x = xx, y = yy; &#125; void put() &#123; printf("[x=%f y=%f]\n", x, y); &#125;&#125; a[maxn], b[maxn];complexx operator+(complexx a, complexx b) &#123; return complexx(a.x + b.x, a.y + b.y); &#125;complexx operator-(complexx a, complexx b) &#123; return complexx(a.x - b.x, a.y - b.y); &#125;complexx operator*(complexx a, complexx b) &#123; return complexx(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y); &#125;void fft(int len, complexx *a, int o) &#123; if (len == 1) return; complexx a0[(len &gt;&gt; 1) + 3], a1[(len &gt;&gt; 1) + 3]; for (int i = 0; i &lt;= len; i += 2) a0[i &gt;&gt; 1] = a[i], a1[i &gt;&gt; 1] = a[i + 1]; fft(len &gt;&gt; 1, a0, o); fft(len &gt;&gt; 1, a1, o); complexx wn = complexx(cos(2 * pi / len), o * sin(2 * pi / len)), w0 = complexx(1, 0); for (int i = 0; i &lt; (len &gt;&gt; 1); i++, w0 = w0 * wn) &#123; a[i] = a0[i] + w0 * a1[i];// a[i + (len &gt;&gt; 1)] = a0[i] - w0 * a1[i]; //å‰é¢è¯´çš„ä¸€ä¸ªä¼˜åŒ– &#125; //ä¸åŠ ä¼˜åŒ–ç»§ç»­è·‘ä¸‹å»ï¼Œç›´æ¥æšä¸¾æ‰€æœ‰ for (int i = (len &gt;&gt; 1); i &lt; len; i++, w0 = w0 * wn) &#123; a[i] = a0[i - (len &gt;&gt; 1)] + w0 * a1[i - (len &gt;&gt; 1)]; &#125;&#125;char s[maxn];int ans[maxn];int main() &#123; f(); scanf("%s", s); int la = strlen(s); for (int i = la - 1; i &gt;= 0; i--)a[i].x = s[la - i - 1] - '0'; scanf("%s", s); int lb = strlen(s); for (int i = lb - 1; i &gt;= 0; i--)b[i].x = s[lb - i - 1] - '0'; int m = la + lb - 2; int len = 1; for (; len &lt;= m; len &lt;&lt;= 1); fft(len, a, 1);//DFT fft(len, b, 1);//DFT for (int i = 0; i &lt;= len; i++) a[i] = a[i] * b[i]; fft(len, a, -1);//IDFT for (int i = 0; i &lt;= m; i++) &#123; ans[i] = (int) (a[i].x / len + eps);//è®°å¾—é™¤len eps ç”¨æ¥æ¶ˆ æµ®ç‚¹è¯¯å·®æˆ‘ç”¨çš„ 0.5 &#125; for (int i = 0; i &lt;= m; i++)ans[i + 1] += ans[i] / 10, ans[i] = ans[i] % 10; if (ans[m + 1])printf("%d", ans[m + 1]); for (int i = m; i &gt;= 0; i--) &#123; printf("%d", ans[i]); &#125; puts("");#ifndef ONLINE_JUDGE cout &lt;&lt; "è¿è¡Œæ—¶é—´:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125; ä½ ä»¥ä¸ºå¤§ç»“å±€äº†å—?æ²¡æœ‰ ä¼˜åŒ–é™¤äº†å‰é¢é‚£ä¸ªç›´æ¥å†è¡¨è¾¾å¼ä¸Šçš„ä¼˜åŒ–,ï¼Œä¸‹é¢è¿˜æœ‰ä»£ç ä¸Šçš„ä¼˜åŒ–ã€‚é€’å½’å¤ªæ…¢äº†ï¼Œå¯ä»¥æ¢æˆè¿­ä»£ã€‚å¦å¤–ï¼Œè¿™ç©ºé—´å˜æˆäº†nlog(n) ï¼Œé‚£ä¸ªè¾…åŠ©æ•°ç»„ä¼˜åŒ–æ‰ä¹Ÿå¯ä»¥ä¸å¥½.å·²ç»ç†è§£æ ¸å¿ƒäº†ï¼Œåé¢è¿™ä¸ªå°±ä¸ç”¨æˆ‘è¯´äº†å§ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚æ˜¯æˆ‘æ‡’å¾—å†™äº†ï¼Œæˆ‘18å²æˆ‘å¥½ç´¯ ç›´æ¥è´´ä¸€ä¸ªå¤§å“¥çš„æ¿å­æŠŠï¼Œæ‰¾çš„å¤ªå¤šäº†éƒ½ä¸çŸ¥é“æ˜¯è°çš„äº† 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//fft#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int N=(1&lt;&lt;18)+5, INF=1e9;const double PI=acos(-1);inline int read()&#123; char c=getchar();int x=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125; struct meow&#123; double x, y; meow(double a=0, double b=0):x(a), y(b)&#123;&#125;&#125;;meow operator +(meow a, meow b) &#123;return meow(a.x+b.x, a.y+b.y);&#125;meow operator -(meow a, meow b) &#123;return meow(a.x-b.x, a.y-b.y);&#125;meow operator *(meow a, meow b) &#123;return meow(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);&#125;meow conj(meow a) &#123;return meow(a.x, -a.y);&#125;typedef meow cd; struct FastFourierTransform &#123; int n, rev[N]; cd omega[N], omegaInv[N]; void ini(int lim) &#123; n=1; int k=0; while(n&lt;lim) n&lt;&lt;=1, k++; for(int i=0; i&lt;n; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1) | ((i&amp;1)&lt;&lt;(k-1)); for(int k=0; k&lt;n; k++) &#123; omega[k] = cd(cos(2*PI/n*k), sin(2*PI/n*k)); omegaInv[k] = conj(omega[k]); &#125; &#125; void fft(cd *a, cd *w) &#123; for(int i=0; i&lt;n; i++) if(i&lt;rev[i]) swap(a[i], a[rev[i]]); for(int l=2; l&lt;=n; l&lt;&lt;=1) &#123; int m=l&gt;&gt;1; for(cd *p=a; p!=a+n; p+=l) for(int k=0; k&lt;m; k++) &#123; cd t = w[n/l*k] * p[k+m]; p[k+m]=p[k]-t; p[k]=p[k]+t; &#125; &#125; &#125; void dft(cd *a, int flag) &#123; if(flag==1) fft(a, omega); else &#123; fft(a, omegaInv); for(int i=0; i&lt;n; i++) a[i].x/=n; &#125; &#125; void mul(cd *a, cd *b, int m) &#123; ini(m); dft(a, 1); dft(b, 1); for(int i=0; i&lt;n; i++) a[i]=a[i]*b[i]; dft(a, -1); &#125;&#125;f; int n1, n2, m, c[N];cd a[N], b[N];char s1[N], s2[N];int main() &#123; //freopen("in","r",stdin); scanf("%s%s",s1,s2); n1=strlen(s1); n2=strlen(s2); for(int i=0; i&lt;n1; i++) a[i].x = s1[n1-i-1]-'0'; for(int i=0; i&lt;n2; i++) b[i].x = s2[n2-i-1]-'0'; m=n1+n2-1; f.mul(a, b, m); for(int i=0; i&lt;m; i++) c[i]=floor(a[i].x+0.5); for(int i=0; i&lt;m; i++) c[i+1]+=c[i]/10, c[i]%=10; if(c[m]) m++; for(int i=m-1; i&gt;=0; i--) printf("%d",c[i]);&#125; å¦‚æœ‰é”™è¯¯ï¼Œæœ›æŒ‡å‡ºã€‚]]></content>
      <categories>
        <category>ACM</category>
        <category>æ•°è®º</category>
      </categories>
      <tags>
        <tag>FFT/NTT/FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥ï¼ˆç¬¬äºŒåœºï¼‰F MAZE]]></title>
    <url>%2F2019%2F07%2F20%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5(%E7%AC%AC%E4%BA%8C%E5%9C%BA)F%2F</url>
    <content type="text"><![CDATA[2019ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥ï¼ˆç¬¬äºŒåœºï¼‰F MAZEä¸–ç•Œä¸Šæœ‰ç§ç®—æ³•ä¸å«åšç®—æ³•ï¼Œé‚£å°±æ˜¯æš´åŠ›ã€‚ã€‚ã€‚ã€‚ C_{2n}^n æ˜¯$4e7$ï¼Œæ€»çŠ¶æ€æ˜¯$4e7$ç§ï¼Œç„¶åè½¬ç§»,$O(n)$ç›´æ¥å‘ç›¸é‚»çš„çŠ¶æ€è½¬ç§»ã€‚æ€»å¤æ‚åº¦$O(C_{2n}^{n} * n)$ã€‚1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;(x)&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("dat.in", "r", stdin);#endif // ONLINE_JUDGE&#125;#ifndef ONLINE_JUDGEclock_t start=clock();#endif // ONLINE_JUDGEint n,m;int mp[30][30];LL sum,ans;int ar[15],br[15]; //a b ä¸ªè¡¨ç¤ºä¸€ä¸ªé›†åˆint la,lb;void dfs(int num) &#123; //é€‰nä½ if(la&gt;n||lb&gt;n)return ; if(la==n&amp;&amp;lb==n) &#123; //å¦‚æœå„é€‰äº† n ä½å°±æ›´æ–°ç­”æ¡ˆ ans=max(sum,ans); return ; &#125; else &#123; if(la&lt;n) &#123; LL tmp=0; for(int i=0; i&lt;lb; i++) &#123; //é€‰åˆ° a é›†åˆ tmp+=mp[num][br[i]]; &#125; sum+=tmp; ar[la++]=num; dfs(num+1); ar[--la]; sum-=tmp; &#125; if(lb&lt;n) &#123; LL tmp=0; for(int i=0; i&lt;la; i++) &#123; //é€‰åˆ° b é›†åˆ tmp+=mp[num][ar[i]]; &#125; sum+=tmp; br[lb++]=num; dfs(num+1); br[lb--]; sum-=tmp; &#125; &#125;&#125;int main() &#123; f(); scanf("%d", &amp;n); m = 2 * n; for(int i = 0; i &lt; m; ++i) &#123; for(int j = 0; j &lt; m; ++j) &#123; scanf("%d", &amp;mp[i][j]); &#125; &#125; dfs(0); printf("%lld\n",ans);#ifndef ONLINE_JUDGE debug((1.0*(clock()-start)/1000));#endif // ONLINE_JUDGE return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>æ¯”èµ›</category>
      </categories>
      <tags>
        <tag>ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥</tag>
        <tag>æš´åŠ›</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥(ç¬¬ä¸€åœº) C Euclidean Distance]]></title>
    <url>%2F2019%2F07%2F19%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%B8%80%E5%9C%BA%EF%BC%89C%2F</url>
    <content type="text"><![CDATA[2019ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥ï¼ˆç¬¬ä¸€åœºï¼‰C Euclidean Distanceé¢˜è§£: æ‹‰æ ¼æœ—æ—¥ä¹˜å­æ³•ï¼Œé¦–å…ˆå¼•å…¥æ‹‰æ ¼æœ—æ—¥ä¹˜å­å¾—å‡ºå…¬å¼ f(x)=\sum_{i=1}^{n}(p_i-a_i)^2+2*\lambda(\sum_{i=0}^{n}p_i-1)è¿™ä¸ªåº”è¯¥çœ‹çš„æ‡‚ï¼Œç„¶åå¼•å…¥å¯¹å¶å˜æˆæˆ\max_\lambda f(\lambda)å…¶ä¸­ f(\lambda)=\min_{p_i\geq0}\sum_{i=1}^{n}(p_i-a_i)^2+2*\lambda(\sum_{i=0}^{n}p_i-1)ç„¶ååŒ–æˆå‰å§ç»™çš„é¢˜è§£é‡Œé¢çš„å…¬å¼å°±è¡Œäº† f(\lambda)=\min_{p_i\geq0}\sum_{i=1}^{n}(p_i-(a_i-\lambda))^2+\lambda(\sum_{i=0}^{n}(a_i^2-(a_i-\lambda)^2)-2\lambdaå†ç„¶åï¼Œæˆ‘å°±ä¸ä¼šäº†qaqåæ¥çœ‹äº†ä¸€ä¸‹åˆ«çš„å¤§ä½¬çš„åšå®¢ï¼Œçªç„¶æ„Ÿè§‰å¯ä»¥ç›´æ¥ç†è§£ä¸€ä¸‹ï¼Œå‡è®¾æ‰€æœ‰çš„$p_i=0$,$f(x)$å°±ç­‰äº$a_i^2$çš„å’Œ é¢˜ç›®è¦æ±‚çš„æ˜¯ åœ¨ q_i\geq0,\quad \sum_{i=0}^{n}q_i=1æ¡ä»¶ä¸‹æ±‚ $f(x)=\sum_{i=1}^{n}(p_i-a_i)^2$ ã€‚ç›¸å½“äºåˆ†é…$p_i$ çš„å€¼ï¼Œå»è®© $(p_i-a_i)^2$ å˜å°ã€‚æ ¹æ®äºŒæ¬¡å‡½æ•°çš„æ€§è´¨ï¼Œè‡ªå˜é‡ $x$ è¶Šå¤§å› å˜é‡ $y$ åŒ–è¶Šå¿«ã€‚æ‰€ä»¥å…ˆåˆ†é…ç»™æœ€å¤§è‚¯å®šæ›´ä¼˜å•Šï¼Œç›´æ¥è´ªå¿ƒä¸‹å»å•Šã€‚æœ€åè‚¯å®šæ˜¯å˜æˆ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("dat.in", "r", stdin);#endif // ONLIN_JUDGE&#125;LL a[maxn];int n;LL m;int main() &#123; while(~scanf("%d%lld",&amp;n,&amp;m)) &#123; for(int i=1; i&lt;=n; i++) &#123; scanf("%lld",&amp;a[i]); &#125; sort(a+1,a+n+1,greater&lt;int&gt;()); LL r=m; //p[i]çš„æ€»åˆ†é…ä»·å€¼æ˜¯ 1 ä¹Ÿå°±æ˜¯ m/m LL pos=1; // pos æ ‡è®°èƒ½å¤Ÿåˆ†é…p[i] åˆ°ç¬¬ pos ä¸ª while(pos&lt;n) &#123; if(r&lt;(a[pos]-a[pos+1])*pos)break; r-=(a[pos]-a[pos+1])*pos; pos++; &#125; // æœ€ç»ˆå‰posä¸ªçš„å€¼ éƒ½ä¼šæ˜¯a[pos]-r/pos,å°†ä»–æ‰©å¤§pos å€, ç„¶åå†ä¹˜ä»¥ pos ä¸ª LL ans=(a[pos]*pos-r)*(a[pos]*pos-r)*pos; //å› ä¸ºæœ€åçš„å€¼å¯èƒ½æ˜¯ 1/pos,æ‰€ä»¥æŠŠåˆ†å­åˆ†æ¯åŒæ—¶ä¹˜ä»¥posä¸ª LL b=m*m*pos*pos; // å› ä¸ºæ±‚çš„æ˜¯è·ç¦»çš„å¹³æ–¹ åˆ†æ¯ å°±æ˜¯ m*m*pos*pos for(int i=pos+1; i&lt;=n; i++) &#123; //åˆ†é…ä¸åˆ°çš„ a[i]ï¼Œç›´æ¥åŠ ä¸Š ans+=a[i]*a[i]*pos*pos; &#125; LL g=__gcd(ans,b); if(ans%b==0)printf("%lld\n",ans/b); else printf("%lld/%lld\n",ans/g,b/g); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>æ¯”èµ›</category>
      </categories>
      <tags>
        <tag>ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥</tag>
        <tag>æ‹‰æ ¼æœ—æ—¥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexoNextä¸»é¢˜æ’å…¥æ•°å­¦å…¬å¼]]></title>
    <url>%2F2019%2F07%2F17%2FhexoNext%E4%B8%BB%E9%A2%98%E6%8F%92%E5%85%A5%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[å¼€å¯mathjaxå…ˆæŠŠè¿™ä¸ªæ‰“å¼€ï¼Œç„¶åçœ‹åˆ°mathjaxä¸Šé¢è¿™ä¸€è¡Œäº†æ²¡æœ‰ï¼Œè¦ç”¨hexo-rendering-pandoc æˆ–è€…hexo-renderer-kramedè¿™ä¸ªæ¸²æŸ“ï¼Œç¬¬ä¸€ä¸ªæˆ‘è¯•çš„æ—¶å€™å‘ç°å’Œhexo-renderer-markedè¿™ä¸ªè¯­æ³•æœ‰ç‚¹å‡ºå…¥ (hexoé»˜è®¤ä½¿ç”¨ hexo-renderer-marked æ¸²æŸ“) ï¼Œå¦‚æœæ¢äº†å‰é¢å†™æ‰€æœ‰mdæ–‡ä»¶çš„å…¨éƒ½è¦æ”¹è¯­æ³•ï¼Œæ‰€ä»¥æˆ‘å°±ç”¨äº†ç¬¬äºŒä¸ª,å…ˆæŠŠhexo-renderer-markedçš„å¸äº†ï¼Œå†è£…hexo-renderer-kramedã€‚12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save ç”¨æ•°å­¦å…¬å¼çš„æ—¶å€™è®°å¾—æ‰“å¼€ æµ‹è¯•ä»£ç å¦‚ä¸‹12345678$$P = \frac&#123;\sum_&#123;i=1&#125;^n (x_i- x)(y_i- y)&#125;&#123;\displaystyle \left[\sum_&#123;i=1&#125;^n (x_i-x)^2\sum_&#123;i=1&#125;^n (y_i-y)^2\right]^&#123;1/2&#125; &#125;$$ æ•ˆæœå¦‚ä¸‹: P = \frac {\sum_{i=1}^n (x_i- x)(y_i- y)} {\displaystyle \left[ \sum_{i=1}^n (x_i-x)^2 \sum_{i=1}^n (y_i-y)^2 \right]^{1/2} } HexoEditor å±•ç¤ºæ•°å­¦å…¬å¼å¦‚æœä½ ç”¨è¿™ä¸ªç¼–è¾‘å™¨ï¼Œæƒ³å®æ—¶å±•ç¤ºè¿™ä¸ªæ•ˆæœå°±æ‰“å¼€TeXæ•°å­¦è¡¨è¾¾å¼ã€‚æ•ˆæœå¦‚ä¸‹ï¼š]]></content>
      <categories>
        <category>é…ç½®</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HexoNextæ·»åŠ ç½‘æ˜“äº‘éŸ³ä¹]]></title>
    <url>%2F2019%2F07%2F17%2FHexoNext%E6%B7%BB%E5%8A%A0%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%2F</url>
    <content type="text"><![CDATA[æ·»åŠ ç½‘æ˜“äº‘éŸ³ä¹ç”Ÿæˆå¤–é“¾ ä¿®æ”¹æ¨¡æ¿æ–‡ä»¶å°±æ˜¯è¿™ä¸ªthemes\next\layout\_macro\sidebar.swigè‡ªå·±æ‰¾ä¸ªä½ç½®å¤åˆ¶ç²˜è´´è¿›å»æˆ‘æ˜¯æ”¾åœ¨é‚£ä¸ªæœ€ä¸‹é¢]]></content>
      <categories>
        <category>é…ç½®</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HexoNextæ·»åŠ gitmentè¯„è®º]]></title>
    <url>%2F2019%2F07%2F17%2FHexoNext%E6%B7%BB%E5%8A%A0gitment%E8%AF%84%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[æ·»åŠ gitmentè¯„è®ºåŒºå®‰è£…gitment1npm install gitment --save #å®‰è£…gitment åˆ›å»ºåº”ç”¨å†åˆ›å»ºä¸€ä¸ª OAuth application1234Application name:éšä¾¿å†™Homepage URL:è¿™ä¸ªä¹Ÿå¯ä»¥éšæ„å†™,å°±å†™ä½ çš„åšå®¢åœ°å€å°±è¡ŒApplication description:æè¿°,ä¹Ÿå¯ä»¥éšæ„å†™Authorization callback URL:è¿™ä¸ªå¿…é¡»å†™ä½ çš„åšå®¢åœ°å€ ç”³è¯·å¥½ä¹‹åç‚¹æ³¨å†Œ,ç„¶åå°±å¯ä»¥çœ‹åˆ°ä¸¤ä¸ªä¸œè¥¿ClientIDå’ŒClient Secret,åé¢ä¼šç”¨åˆ°. åˆ›å»ºå®Œåè¿™ä¸ªç­‰ä¼šè¦ç”¨ä¸Š é…ç½®123456789101112131415# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/gitment: enable: true mint: false # å¦‚æœè¦ä¿®æ”¹gitment.swigåœ°å€å°±æ”¹æˆfalse RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide &apos;Powered by ...&apos; on footer, and more language: # Force language, or auto switch by theme github_user: &#123;you github user id&#125; github_repo: éšä¾¿å†™ä¸€ä¸ªä½ çš„å…¬å¼€çš„gitä»“åº“å°±è¡Œ,åˆ°æ—¶å€™è¯„è®ºä¼šä½œä¸ºé‚£ä¸ªé¡¹ç›®çš„issue client_id: &#123;åˆšæ‰ç”³è¯·çš„ClientID&#125; client_secret: &#123;åˆšæ‰ç”³è¯·çš„Client Secret&#125; proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled ç„¶ååœ¨ ä¸»é¢˜é…ç½®æ–‡ä»¶next config.ymlä¸­å¼€å¯gitmentå› ä¸ºæŸä¸ªæœåŠ¡å™¨æŒ‚äº†ï¼Œæ‰€ä»¥mintè¦ä¸ºfalseæ‰ä¼šæ‰§è¡Œä½ æ‰€ä¿®æ”¹çš„ã€‚ é”™è¯¯ï¼š object ProgressEventc é”™è¯¯å°±æ˜¯ä¸Šé¢è¿™ä¸ªåŸå› ï¼ŒæŠŠmintæ”¹æˆæ³•falseå³å¯ã€‚ æ‰¾åˆ°themes/next/layout/_third-party/comments/gitment.swigæ–‡ä»¶ä¿®æ”¹å…¶ä¸­çš„css å’Œjs ,æ³¨é‡Šæ‰çš„æ˜¯ä¸€å¼€å§‹é»˜è®¤çš„ï¼Œç°åœ¨æ”¹æˆä¸‹æ–¹æ²¡æœ‰æ³¨é‡Šçš„ã€‚ (åé¢è¿™ä¸ªæ˜¯æ±‰åŒ–çš„)123456789101112&lt;!-- LOCAL: You can save these files to your site and update links --&gt;&#123;% if theme.gitment.mint %&#125; &#123;% set CommentsClass = 'Gitmint' %&#125; &lt;script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitmint.browser.js"&gt;&lt;/script&gt;&#123;% else %&#125; &#123;% set CommentsClass = 'Gitment' %&#125; &lt;!-- &lt;script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js"&gt;&lt;/script&gt; --&gt;&lt;script src="https://billts.site/js/gitment.js"&gt;&lt;/script&gt;&#123;% endif %&#125;&lt;!-- &lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css"/&gt; --&gt;&lt;link rel="stylesheet" href="https://billts.site/extra_css/gitment.css"&gt;&lt;!-- END LOCAL --&gt; éœ€è¦æ³¨æ„çš„æ˜¯ç¡®ä¿themes/next/_config.ymlä¸­theme.gitment.mintè®¾ç½®ä¸ºfalse,æ‰ä¼šèµ°åˆ°æˆ‘ä»¬æ”¹åŠ¨çš„åˆ†æ”¯. è¿˜æœ‰ä¿®æ”¹ä¸€ä¸‹gitmentæ¨¡æ¿ï¼Œåªéœ€è¦ä¿®æ”¹idè¿˜æ˜¯åœ¨ä¸Šé¢é‚£ä¸ªæ–‡ä»¶, ï¼ˆæˆ‘ä¹Ÿä¸çŸ¥é“ä¸ºå•¥è¦æ”¹ï¼Œå¤§ä½¬é—¨è¯´è¦æ”¹ï¼Œå®é™…ä¸Šæˆ‘æ²¡æ”¹ä¹Ÿæ²¡å‡ºç°å•¥é”™è¯¯1234var gitment = new &#123;&#123;CommentsClass&#125;&#125;(&#123; id: &apos;&#123;&#123; page.date &#125;&#125;&apos;, owner: &apos;&#123;&#123; theme.gitment.github_user &#125;&#125;&apos;, repo: &apos;&#123;&#123; theme.gitment.github_repo &#125;&#125;&apos;,]]></content>
      <categories>
        <category>é…ç½®</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018CCPCå‰æ—åœºé‡ç°èµ›]]></title>
    <url>%2F2019%2F07%2F16%2F2018CCPC%E5%90%89%E6%9E%97%E5%9C%BA%E9%87%8D%E7%8E%B0%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[2018CCPCå‰æ—èµ›åŒºï¼ˆé‡ç°èµ›ï¼‰ä¼ é€é—¨ A Bè¿™ä¸¤é¢˜å¦‚æœä¸ä¼šå†™ï¼Œè¿˜æ˜¯å¤šå»åˆ·åˆ·åŸºç¡€é¢˜ï¼Œä¹Ÿæ²¡å‡ ä¸ªäººä¸ºäº†è¿™ä¸¤é¢˜æ¥å§ã€‚ C Justiceé¢˜æ„ï¼š ç»™ä½ Nå †çŸ³å­ ï¼Œæ¯å †çŸ³å­é‡é‡æ˜¯1/(2^ki)çš„é‡é‡ï¼Œç„¶åé—®èƒ½ä¸èƒ½æŠŠçŸ³å­åˆ†æˆå¤§äºç­‰äº1/2é‡é‡çš„ä¸¤å †çŸ³å­ã€‚é¢˜è§£ï¼š ä»å¤§åˆ°å°æ¯æ¬¡åˆå¹¶ä¸¤å †ä¸€æ ·çš„ï¼Œå¦‚æœåªå‰©ä¸€ä¸ªå°±ç›´æ¥ä¸¢æ‰ï¼Œå› ä¸ºæ— è®ºå¦‚ä½•è¿™ä¸ªéƒ½æ²¡æ³•åˆå¹¶æˆæ›´å¤§çš„ä¸€å±‚çš„ã€‚ä¸€ç›´è¿™æ ·åˆå¹¶ä¸‹å»å¦‚æœèƒ½åˆ†æˆä¸¤å †ä¸€æ ·çš„å„å¤§äº1/2ï¼Œé‚£ä¹ˆæœ€ç»ˆåˆå¹¶çš„å’Œä¸€å®šèƒ½åˆæˆä¸€ä¸ª 0ä¾‹å­:1 3 3 4 4 5 2å…ˆæŒ‰å¤§å°æ’åº5 4 4 3 3 2 15æ²¡æ³•åˆå¹¶ï¼Œç›´æ¥ä¸¢æ‰ï¼Œåˆå¹¶ä¸¤ä¸ª4è·å¾—ä¸€ä¸ª33 3 3 2 1åˆå¹¶ä¸¤ä¸ª3æˆ–å¾—ä¸€ä¸ª2 ï¼Œå¤šå‡ºæ¥çš„ä¸€ä¸ª3æ²¡æ³•åˆæˆ2ç›´æ¥ä¸¢æ‰ã€‚2 2 1åˆå¹¶ä¸¤ä¸ª2å†åˆå¹¶ä¸¤ä¸ª1æœ€ç»ˆè·å¾—0.èƒ½å¤Ÿè·å¾—0è¯´æ˜èƒ½åˆ†æˆä¸¤å †ä¸€æ ·çš„1/2ä¸€å¼€å§‹æ²¡çœ‹åˆ°è¦è®°å½•çŠ¶æ€ï¼Œåæ¥è¡¥æ•‘äº†ä¸€ä¸‹ï¼Œåˆå¹¶çš„æ—¶å€™åŠ ä¸€ä¸ªå¹¶æŸ¥é›†å°±è¡Œäº†ï¼Œä¸å½±å“å¤æ‚åº¦ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const long long mod = 1e9 + 7;const int maxn = 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;clock_t prostart;void f() &#123;#ifndef ONLINE_JUDGE prostart = clock(); freopen("../data.in", "r", stdin);#endif return;&#125;vector&lt;P&gt; v;int par[maxn];int find(int x) &#123; return x == par[x] ? x : par[x] = find(par[x]);&#125;priority_queue&lt;P, vector&lt;P&gt;, less&lt;P&gt; &gt; q;int main() &#123; f(); int T; int cas = 1; scanf("%d", &amp;T); while (T--) &#123; int n; scanf("%d", &amp;n); v.clear(); for (int i = 0; i &lt;= n; i++)par[i] = i; for (int i = 0; i &lt; n; i++) &#123; int a; scanf("%d", &amp;a); if (a &lt; n + 1) &#123; v.emplace_back(P(a, i + 1)); &#125; &#125; sort(v.begin(), v.end()); int flag = 0, ans = -1; for (int i = (int) v.size() - 1; i &gt;= 0; i--) &#123; while (q.size() &amp;&amp; v[i].first &lt; q.top().first)q.pop(); if (q.empty()) &#123; q.push(P(v[i].first, v[i].second)); if (v[i].first == 1)ans = v[i].second; &#125; else &#123; int l = v[i].first, y = v[i].second; while (q.size() &amp;&amp; q.top().first == l) &#123; if (l - 1 &gt;= 1) &#123; int x = find(q.top().second); par[x] = y; if (l - 1 == 1)ans = y; &#125; q.pop(); l = l - 1; &#125; if (l &lt;= 0)flag = y; q.push(P(l, y)); &#125; &#125; while (q.size()) &#123; int l = q.top().first, y = q.top().second; if (l == 1)ans = y; q.pop(); while (q.size() &amp;&amp; q.top().first == l) &#123; if (l - 1 &gt;= 1) &#123; int x = find(q.top().second); par[x] = y; if (l - 1 == 1)ans = y; &#125; q.pop(); l = l - 1;// if (l == 1)ans = y; &#125; if (l &lt;= 0)flag = 1; &#125; printf("Case %d: %s\n", cas++, flag ? "YES" : "NO"); if (flag) &#123;// debug(find(2)); for (int i = 1; i &lt;= n; i++) &#123; if (find(i) == ans)printf("1"); else printf("0"); &#125; puts(""); &#125; &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "è¿è¡Œæ—¶é—´:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125; D The Mooné¢˜æ„ï¼š pçš„æ¦‚ç‡èµ¢ï¼Œåˆå§‹è·å¾—åŒ…æ¦‚ç‡qä¸º 2% æ¯æ¬¡è¿›è¡Œä¸€æ¬¡æ¸¸æˆï¼Œå¦‚æœèµ¢äº†qçš„æ¦‚ç‡è·å¾—åŒ…ï¼Œå¦‚æœæ²¡è·å¾—æ¦‚ç‡qå˜æˆmin(100%ï¼Œp),å¦‚æœè¾“äº†qå˜æˆmin(100%ï¼Œp),è¾“å…¥pé—®æœŸæœ›è®ºæ•°æ˜¯å¤šå°‘.é¢˜è§£: pæ˜¯ä¸€ä¸ªæ•´æ•°ï¼Œæ€»å…±åªæœ‰100ä¸ªå€¼ï¼Œqæœ€å¤šåªä¼šå‡ºç°0.5%ï¼Œçœ‹åˆ°è¿™äº›æˆ‘æœ‰ä¸€ä¸ªå¤§èƒ†çš„æƒ³æ³•ã€‚æœŸæœ›ç­‰äº è½®æ•°*æ¦‚ç‡æ‰€ä»¥æˆ‘æš´åŠ›æšä¸¾1e6è½®ï¼Œç”¨dp[i]è¡¨ç¤ºq=i/2%çš„æ¦‚ç‡ï¼Œç„¶åç›´æ¥æŠŠ1e6è½®çš„å€¼åŠ èµ·æ¥ï¼Œå› ä¸ºåˆ°åé¢æ¦‚ç‡ç»å¯¹è¶Šæ¥è¶Šå°1e6è½®è¯¯å·®å·²ç»å¾ˆå°ï¼Œç„¶åæš´åŠ›æšä¸¾pçš„1-100,æŠŠç­”æ¡ˆæ‰“å°ä¸‹æ¥ã€‚ã€‚ã€‚ã€‚ç„¶åä½ æ‡‚çš„(æ³¨é‡Šæ‰çš„æ˜¯æš´åŠ›è·‘çš„ä»£ç )123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const long long mod = 1e9 + 7;const int maxn = 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;clock_t prostart;void f() &#123;#ifndef ONLINE_JUDGE prostart = clock(); freopen("../data.in", "r", stdin);#endif return;&#125;bool cmp(double o1, double o2) &#123; return abs(o1 - o2) &lt; eps;&#125;struct point3 &#123; double x, y, z;&#125; s, t;double dp[maxn];double a[1000] = &#123;130.7530454000, 79.2053644503, 61.1640496589, 51.6033688156, 45.5020175987, 41.1756105103, 37.8950632978, 35.2908241865, 33.1540346125, 31.3568193706, 29.8159317728, 28.4744883082, 27.2920701057, 26.2390206161, 25.2929905666, 24.4367537696, 23.6567754479, 22.9422440770, 22.2843986720, 21.6760501176, 21.1112333591, 20.5849499398, 20.0929742362, 19.6317054554, 19.1980530697, 18.7893470611, 18.4032668302, 18.0377843270, 17.6911181415, 17.3616961332, 17.0481247749, 16.7491638265, 16.4637052733, 16.1907557033, 15.9294214771, 15.6788961816, 15.4384499618, 15.2074204071, 14.9852047313, 14.7712530335, 14.5650624685, 14.3661721843, 14.1741589106, 13.9886331012, 13.8092355497, 13.6356344123, 13.4675225797, 13.3046153516, 13.1466483734, 12.9933758002, 12.8445686601, 12.7000133904, 12.5595105271, 12.4228735274, 12.2899277111, 12.1605093052, 12.0344645825, 11.9116490803, 11.7919268935, 11.6751700320, 11.5612578361, 11.4500764445, 11.3415183077, 11.2354817448, 11.1318705365, 11.0305935527, 10.9315644109, 10.8347011617, 10.7399260000, 10.6471649983, 10.5563478614, 10.4674076992, 10.3802808172, 10.2949065219, 10.2112269412, 10.1291868575, 10.0487335524, 9.9698166630, 9.8923880479, 9.8164016621, 9.7418134409, 9.6685811914, 9.5966644912, 9.5260245936, 9.4566243391, 9.3884280725, 9.3214015652, 9.2555119427, 9.1907276158, 9.1270182166, 9.0643545388, 9.0027084802, 8.9420529899, 8.8823620181, 8.8236104686, 8.7657741544, 8.7088297556, 8.6527547795, 8.5975275235, 8.5431270393&#125;;int main() &#123;// f(); int T; int cas = 1;// T=100; scanf("%d", &amp;T); // int t=1; while (T--) &#123; int p;// p = t++; scanf("%d", &amp;p); printf("Case %d: %.10f\n", cas++, a[p - 1]);// p = p / 100;// double ans = 0;// memset(dp, 0, sizeof(dp + 300));// dp[4] = 1;// for (int i = 1; i &lt; maxn; i++) &#123;// for (int j = 200; j &gt;= 0; j--) &#123;//// debug(dp[j]);// if (dp[j] == 0)continue;// ans += i * dp[j] * j / 200.0 * p;// double t = dp[j];// dp[j] = 0;// dp[min(j + 4, 200)] += p * t * (1 - j / 200.0);// dp[min(200, j + 3)] += (1 - p) * t;// &#125;// &#125;// printf("%.10f\n", ans);// a[t - 1] = ans; &#125;// for (int i = 1; i &lt;= 100; i++)printf("%.10f\n", a[i]);#ifndef ONLINE_JUDGE cout &lt;&lt; "è¿è¡Œæ—¶é—´:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125; E The Toweré¢˜æ„ï¼š ç»™ä¸€ä¸ªåœ†é”¥çš„r,h å’Œä¸€ä¸ªç‚¹(x,y,z)ï¼Œç‚¹çš„ç§»åŠ¨é€Ÿåº¦(vx,vy,vz)é—®è¿™ä¸ªç‚¹ä»€ä¹ˆæ—¶å€™æ’ä¸Šå»ï¼Œä¿è¯ç›´æ¥ä»å¤–é¢æ’ä¸Šå»ã€‚é¢˜è§£ï¼š çº¿çš„æ–¹ç¨‹:x=x0+vx*ty=y0+vy*tz=z0+vz*tåœ†é”¥æ–¹ç¨‹: x^2 + y^2 = (h-z)^2 * r^2 / h^2è§£æ–¹ç¨‹é«˜ä¸­çŸ¥è¯†1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const long long mod = 1e9 + 7;const int maxn = 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif return;&#125;bool cmp(double o1, double o2) &#123; return abs(o1 - o2) &lt; eps;&#125;struct point3 &#123; double x, y, z;&#125; s, t;int main() &#123; f(); int T; double r, h; int cas = 0; scanf("%d", &amp;T); while (T--) &#123; scanf("%lf%lf%lf%lf%lf%lf%lf%lf", &amp;r, &amp;h, &amp;s.x, &amp;s.y, &amp;s.z, &amp;t.x, &amp;t.y, &amp;t.z); double tx, ty, tz; tx = t.x; ty = t.y; tz = t.z; double a, b, c; a = (tx * tx + ty * ty - tz * tz * r * r / h / h); b = 2 * (tx * s.x + ty * s.y + tz * (h - s.z) * r * r / h / h); c = s.x * s.x + s.y * s.y - (h - s.z) * (h - s.z) * r * r / h / h; double high = max((h - s.z) / tz, -s.z / tz), low = min((h - s.z) / tz, -s.z / tz); double a1 = (-b + sqrt(b * b - 4 * a * c)) / 2 / a, a2 = (-b - sqrt(b * b - 4 * a * c)) / 2 / a, ans; ans = inf; if (a1 &gt;= low &amp;&amp; a1 &lt;= high)ans = min(a1, ans); if (a2 &gt;= low &amp;&amp; a2 &lt;= high)ans = min(a2, ans); else ans = a2; cout &lt;&lt; "Case " &lt;&lt; ++cas &lt;&lt; ": " &lt;&lt; fixed &lt;&lt; setprecision(10) &lt;&lt; ans &lt;&lt; "\n"; &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125; F The Hermité¢˜æ„: å¤ªé•¿äº†è‡ªå·±è¯»å§.é¢˜è§£: è¯»é¢˜è¯»æ‡‚äº†å¯ä»¥å‘ç°ä¸€ä¸ªæœ‰è¶£çš„äº‹ï¼Œæ¯ä¸ªiå¯¹åº”çš„kéƒ½æ˜¯è¿ç»­çš„å‡ ä¸ªã€‚ä¸ºä»€ä¹ˆä¼šè¿™æ ·å‘¢ï¼Ÿä»”ç»†åˆ†ææ¯ä¸ªç«™ç‚¹çš„åŒºåŸŸå‘ç°ï¼Œåé¢çš„ç»“æŸä¸€å®šæ¯”å‰é¢çš„æ™šï¼Œå‰é¢çš„å¼€å§‹çš„ä¸€å®šæ¯”åé¢æ™šï¼Œæ‰€ä»¥å¯¼è‡´äº†kæ˜¯è¿ç»­çš„ï¼Œæšä¸¾iç”¨setä¿å­˜è¦†ç›–åˆ°içš„j ç”¨setçš„äºŒåˆ†æ‰¾åˆ°ä¸€ä¸ªä¸iæœ‰kçš„èµ·å§‹ä½ç½®ï¼Œåˆ°setæœ€åä¸€ä¸ªjçš„æœ€åä¸€ä¸ªkçš„ä½ç½®ï¼Œè¿™ä¸¤ä¸ªä½ç½®ä¹‹é—´çš„ç«™ç‚¹éƒ½æ˜¯içš„kï¼Œç„¶åå¼‚æˆ–å°±è¡Œäº†ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;int n;set&lt;P&gt; s;int main() &#123; f(); int T, cas = 1; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int a; scanf("%d", &amp;a); int last = a + i - 1; if (s.size()) &#123; set&lt;P&gt;::iterator ite = s.lower_bound(P(i - (a - 1) / 2, 0)); if (ite != s.end()) &#123; int stat = max(i - a + 1, 2 * ite-&gt;first - ite-&gt;second); int end = 2 * (--s.end())-&gt;first - i; ans ^= end - stat + 1; &#125; &#125; s.insert(P(i, last)); while (s.size() &amp;&amp; s.begin()-&gt;second &lt;= i) &#123; s.erase(s.begin()); &#125; &#125; s.clear(); printf("Case %d: %d\n", cas++, ans); &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "è¿è¡Œæ—¶é—´:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125; H Loversé¢˜æ„ï¼š n ä¸ªå­—ç¬¦ä¸²ï¼Œmä¸ªæ“ä½œï¼Œwrapæ“ä½œåœ¨åŒºé—´[l,r]çš„å­—ç¬¦ä¸²å‰åå„åŠ ä¸€ä¸ªæ•°å­—,å¦‚3åŠ å…¥2112å˜æˆ321123ï¼Œä¸€å¼€å§‹æ˜¯ä¸ªç©ºå­—ç¬¦ä¸²ï¼Œå€¼ä¸º0ã€‚query æŸ¥è¯¢[l,r]ä¹‹é—´æ‰€æœ‰å­—ç¬¦ä¸²çš„å€¼çš„å’Œæ¨¡1e9+7ã€‚é¢˜è§£ï¼š æŠŠå­—ç¬¦ä¸²åˆ†æˆä¸‰æ®µ å‰ç¼€+åŸæœ¬çš„å€¼+åç¼€ï¼Œå‰ç¼€å’Œåç¼€å°±æ˜¯ä¸€ä¸ªç›¸åçš„ï¼Œæˆ‘ç›´æ¥æŠŠä»–å¤„ç†æˆæ•°å­—ï¼Œç„¶åè®°å½•é•¿åº¦ï¼ŒåŸæœ¬çš„å€¼ä¹Ÿæ˜¯ä¸€æ ·ï¼Œä¿å­˜å€¼å’Œé•¿åº¦ã€‚ç„¶åçº¿æ®µæ ‘éšä¾¿æï¼Œlazyæ•°ç»„ä¿å­˜å­—ç¬¦ä¸²åŠ åœ¨å‰é¢çš„è´¡çŒ®ï¼Œlazy2 åç¼€è´¡çŒ®,datåŒºé—´å†…æ·»åŠ ä¸€ä¸ªæ•°å½±å“çš„æ€»è´¡çŒ®ï¼ŒvalåŒºé—´å’Œ.æ¯æ¬¡æ›´æ–°å€¼ï¼šval[k] =lazy[k]*dat[k] + val[k] * lenth(lazy[k]) + lazy2[k]dat[k] = dat[k] * lenth(lazy[k]) å…·ä½“è§ä»£ç add() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;LL dat[maxn &lt;&lt; 2], lazy[maxn &lt;&lt; 2], val[maxn &lt;&lt; 2], lazy2[maxn &lt;&lt; 2];LL p10[maxn];int len[maxn &lt;&lt; 2];void up(int l, int r, int k) &#123; val[k] = (val[chl] + val[chr]) % mod; dat[k] = (dat[chl] + dat[chr]) % mod; len[k] = 0; lazy2[k] = lazy[k] = 0;&#125;void build(int l, int r, int k) &#123; if (r == l) &#123; dat[k] = 1; lazy2[k] = lazy[k] = 0; len[k] = 0; val[k] = 0; &#125; else &#123; build(lson); build(rson); up(l, r, k); &#125;&#125;LL re(LL x) &#123; LL res = 0; while (x &gt; 0) &#123; res = res * 10 + x % 10 % mod; x /= 10; &#125; return res;&#125;void add(int l, int r, int k, LL x, LL y, int lenx) &#123; if (r == l) &#123; lazy2[k] = lazy[k] = 0; val[k] = (1LL * y % mod + val[k] * p10[lenx] % mod + dat[k] * p10[lenx] % mod * x % mod) % mod; dat[k] = dat[k] * p10[2 * lenx] % mod; return; &#125; lazy[k] = (lazy[k] + x * p10[len[k]] % mod) % mod; lazy2[k] = (lazy2[k] * p10[lenx] % mod + y) % mod; len[k] += lenx; val[k] = (1LL * y * (r - l + 1) % mod + val[k] * p10[lenx] % mod + dat[k] * p10[lenx] % mod * x % mod) % mod; dat[k] = dat[k] * p10[2 * lenx] % mod;&#125;void pushdown(int l, int r, int k) &#123; if (len[k] == 0) &#123; return; &#125; else &#123; add(lson, lazy[k], lazy2[k], len[k]); add(rson, lazy[k], lazy2[k], len[k]); up(l, r, k); &#125;&#125;int t;int n, m;void update(int a, int b, int l, int r, int k, int x) &#123; pushdown(l, r, k); if (r &lt; a || l &gt; b)return; else if (a &lt;= l &amp;&amp; r &lt;= b) &#123; add(l, r, k, x, x, 1LL); &#125; else &#123; update(a, b, lson, x); update(a, b, rson, x); up(l, r, k); &#125;&#125;LL querry(int a, int b, int l, int r, int k) &#123; pushdown(l, r, k); if (r &lt; a || l &gt; b)return 0; else if (a &lt;= l &amp;&amp; r &lt;= b) &#123;// debug(val[k]); return val[k]; &#125; else &#123; return (querry(a, b, lson) + querry(a, b, rson)) % mod; &#125;&#125;int main() &#123; f(); p10[0] = 1; for (int i = 1; i &lt;= 400000; i++) &#123; p10[i] = p10[i - 1] * 10 % mod; &#125; int cas = 1; scanf("%d", &amp;t); while (t--) &#123; scanf("%d%d", &amp;n, &amp;m); build(1, n, 0); printf("Case %d:\n", cas++); while (m--) &#123; char s[10]; int l, r; scanf("%s%d%d", s, &amp;l, &amp;r); if (s[0] == 'q') &#123; LL ans = querry(l, r, 1, n, 0); printf("%lld\n", ans % mod); &#125; else &#123; int x; scanf("%d", &amp;x); update(l, r, 1, n, 0, x);// for (int i = 1; i &lt;= n; i++) &#123;// printf("%lld ", querry(i, i, 1, n, 0));// &#125;// puts(""); &#125; &#125; &#125; return 0;&#125; I Strengthé¢˜æ„: æ¸¸æˆç‹ï¼Œæˆ‘æœ‰nä¸ªæ€ª å…¨éƒ½æ˜¯æˆ˜æ–—è¡¨ç¤º ,å¯¹é¢æœ‰mä¸ªæ€ªï¼Œ0è¡¨ç¤ºæˆ˜æ–—è¡¨ç¤ºï¼Œ1é˜²å®ˆè¡¨ç¤º,é—®æˆ‘ç¬¬ä¸€å›åˆèƒ½é€ æˆå¤šå°‘ç‚¹ä¼¤å®³ã€‚é¢˜è§£: ä¸€ä¸ªæ°´é¢˜ï¼Œå…¶å®å’ŒA Béš¾åº¦å·®è·ä¸å¤§ã€‚æšä¸¾ä¸¤ç§æƒ…å†µï¼Œä¸€ç§æ˜¯èƒ½æŠŠå¯¹é¢æ€ªå…¨éƒ¨ç äº†ï¼Œä¸€ç§æ˜¯ä¸èƒ½ã€‚ä¸èƒ½å…¨ç æ­»ï¼Œç›´æ¥ç”¨æœ€å¤§çš„ç å¯¹é¢æ”»å‡»è¡¨ç¤ºæœ€å°çš„ï¼Œç ä¸è¿‡å°±ç®—äº†ä¸æ‰“äº†ã€‚èƒ½å…¨ç æ­»ï¼Œæœ¬æ¥è¿™è¿˜æœ‰ä¸¤ç§æƒ…å†µï¼Œå°±ç®—æˆ‘èƒ½å…¨ç æ­»å¯¹é¢çš„æ€ªï¼Œä½†æ˜¯æˆ‘å…¨ç æ­»ï¼Œå’Œç¬¬ä¸€ç§æƒ…å†µä¸€æ ·ï¼Œç›´æ¥ç”¨æœ€å¤§çš„ç ä½ æœ€å°çš„ï¼Œå¦ä¸€ç§å°±æ˜¯å…¨ç æ­» (äº‹å®ä¸Šæ•°æ®å°±åªæœ‰è¿™ä¸€ç§æƒ…å†µï¼Œå¯èƒ½å‡ºé¢˜äººæœ‰ç‰¹æ®Šç™–å¥½ï¼Œè¦ç å°±å…¨ç æ­») ï¼Œå…ˆæŠŠé˜²å¾¡çŠ¶æ€çš„ç”¨å°½å¯èƒ½å°çš„ä»£ä»·ç æ­»ï¼Œç„¶åä½ æƒ³æ€ä¹ˆç å°±æ€ä¹ˆç ï¼Œåæ­£æœ€åä»£ä»·éƒ½æ˜¯ä½ æ€ªæ”»å‡»åŠ›æ€»å’Œå‡å¯¹é¢æˆ˜æ–—åŠ›æ€»å’Œã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;struct node &#123; int x, op; bool operator&lt;(const node &amp;o) const &#123; if (op == o.op)return x &lt; o.x; return op &lt; o.op; &#125;&#125; k[maxn], d[maxn];bool cmp(node &amp;o1, node &amp;o2) &#123; return o1.x &gt; o2.x;&#125;int main() &#123; f(); int T, cas = 1; scanf("%d", &amp;T); while (T--) &#123; int n, m; multiset&lt;int&gt; s; priority_queue&lt;int&gt; q; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;k[i].x); s.insert(k[i].x); q.push(k[i].x); &#125; for (int i = 0; i &lt; m; i++) &#123; scanf("%d", &amp;d[i].x); &#125; for (int i = 0; i &lt; m; i++) &#123; scanf("%d", &amp;d[i].op); &#125; sort(k, k + n, cmp); sort(d, d + m, cmp); int flag = 0; if (n &lt; m)flag = 1; else &#123; for (int i = 0; i &lt; m; i++) &#123; if (k[i].x &lt; d[i].x) &#123; flag = 1; break; &#125; &#125; &#125; LL ans = 0; if (flag == 1) &#123; sort(d, d + m); for (int i = 0; i &lt; m; i++) &#123; if (d[i].op == 1)break; else &#123; if (q.top() &gt; d[i].x) &#123; ans += q.top() - d[i].x; q.pop(); &#125; &#125; &#125; &#125; else &#123; sort(d, d + m); for (int i = 0; i &lt; m; i++) &#123; if (d[i].op == 1)break; else &#123; if (k[i].x &gt; d[i].x) &#123; ans += k[i].x - d[i].x; &#125; else &#123; break; &#125; &#125; &#125; LL res = 0; for (int i = 0; i &lt; m; i++) &#123; if (d[i].op == 1) &#123; s.erase(s.lower_bound(d[i].x)); &#125; else &#123; res -= d[i].x; &#125; &#125; for (auto au:s) &#123; res += au; &#125; ans = max(res, ans); &#125; printf("Case %d: %lld\n", cas++, ans); &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "è¿è¡Œæ—¶é—´:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>æ¯”èµ›</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>CCPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 573 Div 2]]></title>
    <url>%2F2019%2F07%2F13%2FCodeforces-Round-573-Div-2%2F</url>
    <content type="text"><![CDATA[A - Tokitsukaze and Enhancementç®€å•é¢˜ä¸ä¸è¯´æ˜12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt; using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P; #define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a)); const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("dat.in", "r", stdin);#endif // ONLIN_JUDGE&#125; int main() &#123; f(); int x; cin&gt;&gt;x; x=x%4; if(x==0) &#123; printf("1 A\n"); &#125; else if(x==1) &#123; printf("0 A\n"); &#125; else if(x==2) &#123; printf("1 B\n"); &#125; else printf("2 A\n"); return 0;&#125; B - Tokitsukaze and Mahjong1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt; using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P; #define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a)); const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("dat.in", "r", stdin);#endif // ONLIN_JUDGE&#125;char s[20];vector&lt;int &gt;v[3],v2,v3; int f(int x) &#123; sort(v[x].begin(),v[x].end()); if(v[x].size()==0)return 3; if(v[x].size()==1)return 2; else if(v[x].size()==2) &#123; if(v[x][1]==v[x][0])return 1; if(v[x][1]==v[x][0]+1)return 1; if(v[x][1]==v[x][0]+2)return 1; return 2; &#125; else &#123; if(v[x][1]==v[x][0]&amp;&amp;v[x][1]==v[x][2])return 0; if(v[x][1]==v[x][0]+1&amp;&amp;v[x][1]==v[x][2]-1)return 0; if(v[x][1]==v[x][0]||v[x][1]==v[x][2])return 1; if(v[x][1]==v[x][0]+1||v[x][1]==v[x][0]+2||v[x][1]==v[x][2]-1||v[x][1]==v[x][2]-2)return 1; return 2; &#125;&#125;int main() &#123; int ans=2; for(int i=0; i&lt;3; i++) &#123; scanf("%s",s); if(s[1]=='s') &#123; v[0].push_back(s[0]); &#125; else if(s[1]=='p') &#123; v[1].push_back(s[0]); &#125; else v[2].push_back(s[0]); &#125; for(int i=0; i&lt;3; i++) &#123;// debug(i); ans=min(ans,f(i)); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; C - Tokitsukaze and Discard Items12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt; using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P; #define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a)); const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("dat.in", "r", stdin);#endif // ONLIN_JUDGE&#125; LL n,m,k;LL a[maxn];int main() &#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=0; i&lt;m; i++) &#123; scanf("%lld",&amp;a[i]); &#125; sort(a,a+m); LL sum=0,ans=0,num=0; LL page=1; for(int i=0; i&lt;m; i++) &#123; if(a[i]&lt;=page*k+sum) &#123; num++; &#125; else &#123; if(num==0) &#123; page=(a[i]-sum+k-1)/k; num++; &#125; else &#123; ans++; sum+=num; page=(a[i]-sum+k-1)/k; num=1; &#125; &#125; &#125; if(num!=0)ans++; printf("%lld\n",ans); return 0;&#125; D - Tokitsukaze, CSL and Stone Gameé¦–å…ˆè¿™é¢˜æ˜¯ç®€å•ç²—æš´ï¼Œå› ä¸ºé€‰æ‹©åˆ°ä¸¤ä¸ªç›¸åŒçš„å°±è¾“äº†ï¼Œè¯´æ˜æ¯ä¸€ä¸ªéƒ½ä¸ç›¸åŒï¼Œæœ€ç»ˆçŠ¶æ€è‚¯å®šæ˜¯ 0 1 2 3 â€¦. n-1è¿™ç§çŠ¶æ€è‚¯å®šæ˜¯å¿…è¾“ï¼Œæ— æ³•åŠ¨å¼¹ã€‚æ‰€ä»¥æœ€ç»ˆéƒ½ä¼šå˜æˆè¿™ä¸ªçŠ¶æ€ï¼Œåˆ¤æ–­ä¸€ä¸‹åˆ°è¿™ä¸ªçŠ¶æ€çš„å¥‡å¶å°±æ˜¯ç­”æ¡ˆã€‚å¦å¤–è¿˜æœ‰ä¸€å¼€å§‹å°±è¾“äº†çš„çŠ¶æ€ï¼Œæ¯”å¦‚ 3 4 4 ä¸¤ä¸ªä¸€æ ·çš„ï¼Œåªèƒ½é€‰ä¸€æ ·çš„ï¼Œä½†æ˜¯é€‰äº†æœ‰ä¸€ä¸ªå’Œä»–ç›¸åŒï¼Œè¿˜æœ‰ 0 0 ä¸€å¼€å§‹å°±æœ‰ä¸¤ä¸ª0 è¿˜æœ‰å°±æ˜¯ 5 5 5 ä¸‰ä¸ªä¸€æ ·çš„æˆ–è€…ä¸¤å¯¹ä¸¤ä¸ªä¸€æ ·çš„ï¼Œè¿™å››ç§çŠ¶æ€ç»å¯¹æ˜¯ç›´æ¥è¾“äº†ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374By ET_BUBBLE, contest:Codeforces Round #573 (Div. 2), problem: (D) Tokitsukaze, CSL and Stone Game, Accepted, ##include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("dat.in", "r", stdin);#endif // ONLIN_JUDGE&#125;LL n;LL a[maxn];int flag=1,num;map&lt;LL,LL&gt; mp;LL sum=0;int main() &#123; cin&gt;&gt;n; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;a[i]; &#125; sort(a,a+n); for(int i=0; i&lt;n; i++) &#123; if(mp.find(a[i])!=mp.end()) &#123; num++; if(mp.find(a[i]-1)!=mp.end())flag=0; &#125; mp[a[i]]++; &#125; if(num&gt;1||mp[0]&gt;=2||flag==0) &#123; puts("cslnb"); return 0; &#125; if(n==1) &#123; puts((a[0]&amp;1)?"sjfnb":"cslnb"); &#125; else &#123; int flag=1; sum=0; for(int i=0; i&lt;n; i++) &#123; if(a[i]&lt;i) &#123; flag=0; &#125; else &#123; sum+=a[i]-i; &#125; &#125; if(flag==0) &#123; puts("cslnb"); return 0; &#125; puts(sum%2==1?"sjfnb":"cslnb"); &#125; return 0;&#125; F - Tokitsukaze and Strange Rectangleé¢˜æ„ï¼šè‡ªå·±è¯»å»é¢˜è§£ï¼šå…ˆæŒ‰ç…§,yä»å¤§åˆ°å°æ’åºåœ¨æŒ‰ç…§xä»å°åˆ°å¤§æ’åºï¼Œç„¶åæ¯æ¬¡åˆ¤æ–­ä¸€å±‚yã€‚å…ˆåˆ¤æ–­ç¬¬ä¸€å±‚ 1 2 6 7 10 ï¼ˆå‡è®¾ï¼‰y=10ç„¶ååˆ¤æ–­ç¬¬äºŒå±‚ 4 8 (å‡è®¾) y = 9ç¬¬ä¸€å±‚èƒ½å¤Ÿå‡ºç°çš„ä¸åŒçš„é€‰æ³•æ˜¯ 5*(5-1)/2;ç¬¬äºŒå±‚ä¼šå—åˆ°ç¬¬ä¸€å±‚çš„å½±å“ 1 2 åœ¨ 4 å‰é¢ï¼Œæ‰€ä»¥è¦é€‰ 4 çš„çŸ©å½¢æƒ…å†µ æ˜¯çº¢è‰²låˆ°å³è¾¹è“è‰²rçš„æ‰€æœ‰çŸ©å½¢ï¼Œä¼šé€‰ä¸Š4,åŒç†é€‰ä¸Š8åˆä¸å’Œå‰é¢çš„é‡å¤å°±åªèƒ½æ˜¯è¿™æ ·äº†ã€‚ç„¶ååˆå¯ä»¥å‘ç°ï¼Œå¦‚æœæœ‰ç¬¬3å±‚ ï¼Œå‰é¢ä¸¤å±‚å¯¹ç¬¬3å±‚çš„å½±å“åªä¸xçš„å‡ºç°æœ‰å…³ï¼Œæ¯æ¬¡åˆ¤æ–­ä¸€å±‚åªéœ€è¦è€ƒè™‘ä¸Šé¢å‡ºç°çš„ xçš„å½±å“ã€‚å…ˆç¦»æ•£åŒ–ä¸€ä¸‹ï¼Œç„¶åç”¨æ ‘çŠ¶æ•°ç»„æ±‚ä¸€ä¸‹è¿™ä¸ªç‚¹å‰é¢æœ‰å¤šä¸ªç‚¹ï¼Œåé¢æœ‰å¤šå°‘ä¸ªç‚¹ï¼Œç„¶åä¹˜ä¸€ä¸‹å°±å¯ä»¥äº†ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("dat.in", "r", stdin);#endif // ONLIN_JUDGE&#125;int bit[maxn+1],pos;int sum(int i) &#123; int s=0; while(i&gt;0) &#123; s +=bit[i]; i-=i&amp;-i; &#125; return s;&#125;void add(int i,int x) &#123; while(i&lt;=pos) &#123; bit[i]+=x; i+=i&amp;-i; &#125;&#125;int n;struct node &#123; int x,y;&#125; p[maxn];bool cmp(node &amp;o1,node &amp;o2) &#123; if(o1.y==o2.y)return o1.x&lt;o2.x; return o1.y&gt;o2.y;&#125;LL ans=0;unordered_map&lt;int,int&gt;mp;int a[maxn];int main() &#123; f(); scanf("%d",&amp;n); for(int i=0; i&lt;n; i++) &#123; scanf("%d%d",&amp;p[i].x,&amp;p[i].y); a[i]=(p[i].x); &#125; pos=1; sort(a,a+n); for(int i=0; i&lt;n; i++) &#123; if(i==0) &#123; mp[a[0]]=pos++; &#125; else if(a[i]!=a[i-1]) &#123; mp[a[i]]=pos++; &#125; &#125; for(int i=0; i&lt;n; i++) &#123; p[i].x=mp[p[i].x]; &#125; sort(p,p+n,cmp); int len=0; a[len++]=p[0].x; add(p[0].x,1); int mx=pos; for(int i=1; i&lt;n; i++) &#123; if(p[i].y==p[i-1].y) &#123; a[len++]=p[i].x; if(sum(p[i].x)-sum(p[i].x-1)==0)add(p[i].x,1); &#125; else &#123; int la=0; // sort(a,a+len); for(int j=0; j&lt;len; j++) &#123; int i=a[j]; ans+=1LL*(sum(i)-sum(la))*(sum(mx)-sum(i-1)); la=i; &#125; len=0; a[len++]=(p[i].x); if(sum(p[i].x)-sum(p[i].x-1)==0)add(p[i].x,1); &#125; &#125; int la=0; // sort(a,a+len); for(int j=0; j&lt;len; j++) &#123; int i=a[j]; ans+=1LL*(sum(i)-sum(la))*(sum(mx)-sum(i-1)); la=i; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>æ¯”èµ›</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ‹‰æ ¼æœ—æ—¥æ’å€¼å’Œæ±‚å¤šé¡¹å¼ç³»æ•°]]></title>
    <url>%2F2019%2F07%2F12%2F%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E5%92%8C%E6%B1%82%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%B3%BB%E6%95%B0%2F</url>
    <content type="text"><![CDATA[æ‹‰æ ¼æœ—æ—¥ä»‹ç»å…ˆè¯´è¯´æ‹‰æ ¼æœ—æ—¥æ˜¯å•¥å§é¦–å…ˆ æ‹‰æ ¼æœ—æ—¥æ’å€¼æ˜¯ç»™ä½  n+1 ä¸ªç‚¹ $(x,y)$ ç„¶åæ ¹æ®è¿™nä¸ªç‚¹å¯ä»¥$O(n^2)$çš„æ±‚å‡ºå¤šé¡¹å¼çš„ç³»æ•°ã€‚ä¹Ÿå°±æ˜¯è§£å‡ºè¿™ä¸ªå¤šé¡¹å¼çš„ç­”æ¡ˆã€‚ å‡è®¾ç»™ä½ ä¸€ä¸ªå¤šé¡¹å¼$y=a_0+a_1x+a_2x^2$ç„¶åç»™ä½ 3ä¸ªè§£$(x1,y1)(x2,y2)(x3,y3)$ä½ ç¬¬ä¸€ä¸ªæƒ³æ³•æ˜¯æ€ä¹ˆè§£ï¼Ÿè§£æ–¹ç¨‹å•Šæ˜¯ä¸æ˜¯ä»£è¿›å»æ˜¯ä¸æ˜¯è¿™æ · \begin{cases} y_1=a_0+a_1x_1+a_2x_1^2\\ y_2=a_0+a_1x_2+a_2x_2^2\\ y_3=a_0+a_1x_3+a_2x_3^2 \end{cases}ç„¶å¹´åè§£è¿™ä¸ªæ–¹ç¨‹ï¼Ÿè§£è¿™ä¸ªæ–¹ç¨‹å¤æ‚åº¦å¤šå°‘,é«˜æ–¯æ¶ˆå…ƒO(n^3)å¾ˆæ˜¾ç„¶å¤æ‚åº¦é«˜äº†ã€‚æ‹‰æ ¼æœ—æ—¥å°±æ¯”è¾ƒå‰å®³äº†ä»–èƒ½O(n^2)è§£å†³é¦–å…ˆ å‡è®¾ä¸€ä¸ªå¤šé¡¹å¼$f_1(x)= b_0 + b_1x+b_2x^2$å½“ä»–$x=x_1$è§£æ˜¯1,$x_2$ $x_3$ è§£æ˜¯ 0åŒç†å†å‡è®¾ $f_2(x)$ $f_3(x)$ç„¶å$L(x)=y_1f_1(x)+y_2f_2(x)+y_3f_3(x)$,è¿™ä¸ªå°±æ˜¯æœ€å¼€å§‹é‚£ä¸ªæ–¹ç¨‹ï¼Œä¸ä¿¡?ä½ æŠŠ$x_1 x_2 x_3$ å¸¦è¿›å»è§£ç»å¯¹æ˜¯ $y_1 y_2 y_3$ã€‚é‚£ä¹ˆé—®é¢˜æ¥äº†åé¢$f_1(x)$è¿™ä¸ªå¤šé¡¹å¼æ€ä¹ˆæ±‚å‡ºæ¥ï¼Ÿï¼Ÿï¼Ÿï¼Ÿè¿™å°±æ˜¯æ‹‰æ ¼æœ—æ—¥åŸºæœ¬å…¬å¼ f(x)=\sum_{i=0}^{n-1}y_i\prod_{j=0,j\neq i}^{n-1}\frac{x-x_i}{x_j-x_i}æ²¡é”™å°±æ˜¯ä»–å“¦ï¼æé”™äº†æ˜¯ä¸‹é¢è¿™ä¸ªï¼Œä¸Šé¢é‚£ä¸ªæ˜¯ä¹˜ä¸Š$y_i$çš„æœ€ç»ˆè¡¨è¾¾å¼å†æ¥ä¸€éï¼Œè¿™å°±æ˜¯æ‹‰æ ¼æœ—æ—¥åŸºæœ¬å…¬å¼ l_j(x)=\prod_{j=0,j\neq i}^{n-1}\frac{x-x_i}{x_j-x_i}æŠŠè¿™ä¸ªå¤šé¡¹å¼å±•å¼€ä¼šå‘ç°éå¸¸ç¥å¥‡çš„äº‹ï¼Œå½“$x=x_j$çš„æ—¶å€™åˆšå¥½ç­‰äº1å¦åˆ™ç­‰äº0,åˆšå¥½æ»¡è¶³äº†åŸæ¥æ‰€éœ€è¦çš„æ–¹ç¨‹å¼ã€‚å°±æ˜¯ä¸‹é¢è¿™æ ·ï¼š l_j(x)=\prod_{j=0,j\neq i}^{k}\frac{x-x_i}{x_i-x_j}=\frac{x-x_0}{x_0-x_j}\cdots\frac{x-x_0}{x_j-x_{j-1}}\frac{x-x_{j+1}}{x_j-x_{j+1}}\cdots\frac{x-x_k}{x_j-x_k}æ€•ä½ è¿˜æ˜¯çœ‹ä¸æ‡‚ï¼Œä¸¾ä¸ªä¾‹å­ç»™ä½ çœ‹ $f(4)=10\ f(5)=5.25\ f(6)=1$ æ±‚ $f(18)$ é¦–å…ˆå†™å‡ºæ‹‰æ ¼æœ—æ—¥åŸºæœ¬å¤šé¡¹å¼ l_0=\frac{(x-5)(x-6)}{(4-5)(5-6)}l_1=\frac{(x-4)(x-6)}{(5-4)(5-6)}l_2=\frac{(x-4)(x-5)}{(6-4)(6-5)}\begin{cases} p(x)&=f(4)l_0(x)+f(5)l_1(x)+f(6)l_2(x)\\ &=10\frac{(x-5)(x-6)}{(4-5)(5-6)}+5.25\frac{(x-4)(x-6)}{(5-4)(5-6)}+1*\frac{(x-4)(x-5)}{(6-4)(6-5)}\\ &=\frac{1}{4}(x^2-28x+136) \end{cases}æ­¤æ—¶ä»£å…¥18:$f(18)=p(18)=-11$è¿˜æœ‰ä¸€ä¸ªé—®é¢˜ä½ ä»¬è‚¯å®šå¾ˆæƒ³é—®ã€‚ã€‚ã€‚çŸ¥é“å…¬å¼ä¹‹åæ€ä¹ˆè§£ã€‚ã€‚ã€‚å¯¹äºè¿™ä¸ªé—®é¢˜åˆ†æ¯ æ˜¯ä¸æ˜¯æ¯æ¬¡ç®—ä¸€ä¸‹å°±è¡Œäº†ï¼Œç­”æ¡ˆæ˜¯å›ºå®šçš„åˆ†å­æ˜¯ä¸æ˜¯ä¸€ä¸ªå¤§çš„å¤šé¡¹å¼é‡Œé¢å°‘äº†ä¸€ä¸ªï¼Œå°±é¢„å¤„ç†å‡ºæ€»çš„å¤šé¡¹å¼ç„¶åï¼Œæ¨¡æ‹Ÿé™¤ä¸€ä¸‹$(x+c)$çš„å¤šé¡¹å¼ ç†è®ºçŸ¥è¯†å…¨éƒ¨æå®šï¼Œä¸‹é¢å°±ç»™ä½ è´´æ¨¡æ¿äº† æ¿å­123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//è¿™ä¸ªæ˜¯æœæ•™çš„æ¿å­ æˆ‘æ‰“äº†ç‚¹æ³¨é‡Š/// æ³¨æ„modï¼Œä½¿ç”¨å‰é¡»è°ƒç”¨ä¸€æ¬¡ polysum::init(int M);/// æ³¨æ„modï¼Œä½¿ç”¨å‰é¡»è°ƒç”¨ä¸€æ¬¡ polysum::init(int M);namespace polysum &#123;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)typedef long long ll;const ll mod = 1e9 + 7; /// å–æ¨¡å€¼ll powmod(ll a, ll b) &#123; ll res = 1; a %= mod; assert(b &gt;= 0); for (; b; b &gt;&gt;= 1) &#123; if (b &amp; 1)res = res*a%mod; a = a*a%mod; &#125; return res;&#125;const int D = 1010000; /// æœ€é«˜æ¬¡é™åˆ¶ll a[D], f[D], g[D], p[D], p1[D], p2[D], b[D], h[D][2], C[D];ll calcn(int d, ll *a, ll n) &#123; //æ ¹æ®å‰ d é¡¹ æ±‚ ç¬¬né¡¹ if (n &lt;= d) return a[n]; p1[0] = p2[0] = 1; rep(i, 0, d + 1) &#123; ll t = (n - i + mod) % mod; p1[i + 1] = p1[i] * t%mod; &#125; rep(i, 0, d + 1) &#123; ll t = (n - d + i + mod) % mod; p2[i + 1] = p2[i] * t%mod; &#125; ll ans = 0; rep(i, 0, d + 1) &#123; ll t = g[i] * g[d - i] % mod*p1[i] % mod*p2[d - i] % mod*a[i] % mod; if ((d - i) &amp; 1) ans = (ans - t + mod) % mod; else ans = (ans + t) % mod; &#125; return ans;&#125;void init(int M) &#123; /// Mï¼šæœ€é«˜æ¬¡ f[0] = f[1] = g[0] = g[1] = 1; rep(i, 2, M + 5) f[i] = f[i - 1] * i%mod; g[M + 4] = powmod(f[M + 4], mod - 2); per(i, 1, M + 4) g[i] = g[i + 1] * (i + 1) % mod; //é€†å…ƒ&#125;ll polysum(ll n, ll *arr, ll m) &#123; /// a[0].. a[m] \sum_&#123;i=0&#125;^&#123;n-1&#125; a[i] for (int i = 0; i &lt;= m; i++) a[i] = arr[i]; a[m + 1] = calcn(m, a, m + 1); rep(i, 1, m + 2) a[i] = (a[i - 1] + a[i]) % mod; return calcn(m + 1, a, n - 1);&#125;ll qpolysum(ll R, ll n, ll *a, ll m) &#123; /// a[0].. a[m] \sum_&#123;i=0&#125;^&#123;n-1&#125; a[i]*R^i if (R == 1) return polysum(n, a, m); a[m + 1] = calcn(m, a, m + 1); ll r = powmod(R, mod - 2), p3 = 0, p4 = 0, c, ans; h[0][0] = 0; h[0][1] = 1; rep(i, 1, m + 2) &#123; h[i][0] = (h[i - 1][0] + a[i - 1])*r%mod; h[i][1] = h[i - 1][1] * r%mod; &#125; rep(i, 0, m + 2) &#123; ll t = g[i] * g[m + 1 - i] % mod; if (i &amp; 1) p3 = ((p3 - h[i][0] * t) % mod + mod) % mod, p4 = ((p4 - h[i][1] * t) % mod + mod) % mod; else p3 = (p3 + h[i][0] * t) % mod, p4 = (p4 + h[i][1] * t) % mod; &#125; c = powmod(p4, mod - 2)*(mod - p3) % mod; rep(i, 0, m + 2) h[i][0] = (h[i][0] + h[i][1] * c) % mod; rep(i, 0, m + 2) C[i] = h[i][0]; ans = (calcn(m, C, n)*powmod(R, n) - c) % mod; if (ans&lt;0) ans += mod; return ans;&#125;&#125; ç„¶åä¸‹é¢è¿™ä¸ªæ˜¯æ±‚å¤šé¡¹å¼çš„1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374LL temp[maxn];void mul(LL *f, int len, LL t) &#123; //lenä¸ºå¤šé¡¹å¼çš„æ¬¡æ•°+1ï¼Œå‡½æ•°è®©å¤šé¡¹å¼få˜æˆf*(x+t) for(int i = len; i &gt; 0; --i) &#123; temp[i] = f[i]; f[i] = f[i-1]; &#125; temp[0] = f[0], f[0] = 0; for(int i = 0; i &lt;= len; ++i) &#123; f[i] = (f[i] + t*temp[i])%mod; &#125;&#125;void dev(LL *f, LL *r, LL t,int len) &#123; //fæ˜¯è¢«é™¤å¤šé¡¹å¼çš„ç³»æ•°ï¼Œrä¿å­˜fé™¤ä»¥x+tçš„ç»“æœ lenæ˜¯æœ€é«˜æ¬¡é¡¹ for(int i = 0; i &lt;= len; ++i) &#123; temp[i] = f[i]; &#125; for(int i = len; i &gt; 0; --i) &#123; r[i-1] = temp[i]; temp[i-1] = (temp[i-1] - t*temp[i])%mod; &#125; return;&#125;LL a[maxn], b[maxn], c[maxn];LL x[maxn], y[maxn]; //x,yè¾“å…¥ä» 1å¼€å§‹åˆ°nint n;void lglr() &#123; memset(a,0,sizeof a); b[1] = 1, b[0] = -x[1]; for(int i = 2; i &lt;= n; ++i) &#123; mul(b, i, -x[i]); &#125;//é¢„å¤„ç†(x-x1)*(x-x2)...*(x-xn) for(int i = 1; i &lt;= n; ++i) &#123; LL fz = 1; for(int j = 1; j &lt;= n; ++j) &#123; if(j == i) continue; fz = fz*(x[i] - x[j])%mod; &#125; fz = qm(fz, mod-2); fz = fz*y[i]%mod;//å¾—åˆ°å¤šé¡¹å¼ç³»æ•° dev(b, c, -x[i],n);//å¾—åˆ°å¤šé¡¹å¼ï¼Œä¿å­˜åœ¨bæ•°ç»„ for(int j = 0; j &lt; n; ++j) a[j] = (a[j] + fz*c[j])%mod; &#125;&#125;LL cal(LL k) &#123; //è®¡ç®—ç¬¬x=kå€¼ LL ans = 0; LL res = 1; for(int i = 0; i &lt; n; ++i) &#123; ans = (ans + res*a[i])%mod; res = res*k%mod; &#125; ans = (ans + mod)%mod; return ans;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>æ•°è®º</category>
      </categories>
      <tags>
        <tag>æ•°è®º</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å¤§æ•°ç´ æ•°åˆ¤æ–­åŠè´¨å› å­åˆ†è§£]]></title>
    <url>%2F2019%2F07%2F11%2F%E5%A4%A7%E6%95%B0%E7%B4%A0%E6%95%B0%E5%88%A4%E6%96%AD%E5%8F%8A%E8%B4%A8%E5%9B%A0%E5%AD%90%E5%88%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[åˆ¤æ–­æ˜¯å¦æ˜¯ç´ æ•°å‡ ä¸ªå¸¸ç”¨çš„sqrt(n)å¤æ‚åº¦çš„å°±ä¸è¯´äº†ã€‚å¯¹äºä¸€ä¸ª longlong èŒƒå›´æˆ–è€…æ›´å¤§çš„æ•°ï¼Œæ€ä¹ˆå¿«é€Ÿåˆ¤æ–­ä¸€ä¸ªæ•°æ˜¯ä¸æ˜¯ç´ æ•°ï¼Œå°±è¦ç”¨åˆ°Miller_Rabinç®—æ³•.ç«‹ç”¨a^(n-1)=1(mod n) æ€ä¹ˆæ¥çš„å°±ä¸è§£é‡Šäº†ï¼Œæœ‰å…´è¶£çš„åŒå­¦å¯ä»¥çœ‹çœ‹ç®—æ³•å¯¼è®ºP566æœ‰è¯¦ç»†æ¨å¯¼ã€‚åœ¨è¿™ä¸ªçš„åŸºç¡€ä¸Šç”¨ éšæœºæ•°è¿›è¡Œæµ‹è¯•ï¼ˆç›´æ¥ç”¨çš„è¯ä¼šæœ‰ä¸€äº›ä¼ªç´ æ•°ï¼‰ã€‚é‡Œé¢ aç”¨éšæœºæ•°éšæœºï¼Œ (n-1) å†™æˆ 2^r*s ä¸ºå•¥è¿™ä¹ˆå†™æˆ‘ä¹Ÿä¸çŸ¥é“ï¼Œåæ­£å¤§å®¶éƒ½æ˜¯è¿™ä¹ˆå†™çš„ qaqç„¶åå°±æ ¹æ®ä¸Šé¢é‚£ä¸ªåˆ¤æ–­å°±è¡Œäº†è¿™ä¸ªç®—æ³•æœ‰æ—¶å€™ä¼šå‡ºé”™ï¼Œå‡ºé”™çš„æ¦‚ç‡å·®ä¸å¤šæ˜¯ 2^-å¾ªç¯æ¬¡æ•°12345678910111213141516171819202122232425262728293031323334353637inline LL ksc(LL x,LL n,LL mod) &#123; LL res=0; while(n&gt;0) &#123; if(n&amp;1)res=(res+x)%mod; x=(x+x)%mod; n&gt;&gt;=1; &#125; return res%mod;&#125;inline LL ksm(LL x,LL n,LL mod) &#123; LL res=1; while(n&gt;0) &#123; if(n&amp;1)res=ksc(res,x,mod); x=ksc(x,x,mod); n&gt;&gt;=1; &#125; return res%mod;&#125;bool check(LL x) &#123; //Miller_Rabinç®—æ³•ï¼Œåˆ¤æ–­næ˜¯å¦ä¸ºç´ æ•° for(int i=0; i&lt;50; i++) &#123; int a=rand()%(x-1)+1,k=0; LL t=x-1; if(ksm(a,x-1,x)!=1)return 0; while(t&amp;1==0) &#123; ++k; t&gt;&gt;=1; &#125; LL u=ksm(a,t,x),l=u; for(int i=1; i&lt;=k; i++) &#123; u=ksc(u,u,x); if(u==1&amp;&amp;l!=1&amp;&amp;l!=x-1)return 0; l=u; &#125; &#125; return 1;&#125; è´¨å› å­åˆ†è§£pollard_rhoç®—æ³•,è¿™ä¸ªç®—æ³•ååˆ†ç„å­¦ï¼Œæ‰¾åˆ°ä¸€ä¸ªæ•°x0 ï¼Œç„¶åç”¨ä¸€ä¸ªç„å­¦é€’æ¨å¾—åˆ° x1=x0*x0 + ä¸€ä¸ªéšæœºæ•° ç„¶åç”¨ä¸¤ä¸ªçš„å·®å€¼å»å’Œ nåš gcd ç„¶åå¾—å‡ºæ¥å¦‚æœæ˜¯1å°±ç»§ç»­æ‰¾ï¼Œå¦‚æœä¸æ˜¯1 ä¸å°±æ˜¯ä¸ªå› å­å—ï¼Ÿ ï¼ˆä¸ªäººç†è§£æœ‰ç‚¹åƒç›´æ¥éšæœºä¸€ä¸ªæ•°å’Œä»–åšGCDæœ‰æ²¡æœ‰å…¬çº¦æ•°ã€‚ã€‚ã€‚ã€‚ï¼‰ è¡¥å……è¯´æ˜ä¸€ä¸‹ x=(x*x +c)%n æ˜¯ä¸€ä¸ªæ»šå¾ªç¯ åƒÏæ‰€ä»¥ç§°ä¸ºpollard_rhoç®—æ³•ï¼Œæ‰€ä»¥è¦åˆ¤æ–­å¾ªç¯ç»“ ç”¨ floyd åˆ¤æ–­ã€‚1234567891011121314151617181920212223242526272829303132333435363738LL pollard_rho(LL n, LL c) &#123; LL i = 1, k = 2; LL x = rand() % (n - 1) + 1; LL y = x; while (1) &#123; i++; x = (ksc(x, x, n) + c) % n; //ç„å­¦é€’æ¨ LL d = __gcd((y - x + n) % n, n); if (1LL &lt; d &amp;&amp; d &lt; n) &#123; //å¦‚æœæœ‰å› å­å°±ç›´æ¥è¿”å› return d; &#125; if (y == x) &#123; //å¦‚æœæ‰¾åˆ°äº†å¾ªç¯èŠ‚å°±è·³å‡º return n; &#125; if (i == k) &#123; //ç©ºé—´ o1 åˆ¤æ–­å¾ªç¯èŠ‚ç”¨çš„ ï¼Œçœ‹ä¸æ‡‚ä½ æ²¡æ•‘äº† y = x; k &lt;&lt;= 1; &#125; &#125;&#125;LL fac[100],ct;void find(LL n, int c) &#123; if (n == 1) &#123; return; &#125; if (check(n)) &#123; fac[ct++] = n; //æ˜¯ä¸ªè´¨å› å­ return; &#125; LL p = n; LL k = c; while (p &gt;= n) &#123; p = pollard_rho(p, c--); //å¦‚æœæ˜¯åˆæ•°æ€»ä¼šæ‰¾åˆ°ä¸€ä¸ªå› å­ &#125; find(p, k); //ç»§ç»­æ‰¾ find(n / p, k);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>æ•°è®º</category>
      </categories>
      <tags>
        <tag>æ•°è®º</tag>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å¦‚ä½•å°†æœ¬åœ°é¡¹ç›®ä¼ å…¥github]]></title>
    <url>%2F2019%2F06%2F24%2F%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%BC%A0%E5%85%A5github%2F</url>
    <content type="text"><![CDATA[åˆå§‹åŒ–æ–‡ä»¶å¤¹åœ¨æœ¬åœ°æ‰§è¡Œgit initå‘½ä»¤1git init æ·»åŠ éœ€è¦ä¸Šä¼ åˆ°githubçš„ä»£ç åˆ°æœ¬åœ°ä»“åº“git statusæŸ¥çœ‹å“ªäº›æ–‡ä»¶æ˜¯æ²¡æœ‰åŠ å…¥åˆ°æœ¬åœ°ä»“åº“çš„ï¼Œçº¢è‰²çš„æ²¡æœ‰ï¼Œç»¿è‰²æ˜¯å·²ç»æ·»åŠ äº†çš„ã€‚ 1git add å¯ä»¥æŠŠéœ€è¦çš„æ–‡ä»¶åŠ å…¥æœ¬åœ°ä»“åº“ å°†addçš„æ–‡ä»¶commitåˆ°ä»“åº“1git commit -m &quot;ç¬¬ä¸€æ¬¡æäº¤&quot; å»githubä¸Šåˆ›å»ºè‡ªå·±çš„Repositoryè¿™ä¸ªä¸ç”¨æ•™äº†å§ å°†æœ¬åœ°çš„ä»“åº“å…³è”åˆ°githubä¸Š1git remote add origin +é“¾æ¥ ä¸Šä¼ ä»£ç åˆ°githubè¿œç¨‹ä»“åº“12git push #ä¼ ä¸Šå»git pull #æ‹‰å›æ¥ 123git pull --rebase origin mastergit push -u origin master]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEAè¿æ¥myqslæ•°æ®åº“]]></title>
    <url>%2F2019%2F05%2F24%2FIDEA%E8%BF%9E%E6%8E%A5myqsl%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[ç¬¬ä¸€æ­¥ç„¶åå³è¾¹å°±ä¼šå‡ºç°ä¸€ä¸ªdatabase è¿™ä¸ªåœ°æ–¹å¯èƒ½è¦æ›´æ–°ä¸€ä¸‹é©±åŠ¨ï¼Œidea æœ‰è‡ªå¸¦æ›´æ–°ï¼Œç‚¹ä¸€ä¸‹ä¸‹é¢é‚£ä¸ª MySQL å°±è¡Œæ·»åŠ è¿æ¥æ•°æ®åº“çš„JavaåŒ…é€‰æ‹©æ‰¾åˆ°çš„åŒ…æ·»åŠ å¥½ååº”è¯¥ä¼šåœ¨ä¸‹é¢å¤šä¸€ä¸ªè¿™æ ·çš„åŒ…è¿æ¥æ•°æ®åº“å°±æˆåŠŸäº†æµ‹è¯•ä¸€ä¸‹ï¼Œå…·ä½“æµ‹è¯•æ ¹æ®ä½ è‡ªå·±æ•°æ®åº“æ¥ï¼Œåé¢æˆ‘æ‰“æœ‰æ³¨é‡Š1234567891011121314151617181920212223242526272829303132package longpf;import java.sql.*;public class My &#123; public static void main(String[] args) &#123; Connection conn = null; //å»ºç«‹ä¸€ä¸ªæ•°æ®åº“è¿æ¥ try &#123; Class.forName( "com.mysql.jdbc.Driver"); //åŠ è½½é©±åŠ¨ System.out.println("æ•°æ®åº“é©±åŠ¨åŠ è½½æˆåŠŸ"); long start=System.currentTimeMillis(); //è®°å½•å¼€å§‹æ—¶é—´ conn=DriverManager.getConnection("jdbc:mysql://localhost:3306/mygamedb","root","root"); //è¿æ¥æ•°æ®åº“ï¼Œå‚æ•°æ•°æ®åº“ä½ç½®ï¼Œç”¨æˆ·å å¯†ç  long end=System.currentTimeMillis(); // è®°å½•ç»“æŸæ—¶é—´ System.out.println(conn); // æ‰“å°è¿æ¥ System.out.println("å»ºç«‹ç”¨æ—¶ï¼š"+(end-start)+"ms"); // åˆ›å»ºStatementå¯¹è±¡ Statement stmt = conn.createStatement(); // æ‰§è¡ŒSQLè¯­å¥ ResultSet rs = stmt.executeQuery("select * from users"); System.out.println("id\tusername\tpwd\t\tregTime"); while (rs.next()) &#123; System.out.println(rs.getInt(1) + "\t" + rs.getString(2) + "\t\t" + rs.getString(3)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return; &#125;&#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlå­¦ä¹ ç¬”è®°(ä¸‰)]]></title>
    <url>%2F2019%2F05%2F19%2Fsql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[sqlçš„ç‰¹ç‚¹SQLè¯­è¨€é›†æ•°æ®æŸ¥è¯¢ï¼ˆdata queryï¼‰ã€æ•°æ®æ“çºµï¼ˆdata manipulationï¼‰ã€æ•°æ®å®šä¹‰ï¼ˆdata definitionï¼‰å’Œæ•°æ®æ§åˆ¶ï¼ˆdata controlï¼‰åŠŸèƒ½äºä¸€ä½“ï¼Œå……åˆ†ä½“ç°äº†å…³ç³»æ•°æ®è¯­è¨€çš„ç‰¹ç‚¹å’Œä¼˜ç‚¹ã€‚å…¶ä¸»è¦ç‰¹ç‚¹åŒ…æ‹¬ï¼š 1.ç»¼åˆç»Ÿä¸€SQLè¯­è¨€é›†æ•°æ®å®šä¹‰è¯­è¨€DDLã€æ•°æ®æ“çºµè¯­è¨€DMLã€æ•°æ®æ§åˆ¶è¯­è¨€DCLçš„åŠŸèƒ½äºä¸€ä½“ï¼Œè¯­è¨€é£æ ¼ç»Ÿä¸€ï¼Œå¯ä»¥ç‹¬ç«‹å®Œæˆæ•°æ®åº“ç”Ÿå‘½å‘¨æœŸä¸­çš„å…¨éƒ¨æ´»åŠ¨ï¼ŒåŒ…æ‹¬å®šä¹‰å…³ç³»æ¨¡å¼ã€å½•å…¥æ•°æ®ä»¥å»ºç«‹æ•°æ®åº“ã€æŸ¥è¯¢ã€æ›´æ–°ã€ç»´æŠ¤ã€æ•°æ®åº“é‡æ„ã€æ•°æ®åº“å®‰å…¨æ€§æ§åˆ¶ç­‰ä¸€ç³»åˆ—æ“ä½œè¦æ±‚ï¼Œè¿™å°±ä¸ºæ•°æ®åº“åº”ç”¨ç³»ç»Ÿå¼€å‘æä¾›äº†è‰¯å¥½çš„ç¯å¢ƒï¼Œä¾‹å¦‚ç”¨æˆ·åœ¨æ•°æ®åº“æŠ•å…¥è¿è¡Œåï¼Œè¿˜å¯æ ¹æ®éœ€è¦éšæ—¶åœ°é€æ­¥åœ°ä¿®æ”¹æ¨¡å¼ï¼Œå¹¶ä¸å½±å“æ•°æ®åº“çš„è¿è¡Œï¼Œä»è€Œä½¿ç³»ç»Ÿå…·æœ‰è‰¯å¥½çš„å¯æ‰©å……æ€§ã€‚ 2.é«˜åº¦éè¿‡ç¨‹åŒ–éå…³ç³»æ•°æ®æ¨¡å‹çš„æ•°æ®æ“çºµè¯­è¨€æ˜¯é¢å‘è¿‡ç¨‹çš„è¯­è¨€ï¼Œç”¨å…¶å®ŒæˆæŸé¡¹è¯·æ±‚ï¼Œå¿…é¡»æŒ‡å®šå­˜å–è·¯å¾„ã€‚è€Œç”¨SQLè¯­è¨€è¿›è¡Œæ•°æ®æ“ä½œï¼Œç”¨æˆ·åªéœ€æå‡ºâ€œåšä»€ä¹ˆâ€ï¼Œè€Œä¸å¿…æŒ‡æ˜â€œæ€ä¹ˆåšâ€ï¼Œå› æ­¤ç”¨æˆ·æ— éœ€äº†è§£å­˜å–è·¯å¾„ï¼Œå­˜å–è·¯å¾„çš„é€‰æ‹©ä»¥åŠSQLè¯­å¥çš„æ“ä½œè¿‡ç¨‹ç”±ç³»ç»Ÿè‡ªåŠ¨å®Œæˆã€‚è¿™ä¸ä½†å¤§å¤§å‡è½»äº†ç”¨æˆ·è´Ÿæ‹…ï¼Œè€Œä¸”æœ‰åˆ©äºæé«˜æ•°æ®ç‹¬ç«‹æ€§ã€‚ 3.é¢å‘é›†åˆçš„æ“ä½œæ–¹å¼SQLè¯­è¨€é‡‡ç”¨é›†åˆæ“ä½œæ–¹å¼ï¼Œä¸ä»…æŸ¥æ‰¾ç»“æœå¯ä»¥æ˜¯å…ƒç»„çš„é›†åˆï¼Œè€Œä¸”ä¸€æ¬¡æ’å…¥ã€åˆ é™¤ã€æ›´æ–°æ“ä½œçš„å¯¹è±¡ä¹Ÿå¯ä»¥æ˜¯å…ƒç»„çš„é›†åˆã€‚éå…³ç³»æ•°æ®æ¨¡å‹é‡‡ç”¨çš„æ˜¯é¢å‘è®°å½•çš„æ“ä½œæ–¹å¼ï¼Œä»»ä½•ä¸€ä¸ªæ“ä½œå…¶å¯¹è±¡éƒ½æ˜¯ä¸€æ¡è®°å½•ã€‚ä¾‹å¦‚æŸ¥è¯¢æ‰€æœ‰å¹³å‡æˆç»©åœ¨80åˆ†ä»¥ä¸Šçš„å­¦ç”Ÿå§“åï¼Œç”¨æˆ·å¿…é¡»è¯´æ˜å®Œæˆè¯¥è¯·æ±‚çš„å…·ä½“å¤„ç†è¿‡ç¨‹ï¼Œå³å¦‚ä½•ç”¨å¾ªç¯ç»“æ„æŒ‰ç…§æŸæ¡è·¯å¾„ä¸€æ¡ä¸€æ¡åœ°æŠŠæ»¡è¶³æ¡ä»¶çš„å­¦ç”Ÿè®°å½•è¯»å‡ºæ¥ã€‚ 4.ä»¥åŒä¸€ç§è¯­æ³•ç»“æ„æä¾›ä¸¤ç§ä½¿ç”¨æ–¹å¼SQLè¯­è¨€æ—¢æ˜¯è‡ªå«å¼è¯­è¨€ï¼Œåˆæ˜¯åµŒå…¥å¼è¯­è¨€ã€‚ä½œä¸ºè‡ªå«å¼è¯­è¨€ï¼Œå®ƒèƒ½å¤Ÿç‹¬ç«‹åœ°ç”¨äºè”æœºäº¤äº’çš„ä½¿ç”¨æ–¹å¼ï¼Œç”¨æˆ·å¯ä»¥åœ¨ç»ˆç«¯é”®ç›˜ä¸Šç›´æ¥é”®å…¥SQLå‘½ä»¤å¯¹æ•°æ®åº“è¿›è¡Œæ“ä½œã€‚ä½œä¸ºåµŒå…¥å¼è¯­è¨€ï¼ŒSQLè¯­å¥èƒ½å¤ŸåµŒå…¥åˆ°é«˜çº§è¯­è¨€ï¼ˆä¾‹å¦‚Cã€PBï¼‰ç¨‹åºä¸­ï¼Œä¾›ç¨‹åºå‘˜è®¾è®¡ç¨‹åºæ—¶ä½¿ç”¨ã€‚è€Œåœ¨ä¸¤ç§ä¸åŒçš„ä½¿ç”¨æ–¹å¼ä¸‹ï¼ŒSQLè¯­è¨€çš„è¯­æ³•ç»“æ„åŸºæœ¬ä¸Šæ˜¯ä¸€è‡´çš„ã€‚è¿™ç§ä»¥ç»Ÿä¸€çš„è¯­æ³•ç»“æ„æä¾›ä¸¤ç§ä¸åŒçš„ä½¿ç”¨æ–¹å¼çš„ä½œæ³•ï¼Œä¸ºç”¨æˆ·æä¾›äº†æå¤§çš„çµæ´»æ€§ä¸æ–¹ä¾¿æ€§ã€‚ ä»¥ä¸Šéƒ½æ˜¯åºŸè¯ å‰é¢è¯´è¿‡ä¸‰å±‚ç»“æ„ï¼Œå¤–æ¨¡å¼ï¼Œæ¨¡å¼ï¼Œå†…æ¨¡å¼ï¼Œå¤–æ¨¡å¼å°±å¯¹åº”sql é‡Œé¢çš„è§†å›¾ ï¼Œæ¨¡å¼å¯¹åº”è¡¨ï¼Œå†…æ¨¡å¼å°±æ˜¯å¯¹åº”å‚¨å­˜æ–‡ä»¶äº†(è¿™ä¸ªå¹¶ä¸éœ€è¦ç®¡)åé¢è¯´å®ç”¨çš„äº† SQLè¯­æ³•1.æ¨¡å¼åˆ›å»º1create schema æ¨¡å¼å; åˆ é™¤1drop schema æ¨¡å¼å; å®šä¹‰ä¸€ä¸ªåŸºæœ¬è¡¨create table è¡¨å(åˆ—å æ•°æ®ç±»å‹ çº¦æŸæ¡ä»¶,åˆ—å æ•°æ®ç±»å‹ çº¦æŸæ¡ä»¶,åˆ—å æ•°æ®ç±»å‹ çº¦æŸæ¡ä»¶)1create table]]></content>
      <categories>
        <category>æ•°æ®åº“</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>æ•°æ®åº“</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlå­¦ä¹ ç¬”è®°(äºŒ)å…³ç³»æ•°æ®åº“]]></title>
    <url>%2F2019%2F05%2F19%2Fsql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[å…³ç³»å…³ç³»æ¨¡å‹çš„æ•°æ®ç»“æ„éå¸¸ç®€å•ï¼ŒåªåŒ…å«å•ä¸€çš„æ•°æ®ç»“æ„ï¼Œå…³ç³»ã€‚åœ¨ç”¨æˆ·çœ‹æ¥å°±æ˜¯ä¸€å¼ è¡¨ã€‚ 1.åŸŸåŸŸæ˜¯ä¸€ç»„å…·æœ‰ç›¸åŒçš„æ•°æ®ç±»å‹çš„å€¼çš„é›†åˆã€‚æ¯”å¦‚æ€§åˆ«{ç”·,å¥³} 2.ç¬›å¡å°”ç§¯ä¸€å †åŸŸçš„ä¹˜ç§¯ã€‚D1*D2*D3*â€¦*Dn = {d1,â€¦,dn|di in Di};æ¯ä¸ª (d1â€¦dn) å«å…ƒç»„ï¼Œæ¯ä¸ªå€¼å«åˆ†é‡ã€‚ä¸€ä¸ªåŸŸçš„ä¸åŒå–å€¼å«åšè¿™ä¸ªåŸŸçš„åŸºæ•° 3.å…³ç³»D1*D2...*Dn çš„å­é›†å«åšåœ¨D1,â€¦ï¼ŒDnä¸Šçš„å…³ç³»ã€‚n è¢«ç§°åšç›®æˆ–åº¦n=1 å•å…ƒå…³ç³»ï¼Œn=2 äºŒå…ƒå…³ç³»å€™é€‰ç æŸä¸€å±æ€§ç»„èƒ½å¤Ÿå”¯ä¸€åœ°è¡¨ç¤ºä¸€ä¸ªå…ƒç»„ï¼Œè€Œå…¶å­é›†ä¸èƒ½ã€‚æœ‰å¤šä¸ªå€™é€‰ç çš„æ—¶å€™é€‰ä¸€ä¸ªä½œä¸ºä¸»ç å€™é€‰ç çš„è¯¸å±æ€§å«åšä¸»å±æ€§ï¼Œå…¶ä½™è¢«ç§°ä¸ºéä¸»å±æ€§æˆ–éç å±æ€§ åŸºæœ¬çš„å…³ç³»æ“ä½œæŸ¥è¯¢æ“ä½œ(query),æ’å…¥(insert)ï¼Œåˆ é™¤(delete)ï¼Œä¿®æ”¹(update)æŸ¥è¯¢å…¶ä¸­åˆæœ‰ é€‰æ‹©(select)ã€æŠ•å½±(project)ã€è¿æ¥(join)ã€é™¤(divide)ã€å¹¶(union)ã€å·®(except)ã€äº¤(intersection);]]></content>
      <categories>
        <category>æ•°æ®åº“</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>æ•°æ®åº“</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlå­¦ä¹ ç¬”è®°ï¼ˆä¸€ï¼‰åŸºæœ¬ä»‹ç»]]></title>
    <url>%2F2019%2F05%2F19%2Fsql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[æ•°æ®åº“åŸºæœ¬æ¦‚å¿µ1.æ•°æ®(Data): ä¾‹å¦‚ æ–‡æœ¬(text)ã€å›¾å½¢(graph)ã€å›¾åƒ(image)ã€éŸ³é¢‘(audio)ã€è§†é¢‘(video)ç­‰.2.æ•°æ®åº“(Database) DB: æ•°æ®åº“æŒ‡çš„æ˜¯ä»¥ä¸€ä¸€å®šæ–¹å¼å‚¨å­˜åœ¨ä¸€èµ·ã€èƒ½ä¸ºå¤šä¸ªç”¨æˆ·å…±äº«ã€å…·æœ‰å°½å¯èƒ½å°çš„å†—ä½™åº¦ã€ä¸åº”ç”¨ç¨‹åºå½¼æ­¤ç‹¬ç«‹çš„æ•°æ®é›†åˆã€‚å®ƒå…·æœ‰æ•´ä½“æ€§ã€å…±äº«æ€§ã€‚3.æ•°æ®åº“ç®¡ç†ç³»ç»Ÿ(DataBase Management System)DBMS4.æ•°æ®åº“ç³»ç»Ÿ(DataBase System) DBS æ•°æ®æ¨¡å‹æ•°æ®æ¨¡å‹æ˜¯å¯¹ç°å®ä¸–ç•Œæ•°æ®ç‰¹å¾çš„æŠ½è±¡ä¸¤ç±»æ•°æ®æ¨¡å‹ æ¦‚å¿µæ¨¡å‹ é€»è¾‘æ¨¡å‹å’Œç‰©ç†æ¨¡å‹ å¸¸ç”¨çš„æ•°æ®æ¨¡å‹ å±‚æ¬¡æ¨¡å‹ ç½‘çŠ¶æ¨¡å‹ å…³ç³»æ¨¡å‹ é¢å‘å¯¹è±¡æ•°æ®æ¨¡å‹ å¯¹è±¡å…³ç³»æ•°æ®æ¨¡å‹ åŠç»“æ„åŒ–æ•°æ®æ¨¡å‹ æ•°æ®åº“ä¸‰å±‚æ¨¡å¼ä¸¤å±‚æ˜ å°„ 1.æ¨¡å¼æ¨¡å¼ä¹Ÿç§°æ¦‚å¿µæ¨¡å¼ï¼Œæ˜¯æ•°æ®åº“ä¸­å…¨éƒ¨æ•°æ®çš„é€»è¾‘ç»“æ„å’Œç‰¹å¾çš„æè¿°ï¼Œå®ƒç”±è‹¥å¹²ä¸ªæ¦‚å¿µè®°å½•ç±»å‹ç»„æˆï¼Œåªæ¶‰åŠè¡Œçš„æè¿°ï¼Œä¸æ¶‰åŠå…·ä½“çš„å€¼ã€‚æ¦‚å¿µæ¨¡å¼çš„ä¸€ä¸ªå…·ä½“å€¼ç§°ä¸ºæ¨¡å¼çš„ä¸€ä¸ªå®ä¾‹ï¼ŒåŒä¸€ä¸ªæ¨¡å¼å¯ä»¥æœ‰å¾ˆå¤šå®ä¾‹ã€‚æ¦‚å¿µæ¨¡å¼åæ˜ çš„æ˜¯æ•°æ®åº“çš„ç»“æ„åŠå…¶è”ç³»ï¼Œæ‰€ä»¥æ˜¯ç›¸å¯¹ç¨³å®šçš„ï¼›è€Œå®ä¾‹åæ˜ çš„æ˜¯æ•°æ®åº“æŸä¸€æ—¶åˆ»çš„çŠ¶æ€ï¼Œæ‰€ä»¥æ˜¯ç›¸å¯¹å˜åŠ¨çš„ã€‚éœ€è¦è¯´æ˜çš„æ˜¯ï¼Œæ¦‚å¿µæ¨¡å¼ä¸ä»…è¦æè¿°æ¦‚å¿µè®°å½•ç±»å‹ï¼Œè¿˜è¦æè¿°è®°å½•é—´çš„è”ç³»ã€æ“ä½œã€æ•°æ®çš„å®Œæ•´æ€§å’Œå®‰å…¨æ€§ç­‰è¦æ±‚ã€‚ä½†æ˜¯ï¼Œæ¦‚å¿µæ¨¡å¼ä¸æ¶‰åŠå­˜å‚¨ç»“æ„ã€è®¿é—®æŠ€æœ¯ç­‰ç»†èŠ‚ã€‚åªæœ‰è¿™æ ·ï¼Œæ¦‚å¿µæ¨¡å¼æ‰ç®—åšåˆ°äº†â€œç‰©ç†æ•°æ®ç‹¬ç«‹æ€§â€ã€‚æè¿°æ¦‚å¿µæ¨¡å¼çš„æ•°æ®å®šä¹‰è¯­è¨€ç§°ä¸ºâ€œæ¨¡å¼DDLâ€ 2.å¤–æ¨¡å¼å¤–æ¨¡å¼ä¹Ÿç§°ç”¨æˆ·æ¨¡å¼æˆ–å­æ¨¡å¼ï¼Œæ˜¯ç”¨æˆ·ä¸æ•°æ®åº“ç³»ç»Ÿçš„æ¥å£ï¼Œæ˜¯ç”¨æˆ·ç”¨åˆ°çš„é‚£éƒ¨åˆ†æ•°æ®çš„æè¿°ã€‚å®ƒç”±è‹¥å¹²ä¸ªå¤–éƒ¨è®°å½•ç±»å‹ç»„æˆã€‚ç”¨æˆ·ä½¿ç”¨æ•°æ®æ“çºµè¯­è¨€å¯¹æ•°æ®åº“è¿›è¡Œæ“ä½œï¼Œå®é™…ä¸Šæ˜¯å¯¹å¤–æ¨¡å¼çš„å¤–éƒ¨è®°å½•è¿›è¡Œæ“ä½œã€‚æè¿°å¤–æ¨¡å¼çš„æ•°æ®å®šä¹‰è¯­è¨€ç§°ä¸ºâ€œå¤–æ¨¡å¼DDLâ€ã€‚æœ‰äº†å¤–æ¨¡å¼åï¼Œç¨‹åºå‘˜ä¸å¿…å…³å¿ƒæ¦‚å¿µæ¨¡å¼ï¼Œåªä¸å¤–æ¨¡å¼å‘ç”Ÿè”ç³»ï¼ŒæŒ‰å¤–æ¨¡å¼çš„ç»“æ„å­˜å‚¨å’Œæ“ä½œæ•°æ®ã€‚ 3.å†…æ¨¡å¼å†…æ¨¡å¼ä¹Ÿç§°ä¸ºå­˜å‚¨æ¨¡å¼ï¼Œæ˜¯æ•°æ®ç‰©ç†ç»“æ„å’Œå­˜å‚¨æ–¹å¼çš„æè¿°ï¼Œæ˜¯æ•°æ®åœ¨æ•°æ®åº“å†…éƒ¨çš„è¡¨ç¤ºæ–¹å¼ã€‚éœ€è¦å®šä¹‰æ‰€ä»¥çš„å†…éƒ¨è®°å½•ç±»å‹ã€ç´¢å¼•å’Œæ–‡ä»¶çš„ç»„ç»‡æ–¹å¼ï¼Œä»¥åŠæ•°æ®æ§åˆ¶æ–¹é¢çš„ç»†èŠ‚ã€‚ä¾‹å¦‚ï¼Œè®°å½•çš„å­˜å‚¨æ–¹å¼æ˜¯é¡ºåºå­˜å‚¨ã€Bæ ‘ç»“æ„å­˜å‚¨è¿˜æ˜¯Hashæ–¹æ³•å­˜å‚¨ï¼›ç´¢å¼•æŒ‰ç…§ä»€ä¹ˆæ–¹å¼ç»„ç»‡ï¼›æ•°æ®æ˜¯å¦å‹ç¼©å­˜å‚¨ï¼Œæ˜¯å¦åŠ å¯†ï¼›æ•°æ®çš„å­˜å‚¨è®°å½•ç»“æ„æœ‰ä½•è§„å®šã€‚éœ€è¦è¯´æ˜çš„æ˜¯ï¼Œå†…éƒ¨è®°å½•å¹¶ä¸æ¶‰åŠç‰©ç†è®°å½•ï¼Œä¹Ÿä¸æ¶‰åŠè®¾å¤‡çš„çº¦æŸã€‚æ¯”å†…æ¨¡å¼æ›´æ¥è¿‘äºç‰©ç†å­˜å‚¨å’Œè®¿é—®çš„é‚£äº›è½¯ä»¶æœºåˆ¶æ˜¯æ“ä½œç³»ç»Ÿçš„ä¸€éƒ¨åˆ†ï¼ˆå³æ–‡ä»¶ç³»ç»Ÿï¼‰ã€‚ä¾‹å¦‚ï¼Œä»ç£ç›˜ä¸Šè¯»ã€å†™æ•°æ®ã€‚æè¿°å†…æ¨¡å¼çš„æ•°æ®å®šä¹‰è¯­è¨€ç§°ä¸ºâ€œå†…æ¨¡å¼DDLâ€ã€‚æ€»ä¹‹ï¼Œæ•°æ®æŒ‰å¤–æ¨¡å¼çš„æè¿°æä¾›ç»™ç”¨æˆ·ï¼›æŒ‰å†…æ¨¡å¼çš„æè¿°å­˜å‚¨åœ¨ç£ç›˜ä¸Šï¼›è€Œæ¦‚å¿µæ¨¡å¼æä¾›äº†è¿æ¥è¿™ä¸¤çº§æ¨¡å¼çš„ç›¸å¯¹ç¨³å®šçš„ä¸­é—´å±‚ï¼Œå¹¶ä½¿å¾—ä¸¤çº§ä¸­ä»»æ„ä¸€çº§çš„æ”¹å˜éƒ½ä¸å—å¦ä¸€çº§çš„ç‰µåˆ¶ 4.ä¸‰çº§æ¨¡å¼ä¸¤çº§æ˜ åƒæ•°æ®åº“ç³»ç»Ÿåœ¨ä¸‰çº§æ¨¡å¼ä¹‹é—´æä¾›äº†ä¸¤çº§æ˜ åƒï¼šæ¨¡å¼/å†…æ¨¡å¼çš„æ˜ åƒã€å¤–æ¨¡å¼/æ¨¡å¼çš„æ˜ åƒã€‚è¿™ä¸¤çº§æ˜ å°„ä¿è¯äº†æ•°æ®åº“ä¸­çš„æ•°æ®å…·æœ‰è¾ƒé«˜çš„ç‰©ç†ç‹¬ç«‹æ€§å’Œé€»è¾‘ç‹¬ç«‹æ€§ã€‚ æ¨¡å¼/å†…æ¨¡å¼çš„æ˜ åƒï¼šå®ç°æ¦‚å¿µæ¨¡å¼åˆ°å†…æ¨¡å¼ä¹‹é—´çš„ç›¸äº’è½¬æ¢ã€‚ å¤–æ¨¡å¼/æ¨¡å¼çš„æ˜ åƒï¼šå®ç°å¤–æ¨¡å¼åˆ°æ¦‚å¿µæ¨¡å¼ä¹‹é—´çš„ç›¸äº’è½¬æ¢ã€‚ æ•°æ®çš„ç‹¬ç«‹æ€§æ˜¯æŒ‡æ•°æ®ä¸ç¨‹åºç‹¬ç«‹ï¼Œå°†æ•°æ®çš„å®šä¹‰ä»ç¨‹åºä¸­åˆ†ç¦»å‡ºå»ï¼Œç”±DBMSè´Ÿè´£æ•°æ®çš„å­˜å‚¨ï¼Œä»è€Œç®€åŒ–åº”ç”¨ç¨‹åºï¼Œå¤§å¤§å‡å°‘åº”ç”¨ç¨‹åºç¼–åˆ¶çš„å·¥ä½œé‡ã€‚æ•°æ®çš„ç‹¬ç«‹æ€§æ˜¯ç”±DBMSçš„äºŒçº§æ˜ åƒåŠŸèƒ½æ¥ä¿è¯çš„ã€‚æ•°æ®çš„ç‹¬ç«‹æ€§åŒ…æ‹¬æ•°æ®çš„ç‰©ç†ç‹¬ç«‹æ€§å’Œæ•°æ®çš„é€»è¾‘ç‹¬ç«‹æ€§ã€‚æ•°æ®çš„ç‰©ç†ç‹¬ç«‹æ€§æ˜¯æŒ‡å½“æ•°æ®åº“çš„å†…æ¨¡å¼å‘ç”Ÿæ”¹å˜æ—¶ï¼Œæ•°æ®çš„çš„é€»è¾‘ç»“æ„ä¸å˜ã€‚ç”±äºåº”ç”¨ç¨‹åºå¤„ç†çš„åªæ˜¯æ•°æ®çš„é€»è¾‘ç»“æ„ï¼Œè¿™æ ·ç‰©ç†ç‹¬ç«‹æ€§å¯ä»¥ä¿è¯ï¼Œå½“æ•°æ®çš„ç‰©ç†ç»“æ„æ”¹å˜äº†ï¼Œåº”ç”¨ç¨‹åºä¸ç”¨æ”¹å˜ã€‚ä½†æ˜¯ï¼Œä¸ºäº†ä¿è¯åº”ç”¨ç¨‹åºèƒ½å¤Ÿæ­£ç¡®æ‰§è¡Œï¼Œéœ€è¦ä¿®æ”¹æ¦‚å¿µæ¨¡å¼/å†…æ¨¡å¼ä¹‹é—´çš„æ˜ åƒã€‚æ•°æ®çš„é€»è¾‘ç‹¬ç«‹æ€§æ˜¯æŒ‡ç”¨æˆ·çš„åº”ç”¨ç¨‹åºä¸æ•°æ®åº“ç»“æ„æ˜¯ç›¸äº’ç‹¬ç«‹çš„ã€‚æ•°æ®çš„é€»è¾‘ç»“æ„å‘ç”Ÿå˜åŒ–åï¼Œç”¨æˆ·ç¨‹åºä¹Ÿå¯ä»¥ä¸ä¿®æ”¹ã€‚ä½†æ˜¯ï¼Œä¸ºäº†ä¿è¯åº”ç”¨ç¨‹åºèƒ½å¤Ÿæ­£ç¡®æ‰§è¡Œï¼Œéœ€è¦ä¿®æ”¹å¤–æ¨¡å¼/æ¦‚å¿µæ¨¡å¼ä¹‹é—´çš„æ˜ åƒã€‚]]></content>
      <categories>
        <category>æ•°æ®åº“</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>æ•°æ®åº“</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EC-FINAL I Misunderstood Missing]]></title>
    <url>%2F2019%2F04%2F25%2FEC-FINAL-I%2F</url>
    <content type="text"><![CDATA[å†™æ­¤ç¯‡è®°å½•EC-FINAL é“ç‰Œã€‚I Misunderstood â€¦ Missingæ­¤é¢˜ï¼Œæ˜¯ECæ‰“é“çš„ä¸»è¦åŸå› ã€‚åœ¨ç‰›å®¢çš„é‚£ä¸ªç½‘ç«™ä¸Šæ­¤é¢˜å‡ºçš„æ¯”Fé¢˜è¿˜è¦å¤šï¼Œç„¶è€Œæˆ‘åœ¨æ¯”èµ›ä¸­å´æ²¡æœ‰å†™å‡ºæ¥ï¼Œå¦‚æœè¿™é¢˜å†™å‡ºæ¥äº†ï¼Œå¯èƒ½è¿˜æœ‰æ•‘ã€‚å¯¹äºè¿™é¢˜DPæ²¡å†™å‡ºæ¥ï¼Œæ„Ÿè§‰æ˜¯çœŸçš„å‚»é€¼ã€‚ä»¥åæ‰“æ¯”èµ›åˆ‡è®°ä¸å¯ä»¥æ…Œå¼ ï¼Œæ…Œå¼ å¹¶ä¸èƒ½è§£å†³é—®é¢˜ï¼Œè¿™é¢˜å¦‚æœé™ä¸‹å¿ƒæ¥æ€è€ƒåº”è¯¥ä¸éš¾æƒ³å‡ºæ¥ã€‚é¢˜æ„ï¼št ç»„æ•°æ® n ä¸ªå›åˆåˆå§‹æˆ˜åŠ› A ä¸º 0 åé¢æœ‰n ä¸ªå›åˆï¼Œæ¯ä¸ªå›åˆå¯ä»¥è¿›è¡Œä¸€ä¸ªæ“ä½œ1å¯ä»¥é€ æˆA+aç‚¹ä¼¤å®³2æ¯ä¸ªå›åˆæˆ˜åŠ›åŠ b3ç›´æ¥æå‡ c ç‚¹æˆ˜æ–—åŠ›é—®æœ€å¤šèƒ½é€ æˆå¤šå°‘ç‚¹ä¼¤å®³é¢˜è§£ï¼šDPæ±‚è§£ dp[i][j]ä¸ºj ä¸ªå›åˆè¿›è¡Œäº†ç¬¬ä¸€ç§æ“ä½œï¼Œæ“ä½œçš„ä¸‹æ ‡å’Œä¸ºjã€‚å¦‚æœæŠŠ1 2 3 ä¸‰ç§æ“ä½œçš„ä¼¤å®³åŒºåˆ†å¼€æ¥ï¼Œ1 æ“ä½œå°±æ˜¯ç›´æ¥é€ æˆ a ç‚¹ä¼¤å®³ã€‚ 2 æ“ä½œä¼šå¯¹åé¢çš„Aé€ æˆå½±å“ï¼Œä»”ç»†æ€è€ƒä¸€ä¸‹åŠ å…¥ 2 æ“ä½œæ˜¯ ç¬¬ i ä¸ª åé¢è¿›è¡Œäº† j æ¬¡æ”»å‡» ,èƒ½å¤Ÿå‘ç° 2 æ“ä½œ æœ€ç»ˆé€ æˆçš„ä¼¤å®³å’Œæ˜¯ ï¼ˆä¸‹æ ‡å’Œ - i * j ï¼‰ b ç‚¹ä¼¤å®³ã€‚ä¸¾ä¸ªä¾‹å­ï¼šå¦‚æœ ä½ åœ¨ 2 3 è¿›è¡Œäº†æ”»å‡»,ä½ åœ¨ç¬¬1ä¸ªå›åˆè¿›è¡Œäº†2æ“ä½œ é‚£ä¹ˆè´¡çŒ®å°± æ˜¯ (2+3 - 1 * 2)*bã€‚ç†è§£äº†è¿™ä¸ª 3 æ“ä½œå°±æ›´ç®€å•äº†ï¼Œç›´æ¥å°±æ˜¯j*cçš„ä¼¤å®³ã€‚çœ‹åˆ°è¿™é‡Œä¹Ÿå·®ä¸å¤šæ˜ç™½ï¼Œè¿™ä¸ªDPæ˜¯ä»åå¾€å‰DPçš„ã€‚åé¢çš„çŠ¶æ€æ°¸è¿œéƒ½ä¸ä¼šå½±å“åˆ°å‰é¢ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &quot;bits/stdc++.h&quot;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout &lt;&lt; &quot;[&quot; &lt;&lt; x &lt;&lt; &quot;]&quot; &lt;&lt; endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const long long mod = 1e9 + 7;const int maxn = 6e3 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen(&quot;../data.in&quot;, &quot;r&quot;, stdin);#endif return;&#125;LL dp[maxn][105];LL a[105], b[105], c[105];int main() &#123; f(); int t, n; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%lld%lld%lld&quot;, &amp;a[i], &amp;b[i], &amp;c[i]); &#125; memset(dp, -1, sizeof(dp)); dp[n][1]=a[n]; for (int i = n - 1; i &gt;= 1; i--) &#123; for (int j = maxn-1; j&gt;=0; j--) &#123; for (int l = 0; l &lt;= n; l++) &#123; if(dp[j][l]==-1)continue; if(j+i&lt;maxn)dp[j+i][l+1]=max(dp[j+i][l+1],dp[j][l]+a[i]); dp[j][l]=max(dp[j][l]+c[i]*l,max(dp[j][l],dp[j][l]+b[i]*(j-l*i))); &#125; &#125; &#125; LL ans=0; for(int i=0; i&lt;=n; i++) &#123; for(int j=0; j&lt;maxn; j++) &#123; ans=max(dp[j][i],ans); &#125; &#125; printf(&quot;%lld\n&quot;,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>åŠ¨æ€è§„åˆ’</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ sockç¼–ç¨‹å­¦ä¹ ç¬”è®°]]></title>
    <url>%2F2019%2F04%2F19%2FC%2B%2B-sock%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ä¸»æœºå­—èŠ‚åºå’Œç½‘ç»œå­—èŠ‚åºCPUç´¯åŠ å™¨ä¸€æ¬¡èƒ½è£…è½½è‡³å°‘4ä¸ªå­—èŠ‚ï¼Œå³ä¸€ä¸ªæ•´æ•°ã€‚å­—èŠ‚åºåˆ†ä¸ºå¤§ç«¯å­—èŠ‚åºå’Œå°ç«¯å­—èŠ‚åºã€‚å¤§ç«¯å­—èŠ‚åºé«˜ä½å­—èŠ‚ï¼ˆ23-31bitï¼‰å‚¨å­˜åœ¨å†…å­˜çš„ä½å¤„ï¼Œä½ä½å­—èŠ‚å‚¨å­˜åœ¨é«˜åœ°å€åˆã€‚å°ç«¯å­—èŠ‚åºæ°æ°ç›¸åã€‚å¤§éƒ¨åˆ†PCç”µè„‘ç”µè„‘ä½¿ç”¨å°ç«¯å­—èŠ‚åºï¼Œæ‰€ä»¥åˆè¢«ç§°ä¸ºä¸»æœºå­—èŠ‚åºã€‚å¤§ç«¯å­—èŠ‚åºè¢«ç§°ä¸ºç½‘ç»œå­—èŠ‚åºã€‚JAVAè™šæ‹Ÿæœºä½¿ç”¨çš„æ˜¯å¤§ç«¯å­—èŠ‚åº4ä¸ªå‡½æ•°å‡½æ•°ç”¨æ¥å®Œæˆå­—èŠ‚åºè½¬æ¢ã€‚123456// #include&lt;netinet/in.h&gt; //linux ä¸‹å¤´æ–‡ä»¶#include&lt;winsock2.h&gt; //window ä¸‹å¤´æ–‡ä»¶unsigned long htonl(unsigned long); //host to net è½¬æ¢IPunsigned long ntohl(unsigned long); //net to host è½¬æ¢IPunsigned short htons(unsigned short); //host to net è½¬æ¢ç«¯å£unsigned short ntohs(unsigned short); //net to host è½¬æ¢ç«¯å£]]></content>
      <categories>
        <category>è®¡ç®—æœºç½‘ç»œ</category>
      </categories>
      <tags>
        <tag>è®¡ç®—æœºç½‘ç»œ</tag>
        <tag>ç¬”è®°</tag>
        <tag>sock ç¼–ç¨‹</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é€‰æ‹”èµ›Tulip FestivalåŠå…¶è¿›é˜¶]]></title>
    <url>%2F2019%2F04%2F16%2F%E9%80%89%E6%8B%94%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[çº¿æ®µæ ‘åŠ¨æ€å¼€ç‚¹ï¼Œå¯¹äºè¿™é¢˜é¡ºä¾¿æŒ‚ä¸ªè‡ªå·±å­¦æ ¡OJ Tulip Festivalä»¥åŠåé¢è·Ÿç€çš„å‡ ä¸ªç‰ˆæœ¬ï¼Œç”¨çº¿æ®µæ ‘åŠ¨æ€å¼€ç‚¹éƒ½èƒ½è¿‡ã€‚é¢˜æ„ï¼šç»™ n ä¸ªæ•°å­—,mä¸ªæ“ä½œæ“ä½œä¸¤ç§:1 æŠŠpä¿®æ”¹æˆx2 æŸ¥è¯¢ [l,r]åŒºä»¶ç±»ä¸ [l,r]åŒºé—´å¼‚æˆ–å’Œä¸ç›¸ç­‰çš„æ•°å­—ä¸ªæ•°ã€‚ é¢˜è§£ï¼šæŠŠæ¯ä¸ªæ•°å­—çš„ä¸‹æ ‡æ”¾åˆ°ä¸€ä¸ªæ•°ç»„ï¼ŒåŒºé—´å¼‚æˆ–å’Œç›´æ¥ç”¨æ ‘çŠ¶æ•°ç»„æ±‚å‡ºæ¥(å¯¹äºä¸ä¼šç”¨æ ‘çŠ¶æ•°ç»„æ±‚åŒºé—´å¼‚æˆ–å’Œçš„å¤šå»åšåšæ ‘çŠ¶æ•°ç»„åŸºç¡€é¢˜)ç„¶åæ¯æ¬¡æŸ¥è¯¢åŒºé—´é‡Œé¢çš„æœ‰ä¸ªæ•°å­—å’Œå¼‚æˆ–å€¼ç›¸ç­‰å³å¯ã€‚æœ‰ä¸€ä¸ªç‰ˆæœ¬åªæœ‰200ä¸ªç›¸åŒå€¼ï¼Œè¿™ä¸ªç›´æ¥ç”¨vectorå­˜ï¼Œç„¶åæš´åŠ›æŸ¥æ‰¾å°±è¡Œäº†ã€‚ä½†æ˜¯åé¢å‡ºç°äº†å¤§é‡ç›¸åŒçš„æ•°å­—ï¼Œå°±ä¸èƒ½æš´åŠ›äº†ã€‚æŸ¥è¯¢åŒºé—´ç±»æœ‰å¤šå°‘ä¸ªå€¼ï¼Œå¯ä»¥ç”¨æ ‘çŠ¶æ•°ç»„æœ€ç®€æ´ï¼Œä½†æ˜¯æ˜æ˜¾1e6ä¸ªæ•°ï¼Œæ¯ä¸ªæ•°å¼€ä¸€ä¸ªæ ‘çŠ¶æ•°ç»„ï¼Œé•¿åº¦ä¸º1e6æ˜æ˜¾ç‚¸äº†ã€‚ç”¨çº¿æ®µæ ‘ï¼Œå¦‚æœç›´æ¥å¼€ç©ºé—´æ¯ä¸ªéƒ½è¦å¼€nlognä¸ªç‚¹ï¼Œæ˜æ˜¾ä¹Ÿä¼šç‚¸ã€‚ä½†æ˜¯è‡ªä¿¡ä¸€æƒ³ï¼Œå…¶ä¸­æœ‰å¾ˆå¤šç‚¹éƒ½æ˜¯æ— ç”¨çš„ï¼Œæ‰€æœ‰æ•°åŠ èµ·æ¥ä¸ªæ•°æœ€å¤šä¸åˆ°1e6ä¸ªç‚¹ï¼Œæ‰€ä»¥ç”¨çº¿æ®µæ ‘åŠ¨æ€å¼€ç‚¹ï¼Œæœ€å¤šä¸ä¼šè¶…è¿‡nlognä¸ªç‚¹ã€‚çº¿æ®µæ ‘åŠ¨æ€å¼€ç‚¹å…¶å®å’Œæ™®é€šçš„çº¿æ®µæ ‘å…¶å®å·®è·ä¸å¤§ã€‚åŠ¨æ€å¼€ç‚¹ï¼Œå°±æ˜¯æŠŠæ²¡æœ‰ç”¨çš„èŠ‚ç‚¹å°±ä¸ç»™ä»–åˆ†é…å†…å­˜ï¼Œå­—èŠ‚å½“ä½œç©ºï¼Œè¿™æ ·æ¯ä¸ªæ•°å­—æœ€å¤šæœ€å¤šå¼€lognä¸ªç‚¹ã€‚åŠ¨æ€å¼€ç‚¹å»ºè®®ç”¨ç»“æ„ä½“å†™ï¼Œè¿™æ ·å¯ä»¥æ–¹ä¾¿ä¸€ç‚¹ã€‚ç»“æ„ä½“è®¾ç½®3ä¸ªå€¼ä¸€ä¸ªæ˜¯å½“å‰èŠ‚ç‚¹ä¿å­˜çš„å€¼ï¼Œå·¦å³å„¿å­ä¸‹æ ‡ä¸¾ä¸ªä¾‹å­ï¼ŒåŠ å…¥çº¿æ®µæ ‘æ€»é•¿åº¦æ˜¯ 1 - 8,ä½ åœ¨ 1 1 æ’å…¥ä¸€ä¸ªå€¼ã€‚é‚£ä¹ˆä½ å°±éœ€è¦ 1-8 1-4 1-2 1-1è¿™å‡ ä¸ªç‚¹å¼€ç©ºé—´ï¼Œå…¶ä»–ç‚¹ç›´æ¥ä¸ç”¨ç®¡ï¼ŒæŸ¥è¯¢çš„æ—¶å€™ç›´æ¥è¿”å›0123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define bug printf("*********\n");#define debug(x) cout &lt;&lt; "[" &lt;&lt; x &lt;&lt; "]" &lt;&lt; endl;#define mid (l + r) / 2#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const long long mod = 1e9 + 7;const int maxn = 1e6 + 5 + 1e5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("../1.in", "r", stdin); freopen("../data.out", "w", stdout);#endif return;&#125;int tot, n, m;int a[maxn], bit[maxn];unordered_map&lt;int, int&gt; mp;int sum(int i) &#123; int ans = 0; while (i &gt; 0) &#123; ans ^= bit[i]; // debug(i); i -= i &amp; -i; &#125; return ans;&#125;void add(int i, int x) &#123; while (i &lt;= n) &#123; bit[i] ^= x; // debug(i); i += i &amp; -i; &#125;&#125;struct node &#123; int x; int chl, chr;&#125; tree[maxn * 50];int tt;void update(int a, int b, int l, int r, int k, int bol) &#123; if (b &lt; l || a &gt; r)return; else if (a &lt;= l &amp;&amp; r &lt;= b) &#123; if (bol)tree[k].x = 1; else tree[k].x = 0; &#125; else &#123; if (b &lt;= mid) &#123; if (tree[k].chl == 0) &#123; tree[k].chl = tt++; &#125; update(a, b, l, mid, tree[k].chl, bol); &#125; else &#123; if (tree[k].chr == 0) &#123; tree[k].chr = tt++; &#125; update(a, b, mid + 1, r, tree[k].chr, bol); &#125; int sum = 0; if (tree[k].chl != 0) &#123; sum += tree[tree[k].chl].x; &#125; if (tree[k].chr != 0) &#123; sum += tree[tree[k].chr].x; &#125; tree[k].x = sum; return; &#125;&#125;int querry(int a, int b, int l, int r, int k) &#123; if (b &lt; l || a &gt; r) &#123; return 0; &#125; else if (a &lt;= l &amp;&amp; r &lt;= b) &#123; return tree[k].x; &#125; else &#123; int sum = 0; if (tree[k].chl != 0) &#123; sum += querry(a, b, l, mid, tree[k].chl); &#125; if (tree[k].chr != 0) &#123; sum += querry(a, b, mid + 1, r, tree[k].chr); &#125; return sum; &#125;&#125;int main() &#123; f(); scanf("%d%d", &amp;n, &amp;m); tt = n + m + 1; for (int i = 0; i &lt; n; i++) &#123; int t; scanf("%d", &amp;t); add(i + 1, t); if (mp[t] == 0) &#123; mp[t] = ++tot; update(i + 1, i + 1, 1, n, tot, 1); &#125; else &#123; update(i + 1, i + 1, 1, n, mp[t], 1); &#125; &#125; // debug(sum(1)); while (m--) &#123; int op; scanf("%d", &amp;op); if (op == 1) &#123; int p, x; scanf("%d%d", &amp;p, &amp;x); int t = sum(p) ^sum(p - 1); update(p, p, 1, n, mp[t], 0); add(p, t ^ x); if (mp[x] == 0)mp[x] = ++tot; update(p, p, 1, n, mp[x], 1); assert(tt &lt; 5e7); &#125; else &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); int t = sum(r) ^sum(l - 1); //debug(t); if (mp[t] == 0)printf("%d\n", r - l + 1); else printf("%d\n", r - l + 1 - querry(l, r, 1, n, mp[t])); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>æ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>æ•°æ®ç»“æ„</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3Dè§¦å‘å™¨å’Œç¢°æ’å™¨]]></title>
    <url>%2F2019%2F03%2F26%2FUnity3D%E8%A7%A6%E7%A2%B0%E5%99%A8%E5%92%8C%E7%A2%B0%E6%92%9E%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Unity3dç¢°æ’æ£€æµ‹ä¸­ç¢°æ’å™¨ä¸è§¦å‘å™¨çš„åŒºåˆ«è¦äº§ç”Ÿç¢°æ’å¿…é¡»ä¸ºæ¸¸æˆå¯¹è±¡æ·»åŠ åˆšä½“ï¼ˆRigidbodyï¼‰å’Œç¢°æ’å™¨ï¼Œåˆšä½“å¯ä»¥è®©ç‰©ä½“åœ¨ç‰©ç†å½±å“ä¸‹è¿åŠ¨ã€‚ç¢°æ’ä½“æ˜¯ç‰©ç†ç»„ä»¶çš„ä¸€ç±»ï¼Œå®ƒè¦ä¸åˆšä½“ä¸€èµ·æ·»åŠ åˆ°æ¸¸æˆå¯¹è±¡ä¸Šæ‰èƒ½è§¦å‘ç¢°æ’ã€‚å¦‚æœä¸¤ä¸ªåˆšä½“ç›¸äº’æ’åœ¨ä¸€èµ·ï¼Œé™¤éä¸¤ä¸ªå¯¹è±¡æœ‰ç¢°æ’ä½“æ—¶ç‰©ç†å¼•æ“æ‰ä¼šè®¡ç®—ç¢°æ’ï¼Œåœ¨ç‰©ç†æ¨¡æ‹Ÿä¸­ï¼Œæ²¡æœ‰ç¢°æ’ä½“çš„åˆšä½“ä¼šå½¼æ­¤ç›¸äº’ç©¿è¿‡ã€‚ ç‰©ä½“å‘ç”Ÿç¢°æ’çš„å¿…è¦æ¡ä»¶ ä¸¤ä¸ªç‰©ä½“éƒ½å¿…é¡»å¸¦æœ‰ç¢°æ’å™¨(Collider)ï¼Œå…¶ä¸­ä¸€ä¸ªç‰©ä½“è¿˜å¿…é¡»å¸¦æœ‰Rigidbodyåˆšä½“ã€‚ åœ¨unity3dä¸­ï¼Œèƒ½æ£€æµ‹ç¢°æ’å‘ç”Ÿçš„æ–¹å¼æœ‰ä¸¤ç§ï¼Œä¸€ç§æ˜¯åˆ©ç”¨ç¢°æ’å™¨ï¼Œå¦ä¸€ç§åˆ™æ˜¯åˆ©ç”¨è§¦å‘å™¨ã€‚ ç¢°æ’å™¨ï¼šä¸€ç¾¤ç»„ä»¶ï¼Œå®ƒåŒ…å«äº†å¾ˆå¤šç§ç±»ï¼Œæ¯”å¦‚ï¼šBox Colliderï¼ˆç›’ç¢°æ’ä½“ï¼‰ï¼ŒMesh Colliderï¼ˆç½‘æ ¼ç¢°æ’ä½“ï¼‰ç­‰ï¼Œè¿™äº›ç¢°æ’å™¨åº”ç”¨çš„åœºåˆä¸åŒï¼Œä½†éƒ½å¿…é¡»åŠ åˆ°GameObjecetèº«ä¸Šã€‚ è§¦å‘å™¨ï¼Œåªéœ€è¦åœ¨æ£€è§†é¢æ¿ä¸­çš„ç¢°æ’å™¨ç»„ä»¶ä¸­å‹¾é€‰IsTriggerå±æ€§é€‰æ‹©æ¡†ã€‚å‹¾é€‰Is Trigger åä¸ä¼šæœ‰ç¢°æ’ç‰©ç†ç°è±¡è§¦å‘ä¿¡æ¯æ£€æµ‹ï¼š 1.MonoBehaviour.OnTriggerEnter(Collider collider)å½“è¿›å…¥è§¦å‘å™¨ 2.MonoBehaviour.OnTriggerExit(Collider collider)å½“é€€å‡ºè§¦å‘å™¨ 3.MonoBehaviour.OnTriggerStay(Collider collider)å½“é€—ç•™è§¦å‘å™¨ ç¢°æ’ä¿¡æ¯æ£€æµ‹ï¼š 1.MonoBehaviour.OnCollisionEnter(Collision collision) å½“è¿›å…¥ç¢°æ’å™¨ 2.MonoBehaviour.OnCollisionExit(Collision collision) å½“é€€å‡ºç¢°æ’å™¨ 3.MonoBehaviour.OnCollisionStay(Collision collision) å½“é€—ç•™ç¢°æ’å™¨ 12345678void OnTriggerEnter(Collider collider)&#123; //è¿›å…¥è§¦å‘å™¨æ‰§è¡Œçš„ä»£ç &#125;void OnCollisionEnter(Collision collision) &#123; //è¿›å…¥ç¢°æ’å™¨æ‰§è¡Œçš„ä»£ç &#125;]]></content>
      <categories>
        <category>æ¸¸æˆ</category>
        <category>U3D</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ä¸­å—å¤šæ ¡ç¬¬ä¸€åœº]]></title>
    <url>%2F2019%2F03%2F18%2F%E4%B8%AD%E5%8D%97%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%80%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[æºé¢˜ç›® 2018-2019 ACM-ICPC Nordic Collegiate Programming Contest (NCPC 2018)&lt;/br&gt; å†™ä¸€ç¯‡åšå®¢è¡¨ç¤ºè‡ªå·±æŠŠé¢˜è¡¥äº†. &lt;/br&gt; A.Altruistic Amphibiansç®€å•DPï¼Œæ¯ä¸ªé’è›™çš„é‡é‡æ€»å’Œä¸ä¼šè¶…è¿‡ 1e8ï¼Œæ¯ä¸€æ¬¡å½±å“çš„çŠ¶æ€æœ€å¤šåªæœ‰ 1e8å¤æ‚åº¦æœ€é«˜åªæœ‰1e8dp[j]è¡¨ç¤ºèƒ½æ”¯æ’‘é‡é‡jæœ€å¤§é«˜åº¦æ˜¯å¤šå°‘ã€‚dp[j-w[i]]=max(dp[j-w[i]],dp[j]);1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;x&lt;&lt;"]" &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e8+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;int a[maxn/10];struct node &#123; int l,w,h; bool operator&lt;(const node &amp; t) &#123; return w&gt;t.w; &#125;&#125; dat[maxn/10];int dp[maxn*2];int main() &#123; int n,d; scanf("%d%d",&amp;n,&amp;d); int mx=0; for(int i=0; i&lt;n; i++) &#123; scanf("%d%d%d",&amp;dat[i].l,&amp;dat[i].w,&amp;dat[i].h); mx=max(mx,dat[i].w); &#125; sort(dat,dat+n); int ans=0; for(int i=0; i&lt;n; i++) &#123; if(dp[dat[i].w]+dat[i].l&gt;d)ans++; for(int j=dat[i].w+1; j&lt;min(2*dat[i].w,maxn); j++) &#123; dp[j-dat[i].w]=max(dp[j-dat[i].w],dp[j]+dat[i].h); &#125; &#125; printf("%d\n",ans); return 0;&#125; B. Baby Bitesæ°´é¢˜éƒ½ä¸è§£é‡Š12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#define fi first#define se second#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1#define pb push_back#define MP make_pair#define LL long long#define FIN freopen("in.txt","r",stdin)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt;pii;int n;string s;int main()&#123;#ifndef ONLINE_JUDGE FIN;#endif // ONLINE_JUDGE while(cin&gt;&gt;n) &#123; int falg= 1; for(int i = 1; i&lt;=n; i++) &#123; cin&gt;&gt;s; if(s=="mumble") continue; else &#123; int tmp = stoi(s); if(tmp!=i) &#123; falg = 0; &#125; &#125; &#125; if(falg)&#123; cout&lt;&lt;"makes sense"&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;"something is fishy"&lt;&lt;endl; &#125; &#125; return 0;&#125; C. Code Cleanups12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#define fi first#define se second#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1#define pb push_back#define MP make_pair#define LL long long#define FIN freopen("in.txt","r",stdin)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt;pii;const int mod = 1e9+7;const int MX = 3e3+5;int n;int vis[MX];int main()&#123;#ifndef ONLINE_JUDGE FIN;#endif // ONLINE_JUDGE while(~scanf("%d",&amp;n))&#123; memset(vis,0,sizeof(vis)); for(int i = 1,x;i &lt;= n;i++) &#123; scanf("%d",&amp;x); vis[x] = 1; &#125; int ans = 0; int sum = 0,cnt = 0; for(int i = 1;i &lt;= 365;i++) &#123; sum += cnt; if(sum &gt;= 20) &#123; ans++; sum = 0; cnt = 0; i--; continue; &#125; if(vis[i]) cnt++; &#125; if(cnt) ans++; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; D. Delivery Delaysè¿™é¢˜ä¹ŸæŒºç®€å•çš„ï¼Œä¸è¿‡å‡ºäº†ä¸å°‘bugè®°å½•ä¸€ä¸‹ã€‚é¦–å…ˆé¢„å¤„ç†å‡ºæ‰€æœ‰ç‚¹ç›´æ¥çš„æœ€è¿‘è·ç¦»ï¼Œç„¶åå†é¢„å¤„ç†å‡ºé€å®Œç¬¬jä¸ªå›åˆ°1ç‚¹ç„¶åä¸€ç›´ç­‰åˆ° i ç¬¬iä¸ªè®¢å•çš„éœ€è¦çš„æ—¶é—´ï¼Œå’Œç”¨æˆ·æœ€å¤§ç­‰å¾…æ—¶é—´ã€‚ç„¶ådp[i]ä¿å­˜é€å®Œç¬¬ i ä¸ªè®¢å•å›åˆ° 1 çš„æœ€å°æ—¶é—´ï¼Œç„¶åå†äºŒåˆ†æœ€å¤§ç­‰å¾…æ—¶é—´ã€‚æœ€åå†™äºŒåˆ†å‡ºäº†ç‚¹é—®é¢˜ï¼ŒäºŒåˆ†çš„èŒƒå›´ ï¼Œl åˆå€¼åº”è¯¥æ˜¯-1è€Œä¸æ˜¯0;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;LL, int&gt; P;#define bug printf("*********\n");#define debug(x) cout &lt;&lt; "[" &lt;&lt; x &lt;&lt; "]" &lt;&lt; endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const long long mod = 1e9 + 7;const int maxn = 1e3 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f3f3f3f3f;const double eps = 1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif return;&#125;int n, m;struct edge &#123; int to, next; LL w;&#125; eg[maxn * 10];int head[maxn], tot;LL cost[maxn];void init() &#123; memset(head, -1, sizeof(head)); tot = 0;&#125;void add(int u, int v, LL w) &#123; eg[tot].to = v; eg[tot].w = w; eg[tot].next = head[u]; head[u] = tot++;&#125;LL dis[maxn][maxn];void dij(int u) &#123; memset(cost, inf, sizeof(cost)); priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; q; cost[u] = 0; q.push(P(cost[u], u)); while (q.size()) &#123; int v = q.top().second; LL w = q.top().first; q.pop(); if (cost[v] &lt; w)continue; else &#123; for (int i = head[v]; i != -1; i = eg[i].next) &#123; edge &amp;e = eg[i]; if (cost[e.to] &gt; w + e.w) &#123; cost[e.to] = w + e.w; q.push(P(cost[e.to], e.to)); &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; dis[u][i] = cost[i]; &#125;&#125;int q;LL s[maxn], to[maxn], t[maxn];LL dp[maxn];LL k[maxn][maxn];LL mx[maxn][maxn];int solve(LL m) &#123; memset(dp, inf, sizeof(dp)); dp[0] = 0; for (int i = 1; i &lt;= q; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; LL ti = dp[j], flag = 1; ti = max(ti, t[i]); if(mx[j][i]+ti&gt;m)flag=0; ti+=k[j][i]; if (flag == 0)continue; else &#123; dp[i] = min(dp[i], ti + dis[to[i]][1]); &#125; &#125; &#125; for(int i=1;i&lt;=q;i++)&#123; if(dp[i]==dp[maxn-1])return 0; &#125; return 1;&#125;int main() &#123; f(); scanf("%d%d", &amp;n, &amp;m); init(); for (int i = 0; i &lt; m; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, w); &#125; for (int i = 1; i &lt;= n; i++) &#123; dij(i); &#125; scanf("%d", &amp;q); to[0] = 1; for (int i = 1; i &lt;= q; i++) &#123; scanf("%lld%lld%lld", &amp;s[i], &amp;to[i], &amp;t[i]); &#125; for (int i = 1; i &lt;= q; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; LL ti,m=-inf; ti=0; int pos = j + 1, lat = 1; while (pos &lt;= i) &#123; ti += dis[lat][to[pos]]; if (ti - s[pos] &gt; m ) &#123; m=ti - s[pos]; &#125; lat = to[pos]; pos++; &#125; k[j][i]=ti; mx[j][i]=m; &#125; &#125; LL l = -1, r =inf; while (r &gt; l + 1) &#123; if (solve(mid))r = mid; else l = mid; &#125; printf("%lld\n", r); return 0;&#125; E. Explosion Exploitè¿™é¢˜ç«Ÿç„¶æ²¡æƒ³åˆ°ç”¨ ç±»ä¼¼çŠ¶å‹DPäº†ï¼Œè¿˜ä¸€ç›´æƒ³æ€ä¹ˆåç»´æ•°ç»„äº†ï¼Œå”‰ã€‚ç›´æ¥ç”¨ä¸€ä¸ªlong long æ•´æ•°ï¼Œå‰5ä½ä¿å­˜è‡ªå·±å°å…µçš„å€¼ï¼Œå5ä½ä¿å­˜å¯¹é¢å°å…µçš„å€¼ã€‚åæ¥å‘ç°è¿™æ ·å†™å¤æ‚åº¦è¿‡ä¸å»ã€‚å°±ç®—æ˜¯è®°å¿†åŒ–æœç´¢è¿˜æ˜¯é”™çš„ã€‚åº”è¯¥ç”¨6ä½æ¥ä¿å­˜è¿˜å‰©å¤šå°‘ç‚¹è¡€çš„å°å…µçš„ä¸ªæ•°ã€‚å› ä¸º å‰é¢ä¸€ç§æœç´¢ï¼Œ31300å’Œ 13300ä¸æ˜¯åŒä¸€ç§çŠ¶æ€ï¼Œé™¤éæ’ä¸€ä¸‹åºã€‚è€Œåé¢è¿™ä¸€ç§ä¿å­˜æ–¹å¼ï¼Œå…¨éƒ¨éƒ½æ˜¯102ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;x&lt;&lt;"]" &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;map&lt;LL,double&gt;mp;int n,m,k;double dfs(LL a,int u) &#123; if(mp.count(a)) &#123; return mp[a]; &#125; LL b=a; LL ans=0,a1=0,a2=0; for(int i=0; i&lt;12; i++) &#123; if(i&gt;=6) &#123; if(b%10!=0)a2+=b%10; b/=10; continue; &#125; ans+=(b%10)*(6-i); if(b%10!=0)a1+=b%10; b/=10; &#125;// debug(ans&lt;&lt;"a="&lt;&lt;a2); if(ans==0) &#123; mp[a]=1; return 1; &#125; if(ans&gt;u) &#123; mp[a]=0; return 0; &#125; double tp=0; if(a2==0) &#123; mp[a]=1; return 1; &#125; else &#123; LL tk=1; b=a; for(int i=0; i&lt;12; i++) &#123; if(b%10!=0) &#123; if(i==11||i==5)&#123; tp+=dfs(a-tk,u-1)*(b%10)*1.0/(a1+a2); &#125; else if(i&lt;6)&#123; tp+=dfs(a-tk+tk*10,u-1)*(b%10)*1.0/(a1+a2); &#125; else tp+=dfs(a-tk+tk*10,u-1)*(b%10)*1.0/(a1+a2); &#125; b/=10; tk*=10; &#125; &#125; mp[a]=tp; return tp;&#125;LL a;int b[2][10];int main() &#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=0 ; i&lt;n; i++) &#123; int p; scanf("%d",&amp;p); b[0][p]++; &#125; for(int i=0; i&lt;m; i++) &#123; int p; scanf("%d",&amp;p); b[1][p]++; &#125; for(int i=1; i&lt;=6; i++) &#123; a=a*10+b[0][i]; &#125; for(int i=1; i&lt;=6; i++) &#123; a=a*10+b[1][i]; &#125; printf("%.10f\n",dfs(a,k)); return 0;&#125;/*2 2 31 11 2*/ F * G è¿™ä¸¤é¢˜æœ‰ç‚¹éš¾ï¼Œæ²¡å†™å‡ºæ¥ã€‚ã€‚ã€‚ç©ºç€ã€‚ã€‚ H. House Lawné˜Ÿå‹å†™çš„ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;typedef long long LL;typedef long double lb;typedef pair&lt;int, int&gt; P;#define debug(x) cout&lt;&lt;"["&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define bug cout&lt;&lt;"*******************"&lt;&lt;endl;#define mem(a,b) memset(a,b,sizeof(a));#define fi first#define se second#define pb(x) push_back(x)const LL mod = 1e9+7;const int inf=0x3f3f3f3f;const int INF=0x7fffffff;const double eps = 1e-7;const double pi = acos(-1);const int maxn=1e6+5;int n, sum;string s, name[106];int stak[106], top = 0;int minp;struct node &#123; int id; LL p, c, t, r;&#125; lawn[107];LL solve(LL tm, LL tp, LL c, LL t, LL r) &#123; return (c*t*(tp/(t+r)))/sum;&#125;int main() &#123; //scanf("%d%d", &amp;sum, &amp;n); cin &gt;&gt; sum &gt;&gt; n; int ans = inf; int p, c, t, r; minp = INF; getchar(); for(int i = 1, len; i &lt;= n; ++i) &#123; getline(cin, s); len = s.length(); int tmp = 0; for(; s[tmp] != ',';++tmp) ; name[i] = s.substr(0, tmp); //cout &lt;&lt; name[i] &lt;&lt; endl; p = c = t = r = 0; for(++tmp; s[tmp] != ',';++tmp) p = p*10+s[tmp]-'0'; for(++tmp; s[tmp] != ',';++tmp) c = c*10+s[tmp]-'0'; for(++tmp; s[tmp] != ',';++tmp) t = t*10+s[tmp]-'0'; for(++tmp; tmp &lt; len;++tmp) r = r*10+s[tmp]-'0'; //cout &lt;&lt; p &lt;&lt;" "&lt;&lt; c &lt;&lt;" "&lt;&lt; t &lt;&lt;" "&lt;&lt; r &lt;&lt; endl; //cin &gt;&gt; p &gt;&gt; c &gt;&gt; t &gt;&gt; r; //scanf("%d%d%d%d", &amp;p, &amp;c, &amp;t, &amp;r); lawn[i].id = i; lawn[i].p = p; lawn[i].c = c; lawn[i].t = t; lawn[i].r = r; &#125; for(int i = 1; i &lt;= n; ++i) &#123; LL tp = 10080LL * (lawn[i].t+lawn[i].r) / __gcd(10080LL , 1LL*(lawn[i].t+lawn[i].r)); LL T = tp / 10080; LL tot = sum * T; LL tt = solve(tot, tp, lawn[i].c, lawn[i].t, lawn[i].r); //printf("i: %d, T: %lld, tp: %lld, tt: %lld\n", i, T, tp, tt); if(tt &gt;= T) &#123; //printf("OK\n"); if(minp &gt; lawn[i].p) &#123; minp = lawn[i].p; top = 1; stak[top] = lawn[i].id; &#125; else if(minp == lawn[i].p) &#123; top ++; stak[top] = lawn[i].id; &#125; &#125; &#125; for(int i = 1; i &lt;= top; ++i) &#123; cout &lt;&lt; name[stak[i]] &lt;&lt; "\n"; &#125; if(top == 0) cout &lt;&lt; "no such mower\n"; //printf("%d\n", ans); return 0;&#125;/*7000 49999 10 120 120999 1 120 2405499 2 25 355499 3 25 3510000 3aaa,1,1,1,1bbb,1,10000,10080,1ccc,1,10000,10079,1*/ I. Intergalactic Biddingå¤§æ•°ï¼Œæ’åº,æ²¡äº†ã€‚ã€‚å› ä¸ºä¿è¯ ä¸€ä¸ªå€¼ç­‰äºå¦ä¸€ä¸ªå€¼çš„2å€ä»¥ä¸Šã€‚æ‰€ä»¥æœ‰ä¸”åªæœ‰ä¸€ç§æƒ…å†µã€‚èƒ½é€‰å°±ä¸€å®šè¦é€‰ä¸Š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;typedef long long LL;typedef long double lb;typedef pair&lt;int, int&gt; P;#define debug(x) cout&lt;&lt;"["&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define bug cout&lt;&lt;"*******************"&lt;&lt;endl;#define mem(a,b) memset(a,b,sizeof(a));#define fi first#define se second#define pb(x) push_back(x)const LL mod = 1e9+7;const int inf=0x3f3f3f3f;const int INF=0x7fffffff;const double eps = 1e-7;const double pi = acos(-1);const int maxn=1e6+5;const int MAXL = 6e3+5;const int MAXN = 9999;const int DLEN = 4 ;class big &#123;public: int a[MAXN],len; big (const char *s) &#123; int t,k,index=0,L=strlen(s); memset(a,0,sizeof(a)); len=L/DLEN; if(L%DLEN) len++; for(int i = L-1; i&gt;=0; i-=DLEN) &#123; t=0; k=i-DLEN + 1; if(k&lt;0) k=0; for(int j = k; j &lt;=i ; j++) t=t*10+s[j]-'0'; a[index++]=t; &#125; &#125; bool operator&lt;(const big &amp;t) const &#123; int ln; if(len&gt;t.len) return false; else if(len==t.len) &#123; ln=len-1; while(a[ln]==t.a[ln]&amp;&amp;ln&gt;=0) ln--; if(ln&gt;=0&amp;&amp;a[ln]&gt;t.a[ln]) return false; else return true; &#125; else return true; &#125; big operator-(const big &amp;T)const &#123; bool flag; big t1=*this,t2=T; flag=0; int b=t1.len; for(int i=0,j; i&lt;b; i++) &#123; if(t1.a[i]&lt;t2.a[i]) &#123; if(j=i+1); while(t1.a[j]==0) j++; t1.a[j--]--; while(j&gt;i) t1.a[j--]+=MAXN; t1.a[i]+=MAXN+1-t2.a[i]; &#125; else t1.a[i]-=t2.a[i]; &#125; t1.len=b; while(t1.a[t1.len-1]==0&amp;&amp;t1.len&gt;1) t1.len--,b--; return t1; &#125; void print() &#123; printf("%d",a[len-1]); for(int i=len-2; i&gt;=0; i--) &#123; printf("%04d",a[i]); &#125; &#125;&#125;;typedef pair&lt;big,string&gt; PS;vector&lt;PS&gt; v;int main() &#123; int n; char s[1005]; scanf("%d%s",&amp;n,s); big mx(s);// debug((mx&lt;big("0")&amp;&amp;big("0")&lt;mx));// mx.print(); char nam[100]; for(int i=0; i&lt;n; i++) &#123; scanf("%s%s",nam,s); v.push_back(PS(s,nam)); &#125; sort(v.begin(),v.end()); int l=v.size(); vector&lt;string&gt; ans; while(l--&gt;0) &#123; big b=v[l].first; if(b&lt;mx) &#123; ans.pb(v[l].se); mx=mx-b; &#125; &#125; big temp("0"); if(!(temp&lt;mx&amp;&amp;mx&lt;temp)) &#123; printf("0\n"); return 0; &#125; printf("%d\n",ans.size()); for(auto i:ans) &#123; cout&lt;&lt;i&lt;&lt;"\n"; &#125; return 0;&#125; J. Jumbled Stringé¦–å…ˆæ›´å…·a,dç®—å‡ºæœ‰å¤šå°‘ä¸ª0 å’Œ 1 ç‰¹åˆ¤ä¸€ä¸‹åªæœ‰ä¸€ä¸ª1çš„æƒ…å†µã€‚æ›´å…·è¿™ä¸ªå¯ä»¥åˆ¤æ–­å‡º 01 10 è¿™ä¸¤ç§å­—ç¬¦ä¸²å°±æ˜¯ 0 åœ¨1å‰é¢å’Œ1åœ¨0å‰é¢åˆå¤šå°‘ä¸ªï¼Œè¿˜å¯ä»¥å‘ç°0åœ¨1å‰é¢å’Œ1åœ¨0å‰é¢çš„æ€»å’Œæ˜¯ä¸€æ ·çš„ï¼Œæ›´å…·è¿™ä¸ªå¯ä»¥åˆ¤æ–­æœ‰æ²¡æœ‰è¿™æ ·çš„å­—ç¬¦ä¸²ã€‚ç„¶ååœ¨éšä¾¿æ„é€ ä¸€ä¸ªå­—ç¬¦ä¸²å°±è¡Œäº†ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;typedef long long LL;typedef long double lb;typedef pair&lt;int, int&gt; P;#define debug(x) cout&lt;&lt;"["&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define bug cout&lt;&lt;"*******************"&lt;&lt;endl;#define mem(a,b) memset(a,b,sizeof(a));#define fi first#define se second#define pb(x) push_back(x)const LL mod = 1e9+7;const int inf=0x3f3f3f3f;const int INF=0x7fffffff;const double eps = 1e-7;const double pi = acos(-1);const int maxn=1e6+5;LL a,b,c,d;LL zn=-1,on=-1;int main() &#123; while(~scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;d)) &#123; for(LL i=0; i&lt;1e5; i++) &#123; if(i*(i-1)&gt;2*a) &#123; break; &#125; else if(i*(i-1)==2*a) &#123; zn=i; &#125; &#125; for(LL i=0; i&lt;1e5; i++) &#123; if(i*(i-1)&gt;2*d) &#123; break; &#125; else if(i*(i-1)==2*d) &#123; on=i; &#125; &#125; if(a==0) &#123; if(b!=0||c!=0) &#123; zn=1; &#125; else zn=0; &#125; if(d==0) &#123; if(b!=0||c!=0) &#123; on=1; &#125; else on=0; &#125;// debug(zn);// debug(on); if(((b+c)!=on*zn)||zn==-1||on==-1) &#123; puts("impossible"); &#125; else &#123; LL k=(on==0)?0:((on*zn)-b)/on,num=(on==0)?0:((on*zn)-b)%on;// debug(k);// debug(num); for(int i=0; i&lt;zn+on; i++) &#123; if(i&lt;zn-k-1) &#123; printf("0"); &#125; else if(i&gt;zn+on-k-1) &#123; printf("0"); &#125; else if(i==zn-k+num-1) &#123; printf("0"); &#125; else printf("1"); &#125; puts(""); &#125; &#125; return 0;&#125; K. Kingâ€™s Colorsé˜Ÿå‹å†™çš„ã€‚ã€‚ã€‚ä¸è¿‡è¿™é¢˜å°±æ˜¯ä¸€ä¸ªå®¹æ–¥ï¼Œæ˜¯ä¸€é¢—æ ‘ï¼Œæ‰€ä»¥èƒ½å¤Ÿä¿è¯ä¸€ä¸ªèŠ‚ç‚¹çš„æŸ“è‰²åªåˆä¸€ä¸ªèŠ‚ç‚¹æœ‰å…³ã€‚12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;typedef long long LL;typedef long double lb;typedef pair&lt;int, int&gt; P;#define debug(x) cout&lt;&lt;"["&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define bug cout&lt;&lt;"*******************"&lt;&lt;endl;#define mem(a,b) memset(a,b,sizeof(a));#define fi first#define se second#define pb(x) push_back(x)const LL mod = 1e9+7;const int inf=0x3f3f3f3f;const int INF=0x7fffffff;const double eps = 1e-7;const double pi = acos(-1);const int maxn=1e6+5;char s[10];int rint(char* t) &#123; int l=strlen(t); if(t[0]&lt;'0'||t[0]&gt;'9') &#123; return -1; &#125; else &#123; int i=0,ans=0; while(i&lt;l)&#123; ans=ans*10+t[i]-'0'; i++; &#125; return ans; &#125;&#125;//int a[maxn];LL ksm(LL a, int b) &#123; LL res = 1; for(;b;b&gt;&gt;=1,a=a*a%mod) &#123; if(b&amp;1) res = res*a%mod; &#125; return res;&#125;LL C[3005][3005];int main() &#123; C[1][1] = 1; for(int i = 2; i &lt; 3000; ++i) &#123; for(int j = 1; j &lt;= i; ++j) &#123; C[i][j] = (C[i-1][j]+C[i-1][j-1])%mod; &#125; &#125; LL n, k; scanf("%lld%lld",&amp;n, &amp;k); for(int i = 1, x; i &lt; n; ++i) &#123; scanf("%d", &amp;x); &#125; LL ans = 0, tmp; for(LL i = k, j = 0; i &gt;= 2; --i, j = !j) &#123; tmp = C[k+1][i+1] * i % mod * ksm(i-1, n-1) % mod; if(j == 0) ans = (ans+tmp)%mod; else ans = (ans - tmp)%mod; &#125; printf("%lld\n", (ans+mod)%mod); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>æ¯”èµ›</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HexoNextä¸€äº›æ“ä½œ]]></title>
    <url>%2F2019%2F03%2F16%2FHexoNext%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[æ›´æ”¹å¤´åƒ1.åœ¨ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­æœç´¢ avatar2.3.æ‰¾åˆ°è¿™ä¸ªè·¯å¾„ä¿®æ”¹å°±è¡Œäº†ã€‚4. æ·»åŠ ä¸ªäººcssthemes\next\source\css\_customä¿®æ”¹è¿™ä¸ªæ–‡ä»¶ 12345678910111213141516171819202122232425262728293031323334353637// Custom styles.@media screen and (min-width:1200px) &#123; body &#123; background:url(https://i.loli.net/2019/03/01/5c7942720fc39.png); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%; background-size: cover; &#125; #footer a &#123; color:#eee; &#125; .main-inner &#123; margin-top: 10px; opacity: 0.8; &#125; .header-inner &#123; margin-top: 10px; position: absolute; top: auto; overflow: hidden; padding: 0; width: 240px; background: #fff; box-shadow: initial; border-radius: initial; opacity: 1; &#125; .post &#123; margin-bottom: 30px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125;&#125;]]></content>
      <categories>
        <category>é…ç½®</category>
      </categories>
      <tags>
        <tag>é…ç½®</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ä½¿ç”¨VScode è°ƒè¯•çš„æ—¶å€™æç¤ºUnable to start debugging]]></title>
    <url>%2F2019%2F03%2F02%2F%E4%BD%BF%E7%94%A8VScode%20%E8%B0%83%E8%AF%95%E7%9A%84%E6%97%B6%E5%80%99%E6%8F%90%E7%A4%BAUnable%20to%20start%20debugging%2F</url>
    <content type="text"><![CDATA[ä½¿ç”¨VScode è°ƒè¯•çš„æ—¶å€™æç¤ºUnable to start debugging. Launch options string provided by the project system is invalid. Unable to determine path to debugger. Please specify the â€œMIDebuggerPathâ€ option. æç¤ºè¿™ä¸ªé”™è¯¯ã€‚ ç¿»è¯‘è¿‡æ¥å°±æ˜¯ miDebuggerPathä»–å‡ºé”™äº†ã€‚ å¦‚æœä½ æ˜¯åœ¨linux ä¸‹æŒ‰ç…§å®˜ç½‘çš„é™ªåº”è¯¥å°±æ˜¯ è¿™ä¸ªåœ°æ–¹é™ªé”™äº†ï¼Œè¦å…ˆä¸‹è½½gdb åœ¨ç»ˆç«¯è¾“å…¥ apt-get install gdb ç„¶åæŠŠgdbçš„è·¯å¾„ä¸¢è¿›å»å°±è¡Œäº†ã€‚]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Deepin VSCODEå®‰è£…C++ç¯å¢ƒ]]></title>
    <url>%2F2019%2F03%2F02%2FDeepin-VSCODE%E5%AE%89%E8%A3%85C%2B%2B%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[é¦–å…ˆ]]></content>
      <categories>
        <category>é…ç½®</category>
      </categories>
      <tags>
        <tag>é…ç½®</tag>
        <tag>VScode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublimeå¿«æ·é”®é›†åˆ]]></title>
    <url>%2F2019%2F03%2F02%2Fsublime%E5%BF%AB%E6%8D%B7%E9%94%AE%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Sublime Text 3 å¿«æ·é”®åˆ—è¡¨ï¼šç²¾åç‰ˆ Ctrl+Shift+Pï¼šæ‰“å¼€å‘½ä»¤é¢æ¿ Ctrl+Pï¼šæœç´¢é¡¹ç›®ä¸­çš„æ–‡ä»¶ Ctrl+Gï¼šè·³è½¬åˆ°ç¬¬å‡ è¡Œ Ctrl+Wï¼šå…³é—­å½“å‰æ‰“å¼€æ–‡ä»¶ Ctrl+Shift+Wï¼šå…³é—­æ‰€æœ‰æ‰“å¼€æ–‡ä»¶ Ctrl+Shift+Vï¼šç²˜è´´å¹¶æ ¼å¼åŒ– Ctrl+Dï¼šé€‰æ‹©å•è¯ï¼Œé‡å¤å¯å¢åŠ é€‰æ‹©ä¸‹ä¸€ä¸ªç›¸åŒçš„å•è¯ Ctrl+Lï¼šé€‰æ‹©è¡Œï¼Œé‡å¤å¯ä¾æ¬¡å¢åŠ é€‰æ‹©ä¸‹ä¸€è¡Œ Ctrl+Shift+Lï¼šé€‰æ‹©å¤šè¡Œ Ctrl+Shift+Enterï¼šåœ¨å½“å‰è¡Œå‰æ’å…¥æ–°è¡Œ Ctrl+Xï¼šåˆ é™¤å½“å‰è¡Œ Ctrl+Mï¼šè·³è½¬åˆ°å¯¹åº”æ‹¬å· Ctrl+Uï¼šè½¯æ’¤é”€ï¼Œæ’¤é”€å…‰æ ‡ä½ç½® Ctrl+Jï¼šé€‰æ‹©æ ‡ç­¾å†…å®¹ Ctrl+Fï¼šæŸ¥æ‰¾å†…å®¹ Ctrl+Shift+Fï¼šæŸ¥æ‰¾å¹¶æ›¿æ¢ Ctrl+Hï¼šæ›¿æ¢ Ctrl+Rï¼šå‰å¾€ method Ctrl+Nï¼šæ–°å»ºçª—å£ Ctrl+K+Bï¼šå¼€å…³ä¾§æ  Ctrl+Shift+Mï¼šé€‰ä¸­å½“å‰æ‹¬å·å†…å®¹ï¼Œé‡å¤å¯é€‰ç€æ‹¬å·æœ¬èº« Ctrl+F2ï¼šè®¾ç½®/åˆ é™¤æ ‡è®° Ctrl+/ï¼šæ³¨é‡Šå½“å‰è¡Œ Ctrl+Shift+/ï¼šå½“å‰ä½ç½®æ’å…¥æ³¨é‡Š Ctrl+Alt+/ï¼šå—æ³¨é‡Šï¼Œå¹¶Focusåˆ°é¦–è¡Œï¼Œå†™æ³¨é‡Šè¯´æ˜ç”¨çš„ Ctrl+Shift+Aï¼šé€‰æ‹©å½“å‰æ ‡ç­¾å‰åï¼Œä¿®æ”¹æ ‡ç­¾ç”¨çš„ F11ï¼šå…¨å± Shift+F11ï¼šå…¨å±å…æ‰“æ‰°æ¨¡å¼ï¼Œåªç¼–è¾‘å½“å‰æ–‡ä»¶ Alt+F3ï¼šé€‰æ‹©æ‰€æœ‰ç›¸åŒçš„è¯ Alt+.ï¼šé—­åˆæ ‡ç­¾ Alt+Shift+æ•°å­—ï¼šåˆ†å±æ˜¾ç¤º Alt+æ•°å­—ï¼šåˆ‡æ¢æ‰“å¼€ç¬¬Nä¸ªæ–‡ä»¶ Shift+å³é”®æ‹–åŠ¨ï¼šå…‰æ ‡å¤šä¸ï¼Œç”¨æ¥æ›´æ”¹æˆ–æ’å…¥åˆ—å†…å®¹ é¼ æ ‡çš„å‰è¿›åé€€é”®å¯åˆ‡æ¢Tabæ–‡ä»¶ æŒ‰Ctrlï¼Œä¾æ¬¡ç‚¹å‡»æˆ–é€‰å–ï¼Œå¯éœ€è¦ç¼–è¾‘çš„å¤šä¸ªä½ç½® æŒ‰Ctrl+Shift+ä¸Šä¸‹é”®ï¼Œå¯æ›¿æ¢è¡Œ é€‰æ‹©ç±» Ctrl+D é€‰ä¸­å…‰æ ‡æ‰€å çš„æ–‡æœ¬ï¼Œç»§ç»­æ“ä½œåˆ™ä¼šé€‰ä¸­ä¸‹ä¸€ä¸ªç›¸åŒçš„æ–‡æœ¬ã€‚ Alt+F3 é€‰ä¸­æ–‡æœ¬æŒ‰ä¸‹å¿«æ·é”®ï¼Œå³å¯ä¸€æ¬¡æ€§é€‰æ‹©å…¨éƒ¨çš„ç›¸åŒæ–‡æœ¬è¿›è¡ŒåŒæ—¶ç¼–è¾‘ã€‚ä¸¾ä¸ªæ —å­ï¼šå¿«é€Ÿé€‰ä¸­å¹¶æ›´æ”¹æ‰€æœ‰ç›¸åŒçš„å˜é‡åã€å‡½æ•°åç­‰ã€‚ Ctrl+L é€‰ä¸­æ•´è¡Œï¼Œç»§ç»­æ“ä½œåˆ™ç»§ç»­é€‰æ‹©ä¸‹ä¸€è¡Œï¼Œæ•ˆæœå’Œ Shift+â†“ æ•ˆæœä¸€æ ·ã€‚ Ctrl+Shift+L å…ˆé€‰ä¸­å¤šè¡Œï¼Œå†æŒ‰ä¸‹å¿«æ·é”®ï¼Œä¼šåœ¨æ¯è¡Œè¡Œå°¾æ’å…¥å…‰æ ‡ï¼Œå³å¯åŒæ—¶ç¼–è¾‘è¿™äº›è¡Œã€‚ Ctrl+Shift+M é€‰æ‹©æ‹¬å·å†…çš„å†…å®¹ï¼ˆç»§ç»­é€‰æ‹©çˆ¶æ‹¬å·ï¼‰ã€‚ä¸¾ä¸ªæ —å­ï¼šå¿«é€Ÿé€‰ä¸­åˆ é™¤å‡½æ•°ä¸­çš„ä»£ç ï¼Œé‡å†™å‡½æ•°ä½“ä»£ç æˆ–é‡å†™æ‹¬å·å†…é‡Œçš„å†…å®¹ã€‚ Ctrl+M å…‰æ ‡ç§»åŠ¨è‡³æ‹¬å·å†…ç»“æŸæˆ–å¼€å§‹çš„ä½ç½®ã€‚ Ctrl+Enter åœ¨ä¸‹ä¸€è¡Œæ’å…¥æ–°è¡Œã€‚ä¸¾ä¸ªæ —å­ï¼šå³ä½¿å…‰æ ‡ä¸åœ¨è¡Œå°¾ï¼Œä¹Ÿèƒ½å¿«é€Ÿå‘ä¸‹æ’å…¥ä¸€è¡Œã€‚ Ctrl+Shift+Enter åœ¨ä¸Šä¸€è¡Œæ’å…¥æ–°è¡Œã€‚ä¸¾ä¸ªæ —å­ï¼šå³ä½¿å…‰æ ‡ä¸åœ¨è¡Œé¦–ï¼Œä¹Ÿèƒ½å¿«é€Ÿå‘ä¸Šæ’å…¥ä¸€è¡Œã€‚ Ctrl+Shift+[ é€‰ä¸­ä»£ç ï¼ŒæŒ‰ä¸‹å¿«æ·é”®ï¼ŒæŠ˜å ä»£ç ã€‚ Ctrl+Shift+] é€‰ä¸­ä»£ç ï¼ŒæŒ‰ä¸‹å¿«æ·é”®ï¼Œå±•å¼€ä»£ç ã€‚ Ctrl+K+0 å±•å¼€æ‰€æœ‰æŠ˜å ä»£ç ã€‚ Ctrl+â† å‘å·¦å•ä½æ€§åœ°ç§»åŠ¨å…‰æ ‡ï¼Œå¿«é€Ÿç§»åŠ¨å…‰æ ‡ã€‚ Ctrl+â†’ å‘å³å•ä½æ€§åœ°ç§»åŠ¨å…‰æ ‡ï¼Œå¿«é€Ÿç§»åŠ¨å…‰æ ‡ã€‚ shift+â†‘ å‘ä¸Šé€‰ä¸­å¤šè¡Œã€‚ shift+â†“ å‘ä¸‹é€‰ä¸­å¤šè¡Œã€‚ Shift+â† å‘å·¦é€‰ä¸­æ–‡æœ¬ã€‚ Shift+â†’ å‘å³é€‰ä¸­æ–‡æœ¬ã€‚ Ctrl+Shift+â† å‘å·¦å•ä½æ€§åœ°é€‰ä¸­æ–‡æœ¬ã€‚ Ctrl+Shift+â†’ å‘å³å•ä½æ€§åœ°é€‰ä¸­æ–‡æœ¬ã€‚ Ctrl+Shift+â†‘ å°†å…‰æ ‡æ‰€åœ¨è¡Œå’Œä¸Šä¸€è¡Œä»£ç äº’æ¢ï¼ˆå°†å…‰æ ‡æ‰€åœ¨è¡Œæ’å…¥åˆ°ä¸Šä¸€è¡Œä¹‹å‰ï¼‰ã€‚ Ctrl+Shift+â†“ å°†å…‰æ ‡æ‰€åœ¨è¡Œå’Œä¸‹ä¸€è¡Œä»£ç äº’æ¢ï¼ˆå°†å…‰æ ‡æ‰€åœ¨è¡Œæ’å…¥åˆ°ä¸‹ä¸€è¡Œä¹‹åï¼‰ã€‚ Ctrl+Alt+â†‘ å‘ä¸Šæ·»åŠ å¤šè¡Œå…‰æ ‡ï¼Œå¯åŒæ—¶ç¼–è¾‘å¤šè¡Œã€‚ Ctrl+Alt+â†“ å‘ä¸‹æ·»åŠ å¤šè¡Œå…‰æ ‡ï¼Œå¯åŒæ—¶ç¼–è¾‘å¤šè¡Œã€‚ ç¼–è¾‘ç±» Ctrl+J åˆå¹¶é€‰ä¸­çš„å¤šè¡Œä»£ç ä¸ºä¸€è¡Œã€‚ä¸¾ä¸ªæ —å­ï¼šå°†å¤šè¡Œæ ¼å¼çš„CSSå±æ€§åˆå¹¶ä¸ºä¸€è¡Œã€‚ Ctrl+Shift+D å¤åˆ¶å…‰æ ‡æ‰€åœ¨æ•´è¡Œï¼Œæ’å…¥åˆ°ä¸‹ä¸€è¡Œã€‚ Tab å‘å³ç¼©è¿›ã€‚ Shift+Tab å‘å·¦ç¼©è¿›ã€‚ Ctrl+K+K ä»å…‰æ ‡å¤„å¼€å§‹åˆ é™¤ä»£ç è‡³è¡Œå°¾ã€‚ Ctrl+Shift+K åˆ é™¤æ•´è¡Œã€‚ Ctrl+/ æ³¨é‡Šå•è¡Œã€‚ Ctrl+Shift+/ æ³¨é‡Šå¤šè¡Œã€‚ Ctrl+K+U è½¬æ¢å¤§å†™ã€‚ Ctrl+K+L è½¬æ¢å°å†™ã€‚ Ctrl+Z æ’¤é”€ã€‚ Ctrl+Y æ¢å¤æ’¤é”€ã€‚ Ctrl+U è½¯æ’¤é”€ï¼Œæ„Ÿè§‰å’Œ Gtrl+Z ä¸€æ ·ã€‚ Ctrl+F2 è®¾ç½®ä¹¦ç­¾ Ctrl+T å·¦å³å­—æ¯äº’æ¢ã€‚ F6 å•è¯æ£€æµ‹æ‹¼å†™ æœç´¢ç±» Ctrl+F æ‰“å¼€åº•éƒ¨æœç´¢æ¡†ï¼ŒæŸ¥æ‰¾å…³é”®å­—ã€‚ Ctrl+shift+F åœ¨æ–‡ä»¶å¤¹å†…æŸ¥æ‰¾ï¼Œä¸æ™®é€šç¼–è¾‘å™¨ä¸åŒçš„åœ°æ–¹æ˜¯sublimeå…è®¸æ·»åŠ å¤šä¸ªæ–‡ä»¶å¤¹è¿›è¡ŒæŸ¥æ‰¾ï¼Œç•¥é«˜ç«¯ï¼Œæœªç ”ç©¶ã€‚ Ctrl+P æ‰“å¼€æœç´¢æ¡†ã€‚ä¸¾ä¸ªæ —å­ï¼š1ã€è¾“å…¥å½“å‰é¡¹ç›®ä¸­çš„æ–‡ä»¶åï¼Œå¿«é€Ÿæœç´¢æ–‡ä»¶ï¼Œ2ã€è¾“å…¥@å’Œå…³é”®å­—ï¼ŒæŸ¥æ‰¾æ–‡ä»¶ä¸­å‡½æ•°åï¼Œ3ã€è¾“å…¥ï¼šå’Œæ•°å­—ï¼Œè·³è½¬åˆ°æ–‡ä»¶ä¸­è¯¥è¡Œä»£ç ï¼Œ4ã€è¾“å…¥#å’Œå…³é”®å­—ï¼ŒæŸ¥æ‰¾å˜é‡åã€‚ Ctrl+G æ‰“å¼€æœç´¢æ¡†ï¼Œè‡ªåŠ¨å¸¦ï¼šï¼Œè¾“å…¥æ•°å­—è·³è½¬åˆ°è¯¥è¡Œä»£ç ã€‚ä¸¾ä¸ªæ —å­ï¼šåœ¨é¡µé¢ä»£ç æ¯”è¾ƒé•¿çš„æ–‡ä»¶ä¸­å¿«é€Ÿå®šä½ã€‚ Ctrl+R æ‰“å¼€æœç´¢æ¡†ï¼Œè‡ªåŠ¨å¸¦@ï¼Œè¾“å…¥å…³é”®å­—ï¼ŒæŸ¥æ‰¾æ–‡ä»¶ä¸­çš„å‡½æ•°åã€‚ä¸¾ä¸ªæ —å­ï¼šåœ¨å‡½æ•°è¾ƒå¤šçš„é¡µé¢å¿«é€ŸæŸ¥æ‰¾æŸä¸ªå‡½æ•°ã€‚ Ctrl+ï¼š æ‰“å¼€æœç´¢æ¡†ï¼Œè‡ªåŠ¨å¸¦#ï¼Œè¾“å…¥å…³é”®å­—ï¼ŒæŸ¥æ‰¾æ–‡ä»¶ä¸­çš„å˜é‡åã€å±æ€§åç­‰ã€‚ Ctrl+Shift+P æ‰“å¼€å‘½ä»¤æ¡†ã€‚åœºæ™¯æ —å­ï¼šæ‰“å¼€å‘½åæ¡†ï¼Œè¾“å…¥å…³é”®å­—ï¼Œè°ƒç”¨sublime textæˆ–æ’ä»¶çš„åŠŸèƒ½ï¼Œä¾‹å¦‚ä½¿ç”¨packageå®‰è£…æ’ä»¶ã€‚ Esc é€€å‡ºå…‰æ ‡å¤šè¡Œé€‰æ‹©ï¼Œé€€å‡ºæœç´¢æ¡†ï¼Œå‘½ä»¤æ¡†ç­‰ã€‚ æ˜¾ç¤ºç±» Ctrl+Tab æŒ‰æ–‡ä»¶æµè§ˆè¿‡çš„é¡ºåºï¼Œåˆ‡æ¢å½“å‰çª—å£çš„æ ‡ç­¾é¡µã€‚ Ctrl+PageDown å‘å·¦åˆ‡æ¢å½“å‰çª—å£çš„æ ‡ç­¾é¡µã€‚ Ctrl+PageUp å‘å³åˆ‡æ¢å½“å‰çª—å£çš„æ ‡ç­¾é¡µã€‚ Alt+Shift+1 çª—å£åˆ†å±ï¼Œæ¢å¤é»˜è®¤1å±ï¼ˆéå°é”®ç›˜çš„æ•°å­—ï¼‰ Alt+Shift+2 å·¦å³åˆ†å±-2åˆ— Alt+Shift+3 å·¦å³åˆ†å±-3åˆ— Alt+Shift+4 å·¦å³åˆ†å±-4åˆ— Alt+Shift+5 ç­‰åˆ†4å± Alt+Shift+8 å‚ç›´åˆ†å±-2å± Alt+Shift+9 å‚ç›´åˆ†å±-3å± Ctrl+K+B å¼€å¯/å…³é—­ä¾§è¾¹æ ã€‚ F11 å…¨å±æ¨¡å¼ Shift+F11 å…æ‰“æ‰°æ¨¡å¼]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdownè¯­æ³•]]></title>
    <url>%2F2019%2F02%2F27%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[æ­¤ç‰‡æ–‡ç« ä¸»è¦ç”¨äºè®°å½•ä¸€äº›ç®€å•çš„Markdownè¯­æ³•&lt;/br&gt;&lt;/br&gt;&lt;/br&gt; æ ‡é¢˜123# æ ‡é¢˜1çº§## æ ‡é¢˜2çº§### æ ‡é¢˜3çº§ æ ‡é¢˜1çº§æ ‡é¢˜2çº§æ ‡é¢˜3çº§æ–‡æœ¬12345æ­£å¸¸æ–‡æœ¬**åŠ ç²—æ–‡æœ¬***æ–œä½“æ–‡æœ¬ ****æ–œä½“åŠ ç²—æ–‡æœ¬***~~ä¸­é—´åŠ çº¿æ–‡æœ¬~~ æ­£å¸¸æ–‡æœ¬åŠ ç²—æ–‡æœ¬æ–œä½“æ–‡æœ¬ æ–œä½“åŠ ç²—æ–‡æœ¬ä¸­é—´åŠ çº¿æ–‡æœ¬ å¼•ç”¨123456&gt;å¼•ç”¨&gt;&gt;äºŒçº§å¼•ç”¨&gt;&gt;&gt;ä»¥æ­¤å†…æ¨&gt;è¿™æ˜¯å¼•ç”¨çš„å†…å®¹&gt;&gt;è¿™æ˜¯å¼•ç”¨çš„å†…å®¹&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;è¿™æ˜¯å¼•ç”¨çš„ å¼•ç”¨ äºŒçº§å¼•ç”¨ ä»¥æ­¤å†…æ¨è¿™æ˜¯å¼•ç”¨çš„å†…å®¹è¿™æ˜¯å¼•ç”¨çš„å†…å®¹ è¿™æ˜¯å¼•ç”¨çš„ åˆ†å‰²çº¿1234---åˆ†å‰²çº¿----- åˆ†å‰²çº¿ 1![å›¾ç‰‡](https://i.loli.net/2019/02/27/5c767c74660a3.png) å›¾æ’å…¥1![å›¾ç‰‡å](images/Markdownè¯­æ³•/20190301060640743.png) è¶…é“¾æ¥1[è¶…é“¾æ¥](http://baidu.com) è¶…é“¾æ¥ åˆ—è¡¨æ— åºåˆ—è¡¨12345- æ— åºåˆ—è¡¨- 1- 1* 1* 2 æ— åºåˆ—è¡¨ 1 1 1 2æœ‰åºåˆ—è¡¨ 1231.åˆ—è¡¨12.åˆ—è¡¨23.æœ‰åºåˆ—è¡¨ 1.åˆ—è¡¨12.åˆ—è¡¨23.æœ‰åºåˆ—è¡¨ åˆ—è¡¨åµŒå¥—123456- åˆ—è¡¨1 1.åˆ—è¡¨åµŒå¥— 3.åˆ—è¡¨2 4.åˆ—è¡¨3- åˆ—è¡¨2 1.åˆ—è¡¨ ä¸‹ä¸€çº§å‰3ä¸ªç©ºæ ¼ åˆ—è¡¨1 1.åˆ—è¡¨åµŒå¥— 3.åˆ—è¡¨2 4.åˆ—è¡¨3 åˆ—è¡¨2 1.åˆ—è¡¨ è¡¨æ ¼1234è¡¨å¤´|è¡¨å¤´|è¡¨å¤´---|:--:|---:å†…å®¹|å†…å®¹|å†…å®¹å†…å®¹|å†…å®¹|å†…å®¹ ç¬¬äºŒè¡Œåˆ†å‰²è¡¨å¤´å’Œå†…å®¹ã€‚-æœ‰ä¸€ä¸ªå°±è¡Œï¼Œä¸ºäº†å¯¹é½ï¼Œå¤šåŠ äº†å‡ ä¸ª æ–‡å­—é»˜è®¤å±…å·¦-ä¸¤è¾¹åŠ ï¼šè¡¨ç¤ºæ–‡å­—å±…ä¸­-å³è¾¹åŠ ï¼šè¡¨ç¤ºæ–‡å­—å±…å³ è¡¨å¤´ è¡¨å¤´ è¡¨å¤´ å†…å®¹ å†…å®¹ å†…å®¹ å†…å®¹ å†…å®¹ å†…å®¹ ä»£ç å—12345var num = 0;for (var i = 0; i &lt; 5; i++) &#123; num+=i;&#125;console.log(num); ``` (æ­¤å¤„å†™ä»£ç è¯­è¨€)ä¸­é—´å¯å†™å…¥ä»£ç  ``` ` ä¸€ä¸ªç‚¹å°å‹åˆ†å—]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVAç¯å¢ƒé…ç½®]]></title>
    <url>%2F2019%2F02%2F27%2FJAVA%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[æœ¬ç¯‡æ–‡ç« ç”¨äºè®°å½•JAVAé…ç½®ã€‚ JAVAå®‰è£…ï¼Œç™¾åº¦æœç´¢JAVAå®˜ç½‘ï¼Œä¸‹è½½å¯¹åº”ç³»ç»Ÿç‰ˆæœ¬ï¼Œä¸‹è½½å®‰è£…å¥½ååº”è¯¥æœ‰ JDK å’ŒJDR ä¸¤ä¸ªæ–‡ä»¶å¤¹ é…ç½®ç³»ç»Ÿç¯å¢ƒ(1)æ–°å»º-&gt;å˜é‡åâ€JAVA_HOMEâ€ï¼Œå˜é‡å€¼ C:\Java\jdk1.8.0_05(ä½ çš„JDKè·¯å¾„)(2)æ–°å»º-&gt;å˜é‡åâ€œCLASSPATHâ€,å˜é‡å€¼ .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;ç¬¬ä¸‰ä¸ªå˜é‡ï¼Œå¦‚æœå·²ç»æœ‰äº†Pathå˜é‡åº”è¯¥ç›´æ¥ç¼–è¾‘ï¼Œç„¶åå†åœ¨èƒŒåæ·»åŠ å˜é‡(3)ç¼–è¾‘-&gt;å˜é‡åâ€Pathâ€ï¼Œåœ¨åŸå˜é‡å€¼çš„æœ€åé¢åŠ ä¸Š ;%JAVA_HOME%\bin;%JAVA_HOME%\jre\binè¿™ä¸ªå˜é‡æ²¡é…ç½®å¥½ä¼šå‡ºç°æ²¡æœ‰javacè¿™ä¸ªæŒ‡ä»¤ å˜é‡å€¼æ˜¯ä»¥ ï¼› åŒºåˆ†å‡ ä¸ªå˜é‡å€¼ã€‚åœ¨win10æƒ…å†µä¸‹ï¼Œç‚¹å‡»ç¼–è¾‘Pathè·¯å¾„èƒ½å¤Ÿçœ‹è§ä¸€ä¸ªå›¾è¡¨ é‡Œé¢å­˜æœ‰å„ä¸ªå˜é‡å€¼ï¼Œç‚¹å‡»ç¼–è¾‘æ–‡æœ¬å¯ä»¥çœ‹è§å˜é‡å€¼æ–‡æœ¬å½¢å¼ï¼Œä¸¤è€…å¯¹ç…§çœ‹åº”è¯¥å°±èƒ½æ˜ç™½æ€ä¹ˆç»™Pathæ·»åŠ ä¸€ä¸ªæ–°çš„å˜é‡ã€‚ window åœ¨æ§åˆ¶å°è¾“å…¥ä¸‰ä¸ªæŒ‡ä»¤ javaï¼Œjavacï¼Œjava -version å¦‚æœæ˜¾ç¤ºæ²¡æœ‰è¿™ä¸ªæŒ‡ä»¤è¯´æ˜é…ç½®é”™è¯¯ã€‚]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>é…ç½®</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next 6.0 ä»¥ä¸Šç‰ˆæœ¬èƒŒæ™¯åŠ¨ç”»Canvas_nestè®¾ç½®æ— æ•ˆ]]></title>
    <url>%2F2019%2F02%2F25%2FNext%206.0%20%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC%E8%83%8C%E6%99%AF%E5%8A%A8%E7%94%BBCanvas_nest%E8%AE%BE%E7%BD%AE%E6%97%A0%E6%95%88%2F</url>
    <content type="text"><![CDATA[æŠŠè¿™ä¸ªä¸‹è½½ä¸€ä¸‹ è§å®˜æ–¹æ–‡æ¡£ https://github.com/theme-next/theme-next-canvas-nest åœ¨ä½ çš„åšå®¢ç›®å½•ä¸‹ 1git clone https://github.com/theme-next/theme-next-canvas-nest themes/next/source/lib/canvas-nest å°±å¯ä»¥äº†]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unityå®‰è£…å¥½SDK JDK è¿˜æ˜¯æ— æ³•æ‰“åŒ…app 2019ç‰ˆæœ¬é—®é¢˜]]></title>
    <url>%2F2019%2F02%2F22%2FUnity%E5%AE%89%E8%A3%85%E5%A5%BDSDK%20JDK%20%E8%BF%98%E6%98%AF%E6%97%A0%E6%B3%95%E6%89%93%E5%8C%85app%20%20%202019%E7%89%88%E6%9C%AC%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[å®‰è£…å¥½SDKï¼ŒJDKï¼Œæ‰“çˆ†å®‰å“è½¯ä»¶è¿˜æ˜¯å‡ºé”™ã€‚å‡ºç°ç‰ˆæœ¬å°äº† å¼¹å‡ºé”™è¯¯ CommandInvokationFailure: Failed to create a raw.ap_ package 1234567891011121314151617181920212223242526272829303132333435363738 CommandInvokationFailure: Failed to create a raw.ap_ packageH:\Program Files\Unity\Editor\Data\PlaybackEngines\AndroidPlayer/Tools\OpenJDK\Windows\bin\java.exe -Xmx4096M -Dcom.android.sdkmanager.toolsdir=&quot;H:/Program Files/android-sdk-windows\tools&quot; -Dfile.encoding=UTF8 -jar &quot;H:\Program Files\Unity\Editor\Data\PlaybackEngines\AndroidPlayer/Tools\sdktools.jar&quot; -stderr[Exception in thread &quot;main&quot; java.lang.reflect.InvocationTargetException at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at SDKMain.main(SDKMain.java:136)Caused by: java.lang.NoSuchMethodError: com.google.common.util.concurrent.MoreExecutors.directExecutor()Ljava/util/concurrent/Executor; at com.android.apkzlib.zip.ZFile.createSources(ZFile.java:1586) at com.android.apkzlib.zip.ZFile.makeStoredEntry(ZFile.java:1546) at com.android.apkzlib.zip.ZFile.add(ZFile.java:1625) at com.android.apkzlib.zip.ZFile.add(ZFile.java:1499) at com.android.apkzlib.sign.ManifestGenerationExtension.updateManifest(ManifestGenerationExtension.java:241) at com.android.apkzlib.sign.ManifestGenerationExtension.access$000(ManifestGenerationExtension.java:52) at com.android.apkzlib.sign.ManifestGenerationExtension$1.lambda$beforeUpdate$0(ManifestGenerationExtension.java:168) at com.android.apkzlib.zip.ZFile.notify(ZFile.java:2099) at com.android.apkzlib.zip.ZFile.update(ZFile.java:871) at com.android.apkzlib.zip.ZFile.close(ZFile.java:1161) at com.android.apkzlib.zfile.ApkZFileCreator.close(ApkZFileCreator.java:189) at UnityPackageBuilder.CreatePackage(UnityPackageBuilder.java:136) at UnityPackageBuilder.&lt;init&gt;(UnityPackageBuilder.java:70) at UnityPackageBuilder.main(UnityPackageBuilder.java:27) ... 5 more]stdout[]exit code: 1UnityEditor.Android.AndroidSDKTools.RunCommand (System.String javaExe, System.String sdkToolsDir, System.String[] sdkToolCommand, System.String workingdir, System.String errorMsg, System.Int32 memoryMB) (at &lt;7cbc688ae1af4105929402a46c6a4414&gt;:0)UnityEditor.Android.AndroidSDKTools.RunSDKToolWithReadLock (System.String[] command, System.String workingdir, System.String errorMsg) (at &lt;7cbc688ae1af4105929402a46c6a4414&gt;:0)UnityEditor.Android.PostProcessor.Tasks.AAPTPackage.CreatePackage (UnityEditor.Android.PostProcessor.PostProcessorContext context, System.String package, System.String directory, System.Boolean compress) (at &lt;7cbc688ae1af4105929402a46c6a4414&gt;:0)UnityEditor.Android.PostProcessor.Tasks.AAPTPackage.Pack (UnityEditor.Android.PostProcessor.PostProcessorContext context, System.String package, System.String directory, System.Boolean compress, System.Boolean useAAPT) (at &lt;7cbc688ae1af4105929402a46c6a4414&gt;:0)UnityEditor.Android.PostProcessor.Tasks.AAPTPackage.Execute (UnityEditor.Android.PostProcessor.PostProcessorContext context) (at &lt;7cbc688ae1af4105929402a46c6a4414&gt;:0)UnityEditor.Android.PostProcessor.PostProcessRunner.RunAllTasks (UnityEditor.Android.PostProcessor.PostProcessorContext context) (at &lt;7cbc688ae1af4105929402a46c6a4414&gt;:0)UnityEngine.GUIUtility:ProcessEvent(Int32, IntPtr) è¿™ä¸ªæ˜¯ç‰ˆæœ¬è·Ÿä¸ä¸Šç»“æœï¼Œè¦ä¹ˆæ›´æ–°SDK ï¼Œè¦ä¹ˆå°±æ˜¯unityæœ‰ä¸€ä¸ªuse legecy SDK tool é€‰ä¸Šå°±å¯ä»¥äº†]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å®‰è£…JAVAç¯å¢ƒ javaèƒ½ç”¨javacä¸èƒ½ç”¨]]></title>
    <url>%2F2019%2F02%2F22%2F%E5%AE%89%E8%A3%85JAVA%E7%8E%AF%E5%A2%83%20java%E8%83%BD%E7%94%A8javac%E4%B8%8D%E8%83%BD%E7%94%A8%2F</url>
    <content type="text"><![CDATA[å®‰è£…javaç¯å¢ƒå°±ä¸è¯´äº†ï¼Œç™¾åº¦ä¸€ä¸‹ä¸€å¤§ç‰‡ã€‚é‡ç‚¹æ˜¯å®‰è£…é‚£ä¸ªå®‰è£…å¥½åjavacä¸èƒ½ç”¨ã€‚ è¿™ä¸ªå¤§éƒ¨åˆ†éƒ½æ˜¯å› ä¸ºæ²¡æœ‰ä¸»ä¹‰ä¸€ä¸‹ç¯å¢ƒè®¾ç½®ç»†èŠ‚ã€‚ æˆ‘æŠŠè¿™å‡ ä¸ªæ‰“æˆä»£ç å…å¾—ä¸çŸ¥é“å¼•å·å’Œç©ºæ ¼æ˜¯ä¸æ˜¯è¦è¾“å…¥çš„ã€‚ã€‚ã€‚ æ–°å»ºç¯å¢ƒå˜é‡ å˜é‡å 1CLASSPATH å˜é‡å€¼ 1.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; æ–°å»ºç¯å¢ƒå˜é‡ å˜é‡å 1JAVA_HOME å˜é‡å€¼ //æ˜¯ä½ å®‰è£…JDKçš„è·¯å¾„åˆ«ç›´æ¥å¤åˆ¶ç²˜è´´ 1H:\Program Files\Java\jdk å‰é¢ä¸¤ä¸ªæ˜¯æ–°å»ºè·¯å¾„ï¼Œä¸€èˆ¬ä¸ä¼šæœ‰å•¥é—®é¢˜ã€‚åé¢è¿™ä¸ªä¸€èˆ¬æ˜¯ç¼–è¾‘ï¼Œå› ä¸ºç³»ç»Ÿè‡ªå¸¦ä¸€éƒ¨åˆ†è·¯å¾„ã€‚ç¼–è¾‘å°±æ¯”è¾ƒå®¹æ˜“å‡ºé”™ã€‚ ç¼–è¾‘ç¯å¢ƒå˜é‡ å˜é‡å 1Path å˜é‡å€¼ 1C:\ProgramData\Oracle\Java\javapath;%java_home%\bin;%java_home%\jre\bin; ç¼–è¾‘ä¹‹ååº”è¯¥æ˜¯è¿™ä¸ªæ ·å­ï¼Œä¸€å¼€å§‹æœ‰ä¸€éƒ¨åˆ†ã€‚ ä¸€èˆ¬å°±æ˜¯å‡ºé”™åœ¨è¿™ï¼Œå¤§éƒ¨åˆ†äººçœ‹ä¸æ‡‚é‚£ä¸ªè·¯å¾„å°±ç›´æ¥å¤åˆ¶ç²˜è´´ä¸Šå»ã€‚å°±ä¼šå‡ºç°è¿™ç§æƒ…å†µ è§£å†³åŠæ³•ï¼Œç‚¹å‡»å³ä¸‹è§’çš„ç¼–è¾‘æ–‡æœ¬,æŠŠä¸‹é¢ä¸¤ä¸ªå¼•å·åˆ é™¤å°±å¯ä»¥äº† ç„¶åä½ é‡æ–°ç‚¹å‡»ç¼–è¾‘å˜é‡å€¼ï¼Œåº”è¯¥æ˜¯ä¸‹é¢è¿™ä¸ªæ ·å­ã€‚ å‡ºç°è¿™ç§æƒ…å†µæ˜¯å› ï¼Œä½ ç›´æ¥å¤åˆ¶ç²˜è´´çš„è¿™ä¸€æ®µé‡Œé¢æœ‰åˆ†å·ï¼Œåˆ†å·æ˜¯ç¯å¢ƒå˜é‡çš„åˆ†å‰²ç¬¦ï¼Œä½ è¾“å…¥çš„æ–‡æœ¬é‡Œé¢æœ‰åˆ†å·ï¼Œç»“æœç³»ç»Ÿè‡ªåŠ¨ç»™ä½ åŠ äº†å¼•å·ã€‚ æŠŠåˆ†å·å»æ‰ä¸€æ®µä¸€æ®µçš„è¾“å…¥ä¹Ÿæ˜¯å¯ä»¥çš„ã€‚]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity ç‚¹å‡»UIä¸ç‚¹å‡»å±å¹•å†²çª]]></title>
    <url>%2F2019%2F02%2F20%2FUnity%20%E7%82%B9%E5%87%BBUI%E4%B8%8E%E7%82%B9%E5%87%BB%E5%B1%8F%E5%B9%95%E5%86%B2%E7%AA%81%2F</url>
    <content type="text"><![CDATA[Unity æœ‰ç‚¹å‡»å±å¹•è¿›è¡Œç§»åŠ¨æ“ä½œï¼Œé€šè¿‡Input.GetMouseButtonDown(0)ã€‚å¦‚æœç‚¹å‡»åˆ°äº†ä¸€äº›UIä¸Šé¢ä¼šè§¦å‘ç‚¹å‡»å±å¹•äº‹ä»¶ã€‚ å¼•å…¥UnityEngine.EventSystemsï¼Œç”¨å‡½æ•°åˆ¤æ–­ä¸€ä¸‹å³å¯ 12345678910111213141516 using System.Collections;using System.Collections.Generic;using UnityEngine;using DG.Tweening;using UnityEngine.EventSystems;public class PlayerController : MonoBehaviour&#123; private void Update() &#123; if (EventSystem.current.IsPointerOverGameObject()) return; if (Input.GetMouseButtonDown(0)) &#123; Debug.Log(&quot;ç‚¹å‡»å±å¹•&quot;); &#125; &#125;&#125; è¿™ä¸ªæ–¹æ³•ä¼šå°†ç‚¹å‡»Textçš„æ—¶å€™ä¹Ÿä¼šå½“ä½œç‚¹å‡»UI å°†raycast target å–æ¶ˆå‹¾é€‰å¯ä»¥é¿å…ã€‚]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç”¨è™šæ‹ŸæœºCentOS7 åšæœåŠ¡å™¨ æ­å»ºä¸ªäººåšå®¢ è¯¦ç»†æ•™ç¨‹ 2019.02]]></title>
    <url>%2F2019%2F02%2F11%2F%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BACentOS7%20%E5%81%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%20%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%202019.02%2F</url>
    <content type="text"><![CDATA[æœåŠ¡å™¨ç”¨çš„æ˜¯CentOS7 , æˆ‘å»ºåœ¨è™šæ‹Ÿæœºä¸Šï¼Œåƒè…¾è®¯äº‘ä»€ä¹ˆçš„å…¶å®ä¹Ÿæ˜¯ä¸€æ ·çš„ã€‚ è™šæ‹Ÿæœºçš„å®‰è£…å°±ä¸è¯´äº†ï¼Œä¸æ‡‚çš„è‡ªå·±å»ç™¾åº¦ä¸‹ï¼Œä¸€ç™¾åº¦ä¸€å¤§å †ã€‚ å‡†å¤‡å·¥ä½œ æ²¡æœ‰ç»™å‡ºä¸‹è½½è¿æ¥ï¼Œéƒ½æ˜¯äº›å¸¸è§çš„ä¸œè¥¿ï¼Œå¦‚æœå®åœ¨æ‰¾ä¸åˆ°æˆ–è€…æœ‰ç–‘é—®ç•™ä¸‹è¯„è®ºã€‚ å®‰è£… æœ‰CentOS è™šæ‹Ÿæœºçš„ VMware (å®‰è£…CentOS7 çš„æ—¶å€™è®°å¾—æ‰“å¼€ç½‘å¡ï¼Œä¸ç„¶åé¢è¦ç”¨å‘½ä»¤è¡Œæ‰“å¼€æŒºéº»çƒ¦çš„ï¼Œè¿™ä¸ªè‡ªå·±å»ç™¾åº¦æ€ä¹ˆæ‰“å¼€ã€‚) Xshell 6 åŒç±»å‹çš„è¿æ¥æœåŠ¡å™¨è½¯ä»¶ä¹Ÿå¯ä»¥ï¼Œè…¾è®¯äº‘æˆ–è‡ªå·±çš„è¿æ¥ä¹Ÿè¡Œã€‚ start ï¼ˆå…ˆç™»å½•ã€‚ã€‚ã€‚ã€‚ï¼‰ æŸ¥çœ‹è‡ªå·±è™šæ‹Ÿæœº IP æŒ‡ä»¤ï¼šip add 1ip add å¦‚ä¸Šå›¾ å°±æ˜¯IP4 çš„åœ°å€ï¼Œç„¶åé€šè¿‡Xshell6 è¿æ¥ (ä¸ºäº†æ¨¡æ‹ŸæœåŠ¡å™¨è¿æ¥ï¼Œæ‰€ä»¥è™šæ‹Ÿæœºç›´æ¥åå°è¿è¡Œï¼Œå®é™…ä¸Šç›´æ¥åœ¨è™šæ‹Ÿæœºå¤„ç†ä¹Ÿæ˜¯ä¸€æ ·ï¼Œè¿™é‡Œè¯´ä¸€ä¸‹è¿æ¥æœåŠ¡å™¨çš„æ–¹æ³•) æ–°å»ºä¸€ä¸ªè¿æ¥ ç„¶åè¿æ¥å°±å¯ä»¥äº† å…³é—­é˜²ç«å¢™ï¼Œä¹Ÿå¯ä»¥å¼€ä¸€ä¸ªç«¯å£ã€‚ ä¸ºäº†æ–¹ä¾¿æˆ‘ç›´æ¥å…³é—­é˜²ç«å¢™ã€‚ 12 systemctl stop firewalld.service #åœæ­¢firewallsystemctl disable firewalld.service #ç¦æ­¢firewallå¼€æœºå¯åŠ¨ ç„¶åç›´æ¥å®‰è£…ï¼Œhttpdå³å¯ä¹Ÿå°±æ˜¯Apache æŒ‡ä»¤ï¼šyum install httpd 1yum install httpd ç„¶åå¯åŠ¨æœåŠ¡ æŒ‡ä»¤:systemctl start httpd.service 1systemctl start httpd.service è¾“å…¥IPåº”è¯¥å°±èƒ½çœ‹è§è¿™ä¸ªç©æ„äº†ã€‚ è¯´æ˜å·²ç»å®‰è£…å¥½äº† ç„¶åå°±æ˜¯å®‰è£…mysql å› ä¸ºæ²¡æœ‰mysql æº æ‰€ä»¥å…ˆè£…ä¸€ä¸ªã€‚ æŒ‡ä»¤ï¼šsudo rpm -Uvh http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm yum install mysql mysql-server mysql-libs mysql-server 12 sudo rpm -Uvh http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpmyum install mysql mysql-server mysql-libs mysql-server ç„¶åå¯åŠ¨ä¸€ä¸‹è¿™ä¸ªmysqlæœåŠ¡ systemctl restart mysql.service 123 systemctl restart mysql.service #é‡å¯mysqlæœåŠ¡systemctl start mysql.service #å¯åŠ¨mysqlæœåŠ¡systemctl stop mysql.service #åœæ­¢mysqlæœåŠ¡ ä¸ºmysqlè®¾ç½®ç™»é™†å¯†ç ï¼Œç„¶åç™»é™†ï¼Œåœ¨åˆ›å»ºä¸€ä¸ªwordpress çš„æ•°æ®åº“ã€‚ 1234 /usr/bin/mysqladmin -u root password &apos;123456&apos; #åé¢è¿™ä¸¤ä¸ªå¼•å·é‡Œé¢çš„æ˜¯å¯†ç mysql -uroot --password=&apos;123456&apos; #è¾“å…¥ç™»é™†å¯†ç CREATE DATABASE wordpress; #åˆ›å»ºwordpressæ•°æ®åº“exit #é€€å‡ºmysql ç„¶åå†å®‰è£…PHP æŒ‡ä»¤ï¼šyum install php-fpm php-mysql -y 123 yum install php-fpm php-mysql -yyum install phpyum install php-gd php-imap php-ldap php-odbc php-pear php-xml php-xmlrpc å¯åŠ¨PHPæœåŠ¡ å†æŠŠå®ƒè®¾ç½®ä¸ºå¼€æœºå¯åŠ¨ã€‚ 12 service php-fpm startchkconfig php-fpm on ç„¶åå†æŠŠï¼ŒApache å’Œ mysql è®¾ç½®æˆå¼€æœºè‡ªåŠ¨å¯åŠ¨å†é‡å¯ä¸€ä¸‹æœåŠ¡ 1234 systemctl enable httpd.servicesystemctl enable mysqld.servicesystemctl restart httpd.servicesystemctl restart mysqld.service ç„¶ååˆ›å»ºä¸€ä¸ª phpæ–‡ä»¶è¯•è¯•æ˜¯ä¸æ˜¯æˆåŠŸè£…å¥½äº†PHP æŒ‡ä»¤ï¼švi /var/www/html/info.php (å¦‚æœç›´æ¥ä¿®æ”¹ä¸äº†å°±è¿›å…¥è¿™ä¸ªæ–‡ä»¶å¤¹é‡Œé¢å…ˆåˆ›å»ºå†ä¿®æ”¹) 1vi /var/www/html/info.php ç„¶åæŒ‰ i è¿›å…¥è¾“å…¥æ¨¡å¼ï¼Œå†è¾“å…¥ 123 &lt;?phpphpinfo();?&gt; ç„¶åæŒ‰ESC æŒ‰ : è¾“å…¥ wq ç¡®å®š ï¼Œä¿å­˜é€€å‡ºã€‚ ç„¶åå†å»æµè§ˆå™¨è¾“å…¥ ç½‘å€ ä½ åŸæœ¬çš„ip/info.php åº”è¯¥å°±æ˜¯è¿™ä¸ªæ ·å­ï¼Œç„¶åï¼Œå°±å»è‡ªå·±ç”µè„‘ä¸Šæ‰¾wordpress çš„æ–‡ä»¶ ç„¶åè·å¾—è¿™ä¸ªå®‰è£…åŒ… wget åˆšæ‰é‚£ä¸ªè¿æ¥ å¦‚æœæ˜¾ç¤º æ²¡æœ‰wget å…ˆ è¾“å…¥ yum install wegt å…ˆå®‰è£… 1wget https://wordpress.org/latest.zip ç„¶ååœ¨ è§£å‹ unzip latest.zip å¦‚æœæ˜¾ç¤ºæ²¡æœ‰unzip ä¸€æ ·çš„å…ˆè¾“å…¥ yum insatll unzip 1unzip latest.zip #æ˜¯ä»€ä¹ˆæ–‡ä»¶åå°±æ˜¯è§£å‹ä»€ä¹ˆæ–‡ä»¶ ç„¶åå†å¤åˆ¶åˆ°html æ–‡ä»¶é‡Œé¢å» 1cp -rf wordpress/* /var/www/html/ å†ä¿®æ”¹ä¸€ä¸‹æ–‡ä»¶æƒé™ã€‚ 1chmod -R 777 html/ ç„¶åè¾“å…¥IPåº”è¯¥å°±å¯ä»¥è¿›å…¥å®‰è£…ç•Œé¢äº†ã€‚ ç„¶åä¸€è·¯ç‚¹ä¸‹å»å°±è¡Œäº†ï¼Œè¾“å…¥æ•°æ®åº“åï¼Œè¿˜æœ‰æ•°æ®åº“ç™»é™†è´¦æˆ·å’Œå¯†ç ï¼Œå°±æ˜¯ç™»é™†mysqlçš„ã€‚ç”¨æˆ·åä¸€èˆ¬å°±æ˜¯rootã€‚ å¦‚æœå‡ºç°è¿™ä¸ªï¼ŒæŠŠé‡Œé¢å†…å®¹å¤åˆ¶ä¸€éï¼Œåˆ›å»ºä¸€ä¸ªwp-config.phpæ–‡ä»¶ç„¶åå¤åˆ¶ç²˜è´´è¿›å»å°±è¡Œäº†ã€‚ ç„¶åæŒ‰æç¤ºä¸€è·¯ä¸‹å»å°±è¡Œäº†ï¼Œå¦‚æœåé¢è£…æ’ä»¶å‡ºäº†ç‚¹é—®é¢˜ï¼Œè¦FTPåè®®çš„è¯å°±å»è£…ä¸€ä¸‹ yum install vsftpd useradd admin passwd 123456systemctl enable vsftpd.service systemctl restart vsftpd.service 123456789 yum install vsftpduseradd adminpasswd 123456systemctl enable vsftpd.service systemctl restart vsftpd.service]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wordpress Error establishing a database connection Mysql80å»ºç«‹æ•°æ®åº“è¿æ¥æ—¶å‡ºé”™]]></title>
    <url>%2F2019%2F02%2F07%2FWordpress%20Error%20establishing%20a%20database%20connection%20Mysql80%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%97%B6%E5%87%BA%E9%94%99%2F</url>
    <content type="text"><![CDATA[å»ºç«‹æ•°æ®åº“è¿æ¥æ—¶å‡ºé”™ è¿™æˆ–è€…æ„å‘³ç€æ–‡ä»¶ä¸­çš„ç”¨æˆ·åå’Œå¯†ç ä¿¡æ¯ wp-config.php ä¸æ­£ç¡®ï¼Œæˆ–è€…æˆ‘ä»¬æ— æ³•è”ç³»æ•°æ®åº“æœåŠ¡å™¨ localhost ã€‚è¿™å¯èƒ½æ„å‘³ç€ä¸»æœºçš„æ•°æ®åº“æœåŠ¡å™¨å·²å…³é—­ã€‚ æ‚¨ç¡®å®šæ‹¥æœ‰æ­£ç¡®çš„ç”¨æˆ·åå’Œå¯†ç å—ï¼Ÿ æ‚¨ç¡®å®šå·²é”®å…¥æ­£ç¡®çš„ä¸»æœºåå—ï¼Ÿ æ‚¨ç¡®å®šæ•°æ®åº“æœåŠ¡å™¨æ­£åœ¨è¿è¡Œå—ï¼Ÿ å¦‚æœæ‚¨ä¸ç¡®å®šè¿™äº›æœ¯è¯­çš„å«ä¹‰ï¼Œæ‚¨åº”è¯¥è”ç³»æ‚¨çš„ä¸»äººã€‚å¦‚æœæ‚¨ä»éœ€è¦å¸®åŠ©ï¼Œå¯ä»¥éšæ—¶è®¿é—®WordPressæ”¯æŒè®ºå›ã€‚ å‡ºç°è¿™ä¸ªé—®é¢˜æœ‰å‡ ç§å¯èƒ½ï¼Œæœ€å¸¸è§å‡ ç§å°±æ˜¯ç”¨æˆ·åå¯†ç æˆ–è€…æ•°æ®åº“åæ‰“é”™äº†ã€‚ è¿˜æœ‰ä¸€ç§å¯èƒ½å°±æ˜¯ä½ çš„mysqlåŠ å¯†æ–¹å¼ä¸ä¸€æ ·ã€‚ å…ˆè¾“å…¥ use mysql ; å†è¾“å…¥ select host,user,plugin from user; 12 use mysql;select host,user,plugin from user; æŸ¥çœ‹åŠ å¯†æ–¹å¼ï¼Œå°±æ˜¯ plugin è¿™ä¸ªä¸‹é¢æ˜¾ç¤ºã€‚ caching_sha2_password æ˜¯ä¸€ç§æ–°çš„åŠ å¯†æ–¹å¼ï¼Œwpå’Œdiscuz æœ‰äº›ç‰ˆæœ¬ æ˜¯ä¸æ”¯æŒçš„ã€‚ æ‰€ä»¥è¿™ä¸ªæ—¶å€™è¦ä¿®æ”¹ä¸€ä¸‹ è¾“å…¥æŒ‡ä»¤ update user set plugin=â€™mysql_native_passwordâ€™ where user=â€™rootâ€™; 1update user set plugin=&apos;mysql_native_password&apos; where user=&apos;root&apos;; è¾“å…¥æŒ‡ä»¤ä¹‹åå°±æ˜¯ä¸‹é¢è¿™ä¸ªæ ·å­ã€‚è¾“å…¥è¿™ä¸ªæŒ‡ä»¤ä¹‹å ä½ åŸæœ¬çš„å¯†ç åŠ å¯†æ–¹å¼å˜äº†ï¼Œæ‰€ä»¥ä½ çš„å¯†ç ä¹Ÿå˜äº†ï¼Œå¦‚æœä½ æŠ€æœ¯å¥½ï¼Œå¯ä»¥ç ”ç©¶ä¸€ä¸‹ä½ çš„å¯†ç å˜æˆäº†å¤šå°‘ï¼Œå¦‚æœç®—ä¸å‡ºæ¥å°±è€è€å®å®æ”¹å¯†ç ã€‚æ³¨æ„ï¼šæ”¹å¯†ç å¿…é¡»æŒ‡æ˜åŠ å¯†æ–¹å¼ï¼Œä¸ç„¶åˆä¼šå˜å›å»ã€‚ è¾“å…¥æŒ‡ä»¤ï¼šALTER USER â€˜rootâ€™@â€™localhostâ€™ IDENTIFIED WITH mysql_native_password BY â€˜ä½ çš„å¯†ç â€™; 1ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;; ç„¶ååœ¨è¾“å…¥å‰é¢é‚£ä¸ªæŒ‡ä»¤çœ‹ä¸€ä¸‹ select host,user,plugin from user; æœ€åè¾“å…¥æœ€åä¸€ä¸ªæ›´æ–°æƒé™æŒ‡ä»¤ï¼š flush privileges; 1flush privileges; ç„¶åé€€å‡ºé‡å¯å°±è¡Œäº†ã€‚]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+githubæ­å»ºä¸ªäººåšå®¢ 2019.2 è¯¦ç»†æ•™ç¨‹]]></title>
    <url>%2F2019%2F02%2F04%2Fhexo%2Bgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%202019.2%20%20%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[å¤§è¿‡å¹´çš„ï¼Œå°±å»è¯•è¯•æ­ä¸€ä¸ªè‡ªå·±çš„åšå®¢ï¼Œçœ‹äº†åˆ«äººçš„åšå®¢ï¼Œç…§ç€æ­äº†ä¸€ä¸ªï¼Œä¸­é—´å› ä¸ºå„ç§bugï¼Œè¯•äº†åŠå¤©å“ã€‚ä¸è¿‡ä¹Ÿæ˜¯ä¸ªå¾ˆå¥½ç†è§£github,hexoçš„æ³•å­ï¼Œæ¯•ç«Ÿä¸å‡ºé”™ï¼Œæ€ä¹ˆä¼šç†è§£ã€‚ä¸­é—´è¿˜æœ‰äº›ä¸œè¥¿è¿˜æ²¡ææ˜ç™½ï¼Œå¸Œæœ›å¤§ä½¬å‰æ¥è§£ç­”ä¸€ä¸‹ã€‚ ä¸‹é¢å°±å¼€å§‹æ­å»ºäº†ã€‚ å‡†å¤‡å·¥ä½œ node.js https://nodejs.org/en/ é“¾æ¥ï¼šhttps://pan.baidu.com/s/1-I1ROA_2rq4MDG1BFe0BqA æå–ç ï¼šcnsz GIT https://git-scm.com/downloads ç™¾åº¦äº‘é“¾æ¥ï¼šhttps://pan.baidu.com/s/1-I1ROA_2rq4MDG1BFe0BqA æå–ç ï¼šcnsz (ä¸è¦é—®ä¸ºå•¥ç»™ä½ ä»¬æ”¾ä¸ªç™¾åº¦äº‘é“¾æ¥ ï¼Œæˆ‘ç‰¹ä¹ˆå®˜ç½‘ä¸‹ä¸äº†ï¼Œè¿˜æ‰¾äº†åŠå¤©) å®‰è£…å¥½åç¡®è®¤ä¸€ä¸‹ï¼š è£…å¥½åï¼Œåœ¨cmd æˆ–è€… power shell é‡Œé¢æ‰“å‡ºè¿™å‡ ä¸ªæŒ‡ä»¤ï¼Œå°±å¯ä»¥æ˜¾ç¤ºç‰ˆæœ¬ï¼Œä¹Ÿå°±æ˜¯æœ‰è¿™å‡ ä¸ªè½¯ä»¶ã€‚ first æ³¨å†Œä¸ªgithub,è¿™ä¸ªå°å­©å­ç©æ„æˆ‘å°±ä¸å’Œä½ ä»¬BBï¼Œè‡ªå·±å»æ³¨å†Œã€‚ æ³¨å†Œå¥½ååº”è¯¥æ˜¯ä¸ªè¿™æ ·çš„çJ Bæ ·å­ï¼Œç„¶ååˆ›å»ºä¸€ä¸ªä»“åº“ ä»“åº“å: _yourname_._github.oi_ è¿›å…¥setting è¿™ä¸ªæ˜¯ä½ çš„ä»“åº“åï¼Œç„¶åå‘ä¸‹æ»‘åŠ¨ã€‚ ä¸Šé¢é‚£ä¸ªç½‘å€ï¼Œå°±æ˜¯ä½ å¯ä»¥å¤–ç½‘è®¿é—®çš„ï¼Œä½ çš„æœåŠ¡å™¨å°±æ˜¯è¿™ä¸ªäº†ã€‚æˆ‘ä»¬ç°åœ¨å°±æ˜¯è¦æŠŠåšå®¢æ”¾ä¸Šå»ã€‚ åœ¨è¿™ä¸ªåœ°æ–¹é‡åˆ°äº†å‡ ä¸ªé”™è¯¯ 1cd ~/.ssh è¿™ä¸ªæŒ‡ä»¤è¿›å…¥ssh,å¦‚æœæ˜¾ç¤ºæ²¡æœ‰è¿™ä¸ªæ–‡ä»¶å¤¹ï¼Œé‚£å°±ç›´æ¥åˆ›å»ºæ–‡ä»¶å¤¹BLOG åé¢å°±æ˜¯ç”¨æ¥æ”¾åšå®¢æ–‡ä»¶çš„ è¿›å…¥æ–‡ä»¶å¤¹ï¼Œå³å‡»ï¼Œgit bashï¼Œ(é€šè¿‡cmd,power shell å‘½ä»¤è¡Œè¿›å…¥ä¹Ÿæ˜¯ä¸€æ ·çš„) åœ¨å‘½ä»¤è¡Œä¸­è¾“å…¥æŒ‡ä»¤ hexo init åˆå§‹åŒ–ã€‚ 1hexo init è¾“å…¥npm installï¼Œå®‰è£…æ‰€éœ€è¦çš„ç»„ä»¶ 1npm install ç„¶åè¾“å…¥ hexo -g é™æ€éƒ¨ç½² 1hexo g å·®ä¸å¤šå°±æ˜¯è¿™ä¸ªæ ·å­ï¼Œè¿™ä¸ªæ—¶å€™ åšå®¢å·²ç»å¯ä»¥è®¿é—®äº†ã€‚ è¦çœ‹ä¸€ä¸‹çš„è¯è¾“å…¥ hexo s æœåŠ¡å™¨å¯åŠ¨ 1hexo s ç„¶åä½ è¾“å…¥ä¸€ä¸‹ http://localhost:4000/ å°±å¯ä»¥çœ‹ä¸€ä¸‹ localhost æ˜¯æœ¬æœºçš„åœ°å€ ï¼Œç«¯å£æ˜¯ 4000 å¦‚æœ 4000 ç«¯å£è¢«ç”¨äº†çš„è¯å¯ä»¥æ¢ä¸€ä¸ªç«¯å£ã€‚ hexo server -p ç«¯å£å· æŒ‡ä»¤æ˜¯è¿™ä¸ªï¼Œå‘ç”Ÿä»€ä¹ˆæˆ‘å°±ä¸æˆªå›¾äº†ã€‚ åº”è¯¥æ˜¯è¿™ä¸ªæ ·å­ã€‚ çœ‹å®Œä¹‹åctrl +c åœæ­¢è¿è¡ŒæœåŠ¡å™¨ã€‚ ã€‚ ä¸‹ä¸€æ­¥å°±æ˜¯æŠŠè¿™ä¸ªç½‘é¡µä¼ åˆ°github ä¸Šå»ã€‚ ä¸ºäº†æ–¹ä¾¿æˆ‘ä»¬å»ºä¸€ä¸ª ssh gitä½¿ç”¨httpsåè®®ï¼Œæ¯æ¬¡pull,pushéƒ½è¦è¾“å…¥å¯†ç ï¼Œä½¿ç”¨gitåè®®ï¼Œä½¿ç”¨sshç§˜é’¥ï¼Œå¯ä»¥çœå»æ¯æ¬¡è¾“å¯†ç  ä¸€ã€æœ¬åœ°ç”Ÿæˆå¯†é’¥å¯¹ï¼› äºŒã€è®¾ç½®githubä¸Šçš„å…¬é’¥ï¼› cd ~/.ssh ssh-keygen -t rsa -C â€œä½ åˆ›å»ºé‚£ä¸ªgithubçš„é‚®ç®±â€ 12 cd ~/.sshssh-keygen -t rsa -C &quot;3035536707@qq.com&quot; è¿ç»­ä¸‰ä¸ªå›è½¦ï¼Œç”Ÿæˆå¯†é’¥ï¼Œæœ€åå¾—åˆ°äº†ä¸¤ä¸ªæ–‡ä»¶ï¼šid_rsaå’Œid_rsa.pubï¼ˆé»˜è®¤å­˜å‚¨è·¯å¾„æ˜¯ï¼šC:\Users\Administrator.ssh ï¼‰æ‰¾ä¸åˆ°å°±ç”¨æœç´¢ã€‚ å¦‚æœæ˜¾ç¤ºæ²¡æœ‰è¿™ä¸ªæ–‡ä»¶å¤¹ï¼Œå°±å…ˆåˆ›å»ºï¼Œå†è¿›å…¥ï¼Œå°±æ˜¯æŠŠä¸¤ä¸ªæŒ‡ä»¤æ¢ä¸€ä¸‹è¾“å…¥ã€‚ ç”¨è®°äº‹æœ¬æ‰“å¼€è¿™ä¸ª ç„¶åæŠŠé‡Œé¢çš„ä¸œè¥¿å¤åˆ¶ä¸€ä¸‹ï¼Œåº”è¯¥æ˜¯ä¸€å¤§å †çœ‹ä¸æ‡‚çš„ä¸œè¥¿ã€‚ ç„¶åå°±æ”¾åˆ°githubä¸Šã€‚ æµ‹è¯•ï¼š åœ¨ç»ˆç«¯ ssh -T git@github.com æ·»åŠ å¥½å é‡æ–°å›åˆ°ä½ åˆ›å»ºçš„æ–‡ä»¶å¤¹ã€‚ æ–‡æœ¬ç¼–è¾‘ä¸€ä¸‹è¿™ä¸ªæ–‡ä»¶ 1234deploy: type: git repository: git@github.com:ETBUBBLE/ETBUBBLE.github.io.git branch: master ä½ çš„ä»“åº“åœ°å€å°±æ˜¯æ˜¯è¿™ä¸ª è¿™ä¸ªæ˜¯ä½ å‰é¢çœ‹è¿‡çš„é‚£ä¸ªç©æ„ï¼Œå¦‚æœæ²¡æœ‰è®¾ç½®ä¼šå‡ºå•¥é—®é¢˜è‡ªå·±å»è¯•è¯•ã€‚ ç„¶åé‡æ–°å›åˆ°å‘½ä»¤è¡Œï¼Œè¿›å…¥ BLOG æ–‡ä»¶å¤¹ åœ¨ç”Ÿæˆä»¥åŠéƒ¨ç½²æ–‡ç« ä¹‹å‰ï¼Œéœ€è¦å®‰è£…ä¸€ä¸ªæ‰©å±• ç„¶åè¾“å…¥ hexo clean hexo d -g 12 hexo cleanhexo d -g ä¼ åˆ°ä»“åº“å»å°±å¯ä»¥äº†ã€‚ ç„¶åå°±å†ä¹Ÿæ²¡æœ‰ç„¶åäº†ã€‚ hexo new post â€œä½ çš„åšå®¢å†…å®¹â€ å°±å¯ä»¥å‘é€å‡ºå»äº†ã€‚ ä¸€ä¸ªåšå®¢å°±æ­å¥½äº†ï¼Œæ˜¯ä¸æ˜¯ç‰¹åˆ«ç®€å•ã€‚ è¡¥å……ç»‘å®šåŸŸå å»åŸŸåè§£æä¸Šé¢æ·»åŠ è§£æã€‚ ç„¶åå†åœ¨è‡ªå·±çš„githubä»“åº“é‡Œé¢æ–°å»ºä¸€ä¸ªCNAMEæ–‡ä»¶ï¼Œæ²¡æœ‰åç¼€ é‡Œé¢å†™ä¸Šä½ çš„åŸŸåã€‚ 1www.etbubble.xyz å†å»sourceåˆ›å»ºä¸€ä¸ªCNAMEæ–‡ä»¶å’Œä¸Šé¢ä¸€æ ·]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeCraft-19 and Codeforces Round 537 (Div. 2)]]></title>
    <url>%2F2019%2F02%2F04%2FCodeCraft-19%20and%20Codeforces%20Round%20537%20(Div.%202)%2F</url>
    <content type="text"><![CDATA[å¯¹äºè¿™ä¸€åœºæˆ‘æ˜¯å†…å¿ƒå´©æºƒçš„0.0 A. Superhero Transformation æˆ‘ç‰¹ä¹ˆé†‰äº†ï¼Œæ²¡ä»»ä½•éš¾åº¦ï¼Œä½†æ˜¯æˆ‘æ•°ç»„å¼€å°äº†ï¼Œå°‘æ‰“äº†ä¸€ä¸ª0.ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚è¢«fst. 123456789101112131415161718192021222324252627 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;const int maxn=1e7+5;int k[1000];int main() &#123; k[&apos;a&apos;]=1; k[&apos;e&apos;]=1; k[&apos;i&apos;]=1; k[&apos;o&apos;]=1; k[&apos;u&apos;]=1; char s[2000],t[2000]; cin&gt;&gt;s&gt;&gt;t; int l=strlen(s),l2=strlen(t),flag=1; if(l==l2) &#123; for(int i=0; i&lt;l; i++) &#123; if(k[s[i]]!=k[t[i]])flag=0; &#125; &#125; else flag=0; puts(flag?&quot;YES&quot;:&quot;NO&quot;); return 0;&#125; B. Average Superhero Gang Power ç›´æ¥ç®—å°±è¡Œäº†ï¼Œç„¶è€Œæˆ‘è¿˜æ˜¯é”™äº†ã€‚ç›´æ¥æšä¸¾åˆ é™¤æœ€å°çš„ mä¸ªã€‚ 12345678910111213141516171819202122232425 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;const int maxn=1e5+5;int kk[maxn];int main() &#123; LL n,k,m; LL ans=0; cin&gt;&gt;n&gt;&gt;k&gt;&gt;m; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d&quot;,&amp;kk[i]); ans+=kk[i]; &#125; sort(kk,kk+n); double res=0; for(int i=0; i&lt;=min(m,n-1); i++) &#123; res=max(res,(double)(min((n-i)*k,m-i)+ans)/(n-i)); ans-=kk[i]; &#125; printf(&quot;%.10f\n&quot;,res); return 0;&#125; C. Creative Snap è¿™é¢˜å¥½äº†ï¼Œç»ˆäºæ²¡æœ‰fstäº†ï¼Œç„¶è€Œè¿™é¢˜æ‰æ˜¯æœ€å´©æºƒçš„ï¼Œä¸€å¼€å§‹å°±æƒ³åˆ°äº†dfs,æƒ³äº†ä¸€ä¸‹å¤æ‚åº¦ä¸è¡Œï¼Œä¸è¡Œä½ å¦¹å•Šï¼Œç„¶åå‘ç°å¯ä»¥ï¼Œç„¶åè®¡ç®—åœ¨åŒºé—´ [l,r]ä¹‹é—´æœ‰å¤šå°‘ä¸ªæ•°ï¼Œæˆ‘ç¬¬ä¸€ä¸ªæƒ³åˆ°äº†æš´åŠ›ï¼Œæˆ‘ç‰¹ä¹ˆæƒ³æŠŠè‡ªå·±ç»™æ‹æ­»ï¼ŒäºŒåˆ†ä¸è¡Œå—ï¼ŒäºŒåˆ†ä¸è¡Œå—ï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿæˆ‘å¾—å›åˆ°ä»Šå¤©å‡Œæ™¨å»æŠŠè‡ªå·±æ‹æ­»ã€‚ 1234567891011121314151617181920212223242526272829303132 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; p;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;const int maxn=1e5+5;int n,k,a,b;LL d[maxn];LL dfs(LL l, LL r,LL i,LL j,LL cnt) &#123; if(cnt&lt;=0) &#123; return a; &#125; else &#123; LL mid=(l+r)/2; LL a1=cnt*(r-l+1)*b; LL pos=upper_bound(d+i,d+j+1,mid)-d; if(r-l==0)return a1; return min(a1,dfs(l,mid,i,pos-1,pos-i)+dfs(mid+1,r,pos,j,j-pos+1)); &#125;&#125;int main() &#123; scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;k,&amp;a,&amp;b); for(int i=0; i&lt;k; i++) &#123; scanf(&quot;%d&quot;,&amp;d[i]); &#125; sort(d,d+k); LL ans=0; ans=dfs(1LL,1&lt;&lt;n,0LL,k-1,k); printf(&quot;%lld\n&quot;,ans); return 0;&#125; æœ€ç»ˆæ‰åˆ†ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚åŸè°…æˆ‘çš„èœã€‚]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCPC-Wannafly Winter Camp Day2 E]]></title>
    <url>%2F2019%2F02%2F01%2FCCPC-Wannafly%20Winter%20Camp%20Day2%20E%2F</url>
    <content type="text"><![CDATA[Power of Function è¿™ä¸ªé¢˜é‡ç‚¹æ˜¯è¯»é¢˜ã€‚çœ‹æ‡‚å‡½æ•°ï¼Œå‡½æ•°æœ€ç»ˆè¡¨ç¤ºçš„æ˜¯ n å†™æˆKè¿›åˆ¶ï¼ŒKè¿›åˆ¶çš„å€¼çš„å’ŒåŠ ä¸Šé•¿åº¦ -2 å°±æ˜¯mã€‚ ç»™ä½ ä¸€ä¸ª ï¼Œk,l,r,æ±‚Kè¿›åˆ¶ä¸‹ï¼Œ[l,r]åŒºé—´å†…mçš„æœ€å¤§å€¼ã€‚ç„¶åè¾“å‡ºå½“mæœ€å¤§æ—¶[l,r]åŒºé—´æœ€å¤§å€¼å’Œæœ€å°å€¼ã€‚ é¢˜è§£ï¼šæŠŠl,rè½¬æ¢æˆKè¿›åˆ¶ï¼Œ r&gt;lï¼Œå¦‚æœr,l,é«˜ä½ç›¸åŒï¼Œé‚£ä¹ˆæ±‚å¾—åˆ°æœ€å¤§å€¼Mé«˜ä½è‚¯å®šä¹Ÿæ˜¯å’Œè¿™ä¸ªå€¼ä¸€æ ·ã€‚ç„¶åä»ç¬¬ä¸€ä¸ªä½ä¸åŒå¼€å§‹ï¼Œæƒ³è®©Må€¼æœ€å¤§ï¼Œåªæœ‰ä¸¤ç§å¯èƒ½ï¼Œä¸€ç§æ˜¯å–rè¿™ä¸ªå€¼äºŒè¿›åˆ¶ä¸‹ä½å‡ä¸€ï¼Œç„¶ååé¢ä½çš„å…¨éƒ¨å– k-1,æˆ–è€…è¿™ä¸ªä½å–æœ€å¤§å€¼å†ç»§ç»­è®¨è®ºä¸‹ä¸€ä¸ªä½ã€‚å†™ä¸ªDFSå°±å¯ä»¥ï¼Œå’Œæ•°ä½DPæœ‰ç‚¹åƒã€‚ ä¸¾ä¸ªä¾‹å­ ï¼šk=10 ,l=1001,r=1179. 10è¿›åˆ¶ä¸‹ l = 1 0 0 1 r = 1 1 7 9 æœ€å‰é¢ 1 å’Œ 1 æ˜¯ç›¸åŒçš„æ‰€ä»¥è¦ mæœ€å¤§ è‚¯å®š æœ€é«˜ä½ä¹Ÿæ˜¯ 1 b=1 0 0 0 ç„¶åä»ç¬¬3ä½å¼€å§‹dfs(3) è¦ä¹ˆè¿™ä¸ªä½å– 1ï¼Œ è¦ä¹ˆ å– 0 åæ…¢æ…¢å…¨å– 9ï¼Œ å¦‚æœè¿™ä¸ªä½ å– 1 å°±ä¼šå½±å“ä¸‹ä¸€ä¸ªä½ï¼Œæ‰€ä»¥å†DFSï¼ˆ2ï¼‰ ç„¶åå‘ç° è¦ä¹ˆå–7 ï¼Œï¼ˆè¦ä¹ˆ å– 6 åé¢å…¨ä¸º9ï¼‰ ä»¥æ­¤ç±»æ¨ï¼Œæœ€åå‘ç° åé¢3ä¸º 179 099 å–å¾— åé¢æ¯”è¾ƒå¤§ï¼Œé‚£ä¹ˆmå–æœ€å¤§å°±æ˜¯ 1099ï¼› è¿˜æœ‰ä¸€äº›ç»†èŠ‚è¦æ³¨æ„ï¼Œæ¯”å¦‚ 179 ï¼Œ99æ˜¯ä¸€æ ·æ‰“çš„ï¼Œå› ä¸º99åªæœ‰ä¸¤ä½æ•°ã€‚è¿˜æœ‰ 0 æ˜¯æ²¡æœ‰ æ¯”ä»–å°1è¿™ä¸ªæ•°ï¼Œå¦‚æœè¦å°1å°±è¦å‘é«˜ä½å€Ÿï¼Œæ‰€ä»¥è¿™æƒ…å†µè¦æ’é™¤ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;int t;LL k,l,r;vector&lt;LL&gt; v1,v2,mi,mx;LL p[2000];LL dfs(LL pos,bool limit) &#123; if(pos==-1)return 0; if(limit) &#123; LL m1,m2; m1=dfs(pos-1,1); m2=dfs(pos-1,0); m1+=v2[pos]; m2+=v2[pos]-1; if(v2[pos]==0)m2=-1; //æ’é™¤ ä¸º r posä½ ä¸º0æƒ…å†µ if(pos==v2.size()-1&amp;&amp;v2[pos]==1)m2--; // æœ€é«˜ä½ä¸º 0 m2è¦å‡ä¸€ if(m1&gt;m2) &#123; mx[pos]=mi[pos]=v2[pos]; return m1; &#125; else if(m1==m2) &#123; mx[pos]=v2[pos]; mi[pos]=v2[pos]-1; for(int i=0; i&lt;pos; i++) &#123; mi[i]=k-1; &#125; return m2; &#125; else &#123; mx[pos]=mi[pos]=v2[pos]-1; for(int i=0; i&lt;pos; i++) &#123; mi[i]=mx[i]=k-1; &#125; return m2; &#125; &#125; else &#123; return (k-1)*(pos+1); &#125;&#125;int cas=1;int main() &#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%lld%lld%lld&quot;,&amp;k,&amp;l,&amp;r); v1.clear(); v2.clear(); LL x=r; while(x&gt;0) &#123; v2.push_back(x%k); x/=k; &#125; x=l; while(x&gt;0) &#123; v1.push_back(x%k); x/=k; &#125; while(v1.size()&lt;v2.size()) &#123; v1.push_back(0); &#125; p[0]=1; for(int i=1; i&lt;v2.size(); i++) &#123; p[i]=p[i-1]*k; &#125; int pos=v2.size()-1; mi.resize(v2.size()); mx.resize(v2.size()); while(pos&gt;=0) &#123; if(v1[pos]==v2[pos]) &#123; mi[pos]=mx[pos]=v2[pos]; &#125; else break; pos--; &#125; if(pos!=-1)dfs(pos,1); LL a=0,b=0,m=0,flag=1; for(int i=mx.size()-1; i&gt;=0; i--) &#123; m+=mx[i]; if(mx[i]!=0)flag=0; if(flag)m--; b+=mx[i]*p[i]; a+=mi[i]*p[i]; &#125; m=m+mx.size()-2; printf(&quot;Case #%d: %lld %lld %lld\n&quot;,cas++,m,a,b); &#125; return 0; //çœ‹ä¸æ‡‚ç•™è¨€0.0ï¼Œæˆ–è€…åŠ Q3035536707&#125;]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 CCPC-Wannafly Winter Camp Day2ï¼ˆDiv2ï¼‰]]></title>
    <url>%2F2019%2F01%2F28%2F2019%20CCPC-Wannafly%20Winter%20Camp%20Day2%EF%BC%88Div2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Camp çš„é¢˜æ˜¯çœŸçš„éš¾ï¼Œè¿˜å¥½æ²¡å»ï¼Œä¸ç„¶è¦è¢«è¡€è™ã€‚ åšäº†Day2çš„å‡ é“é¢˜ã€‚ Aé¢˜ï¼ŒErase Numbers II è¿™ä¸ªæŒºç®€å•çš„ï¼Œå°±æ˜¯èŒƒå›´ç‚¸äº†long long ,æš´åŠ›æšä¸¾ä¸¤ä¸ªæ•°å°±è¡Œäº†ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;//typedef long long LL;typedef unsigned long long LL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=6e3+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;int t,n;LL a[maxn],m1=0,ans1,ans2;LL k(LL x,LL y)&#123; LL k=x; while(k&gt;0)&#123; k/=10; y*=10; &#125; return y+x;&#125;int main() &#123; scanf(&quot;%d&quot;,&amp;t); int cas=1; while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); m1=0; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;a[i]; &#125; ans1=ans2=0; for(int i=0;i&lt;n;i++)&#123; for(int j=i+1;j&lt;n;j++)ans1=max(ans1,k(a[j],a[i])); &#125; printf(&quot;Case #%d: &quot;,cas++); cout&lt;&lt;ans1&lt;&lt;endl; &#125; return 0;&#125; Bé¢˜ï¼šErase Numbers I é¢˜æ„ï¼šåˆ é™¤ä¸¤ä¸ªæ•°ï¼Œæœ€åè¿èµ·æ¥çš„æ•°å­—ç»“æœæœ€å¤§ã€‚ è¿™é¢˜æš´åŠ›è¿‡äº†ï¼Œå®é™…ä¸Šæš´åŠ›æ˜¯è¿‡ä¸äº†ï¼Œæœ¬æ¥è¦é¢„å¤„ç†ä¸€ä¸‹ï¼Œåˆ é™¤ä¸€ä¸ªé•¿åº¦ä¸º Lçš„æ•°å­—ä¸²ï¼Œç¬¬ä¸€ä¸ªä¸åŒçš„æ•°å­—çš„ä½ç½®ï¼Œ æ¯”å¦‚ï¼š12 55 58 åˆ é™¤ç¬¬äºŒä¸ª å­—ç¬¦ä¸²çš„æ—¶å€™ï¼Œ ä¼šå˜æˆ 1258ï¼Œå’ŒåŸå­—ç¬¦ä¸² 125558 å­—ç¬¦æ˜¯ 5 å’Œ8 ä¸åŒï¼ˆè¿™ä¸ªåœ°æ–¹åªæ˜¯ä¸¾ä¾‹è¯´æ˜åˆ ä¸€ä¸ªå­—ç¬¦ä¸²ï¼‰ ä½†æ˜¯å‡ºé¢˜äººå¥½åƒæ²¡æœ‰ç‰¹æ„å¡ï¼Œå°±ç›´æ¥æš´åŠ›è¿‡äº† 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;//#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot;&lt;&lt;endl;const int maxn=6e3+5;int a[maxn],b[maxn],t,n,mi,a1,a2;char s[maxn*10];char c[maxn][15];bool pd(int pos) &#123; int pos2=pos+1,i=0,j=0; // å°±æ˜¯è¿™ä¸ªåœ°æ–¹è¦æœ¬æ¥æ˜¯è¦é¢„å¤„ç†çš„ï¼Œä½†æ˜¯æš´åŠ›æ¯æ¬¡æ¯”è¾ƒä¹Ÿå¯ä»¥è¿‡ while(1) &#123; if(c[pos][i]&lt;c[pos2][j]) &#123; return 1; &#125; else if(c[pos][i]&gt;c[pos2][j]) &#123; return 0; &#125; i++; j++; if(i==b[pos]) &#123; pos++; i=0; &#125; if(j==b[pos2]) &#123; pos2++; j=0; &#125; if(pos2==n)return 1; &#125;&#125;bool pd2(int pos) &#123; int pos2=pos+1,i=0,j=0; while(1) &#123; if(pos==a1)pos++; if(pos2==a1)pos2++; if(c[pos][i]&lt;c[pos2][j]) &#123; return 1; &#125; else if(c[pos][i]&gt;c[pos2][j]) &#123; return 0; &#125; i++; j++; if(i==b[pos]) &#123; pos++; i=0; &#125; if(j==b[pos2]) &#123; pos2++; j=0; &#125; if(pos2==n)return 1; &#125;&#125;int main() &#123; scanf(&quot;%d&quot;,&amp;t); int cas=1; while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); mi=100; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%s&quot;,c[i]); b[i]=strlen(c[i]); a[i]=0; for(int j=0; j&lt;b[i]; j++) &#123; a[i]=a[i]*10+c[i][j]-&apos;0&apos;; &#125; mi=min(mi,b[i]); &#125; a1=-1; for(int i=0; i&lt;n; i++) &#123; if(b[i]==mi) &#123; if(pd(i)) &#123; a1=i; break; &#125; &#125; &#125; if(a1==-1) &#123; for(int i=n-1; i&gt;=0; i--) &#123; if(b[i]==mi) &#123; a1=i; break; &#125; &#125; &#125; mi=100; a2=-1; for(int i=0; i&lt;n; i++) &#123; if(i==a1)continue; mi=min(b[i],mi); &#125; for(int i=0; i&lt;n; i++) &#123; if(i==a1)continue;; if(b[i]==mi) &#123; if(pd2(i)) &#123; a2=i; break; &#125; &#125; &#125; if(a2==-1) &#123; for(int i=n-1; i&gt;=0; i--) &#123; if(i==a1)continue; if(b[i]==mi) &#123; a2=i; break; &#125; &#125; &#125; printf(&quot;Case #%d: &quot;,cas++); for(int i=0; i&lt;n; i++) &#123; if(i==a1||a2==i)continue; printf(&quot;%d&quot;,a[i]); &#125; puts(&quot;&quot;); &#125; return 0;&#125; Hé¢˜ï¼šCosmic Cleaner é¢˜æ„ï¼šé—®åˆ é™¤çš„çƒå’ŒåŸæ¥ç»™çš„è¿™äº›çƒç›¸äº¤çš„ä½“ç§¯æœ‰å¤šå°‘ã€‚ è´´ä¸ªæ±‚çƒç›¸äº¤çš„ä½“ç§¯æ¿å­å°±è¡Œäº†0.0. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889 #include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#define CLR(a,b) memset(a,b,sizeof(a));using namespace std;const double PI = acos(-1);const int maxn= 105;typedef struct point &#123; double x,y,z; point() &#123; &#125; point(double a, double b,double c) &#123; x = a; y = b; z = c; &#125; point operator -(const point &amp;b)const &#123; //è¿”å›å‡å»åçš„æ–°ç‚¹ return point(x - b.x, y - b.y,z-b.z); &#125; point operator +(const point &amp;b)const &#123; //è¿”å›åŠ ä¸Šåçš„æ–°ç‚¹ return point(x + b.x, y + b.y,z+b.z); &#125; //æ•°ä¹˜è®¡ç®— point operator *(const double &amp;k)const &#123; //è¿”å›ç›¸ä¹˜åçš„æ–°ç‚¹ return point(x * k, y * k,z*k); &#125; point operator /(const double &amp;k)const &#123; //è¿”å›ç›¸é™¤åçš„æ–°ç‚¹ return point(x / k, y / k,z/k); &#125; double operator *(const point &amp;b)const &#123; //ç‚¹ä¹˜ return x*b.x + y*b.y+z*b.z; &#125;&#125; point;double dist(point p1, point p2) &#123; //è¿”å›å¹³é¢ä¸Šä¸¤ç‚¹è·ç¦» return sqrt((p1 - p2)*(p1 - p2));&#125;typedef struct sphere &#123;//çƒ double r; point centre;&#125; sphere;sphere s,a[maxn];void SphereInterVS(sphere a, sphere b,double &amp;v,double &amp;s) &#123; double d = dist(a.centre, b.centre);//çƒå¿ƒè· double t = (d*d + a.r*a.r - b.r*b.r) / (2.0 * d);// double h = sqrt((a.r*a.r) - (t*t)) * 2;//h1=h2ï¼Œçƒå† çš„é«˜ double angle_a = 2 * acos((a.r*a.r + d*d - b.r*b.r) / (2.0 * a.r*d)); //ä½™å¼¦å…¬å¼è®¡ç®—r1å¯¹åº”åœ†å¿ƒè§’ï¼Œå¼§åº¦ double angle_b = 2 * acos((b.r*b.r + d*d - a.r*a.r) / (2.0 * b.r*d)); //ä½™å¼¦å…¬å¼è®¡ç®—r2å¯¹åº”åœ†å¿ƒè§’ï¼Œå¼§åº¦ double l1 = ((a.r*a.r - b.r*b.r) / d + d) / 2; double l2 = d - l1; double x1 = a.r - l1, x2 = b.r - l2;//åˆ†åˆ«ä¸ºä¸¤ä¸ªçƒç¼ºçš„é«˜åº¦ double v1 = PI*x1*x1*(a.r - x1 / 3);//ç›¸äº¤éƒ¨åˆ†r1åœ†æ‰€å¯¹åº”çš„çƒç¼ºéƒ¨åˆ†ä½“ç§¯ double v2 = PI*x2*x2*(b.r - x2 / 3);//ç›¸äº¤éƒ¨åˆ†r2åœ†æ‰€å¯¹åº”çš„çƒç¼ºéƒ¨åˆ†ä½“ç§¯ v = v1 + v2;//ç›¸äº¤éƒ¨åˆ†ä½“ç§¯ double s1 = PI*a.r*x1; //r1å¯¹åº”çƒå† è¡¨é¢ç§¯ double s2 = PI*a.r*x2; //r2å¯¹åº”çƒå† è¡¨é¢ç§¯ s = 4 * PI*(a.r*a.r + b.r*b.r) - s1 - s2;//å‰©ä½™éƒ¨åˆ†è¡¨é¢ç§¯&#125;int t, n;double x, y, z, r;int cas = 1;int main() &#123; cin &gt;&gt; t; while(t--) &#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%lf%lf%lf%lf&quot;,&amp;x,&amp;y,&amp;z,&amp;a[i].r); //å…¶ä»–çƒ a[i].centre = &#123;x,y,z&#125;; &#125; scanf(&quot;%lf%lf%lf%lf&quot;,&amp;x,&amp;y,&amp;z,&amp;r); s.r = r; s.centre = &#123;x,y,z&#125;; //ä¸­å¿ƒçƒ double ans = 0, v = 0; for(int i = 1; i &lt;= n; i++) &#123; double ss, dis = dist(s.centre, a[i].centre); if(dis &gt;= s.r + a[i].r)continue; //åœ¨å¤–éƒ¨ if(dis + min(s.r, a[i].r) &lt;= max(s.r, a[i].r)) &#123; //åœ¨å†…éƒ¨ ans += 4.0 / 3.0 * PI * min(s.r,a[i].r) * min(s.r,a[i].r) * min(s.r,a[i].r); continue; &#125; SphereInterVS(s, a[i], v, ss); //ç›¸äº¤éƒ¨åˆ† ans += v; &#125; printf(&quot;Case #%d: %.14f\n&quot;,cas++,ans); &#125;&#125;//æœç´¢æ¿å­ï¼Œæœåˆ°çš„ä¸€åå¤§ä½¬çš„ï¼Œæˆ‘æ”¹éƒ½æ²¡æ”¹å°±ç›´æ¥è¿‡äº†0.0 Ké¢˜ï¼šSticks é¢„å¤„ç†å‡ºæ‰€æœ‰åˆ†ç»„æƒ…å†µï¼Œä¸€å…±æ˜¯ C(3,12)C(3,9)C(3,6) /24ç§ã€‚ 15400ç§ è®©åæš´åŠ›æ±‚è§£ 15400*6000ç«Ÿç„¶åˆ¤æ–­è¿‡äº†0.0 é¢˜ç›®æ²¡è¯´è¦æ€ä¹ˆè¾“å‡ºç­”æ¡ˆï¼Œç„¶åæˆ‘ç”¨SET é”™äº†ï¼Œç”¨vector è¿‡äº†ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot;&lt;&lt;endl;const int maxn=369605;int a[20];struct th &#123; short x[4][3]; bool operator&lt;(const th&amp; t) const &#123; &#125;&#125; dat,pa[maxn];int u[20],k=0;void dfs(int p) &#123; if(p==4) &#123; pa[k]=dat; k++; return ; &#125; for(int i=0; i&lt;12; i++) &#123; if(u[i])continue; if(dat.x[p-1][0]&gt;i)continue; //è¿™ä¸ªæ˜¯å»é‡çš„ï¼Œä¼šæœ‰é‡å¤çš„æƒ…å†µ for(int i2=i+1; i2&lt;12; i2++) &#123; if(u[i2])continue; for(int i3=i2+1; i3&lt;12; i3++) &#123; if(u[i3])continue; dat.x[p][0]=i; dat.x[p][1]=i2; dat.x[p][2]=i3; u[i]=u[i2]=u[i3]=1; dfs(p+1); u[i]=u[i2]=u[i3]=0; &#125; &#125; &#125;&#125;int t,cas=1;int main() &#123; dfs(0); debug(k); scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; for(int i=0; i&lt;12; i++) scanf(&quot;%d&quot;,&amp;a[i]); int num=0,ans; for(int i=0;i&lt;k;i++) &#123; int tnum=0; for(int j=0; j&lt;4; j++) &#123; int m1=a[pa[i].x[j][0]],m2=a[pa[i].x[j][1]],m3=a[pa[i].x[j][2]]; if(m1+m2&gt;m3&amp;&amp;m2+m3&gt;m1&amp;&amp;m3+m1&gt;m2)tnum++; &#125; if(tnum&gt;num) &#123; num=tnum; ans=i; &#125; if(num==4)break; &#125; printf(&quot;Case #%d: %d\n&quot;,cas++,num); if(num==0)continue; for(int j=0; j&lt;4; j++) &#123; int m1=a[pa[ans].x[j][0]],m2=a[pa[ans].x[j][1]],m3=a[pa[ans].x[j][2]]; if(m1+m2&gt;m3&amp;&amp;m2+m3&gt;m1&amp;&amp;m3+m1&gt;m2)&#123; printf(&quot;%d %d %d\n&quot;,m1,m2,m3); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-2019 ACM-ICPC, Asia Nanjing Regional Contest M]]></title>
    <url>%2F2019%2F01%2F23%2F2018-2019%20ACM-ICPC%2C%20Asia%20Nanjing%20Regional%20Contest%20M%2F</url>
    <content type="text"><![CDATA[2018-2019 ACM-ICPC, Asia Nanjing Regional Contest M æ‰©å±•KMP+é©¬æ‹‰è½¦å›æ–‡ä¸² s:ababa t:aba é¢˜æ„ï¼šå°†ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²çš„ä¸€ä¸ªå­—ä¸²ï¼Œä¸ç¬¬äºŒä¸ªå­—ç¬¦ä¸²ä» (0-k)çš„å­—ç¬¦è¿åœ¨ä¸€èµ·å¯ä»¥æˆä¸ºå›æ–‡å­—ç¬¦ä¸²ï¼Œä¸”ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²å­—ä¸²çš„é•¿åº¦æ¯”ç¬¬äºŒä¸ªå­—ç¬¦ä¸²çš„é•¿åº¦è¦å¤§ã€‚ è¦æ„æˆçš„çš„å›æ–‡å­—ç¬¦ä¸² ä¸¤éƒ¨åˆ†æ„æˆ sâ€™ ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²çš„å­—ä¸²ï¼Œå’Œç¬¬äºŒä¸ªå­—ç¬¦ä¸²çš„å‰ç¼€tâ€™ï¼Œæ„æˆä¸€ä¸ªå›æ–‡å­—ç¬¦ä¸²ã€‚ é‚£ä¹ˆå¦‚æœæŠŠç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²å€’è¿‡æ¥ï¼Œ é‚£å°±ç›¸å½“äºï¼Œsâ€™ çš„ä¸€éƒ¨åˆ†æ˜¯å’Œ tâ€™æ˜¯ç›¸åŒçš„ï¼Œsâ€™è¿˜æœ‰ä¸€éƒ¨åˆ†æ˜¯å›æ–‡å­—ç¬¦ä¸²ã€‚ é‚£ä¹ˆsâ€™ä¸tâ€™ç›¸åŒçš„é•¿åº¦ * ä»å½“å‰ä½ç½®èƒ½å¤Ÿäº§ç”Ÿçš„å›æ–‡ä¸²æ•°é‡ï¼Œå°±ç›¸å½“èƒ½å¤Ÿæ„æˆçš„å›æ–‡ä¸²ä¸ªæ•°ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot;&lt;&lt;endl;const int maxn=1e6+5;int nxt[maxn*2],ex[maxn*2];void getnext(char * str) &#123; int i=0,j,po,len=strlen(str); nxt[0]=len; while(i+1&lt;len&amp;&amp;str[i]==str[i+1])i++; nxt[1]=i; po=1,j=0; for(i=2; i&lt;len; i++) &#123; int p=nxt[po]+po; if(nxt[i-po]+i&lt;p) &#123; nxt[i]=nxt[i-po]; &#125; else &#123; j=p-i; if(j&lt;0)j=0; while(i+j&lt;len&amp;&amp;str[j]==str[j+i]) j++; nxt[i]=j; po=i; &#125; &#125;&#125;void exkmp(char *s1,char *s2) &#123; int i=0,j,po,len=strlen(s1),l2=strlen(s2); getnext(s2); while(s1[i]==s2[i]&amp;&amp;i&lt;l2&amp;&amp;i&lt;len)i++; ex[0]=i; po=0; for(i=1; i&lt;len; i++) &#123; int p=ex[po]+po; if(nxt[i-po]+i&lt;p) &#123; ex[i]=nxt[i-po]; &#125; else &#123; j=max(0,p-i); while(i+j&lt;len&amp;&amp;j&lt;l2&amp;&amp;s1[i+j]==s2[j]) &#123; j++; &#125; ex[i]=j; po=i; &#125; &#125;&#125;char Ma[maxn*2];int Mp[maxn*2],pos[maxn*2];int dp[maxn*2],cnt[maxn];void Manacher(char s[],int len) &#123; //ä¸€åå¤§ä½¬çš„å†™æ³•0.0 memset(pos,-1,sizeof(pos)); int l=0; Ma[l++]=&apos;$&apos;; Ma[l++]=&apos;#&apos;; for(int i=0; i&lt;len; i++) &#123; pos[l]=i; Ma[l++]=s[i]; Ma[l++]=&apos;#&apos;; &#125; Ma[l]=0; int mx=0,id=0; for(int i=0; i&lt;l; i++) &#123; Mp[i]=mx&gt;i?std::min(Mp[2*id-i],mx-i):1; while(i-Mp[i]&gt;=0&amp;&amp;Ma[i+Mp[i]]==Ma[i-Mp[i]]) Mp[i]++; if(i+Mp[i]&gt;mx) &#123; mx=i+Mp[i]; id=i; &#125; &#125; for(int i=0; i&lt;l; i++) &#123; dp[i+Mp[i]-1]++; if(i&gt;0) dp[i-1]--; &#125; for(int i=l-1; i&gt;=0; i--) &#123; dp[i]+=dp[i+1]; &#125; for(int i=0; i&lt;l; i++) &#123; if(pos[i]==-1) continue; cnt[pos[i]]=dp[i]; &#125;&#125;char s[maxn],c[maxn];int main() &#123; scanf(&quot;%s%s&quot;,s,c); int len=strlen(s); reverse(s,s+len); Manacher(s,len); exkmp(s,c); LL ans=0; for(int i=1; i&lt;len; i++) &#123; ans+=1LL*cnt[i-1]*ex[i]; &#125; printf(&quot;%lld\n&quot;,ans); return 0;&#125;]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF201812 JAVA]]></title>
    <url>%2F2019%2F01%2F16%2FCCF201812%20JAVA%2F</url>
    <content type="text"><![CDATA[å‘ç°JAVAæ¯”C++æ…¢äº†ä¸æ­¢ä¸€æ˜ŸåŠç‚¹ C++èƒ½ç›´æ¥è¿‡ï¼Œè¿™ä¸ªJAVAå¡æé™è¿‡äº† ç¬¬ä¸€äºŒé¢˜ï¼Œéšä¾¿å†™ä¸€ä¸‹æ²¡å•¥éš¾åº¦ï¼Œç›´æ¥å†™ç¬¬4é¢˜çš„ä»£ç  CCF201812-4123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner input=new Scanner(System.in); int n,m,r; n=input.nextInt(); m=input.nextInt(); r=input.nextInt(); Point arr[]=new Point[m]; for(int i=0;i&lt;m;i++) arr[i]=new Point(); for(int i=0;i&lt;m;i++)&#123; arr[i].x=input.nextInt(); arr[i].y=input.nextInt(); arr[i].c=input.nextInt(); &#125; Arrays.sort(arr, new MyComprator()); int ans=0; int k=0; int []par=new int[m+1]; for(int i=1;i&lt;=m;i++)par[i]=i; for(int i=0;i&lt;m;i++)&#123; int x=find(arr[i].x,par),y=find(arr[i].y,par); if(x!=y) &#123; par[x] = y; ans = arr[i].c; k++; &#125; if(k==n-1)break; &#125; System.out.println(ans); &#125; static int find(int x,int[] par)&#123; return x==par[x] ? x : (par[x]=find(par[x],par)); &#125;&#125;class Point&#123; int x,y,c;&#125;class MyComprator implements Comparator &#123; public int compare(Object arg0, Object arg1) &#123; Point t1=(Point)arg0; Point t2=(Point)arg1; return t1.c&gt;t2.c? 1:-1; &#125;&#125;]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 528 (Div. 2, based on Technocup 2019 Elimination Round 4)]]></title>
    <url>%2F2018%2F12%2F24%2FCodeforces%20Round%20528%20(Div.%202%2C%20based%20on%20Technocup%202019%20Elimination%20Round%204)%2F</url>
    <content type="text"><![CDATA[éšæ‰‹å†™ä¸€ç¯‡åšå®¢å§0.0 A. Right-Left Cipher ç›´æ¥æ¨¡æ‹Ÿï¼Œå¶æ•°åœ¨å·¦è¾¹ï¼Œå¥‡æ•°åœ¨å³è¾¹ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;char s[maxn],t[maxn];int main() &#123; cin&gt;&gt;t; int l=strlen(t); int k=l-1; if(l&amp;1)k++; for(int i=0; i&lt;(l+1)/2; i++) &#123; s[k]=t[i]; k-=2; &#125; k=2; for(int i=(l+1)/2; i&lt;l; i++) &#123; s[k]=t[i]; k+=2; &#125; for(int i=1; i&lt;=l; i++)printf(&quot;%c&quot;,s[i]); return 0;&#125; B. Div Times Mod ç›´æ¥æš´åŠ›æšä¸¾å•Šï¼Œä¸å°±æ˜¯ a*k+b=x b=n/a,ç›´æ¥æš´åŠ›æšä¸¾nçš„å› å­ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;LL n,k;int main() &#123; cin&gt;&gt;n&gt;&gt;k; LL ans=inf*inf; for(LL i=1; i&lt;=n; i++) &#123; if(n%i==0&amp;&amp;n/i&lt;k) &#123; ans=min(ans,k*i+n/i); &#125; &#125; cout&lt;&lt;ans&lt;&lt;&quot;\n&quot;; return 0;&#125; C. Connect Three ç›´æ¥æƒ³è±¡æ€ä¹ˆèµ°æœ€è¿‘ï¼Œéšä¾¿çå‡ æŠŠå†™ï¼Œæ•°æ®æœ‰ç‚¹æ°´ï¼Œæˆ‘æ•°ç»„å¼€å°äº†éƒ½è¿‡äº†ï¼Œç»“æœè¢«fstäº†ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e3+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;int a[3],b[3];pair&lt;int,int&gt;p[3];int x[maxn*100],y[maxn*1000];int mp[maxn][maxn];int main() &#123; for(int i=0; i&lt;3; i++) &#123; scanf(&quot;%d%d&quot;,&amp;a[i],&amp;b[i]); p[i].first=a[i]; p[i].second=b[i]; &#125; sort(a,a+3); sort(b,b+3); sort(p,p+3); printf(&quot;%d\n&quot;,a[2]-a[0]+b[2]-b[0]+1); int x1=p[0].first,y1=p[0].second,x2=p[1].first,x3=a[2];// debug(x1);// debug(x2);// debug(x3); int k=0; for(int i=0;i&lt;=x2-x1;k++,i++)&#123; x[k]=x1+i; y[k]=y1; mp[x[k]][y[k]]=1; &#125; for(int i=0;i&lt;=b[2]-b[0];i++)&#123; if(mp[x2][b[0]+i])continue; x[k]=x2; y[k]=b[0]+i; mp[x[k]][y[k]]=1; k++; &#125; for(int i=1;i&lt;=x3-x2;i++)&#123; if(mp[x2+i][p[2].second])continue;// debug(y[0]); x[k]=x2+i; y[k]=p[2].second; k++;// debug(k); &#125; k=a[2]-a[0]+b[2]-b[0]+1; for(int i=0;i&lt;k;i++) printf(&quot;%d %d\n&quot;,x[i],y[i]); return 0;&#125; D. Minimum Diameter Tree ç›´å¾„æ˜¯é€šè¿‡æƒå€¼åˆ†é…æ¥æå®šçš„ï¼Œè¦ç›´å¾„æœ€å¤§å€¼æœ€å°ã€‚ç›´å¾„æœ€å¤§å€¼è‚¯å®šæ˜¯ä»æ¯ä¸€ä¸ªå¶å­èµ°åˆ°å¦ä¸€ä¸ªå¶å­ï¼Œæ‰€ä»¥ç›´æ¥ç®—æœ‰å¤šå°‘ä¸ªå¶å­ï¼Œç­”æ¡ˆå°±æ˜¯s*2.0/(å¶å­æ•°é‡)ã€‚ä»»æ„ä¸¤ä¸ªå¶å­ä¹‹é—´çš„è·ç¦»ç›¸åŒï¼Œå°±æ˜¯æœ€å°ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;vector&lt;int&gt; G[maxn];int pre[maxn],in[maxn];int k[maxn],u[maxn];int main() &#123; int n; double s; scanf(&quot;%d%lf&quot;,&amp;n,&amp;s); for(int i=0; i&lt;n-1; i++) &#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); in[a]++; in[b]++; G[a].push_back(b); G[b].push_back(a); &#125; double ans=0; for(int i=1; i&lt;=n; i++) &#123; if(in[i]==1) &#123; ans+=1; &#125; &#125; printf(&quot;%.10f&quot;,s*2.0/ans); return 0;&#125;]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 526 (Div. 2)]]></title>
    <url>%2F2018%2F12%2F13%2FCodeforces%20Round%20526%20(Div.%202)%2F</url>
    <content type="text"><![CDATA[å¾ˆä¹…æ²¡å†™ä»£ç äº†ã€‚éšä¾¿åˆ·äº†ä¸€ä¸‹CF C. The Fair Nut and String å…ˆç»Ÿè®¡ä¸€ä¸‹è¢«â€™bâ€™åˆ†éš”çš„â€˜aâ€™æœ‰å¤šå°‘ä¸ªï¼Œæ”¾åˆ°ä¸€ä¸ªæ•°ç»„é‡Œé¢ï¼Œæ¯”å¦‚è¯´ï¼Œababaaba a[0]=1,a[1]=1,a[2]=2,a[3]=1; ç„¶åç®—ä¸€ä¸‹æ€»æ–¹æ¡ˆæ•°ï¼Œè¿™ä¸ªæœ‰ç‚¹éš¾è§£é‡Šï¼Œå°±æ˜¯å–è¿™ä¸ªä¹‹å‰æ‰€æœ‰çš„æ–¹æ¡ˆæ•°*è¿™ä¸ªé‡Œé¢çš„ä¸ªæ•°ï¼Œå†åŠ ä¸Šåªå–è¿™ä¸ªé‡Œé¢çš„ä¸ªæ•°ã€‚ å·®ä¸å¤šå°±æ˜¯è¿™ä¹ˆç®—çš„:sum[i]=sum[i-1]*a[i]+a[i]; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;char s[maxn];LL ans[maxn];long long n,k,num,sum,ct;int main() &#123; scanf(&quot;%s&quot;,s); int l = strlen(s); k=0; ct=1; for(int i = 0 ; i &lt; l ; i ++) &#123; if(s[i]==&apos;a&apos;)&#123; n++; ct=0; &#125; if(s[i]==&apos;b&apos;)&#123; if(ct==0)ans[k++]=n; ct=1; n=0; &#125; &#125; if(!ct)ans[k++]=n; for(int i = 0 ; i &lt; k ; i++)&#123; sum+=sum*ans[i]; sum%=mod; sum+=ans[i]; sum%=mod; &#125; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125; D. The Fair Nut and the Best Path è¿™é¢˜æ˜¯ä¸ªæ ‘å½¢DPï¼Œæ¯æ¬¡é€‰æœ€è¾¹ä¸Šçš„èŠ‚ç‚¹ï¼Œå¦‚æœä¸€ä¸ªèŠ‚ç‚¹å‘¨å›´çš„èŠ‚ç‚¹åªæœ‰ä¸€ä¸ªæ²¡èµ°è¿‡äº†å°±æŠŠè¿™ä¸ªèŠ‚ç‚¹åŠ åˆ°é˜Ÿåˆ—é‡Œé¢å–åˆ¤æ–­ã€‚ å¦‚æœä½ é€‰çš„èŠ‚ç‚¹æ˜¯æœ€å¤§çš„æ²¹é‡ä¸­çš„ä¸€ä¸ªï¼Œé‚£ä¹ˆï¼Œä¸€å®šç­‰äºå‘¨å›´ä¸¤ä¸ªæœ€å¤§ä¸”å¤§äºé›¶çš„èŠ‚ç‚¹æƒ³åŠ ï¼Œä¸”åŠ ä¸Šè‡ªå·±çš„æ²¹é‡ã€‚å…·ä½“çœ‹ä»£ç å§ï¼Œç„¶ådpæ¯æ¬¡ä¿å­˜åˆ°è¿™ä¸ªèŠ‚ç‚¹æœ€å¤§æ²¹é‡ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,in[maxn];LL w[maxn],ans,dp[maxn];int used[maxn];struct two &#123; LL to,c;&#125;;int k;vector&lt;two&gt; G[maxn];int main() &#123; scanf(&quot;%d&quot;,&amp;n); for(int i = 1 ; i &lt;= n ; i ++) &#123; scanf(&quot;%lld&quot;,&amp;w[i]); &#125; two t; for(int i = 0 ; i &lt; n-1; i++) &#123; int u,v,c; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;c); t.c=c; t.to=v; G[u].push_back(t); t.to=u; G[v].push_back(t); in[u]++; in[v]++; &#125; queue&lt;int&gt;q; for(int i = 1 ; i &lt;= n ; i++) &#123; if(in[i]&lt;=1) &#123; q.push(i); &#125; &#125; LL max1=0,max2=0; LL ans=0; while(q.size()) &#123; int node=q.front(); q.pop(); max1=max2=0; for(auto i:G[node]) &#123; if(used[i.to]==1) &#123; LL temp=dp[i.to]-i.c; if(temp&gt;max1) &#123; swap(max1,temp); &#125; if(temp&gt;max2) &#123; swap(max2,temp); &#125; &#125; else &#123; in[i.to]--; if(in[i.to]&lt;=1)&#123; q.push(i.to); &#125; &#125; &#125; used[node]=1; LL temp=max1+max2+w[node]; ans=max(ans,temp); dp[node]=temp-max2; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[camera.ScreenToWorldPointä½¿ç”¨å‡ºç°å¼•ç”¨é”™è¯¯]]></title>
    <url>%2F2018%2F12%2F06%2Fcamera.ScreenToWorldPoint%E4%BD%BF%E7%94%A8%E5%87%BA%E7%8E%B0%E5%BC%95%E7%94%A8%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[ä½¿ç”¨camera.ScreenToWorldPointå‡ºç°å¦‚ä¸‹é”™è¯¯ NullReferenceException: Object reference not set to an instance of an object PlayerController.FixedUpdate () (at Assets/Scenes/PlayerController.cs:37) æ²¡æœ‰è®¾ç½®ä¸»ç›¸æœº]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity 3D ç²’å­æ’­æ”¾]]></title>
    <url>%2F2018%2F12%2F03%2FUnity%203D%20%E7%B2%92%E5%AD%90%E6%92%AD%E6%94%BE%2F</url>
    <content type="text"><![CDATA[gameObject.GetCompoment().Play();æ’­æ”¾ gameObject.GetCompoment().Pause();æš‚åœ gameObject.GetCompoment().Stop();åœæ­¢]]></content>
      <categories>
        <category>æ¸¸æˆ</category>
        <category>U3D</category>
      </categories>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity3då¼€å‘ä¸­ï¼Œç”¨VSæ‰“å¼€è„šæœ¬æ–‡ä»¶ä¸è‡ªåŠ¨è¡¥å…¨]]></title>
    <url>%2F2018%2F12%2F03%2Funity3d%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8C%E7%94%A8VS%E6%89%93%E5%BC%80%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6%E4%B8%8D%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%2F</url>
    <content type="text"><![CDATA[è®¾ç½®ä¸€ä¸‹é»˜è®¤ä»£ç è½¯ä»¶ï¼Œè¿™ä¸ªæ˜¯å› ä¸ºæ–‡ä»¶ä¸æ˜¯é»˜è®¤ç”¨VSæ‰“å¼€çš„ã€‚ è¿›å…¥Edit-&gt;Preferences External Tools æŠŠVSè®¾æˆç¼–è¾‘å™¨å°±å¯ä»¥äº†ã€‚]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ±‡ç¼–è¯­è¨€å®éªŒåè¿›åˆ¶2è¿›åˆ¶16è¿›åˆ¶è½¬æ¢è¾“å‡º]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E8%BF%9B%E5%88%B62%E8%BF%9B%E5%88%B616%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[ä»é”®ç›˜è¾“å…¥ä¸€ä¸ª0â€“255ä¹‹é—´çš„æ•´æ•°ï¼Œåœ¨å±å¹•ä¸Šæ˜¾ç¤ºå‡ºè¯¥æ•´æ•°å¯¹åº”çš„äºŒè¿›åˆ¶å’Œåå…­è¿›åˆ¶æ•°ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178 DATA SEGMENTMEG DB &apos;Please input a number(0~255):&apos;,0DH,0AH,&apos;$&apos;ME2 DB 0DH,0AH,&apos;Input a invalid number,exit!&apos;,0DH,0AH,&apos;$&apos;X DB ?Y DB 0AHBUF DB 10 DB ? DB 10 DUP(?)BU2 DB &apos;0&apos;,&apos;$&apos; DB 8 DUP(?) DATA ENDSCODE SEGMENT ASSUME DS:DATA,CS:CODESTART: MOV AX,DATA MOV DS,AX MOV AH,09H MOV DX,OFFSET MEG INT 21H MOV AH,0AH MOV DX,OFFSET BUF INT 21H MOV DL,BUF[1] CMP DL,3 JA ER MOV DL,BUF[2] CMP DL,0DH JZ PD CMP DL,&apos;0&apos; JB ER CMP DL,&apos;9&apos; JA ER SUB DL,&apos;0&apos; MOV X,DL MOV DL,BUF[3] CMP DL,0DH JZ PD CMP DL,&apos;0&apos; JB ER CMP DL,&apos;9&apos; JA ER MOV AL,X MUL Y SUB DL,&apos;0&apos; ADD AL,DL MOV X,AL MOV DL,BUF[4] CMP DL,0DH JZ PD CMP DL,&apos;0&apos; JB ER CMP DL,&apos;9&apos; JA ER SUB DL,&apos;0&apos; MOV AL,X CMP AL,19H JA ER MUL Y MOV BL,0FFH SUB BL,DL CMP AL,BL JA ER ADD AL,DL MOV X,ALPD: CMP X,0 JB ER CMP X,255 JA ER MOV AL,X MOV Y,AL CMP AL,0 JE XS MOV BL,BUF[1] MOV DI,BX MOV BU2[DI],&apos;$&apos; MOV BL,0AH AND AX,00FFH DIV BL DEC DI ADD AH,&apos;0&apos; MOV BU2[DI],AH MOV BL,AL CMP BL,0 JE XS MOV AL,BL MOV BL,0AH AND AX,00FFH DIV BL ADD AH,&apos;0&apos; DEC DI MOV BU2[DI],AH MOV BL,AL CMP BL,0 JE XS DEC DI MOV AL,BL MOV BL,0AH AND AX,00FFH DIV BL ADD AH,&apos;0&apos; MOV BU2[DI],AHXS: MOV AH,09H MOV DX,OFFSET BU2 INT 21H MOV AH,02H MOV DL,&apos;=&apos; INT 21H MOV CX,8 MOV AL,X SEC: MOV AL,Y MOV DI,CX MOV CL,1 ROL AL,CL MOV Y,AL AND AL,01H MOV DL,AL MOV AH,02H ADD DL,&apos;0&apos; INT 21H MOV CX,DI LOOP SEC MOV AH,02H MOV DL,&apos;B&apos; INT 21H MOV AH,02H MOV DL,&apos;=&apos; INT 21H MOV DL,X MOV CL,4 SHR DL,CL OR DL,30H CMP DL,39H JBE AD1 ADD DL,7AD1: MOV AH,2 INT 21H MOV DL,X AND DL,0FH OR DL,30H CMP DL,39H JBE AD2 ADD DL,7AD2: MOV AH,2 INT 21H MOV AH,02H MOV DL,&apos;H&apos; INT 21H MOV AH,4CH INT 21HER: MOV AH,09H MOV DX,OFFSET ME2 INT 21H MOV AH,4CH INT 21HCODE ENDS END START]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ±‡ç¼–è¯­è¨€å®ç°æ˜¾ç¤º16è¿›åˆ¶æ•°]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E6%98%BE%E7%A4%BA16%E8%BF%9B%E5%88%B6%E6%95%B0%2F</url>
    <content type="text"><![CDATA[å°†å†…å­˜å•å…ƒå­˜å‚¨çš„8ä¸ªä¸¤ä½16è¿›åˆ¶æ•°ï¼š01H, 25H, 38H, 62H, 8DH, 9AH, BAH, CEHä¾æ¬¡æ˜¾ç¤ºåœ¨å±å¹•ä¸Šã€‚ ç›´æ¥è½¬æ¢ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 DATA SEGMENTBUF DB 01H,25H,38H,62H,8DH,9AH,0BAH,0CEHN DW $-BUFX DW 0DATA ENDSCODE SEGMENT ASSUME CS:CODE,DS:DATASTART: MOV AX,DATA MOV DS,AX MOV CX,NBE: MOV N,CX MOV BX,X MOV DL,BUF[BX] INC BX MOV X,BX CALL DELY MOV CX,N CMP CX,1 JE FINISH MOV DL,&apos;,&apos; MOV AH,2 INT 21H LOOP BEFINISH:MOV AX,4C00H INT 21HDELY PROC NEAR MOV BL,DL MOV CL,4 SHR DL,CL OR DL,30H CMP DL,39H JBE AD1 ADD DL,7AD1: MOV AH,2 INT 21H MOV DL,BL AND DL,0FH OR DL,30H CMP DL,39H JBE AD2 ADD DL,7AD2: MOV AH,2 INT 21H MOV DL,&apos;H&apos; MOV AH,2 INT 21H RETDELY ENDPCODE ENDS END START æ‰“è¡¨æ³•ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 DATA SEGMENTBUF DB 01H,25H,38H,62H,8DH,9AH,0BAH,0CEHN DW $-BUFASCII DB 30H,31H,32H,33H,34H,35H,36H,37H,38H,39H DB 41H,42H,43H,44H,45H,46HX DW 0Y DB 0DATA ENDSCODE SEGMENT ASSUME CS:CODE,DS:DATASTART: MOV AX,DATA MOV DS,AX MOV CX,NBE: MOV N,CX MOV BX,X MOV DL,BUF[BX] INC BX MOV X,BX MOV CX,N CMP CX,1 JE FINISH MOV DL,&apos;,&apos; MOV AH,2 INT 21H LOOP BEFINISH:MOV AX,4C00H INT 21HDELY PROC NEAR MOV Y,DL MOV CL,4 SHR DL,CL MOV BX,OFFSET ASCII MOV AL,DL AND AL,0FH XLAT MOV DL,AL MOV AH,2 INT 21H MOV AL,Y AND AL,0FH XLAT MOV DL,AL MOV AH,2 INT 21H MOV DL,&apos;H&apos; MOV AH,2 INT 21H RETDELY ENDPCODE ENDS END START]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ±‡ç¼–è¯­è¨€å®ç°å†’æ³¡æ³•æ’åº]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%86%92%E6%B3%A1%E6%B3%95%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[åˆ©ç”¨å†’æ³¡æ³•æ’åºç®—æ³•ï¼Œå°†å†…å­˜å•å…ƒå­˜å‚¨çš„æ•°35Hï¼Œ78Hï¼Œ25Hï¼Œ13Hï¼Œ8Hï¼ŒD2Hç”±å¤§åˆ°å°è¿›è¡Œæ’åºã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041 DATA SEGMENTDAT DB 35H,78H,25H,13H,8H,0D2HDATA ENDSCODE SEGMENT ASSUME CS:CODE,DS:DATASTART: MOV AX,DATA MOV DS,AX MOV CX,5A1: MOV DI,CX MOV BX,0A2: MOV AL,DAT[BX] CMP AL,DAT[BX+1] JGE A3 XCHG AL,DAT[BX+1] MOV DAT[BX],ALA3: ADD BX,1 LOOP A2 MOV CX,DI LOOP A1 MOV DL,DAT[0] MOV CL,4 SHR DL,CL OR DL,30H CMP DL,39H JBE AD1 ADD DL,7AD1: MOV AH,2 INT 21H MOV DL,DAT[0] AND DL,0FH OR DL,30H CMP DL,39H JBE AD2 ADD DL,7AD2: MOV AH,2 INT 21H MOV AH,4CH INT 21HCODE ENDS END START]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ±‡ç¼–è¯­è¨€å®ç°æ–‡æœ¬æµè§ˆå™¨]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E6%B5%8F%E8%A7%88%E5%99%A8%2F</url>
    <content type="text"><![CDATA[è¿è¡Œç¨‹åºåï¼Œå±å¹•æ˜¾ç¤ºâ€œinput number (1-3)ï¼šâ€ é”®å…¥â€œ1â€åï¼Œæ˜¾ç¤ºâ€œchapter1: introductionâ€ é”®å…¥â€œ2â€åï¼Œæ˜¾ç¤ºâ€œchapter2: designing methodâ€ é”®å…¥â€œ3â€åï¼Œæ˜¾ç¤ºâ€œchapter3: experimentâ€ é”®å…¥å…¶ä»–æ•°å­—åï¼Œè¿”å›å±å¹•æç¤ºçŠ¶æ€ ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 data segmentstr db &apos;please input number(1-3):&apos;,&apos;$&apos;str1 db &apos;chapter1: introduction&apos;,&apos;$&apos;str2 db &apos;chapter2: designing method&apos;,&apos;$&apos;str3 db &apos;chapter3:experimenr&apos;,&apos;$&apos;table dw A1,A2,A3 data endscode segment assume cs:code,ds:datastart: mov ax,data mov ds,ax begin:mov dx,offset str mov ah,9 int 21h mov ah,01h int 21h cmp al,&apos;1&apos; jb finish cmp al,&apos;3&apos; ja finish and ax,000FH dec ax shl ax,1 mov bx,ax jmp table[bx] A1: mov dx,offset str1 mov ah,9 int 21h jmp enter A2: mov dx,offset str2 mov ah,9 int 21h jmp enter A3: mov dx,offset str3 mov ah,9 int 21h jmp enter finish: mov dl,0dh mov ah,2 int 21h mov dl,0ah int 21h jmp begin enter: mov ax,4c00h int 21hcode ends end start]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ±‡ç¼–è¯­è¨€å®éªŒå°†å†…å­˜å•å…ƒå­˜å‚¨çš„å­—èŠ‚æ•°æ®çš„16è¿›åˆ¶æ•°çš„ä½ä½è¾“å‡ºåˆ°æ˜¾ç¤ºå™¨å¹¶æ˜¾ç¤ºã€‚]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%B0%86%E5%86%85%E5%AD%98%E5%8D%95%E5%85%83%E5%AD%98%E5%82%A8%E7%9A%84%E5%AD%97%E8%8A%82%E6%95%B0%E6%8D%AE%E7%9A%8416%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E4%BD%8E%E4%BD%8D%E8%BE%93%E5%87%BA%E5%88%B0%E6%98%BE%E7%A4%BA%E5%99%A8%E5%B9%B6%E6%98%BE%E7%A4%BA%E3%80%82%2F</url>
    <content type="text"><![CDATA[æ‰“è¡¨æ³•ï¼š 1234567891011121314151617181920 DATA SEGMENTASCII DB 30H,31H,32H,33H,34H,35H,36H,37H,38H,39H DB 41H,42H,43H,44H,45H,46HHEX DB 0BHDATA ENDSCODE SEGMENT ASSUME CS:CODE,DS:DATASTART: MOV AX,DATA MOV DS,AX MOV BX,OFFSET ASCII MOV AL,HEX AND AL,0FH XLAT MOV DL,AL MOV AH,2 INT 21H MOV AX,4C00H INT 21HCODE ENDS END START ç›´æ¥è½¬æ¢ï¼š 12345678910111213141516171819 DATA SEGMENTHEX DB 0BHDATA ENDSCODE SEGMENT ASSUME CS:CODE,DS:DATASTART: MOV AX,DATA MOV DS,AX MOV DL,HEX AND DL,0FH OR DL,30H CMP DL,39H JBE AD1 ADD DL,7AD1: MOV AH,2 INT 21H MOV AX,4C00H INT 21HCODE ENDS END START]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ±‡ç¼–å®ç°å¤§å°å­—æ¯è½¬æ¢]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B1%87%E7%BC%96%E5%AE%9E%E7%8E%B0%E5%A4%A7%E5%B0%8F%E5%AD%97%E6%AF%8D%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[ä»é”®ç›˜é”®å…¥ä¸€ä¸ªå¤§å†™è‹±æ–‡å­—æ¯ï¼Œå­˜æ”¾åˆ°å†…å­˜å•å…ƒBUF1ä¸­ï¼Œå†è½¬åŒ–ä¸ºå¯¹åº”çš„å°å†™å­—æ¯ï¼Œå­˜æ”¾åˆ°å†…å­˜å•å…ƒBUF2ä¸­ã€‚ 1234567891011121314151617181920 data segmentbuf1 db ?buf2 db ?data endscode segmentassume ds:data,cs:codebegin:mov ax,datamov ds,axmov ah,01int 21hmov buf1,aladd al,20hmov buf2,almov dl,almov ah,02int 21hmov ah,4chint 21hcode endsend begin]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ±‡ç¼–å®ç°ä¸€ä¸ªç®€å•åŠ æ³•ç¨‹åºã€‚]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B1%87%E7%BC%96%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E5%8A%A0%E6%B3%95%E7%A8%8B%E5%BA%8F%E3%80%82%2F</url>
    <content type="text"><![CDATA[æ±‡ç¼–è¯­è¨€ï¼Œå†™ä¸€ä¸ªç®€å•åŠ æ³•ç¨‹åºâ€œ3+5=8â€ï¼ŒåŠ æ•°å’Œç»“æœåˆ†åˆ«å­˜åœ¨å†…å­˜å•å…ƒNUM1ã€NUM2ã€NUM3ä¸­ã€‚ 12345678910111213141516 data segment num1 db 3 num2 db 5 num3 db ?data endscode segmentassume cs:code,ds:data start:mov ax,data mov ds,ax mov al,num1 add al,num2 mov num3,al mov ax,4c00h int 21hcode endsend start]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-CCSPæ­å·]]></title>
    <url>%2F2018%2F10%2F30%2F2018-CCSP%E6%9D%AD%E5%B7%9E%2F</url>
    <content type="text"><![CDATA[ä½œä¸ºä¸€ä¸ªåªå­¦äº†ä¸€å¹´çš„èœé¸¡ï¼Œæ²¡æƒ³åˆ°ç«Ÿç„¶åœ¨CCSPä¸Šæ‹¿äº†ä¸€å—é‡‘ã€‚åªèƒ½è¯´è¿æ°”ä¸é”™ã€‚ https://git.thusaac.org/publish/CCSP2018]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF 2018-09 é¢˜è§£]]></title>
    <url>%2F2018%2F09%2F17%2FCCF%202018-09%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[CCF 201809 1.å°±æ˜¯æ±‚å¹³å‡å€¼ï¼Œç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªç‰¹åˆ¤ä¸€ä¸‹ã€‚ 2.è¿™é¢˜ä¸¤ç§æ€è·¯ï¼šç¬¬ä¸€ç§ï¼Œç›´æ¥n*nçš„åˆ¤æ–­æœ‰æ²¡æœ‰äº¤å‰çš„åŒºé—´ï¼Œæœ‰å°±ç›´æ¥åŠ ä¸Šå»ã€‚ç¬¬äºŒç§ç›´æ¥æ¨¡æ‹Ÿæ—¶é—´è½´ï¼Œæ—¶é—´è½´æœ€å¤§åªæœ‰1e6ï¼Œé‚£ä¸ªåŒºé—´å¦‚æœæœ‰è¦†ç›–å°±ç›´æ¥+1ï¼Œç„¶åä¸¤ä¸ªäººçš„åŒºé—´è¦†ç›–ï¼Œå¦‚æœä¸¤ä¸ªäººéƒ½æœ‰è¿™ä¸ªåŒºé—´å°±æ˜¯2ï¼Œæ•°ç»„ä¸º2çš„ä¸ªæ•°åŠ èµ·æ¥å°±è¡Œäº†ã€‚ç”±äºåŒºé—´é•¿åº¦æ˜¯S-Tï¼Œå…¶å®è¿™ä¸ªç›¸å½“äº[s,t),æœ‰ä¸€ä¸ªæ˜¯å¼€åŒºé—´ã€‚ 3.è¯·è§ æ”¿å¤§ä½¬ 4.è®°å¿†åŒ–DFSï¼Œå¼€ä¸€ä¸ªvis[400][400][400]çš„æ•°ç»„ï¼Œvis[pos][i][j],posè¡¨ç¤ºä½ç½®ï¼Œiï¼Œè¡¨ç¤ºå½“å‰ä½ç½®çš„å€¼ï¼Œj,è¡¨ç¤ºå‰ä¸€ä¸ªä½ç½®çš„å€¼ã€‚ç„¶åå°±æš´åŠ›æšä¸¾æ‰€æœ‰çš„å€¼ï¼Œå¦‚æœé‚£ä¸ªå€¼å’Œå‰é¢ä¸€ä¸ªçš„å€¼å·²ç»è®¿é—®è¿‡äº†å°±ç›´æ¥è¿”å›0ã€‚ä»å°å¾€å¤§æœç´¢ï¼Œè¿™æ ·å°±å¯ä»¥ä¿è¯å­—å…¸åºæœ€å°ã€‚ è¿™é¢˜å¯ä»¥ç”¨ç¬¬ä¸€é¢˜å¯¹æ‹ä¸€ä¸‹å“ˆå“ˆ ä¸»è¦è€ƒç‚¹: 1.å¹³å‡å€¼ï¼ŒçŸ¥é“a[pos],b[pos-1],b[pos]å¯ä»¥æ¨å‡ºb[pos+1]åªæœ‰3ç§å–å€¼(æ»¡è¶³(b[pos-1]+b[pos]+b[pos+1])/3==a[pos])ï¼› 2 è®°å¿†åŒ–æœç´¢ï¼Œå› ä¸ºæ¯ç§çŠ¶æ€åé¢éƒ½æœ‰3ç§å–å€¼æ‰€ä»¥æš´åŠ›æ˜¯ï¼Œ3^100å¤æ‚åº¦ï¼Œæ˜æ˜¾è¶…æ—¶ã€‚æ‰€ä»¥è¦å‰ªæï¼Œå°±æ˜¯å‰é¢è¯´çš„visæ•°ç»„ã€‚è¿™æ ·æ‰€æœ‰çŠ¶æ€æœ€å¤šè·‘ä¸€æ¬¡ï¼Œæ€»å¤æ‚åº¦300^3,ï¼ˆå®é™…ä¸Šæ²¡æœ‰è¿™ä¹ˆå¤§ï¼‰å¯ä»¥è¿‡ã€‚ 5.ä½ èƒ½å¼€è¿™ä¸€é¢˜ï¼Œå¯ä»¥ç›´æ¥è·³è¿‡æˆ‘åšå®¢äº†ã€‚]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é•¿æ²™ç†å·¥é›†è®­é˜Ÿ-9.11æ—¥ç»„é˜Ÿèµ›]]></title>
    <url>%2F2018%2F09%2F15%2F%E9%95%BF%E6%B2%99%E7%90%86%E5%B7%A5%E9%9B%86%E8%AE%AD%E9%98%9F-9.11%E6%97%A5%E7%BB%84%E9%98%9F%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[å¥½ä¹…æ²¡å†™åšå®¢äº†ï¼Œå†™ç¯‡åšå®¢æ”¾æ¾ä¸€ä¸‹ã€‚ å¤–ç½‘OJï¼šhttp://csustacm.com:4803/ 1é¢˜æˆ‘å°±ä¸å†™äº†è¿™é¢˜å†™äº†ä¹Ÿæ²¡å•¥æ„ä¹‰ã€‚ 2.é»„é‡‘çŸ¿å·¥ Description æ¸¸æˆä¸­æœ‰nä¸ªå®çŸ³ï¼Œæ¯ä¸ªå®çŸ³æœ‰ä¸€ä¸ªä»·å€¼viï¼Œæ¯æ¬¡æŒ–å‡ºè¿™ä¸ªå®çŸ³éœ€è¦æ—¶é—´tiã€‚å› ä¸ºæœ‰äº›å®çŸ³è¢«å¦å¤–ä¸€ä¸ªå®çŸ³æŒ¡ä½äº†ï¼ˆä¸¤ä¸ªå®çŸ³åœ¨åŒä¸€ç›´çº¿ä¸Šï¼‰ï¼Œä¸€ä¸ªå®çŸ³æœ€å¤šæŒ¡ä½ä¸€ä¸ªå®çŸ³ï¼Œä¸€ä¸ªå®çŸ³æœ€å¤šè¢«ä¸€ä¸ªå®çŸ³æŒ¡ä½ã€‚è¦å…ˆæ¡èµ·æŒ¡è·¯çš„å®çŸ³ï¼Œæ‰èƒ½æ¡èµ·è¯¥å®çŸ³ã€‚æ¯ä¸ªå®çŸ³çš„æŒ¡è·¯å®çŸ³ä¸ºfiï¼Œå¦‚æœæ²¡æœ‰æŒ¡è·¯å®çŸ³fi = 0ï¼Œå³å®ƒè‡ªå·±(é¢˜ç›®ä¿è¯æ²¡æœ‰ç¯ï¼Œä¸”ä¸å­˜åœ¨)ã€‚ æ¸¸æˆçš„æ—¶é—´é™åˆ¶æ˜¯tç§’ï¼Œåœ¨tç§’å†…ä½ è·å¾—æœ€å¤§ä»·å€¼å’Œæ˜¯å¤šå°‘ï¼Ÿ Input ç¬¬ä¸€è¡Œä¸€ä¸ªæ•´æ•°Tï¼Œè¡¨ç¤ºæ¥ä¸‹æ¥æœ‰Tç»„æ•°æ®ã€‚ï¼ˆT &lt;= 50ï¼‰ æ¯ç»„æ•°æ®æ ¼å¼å¦‚ä¸‹ï¼š ç¬¬ä¸€è¡Œä¸¤ä¸ªæ•´æ•°nï¼ˆ1&lt;=n&lt;=200ï¼‰ï¼Œtï¼ˆ1&lt;=t&lt;=100,000,000ï¼‰ æ¥ä¸‹æ¥nè¡Œï¼Œæ¯è¡Œä¸‰ä¸ªæ•´æ•°viï¼ˆ1&lt;=vi&lt;=50ï¼‰ï¼Œtiï¼ˆ1&lt;=ti&lt;=1000,000ï¼‰ï¼Œï¼ˆ0&lt;=fi&lt;=nï¼‰ Output è¾“å‡ºè·å¾—çš„æœ€å¤§ä»·å€¼å’Œ Sample Input 1 11 5 10 2 1 0 5 3 1 3 2 0 1 4 3 4 6 4 Sample Output 1 111 é¢˜æ„ï¼šæŒ–å®çŸ³ï¼ŒæŒ–æŸä¸ªå®çŸ³å‰å¯èƒ½æœ‰ä¸€ä¸ªå®çŸ³ï¼Œä¸€ä¸ªå®çŸ³ä¹Ÿåªèƒ½é˜»éš¾ä¸€ä¸ªå®çŸ³ï¼ŒæŒ–æŸä¸ªå®çŸ³è¦æ¶ˆè€—æ—¶é—´tiè·å¾—ä»·å€¼viï¼Œé—®T=tç§’æœ€å¤šå¯ä»¥æŒ–å®çŸ³çš„æœ€å¤§ä»·å€¼ã€‚ é¢˜è§£ï¼šçœ‹äº†ä¸‹æ•°æ®èŒƒå›´ï¼Œè‚¯å®šæ˜¯ä»¥ä»·å€¼DPï¼Œæ±‚ä»·å€¼çš„æœ€å°æ—¶é—´ï¼Œå¦‚æœæ—¶é—´å°äºæ‰€ç»™å®šçš„æ—¶é—´å°±å¯ä»¥æŒ–åˆ°ç›¸åº”ä»·å€¼ã€‚ é¦–å…ˆå¤„ç†ä¸‹ï¼Œæ¯ä¸ªå®çŸ³å‰åæœ€å¤šåªæœ‰ä¸€ä¸ªï¼Œè‚¯å®šæ˜¯ä¸€æ¡é“¾ï¼ŒæŠŠæ¯æ¡é“¾å¤„ç†ä¸€ä¸‹ï¼ˆå‡å¦‚ä¸€æ¡é“¾æ˜¯1-&gt;2-&gt;3,é‚£ä¹ˆè¿™æ¡é“¾ä¸Šå°±æœ‰3ä¸ªèŠ‚ç‚¹åˆ†åˆ«ä¿å­˜2ä¸ªå€¼ï¼ŒæŒ–åˆ°1ï¼Œ(v1,t1ï¼‰æŒ–åˆ°2ï¼Œï¼ˆv1+v2,t1+t2ï¼‰æŒ–åˆ°3,(v1+v2+v3,t1+t2+t3))ã€‚æœ€å¤šåªæœ‰200æ¡é“¾ï¼Œæ‰€ä»¥ä¸ç”¨æ‹…å¿ƒè¶…æ—¶ã€‚ æ¯æ¡é“¾ä¿å­˜ ä¸¤ä¸ªå€¼ï¼Œä»·å€¼å’Œæ‰€éœ€è¦çš„æ—¶é—´ã€‚ç„¶ååœ¨DPå°±è¡Œäº†ã€‚å› ä¸ºæ¯æ¡é“¾ä¸Šåªèƒ½é€‰ä¸€ä¸ªå€¼æ‰€ä»¥DPè‚¯å®šè¦å¼€äºŒç»´ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 #include&lt;bits/stdc++.h&gt;#define fi first#define se secondusing namespace std;#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot;&lt;&lt;endl;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;const int maxn=1e3+7;const int inf=0x3f3f3f3f;int n, m, tot;int son[maxn];int in[maxn], v[maxn], t[maxn], vis[maxn];vector&lt;P&gt; ar[maxn];int dp[205][10005];void dfs(int u,int val,int tim) &#123; //ç”¨DFSï¼Œä¸€æ¡é“¾ vis[u] = 1; ar[tot].push_back(make_pair(val+v[u],tim+t[u])); if(son[u] == 0)return; dfs(son[u],val+v[u],tim+t[u]);&#125;int main() &#123; int tim; scanf(&quot;%d&quot;, &amp;tim); while(tim--) &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int sum = 0; for(int i = 0; i &lt;= n; ++i) &#123; son[i]=vis[i]=0; ar[i].clear(); &#125; for(int i = 1, u; i &lt;= n; ++i) &#123; scanf(&quot;%d%d%d&quot;, &amp;v[i], &amp;t[i], &amp;u); sum += v[i]; //if(u == 0)continue; son[u] = i; &#125; tot = 0; for(int i = 1; i &lt;= n; ++i) &#123; if(vis[i] == 0) &#123;//å¦‚æœè¿™ä¸ªèŠ‚ç‚¹æ²¡æœ‰çˆ¶äº²ï¼Œå°±è¯´æ˜è¿™æœ‰ä¸€æ¡é“¾ã€‚ dfs(i, 0, 0); tot++; &#125; &#125; memset(dp, 0x3f, sizeof(dp)); for(int i = 0; i &lt; tot; ++i) &#123; ã€‚ ar[i].push_back(make_pair(0, 0));//æ¯ä¸ªé“¾è‚¯å®šå¯ä»¥ä¸€ä¸ªéƒ½ä¸æŒ–ï¼Œæ‰€ä»¥0 ï¼Œ0è¦åŠ è¿›å»ã€‚ sort(ar[i].begin(),ar[i].end()); &#125; int sz = ar[0].size(); for(int i = 0; i &lt; sz; ++i) &#123;//dpåˆå§‹åŒ– dp[0][ar[0][i].fi] = ar[0][i].se; &#125; for(int i = 1; i &lt; tot; ++i) &#123; sz = ar[i].size(); for(int j = 0; j &lt; sz; ++j) &#123; for(int k = sum; k &gt;= ar[i][j].fi; --k) &#123; dp[i][k] = min(dp[i-1][k-ar[i][j].fi]+ar[i][j].se,dp[i][k]); &#125; &#125; &#125; int ans = 0; for(int i = sum; i &gt;= 0; --i) &#123; if(dp[tot-1][i]&lt;=m) &#123; //æ‰¾ç¬¬ä¸€ä¸ªå°äºç­‰äºç»™å®šæ—¶é—´çš„ä»·å€¼ ans = i; break; &#125; &#125; printf(&quot;%d\n&quot;, ans); &#125; return 0;&#125; 3.ç²¾çµç‹å›½ Description å°Jç¦»å¼€äº†ç¥ç§˜ç¾¤å²›ä¹‹åï¼Œæ¥åˆ°äº†ç¹åçš„ç²¾çµç‹å›½ã€‚ ç²¾çµç‹å›½ä¸­æœ‰nä¸ªåŸå¸‚ï¼Œç°åœ¨å·²çŸ¥ç¬¬ i ä¸ªåŸå¸‚å’Œç¬¬ i + 1ä¸ªåŸå¸‚ä¹‹é—´æœ‰ä¸€æ¡é•¿åº¦ä¸ºd[i]çš„åŒå‘é“è·¯ã€‚ï¼ˆç‰¹åˆ«çš„ï¼Œç¬¬nä¸ªåŸå¸‚å’Œç¬¬1ä¸ªåŸå¸‚ä¹‹é—´æœ‰ä¸€æ¡é•¿åº¦ä¸ºd[n]çš„åŒå‘é“è·¯ï¼‰ã€‚ éšç€ç»æµçš„å‘å±•ï¼Œç²¾çµç‹å›½çš„åŸå¸‚ä¹‹é—´å»ºç«‹äº†mæ¡åœ°é“ï¼Œç¬¬iæ¡åœ°é“å¯ä»¥ä»åŸå¸‚u[i]å‰å¾€v[i]ï¼Œä¹Ÿå¯ä»¥ä»v[i]å‰å¾€u[i]ï¼ŒåŒæ—¶åœ°é“çš„é•¿åº¦ä¸ºw[i]ã€‚ ç°åœ¨å°Jåœ¨å„ä¸ªåŸå¸‚ä¹‹é—´æ—…æ¸¸ï¼Œå°Jæƒ³çŸ¥é“ä»åŸå¸‚xå‰å¾€åŸå¸‚yæ—…æ¸¸éœ€è¦èŠ±è´¹å¤šé•¿çš„æ—¶é—´ï¼Ÿ Input ç¬¬ä¸€è¡Œä¸º2ä¸ªæ•´æ•°nã€mã€‚ ç¬¬äºŒè¡Œä¸ºnä¸ªæ­£æ•´æ•°d[i]ã€‚ æ¥ä¸‹æ¥mè¡Œæ¯è¡Œä¸‰ä¸ªæ­£æ•´æ•°u[i]ã€v[i]ã€w[i]ã€‚ ç¬¬m+3è¡Œä¸ºä¸€ä¸ªæ­£æ•´æ•°Qï¼Œè¡¨ç¤ºè¯¢é—®æ¬¡æ•°ã€‚ æ¥ä¸‹æ¥Qè¡Œæ¯è¡Œä¸¤ä¸ªæ­£æ•´æ•°xã€yï¼Œè¡¨ç¤ºä¸€æ¬¡ä»åŸå¸‚xåˆ°åŸå¸‚yçš„æ—…è¡Œã€‚ æ•°æ®èŒƒå›´ï¼š1&lt;=n,q&lt;=1e5,1&lt;=m&lt;=30,1&lt;=u[i],v[i],x,y&lt;=n,1&lt;=d[i],w[i]&lt;=1e9; Output è¾“å‡ºQè¡Œæ¯è¡Œä¸€ä¸ªæ­£æ•´æ•°è¡¨ç¤ºè¯¥æ¬¡æ—…è¡Œçš„æœ€çŸ­æ—¶é—´ã€‚ Sample Input 1 14 1 1 2 3 6 1 3 2 5 1 2 1 4 1 3 2 3 4 3 Sample Output 1 11 5 2 2 3 çœ‹èµ·æ¥æŒºéš¾çš„ï¼Œå…¶å®æ˜¯åˆ°åŸé¢˜ã€‚ã€‚ï¼ŒæŠŠæ•°æ®èŒƒå›´æ”¹äº†ä¸€ä¸‹ï¼Œè§ç‰›å®¢ç¬¬äºŒåœºæŒ‘æˆ˜èµ›ã€‚ çœ‹èµ·æ¥å¾ˆéš¾ï¼Œå®é™…ä¸Šç®€å•çš„ä¸€åŒ¹ï¼Œåªæœ‰30æ¡é“è·¯ï¼Œç›´æ¥æŠŠæœ‰é“è·¯çš„60ä¸ªç‚¹ç›´æ¥å…¨éƒ¨è·‘ä¸€æ¬¡æœ€çŸ­è·¯ï¼Œç„¶åé—®ä¸¤ä¸ªç‚¹ä¹‹é—´çš„æœ€çŸ­è·ç¦»ï¼Œè¦ä¹ˆåäº†åœ°é“ï¼Œé‚£ä¹ˆå°±æ˜¯åˆ°60ä¸ªç‚¹ä¸­çš„ä¸€ä¸ªæœ€çŸ­è·¯åŠ ä¸Šä»è¿™ä¸ªæœ‰é“è·¯çš„ç‚¹åˆ°å¦ä¸€ä¸ªç‚¹çš„æœ€çŸ­è·¯ï¼Œè¦ä¹ˆå°±æ˜¯ä¸åšåœ°é“ï¼Œä¸åšåœ°é“ä¸€ä¸ªå‰ç¼€å’Œå°±è¡Œäº†ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e5+5;const int inf=0x3f3f3f3f;int n,m;int d[maxn];LL dp[maxn];vector&lt;int&gt; v;bool u[maxn];struct edge &#123; int to,next; LL w;&#125; eg[maxn*3];int tot,head[maxn];void add(int u,int v,int w) &#123; eg[tot].to=v; eg[tot].w=w; eg[tot].next=head[u]; head[u]=tot++;&#125;LL dis[65][maxn];int main() &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); mem(head,-1); for(int i = 1; i &lt;= n ; i ++) &#123; scanf(&quot;%d&quot;,&amp;d[i]); dp[i]=dp[i-1]+d[i]; if(i==n) &#123; add(1,n,d[i]); add(n,1,d[i]); &#125; else &#123; add(i,i+1,d[i]); add(i+1,i,d[i]); &#125; &#125; while(m--) &#123; int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); if(u[a]==0) &#123; v.push_back(a); u[a]=1; &#125; if(u[b]==0) &#123; v.push_back(b); u[b]=1; &#125; add(a,b,c); add(b,a,c); &#125; mem(dis,inf); priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; q; for(int i = 0 ; i &lt; v.size(); i ++) &#123; dis[i][v[i]]=0; q.push(P(0,v[i])); while(q.size()) &#123; int u = q.top().second; q.pop(); for(int j = head[u]; j!=-1; j=eg[j].next) &#123; edge &amp;e=eg[j]; if(dis[i][e.to]&gt;dis[i][u]+e.w) &#123; dis[i][e.to]=dis[i][u]+e.w; q.push(P(dis[i][e.to],e.to)); &#125; &#125; &#125; &#125; int Q; scanf(&quot;%d&quot;,&amp;Q); while(Q--) &#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); if(a&gt;b)swap(a,b); LL ans=min(dp[b-1]-dp[a-1],dp[n]-(dp[b-1]-dp[a-1])); for(int i =0 ; i &lt;v.size(); i++) &#123;// debug(dis[i][a]+dis[i][b]); ans=min(ans,dis[i][a]+dis[i][b]); &#125; printf(&quot;%lld\n&quot;,ans); &#125; return 0;&#125; 5.zzqçš„æ•°å­¦æ•™å®¤2 Description zzqæƒ³ä¿ç ”ï¼Œä»–çš„æˆç»©å•ä¸Šæœ‰ä¸€æ’éé€’å‡é¡ºåºçš„æˆç»©ï¼Œé¢è¯•æ—¶è€å¸ˆæƒ³çŸ¥é“ä»–æ•°å­¦æˆç»©çš„ä½ç½®ï¼ŒzzqçŸ¥é“ä»–çš„æ•°å­¦æˆç»©æ˜¯xåˆ†ï¼Œä»–è¦æ‰¾åˆ°ç¬¬ä¸€ä¸ªå‡ºç°xçš„ä½ç½®ã€‚ ä»–æƒ³è¿ç”¨äºŒåˆ†æŸ¥æ‰¾ç®—æ³•ï¼Œ ä»£ç å¦‚ä¸‹ï¼š æ˜¾ç„¶Lå°±æ˜¯æœ€ç»ˆçš„ä½ç½®ã€‚ å¯æ˜¯ç°åœ¨ä»–çš„æˆç»©å…¨è¢«lcyå­¦å§æ‰“ä¹±äº†ï¼ˆéšæœºæŠŠæ•°å­—ä¹±æ”¾ï¼‰ã€‚ ä»–æƒ³çŸ¥é“æœ€åæ‰¾åˆ°çš„ä½ç½®ä»ç„¶æ˜¯åŸæ¥çš„ä½ç½®çš„æ¦‚ç‡ï¼Œ è¯·ä½ å¸®å¸®ä»–ã€‚ æ¦‚ç‡æ˜¯åœ¨æ¨¡1e9 + 7æ„ä¹‰ä¸‹çš„ï¼Œ å³ p / q = p * inv(q) ã€‚inv(q)æ˜¯qåœ¨æ¨¡1e9 + 7 æ„ä¹‰ä¸‹çš„é€†å…ƒã€‚ Input è¾“å…¥ç¬¬ä¸€è¡Œä¸€ä¸ªæ­£æ•´æ•°Nã€‚ ç¬¬äºŒè¡ŒNä¸ªæ­£æ•´æ•°a[i]ï¼Œä»£è¡¨çš„æ˜¯åŸæ¥çš„æˆç»©å•ï¼Œå‘ˆéé€’å‡é¡ºåºã€‚ ç¬¬ä¸‰è¡Œä¸€ä¸ªæ•°å­—xï¼Œä»£è¡¨ä»–çš„æ•°å­¦æˆç»©ã€‚ 1 &lt;= N &lt;= 1e5 1 &lt;= a[i] &lt;= 1e9 xä¿è¯æ˜¯æŸä¸€ä¸ªa[i]ã€‚ Output è¾“å‡ºä¸€ä¸ªæ•´æ•°ä»£è¡¨æ¦‚ç‡ã€‚ Sample Input 1 18 1 1 1 3 7 9 9 10 1 Sample Output 1 11 Sample Input 2 13 1 2 2 2 Sample Output 2 1333333336 Hint å¯¹äºç¬¬äºŒä¸ªæ ·ä¾‹ï¼Œlcyå­¦å§å¯èƒ½æ‰“ä¹±æˆè¿™3ç§ç­‰æ¦‚ç‡çš„æƒ…å†µï¼š 1 2 2 2 1 2 2 2 1 å…¶ä¸­åªæœ‰ç¬¬ä¸€ç§ä¼šç»“æœæ­£ç¡®ã€‚ æ¦‚ç‡æ˜¯1 / 3ã€‚ é¢˜è§£ï¼šæ°´é¢˜ï¼Œç›´æ¥æŠŠå°äºxçš„ä¸ªæ•°ï¼Œaï¼Œå’Œå¤§äºxçš„ä¸ªæ•°ç®—å‡ºæ¥bï¼Œç„¶åç…§è¿™ä¸ªäºŒåˆ†å†™æ³•ä¸€è·¯æŠŠç­”æ¡ˆç®—ä¸‹å»å°±è¡Œäº†ï¼›å…·ä½“çœ‹ä»£ç ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e5+5;const int inf=0x3f3f3f3f;int l,r;LL pow(LL x,LL n) &#123; LL ans=1; while(n) &#123; if(n&amp;1)ans=ans*x%mod; x=x*x%mod; n&gt;&gt;=1; &#125; return ans;&#125;int n,x;int a[maxn];int main() &#123; scanf(&quot;%d&quot;,&amp;n); for(int i = 1 ; i &lt;= n ; i ++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; scanf(&quot;%d&quot;,&amp;x); LL mx=0,mi=0; for(int i = 1; i&lt;=n; i++) &#123; if(a[i]&gt;=x) &#123; mx++;//å¤§äºç­‰äºxçš„ä¸ªæ•° &#125; else &#123; mi++;//å°äºç­‰äºxçš„ä¸ªæ•° &#125; &#125; int l=1,r=n; LL ans=1; while(l&lt;=r) &#123; int mid=(l+r)/2; if(a[mid]&gt;=x) &#123; ans=ans*mx%mod*pow(mi+mx,mod-2)%mod;//éœ€è¦ä¸€ä¸ªé€‰ä¸€ä¸ªå¤§äºç­‰äºxçš„æ•°ï¼Œé€‰åˆ°çš„æ¦‚ç‡æ˜¯(mx/(mi+mx)); mx--; r=mid-1; &#125; else &#123; ans=ans*mi%mod*pow(mi+mx,mod-2)%mod;//åŒä¸Šã€‚ mi--; l=mid+1; &#125; &#125; printf(&quot;%lld\n&quot;,ans); return 0;&#125; 6.zzqçš„æ•°å­¦æ•™å®¤ Description ä¼—æ‰€å‘¨çŸ¥ï¼Œæ‘¸é±¼æ˜¯qwbçš„ä¸€å¤§çˆ±å¥½ã€‚å³ä½¿æ˜¯åœ¨zzqçš„æ•°å­¦è¯¾ä¸Šï¼Œqwbä¹Ÿæ˜¯åœ¨ç–¯ç‹‚æ‘¸é±¼ã€‚è¿™è¢«çœ¼å°–çš„zzqå‘ç°äº†ï¼Œæ‰€ä»¥zzqå†³å®šè€ƒè€ƒæ‘¸é±¼çš„qwbï¼Œå¦‚æœqwbç­”ä¸å‡ºæ¥ï¼Œä»–çš„å¹³æ—¶åˆ†è‡ªç„¶å°±å½’é›¶äº†ã€‚ ç°åœ¨zzqæŠŠæ•°å­—1~nä»å·¦è‡³å³æ’æˆä¸€æ’ï¼ˆç¬¬iä¸ªæ•°çš„å€¼ä¸ºiï¼‰ï¼Œæ¥ä¸‹æ¥è¿›è¡Œmè½®æ“ä½œï¼Œæ¯æ¬¡æ“ä½œæè¿°å¦‚ä¸‹ï¼šå°†å¥‡æ•°ä½ç½®çš„æ•°å­—å–å‡ºå½¢æˆåºåˆ—Aï¼Œå°†å¶æ•°ä½ç½®çš„æ•°å­—å–å‡ºå½¢æˆåºåˆ—Bï¼Œå°†Aåºåˆ—æ‹¼æ¥åœ¨Båºåˆ—ä¹‹åï¼Œæ„æˆæ–°çš„åºåˆ—ã€‚ ç°åœ¨é—®é¢˜æ¥äº†ï¼šè¿›è¡Œmæ¬¡æ“ä½œåï¼Œç¬¬kä¸ªä½ç½®çš„æ•°å­—æ˜¯å¤šå°‘å‘¢ï¼Ÿ Input ç¬¬ä¸€è¡Œï¼Œè¾“å…¥2ä¸ªæ­£æ•´æ•°n,q æ¥ä¸‹æ¥qè¡Œï¼Œæ¯è¡Œ2ä¸ªæ•´æ•°må’Œkï¼Œè¡¨ç¤ºzzqæƒ³çŸ¥é“åœ¨mæ¬¡æ“ä½œä¹‹åç¬¬kä¸ªä½ç½®ä¸Šçš„æ•°æ˜¯å¤šå°‘ã€‚ æ•°æ®èŒƒå›´ï¼š n&lt;=5000 q&lt;=1e6 m&lt;=1e6 k&lt;=n; Output è¾“å‡ºqè¡Œï¼Œæ¯è¡Œè¾“å‡ºç¬¬kä¸ªä½ç½®çš„æ•°å­—ã€‚ Sample Input 1 15 2 1 2 2 3 Sample Output 1 14 2 æ°´é¢˜ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 #include&lt;bits/stdc++.h&gt;using namespace std;#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot;&lt;&lt;endl;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;const int maxn=5e3+7;const int inf=0x3f3f3f3f;int n,q;int ar[maxn], br[maxn];int ans[maxn][maxn];int main()&#123; while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;q))&#123; for(int i = 1; i &lt;= n; ++i)&#123; ar[i] = ans[0][i] = i; &#125; int tot, tim = 1; do&#123; tot = 1; for(int i = 2; i &lt;= n; i += 2)&#123; ans[tim][tot] = ans[tim-1][i]; //printf(&quot;%d &quot;, ans[tim][tot]); tot++; &#125; for(int i = 1; i &lt;= n; i += 2)&#123; ans[tim][tot] = ans[tim-1][i]; //printf(&quot;%d &quot;, ans[tim][tot]); tot++; &#125; int flag = 0; for(int i = 1; i &lt;= n; ++i)&#123; if(ans[tim][i] != ar[i])flag = 1; &#125; if(flag == 0)break; tim ++; &#125;while(1); //printf(&quot;*%d\n&quot;,tim); int m, k; while(q--)&#123; scanf(&quot;%d%d&quot;, &amp;m, &amp;k); m %= tim; if(m == 0)m = tim; printf(&quot;%d\n&quot;, ans[m][k]); &#125; &#125; return 0;&#125; 7.ç©æ¸¸æˆ Description drå–œæ¬¢ç©æ¸¸æˆï¼Œç°åœ¨æœ‰nä¸ªæ¸¸æˆï¼Œæ¯ä¸ªæ¸¸æˆæ—¶é—´ä¸º[Li,Ri)ï¼Œç°åœ¨é—®é¢˜æ˜¯ï¼Œæ‰¾å‡ºæœ€é•¿çš„ä¸€æ®µæ¸¸æˆæ—¶é—´ï¼Œä½¿å¾—è¯¥æ—¶é—´æ®µè¢«è‡³å°‘kä¸ªæ¸¸æˆå®Œå…¨è¦†ç›–(è¿™kä¸ªåŒºé—´è¦æ¯ä¸€ä¸ªéƒ½è¦å®Œå…¨è¦†ç›–ä½ é€‰å‡ºæ¥çš„è¿™ä¸ªåŒºé—´ï¼‰ã€‚ Input å¤šç»„è¾“å…¥ ç¬¬ä¸€è¡Œn,k(1&lt;=n,k&lt;1e6) æ¥ä¸‹æ¥nè¡Œï¼Œæ¯è¡Œä¸¤ä¸ªæ•°l,r(1&lt;=l&lt;r&lt;=1e9) Output è¾“å‡ºè¿™ä¸ªåŒºé—´çš„é•¿åº¦ Sample Input 1 13 2 1 5 1 4 1 3 Sample Output 1 13 è´ªå¿ƒå°±å¥½ï¼Œæ¯æ¬¡ä»æœ€å…ˆç»“æŸçš„ä¸€ä¸ªçº¿æ®µå¼€å§‹é€‰ï¼Œç„¶åæ‰¾æœ€å°çš„kå°äºå½“å‰çº¿æ®µç»“æŸç‚¹çš„èµ·ç‚¹ï¼Œç„¶åæ»¡è¶³æ¡ä»¶çš„åŒºé—´å°±æ˜¯å½“å‰åŒºé—´çš„ç»ˆç‚¹å‡å»kä¸ªèµ·å§‹ç‚¹ä¸­æœ€å¤§å€¼ã€‚æ‰¾å®Œè¿™ä¸ªçº¿æ®µçš„ç»ˆç‚¹åæŠŠè¿™ä¸ªåŒºé—´åˆ æ‰ï¼Œç„¶åä¾æ¬¡ç±»æ¨ä¸‹å»çŸ¥é“æ‰¾å®Œæ‰€æœ‰çš„çº¿æ®µã€‚æœ¬æ¥æ¯æ¬¡æ‰¾kä¸ªå°äºå½“å‰çº¿æ®µçš„ç»“æŸç‚¹èµ·å§‹ç‚¹éœ€è¦ä¸€ä¸ªæ“ä½œï¼Œä½†æ˜¯å› ä¸ºæ•°æ®æœ‰ç‚¹æ°´ï¼Œè¢«æˆ‘æ°´è¿‡å»äº†ã€‚ã€‚ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 #include&lt;bits/stdc++.h&gt;using namespace std;#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot;&lt;&lt;endl;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;const int maxn=1e6+7;const int inf=0x3f3f3f3f;struct th &#123; int st,en,id; bool operator &lt;(const th a)const &#123; if(en==a.en) &#123; return st&lt;a.st; &#125; else return en&lt;a.en; &#125;&#125; a[maxn];bool u[maxn];priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt;q;int main() &#123; int n,m; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)) &#123; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d%d&quot;,&amp;a[i].st,&amp;a[i].en); a[i].id=i; q.push(P(a[i].st,i)); &#125; sort(a,a+n); int cnt=0,ans=0,L=0; memset(u,0,sizeof(u)); for(int i =0; i&lt;n; i++) &#123; if(!u[a[i].id])cnt++; u[a[i].id]=1; L=a[i].st; //æœ¬æ¥è¿™æ˜¯è¦æ‰¾æœ€å¤§å€¼çš„ï¼Œä½†æ˜¯æ•°æ®æœ‰ç‚¹æ°´ï¼Œç›´æ¥å°±è¿‡å»äº†ã€‚ã€‚ã€‚ while(cnt&lt;m&amp;&amp;q.size()) &#123; if(u[q.top().second]==1) &#123; q.pop(); continue; &#125; else if(q.top().first&gt;=a[i].en) &#123; break; &#125; else &#123; cnt++; u[q.top().second]=1; L=max(L,q.top().first); q.pop(); &#125; &#125; if(cnt==m) &#123; ans=max(ans,a[i].en-L); &#125; cnt--; &#125; while(q.size())q.pop(); printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125; 9.ç­¾åˆ°é¢˜ Description â€œç´ æ•°å°±æ˜¯å› å­åªåŒ…å«1å’Œå®ƒæœ¬èº«çš„æ•°â€zzqå¦‚æ˜¯è¯´é“ã€‚ ç°åœ¨zzqçš„æ•°å­¦è¯¾ä¸‹è¯¾äº†ï¼Œä»–å‘ç°qwbåœ¨ä»–çš„è¯¾æ‘¸é±¼ï¼Œäºæ˜¯è¦å‡ºä¸€ä¸ªé¢˜è€ƒqwbï¼šNï¼çš„ç´ å› å­æœ‰å¤šå°‘ä¸ªï¼Ÿ å¦‚æœqwbåšä¸å‡ºæ¥å°±è¦è¢«pyäº¤æ˜“ï¼ä½†æ˜¯qwbå®Œå…¨ä¸çŸ¥é“zzqä¸Šè¯¾è®²äº†ä»€ä¹ˆï¼Œäºæ˜¯å‘ä»æ¥ä¸æ‘¸é±¼çš„ä½ æ±‚åŠ©äº†ï¼ˆåˆ’é‡ç‚¹ï¼šè¿™æ˜¯ç®€å•é¢˜ï¼‰ã€‚ Input ç¬¬ä¸€è¡Œè¾“å…¥ä¸€ä¸ªæ•´æ•°Tï¼ˆT \leq 10Tâ‰¤10ï¼‰ï¼Œè¡¨ç¤ºæœ‰Tç»„æ•°æ®ã€‚ æ¯ç»„æ•°æ®è¾“å…¥ç«™ä¸€è¡Œï¼Œè¾“å…¥ä¸€ä¸ªæ•´æ•°Nï¼ˆN \leq 10^5Nâ‰¤105ï¼‰ Output å¯¹äºæ¯ç»„æ•°æ®ï¼Œè¾“å‡ºN!æœ‰å¤šå°‘ä¸ªç´ å› å­ Sample Input 1 12 1 4 Sample Output 1 10 4 å¦‚é¢˜ç›®ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;const int maxn=1e5+7;const int inf=0x3f3f3f3f;int prim[maxn], p[maxn], pcnt;int sum[maxn];int main() &#123; int t; prim[0]=1; prim[1]=1; pcnt = 0; for(int i =2; i &lt; maxn; i++) &#123; if(!prim[i]) p[pcnt++] = i; for(int j = 0; j &lt; pcnt&amp;&amp;i*p[j]&lt;maxn; ++j) &#123; prim[i*p[j]] = 1; if(i%p[j] == 0)break; &#125; &#125; sum[0] = 0; sum[1] = 0; sum[2] = 1; for(int i = 3; i &lt; maxn; ++i) &#123; int tmp = i,cnt = 0; if(prim[i] == 0) &#123; sum[i]=sum[i-1]+1; continue; &#125; for(int j = 0; j &lt; pcnt; ++j) &#123; while(tmp % p[j] == 0) &#123; tmp /= p[j]; cnt++; &#125; if(tmp == 1)break; &#125; if(tmp!=1)cnt++; sum[i] = sum[i-1] + cnt; &#125; int n; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;, &amp;n); printf(&quot;%d\n&quot;, sum[n]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCFå‚»é€¼é¢˜ï¼Œ201709-5-é™¤æ³•---æš´åŠ›å¯ä»¥è¿‡ï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿ]]></title>
    <url>%2F2018%2F09%2F06%2FCCF%E5%82%BB%E9%80%BC%E9%A2%98%EF%BC%8C201709-5-%E9%99%A4%E6%B3%95---%E6%9A%B4%E5%8A%9B%E5%8F%AF%E4%BB%A5%E8%BF%87%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[è¿™é¢˜ç‰¹ä¹ˆæ— è¯­ï¼Œå²ä¸Šæœ€æ— è¯­æ²¡æœ‰ä¹‹ä¸€ï¼ŒC++çº¯æš´åŠ›è¿‡ 90ï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼ŒJAVAçº¯æš´åŠ›è¿‡äº†ï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Œtell me ï¼Œå‘ç”Ÿäº†ä»€ä¹ˆï¼Œè¿™é¢˜ä¸ºä»€ä¹ˆèƒ½æš´åŠ›ã€‚ CCFå¦‚æœJAVAç†Ÿç»ƒï¼Œå»ºè®®å¤§å®¶ç”¨JAVAã€‚ http://118.190.20.162/view.page?gpid=T59 JAVAçº¯æš´åŠ›ACä»£ç ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 //import java.lang.reflect.Array;import java.math.*;import java.util.Arrays;import java.util.Scanner;//import om.sun.swing.internal.plaf.basic.resources.basic;public class Main &#123; static int[] a= new int[100005]; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int n = input.nextInt(),m = input.nextInt(); for(int i= 1 ; i &lt;= n ; i ++) &#123; a[i] = input.nextInt(); &#125; int op,l,r,v; for(int j=0;j&lt;m;j++) &#123;// op = input.nextInt(); l = input.nextInt(); r = input.nextInt(); if(op==1) &#123; v = input.nextInt(); if(v == 1)continue; for(int i = l ; i &lt;= r; i ++) &#123; if(a[i] &gt;= v &amp;&amp; a[i] % v == 0) &#123; a[i] /= v; &#125; &#125; &#125; else &#123;// l=input.nextInt();// r=input.nextInt(); long ans=0; for(int i=l;i&lt;=r;i++) &#123; ans += a[i]; &#125; System.out.println(ans); &#125; &#125;// System.out.println(ans); &#125;&#125; C++çº¯æš´åŠ›ï¼Œè¿‡ 90%ï¼Œè¿™ä¸ªå¯ä»¥ç†è§£ã€‚ã€‚ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;const long long mod=1e9+7;const int maxn=1e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int A[maxn];int n,m;int main() &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;A[i]); &#125; while(m--) &#123; int op,l,r,v; scanf(&quot;%d%d%d&quot;,&amp;op,&amp;l,&amp;r); if(op==1) &#123; scanf(&quot;%d&quot;,&amp;v); if(v==1)continue; while(l&lt;=r) &#123; if(A[l]&gt;=v&amp;&amp;A[l]%v==0) &#123; A[l]/=v; &#125; l++; &#125; &#125; else &#123; long long ans=0; while(l&lt;=r) &#123; ans+=A[l++]; &#125; printf(&quot;%lld\n&quot;,ans); &#125; &#125; return 0;&#125; C++ï¼ŒACä»£ç ã€‚ä¹Ÿæ˜¯åŠä¸ªæš´åŠ›ã€‚å› ä¸ºæ¯ä¸ªæ•°å»é™¤æœ€å¤šåªèƒ½é™¤ 32æ¬¡ï¼Œï¼ˆå› ä¸ºæ•°çš„æœ€å¤§å€¼åªæœ‰1e6,æ¯æ¬¡å°±ç®—åªé™¤2ï¼Œä¹Ÿä¸èƒ½é™¤å¤šå°‘æ¬¡ï¼Œæ‰€ä»¥è¿™ä¸ªæ›´æ–°å¯ä»¥æš´åŠ›ï¼Œå¹¶ä¸ä¼šè¶…æ—¶ã€‚å¤æ‚åº¦æœ€é«˜ä¹Ÿåªæœ‰ 32 N logN,é‡ç‚¹åœ¨äºå¤„ç†å‰ç¼€å’Œï¼‰ï¼Œä¸ä¼šå†å¤šï¼Œæ‰€ä»¥åªéœ€è¦ç”¨ä¸€ä¸ªæ ‘çŠ¶æ•°ç»„ç»´æŠ¤å‰ç¼€å’Œå³å¯ï¼Œæ¯æ¬¡æ›´æ–°å€¼ï¼Œç›´æ¥æš´åŠ›èƒ½ä¸èƒ½é™¤ï¼Œç„¶åå†æ›´æ–°å€¼å³å¯ã€‚ è€ƒå¯Ÿä¸¤ç‚¹ï¼š1.æš´åŠ›æ›´æ–°å€¼ï¼ˆæ³¨æ„ç‰¹åˆ¤é™¤1ï¼‰ï¼Œ2.æ ‘çŠ¶æ•°ç»„æ±‚å‰ç¼€å’Œã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;const long long mod=1e9+7;const int maxn=1e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int A[maxn];long long bit[maxn];int n,m;long long sum(int i) &#123; long long ans=0; while(i&gt;0) &#123; ans+=bit[i]; i-=i&amp;-i; &#125; return ans;&#125;void add( int i, int x) &#123; while(i&lt;=n) &#123; bit[i]+=x; i += i&amp;-i; &#125;&#125;int main() &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;A[i]); add(i,A[i]); &#125; while(m--) &#123; int op,l,r,v; scanf(&quot;%d%d%d&quot;,&amp;op,&amp;l,&amp;r); if(op==1) &#123; scanf(&quot;%d&quot;,&amp;v); if(v==1)continue; while(l&lt;=r) &#123; if(A[l]&gt;=v&amp;&amp;A[l]%v==0) &#123; add(l,0-A[l]+A[l]/v); A[l]/=v; &#125; l++; &#125; &#125; else &#123; printf(&quot;%lld\n&quot;,sum(r)-sum(l-1)); &#125; &#125; return 0;&#125; ç»†å¿ƒçš„å­©å­ï¼Œè‚¯å®šä¸€å®šå‘ç°äº†ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ï¼ŒJAVAæš´åŠ›ï¼Œ6s ã€‚C++æ ‘çŠ¶æ•°ç»„7sï¼Œæˆ‘ç«Ÿæ— è¨€ä»¥å¯¹ã€‚æš´åŠ›æ¯”æ ‘çŠ¶æ•°ç»„å¿«ï¼Œè¿™æ•°æ®å‡ºçš„æŒºå¥½çš„ã€‚ã€‚ã€‚]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2013-2014 Summer Petrozavodsk Camp, Andrew Stankevich Contest 44 (ASC 44)]]></title>
    <url>%2F2018%2F08%2F31%2F2013-2014%20Summer%20Petrozavodsk%20Camp%2C%20Andrew%20Stankevich%20Contest%2044%20(ASC%2044)%2F</url>
    <content type="text"><![CDATA[æš‘è®­æœ€åä¸€åœºç»„é˜Ÿè®­ç»ƒèµ›ï¼Œç‰¹ä¹ˆæ•…æ„çš„ï¼ŒæŠŠåˆ«äººçš„WFç»ƒä¹ é¢˜ç»™æˆ‘ä»¬å†™ï¼Œå†™äº†åŠå¤©æ‰ç­¾åˆ°ä¸¤é¢˜ã€‚é ï¼ B - Braessâ€™s Paradox Gym - 100518B é¢˜æ„ï¼šæœ‰å‡ ä¸ªç‚¹ï¼Œæ¯ä¸ªç‚¹åˆ°ä¸‹ä¸€ä¸ªç‚¹ä¹‹é—´æœ‰ä¸¤æ¡è·¯ã€‚ä¸Šé¢ä¸€æ¡è·¯çš„é€šè¿‡æ—¶é—´æ˜¯ AK1+B,ä¸‹é¢ä¸€æ¡é€šè¿‡æ—¶é—´æ˜¯CK2+Dï¼Œè¦ä¸¤æ¡è·¯é€šè¿‡çš„æ—¶é—´æ•°å°½é‡ç›¸åŒï¼ŒK1+K2=1(K1,K2æ˜¯ç»è¿‡çš„äººæµé‡å æ€»äººæ•°çš„æ¯”ä¾‹)ã€‚ç„¶åä¸­é—´çš„ç‚¹å¯ä»¥å»ºé©¿ç«™ï¼Œå¦‚æœä¸­é—´çš„ç‚¹ä¸å»ºé©¿ç«™ï¼Œå°±ç›¸å½“äºç›´æ¥ä»èµ·ç‚¹åˆ°ç»ˆç‚¹ï¼Œåªæœ‰ä¸¤æ¡è·¯ï¼Œå¦‚æœå»ºäº†é©¿ç«™ï¼Œå°±ç›¸å½“äºä»èµ·ç‚¹åˆ°é©¿ç«™ï¼Œå†ä»é©¿ç«™åˆ°ç»ˆç‚¹ã€‚ é¢˜è§£ï¼šå‰ä¸¤ä¸ªç›´æ¥ç®—å‡ºæ¥å°±è¡Œï¼Œä¸€ä¸ªé©¿ç«™éƒ½ä¸å»ºï¼Œå°±ç›¸å½“äºä¸¤æ¡è·¯ï¼ŒæŠŠæ‰€æœ‰ç‚¹ä¸Šé¢é‚£æ¡è·¯ï¼Œai.bi,åŠ èµ·æ¥å°±æ˜¯ä¸Šé¢é‚£ä¸€æ¡è·¯çš„A,Bï¼ŒåŒç†ï¼Œä¸‹é¢ä¸€æ¡è·¯å°±æ˜¯æ‰€æœ‰çš„,ci,diåŠ èµ·æ¥ã€‚æ¯ä¸ªéƒ½å»ºå°±æ˜¯ç›¸å½“äºä¸€ä¸ªä¸ªç‚¹èµ°è¿‡å»ï¼Œæš´åŠ›å•Šï¼Œä¸€ä¸ªç‚¹åˆ°å¦ä¸€ä¸ªç‚¹çš„æ—¶é—´ï¼Œç„¶åå…¨åŠ èµ·æ¥å°±è¡Œäº†ã€‚åé¢ä¸¤ä¸ªå°±æ˜¯æ±‚æœ€å°é€šè¿‡æ—¶é—´çš„å’Œæœ€å¤§é€šè¿‡æ—¶é—´ï¼Œçœ‹ä¼¼å¾ˆéš¾ï¼Œå…¶å®å°±æ˜¯ä¸€ä¸ªå¾ˆç®€å•çš„DPï¼ŒN^2çš„å¤æ‚åº¦ä¸ä¼šè¶…æ—¶ã€‚é¦–å…ˆé¢„å¤„ç†ä»èµ·ç‚¹åˆ°å½“å‰ç‚¹çš„A,B,C,Dã€‚ç„¶åæ¯ä¸ªç‚¹çš„æ—¶é—´å°±æ˜¯ä»å‰é¢æŸä¸€ä¸ªç‚¹å»ºé©¿ç«™çš„æœ€å°å€¼ï¼Œæœ€å¤§å€¼è½¬ç§»è¿‡æ¥ã€‚ç›´æ¥è¿‡æ¥ä¸Šé¢è·¯çš„Aï¼ŒBå°±ç”¨ä¸¤ä¸ªå‰ç¼€ç›¸å‡ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;ll,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e3+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;int a[maxn],b[maxn],c[maxn],d[maxn];double qza[maxn],qzb[maxn],qzc[maxn],qzd[maxn];double dp1[maxn],dp2[maxn];double ans1,ans2,ans3,ans4;int main() &#123; freopen(&quot;braess.in&quot;,&quot;r&quot;,stdin); freopen(&quot;braess.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d%d%d%d&quot;,&amp;a[i],&amp;b[i],&amp;c[i],&amp;d[i]); &#125; double A=0,B=0,C=0,D=0; for(int i=1; i&lt;=n; i++) &#123; //ç¬¬ä¸€ç§ç»“æœéƒ½ä¸å»ºï¼ŒAç›¸å½“äºæ‰€æœ‰ç‚¹ä¹‹é—´çš„a[i]ç›¸åŠ  A+=a[i]; B+=b[i]; C+=c[i]; D+=d[i]; &#125; double k; if(A+C!=0) &#123; k=min(1.0,(D+C-B)/(A+C));//k1æœ€å¤§å€¼ä¸èƒ½è¶…è¿‡1 ans1=k*A+B; if(k&lt;=0) &#123; //k1æœ€å°å€¼ä¸èƒ½å°äº0ï¼Œå¦‚æœå°äºç­‰äº0è¯´æ˜æ‰€æœ‰äººéƒ½èµ°ä¸‹é¢ä¸€æ¡è·¯ ans1=C+D; &#125; &#125; else &#123; ans1=min(B,D); //å¦‚æœACéƒ½ç­‰äºé›¶ï¼Œé‚£å°±ç›´æ¥åˆ¤æ–­Bï¼ŒDå¤§å° &#125; ans2=0; for(int i=1; i&lt;=n; i++) &#123; A=a[i]; //æ‰€æœ‰çš„ç‚¹ä¸€ä¸ªä¸ªç®— B=b[i]; C=c[i]; D=d[i]; double temp; if(A+C!=0) &#123; k=min(1.0,(D+C-B)/(A+C)); temp=k*A+B; if(k&lt;=0) &#123; temp=C+D; &#125; &#125; else &#123; temp=min(B,D); &#125; ans2+=temp; &#125; for(int i=1; i&lt;=n; i++) &#123; //æ±‚å‰ç¼€ qza[i]=qza[i-1]+a[i]; qzb[i]=qzb[i-1]+b[i]; qzc[i]=qzc[i-1]+c[i]; qzd[i]=qzd[i-1]+d[i]; dp1[i]=inf; &#125; dp1[0]=0; for(int i=1; i&lt;=n; i++) &#123; for(int j=0; j&lt;i; j++) &#123; A=qza[i]-qza[j]; B=qzb[i]-qzb[j]; //ABCDç­‰äºä¸Šä¸€ä¸ªçŠ¶æ€å’Œå½“å‰çŠ¶æ€çš„å·®å€¼ï¼Œ C=qzc[i]-qzc[j]; D=qzd[i]-qzd[j]; double temp; if(A+C!=0) &#123; k=min(1.0,(D+C-B)/(A+C)); temp=k*A+B; if(k&lt;=0) &#123; temp=C+D; &#125; &#125; else &#123; temp=min(B,D); &#125; dp1[i]=min(dp1[i],dp1[j]+temp); //dp1ä¿ç•™æœ€å°å€¼ï¼Œä»jé©¿ç«™è½¬ç§»åˆ°ié©¿ç«™çš„æœ€å°å€¼ dp2[i]=max(dp2[i],dp2[j]+temp); //æœ€å¤§å€¼ &#125; &#125; ans3=dp1[n]; ans4=dp2[n]; printf(&quot;%.10f\n%.10f\n%.10f\n%.10f\n&quot;,ans1,ans2,ans3,ans4); return 0;&#125; I - Intelligent Tourist Gym - 100518I é¢˜æ„ï¼šæœ‰Nåœºè€ƒè¯•ï¼Œç¬¬iè€ƒè¯•éœ€è¦å¤ä¹ piå¤©ï¼Œè€ƒè¯•æ—¶é—´æ˜¯diï¼Œè€ƒè¯•çš„æ—¶é—´æ²¡æ³•å¤ä¹ ï¼Œå¦‚æœæ²¡æœ‰å¤ä¹ å¤šå¤©é‚£åœºè€ƒè¯•å°±ä¸ä¼šå»ï¼Œå°±ä¼šå»å¤ä¹ å…¶ä»–è€ƒè¯•ï¼Œä¸­é—´æœ‰äº›å¤©æœ‰æ´»åŠ¨ï¼Œæ´»åŠ¨æ—¶é—´æ˜¯s-tæ´»åŠ¨æ—¶é—´ä¸ä¼šå»å¤ä¹ ï¼Œé—®æœ€å¤šèƒ½é€šè¿‡æœºåœºè€ƒè¯•ã€‚ é¢˜è§£ï¼šè´ªå¿ƒï¼Œè¿™é¢˜è´¼ä»–å¦ˆå‚»é€¼ï¼Œæ¼çœ‹äº†ä¸€ä¸ªæ¡ä»¶ï¼ŒDEBUGä¸€ä¸ªå°æ—¶ã€‚ã€‚ã€‚ï¼Œä»åé¢å¾€å‰é¢æ‰«ï¼Œæ¯æ¬¡é€‰éœ€è¦å¤ä¹ æ—¶é—´æœ€å°‘çš„ä¸€åœºè€ƒè¯•ï¼Œå› ä¸ºè¿™ä¸ªæ—¶é—´åªèƒ½ç»™åé¢çš„æ‰€ä»¥ä¸ç”¨æ‹…å¿ƒé€‰çš„è€ƒè¯•æ—¶é—´å·²ç»è¿‡äº†ï¼Œè‡³äºè€ƒè¯•æ—¶é—´ä¸èƒ½å¤ä¹ ï¼Œä½ ç›´æ¥æŠŠè€ƒè¯•ä¹Ÿå½“ä½œå¤ä¹ çš„æ—¶é—´ï¼Œä¸å»è€ƒè¯•å°±ç›¸å½“äºå°‘å¤ä¹ è¿™ç§ç§‘ç›®ä¸€å¤©ï¼Œå»äº†å°±ç›¸å½“äºå¤šå¤ä¹ ä¸€å¤©ã€‚ã€‚ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;ll,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,m;struct one &#123; ll d,p; int id; bool operator&lt;(const one a)const &#123; return d&lt;a.d; &#125;&#125; X;struct two &#123; ll st,en; bool operator&lt;(const two a)const &#123; return st&lt;a.st; &#125;&#125; H;priority_queue&lt;one&gt; q1;priority_queue&lt;two&gt; q2;priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt;q;int main() &#123; freopen(&quot;intelligent.in&quot;,&quot;r&quot;,stdin); freopen(&quot;intelligent.out&quot;,&quot;w&quot;,stdout); while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n) &#123; vector&lt;int&gt; v; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%I64d%I64d&quot;,&amp;X.d,&amp;X.p); X.p++; X.id=i+1; q1.push(X); &#125; scanf(&quot;%d&quot;,&amp;m); for(int i=0; i&lt;m; i++) &#123; scanf(&quot;%I64d%I64d&quot;,&amp;H.st,&amp;H.en); q2.push(H); &#125; while(q2.size()) &#123; if(q2.top().st&gt;q1.top().d) &#123; q2.pop(); &#125; else break; &#125; while(q1.size()) &#123; X=q1.top(); q1.pop(); ll temp; if(q1.size()==0)temp=0; else temp=q1.top().d; ll tim=0; tim=X.d-temp; while(q2.size()) &#123; H=q2.top(); if(H.st&gt;temp) &#123; q2.pop(); tim-=H.en-H.st+1; &#125; else break; &#125; if(X.p==0) &#123; v.push_back(X.id); &#125; else q.push(P(X.p,X.id)); while(tim&gt;0&amp;&amp;q.size()) &#123; P temp2=q.top(); q.pop(); if(tim&gt;=temp2.first) &#123; tim-=temp2.first; v.push_back(temp2.second); &#125; else &#123; temp2.first-=tim; tim=0; q.push(temp2); &#125; &#125; &#125; while(q1.size())q1.pop(); while(q2.size())q2.pop(); while(q.size())q.pop(); sort(v.begin(),v.end()); int ans=v.size(); printf(&quot;%d\n&quot;,ans); for(int i=0; i&lt;ans; i++) &#123; printf(&quot;%d&quot;,v[i]); if(ans==i+1)printf(&quot;\n&quot;); else printf(&quot; &quot;); &#125; if(ans==0)puts(&quot;&quot;); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å‚»ç“œçº§gitå‘½ä»¤ç†è§£]]></title>
    <url>%2F2018%2F08%2F27%2F%E5%82%BB%E7%93%9C%E7%BA%A7git%E5%91%BD%E4%BB%A4%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[git clone wangzhi.com â€”å…‹éš†å¯¹åº”ç½‘å€ä»“åº“ git pull â€“æ›´æ–°ä»“åº“ git add -A æ·»åŠ åˆ°ç¼“å†²åŒºï¼Œ git commit -mâ€œyour nameâ€ æ›´æ–°æœ¬åœ°ä»“ git push æäº¤ä¸Šç½‘ç»œä»“åº“ ä¸Šé¢3ä¸ªè¿ç€ç”¨å°±è¡Œäº†ã€‚ git config â€”global user.name â€œè¾“å…¥ä½ çš„ç”¨æˆ·åâ€ git config â€”global user.email â€œè¾“å…¥ä½ çš„é‚®ç®±â€ åˆå§‹åŒ–ä¸‹èº«ä»½ç…§ç€æ‰“å°±è¡Œäº†]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The 17th Zhejiang University Programming Contest Sponsored by TuSimple(æµ™æ±Ÿçœèµ›)]]></title>
    <url>%2F2018%2F08%2F27%2FThe%2017th%20Zhejiang%20University%20Programming%20Contest%20Sponsored%20by%20TuSimple(%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9B)%2F</url>
    <content type="text"><![CDATA[A - Marjar Cola ZOJ - 3948 ç­¾åˆ°é¢˜ï¼Œx,y,a,b,éƒ½å¾ˆå°ç›´æ¥æš´åŠ›ã€‚åˆ¤æ–­INFï¼Œåªè¦åˆ¤æ–­æ¬¡æ•°æœ‰æ²¡æœ‰è¿‡å¤šå°±è¡Œã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int main() &#123; int x,y,a,b; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; int ans=0; scanf(&quot;%d%d%d%d&quot;,&amp;x,&amp;y,&amp;a,&amp;b); if(x==1||y==1)puts(&quot;INF&quot;); else &#123; while(a&gt;=x||y&lt;=b) &#123; if(a&gt;=x) &#123; a-=x; a++; b++; ans++; &#125; else &#123; b-=y; b++; a++; ans++; &#125;// debug(a);// debug(b); if(ans&gt;3e5)&#123; break; &#125; &#125; if(ans&gt;3e5)&#123; puts(&quot;INF&quot;); &#125; else printf(&quot;%d\n&quot;,ans); &#125; &#125; return 0;&#125; C - How Many Nines ZOJ - 3950 æ‰“ä¸ªè¡¨ï¼Œæ¯”è¾ƒè€ƒè™‘ç»†èŠ‚ï¼ŒçœŸçš„éš¾å¤„ç†ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e4+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int Year[maxn], Mon[35], pre1[maxn], pre2[35];int hh[13], mon[13];bool leap(int y)&#123; if(y%400==0)return 1; if(y%100==0)return 0; if(y%4==0)return 1; return 0;&#125;int nine(int y)&#123; int cnt = 0; while(y)&#123; if(y%10==9)cnt++; y/=10; &#125; return cnt;&#125;void init()&#123; Mon[1]=Mon[3]=Mon[5]=Mon[7]=Mon[8]=Mon[10]=Mon[12]=3;///31 Mon[2]=2; Mon[4]=Mon[6]=Mon[9]=Mon[11] = 3;///30 Mon[9] += 30; hh[1]=hh[3]=hh[5]=hh[7]=hh[8]=hh[10]=hh[12]=31; hh[2] = 28; hh[4]=hh[6]=hh[9]=hh[11]=30; mon[0] = 0; for(int i = 1; i &lt;= 12; ++i)&#123; mon[i] = hh[i]+mon[i-1]; &#125; int sum = 0;pre1[1999]=pre2[0] = 0; for(int i = 1; i &lt;= 12; ++i)&#123; sum += Mon[i]; pre2[i] = pre2[i-1]+Mon[i]; &#125; for(int i = 2000; i &lt;= 9999; ++i)&#123; int tmp = nine(i); if(tmp)&#123; Year[i] = sum + tmp*365; if(leap(i))Year[i] += tmp + 1; &#125;else&#123; Year[i] = sum; if(leap(i))++Year[i]; &#125; pre1[i] = pre1[i-1]+Year[i]; &#125;&#125;int get(int d)&#123; if(d&lt;=9)return 3; if(d&lt;=19)return 2; if(d&lt;=29)return 1; return 0;&#125;int main()&#123;#ifndef ONLINE_JUDGE //freopen(&quot;E://ADpan//in.in&quot;, &quot;r&quot;, stdin); //freopen(&quot;E://ADpan//out.out&quot;, &quot;w&quot;, stdout); #endif init(); int tim;scanf(&quot;%d&quot;,&amp;tim); while(tim--)&#123; int y1,m1,d1,y2,m2,d2; scanf(&quot;%d%d%d%d%d%d&quot;,&amp;y1,&amp;m1,&amp;d1,&amp;y2,&amp;m2,&amp;d2); if(y1==y2)&#123; if(m1==m2)&#123; int ans = get(d1)-get(d2+1); if(m1==9)ans += d2-d1+1; int tmp = nine(y1); ans += tmp*(d2-d1+1); printf(&quot;%d\n&quot;, ans); continue; &#125; int ans = pre2[m2-1]-pre2[m1]; if(leap(y1)&amp;&amp;2&gt;m1&amp;&amp;2&lt;m2)ans++; ans += get(d1) + 3 - get(d2+1); if(m1==2&amp;&amp;leap(y1)==false)ans--; if(m1==9)&#123; ans+=30-d1+1; &#125; if(m2==9)&#123; ans += d2; &#125; int tmp = nine(y1); if(tmp)&#123; int day = mon[m2-1]-mon[m1] + (hh[m1] - d1 + 1) + d2; if(leap(y1)&amp;&amp;2&gt;m1&amp;&amp;2&lt;m2)day++; if(leap(y1)&amp;&amp;m1==2)day++; ans += day*tmp; &#125; printf(&quot;%d\n&quot;, ans); &#125;else&#123; int ans = pre1[y2-1]-pre1[y1]; int a = 0, b = 0, tmp = nine(y1),day; a = pre2[12]-pre2[m1]; a += get(d1); if(leap(y1)==0&amp;&amp;m1==2)a--; if(leap(y1)&amp;&amp;m1==1)a++; if(m1==9)a += 30-d1+1; b = pre2[m2-1]; b += 3-get(d2+1); if(leap(y2)&amp;&amp;m2&gt;2)b++; if(m2==9)b+=d2; if(tmp)&#123; day = mon[12]-mon[m1] + (hh[m1] - d1 + 1); if(leap(y1)&amp;&amp;m1&lt;=2)day++; a += tmp * day; &#125; tmp = nine(y2); if(tmp)&#123; day = mon[m2-1] + d2; if(leap(y2)&amp;&amp;m2&gt;2)day++; b += tmp * day; &#125; ans += a+b; printf(&quot;%d\n&quot;, ans); &#125; &#125; return 0;&#125; F - Knuth-Morris-Pratt Algorithm ZOJ - 3957 ç­¾åˆ°é¢˜ï¼ŒKMPï¼Œåˆ¤æ–­ä¸€ä¸‹æ¬¡æ•°å°±è¡Œã€‚æš´åŠ›åˆ¤æ–­ä¹Ÿæ²¡äº‹ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;char ch1[]=&quot;dog&quot;,ch2[]=&quot;cat&quot;;int nex[2000];void get_next(char *t,int lent)&#123; nex[0] = -1; for(int i = 0,k = -1;i &lt; lent;)&#123; if(k==-1||t[i] == t[k])&#123; ++k;++i; nex[i]=k; &#125;else k = nex[k]; &#125;&#125;int kmp(char *s,int lens,char *t,int lent)&#123; if(lens&lt;lent)return 0; get_next(t,lent); int i = 0, j = 0; int cnt = 0; while(i &lt; lens&amp;&amp;j&lt;lent) &#123; if(j==-1||s[i] == t[j])&#123; i++;j++; if(j==lent)&#123; cnt++; j = nex[j]; &#125; &#125;else j=nex[j]; &#125; return cnt;&#125;int main() &#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; char s[2000]; scanf(&quot;%s&quot;,s); int l=strlen(s); int ans=0; ans+=kmp(s,l,ch1,3); ans+=kmp(s,l,ch2,3); printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125; G - Intervals ZOJ - 3953 è´ªå¿ƒï¼ŒçœŸçš„è´ªçš„å†…å¿ƒå´©æºƒã€‚è´ªå¿ƒç­–ç•¥ï¼ŒæŒ‰Læ’åºï¼Œæ¯æ¬¡åˆ¤æ–­3ä¸ªåŒºé—´ï¼Œå¦‚æœå‡ºç°3ä¸ªé‡åˆï¼Œä¸¢å» Ræœ€å¤§çš„ï¼Œå› ä¸ºå½±å“æœ€å¤§ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;struct seg &#123; int st,en,id; bool operator &lt; (const seg a )const &#123; return en&lt;a.en; &#125;&#125; sg[maxn];bool cmp(seg a,seg b) &#123; if(a.st==b.st) &#123; return a.en&lt;b.en; &#125; return a.st&lt;b.st;&#125;int res[maxn];int main() &#123; int n,t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d%d&quot;,&amp;sg[i].st,&amp;sg[i].en); sg[i].id=i+1; &#125; sort(sg,sg+n,cmp); priority_queue&lt;seg&gt;q; int ans=0; for(int i=0; i&lt;n; i++) &#123; if(q.size()&lt;2) &#123; q.push(sg[i]); &#125; else &#123; q.push(sg[i]); seg s[3]; for(int i=0; i&lt;3; i++) &#123; s[i]=q.top(); q.pop(); &#125; if(s[0].st&lt;=s[2].en&amp;&amp;s[1].st&lt;=s[2].en) &#123; res[ans++]=s[0].id; q.push(s[1]); q.push(s[2]); &#125; else &#123; q.push(s[0]); q.push(s[1]); &#125; &#125; &#125; sort(res,res+ans); printf(&quot;%d\n&quot;,ans); for(int i=0; i&lt;ans; i++) &#123; printf(&quot;%d&quot;,res[i]); if(i+1==ans)printf(&quot;\n&quot;); else printf(&quot; &quot;); &#125; if(ans==0)puts(&quot;&quot;); &#125; return 0;&#125; H - Seven-Segment Display ZOJ - 3954 é¢˜æ„ ï¼š1-9ä¹ä¸ªæ•°ï¼Œåˆ†åˆ«å¯ä»¥ç”¨åé¢7ä¸ª0 1è¡¨ç¤ºï¼Œä¸‹é¢ç»™ä½ nä¸ªæ•°ï¼Œæ¯ä¸ªæ•°åé¢è·Ÿæœ‰7ä¸ª01ä¸²ï¼Œä½ å¯ä»¥äº¤æ¢nä¸ªæ•°ä»»æ„ä¸¤åˆ—ã€‚å¦‚æœå¯ä»¥é€šè¿‡äº¤æ¢è¡¨ç¤ºå‡ºæ¥è¾“å‡ºYES å¦åˆ™NOã€‚ ä¾‹å­ : 17 0101011 1 1101011 æŠŠç¬¬2åˆ—å’Œç¬¬5åˆ—äº¤æ¢ï¼Œå˜æˆ 11 1001111 7 0001111 ä¸1 7 çš„è¡¨ç¤ºåŒ¹é…ï¼Œæ‰€ä»¥è¾“å‡ºYES é¢˜è§£ï¼šè¿™é¢˜åªæœ‰9ä¸ªæ•°ï¼Œæš´åŠ›å•ŠåŒ¹é…ï¼Œn^2éƒ½ä¸ä¼šè¶…æ—¶ã€‚ã€‚ã€‚ï¼›æˆ‘æ˜¯æŠŠæ¯ä¸€åˆ—çš„çŠ¶æ€ç”¨ä¸€ä¸ª10è¿›åˆ¶æ•°ä¿å­˜ï¼Œæ¯æ¬¡èƒ½å¤Ÿä»åŸæ¥çš„æ•°é‡Œé¢æ‰¾ä¸ä¹‹åŒ¹é…çš„çŠ¶æ€ï¼Œå¦‚æœæ‰¾ä¸åˆ°ï¼Œå°±è¾“å‡ºNOï¼› 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int mp[10];int n;int k[10],v[10];int p[10];map&lt;int,int&gt; m;int main() &#123; mp[1]=1001111; mp[2]=10010; mp[3]=110; mp[4]=1001100; mp[5]=100100; mp[6]=100000; mp[7]=1111; mp[8]=0; mp[9]=100; int t; p[0]=1; for(int i=1; i&lt;10; i++) &#123; p[i]=p[i-1]*10; &#125; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d%d&quot;,&amp;k[i],&amp;v[i]); &#125; m.clear(); for(int i=0; i&lt;7; i++) &#123; int sum=0; for(int j=0; j&lt;n; j++) &#123; sum+=mp[k[j]]/p[i]%10*p[j]; &#125; m[sum]++; &#125; int flag=1; for(int i=0; i&lt;7; i++) &#123; int sum=0; for(int j=0; j&lt;n; j++) &#123; sum+=v[j]/p[i]%10*p[j]; &#125; m[sum]--; if(m[sum]&lt;0) &#123; flag=0; break; &#125; &#125; puts(flag?&quot;YES&quot;:&quot;NO&quot;); &#125; return 0;&#125; J - Course Selection System ZOJ - 3956 å‚»é€¼é¢˜,ä¸€å¼€å§‹è¿˜åœ¨æƒ³æ€ä¹ˆæ¨å…¬å¼ï¼Œç»“æœå‘ç°ï¼ŒCIçš„å’Œåªæœ‰5e4ï¼Œæšä¸¾æ‰€ç”¨èƒ½å¤Ÿåˆ°çš„çŠ¶æ€H çš„å’Œæœ€å¤§ä¸ä¹…è¡Œäº†ï¼Œç›´æ¥è½¬æ¢æˆäº† 0 1 èƒŒåŒ…ã€‚ã€‚ã€‚ã€‚ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e4+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;int a[maxn];int x[maxn],y[maxn];int main() &#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]); &#125; mem(a,-1); a[0]=0; for(int i=0; i&lt;n; i++) &#123; for(int j=5e4-y[i]; j&gt;=0; j--) &#123; if(a[j]!=-1) &#123; a[j+y[i]]=max(a[j+y[i]],a[j]+x[i]); &#125; &#125; &#125; ll ans=0; for(ll i=1;i&lt;=5e4;i++)&#123; if(a[i]!=-1) ans=max(ans,1LL*a[i]*a[i]-i*a[i]-i*i); &#125; printf(&quot;%lld\n&quot;,ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCPC2018ä¸­å›½å¤§å­¦ç”Ÿç¨‹åºè®¾è®¡ç«èµ› - ç½‘ç»œé€‰æ‹”èµ›]]></title>
    <url>%2F2018%2F08%2F27%2FCCPC2018%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%20-%20%E7%BD%91%E7%BB%9C%E9%80%89%E6%8B%94%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[HDU 6438 1001 Buy and Resell Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 2282 Accepted Submission(s): 359 Problem Description The Power Cube is used as a stash of Exotic Power. There are n cities numbered 1,2,â€¦,n where allowed to trade it. The trading price of the Power Cube in the i-th city is ai dollars per cube. Noswal is a foxy businessman and wants to quietly make a fortune by buying and reselling Power Cubes. To avoid being discovered by the police, Noswal will go to the i-th city and choose exactly one of the following three options on the i-th day: spend ai dollars to buy a Power Cube resell a Power Cube and get ai dollars if he has at least one Power Cube do nothing Obviously, Noswal can own more than one Power Cubes at the same time. After going to the n cities, he will go back home and stay away from the cops. He wants to know the maximum profit he can earn. In the meanwhile, to lower the risks, he wants to minimize the times of trading (include buy and sell) to get the maximum profit. Noswal is a foxy and successful businessman so you can assume that he has infinity money at the beginning. Input There are multiple test cases. The first line of input contains a positive integer T (Tâ‰¤250), indicating the number of test cases. For each test case: The first line has an integer n. (1â‰¤nâ‰¤105) The second line has n integers a1,a2,â€¦,an where ai means the trading price (buy or sell) of the Power Cube in the i-th city. (1â‰¤aiâ‰¤109) It is guaranteed that the sum of all n is no more than 5Ã—105. Output For each case, print one line with two integers â€”â€” the maximum profit and the minimum times of trading to get the maximum profit. Sample Input 1 3 4 1 2 10 9 5 9 5 9 10 5 2 2 1 Sample Output 1 16 4 5 2 0 0 _Hint_ In the first case, he will buy in 1, 2 and resell in 3, 4. _profit = - 1 - 2 + 10 + 9 = 16_ In the second case, he will buy in 2 and resell in 4. _profit = - 5 + 10 = 5_ In the third case, he will do nothing and earn nothing. _profit = 0_ è´ªå¿ƒï¼Œæ¯æ¬¡ä¿ç•™ä¹°ï¼Œå’Œå–ä¸¤ç§çŠ¶æ€ï¼Œå¦‚æœä¸€ç§ä¹°äº†ï¼Œè¯´æ˜åé¢æœ‰ä¸€å®šæœ‰å¯ä»¥å–çš„ï¼Œä»å‰å¾€åæ‰«æ¯æ¬¡å–å‰é¢æœ€å°çš„ï¼Œå¦‚æœé‡è§èƒ½ä»å–äº†çš„é‡Œé¢å–ï¼Œæ€»æ¬¡æ•°ä¸ç”¨+2ï¼Œå¦‚æœæ˜¯ä»ä¹°äº†çš„é‡Œé¢å–ï¼Œæ€»äº¤æ˜“æ¬¡æ•°+2ï¼› ç”¨ï¼Œ0ï¼Œ1åˆ†åˆ«ä»£è¡¨ä¹°å’Œå–ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int a[maxn];int n;priority_queue&lt;P&gt;q;ll sum=0,ans=0;int main() &#123; int t; cin&gt;&gt;t; while(t--) &#123; sum=0; ans=0; scanf(&quot;%d&quot;,&amp;n); while(q.size())q.pop(); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); q.push(P(-a[i],0)); q.push(P(-a[i],1)); int temp=a[i]+q.top().first; if(q.top().second==0) &#123; ans+=2; &#125; q.pop(); sum+=temp; &#125; printf(&quot;%lld %lld\n&quot;,sum,ans); &#125; return 0;&#125; HDU 6441 1004 Find Integer æ›´å…·è´¹é©¬å¤§å®šç†ï¼Œn&gt;2 å’Œç­‰äº 0è¯¯è§£ï¼Œn=1ï¼Œç›´æ¥è¾“å‡º 1 a+1; n=2 çš„æ—¶å€™ï¼Œå°±æ˜¯ä¸€ä¸ªå‹¾è‚¡å®šç†ï¼Œa^2=cc-bb = (c-b)(c+b) å¦‚æœAä¸ºå¶æ•° c-b=2 c+b=aa/2 ,å¦‚æœaä¸ºå¥‡æ•° c-b=1 c+b=a*a è§£ä¸ªæ–¹ç¨‹å°±è¡Œäº†ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int main() &#123; int t; cin&gt;&gt;t; while(t--) &#123; ll n,k; scanf(&quot;%lld%lld&quot;,&amp;k,&amp;n); if(k==0||k&gt;2)puts(&quot;-1 -1&quot;); else if(k==1) &#123; if(n==1e9)puts(&quot;-1 -1&quot;); else printf(&quot;%lld %lld\n&quot;,1,n+1); &#125; else &#123; ll temp=n; if(n==1||n==2)puts(&quot;-1 -1&quot;); else if(n&amp;1) &#123; ll c=(temp*temp+1)/2; ll b=c-1; if(c&gt;1e9)puts(&quot;-1 -1&quot;); else &#123; printf(&quot;%lld %lld\n&quot;,b,c); &#125; &#125; else &#123; ll c=n*n/4+1,b=c-2; if(c&gt;1e9)puts(&quot;-1 -1&quot;); else printf(&quot;%lld %lld\n&quot;,b,c); &#125; &#125; &#125; return 0;&#125; HDU 6446 1009 Tree and Permutation ç›´æ¥ç®—ä¸€æ¡è¾¹å·¦å³ä¸¤è¾¹ç‚¹çš„ä¸ªæ•°ï¼Œå…¨æ’åˆ—ç§ï¼Œæ¯æ¡è¾¹ç»è¿‡çš„æ¬¡æ•°ç­‰äº ï¼Œ2C,(n-m)(m)*(n-1)ï¼æ¬¡ï¼Œä¸€ä¸ªDFSæ±‚å‡ºä»–æ ¹èŠ‚ç‚¹çš„æ•°é‡ä¸ºmï¼Œå‰ä¸€æ¡è¾¹ æƒå€¼ä¸ºC,æ±‚ä¸€ä¸‹æ‰€æœ‰æ•°çš„å’Œï¼Œé¢„å¤„ç†é˜¶ä¹˜ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;struct edge &#123; int to,cost,next;&#125; eg[maxn];int head[maxn],tot;void init() &#123; mem(head,-1); tot=0;&#125;void add(int u,int v,int c) &#123; eg[tot].to=v; eg[tot].cost=c; eg[tot].next=head[u]; head[u]=tot++;&#125;ll k[maxn];ll c[maxn],num[maxn];int dfs(int r,int p,int v) &#123; c[r]=v%mod; int ans=1; for(int i=head[r]; i!=-1; i=eg[i].next) &#123; if(eg[i].to!=p) &#123; ans+=dfs(eg[i].to,r,eg[i].cost); &#125; &#125; num[r]=ans%mod; return ans;&#125;int main() &#123; k[1]=1; for(int i=2; i&lt;=1e5; i++) &#123; k[i]=k[i-1]*i%mod; &#125; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; init(); for(int i=1; i&lt;n; i++) &#123; int u,v,c; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;c); add(u,v,c); add(v,u,c); &#125; dfs(1,-1,0); ll sum=0; for(int i=2; i&lt;=n; i++) &#123; sum+=2*c[i]*num[i]%mod*(n-num[i])%mod*k[n-1]%mod; sum%=mod; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç¬¬ä¹å±Šç¦å»ºçœå¤§å­¦ç”Ÿç¨‹åºè®¾è®¡ç«èµ›-é‡ç°èµ›ï¼ˆæ„Ÿè°¢æ‰¿åŠæ³‰å·å¸ˆèŒƒå­¦é™¢ï¼‰]]></title>
    <url>%2F2018%2F08%2F26%2F%E7%AC%AC%E4%B9%9D%E5%B1%8A%E7%A6%8F%E5%BB%BA%E7%9C%81%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-%E9%87%8D%E7%8E%B0%E8%B5%9B%EF%BC%88%E6%84%9F%E8%B0%A2%E6%89%BF%E5%8A%9E%E6%B3%89%E5%B7%9E%E5%B8%88%E8%8C%83%E5%AD%A6%E9%99%A2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[A - Uint47 calculator FZU - 2294 æ°´é¢˜ï¼Œç”¨unsigned long long,è‡ªå¸¦è‡ªåŠ¨æº¢å‡ºï¼Œç„¶åå°±å¯ä»¥éšä¾¿å†™äº†ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));ull mod=1;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;string s;map&lt;string,ull&gt; mp;int main() &#123; char op[100]; string tx,ty; ull x,y; for(int i=1;i&lt;48;i++)&#123; mod*=2; &#125; while(~scanf(&quot;%s&quot;,op)) &#123; if(op[0]==&apos;d&apos;&amp;&amp;op[1]==&apos;e&apos;) &#123; //def cin&gt;&gt;s&gt;&gt;x; mp[s]=x; cout&lt;&lt;s&lt;&lt;&quot; = &quot;&lt;&lt;x&lt;&lt;&apos;\n&apos;; &#125; else if(op[0]==&apos;s&apos;) &#123; //sub cin&gt;&gt;tx&gt;&gt;ty; x=mp[tx]; y=mp[ty]; mp[tx]=x=(x-y+mod)%mod; cout&lt;&lt;tx&lt;&lt;&quot; = &quot;&lt;&lt;x&lt;&lt;&apos;\n&apos;; &#125; else if(op[0]==&apos;a&apos;) &#123; cin&gt;&gt;tx&gt;&gt;ty; x=mp[tx]; y=mp[ty]; mp[tx]=x=(x+y)%mod; cout&lt;&lt;tx&lt;&lt;&quot; = &quot;&lt;&lt;x&lt;&lt;&apos;\n&apos;; &#125; else if(op[0]==&apos;m&apos;&amp;&amp;op[1]==&apos;u&apos;) &#123; cin&gt;&gt;tx&gt;&gt;ty; x=mp[tx]; y=mp[ty]; mp[tx]=x=(x*y)%mod; cout&lt;&lt;tx&lt;&lt;&quot; = &quot;&lt;&lt;x&lt;&lt;&apos;\n&apos;; &#125; else if(op[0]==&apos;d&apos;) &#123; cin&gt;&gt;tx&gt;&gt;ty; x=mp[tx]; y=mp[ty]; mp[tx]=x=(x/y)%mod; cout&lt;&lt;tx&lt;&lt;&quot; = &quot;&lt;&lt;x&lt;&lt;&apos;\n&apos;; &#125; else &#123; cin&gt;&gt;tx&gt;&gt;ty; x=mp[tx]; y=mp[ty]; mp[tx]=x=x%y; cout&lt;&lt;tx&lt;&lt;&quot; = &quot;&lt;&lt;x&lt;&lt;&apos;\n&apos;; &#125; &#125; return 0;&#125; B - Human life FZU - 2295 æœ€å¤§æƒé—­åˆå­å›¾ï¼Œkåªæœ‰5æš´åŠ›æšä¸¾æ‰€æœ‰çŠ¶æ€ã€‚ç„¶åå°±æ˜¯ä¸€ä¸ªè£¸é¢˜äº†ã€‚ ç­”æ¡ˆ æ˜¯æœ€å¤§æ­£æƒå€¼-å»æœ€å¤§æµã€‚å¦‚æœæœ‰äººæƒ³äº†è§£ä¸ºå•¥ï¼Œè‡ªè¡Œç™¾åº¦å§ã€‚ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e3+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int v[maxn];int pre[maxn][maxn];int u[maxn];int n,m,K;int a[2][5];int ku[maxn];vector&lt;int&gt; tv[maxn];struct edge &#123; int to,cap,rev;&#125;;vector &lt;edge&gt; G[maxn];int level[maxn];int iter[maxn];void init(int _n) &#123; for(int i=0; i&lt;=_n; i++) &#123; G[i].clear(); tv[i].clear(); &#125; mem(pre,0); mem(u,0);&#125;void init()&#123; for(int i=0;i&lt;=n+m+1;i++)G[i].clear();&#125;void bfs(int s) &#123; memset(level,-1,sizeof(level)); queue&lt;int&gt; que; level[s]=0; que.push(s); while(!que.empty()) &#123; int v= que.front(); que.pop(); for(int i=0; i&lt;G[v].size(); i++) &#123; edge &amp; e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0) &#123; level[e.to]=level[v] + 1; que.push(e.to); &#125; &#125; &#125;&#125;void add(int from,int to,int cap) &#123; edge eg; eg.to=to; eg.cap=cap; eg.rev=G[to].size(); G[from].push_back(eg); eg.to=from; eg.cap=0; eg.rev=G[from].size()-1; G[to].push_back(eg);&#125;int dfs(int v,int t,int f) &#123; if(v == t)return f; for(int &amp;i = iter[v]; i &lt; G[v].size(); i++) &#123; edge &amp;e=G[v][i]; if(e.cap&gt;0 &amp;&amp; level[v]&lt;level[e.to]) &#123; int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0) &#123; e.cap-=d; G[e.to][e.rev].cap+=d; return d; &#125; &#125; &#125; return 0;&#125;int maxflow(int s,int t) &#123; int flow=0; for(;;) &#123; bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while((f = dfs(s,t,INF))&gt;0) &#123; flow +=f; &#125; &#125;&#125;void dfs(int r) &#123; u[r]=1; for(int i=1; i&lt;=n; i++) &#123; if(pre[r][i]) &#123; if(u[i]==0) &#123; dfs(i); &#125; for(int j=1; j&lt;=n; j++) &#123; pre[r][j]|=pre[i][j]; &#125; &#125; &#125;&#125;int main() &#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;K); init(n+m+1); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;v[i]); int k; scanf(&quot;%d&quot;,&amp;k); if(k==0)u[i]=1; for(int j=0; j&lt;k; j++) &#123; int x; scanf(&quot;%d&quot;,&amp;x); pre[i][x]=1; &#125; &#125; for(int i=1; i&lt;=n; i++) &#123; if(u[i]==0) &#123; dfs(i); &#125; &#125; for(int i=n+1; i&lt;=n+m; i++) &#123; scanf(&quot;%d&quot;,&amp;v[i]); int k; bool tu[maxn]= &#123;0&#125;; scanf(&quot;%d&quot;,&amp;k); for(int j=0; j&lt;k; j++) &#123; int x; scanf(&quot;%d&quot;,&amp;x); if(tu[x])continue; tu[x]=1; for(int l=1; l&lt;=n; l++) &#123; tu[l]|=pre[x][l]; &#125; &#125; for(int j=1; j&lt;=n; j++) &#123; if(tu[j]) &#123; tv[i].push_back(j); &#125; &#125; &#125; for(int i=0; i&lt;K; i++) &#123; scanf(&quot;%d%d&quot;,&amp;a[0][i],&amp;a[1][i]); &#125; int mx=0; for(int i=0; i&lt;1&lt;&lt;K; i++) &#123; mem(ku,0); init(); for(int j=0; j&lt;K; j++) &#123; ku[a[(i&gt;&gt;j)&amp;1][j]+n]=1;// debug(a[(i&gt;&gt;j)&amp;1][j]+n); &#125; int sum=0; for(int i=n+1; i&lt;=n+m; i++) &#123; if(ku[i]==1)continue;// debug(i); add(0,i,v[i]); for(int j=0; j&lt;tv[i].size(); j++) &#123; add(i,tv[i][j],inf); &#125; sum+=v[i]; &#125; for(int i=1; i&lt;=n; i++)add(i,n+m+1,v[i]); mx=max(sum-maxflow(0,n+m+1),mx); &#125; printf(&quot;%d\n&quot;,mx); &#125; return 0;&#125; D - Number theory FZU - 2297 ä¸€å¼€å§‹è¿˜ä»¥ä¸ºæ˜¯å¤§æ•°ï¼Œjava äº†ä¸€å‘ï¼Œå¤§æ•°äº†ä¸€å‘ï¼Œå…¨éƒ½TLEï¼Œæ­£è§£å°±æ˜¯ä¸€ä¸ªçº¿æ®µæ ‘ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e3+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int c[maxn][maxn];int q[maxn][maxn];int b2[maxn];long long pow(long long x,long long n,long long mod=1e9+7) &#123; long long res=1; while(n&gt;0) &#123; if(n&amp;1)res=res*x%mod; x=x*x%mod; n&gt;&gt;=1; &#125; return res%mod;&#125;int main() &#123; c[1][1]=1; c[1][0]=1; for(int i=1; i&lt;1e3+1; i++) &#123; c[i+1][0]=1;// printf(&quot;%d &quot;,c[i+1][0]); for(int j=1; j&lt;=i+1; j++) &#123; c[i+1][j]=(c[i][j-1]+c[i][j])%mod;// printf(&quot;%d &quot;,c[i+1][j]); &#125; &#125; for(int i=1; i&lt;1e3+1; i++) &#123; for(int j=0; j&lt;=i; j++) &#123; q[i][j+1]=(q[i][j]+c[i][j])%mod; &#125; &#125; b2[0]=1; for(int i=1; i&lt;1e3+1; i++) &#123; b2[i]=(b2[i-1]*2)%mod; &#125; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); if(m&gt;n) &#123; puts(&quot;0&quot;); &#125; else &#123; cout&lt;&lt;(q[n][n+1]-q[n][m]+mod)%mod*pow(b2[n],mod-2,mod)%mod&lt;&lt;endl; &#125; &#125; return 0;&#125; E - Traffic jamFZU - 2298 æœ€çŸ­è·¯ï¼Œå¤„ç†ä¸‹åˆ°æŸä¸ªç‚¹çš„æƒ…å†µï¼Œå¦‚æœæ˜¯çº¢ç¯ï¼Œæ—¶é—´å˜ä¸ºåˆ°ç»¿ç¯å¼€å§‹ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int a[maxn];int cost[maxn];int n,m;struct edge &#123; int to,c,next;&#125; eg[maxn*2];int head[maxn],tot,vis[maxn];void init() &#123; mem(head,-1); tot=0;&#125;void add(int u,int v,int c) &#123; eg[tot].to=v; eg[tot].c=c; eg[tot].next=head[u]; head[u]=tot++;&#125;int main() &#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; init(); for(int i=0; i&lt;m; i++) &#123; int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); add(a,b,c); add(b,a,c); &#125; int st,en; scanf(&quot;%d%d&quot;,&amp;st,&amp;en); queue&lt;int&gt; q; q.push(st); mem(cost,inf); mem(vis,0); cost[st]=0; while(q.size()) &#123; int v=q.front(); q.pop(); vis[v]=0; for(int i=head[v]; i!=-1; i=eg[i].next) &#123; int d=cost[v]+eg[i].c,to=eg[i].to; if(to!=en&amp;&amp;(d/a[to])&amp;1)d=(d/a[to]+1)*a[to]; if(d&lt;cost[to]) &#123; cost[to]=d; if(vis[to]==0) &#123; vis[to]=1; q.push(to); &#125; &#125; &#125; &#125; printf(&quot;%d\n&quot;,cost[en]); &#125; return 0;&#125; G - IoU FZU - 2300 ç­¾åˆ°é¢˜ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));ull mod=1;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;string s;map&lt;string,ull&gt; mp;int T;struct node &#123; ll x,y,w,h;&#125;a[3];int main() &#123; scanf(&quot;%d&quot;, &amp;T); while (T --) &#123; scanf(&quot;%lld %lld %lld %lld&quot;, &amp;a[0].x,&amp;a[0].y,&amp;a[0].w,&amp;a[0].h); scanf(&quot;%lld %lld %lld %lld&quot;, &amp;a[1].x,&amp;a[1].y,&amp;a[1].w,&amp;a[1].h); ll wi = (min(a[0].x+a[0].w, a[1].x+a[1].w)-max(a[0].x, a[1].x)); ll hi = (min(a[0].y+a[0].h, a[1].y+a[1].h)-max(a[0].y, a[1].y)); ll un; if(wi &gt; 0 &amp;&amp; hi &gt; 0) un = wi*hi; else un = 0; //debug(un); ll sum = a[0].w*a[0].h+a[1].w*a[1].h-un; //debug(sum); printf(&quot;%.2f\n&quot;, 1.0*un/sum); &#125; return 0;&#125;/*61 1 1 11 1 2 21 1 2 11 1 1 21 1 2 22 0 1 10 3 3 32 2 2 10 3 3 32 4 5 51 1 1 1-100 -100 1 1*/ H - Chosen by god FZU - 2301 é¢˜æ„ï¼šnç‚¹ä¼¤å®³éšæœºåˆ†é…ï¼Œæ±‚åˆ†é…åˆ°æ•Œäººèº«ä¸Šå¤§äºç­‰äºmï¼Œçš„æœŸæœ›ï¼Œå°±æ˜¯æ±‚C(M,N)+â€¦+C(M,N); é¢˜è§£ï¼šæ‰“ä¸ªç»„åˆæ•°çš„è¡¨ï¼Œç„¶åå‰ç¼€å¤„ç†ä¸€ä¸‹ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e3+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int c[maxn][maxn];int q[maxn][maxn];int b2[maxn];long long pow(long long x,long long n,long long mod=1e9+7) &#123; long long res=1; while(n&gt;0) &#123; if(n&amp;1)res=res*x%mod; x=x*x%mod; n&gt;&gt;=1; &#125; return res%mod;&#125;int main() &#123; c[1][1]=1; c[1][0]=1; for(int i=1; i&lt;1e3+1; i++) &#123; c[i+1][0]=1;// printf(&quot;%d &quot;,c[i+1][0]); for(int j=1; j&lt;=i+1; j++) &#123; c[i+1][j]=(c[i][j-1]+c[i][j])%mod;// printf(&quot;%d &quot;,c[i+1][j]); &#125; &#125; for(int i=1; i&lt;1e3+1; i++) &#123; for(int j=0; j&lt;=i; j++) &#123; q[i][j+1]=(q[i][j]+c[i][j])%mod; &#125; &#125; b2[0]=1; for(int i=1; i&lt;1e3+1; i++) &#123; b2[i]=(b2[i-1]*2)%mod; &#125; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); if(m&gt;n) &#123; puts(&quot;0&quot;); &#125; else &#123; cout&lt;&lt;(q[n][n+1]-q[n][m]+mod)%mod*pow(b2[n],mod-2,mod)%mod&lt;&lt;endl; &#125; &#125; return 0;&#125; J - Mind control FZU - 2303 é¢˜æ„ï¼šnä¸ªäººï¼Œmä¸ªè›‹ç³•ï¼Œä½ æŠŠè›‹ç³•ç»™ä¸€ä¸ªäººï¼Œä»–åé¢çš„äººä¹Ÿä¼šè¢«é€‰ä¸Šï¼Œä¾‹å¦‚é€‰1 ï¼Œ2 3 4 5 â€¦.ç­‰éƒ½ä¼šè¢«é€‰ä¸Šï¼Œé€‰ 3 4 5 â€¦éƒ½ä¼šè¢«é€‰ä¸Šï¼Œæ±‚é€‰ä¸Šäººæ•°çš„æœŸæœ›ã€‚ é¢˜è§£ï¼šç»™è›‹ç³•çš„æ€»è‚¯èƒ½æ˜¯Cï¼ˆM,Nï¼‰ï¼Œé€‰çš„äººæœ€é«˜ä¸º1 çš„é€‰æ‹©ç§æ•°æ˜¯ï¼ŒCï¼ˆM-1,N-1ï¼‰ï¼Œé€‰ä¸€ä¸ªè›‹ç³•ç»™1ï¼Œç„¶åå…¶ä»–è›‹ç³•ç»™ä»–åé¢çš„äººï¼Œä»¥æ­¤ç±»æ¨ï¼Œæœ€é«˜ä¸º2 é€‰æ‹©ç§æ•°æ˜¯ ,C(M-1,N-2)ï¼Œæœ€é«˜ä¸º3 å¯èƒ½æ˜¯ Cï¼ˆm-1,N-3ï¼‰; ç„¶åæƒå€¼ä¹˜ä»¥æ¦‚ç‡å°±æ˜¯æœŸæœ› ï¼ŒNC(M-1,N-1)+(N-1)C(M-1,N-2)+â€¦.+M*C(M-1,M-1)/C(M,N)ï¼› çœ‹åˆ°æƒå€¼æ˜¯ N,N-1è‚¯å®šè¦åŒ–è¿›ç»„åˆæ•° ï¼Œå¤§ç­”æ¡ˆm/m, å°±å¯ä»¥åŒ–æˆMC(M,N)+M(M,N-1)+â€¦..+MC(M,M)/C(M,N)ï¼› åœ¨åŒ–ç®€ MC(M+1,N+1)/C(M,N)æœ€ååŒ–ä¸ºM(N+1)/(M+1)ï¼› 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;long long pow(long long x,long long n,long long mod=1e9+7) &#123; long long res=1; while(n&gt;0) &#123; if(n&amp;1)res=res*x%mod; x=x*x%mod; n&gt;&gt;=1; &#125; return res%mod;&#125;void read(ll &amp;sum) &#123; sum=0; int flag=0; char ch=getchar(); while(!(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)) &#123; if (ch == &apos;-&apos;) &#123; flag = 1; &#125; ch=getchar(); &#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)sum=sum*10+ch-48,ch=getchar(); if(flag)sum*=-1;&#125;int main() &#123; ll t; read(t); while(t--) &#123; ll n,m; read(n); read(m); cout&lt;&lt;m*(n+1)%mod*pow(m+1,mod-2,mod)%mod&lt;&lt;&quot;\n&quot;; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016CCPCä¸œåŒ—åœ°åŒºå¤§å­¦ç”Ÿç¨‹åºè®¾è®¡ç«èµ› - é‡ç°èµ›]]></title>
    <url>%2F2018%2F08%2F23%2F2016CCPC%E4%B8%9C%E5%8C%97%E5%9C%B0%E5%8C%BA%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%20-%20%E9%87%8D%E7%8E%B0%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[A é¢˜ç›®è¿æ¥ï¼šHDU 5922 Minimumâ€™s Revenge æ°´é¢˜ï¼Œæ¯æ¬¡è¿æ¥ä¸Š1å°±è¡Œï¼Œå°±æ˜¯ä¸€ä¸ªç­‰å·®æ•°åˆ—ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int main() &#123; int n,t,cas=1; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d&quot;,&amp;n); ll res=n; printf(&quot;Case #%d: %lld\n&quot;,cas++,(res+2)*(res-1)/2); &#125; return 0;&#125; B é¢˜ç›®é“¾æ¥ï¼šHDU 5923 Prediction é¢˜æ„ï¼šä¸€æ£µæ ‘ï¼Œæ¯ä¸ªç‚¹ä»£è¡¨ä¸€æ¡è¾¹ï¼Œæ¯æ¬¡é€‰æ‹©å‡ ä¸ªç‚¹ï¼Œéœ€è¦æŠŠä»–çš„ç¥–å…ˆä¹Ÿé€‰ä¸Šï¼Œç„¶åæŠŠå›¾é‡Œé¢ç›¸åº”çš„è¾¹è¿æ¥ä¸Šï¼Œé—®è¿æ¥åçš„å›¾æœ‰å¤šå°‘ä¸ªè”é€šå—ã€‚ é¢˜è§£ï¼šå¯æŒç»­åŒ–å¹¶æŸ¥é›†ï¼Œæ¯ä¸ªé¡¶ç‚¹å¼€ä¸€ä¸ªå¹¶æŸ¥é›†ï¼Œç»´æŠ¤ä»æ ¹èŠ‚ç‚¹åˆ°å½“å‰èŠ‚ç‚¹å·²ç»è¿æ¥çš„å›¾ï¼Œå†æŠŠè‡ªå·±è¿™æ¡è¾¹è¿ä¸Šã€‚ æŸ¥è¯¢ï¼ŒæŠŠæ‰€æœ‰ç‚¹çš„å¹¶æŸ¥é›†åˆå¹¶ä¸€ä¸‹å°±å¯ä»¥ï¼Œç„¶åè¾“å‡ºåˆå¹¶åå¹¶æŸ¥é›†å—çš„ä¸ªæ•°ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 #include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=5e2+2;const int maxm=1e4+5;bool u[maxm];int par[maxm][maxn];struct node &#123; int x,y; int fa;&#125; tree[maxm];int n,m;int find(int y,int x) &#123; return par[y][x]==x?x:par[y][x]=find(y,par[y][x]);&#125;void dfs(int x) &#123; int fa=tree[x].fa; u[x]=1; if(u[fa]==0) &#123; dfs(fa); &#125; else &#123; if(x==1) &#123;// cout&lt;&lt;&quot;1asd&quot;&lt;&lt;endl; for(int i=0; i&lt;=n; i++)par[1][i]=i; par[1][tree[x].x]=tree[x].y; &#125; else &#123; for(int i=0; i&lt;=n; i++)par[x][i]=par[fa][i]; int X=find(x,tree[x].x),Y=find(x,tree[x].y); if(X!=Y) &#123; par[x][X]=par[x][Y]; &#125; &#125; &#125;&#125;int main() &#123; int t,cas=1; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=m; i++) &#123; if(i==1)tree[i].fa=1; else &#123; int x; scanf(&quot;%d&quot;,&amp;x); tree[i].fa=x; &#125; &#125; for(int i=1; i&lt;=m; i++) &#123; u[i]=0; scanf(&quot;%d%d&quot;,&amp;tree[i].x,&amp;tree[i].y); &#125; for(int i=1; i&lt;=m; i++) &#123; if(!u[i]) &#123; dfs(i); &#125; &#125; int q; scanf(&quot;%d&quot;,&amp;q); printf(&quot;Case #%d:\n&quot;,cas++); while(q--) &#123; int k,s; scanf(&quot;%d&quot;,&amp;k); int res=0; for(int i=0; i&lt;=n; i++)par[0][i]=i; while(k--) &#123; scanf(&quot;%d&quot;,&amp;s);// for(int i=1; i&lt;=n; i++)printf(&quot;%d &quot;,par[s][i]); for(int i=1; i&lt;=n; i++) &#123; int t1=find(0,i),t2=find(s,i); if(t1!=t2) &#123; int t3=find(0,t2); if(t3!=t1) &#123; res++; par[0][t1]=par[0][t3]; &#125; &#125; &#125; &#125; printf(&quot;%d\n&quot;,n-res); &#125; &#125; return 0;&#125; C é¢˜ç›®è¿æ¥ï¼šHUD 5924 Mr. Frogâ€™s Problem A/B+ B/A åªæœ‰åœ¨ä¸¤ä¸ªæ•°æœ€æ¥è¿‘çš„æ—¶å€™æœ€å°ï¼Œæ‰€ä»¥å¦‚æœA&lt;=C&lt;D&lt;=B,C /D+D/Cå¿…å®šå°äºäºç­‰ A/B+B/Aæ‰€ä»¥åªæœ‰å’ŒA Bç›¸åŒçš„æ—¶å€™æ‰ä¼šæ»¡è¶³æ¡ä»¶ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;ll a,b,t,n;int main() &#123; int cas=1; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;a&gt;&gt;b; printf(&quot;Case #%d:\n&quot;,cas++); if(a==b) &#123; puts(&quot;1&quot;); cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl; &#125; else &#123; puts(&quot;2&quot;); cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl; cout&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;a&lt;&lt;endl; &#125; &#125; return 0;&#125; D é¢˜ç›®è¿æ¥:HDU 5925 Coconuts é¢˜æ„ï¼šç»™ä½ ä¸€ä¸ªR*Cçš„çŸ©é˜µä¸­é—´æœ‰å‡ ä¸ªnä¸ªç‚¹ï¼Œé—®åˆ†æˆäº†å‡ ä¸ªè”é€šå—ï¼Œè”é€šå—çš„å¤§å°æ˜¯å¤šå°‘ã€‚ é¢˜è§£ï¼šRï¼ŒCèŒƒå›´æ˜¯1e9è‚¯å®šæ˜¯è¦ç¦»æ•£ï¼Œç¦»æ•£ä¹‹åå˜æˆäº†ä¸€ä¸ªä¸åˆ° 2000*2000çš„çŸ©é˜µï¼Œæ±‚è”é€šå—æ•°é‡ç›´æ¥DFSä¸€éå°±å¯ä»¥äº†ã€‚ é—®é¢˜æ¥äº†äº†ï¼Œç¦»æ•£ä¹‹åæ€ä¹ˆæ±‚æ¯ä¸ªå—çš„å¤§å°å‘¢ã€‚ é¦–å…ˆä½ æ˜¯æ ¹æ®è¡Œå’Œåˆ—åˆ†åˆ«ç¦»æ•£ï¼Œè®¡ç®—ä¸»è¦æ˜¯æŠŠç¦»æ•£æ‰çš„é‡æ–°ç®—å›æ¥ã€‚ å¦‚ä¸‹å›¾åŠ å…¥é»„è‰²æ˜¯ä½ è¢«è¦†ç›–çš„æ ¼å­ï¼Œä½ ä¼šæŠŠæ¨ªç€ç¦»æ•£é»‘è‰²çš„æ ¼å­ä¸ºä¸€ä¸ªæ ¼å­ï¼Œçº¢è‰²çš„ç«–ç€ç¦»æ•£æˆä¸€ä¸ªæ ¼å­ã€‚å› æ­¤ï¼Œä½ åªè¦æŠŠè¿™äº›ç¦»æ•£çš„æ ¼å­ä»æ–°åŠ å›æ¥å°±è¡Œäº†ï¼Œå¦å¤–è¿˜è¦åŠ ä¸Šä¸­é—´é‚£ä¸€å—è¢«ç¦»æ•£æ‰çš„ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=205;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;map&lt;int,int&gt; mpx,mpy;int x[maxn],y[maxn];int lx[maxn],ly[maxn];ll vx[maxn*10],vy[maxn*10];int mp[maxn*10][maxn*10],mx,my;int dx[]= &#123;-1,0,1,0&#125;,dy[]= &#123;0,-1,0,1&#125;;ll ans[maxn*10];void dfs(int tx,int ty,int pos) &#123; if(mp[tx][ty]!=0)return ; mp[tx][ty]=pos; ++ans[pos]; for(int i=0; i&lt;4; i++) &#123; int ttx=tx+dx[i],tty=ty+dy[i]; if(ttx&gt;0&amp;&amp;ttx&lt;=mx&amp;&amp;tty&gt;0&amp;&amp;tty&lt;=my) &#123; dfs(ttx,tty,pos); &#125; &#125;&#125;int main() &#123; int cas=1,t;// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); scanf(&quot;%d&quot;, &amp;t); while(t--) &#123; mpx.clear(); mpy.clear(); mem(ans,0); int r,c; scanf(&quot;%d%d&quot;,&amp;r,&amp;c); scanf(&quot;%d&quot;,&amp;n); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]); lx[i]=x[i]; ly[i]=y[i]; &#125; lx[n]=r; sort(lx,lx+n+1); int d=0; vx[d]=0; for(int i=0; i&lt;=n; i++) &#123; if(lx[i]==vx[d])continue; else if(lx[i]==vx[d]+1) &#123; vx[d+1]=vx[d]+1; mpx[lx[i]]=d+1; d+=1; &#125; else if(lx[i]-d==2) &#123; vx[d+1]=vx[d]+1; vx[d+2]=vx[d]+2; mpx[lx[i]]=d+2; d+=2; &#125; else &#123; vx[d+1]=vx[d]+1; vx[d+2]=lx[i]; mpx[lx[i]]=d+2; d+=2; &#125; &#125; ly[n]=c; sort(ly,ly+n+1); mx=d; d=0; vy[d]=0; for(int i=0; i&lt;=n; i++) &#123; if(ly[i]==vy[d])continue; else if(ly[i]==vy[d]+1) &#123; vy[d+1]=vy[d]+1; mpy[ly[i]]=d+1; d+=1; &#125; else if(ly[i]-d&gt;=2) &#123; vy[d+1]=vy[d]+1; vy[d+2]=ly[i]; mpy[ly[i]]=d+2; d+=2; &#125; &#125; my=d; mem(mp,0); for(int i=0; i&lt;n; i++) &#123; mp[mpx[x[i]]][mpy[y[i]]]=-1; &#125; int num=1; for(int i=1; i&lt;=mx; i++) &#123; for(int j=1; j&lt;=my; j++) &#123; if(mp[i][j]==0) &#123; dfs(i,j,num++); &#125; &#125; &#125; for(int j=1; j&lt;=my; j++) &#123; //æŠŠç¦»æ•£ç«–ç€çš„åŠ èµ·æ¥ for(int i=1; i&lt;=mx; i++) &#123; if(mp[i][j]!=-1) &#123; ans[mp[i][j]]+=vx[i]-vx[i-1]-1; &#125; else if(mp[i-1][j]!=-1) &#123; ans[mp[i-1][j]]+=vx[i]-vx[i-1]-1; &#125; &#125; &#125; for(int i=1; i&lt;=mx; i++) &#123; //æŠŠæ¨ªç€ç¦»æ•£æ‰çš„åŠ èµ·æ¥ for(int j=1; j&lt;=my; j++) &#123; if(mp[i][j]!=-1) &#123; ans[mp[i][j]]+=vy[j]-vy[j-1]-1; &#125; else if(mp[i][j-1]!=-1) &#123; ans[mp[i][j-1]]+=vy[j]-vy[j-1]-1; &#125; &#125; &#125; for(int i=1; i&lt;=mx; i++) &#123; //æŠŠä¸­é—´é‚£å—ç¦»æ•£æ‰çš„åŠ èµ·æ¥ for(int j=1; j&lt;=my; j++) &#123; if(mp[i][j]!=-1) &#123; ans[mp[i][j]]+=(vy[j]-vy[j-1]-1)*(vx[i]-vx[i-1]-1); &#125; else if(mp[i-1][j-1]!=-1) &#123; ans[mp[i-1][j-1]]+=(vy[j]-vy[j-1]-1)*(vx[i]-vx[i-1]-1); &#125; &#125; &#125; printf(&quot;Case #%d:\n%d\n&quot;,cas++,num-1); sort(ans+1,ans+num); for(int i=1; i&lt;num; i++) &#123; printf(&quot;%lld&quot;,ans[i]); if(i+1==num)printf(&quot;\n&quot;); else printf(&quot; &quot;); &#125; &#125; return 0;&#125;ä¸‹é¢æ˜¯2ç»„æ•°æ®ï¼Œæ­£ç¡®ç­”æ¡ˆèƒ½æ‰‹ç®—å‡ºæ¥/*2100 100201 501 511 551 602 502 542 562 603 503 513 553 604 514 524 534 544 564 574 584 59100 10081 22 1100 9999 10099 1100 21 992 100*/ E:é¢˜ç›®é“¾æ¥ HDU 5926 Mr. Frogâ€™s Game æ°´é¢˜ä¸è§£é‡Šäº†ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int ar[35][35];int n,m;int dir[4][2]=&#123;1,0,0,1,-1,0,0,-1&#125;;int main() &#123; int cas=1,t; scanf(&quot;%d&quot;, &amp;t); while(t--) &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=0;i&lt;n;++i)&#123; for(int j = 0; j &lt; m; ++j)&#123; scanf(&quot;%d&quot;, &amp;ar[i][j]); &#125; &#125; int flag = 0; for(int i=0;i&lt;n;++i)&#123; for(int j=0;j&lt;m;++j)&#123; for(int k=0;k&lt;4;++k)&#123; int px = i + dir[k][0],py = j + dir[k][1]; if(px&lt;0||py&lt;0||px&gt;=n||py&gt;=m)continue; if(ar[px][py]==ar[i][j])&#123; flag=1;break; &#125; &#125; if(flag)break; &#125; if(flag)break; &#125; for(int i=0;i&lt;n;++i)&#123; for(int j=i+1;j&lt;n;++j)&#123; if(ar[i][0]==ar[j][0]||ar[i][m-1]==ar[j][m-1])&#123; flag=1;break; &#125; &#125; if(flag)break; &#125; for(int i=0;i&lt;m;++i)&#123; for(int j=i+1;j&lt;m;++j)&#123; if(ar[0][i]==ar[0][j]||ar[n-1][i]==ar[n-1][j])&#123; flag=1;break; &#125; &#125; if(flag)break; &#125; printf(&quot;Case #%d: &quot;,cas++); if(flag)printf(&quot;Yes\n&quot;); else printf(&quot;No\n&quot;); &#125; return 0;&#125; F é¢˜ç›®é“¾æ¥ï¼šHDU 5927 Auxiliary Set é¢˜æ„ï¼šéšä¾¿é€‰å‡ ä¸ªç‚¹ä½œä¸ºä¸é‡è¦çš„ç‚¹ï¼Œå…¶ä»–çš„å…¨æ˜¯é‡è¦çš„ç‚¹ï¼Œç„¶åæŠŠä¸é‡è¦çš„ç‚¹ä¸­å¦‚æœæ˜¯ä¸¤ä¸ªä¸åŒèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆå°±æŠŠä»–å˜ä¸ºé‡è¦çš„ç‚¹ï¼Œé—®ï¼Œé€‰äº†å‡ ä¸ªä¸é‡è¦çš„ç‚¹ï¼Œæœ€åé‡è¦çš„ç‚¹æ€»å…±æœ‰å¤šå°‘ä¸ªã€‚ é¢˜è§£ï¼šæ•°æ®çœ‹çš„æŒºå“äººçš„ 1e3 ç»„ 1e5çš„æ•°æ®é‚£å‘½å»å†™å•Šï¼Œå®é™…ä¸Šæ²¡å¤šå°‘ã€‚ã€‚ã€‚ã€‚ã€‚ç›´æ¥æŒ‰ä¸é‡è¦çš„ç‚¹æ·±åº¦æ’ä¸ªåºï¼Œå¦‚æœæ˜¯å¦å¤–ä¸¤ä¸ªé‡è¦çš„ç‚¹çš„LCAå°±å˜æˆé‡è¦çš„ç‚¹ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,m;struct edge &#123; int to,next;&#125; eg[maxn*2];int head[maxn],tot;void init() &#123; mem(head,-1); tot=0;&#125;void add(int u,int v) &#123; eg[tot].to=v; eg[tot].next=head[u]; head[u]=tot++;&#125;int dep[maxn],pre[maxn];int u[maxn];int res[maxn];int num[maxn];int dfs(int r,int p,int d) &#123; dep[r]=d; pre[r]=p; int ans=0; for(int i=head[r]; i!=-1; i=eg[i].next) &#123; if(eg[i].to!=p) &#123; ans+=dfs(eg[i].to,r,d+1); &#125; &#125; num[r]=ans; return ans;&#125;void read(int &amp;sum) &#123; scanf(&quot;%d&quot;,&amp;sum); return ; sum=0; int flag=0; char ch=getchar(); while(!(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)) &#123; if (ch == &apos;-&apos;) &#123; flag = 1; &#125; ch=getchar(); &#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)sum=sum*10+ch-48,ch=getchar(); if(flag)sum*=-1;&#125;bool cmp(int &amp;a,int &amp;b) &#123; return dep[a]&gt;dep[b];&#125;int main() &#123; int t,cas=1; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; read(n); read(m); init(); for(int i=0; i&lt;n-1; i++) &#123; int a,b; read(a); read(b); add(a,b); add(b,a); &#125; dfs(1,-1,1); printf(&quot;Case #%d:\n&quot;,cas++); while(m--) &#123; int k,d,ans=0; read(k); ans=n-k; for(int i=0; i&lt;k; i++) &#123; read(res[i]); u[res[i]]=-1; &#125; sort(res,res+k,cmp); for(int i=0; i&lt;k; i++) &#123; d=0; for(int j=head[res[i]]; j!=-1; j=eg[j].next) &#123; int to=eg[j].to; if(to==pre[res[i]]) &#123; continue; &#125; else &#123; if(u[to]&lt;0) &#123; continue; &#125; if(u[res[i]]==-1) &#123; u[res[i]]=1; &#125; else u[res[i]]++; if(u[res[i]]==2) &#123; ans++; break; &#125; &#125; &#125; &#125; for(int i=0; i&lt;k; i++)u[res[i]]=0; printf(&quot;%d\n&quot;,ans); &#125; &#125; return 0;&#125; H é¢˜ç›®è¿æ¥ï¼šHDU 5929 Basic Data Structure ç®€å•æ¨¡æ‹Ÿä¸€ä¸‹å°±å¯ä»¥äº†ï¼Œè®°å½•ä¸‹ä¸€æœ€åä¸€ä¸ªé›¶çš„ä½ç½®ï¼Œå› ä¸ºåˆ°é›¶é™¤äº†æ˜¯ç¬¬ä¸€ä¸ªä½ç½®ä¹‹å¤–å…¨éƒ½å¿…å®šæ˜¯1. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int a[maxn];int l,r;int t,cas=1;int Q;char s[100];deque&lt;int&gt; q;int main() &#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;,&amp;Q); int x; bool b=1; l=r=2e5+5; printf(&quot;Case #%d:\n&quot;,cas++); q.clear(); while(Q--) &#123; scanf(&quot;%s&quot;,s); if(b) &#123; if(s[0]==&apos;P&apos;&amp;&amp;s[1]==&apos;U&apos;) &#123; scanf(&quot;%d&quot;,&amp;x); a[++r]=x; if(x==0)q.push_back(r); &#125; else if(s[0]==&apos;Q&apos;) &#123; if(r==l)printf(&quot;Invalid.\n&quot;); else if(r-l==1)printf(&quot;%d\n&quot;,a[r]); else &#123; if(q.size()==0) &#123; printf(&quot;%d\n&quot;,(r-l)&amp;1); &#125; else &#123; int k=q.front(); if(r==k)printf(&quot;%d\n&quot;,(k-l+1)&amp;1); else printf(&quot;%d\n&quot;,(k-l)&amp;1); &#125; &#125; &#125; else if(s[0]==&apos;R&apos;) &#123; b=0; &#125; else &#123; if(a[r]==0)q.pop_back(); --r; &#125; &#125; else &#123; if(s[0]==&apos;P&apos;&amp;&amp;s[1]==&apos;U&apos;) &#123; scanf(&quot;%d&quot;,&amp;x); a[l--]=x; if(x==0)q.push_front(l+1); &#125; else if(s[0]==&apos;Q&apos;) &#123; if(r==l)printf(&quot;Invalid.\n&quot;); else if(r-l==1)printf(&quot;%d\n&quot;,a[r]); else &#123; if(q.size()==0)printf(&quot;%d\n&quot;,(r-l)&amp;1); else &#123; int k=q.back(); if(k==l+1)printf(&quot;%d\n&quot;,(r-k)&amp;1); else printf(&quot;%d\n&quot;,(r-k+1)&amp;1); &#125; &#125; &#125; else if(s[0]==&apos;R&apos;) &#123; b=1; &#125; else &#123; if(a[l+1]==0)q.pop_front(); ++l; &#125; &#125; &#125; &#125; return 0;&#125; I -é¢˜ç›®é“¾æ¥ï¼šHDU - 5930 GCD è¿™é¢˜æ˜¯çœŸçš„éš¾ç†è§£.è¿™é¢˜è¦æ˜¯ä¸ç”¨çº¿æ®µæ ‘å¤§å®¶éƒ½ä¼šå†™å§ï¼Œé¦–å…ˆæš´åŠ›ä»å‰é¢çš„æ¯ä¸ªä½ç½®åˆ°å½“å‰ä½ç½®çš„GCD ï¼Œç„¶åè®°å½•æ¯ä¸ªGCDçš„ä¸ªæ•°ï¼Œæ›´æ–°ä¸€ä¸ªç‚¹å°±æ˜¯åˆ é™¤ä¸€ä¸ªç‚¹ï¼Œç„¶åå†åŠ ä¸€ä¸ªç‚¹ï¼Œå°±æ˜¯æš´åŠ›ä»å‰é¢æ‰€æœ‰ä½ç½®åˆ°åé¢æ‰€æœ‰ä½ç½®çš„GCDï¼Œå‡å»è¿™ä¸ªå€¼ã€‚æŠŠå€¼æ›´æ–°å†ä¸€æ¬¡ç®—ä»å‰é¢æ‰€æœ‰ä½ç½®åˆ°åé¢æ‰€æœ‰ä½ç½®çš„GCDï¼Œç„¶ååŠ ä¸Šå»ã€‚ ç«Ÿç„¶ä¼šè¿™ä¸ªè¿™ä¸ªï¼Œè¿™é¢˜å°±æ˜¯ç”¨çº¿æ®µæ ‘ç»´æŠ¤ä¸€ä¸‹GCDçš„å€¼ï¼Œï¼Œï¼Œå°±åƒäºŒåˆ†ä¸€æ ·ï¼Œå› ä¸ºä¼šæœ‰å¾ˆé•¿ä¸€æ®µçš„GCDå€¼æ˜¯ä¸€æ ·çš„ï¼Œæ¯æ¬¡ä¸ç”¨ä¸€ä¸ªä¸ªå»æ‰¾ï¼Œç›´æ¥æ‰¾åˆ°å‰é¢GCDæ”¹å˜çš„ä½ç½®ï¼Œç„¶åå‡å»ä¸Šä¸€æ¬¡GCDæ”¹å˜çš„ä½ç½®ã€‚ä¹Ÿæ˜¯ä¸€ç§æš´åŠ›ã€‚ã€‚ã€‚ä¿®æ”¹å…¶å®ä¹Ÿæ˜¯ä¸€æ ·çš„å°±æ˜¯æŠŠå‰é¢GCDå’Œåé¢GCDæ±‚ä¸€ä¸ªGCDï¼Œç„¶åå‰åGCD çš„æ•°é‡ç›¸ä¹˜ æ¯”å¦‚ 1 1 1 2 4 4 4 å‰é¢3ä¸ªæ•°çš„GCDæ˜¯3 ä¸ª 1 å’Œåé¢3ä¸ªæ•° æ˜¯ 2 é‚£ä¹ˆGCDä¸º gcd(1,2) æ•°é‡å°±æ˜¯ 3 * 3; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int g[maxn&lt;&lt;4],c[maxn];int f[maxn&lt;&lt;4],a[maxn],aa[maxn],b[maxn],bb[maxn];int A,B,n,m;long long gcd(long long a,long long b) &#123; return b==0?a:gcd(b,a%b);&#125;void build(int l,int r,int k) &#123; if(r-l==1) &#123; g[k]=c[r]; &#125; else &#123; build(lson); build(rson); g[k]=gcd(g[chl],g[chr]); &#125;&#125;int findleft(int l,int r,int k,int u,int v) &#123; if(r&lt;=u) &#123; if(gcd(g[k],v)==v)return 0; if(l+1==r)return r; int x=findleft(rson,u,v); if(x)return x; else return findleft(lson,u,v); &#125; if(u&gt;mid) &#123; int x=findleft(rson,u,v); if(x)return x; &#125; return findleft(lson,u,v);&#125;void getleft(int x) &#123; A=0; for(int i=c[x],j=x,k; j!=0; j=k) &#123; k=findleft(0,n,0,j,i); a[A]=j-k; aa[A++]=i; if(k==0)return ; i=gcd(c[k],i); &#125; return ;&#125;int findright(int l,int r,int k,int u,int v) &#123; //è¿™ä¸ªæ˜¯ç”¨çº¿æ®µæ ‘å¾€å·¦æ‰¾GCD if(l+1&gt;=u) &#123; if(gcd(g[k],v)==v)return n+1; if(l+1==r)return r; int x = findright(lson,u,v); if(x&lt;=n)return x; else return findright(rson,u,v); &#125; if(u&lt;=mid) &#123; int x=findright(lson,u,v); if(x&lt;=n)return x; &#125; return findright(rson,u,v);&#125;void getright(int x) &#123; B=0; for(int i= c[x],j=x,k; j&lt;=n; j=k) &#123; //è¿™ä¸ªæ˜¯æš´åŠ›Xæ‰€æœ‰å·¦è¾¹çš„GCD k=findright(0,n,0,j,i); b[B]=k-j; bb[B++]=i; i=gcd(c[k],i); &#125; return ;&#125;void change(int l,int r,int k,int u,int v) &#123; if (l+1==r) &#123; g[k] = v; return; &#125; if (u&lt;=mid) change(lson,u,v); else change(rson,u,v); g[k]=gcd(g[chl],g[chr]);&#125;int main() &#123; int t,cas=1; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; printf(&quot;Case #%d:\n&quot;,cas++); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; ++i)scanf(&quot;%d&quot;,&amp;c[i]); build(0,n,0); //åˆå§‹åŒ–çº¿æ®µæ ‘ memset(f,0,sizeof(f)); int ans=0; for(int i=1; i&lt;=n; i++) &#123; getleft(i); //åˆå§‹åŒ–åªè¦æ‰¾æ‰€æœ‰iå·¦è¾¹çš„GCDæˆ–è€…å³è¾¹ä¹Ÿå¯ä»¥ï¼Œä½†æ˜¯åªèƒ½æ‰¾ä¸€è¾¹ä¸ç„¶ä¼šé‡å¤ã€‚ for(int j=0; j&lt;A; j++) &#123; if(!f[aa[j]])ans++; f[aa[j]]+=a[j]; &#125; &#125; while(m--) &#123; int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); getleft(x); //æ‰¾åˆ°æ‰€æœ‰å·¦è¾¹çš„GCD getright(x); //æ‰¾åˆ°æ‰€æœ‰å³è¾¹çš„GCD for(int j=0; j&lt;A; j++) &#123;//æš´åŠ›æ‰€æœ‰å·¦å³ä¸¤è¾¹GCDæ‰€æœ‰å¯èƒ½ for(int k=0; k&lt;B; k++) &#123; int t=gcd(aa[j],bb[k]); //å·¦å³ä¸¤è¾¹çš„GCDçš„GCD f[t]-=1LL *a[j]*b[k]; // æš´åŠ›åˆ é™¤ if(!f[t])ans--; &#125; &#125; c[x]=y; change(0,n,0,x,y); getleft(x); getright(x); for(int j=0; j&lt;A; j++) &#123; for(int k=0; k&lt;B; k++) &#123; int t=gcd(aa[j],bb[k]);//æš´åŠ›æ·»åŠ  if(!f[t])ans++; f[t]+=1LL*a[j]*b[k]; &#125; &#125; printf(&quot;%d\n&quot;,ans); // å¾—å‡ºç»“è®º &#125; &#125; return 0;&#125; J é¢˜ç›®é“¾æ¥ï¼šHDU5931 - Mission Possible æš´åŠ›æ‰€æœ‰é€Ÿåº¦ï¼Œæ¨ä¸€ä¸‹å…¬å¼ï¼Œå‘ç°è¦ä¹ˆæ˜¯ç”¨åˆå§‹è¡€é‡å»æ‰ä¸åŠ è¡€ï¼Œè¦ä¹ˆæ˜¯åŠ è¡€ç­‰äºæ‰è¡€æ•°é‡çš„æ—¶å€™æ˜¯æœ€ä¼˜è§£ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;ll D,A,GA,GB,GC;int main() &#123; int t,cas=1; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%lld%lld%lld%lld%lld&quot;,&amp;D,&amp;A,&amp;GA,&amp;GB,&amp;GC); ll v,r,h; ll ans=1e18,temp; for(v=1; v&lt;=D; v++) &#123; double t=1.0*D/v; temp=v*GB+A*GC+A*GA; ans=min(ans,temp); double tem2=t*A; temp=v*GB+floor(t*A-eps+1)*GA;// debug(temp-v*GB); ans=min(ans,temp); &#125; printf(&quot;Case #%d: %lld\n&quot;,cas++,ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç¬¬å…«å±Šç¦å»ºçœå¤§å­¦ç”Ÿç¨‹åºè®¾è®¡ç«èµ›-FZU 2280 HASHå¤„ç†+æš´åŠ›æœç´¢]]></title>
    <url>%2F2018%2F08%2F21%2F%E7%AC%AC%E5%85%AB%E5%B1%8A%E7%A6%8F%E5%BB%BA%E7%9C%81%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-FZU%202280%20HASH%E5%A4%84%E7%90%86%2B%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®ï¼šProblem 2280 Magic Problem Description Kim is a magician, he can use n kinds of magic, number from 1 to n. We use string Si to describe magic i. Magic Si will make Wi points of damage. Note that Wi may change over time. Kim obey the following rules to use magic: Each turn, he picks out one magic, suppose that is magic Sk, then Kim will use all the magic i satisfying the following condition: Wi&lt;=Wk Sk is a suffix of Si. Now Kim wondering how many magic will he use each turn. Note that all the strings are considered as a suffix of itself. Input First line the number of test case T. (T&lt;=6) For each case, first line an integer n (1&lt;=n&lt;=1000) stand for the number of magic. Next n lines, each line a string Si (Length of Si&lt;=1000) and an integer Wi (1&lt;=Wi&lt;=1000), stand for magic i and itâ€™s damage Wi. Next line an integer Q (1&lt;=Q&lt;=80000), stand for there are Q operations. There are two kinds of operation. â€œ1 x yâ€ means Wx is changed to y. â€œ2 xâ€ means Kim has picked out magic x, and you should tell him how many magic he will use in this turn. Note that different Si can be the same. Output For each query, output the answer. Sample Input 1 5 abracadabra 2 adbra 1 bra 3 abr 3 br 2 5 2 3 2 5 1 2 5 2 3 2 2 Sample Output 3 1 2 1 Source ç¬¬å…«å±Šç¦å»ºçœå¤§å­¦ç”Ÿç¨‹åºè®¾è®¡ç«èµ›-é‡ç°èµ›ï¼ˆæ„Ÿè°¢æ‰¿åŠæ–¹å¦é—¨ç†å·¥å­¦é™¢ï¼‰ é¢˜ç›®ï¼šç»™ä½ nä¸ªå­—ç¬¦ä¸²ä»¥åŠæƒå€¼ï¼Œä¸¤ç§æ“ä½œ ä¸€ç§ æ›´æ–°å­—ç¬¦ä¸²å¯¹åº”çš„æƒå€¼ ï¼ŒæŸ¥è¯¢ è¾“å‡ºæ‰€æœ‰ä»¥å½“å‰å­—ç¬¦ä¸²ä¸ºåç¼€ä¸”å¯¹åº”æƒå€¼å°äºå½“å‰å­—ç¬¦ä¸²æƒå€¼çš„ä¸ªæ•°ã€‚ é¢˜è§£ï¼šé¦–å…ˆhash é¢„å¤„ç†æ‰€æœ‰èƒ½ä¾›ä»¥å½“å‰å­—ç¬¦ä¸²ä¸ºåç¼€çš„å­—ç¬¦ä¸²ï¼Œç›´æ¥n^2æš´åŠ›å°±è¡Œã€‚ã€‚ã€‚ ç„¶åæŸ¥è¯¢ç›´æ¥æš´åŠ›æœç´¢å°äºå½“å‰å­—ç¬¦ä¸²æƒå€¼çš„ã€‚ æ•°æ®åªæœ‰1000 çš„èŒƒå›´éšä¾¿æš´åŠ›å•Šã€‚ã€‚ã€‚ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e3+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;const int seed=131;ull Hash[maxn][maxn];ull po[maxn];char ch[maxn][maxn];int t,n;int len[maxn];bool mp[maxn][maxn];int val[maxn];void init() &#123; mem(mp,0); po[0]=1; for(int i=1; i&lt;1002; i++) &#123; po[i]=po[i-1]*seed; &#125; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=len[i]; j++) &#123; Hash[i][j]=Hash[i][j-1]*seed+ch[i][j]; &#125; &#125; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=n; j++) &#123; if(len[j]&lt;len[i])continue; else &#123; int l=len[j]-len[i]; if(Hash[j][len[j]]-Hash[j][l]*po[len[i]]==Hash[i][len[i]]) &#123; mp[i][j]=1; &#125; &#125; &#125; &#125;&#125;void read(int &amp;sum) &#123; sum=0; int flag=0; char ch=getchar(); while(!(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)) &#123; if (ch == &apos;-&apos;) &#123; flag = 1; &#125; ch=getchar(); &#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)sum=sum*10+ch-48,ch=getchar(); if(flag)sum*=-1;&#125;int main() &#123; read(t); while(t--) &#123; read(n); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%s%d&quot;,ch[i]+1,&amp;val[i]); len[i]=strlen(ch[i]+1); &#125; init(); int q; read(q); while(q--) &#123; int op; read(op); int x,y; if(op==1) &#123; read(x); read(y); val[x]=y; &#125; else &#123; read(x); int ans=0; for(int i=1;i&lt;=n;i++)if(mp[x][i]&amp;&amp;val[x]&gt;=val[i])ans++; printf(&quot;%d\n&quot;,ans); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[çº¿æ€§æ’åºç®—æ³• --- è®¡æ•°æ’åºï¼ŒåŸºæ•°æ’åºï¼Œæ¡¶æ’åº]]></title>
    <url>%2F2018%2F08%2F21%2F%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%20---%20%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%8C%E6%A1%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[è®¡æ•°æ’åºåº”ç”¨: J - Jeronimoâ€™s List Gym - 101466J http://codeforces.com/gym/101466/problem/J çº¿æ€§æ’åºç®—æ³•è®¡æ•°æ’åºåº”è¯¥æŒºå¥½ç†è§£çš„ï¼Œæ¯æ¬¡æŠŠæ•°å­—å‡ºç°çš„æ¬¡æ•°è®°å½•ä¸‹æ¥ï¼Œç„¶ååšæˆå‰ç¼€ï¼Œå‰ç¼€å°±æ˜¯å°äºç­‰äºå½“å‰æ•°çš„ä¸ªæ•°ã€‚ æ¯”å¦‚ 2,3,0,3,6,2,3,5ï¼Œé¦–å…ˆè®°å½•å‡ºç°æ¬¡æ•° 0 1 2 3 4 5 6 1 0 2 3 0 1 1 ç„¶åå¯¹è¿™ä¸ªæ•°ç»„åšä¸€ä¸ªå‰ç¼€ c[0] c[1] c[2] c[3] c[4] c[5] c[6] 1 1 3 6 6 7 8 å°±æ˜¯è¿™æ · ï¼Œç„¶åæ’åºçš„æ—¶å€™å°± è¾“å‡ºæ•°å­—å¯¹åº”çš„åœ°æ–¹ å¦‚ a[i]= 5 é‚£ä¹ˆ b[c[a[i]]]=a[i]; æŠŠb æ•°ç»„é‡Œé¢ 7çš„ä½ç½®èµ‹å€¼ä¸º5.ç„¶åå°äºç­‰äº5çš„æ•°é‡-1ï¼› 1234567891011121314151617181920212223242526272829303132 #include&lt;bits/stdc++.h&gt;using namespace std;int a[8]= &#123;2,3,0,3,6,2,3,5&#125;;int b[8];int c[7];int main() &#123; for(int i=0; i&lt;8; i++) &#123; c[a[i]]++; &#125; for(int i=1; i&lt;7; i++) &#123; //æŠŠè¿™ä¸ªforå€’è¿‡æ¥å°±æ˜¯ä»å¤§åˆ°å° c[i]=c[i-1]+c[i]; &#125; printf(&quot;Cæ•°ç»„:\n&quot;); for(int i=0; i&lt;7; i++) &#123; printf(&quot;c[%d]\t&quot;,i); &#125; printf(&quot;\n&quot;); for(int i=0; i&lt;7; i++) &#123; printf(&quot; %d\t&quot;,c[i]); &#125; printf(&quot;\n&quot;); printf(&quot;æ’åºè¿‡ç¨‹\n&quot;); for(int i=7; i&gt;=0; i--) &#123; b[--c[a[i]]]=a[i]; for(int i=0; i&lt;7; i++) &#123; printf(&quot;%d &quot;,b[i]); &#125; printf(&quot;\n&quot;); &#125; return 0;&#125; åŸºæ•°æ’åºï¼š å®é™…ä¸Šå’Œè®¡æ•°æ’åºæ²¡å•¥å¤ªå¤§çš„åŒºåˆ« ï¼Œè®¡æ•°æ’åºå¦‚æœæ•°å¤ªå¤§ï¼Œä½  Cæ•°ç»„çš„å°±è¦æµªè´¹éå¸¸å¤§çš„å†…å­˜ï¼Œæˆ–è€…æ ¹æœ¬å¼€ä¸äº†è¿™ä¹ˆå¤§çš„å†…å­˜ã€‚ åŸºæ•°æ’åºï¼Œå°±æ˜¯æŠŠæ¯ä¸ª ä½æ‹†åˆ†å‡ºæ¥ï¼Œå®é™…ä¸Šå’Œè®¡æ•°æ’åºå·®è·ä¸å¤§ã€‚ 12,13,120,33,46,52,3,25 120 12 52 13 33 3 25 46 ä»¥æœ€åä¸€ä½é€’å¢ 3 12 13 120 25 33 46 52 åœ¨æœ€åä¸€ä½ä¸ºé€’å¢åŸºç¡€ä¸Šå€’æ•°ç¬¬2ä½é€’å¢ 3 12 13 25 33 46 52 120 æœ€åä»¥ ç¬¬ä¸€ä½ é€’å¢ï¼Œå°±æ˜¯æ’åºå¥½çš„ 12345678910111213141516171819202122232425262728293031323334353637383940414243 #include&lt;bits/stdc++.h&gt;using namespace std;int a[8]= &#123;12,13,120,33,46,52,3,25&#125;;int b[8];int c[10];int main() &#123; int mx=0,pos=0,cot=1; for(int i=0; i&lt;8; i++) &#123; mx=max(mx,a[i]); &#125; while(mx/cot&gt;0) &#123; memset(c,0,sizeof(c)); for(int i=0; i&lt;8; i++) &#123; c[a[i]/cot%10]++; &#125; for(int i=1; i&lt;10; i++) &#123; //æŠŠè¿™ä¸ªforå€’è¿‡æ¥å°±æ˜¯ä»å¤§åˆ°å° c[i]=c[i-1]+c[i]; &#125; printf(&quot;è®¡æ•°æ•°ç»„:\n&quot;); for(int i=0; i&lt;10; i++) &#123; printf(&quot;c[%d]\t&quot;,i); &#125; printf(&quot;\n&quot;); for(int i=0; i&lt;10; i++) &#123; printf(&quot; %d\t&quot;,c[i]); &#125; printf(&quot;\n&quot;); printf(&quot;æ’åºç¬¬%dä½ç»“æœ:\n&quot;,pos); for(int i=7; i&gt;=0; i--) &#123; b[--c[a[i]/cot%10]]=a[i]; &#125; for(int i=0; i&lt;8; i++) &#123; a[i]=b[i]; &#125; for(int i=0;i&lt;8;i++)&#123; printf(&quot;%d &quot;,a[i]); &#125; puts(&quot;&quot;); cot*=10; pos++; &#125; return 0;&#125; æ¡¶æ’åºï¼Œå®é™…ä¸Šå’Œè®¡æ•°æ’åºä¹Ÿå·®ä¸å¤šï¼Œä½†æ˜¯åˆ°ç›®å‰ä½ç½®æˆ‘è¿˜æ²¡ç”¨è¿‡ã€‚ è®¡æ•°æ’åºå°±ç›¸å½“äº æ¡¶çš„å¤§å°ä¸º 1 çš„æ’åº ã€‚ï¼ˆåŸºæ•°æ’åºå®é™…ä¸Šæœ‰ç‚¹ç±»ä¼¼äºä»¥10 çš„æ¡¶é‡Œé¢å¥—ç€ä¸€ä¸ª10 çš„æ¡¶ï¼‰ä¸ªäººç†è§£ å¼€ä¸€ä¸ªæ¡¶çš„å¤§å° b ç„¶åæŠŠä»–ä¸€ä¸ªæ•°xä¸¢åˆ° x/b é‚£ä¸ªæ¡¶é‡Œé¢å»ï¼Œç„¶åæŠŠæ¯ä¸ªæ¡¶é‡Œé¢æ’åºã€‚æŠŠæ¡¶åˆ†æˆ1ä¸å°±æ˜¯è®¡æ•°æ’åºã€‚ã€‚ä¸ªäººç†è§£ ç†è®ºä¸Šæ¥è¯´ï¼šåœ¨åˆ†å¸ƒæ¡¶å‡åŒ€çš„æƒ…å†µä¸‹ï¼Œæ˜¯O(n+n*(2-1/n)); æœ‰äº›æƒ…å†µä¸‹å¯èƒ½é€€åŒ–æˆ æ™®é€šæ’åºä¸€æ ·çš„å¤æ‚åº¦ã€‚ ä»£ç å°±ä¸æ•²äº†ï¼Œè¿˜æ²¡ç”¨è¿‡ã€‚ã€‚ã€‚ã€‚]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç¬¬å…«å±Šç¦å»ºçœå¤§å­¦ç”Ÿç¨‹åºè®¾è®¡ç«èµ›-FZU 2277 DFS +çº¿æ®µæ ‘+è¯»å…¥æŒ‚]]></title>
    <url>%2F2018%2F08%2F20%2F%E7%AC%AC%E5%85%AB%E5%B1%8A%E7%A6%8F%E5%BB%BA%E7%9C%81%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-FZU%202277%20%20DFS%20%2B%E7%BA%BF%E6%AE%B5%E6%A0%91%2B%E8%AF%BB%E5%85%A5%E6%8C%82%2F</url>
    <content type="text"><![CDATA[FZU 2277 Problem 2277 Change Accept: 245 Submit: 1186 Time Limit: 2000 mSec Memory Limit : 262144 KB Problem Description There is a rooted tree with n nodes, number from 1-n. Rootâ€™s number is 1.Each node has a value ai. Initially all the nodeâ€™s value is 0. We have q operations. There are two kinds of operations. 1 v x k : a[v]+=x , a[vâ€™]+=x-k (vâ€™ is child of v) , a[vâ€™â€™]+=x-2*k (vâ€™â€™ is child of vâ€™) and so on. 2 v : Output a[v] mod 1000000007(10^9 + 7). Input First line contains an integer T (1 â‰¤ T â‰¤ 3), represents there are T test cases. In each test case: The first line contains a number n. The second line contains n-1 number, p2,p3,â€¦,pn . pi is the father of i. The third line contains a number q. Next q lines, each line contains an operation. (â€œ1 v x kâ€ or â€œ2 vâ€) 1 â‰¤ n â‰¤ 3*10^5 1 â‰¤ pi &lt; i 1 â‰¤ q â‰¤ 3*10^5 1 â‰¤ v â‰¤ n; 0 â‰¤ x &lt; 10^9 + 7; 0 â‰¤ k &lt; 10^9 + 7 Output For each operation 2, outputs the answer. Sample Input 1 3 1 1 3 1 1 2 1 2 1 2 2 Sample Output 2 1 Source é¢˜æ„ï¼šç»™ä½ ä¸€æ£µæ ‘ æœ‰ä¸¤ç§æ“ä½œï¼šæŸ¥è¯¢èŠ‚ç‚¹çš„å€¼ï¼Œå’Œå°†æ‰€æœ‰æ ‘èŠ‚ç‚¹åŠä»¥ä¸‹ä¸‹æ‰€æœ‰çš„èŠ‚ç‚¹ + x - (å­èŠ‚ç‚¹æ·±åº¦-å½“å‰æ·±åº¦)*k çš„å€¼ é¢˜è§£ï¼šé¦–å…ˆè‚¯å®šæ˜¯DFSå»ºåºï¼Œç„¶åæ ¹æ®dfs åºå»ºä¸€é¢—çº¿æ®µæ ‘ï¼Œè¿™é¢˜æ›´æ–°æ“ä½œæ˜¯æ›´æ–°ä¸€ä¸ªåŒºé—´ï¼ŒæŸ¥è¯¢æ˜¯å•ç‚¹ã€‚ è¿™é¢˜åªè¦ç”¨ä¸€ä¸ªdepæ•°ç»„ä¿å­˜æ¯ä¸ªèŠ‚ç‚¹æ‰€åŒ…å«åŒºé—´é‡Œé¢çš„æœ€å°æ·±åº¦ï¼Œç„¶åå‘ä¸‹æ›´æ–°çš„æ—¶å€™æ¯æ¬¡æŠŠï¼Œxï¼Œå’Œkï¼Œæ›´æ–°ä¸‹å»ï¼› æ›´æ–°çš„æ—¶å€™ç›´æ¥æŠŠï¼Œ(å­èŠ‚ç‚¹æ·±åº¦-å½“å‰æ·±åº¦)*kçš„å€¼æ›´æ–°åˆ° ï¼Œx,é‡Œé¢ã€‚ æŸ¥è¯¢ç›´æ¥è¿”å›å•ç‚¹çš„x. è¿™é¢˜ä¸»è¦æ˜¯å¡å–æ¨¡å’Œè¯»å…¥ã€‚ã€‚ã€‚è¯»å…¥ç‰¹ä¹ˆå°±å¿«è¶…æ—¶äº†ï¼Œæœ€è®©æˆ‘æ— è¯­çš„è¿˜æ˜¯è¶…æ—¶ç»™æˆ‘è¿”å›ä¸€ä¸ªWAåŠ ä¸ªè¯»å…¥æŒ‚å°±è¿‡äº†ã€‚ã€‚ã€‚ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef ll LL;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=3e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int e[maxn],s[maxn],tdep[maxn];int cnt=0;struct node &#123; ll x,k;&#125; lazy[maxn&lt;&lt;4];int dep[maxn&lt;&lt;4];struct edge &#123; int to,next;&#125; eg[maxn];int head[maxn],tot;void add(int u,int v) &#123; eg[tot].to=v; eg[tot].next=head[u]; head[u]=tot++;&#125;void init() &#123; tot=0; cnt=0; mem(head,-1);&#125;int dfs(int r,int dp) &#123; cnt++; s[r]=cnt; tdep[cnt]=dp; for(int i=head[r]; i!=-1; i=eg[i].next) &#123; int to=eg[i].to; dfs(to,dp+1); &#125; e[r]=cnt;&#125;void build(int l,int r,int k) &#123; if(r-l==1) &#123; dep[k]=tdep[r]; lazy[k].k=0; lazy[k].x=0; &#125; else &#123; build(lson); build(rson); dep[k]=min(dep[chl],dep[chr]); lazy[k].k=0; lazy[k].x=0; &#125;&#125;void pushdown(int l,int r,int k) &#123; if(lazy[k].k==0&amp;&amp;lazy[k].x==0) return ; lazy[chl].k+=lazy[k].k; lazy[chl].k%=mod; lazy[chr].k+=lazy[k].k; lazy[chr].k%=mod; lazy[chl].x+=(lazy[k].x-lazy[k].k%mod*(dep[chl]-dep[k])+mod)%mod; lazy[chl].x=(lazy[chl].x+mod)%mod; lazy[chr].x+=(lazy[k].x-lazy[k].k%mod*(dep[chr]-dep[k])+mod)%mod; lazy[chr].x=(lazy[chr].x+mod)%mod; lazy[k].x=0; lazy[k].k=0;&#125;void update(int a,int b,int l,int r,int k,ll x,ll y,ll dp) &#123; if(b&lt;=l||a&gt;=r) &#123; return ; &#125; else if(a&lt;=l&amp;&amp;r&lt;=b) &#123; lazy[k].x+=(x-y*(dep[k]-dp)%mod+mod)%mod; lazy[k].x%=mod; lazy[k].k+=y; lazy[k].k%=mod; return ; &#125; else &#123; pushdown(l,r,k); update(a,b,lson,x,y,dp); update(a,b,rson,x,y,dp); &#125;&#125;ll res=0;void query(int a,int b,int l,int r,int k) &#123; if(b&lt;=l||a&gt;=r) &#123; return ; &#125; else if(a&lt;=l&amp;&amp;r&lt;=b) &#123; res=lazy[k].x%mod; return ; &#125; else &#123; pushdown(l,r,k); query(a,b,lson); query(a,b,rson); &#125;&#125;void read(LL &amp;sum) &#123; sum=0; char ch=getchar(); while(!(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;))ch=getchar(); while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)sum=sum*10+ch-48,ch=getchar();&#125;void read(int &amp;sum) &#123; sum=0; char ch=getchar(); while(!(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;))ch=getchar(); while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)sum=sum*10+ch-48,ch=getchar();&#125;int main() &#123; int n,t; read(t); while(t--) &#123; init(); scanf(&quot;%d&quot;,&amp;n); for(int i=2; i&lt;=n; i++) &#123; int x; read(x); add(x,i); &#125; dfs(1,1); build(0,n,0); int q; read(q); while(q--) &#123; int op; read(op); ll a,b,c; if(op==1) &#123; read(a); read(b); read(c); update(s[a]-1,e[a],0,n,0,b,c,tdep[s[a]]); &#125; else &#123; scan_d&lt;LL&gt;(a); query(s[a]-1,s[a],0,n,0); printf(&quot;%lld\n&quot;,(res+mod)%mod); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A - Gaby And Addition Gym - 101466A --å­—å…¸æ ‘ ï¼Œæš´åŠ›+è´ªå¿ƒ]]></title>
    <url>%2F2018%2F08%2F19%2FA%20-%20Gaby%20And%20Addition%20Gym%20-%20101466A%20--%E5%AD%97%E5%85%B8%E6%A0%91%20%EF%BC%8C%E6%9A%B4%E5%8A%9B%2B%E8%B4%AA%E5%BF%83%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ ï¼šhttp://codeforces.com/gym/101466/problem/A A. Gaby And Addition time limit per test 6.0 s memory limit per test 1024 MB input standard input output standard output Gaby is a little baby who loves playing with numbers. Recently she has learned how to add 2 numbers using the standard addition algorithm which we summarize in 3 steps: Line up the numbers vertically matching digits places. Add together the numbers that share the same place value from right to left. Carry if necessary. it means when adding two numbers we will get something like this: Unfortunately as Gaby is too young she doesnâ€™t know what the third step means so she just omitted this step using her own standard algorithm (Gabyâ€™s addition algorithm). When adding two numbers without carrying when necessary she gets something like the following: Gaby loves playing with numbers so she wants to practice the algorithm she has just learned (in the way she learned it) with a list of numbers adding every possible pair looking for the pair which generates the largest value and the smallest one. She needs to check if she is doing it correctly so she asks for your help to find the largest and the smallest value generated from the list of numbers using Gabyâ€™s addition algorithm. Input The input starts with an integer _n_ (2 â‰¤ _n_ â‰¤ 106) indicating the number of integers Gaby will be playing with. The next line contains _n_numbers _ni_ (0 â‰¤ _ni_ â‰¤ 1018) separated by a single space. Output Output the smallest and the largest number you can get from adding two numbers from the list using Gabyâ€™s addition algorithm. Examples input Copy 12 617 5 11 0 42 99 output Copy 10 99 input Copy 12 7506823119072235413 991096248449924896 204242310783332529 778958050378192979 384042493592684633 942496553147499866 410043616343857825 output Copy 152990443860776502 972190360051424498 Note In the first sample input this is how you get the minimum and the maximum value é¢˜æ„ï¼šç»™ nä¸ªæ•°æ±‚ä¸è¿›ä½åŠ æ³•ï¼Œä¸¤ä¸ªæ•°å’Œçš„æœ€å¤§å€¼ï¼Œæœ€å°å€¼ã€‚ é¢˜è§£ï¼šåˆ†åˆ«å¯¹æ¯ä¸ªæ•°å­—æ‹†åˆ†æˆ 18ä¸ªä½ï¼Œæ¯ä¸ªä½æ˜¯ 0-9 çš„æ•°å­—ï¼Œç„¶åç”¨æ¯ä¸ªä½å»ºä¸€ä¸ªå­—å…¸æ ‘ã€‚ å°±å½¢æˆäº†ä¸€æ£µä»¥0ç»“ç‚¹ä¸ºæ ¹èŠ‚ç‚¹ï¼Œç„¶åæ¯å±‚åˆ†é…0-9 å„¿å­èŠ‚ç‚¹çš„å­—å…¸æ ‘ï¼Œç„¶åæ¯æ¬¡æŸ¥è¯¢å’Œå½“å‰å€¼ç›¸åŠ æœ€å¤§å€¼å’Œæœ€å°å€¼ï¼Œåˆ†åˆ«æ¯æ¬¡ä»å–æ¨¡10æœ€å¤§çš„å’Œæœ€å°çš„èŠ‚ç‚¹åŒ¹é…ã€‚ ä¾‹å¦‚ å½“å‰ä½æ˜¯ 5 æœ€å¤§å€¼ç›´æ¥ä»å½“å‰ä½å„¿å­èŠ‚ç‚¹ 4å¼€å§‹æ‰¾ å¦‚æœå­˜åœ¨ç›´æ¥æ±‚ä¸¤ä¸ªæ•°çš„å’Œï¼Œå¦åˆ™ç»§ç»­3 2 1.ã€‚ã€‚ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;int cnt=1;struct Trie &#123; int son[10]; void init() &#123; for(int i=0; i&lt;10; i++) &#123; son[i]=-1; &#125; &#125;&#125; tree[maxn*20];ll p[20];void insert(int r,int pos,ll val) &#123; if(pos==-1)return ; ll v=val/p[pos]%10; if(tree[r].son[v]==-1) &#123;// printf(&quot;%d&quot;,v); tree[cnt].init(); tree[r].son[v]=cnt++; &#125; insert(tree[r].son[v],pos-1,val);&#125;ll findmx(int r,int pos,ll val) &#123; if(pos==-1)return 0; ll v=val/p[pos]%10; for(int i=9-v; i&gt;=0; i--) &#123; if(tree[r].son[i]!=-1) &#123; return (p[pos]*((v+i)%10))+findmx(tree[r].son[i],pos-1,val); &#125; &#125; for(int i=9; i&gt;9-v; i--) if(tree[r].son[i]!=-1) return (p[pos]*((v+i)%10))+findmx(tree[r].son[i],pos-1,val);&#125;ll findmi(int r,int pos,ll val) &#123; if(pos==-1)return 0; int v=val/p[pos]%10; for(int i=10-v; i&lt;=9; i++) if(tree[r].son[i]!=-1) &#123; return (p[pos]*((v+i)%10))+findmi(tree[r].son[i],pos-1,val); &#125; for(int i=0; i&lt;10-v; i++) if(tree[r].son[i]!=-1) return (p[pos]*((v+i)%10))+findmi(tree[r].son[i],pos-1,val);&#125;int main() &#123; scanf(&quot;%d&quot;,&amp;n); p[0]=1; for(int i=1; i&lt;=18; i++) &#123; p[i]=p[i-1]*10; &#125; tree[0].init(); ll mx=-1e18,mi=1e18; for(int i=0; i&lt;n; i++) &#123; ll x; scanf(&quot;%lld&quot;,&amp;x); if(i!=0) &#123; mi=min(mi,findmi(0,18,x)); mx=max(mx,findmx(0,18,x)); &#125; insert(0,18,x);// puts(&quot;&quot;); &#125; printf(&quot;%lld %lld\n&quot;,mi,mx); return 0;&#125;]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K - Random Numbers Gym - 101466K ------çº¿æ®µæ ‘+DFSåº]]></title>
    <url>%2F2018%2F08%2F19%2FK%20-%20Random%20Numbers%20Gym%20-%20101466K%20%20------%E7%BA%BF%E6%AE%B5%E6%A0%91%2BDFS%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[K. Random Numbers time limit per test 2.0 s memory limit per test 256 MB input standard input output standard output Tamref love random numbers, but he hates recurrent relations, Tamref thinks that mainstream random generators like the linear congruent generator suck. Thatâ€™s why he decided to invent his own random generator. As any reasonable competitive programmer, he loves trees. His generator starts with a tree with numbers on each node. To compute a new random number, he picks a rooted subtree and multiply the values of each node on the subtree. He also needs to compute the number of divisors of the generated number (because of cryptographical applications). In order to modify the tree (and hence create different numbers on the future), Tamref decided to perform another query: pick a node, and multiply its value by a given number. Given a initial tree _T_, where _T__u_ corresponds to the value on the node _u_, the operations can be summarized as follows: RAND: Given a node _u_ compute and count its divisors, where _T_(_u_) is the set of nodes that belong to the subtree rooted at _u_. SEED: Given a node _u_ and a number _x_, multiply _T__u_ by _x_. Tamref is quite busy trying to prove that his method indeed gives integers uniformly distributed, in the meantime, he wants to test his method with a set of queries, and check which numbers are generated. He wants you to write a program that given the tree, and some queries, prints the generated numbers and count its divisors. Tamref has told you that the largest prime factor of both _T__u_ and _x_ is at most the Tamrefâ€™s favourite prime: 13. He also told you that the root of _T_ is always node 0. The figure shows the sample test case. The numbers inside the squares are the values on each node of the tree. The subtree rooted at node 1 is colored. The RAND query for the subtree rooted at node 1 would generate 14400, which has 63 divisors. Input The first line is an integer _n_ (1 â‰¤ _n_ â‰¤ 105), the number of nodes in the tree _T_. Then there are _n_ - 1 lines, each line contains two integers _u_and _v_ (0 â‰¤ _u_, _v_ &lt; _n_) separated by a single space, it represents that _u_ is a parent of _v_ in _T_. The next line contains _n_ integers, where the _i_ - _th_ integer corresponds to _Ti_ (1 â‰¤ _Ti_ â‰¤ 109). The next line contains a number _Q_ (1 â‰¤ _Q_ â‰¤ 105), the number of queries. The final _Q_ lines contain a query per line, in the form â€œ_RAND_ _u_â€ or â€œSEED _u_ _x_â€ (0 â‰¤ _u_ &lt; _n_, 1 â‰¤ _x_ â‰¤ 109). Output For each _RAND_ query, print one line with the generated number and its number of divisors separated by a space. As this number can be very long, the generated number and its divisors must be printed modulo 109 + 7. Example input Copy 12345678910111213 80 10 21 32 42 53 63 77 3 10 8 12 14 40 153RAND 1SEED 1 13RAND 1 output Copy 12 14400 63187200 126 é¢˜æ„ï¼šå»ºä¸€é¢—æ ‘ï¼ŒæŸ¥è¯¢ æ‰€æœ‰ä»¥å½“å‰èŠ‚ç‚¹å’Œæ‰€æœ‰å„¿å­èŠ‚ç‚¹å› å­ä¸ªæ•°ï¼Œæ›´æ–°ï¼Œå•ç‚¹æ›´æ–°å€æ•°ã€‚ é¢˜è§£ï¼šé¦–å…ˆdfsæŠŠæ‰€æœ‰ä½ç½®å‡ºç°çš„åº æ’å¥½ã€‚é¢˜ç›®æ ·ä¾‹ dfs,è¿›å…¥çš„å…ˆåé¡ºåº æ˜¯ s[0]=1,s[1]=2,s[3]=2,s[6]=4,s[7]=5,s[2]=6,s[4]=7,s[5]=8; ç„¶åä¿ç•™æ¯ä¸ªèŠ‚ç‚¹æœ€åä¸€ä¸ªæ‰€è¦†ç›–çš„æœ€å¤§èŒƒå›´å¦‚ï¼š e[0]=8, å› ä¸º 0èŠ‚ç‚¹è¦†ç›–äº†æ‰€æœ‰èŠ‚ç‚¹ä¹Ÿå°±æ˜¯ 1-8 ï¼Œe[1]=5,1èŠ‚ç‚¹ è¦†ç›–äº†æ‰€æœ‰åºä» s[1]-e[1]ï¼ˆ2 - 5ï¼‰çš„èŠ‚ç‚¹ã€‚ ç„¶åä»¥åºå»ºä¸€é¢—çº¿æ®µæ ‘ï¼š æŸ¥è¯¢ï¼š x æ¯æ¬¡æŸ¥è¯¢ [s[x],e[x]]; æ›´æ–°ï¼š x æ¯æ¬¡æ›´æ–° [ s[x] ,s[x] ]; æˆ‘çš„çº¿æ®µæ ‘æ¯æ¬¡ä¿å­˜çš„æ˜¯ (l,r] ,æ‰€ä»¥ l æ¯æ¬¡è¦-1ã€‚ è¿™é¢˜æ•°æ®å¤„ç†ï¼Œæ¯ä¸ªèŠ‚ç‚¹ä¿ç•™æ‰€æœ‰ç´ æ•°å› å­ä¸ªæ•°ï¼Œç„¶åæ±‚çš„å€¼å°±æ˜¯æ‰€æœ‰ç´ æ•°çš„ä¹˜ç§¯ï¼Œå› å­ä¸ªæ•°å°±æ˜¯ç›¸åº”ç´ æ•°ä¸ªæ•°+1çš„ä¹˜ç§¯ï¼Œ å‡å¦‚ ç´ å› å­2æœ‰6ä¸ªï¼Œç´ å› å­3æœ‰ 2ä¸ª ï¼Œç´ å› å­5æœ‰2ä¸ªï¼Œè¾“å‡ºå°±æ˜¯ 2^63^25^2, 733 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=2e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;vector&lt;int&gt; G[maxn];int e[maxn],s[maxn];int val[maxn],val2[maxn];int cnt=0;int dfs(int r,int p) &#123; cnt++;// debug(r); val[cnt]=val2[r]; s[r]=cnt; for(int i=0; i&lt;G[r].size(); i++) &#123; int to=G[r][i]; if(to!=p) &#123; dfs(to,r); &#125; &#125; e[r]=cnt;&#125;int dat[maxn&lt;&lt;4][6];int prim[]= &#123;2,3,5,7,11,13&#125;;void init(int l,int r,int k) &#123; if(r-l==1) &#123; for(int i=0; i&lt;6; i++) &#123; while(val[r]%prim[i]==0) &#123; val[r]/=prim[i]; dat[k][i]++; &#125; &#125; &#125; else &#123; init(lson); init(rson); for(int i=0; i&lt;6; i++) &#123; dat[k][i]=dat[chl][i]+dat[chr][i]; &#125; &#125;&#125;void update(int a,int b,int l,int r,int k,ll x) &#123; if(b&lt;=l||a&gt;=r) &#123; return ; &#125; else if(a&lt;=l&amp;&amp;r&lt;=b) &#123; for(int i=0; i&lt;6; i++) &#123; while(x%prim[i]==0) &#123; x/=prim[i]; dat[k][i]++; &#125; &#125; return ; &#125; else &#123; update(a,b,lson,x); update(a,b,rson,x); for(int i=0; i&lt;6; i++) &#123; dat[k][i]=dat[chl][i]+dat[chr][i]; &#125; &#125;&#125;int res[6];void query(int a,int b,int l,int r,int k) &#123; if(b&lt;=l||a&gt;=r) &#123; return ; &#125; else if(a&lt;=l&amp;&amp;r&lt;=b) &#123; for(int i=0; i&lt;6; i++) &#123; res[i]+=dat[k][i]; &#125; &#125; else &#123; query(a,b,lson); query(a,b,rson); &#125;&#125;long long pow(long long x,long long n,long long mod=1e9+7) &#123; long long res=1; while(n&gt;0) &#123; if(n&amp;1)res=res*x%mod; x=x*x%mod; n&gt;&gt;=1; &#125; return res%mod;&#125;int main() &#123; int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;n; i++) &#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); G[a].push_back(b); G[b].push_back(a); &#125; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d&quot;,&amp;val2[i]); &#125; dfs(0,-1); init(0,n,0); int q; scanf(&quot;%d&quot;,&amp;q); while(q--) &#123; char ch[100]; scanf(&quot;%s&quot;,ch); if(ch[0]==&apos;R&apos;) &#123; int a; scanf(&quot;%d&quot;,&amp;a); mem(res,0); query(s[a]-1,e[a],0,n,0); ll ans=1,num=1; for(int i=0; i&lt;6; i++) &#123; ans*=pow(prim[i],res[i],mod); ans%=mod; num*=res[i]+1; num%=mod; &#125; printf(&quot;%lld %lld\n&quot;,ans%mod,num%mod); &#125; else &#123; int a; ll b; scanf(&quot;%d%lld&quot;,&amp;a,&amp;b); update(s[a]-1,s[a],0,n,0,b); &#125; &#125; return 0;&#125; 0]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[çœèµ›é€‰æ‹”-å•è°ƒé˜Ÿåˆ—]]></title>
    <url>%2F2018%2F08%2F12%2F%E7%9C%81%E8%B5%9B%E9%80%89%E6%8B%94-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[å•è°ƒé˜Ÿåˆ—å†™æ³•ã€‚ Py&amp;hyhæƒ³è„±å• Description æ€»æ‰€å‘¨çŸ¥,ï¼Œpyå’Œhyhæœ‰ååˆ†æµ“çƒˆçš„è„±å•æ„æ„¿ï¼Œä½†æ˜¯éå¸¸ä¸å¹¸ï¼Œåœ¨ä¸€ä¸ªé£å’Œæ—¥ä¸½çš„ä¸‹åˆï¼Œä»–ä»¬ç©¿è¶Šåˆ°ä¸€ä¸ªæ²¡æœ‰å¦¹å­çš„ä¸–ç•Œï¼Œä»–å¿…é¡»å›ç­”ä¸€ä¸ªé—®é¢˜æ‰èƒ½å›åˆ°æœ¬æ¥çš„ä¸–ç•Œï¼Œè¿™ä¸ªé—®é¢˜æ˜¯ç»™å‡ºä¸€ä¸ªnmçš„çŸ©é˜µï¼Œç„¶åæœ‰qæ¬¡æ“ä½œï¼Œæ¯ä¸€ä¸ªæ“ä½œï¼Œç»™å‡ºxi,yi,ti,è¡¨ç¤ºåœ¨tiæ—¶åˆ»æ‘§æ¯(xi,yi)è¿™ä¸ªæ ¼å­ï¼Œç„¶åä»–ä»¬è¦æ±‚å‡ºä¸€ä¸ªæœ€æ—©æ—¶åˆ»ï¼Œå‡ºç°è‡³å°‘ä¸€ä¸ªkkçš„çŸ©é˜µè¢«æ¯åï¼Œæ³¨æ„ï¼šä¸€ä¸ªkkçŸ©é˜µè¢«æ¯åçš„æ„æ€æ˜¯æŸä¸€ä¸ªkkçš„çŸ©é˜µä¸­çš„æ¯ä¸€ä¸ªæ ¼å­éƒ½è¢«æ‘§æ¯è¿‡ä¸€æ¬¡æˆ–ä¸€æ¬¡ä»¥ä¸Šã€‚èªæ˜çš„acmerèƒ½å¸®ä»–ä»¬å›ç­”è¿™ä¸ªé—®é¢˜å—ï¼ˆå¦‚æœæ²¡äººèƒ½acè¿™ä¸ªé¢˜ï¼Œå°±ä»£è¡¨ä»–ä»¬ä¸¤ä¸ªæ²¡æœ‰è„±å•çš„å¯èƒ½äº†å“¦ï¼‰ Input Inputï¼šé‡‡ç”¨å¤šç»„è¾“å…¥ç¬¬ä¸€è¡Œè¾“å…¥n,m,k,q,(1 â‰¤ n, m â‰¤ 500, 1 â‰¤ k â‰¤ min(n, m), 1 â‰¤ q â‰¤ nÂ·m)åˆ†åˆ«ä»£è¡¨nmçš„çŸ©é˜µï¼Œkkçš„çŸ©é˜µï¼Œå’Œqæ¬¡æ“ä½œæ¥ä¸‹æ¥qè¡Œæ¯ä¸€è¡Œè¾“å…¥xi,yi,ti(1 â‰¤ xi â‰¤ n, 1 â‰¤ yi â‰¤ m, 0 â‰¤ t â‰¤ 1e6)ï¼Œä»£è¡¨ï¼Œåœ¨tiè¿™ä¸ªæ—¶åˆ»ï¼Œxiï¼Œyiè¿™ä¸ªä½ç½®ä¼šè¢«æ‘§æ¯ Output Outï¼šè¾“å‡ºä¸€è¡Œï¼Œä»£è¡¨æœ€æ—©æ—¶åˆ»å‡ºç°è‡³å°‘ä¸€ä¸ªk*kçš„çŸ©é˜µè¢«æ¯åå¦‚æœæ°¸è¿œä¸å­˜åœ¨è¿™ä¸€ä¸ªæ—¶åˆ»ï¼Œè¾“å‡º-1 Sample Input 1 2 3 2 5 2 1 8 2 2 8 1 2 1 1 3 4 2 3 2 Sample Output 1 8 Sample Input 2 3 3 2 5 1 2 2 2 2 1 2 3 5 3 2 10 2 1 100 Sample Output 2 -1 é¢˜æ„ï¼šè‡ªå·±çœ‹ã€‚ è§£æ³•ï¼šæ ‡ç¨‹æ˜¯äºŒåˆ†+äºŒç»´å‰ç¼€å’Œï¼Œæˆ‘ä¸ªäººè§‰å¾—åŒå‘é˜Ÿåˆ—å†™æ³•æ›´ä¼˜ã€‚ é¦–å…ˆæ¯è¡Œ è®°å½• mp[i][ j-k , j ]åŒºé—´çš„æœ€å¤§å€¼ï¼Œå†åœ¨å¾—åˆ°æ¯è¡Œæ¯ä¸ªåŒºé—´æœ€å¤§å€¼çš„æ¡ä»¶ä¸‹å†æ¬¡è®°å½• æ¯åˆ—çš„æœ€å¤§å€¼ mp[i-k,i][j]; è¿™ä¸­å†™æ³•åªè¦ä¼šç”¨åŒå‘é˜Ÿåˆ—æ¥ç»´æŠ¤å•è°ƒé˜Ÿåˆ—ï¼Œå°±å¾ˆå¥½äº›ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_backconst long long mod=998244353;const int maxn=5e3+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,m,k,q;deque&lt;int&gt; dq;int mp[maxn][maxn];int mp2[maxn][maxn]; //å¼€ä¸ªmp2è®°å½•ä¸‹æ¯è¡Œä¸€ä¸ªåŒºé—´çš„æœ€å¤§å€¼int main() &#123; while(~scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;k,&amp;q)) &#123; memset(mp,inf,sizeof(mp)); while(q--) &#123; int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); mp[a][b]=min(mp[a][b],c); &#125; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=m; j++) &#123; if(j&gt;k&amp;&amp;dq.back()==mp[i][j-k]) &#123; dq.pop_back(); &#125; while(dq.size()&gt;0&amp;&amp;dq.front()&lt;mp[i][j]) &#123; dq.pop_front(); &#125; if(dq.size()==0||dq.front()&gt;=mp[i][j]) &#123; dq.push_front(mp[i][j]); &#125; mp2[i][j]=dq.back(); &#125; dq.clear(); &#125; for(int i=k; i&lt;=m; i++) &#123; for(int j=1; j&lt;=n; j++) &#123; if(j&gt;k&amp;&amp;dq.back()==mp2[j-k][i]) &#123; dq.pop_back(); &#125; while(dq.size()&gt;0&amp;&amp;dq.front()&lt;mp2[j][i]) &#123; dq.pop_front(); &#125; if(dq.size()==0||dq.front()&gt;=mp2[j][i]) &#123; dq.push_front(mp2[j][i]); &#125; mp[j][i]=dq.back(); &#125; dq.clear(); &#125; int res=inf; for(int i=k; i&lt;=n; i++) &#123; for(int j=k; j&lt;=m; j++) &#123; res=min(res,mp[i][j]); &#125; &#125; if(res&gt;1e6+1)res=-1; printf(&quot;%d\n&quot;,res); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 2532 Internship(ç½‘ç»œæµæ±‚å‰²è¾¹)]]></title>
    <url>%2F2018%2F08%2F02%2FZOJ%202532%20Internship(%E7%BD%91%E7%BB%9C%E6%B5%81%E6%B1%82%E5%89%B2%E8%BE%B9)%2F</url>
    <content type="text"><![CDATA[ZOJ2532 Internship Time Limit: 5 Seconds Memory Limit: 32768 KB CIA headquarter collects data from across the country through its classified network. They have been using optical fibres long before itâ€™s been deployed on any civilian projects. However they are still under a lot pressure recently because the data are growing rapidly. As a result they are considering upgrading the network with new technologies that provide a few times wider bandwidth. In the experiemental stage, they would like to upgrade one segment of their original network in order to see how it performs. And as a CIA intern itâ€™s your responsibility to investigate which segment could actually help increase the total bandwidth the headquarter receives, suppose that all the cities have infinite data to send and the routing algorithm is optimized. As they have prepared the data for you in a few minutes, you are told that they need the result immediately. Well, practically immediately. Input Input contains multiple test cases. First line of each test case contains three integers n, m and l, they represent the number of cities, the number of relay stations and the number of segments. Cities will be referred to as integers from 1 to n, while relay stations use integers from n+1 to n+m. You can saves assume that n + m &lt;= 100, l &lt;= 1000 (all of them are positive). The headquarter is identified by the integer 0. The next l lines hold a segment on each line in the form of a b c, where a is the source node and b is the target node, while c is its bandwidth. They are all integers where a and b are valid identifiers (from 0 to n+m). c is positive. For some reason the data links are all directional. The input is terminated by a test case with n = 0. You can safely assume that your calculation can be housed within 32-bit integers. Output For each test print the segment idâ€™s that meets the criteria. The result is printed in a single line and sorted in ascending order, with a single space as the separator. If none of the segment meets the criteria, just print an empty line. The segment id is 1 based not 0 based. Sample Input 12 1 3 1 3 2 3 0 1 2 0 1 2 1 3 1 3 1 2 3 1 3 0 2 0 0 0 Sample Output 12 3 &lt;hey here is an invisible empty line&gt; é¢˜æ„ï¼šå°±æ˜¯ç»™ä½ å‡ ä¸ªç‚¹ ç„¶åå…¨éƒ¨è¦æ±‡åˆ° ç»ˆç‚¹ 0 é—®å“ªå‡ æ¡è¾¹æµé‡ä¸Šå‡å¯ä»¥ç›´æ¥å¢å¤§æµé‡ã€‚ é¢˜è§£ï¼š é¦–å…ˆç”¨ç½‘ç»œæµè·‘ä¸€è¾¹ï¼Œç„¶åä¸€ä¸ªæ˜¯èµ·ç‚¹çš„æ®‹ä½™ç½‘ç»œï¼Œä¸€ä¸ªæ˜¯ç»ˆç‚¹çš„æ®‹ä½™ç½‘ç»œï¼Œå¦‚æœæœ‰ä¸€æ¡å˜èƒ½ä»èµ·ç‚¹æ®‹ä½™ç½‘ç»œè·‘åˆ°ç»ˆç‚¹çš„æ®‹ä½™ç½‘ç»œè‚¯å®š å°±æ˜¯å› ä¸ºä»–é™åˆ¶äº†æµé‡ï¼Œæ‰€ä»¥è¿™é¢˜å°±æ˜¯æ‰¾èƒ½è¿æ¥ä¸¤ä¸ªæ®‹ä½™ç½‘ç»œçš„çš„è¾¹ã€‚ èµ·ç‚¹æ®‹ä½™ç½‘ç»œï¼Œå°±é¡ºç€ä½ è¿çš„è¾¹æµä¸€æ¬¡å°±è¡Œäº†ã€‚ ç»ˆç‚¹æ®‹ä½™ç½‘ç»œæ˜¯é€†ç€æµä¸€éï¼Œæ˜¯ç”¨åå‘è¾¹è·‘ï¼Œè¿™ä¸€ç‚¹éœ€è¦æ³¨æ„ä¸‹ï¼Œå› ä¸ºè¿™ä¸ªæ®‹ä½™ç½‘ç»œæ˜¯ä»åˆ«çš„ç‚¹æ±‡èšåˆ°ç»ˆç‚¹ï¼Œä¸æ˜¯ä»é‡ç‚¹æµå‡ºå»ã€‚æŠŠæ‰€æœ‰èƒ½è¿æ¥ä¸¤è¾¹ç‚¹çš„ä¸”è¾¹çš„æµé‡æ˜¯0çš„è¾¹åŠ å…¥ç­”æ¡ˆå°±è¡Œï¼Œæœ€åæ’ä¸ªåºã€‚ æ€•ç†è§£ä¸äº†æ’ä¸ªå›¾ ACä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#define mem(a,b) memset(a,b,sizeof(a))using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;const long long mod=1e9+7;const int maxn=400+25;const int maxm=1e5+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,m,l,tot;struct edge &#123; int num,to,cap,rev;&#125;;vector &lt;edge&gt; G[maxn];int level[maxn];int iter[maxn];void init(int _n) &#123; for(int i=0; i&lt;=_n; i++) &#123; G[i].clear(); &#125;&#125;void bfs(int s) &#123; memset(level,-1,sizeof(level)); queue&lt;int&gt; que; level[s]=0; que.push(s); while(!que.empty()) &#123; int v= que.front(); que.pop(); for(int i=0; i&lt;G[v].size(); i++) &#123; edge &amp; e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0) &#123; level[e.to]=level[v] + 1; que.push(e.to); &#125; &#125; &#125;&#125;void add(int from,int to,int cap) &#123; edge eg; eg.to=to; eg.num=tot; eg.cap=cap; eg.rev=G[to].size(); G[from].push_back(eg); eg.num=2*n+m+1+l+tot++; eg.to=from; eg.cap=0; eg.rev=G[from].size()-1; G[to].push_back(eg);&#125;int dfs(int v,int t,int f) &#123; if(v == t)return f; for(int &amp;i = iter[v]; i &lt; G[v].size(); i++) &#123; edge &amp;e=G[v][i]; if(e.cap&gt;0 &amp;&amp; level[v]&lt;level[e.to]) &#123; int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0) &#123; e.cap-=d; G[e.to][e.rev].cap+=d; return d; &#125; &#125; &#125; return 0;&#125;int maxflow(int s,int t) &#123; int flow=0; for(;;) &#123; bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while((f = dfs(s,t,inf))&gt;0) &#123; flow +=f; &#125; &#125;&#125;int dis[maxn],dis2[maxn];void dfs1(int x) &#123; dis[x]=1; for(int i=0; i&lt;G[x].size(); i++) &#123; if(dis[G[x][i].to]==-1&amp;&amp;G[x][i].cap!=0) &#123; dfs1(G[x][i].to); &#125; &#125;&#125;void dfs2(int x) &#123; dis2[x]=1; for(int i=0; i&lt;G[x].size(); i++) &#123; if(dis2[G[x][i].to]==-1&amp;&amp;G[G[x][i].to][G[x][i].rev].cap!=0) &#123; dfs2(G[x][i].to); &#125; &#125;&#125;int main() &#123; while(~scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;l)&amp;&amp;(m+n+l)) &#123; init(n+m+1); tot=1; for(int i=0; i&lt;l; i++) &#123; int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); add(a,b,c); &#125; for(int i=1; i&lt;=n; i++) &#123; add(n+m+1,i,inf); &#125; maxflow(n+m+1,0); mem(dis,-1); mem(dis2,-1); dfs1(n+m+1); dfs2(0); vector&lt;int&gt; v; v.clear(); for(int i=1; i&lt;=n+m; i++) &#123; if(dis[i]==1) &#123; for(int j=0; j&lt;G[i].size(); j++) &#123; if(G[i][j].num&lt;=l&amp;&amp;dis2[G[i][j].to]==1&amp;&amp;G[i][j].cap==0) &#123; v.push_back(G[i][j].num); &#125; &#125; &#125; &#125; if(v.size()==0) &#123; puts(&quot;&quot;); &#125; else &#123; sort(v.begin(),v.end()); for(int i=0; i&lt;v.size(); i++) &#123; printf(&quot;%d%c&quot;,v[i],i+1==v.size()?&apos;\n&apos;:&apos; &apos;); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Multi-University Training Contest 2]]></title>
    <url>%2F2018%2F07%2F29%2F2018%20Multi-University%20Training%20Contest%202%201007%20Naive%20Operations%2F</url>
    <content type="text"><![CDATA[HDU 6135 Naive Operations Time Limit: 6000/3000 MS (Java/Others) Memory Limit: 502768/502768 K (Java/Others) Total Submission(s): 2438 Accepted Submission(s): 1074 Problem Description In a galaxy far, far away, there are two integer sequence a and b of length n. b is a static permutation of 1 to n. Initially a is filled with zeroes. There are two kind of operations: add l r: add one for al,al+1â€¦ar query l r: query âˆ‘ri=lâŒŠai/biâŒ‹ Input There are multiple test cases, please read till the end of input file. For each test case, in the first line, two integers n,q, representing the length of a,b and the number of queries. In the second line, n integers separated by spaces, representing permutation b. In the following q lines, each line is either in the form â€˜add l râ€™ or â€˜query l râ€™, representing an operation.1â‰¤n,qâ‰¤100000, 1â‰¤lâ‰¤râ‰¤n, thereâ€™re no more than 5 test cases. Output Output the answer for each â€˜queryâ€™, each one line. Sample Input 5 12 1 5 2 4 3 add 1 4 query 1 4 add 2 5 query 2 5 add 3 5 query 1 5 add 2 4 query 1 4 add 2 5 query 2 5 add 2 2 query 1 5 Sample Output 1 1 2 4 4 6 Source 2018 Multi-University Training Contest 2 æ¯”èµ›çš„æ—¶å€™å†™äº†åŠå¤©æ²¡å†™å‡ºæ¥ï¼Œç»“æœå‘ç°æ˜¯çº¿æ®µæ ‘æ¿å­æ•²é”™äº†-_-||| ç»™ä¸€æ®µåŒºé—´ï¼ŒåŒºé—´çš„å€¼å…¨éƒ¨åŠ +1 æŸ¥è¯¢ åŒºé—´ a[i]/b[i]å‘ä¸‹å–æ•´çš„å’Œã€‚ å› ä¸ºæŸ¥è¯¢a[i]/b[i]å‘ä¸‹å–æ•´ï¼Œç›´æ¥æ±‚æœ‰ç‚¹éš¾ã€‚ æ‰€ä»¥æˆ‘ä»¬æ¢ä¸ªæ“ä½œï¼Œæˆ‘ä»¬æ¯æ¬¡åŒºé—´åŠ ä¸€ï¼Œå˜æˆæŠŠæ¯ä¸ªå€¼å‡ä¸€ï¼Œæ¯æ¬¡å‡åˆ°0çš„æ—¶å€™ai/biçš„å€¼å°±ä¼š+1ï¼Œæˆ‘ä»¬è®°å½•è¿™ä¸ª+1ï¼Œå†æŠŠå€¼é‡æ–°æ›´æ–°ä¸ºbiï¼ŒæŸ¥è¯¢çš„æ—¶å€™æŸ¥è¯¢+1 çš„æ€»å’Œã€‚ ç”¨çº¿æ®µæ ‘ä¿ç•™æœ€å°å€¼ï¼Œå½“å‡ºç°æœ€å°å€¼ä¸º0çš„æ—¶å€™æŠŠcnt++ï¼Œå€¼æ›´æ–°ä¸ºb[r]ï¼Œå› ä¸ºæ¯æ¬¡åªä¼šåŠ +1æ‰€ä»¥æ€»æ•°ä¸ä¼šå¤ªå¤§ å¦‚ï¼š 1 2 3 4 5 add 1 4 åŒºé—´å€¼ 0 1 2 3 5 ,å‡ºç°æœ€å°å€¼ 0 æ‰€ä»¥åŒºé—´ cnt++ æŠŠé›¶å˜ä¸º b[i] 1 1 2 3 5 ç„¶åä¸€ç›´ä¸‹å»ï¼ŒæŸ¥è¯¢ç›´æ¥æŸ¥è¯¢cnt æ€»å’Œå°±è¡Œã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxn=1e5+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int b[4*maxn]; int n,q;int dat[4*maxn],lazy[4*maxn];//lazyä¿å­˜åŒºé—´æ‰€åŠ çš„å€¼ dat ä¸ºæœ€å°å€¼ã€‚int res;int cnt[maxn*4]; // ä¿å­˜æ¯ä¸ªåŒºé—´é‡Œé¢çš„æ€»ä¸ªæ•°void init(int l,int r,int k) &#123; //åˆå§‹åŒ– int chl=2*k+1,chr=2*k+2,mid=(l+r)&gt;&gt;1; if(r-l==1) &#123; lazy[k]=cnt[k]=0; dat[k]=b[r]; return ; &#125; else &#123; lazy[k]=cnt[k]=0; init(l,mid,chl); init(mid,r,chr); dat[k]=min(dat[chl],dat[chr]); &#125;&#125;int sum(int a,int c,int l,int r,int k) &#123;//æŸ¥è¯¢æ€»ä¸ªæ•° int chl=2*k+1,chr=2*k+2,m=(l+r)/2; if(c&lt;=l||a&gt;=r) &#123; //ä¸åœ¨åŒºé—´å†… return 0; &#125; else if(a&lt;=l&amp;&amp;r&lt;=c) &#123; //è¦†ç›–è¿™ä¸ªåŒºé—´ return cnt[k]; &#125; else &#123; lazy[chl]+=lazy[k]; //æŠŠlazy æ›´æ–°ä¸‹å» lazy[chr]+=lazy[k]; lazy[k]=0; dat[k]=min(dat[chl]+lazy[chl],dat[chr]+lazy[chr]); return sum(a,c,l,(l+r)/2,k*2+1)+sum(a,c,(l+r)/2,r,k*2+2); &#125;&#125;void update(int a,int c,int l,int r,int k) &#123; int chl=2*k+1,chr=2*k+2,mid=(l+r)/2; if(c&lt;=l||a&gt;=r) &#123; return ; &#125; else if(a&lt;=l&amp;&amp;r&lt;=c) &#123; if(lazy[k]+dat[k]-1&lt;=0) &#123; //å¦‚æœæ‰€è¦†ç›–çš„åŒºé—´å‡ä¸€å‡ºç°å€¼å°äºç­‰äº0 å°±å»æ‰¾é‚£ä¸ªå€¼ if(r-l==1) &#123; cnt[k]++; //æ‰¾åˆ°å cnt ++ dat[k]=b[r]; lazy[k]=0; //æŠŠå½“å‰ç»“ç‚¹çš„å€¼é‡æ–°æ›´æ–°ä¸ºb[r] return ; &#125; lazy[chl]+=lazy[k]; //å‘ä¸‹æ›´æ–°lazy lazy[chr]+=lazy[k]; lazy[k]=0; update(a,c,l,mid,chl); //å‘å·¦å³å„¿å­ç»“ç‚¹æ‰¾ update(a,c,mid,r,chr); if(r-l!=1) &#123; cnt[k]=cnt[chl]+cnt[chr]; dat[k]=min(dat[chl]+lazy[chl],dat[chr]+lazy[chr]); //æ›´æ–°å€¼ &#125; return; &#125; lazy[k]--; //å¦‚æœæ²¡æœ‰å°±ç›´æ¥æŠŠlazyå‡ä¸€ &#125; else &#123; // å¤§åŒºé—´æœ‰ä¸€éƒ¨åˆ†åœ¨å°åŒºé—´å†… lazy[chl]+=lazy[k]; lazy[chr]+=lazy[k]; update(a,c,l,mid,chl); update(a,c,mid,r,chr); lazy[k]=0; dat[k]=min(dat[chl]+lazy[chl],dat[chr]+lazy[chr]); //æ›´æ–° if(r-l!=1)cnt[k]=cnt[chl]+cnt[chr]; &#125;&#125;char ch[10];int l,r;int main() &#123; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;q)!=EOF) &#123; for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;b[i]); &#125; init(0,n,0); while(q--) &#123; scanf(&quot;%s%d%d&quot;,ch,&amp;l,&amp;r); if(ch[0]==&apos;a&apos;) &#123; update(l-1,r,0,n,0); //æˆ‘å†™çš„çº¿æ®µæ˜¯æ˜¯(l,r] æ‰€ä»¥è¦è®°å¾—-1 &#125; else &#123; printf(&quot;%d\n&quot;,sum(l-1,r,0,n,0)); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-4389 X mod f(x) æ•°ä½DP]]></title>
    <url>%2F2018%2F07%2F29%2FHDU-4389%20X%20mod%20f(x)%20%20%E6%95%B0%E4%BD%8DDP%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ ï¼šHDU - 4389 X mod f(x) Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 3619 Accepted Submission(s): 1409 Problem Description Here is a function f(x): int f ( int x ) { if ( x == 0 ) return 0; return f ( x / 10 ) + x % 10; } Now, you want to know, in a given interval [A, B] (1 &lt;= A &lt;= B &lt;= 109), how many integer x that mod f(x) equal to 0. Input The first line has an integer T (1 &lt;= T &lt;= 50), indicate the number of test cases. Each test case has two integers A, B. Output For each test case, output only one line containing the case number and an integer indicated the number of x. Sample Input 2 1 10 11 20 Sample Output Case 1: 10 Case 2: 3 Author WHU Source 2012 Multi-University Training Contest 9 Recommend zhuyuanchen520 æ•°ä½DP æ‰€æœ‰æ•°çš„å’Œæœ€å¤§ä¸è¶…è¿‡82 dp[pos][sum][mod][res] ï¼Œpos ç¬¬å‡ ä½ï¼Œsum åˆ°ç¬¬å‡ ä½æ¯ä¸ªä½æ•°åŠ èµ·æ¥çš„å’Œï¼Œmodï¼Œ å–æ¨¡å¤šå°‘ ã€‚ä½™æ•°æ˜¯res ,çŠ¶æ€ä¸‹æœ‰å¤šå°‘ä¸ªæ•°ã€‚ ç„¶åç›´æ¥ç”¨foræš´åŠ›å–æ¨¡çš„æ•°çš„æ‰€æœ‰æƒ…å†µã€‚ å¥—ä¸ªæ•°ä½DPçš„æ¿å­å°±è¡Œ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 #include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;typedef int ll;int dp[10][82][82][82];// æ‰€æœ‰æ•°çš„å’Œæœ€å¤§ä¸è¶…è¿‡82 dp[pos][sum][mod][res] ï¼Œpos ç¬¬å‡ ä½ï¼Œsum åˆ°ç¬¬å‡ ä½æ¯ä¸ªä½æ•°åŠ èµ·æ¥çš„å’Œï¼Œmodï¼Œ å–æ¨¡å¤šå°‘ ã€‚ä½™æ•°æ˜¯res ,çŠ¶æ€ä¸‹æœ‰å¤šå°‘ä¸ªæ•°ã€‚int a[25];ll dfs(int pos,ll sum,ll mod,ll res,bool limit) &#123; //çŠ¶æ€ pos sum,mod,res, ä¸Šçº¿æƒ…å†µlimit if(sum&gt;mod)return 0; if(pos==-1) &#123; //å½“æšä¸¾å®Œæœ€åä¸€ä½è¿”å› if(sum==mod&amp;&amp;res==0)return 1; //æ»¡è¶³æ¡ä»¶è¿”å›1 else return 0; //ä¸æ»¡è¶³è¿”å›0 &#125; if(limit==0&amp;&amp;dp[pos][sum][mod][res]!=-1)return dp[pos][sum][mod][res];//å¦‚æœå½“å‰çŠ¶æ€æ˜¯å·²ç»æœ‰è¿‡è®°å½•ä¸”å½“å‰æ²¡æœ‰é™åˆ¶å°±ç›´æ¥è¿”å›å·²ç»è®°å½•çš„å€¼ ll up=limit?a[pos]:9,cnt=0;//æœ€å¤§å¯ä»¥æšä¸¾åˆ°up,å¦‚æœå½“å‰æ²¡æœ‰ä¸Šé™å°±å¯ä»¥ 0-9,å¦åˆ™åªèƒ½åˆ°å½“å‰ä½çš„æœ€å¤§å€¼ï¼Œcnt è®°å½•æ€»å…±å¤šå°‘ for(int i=0; i&lt;=up; i++) &#123; //è·³è½¬çŠ¶æ€ï¼Œå‰ä¸€ä½ï¼Œæ€»å’ŒåŠ ä¸Šå€¼ï¼Œå–æ¨¡æ•°ä¸å˜ï¼Œæ›´æ–°ä½™æ•°ï¼Œå¦‚æœå½“å‰æœ‰ä¸Šé™ï¼Œåˆ‡åŠ å…¥çš„å€¼å·²ç»åˆ°è¾¾å½“å‰ä¸Šé™ ä¸‹ä¸€ç§æƒ…å†µæ‰æœ‰ä¸Šçº¿ cnt+=dfs(pos-1,sum+i,mod,(res*10+i)%mod,limit&amp;&amp;i==a[pos]); &#125; if(limit==0)dp[pos][sum][mod][res]=cnt; //å½“å‰çŠ¶æ€æ˜¯æ²¡æœ‰ä¸Šé™çš„æƒ…å†µä¸‹æ±‚çš„å’Œï¼Œå°±å¯ä»¥è®°å½•å½“å‰çŠ¶æ€ return cnt; &#125;ll n,m;ll solve(ll x) &#123; int pos=0; while(x&gt;0) &#123; a[pos++]=x%10; x/=10; &#125; ll ans=0; for(int i=1; i&lt;82; i++) &#123; ans+=dfs(pos-1,0,i,0,true); //ç›´æ¥ç”¨foræš´åŠ›å–æ¨¡çš„æ•°çš„æ‰€æœ‰æƒ…å†µã€‚ &#125; return ans;&#125;int main() &#123; ios_base::sync_with_stdio(0); int t; memset(dp,-1,sizeof(dp)); cin&gt;&gt;t; int l=0; while(t--) &#123; l++; cin&gt;&gt;n&gt;&gt;m; cout&lt;&lt;&quot;Case &quot;&lt;&lt;l&lt;&lt;&quot;: &quot;; cout&lt;&lt;solve(m)-solve(n-1)&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç‰›å®¢ç»ƒä¹ 23]]></title>
    <url>%2F2018%2F07%2F28%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A023%2F</url>
    <content type="text"><![CDATA[ç‰›å®¢ç»ƒä¹ èµ›23 è¿™æ¬¡ç‰›å®¢ç»ƒä¹ èµ›ï¼Œéƒ½è€ƒäº†ä¸€ç‚¹å°æŠ€å·§ã€‚ A éšä¾¿æ¨¡æ‹Ÿä¸€ä¸‹ é“¾æ¥ï¼šhttps://www.nowcoder.com/acm/contest/156/A æ¥æºï¼šç‰›å®¢ç½‘ æ—¶é—´é™åˆ¶ï¼šC/C++ 1ç§’ï¼Œå…¶ä»–è¯­è¨€2ç§’ ç©ºé—´é™åˆ¶ï¼šC/C++ 262144Kï¼Œå…¶ä»–è¯­è¨€524288K 64bit IO Format: %lld é¢˜ç›®æè¿° ç´§å¼ åˆºæ¿€çš„ä¸–ç•Œæ¯æ­£åœ¨è¿›è¡Œä¸­(åœ¨æ‰˜ç±³çš„ä¸–ç•Œçº¿é‡Œ)ï¼Œæ¬§æ´²äººæ‰˜ç±³æ²‰è¿·äºèµŒçƒæ— æ³•è‡ªæ‹”ã€‚ æ‰˜ç±³çš„å£è¢‹é‡Œæœ‰ 100 å…ƒï¼Œ50å…ƒï¼Œ20å…ƒï¼Œ10å…ƒï¼Œ5å…ƒï¼Œ2å…ƒï¼Œ1å…ƒçš„çº¸å¸ï¼Œ50åˆ†ï¼Œ20åˆ†ï¼Œ10åˆ†ï¼Œ5åˆ†ï¼Œ2åˆ†ï¼Œ1åˆ†çš„ç¡¬å¸å„æ— é™ä¸ªã€‚ æ‰˜ç±³è®¡åˆ’ä¹°ä¸‹å‡ æ³¨ a å…ƒ b åˆ†çš„å½©ç¥¨ï¼Œä»–å¸Œæœ›èƒ½æ”¯å‡ºçš„çº¸ç¥¨æ•°é‡å’Œç¡¬å¸æ•°é‡ä¹‹å’Œæœ€å°ï¼Œä»–å¸Œæœ›ä½ å¸®åŠ©ä»–å®Œæˆè¿™ä¸ªä»»åŠ¡ã€‚åŒæ—¶ç”±äºå½©ç¥¨äº­ä¸æ”¯æŒæ‰¾é›¶ï¼Œæ‰˜ç±³å¸Œæœ›ä»–çš„æ”¯å‡ºæ°å¥½ç­‰äº a å…ƒ b åˆ† è¾“å…¥æè¿°:1ç¬¬ä¸€è¡Œè¾“å…¥ä¸€ä¸ªæ­£æ•´æ•° Tä¸‹é¢ T è¡Œæ¯è¡Œä¸¤ä¸ªæ•´æ•° a,b è¾“å‡ºæè¿°:1æ¯è¡Œè¾“å‡º 13 ä¸ªæ­£æ•´æ•° n1 ...n13, å¯¹åº”é¢˜é¢é¡ºåºç»™å‡ºæœ€å°åŒ–æ”¯å‡ºçº¸ç¥¨æ•°é‡å’Œç¡¬å¸æ•°é‡ä¹‹å’Œçš„æƒ…å†µä¸‹ï¼Œæ¯ç§è´§å¸çš„ä½¿ç”¨æ¬¡æ•°ï¼Œå¦‚æœæœ‰å¤šç§æ–¹æ¡ˆï¼Œè¾“å‡ºå­—å…¸åºæœ€å¤§çš„ä¸€ç§ï¼Œæ³¨æ„è¿™é‡Œå­—å…¸åºæ˜¯ä¾æ¬¡æ¯”è¾ƒn1åˆ°n13ï¼Œè€Œä¸æ˜¯ç®€å•çš„æŠŠ 13 ä¸ªæ­£æ•´æ•°æ‹¼æ¥åœ¨ä¸€èµ· ç¤ºä¾‹1 è¾“å…¥ å¤åˆ¶ 123 21 52 4 è¾“å‡º å¤åˆ¶ 12 0 0 0 0 0 0 1 0 0 0 1 0 00 0 0 0 0 1 0 0 0 0 0 2 0 å¤‡æ³¨:1T=100,0â‰¤ aâ‰¤ 109, 0â‰¤ b&lt;100 12345678910111213141516171819202122232425262728 #include&lt;bits/stdc++.h&gt;using namespace std;int a[7]= &#123;100,50,20,10,5,2,1&#125;;int b[6]= &#123;50,20,10,5,2,1&#125;;int a1[7],b1[6];int main() &#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; int x,y; cin&gt;&gt;x&gt;&gt;y; for(int i=0; i&lt;7; i++) &#123; a1[i]=x/a[i]; x=x%a[i]; &#125; for(int i=0; i&lt;6; i++) &#123; b1[i]=y/b[i]; y%=b[i]; &#125; for(int i=0; i&lt;7; i++) &#123; printf(&quot;%d%c&quot;,a1[i],&apos; &apos;); &#125; for(int i=0; i&lt;6; i++) &#123; printf(&quot;%d%c&quot;,b1[i],i==5?&apos;\n&apos;:&apos; &apos;); &#125; &#125; return 0;&#125; B é“¾æ¥ï¼šhttps://www.nowcoder.com/acm/contest/156/B æ¥æºï¼šç‰›å®¢ç½‘ æ—¶é—´é™åˆ¶ï¼šC/C++ 1ç§’ï¼Œå…¶ä»–è¯­è¨€2ç§’ ç©ºé—´é™åˆ¶ï¼šC/C++ 262144Kï¼Œå…¶ä»–è¯­è¨€524288K 64bit IO Format: %lld é¢˜ç›®æè¿° æ¬§æ´²äººæ‰˜ç±³éå¸¸å–œæ¬¢æ•°å­—ï¼Œä»–ç»å¸¸åœ¨ç©ºé—²æ—¶ç©ä¸‹é¢çš„æ¸¸æˆ å¯¹äºä¸€ä¸ªæ•°å­— n, æ‰˜ç±³ä¼šéšæ€§é€‰ä¸­ä¸€ä¸ªæ•° p, (1 ï¼œ p &lt;= n), å°† n æ‹†åˆ†æˆ ,v=n-u,å¹¶å¯¹ u,v é‡å¤è¿™ä¸ªè¿‡ç¨‹ï¼Œç›´åˆ°ä»–æœ‰äº† n ä¸ª 1 1317 ä¸ºäº†æŒ‘æˆ˜æ‰˜ç±³ï¼Œåœ¨æ¯æ¬¡æ‰˜ç±³è¿›è¡Œåˆ’åˆ†æ—¶ï¼Œä¼šç»™æ‰˜ç±³å¥–åŠ± u * v çš„åˆ†æ•°ï¼Œæ‰˜ç±³å¸Œæœ›ä½ èƒ½å¸®ä»–æœ€å¤§åŒ–ä»–çš„å¾—åˆ†ã€‚ è¾“å…¥æè¿°:1ç¬¬ä¸€è¡Œä¸€ä¸ªæ­£æ•´æ•° Tä¸‹é¢ T è¡Œæ¯è¡Œä¸€ä¸ªæ­£æ•´æ•° n è¾“å‡ºæè¿°:1å¯¹äºæ¯ç»„æ•°æ®ï¼Œè¾“å‡ºæ‰˜ç±³çš„æœ€å¤§å¾—åˆ† ç¤ºä¾‹1 è¾“å…¥ å¤åˆ¶ 11 5 è¾“å‡º å¤åˆ¶ 110 å¤‡æ³¨:1Tâ‰¤ 104, nâ‰¤ 109 æ¨å…¬å¼ 2 = 1*1 3 =12 +11; 4=13 +12+1*1; è§„å¾‹å°±æ˜¯ Sn = (n*(n-1))/2; 12345678910111213 #include&lt;bits/stdc++.h&gt;using namespace std;long long n;int main() &#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%lld&quot;,&amp;n); printf(&quot;%lld\n&quot;,(n*(n-1))/2); &#125; return 0;&#125; C é“¾æ¥ï¼šhttps://www.nowcoder.com/acm/contest/156/C æ¥æºï¼šç‰›å®¢ç½‘ æ—¶é—´é™åˆ¶ï¼šC/C++ 1ç§’ï¼Œå…¶ä»–è¯­è¨€2ç§’ ç©ºé—´é™åˆ¶ï¼šC/C++ 262144Kï¼Œå…¶ä»–è¯­è¨€524288K 64bit IO Format: %lld é¢˜ç›®æè¿° æ‰˜ç±³å®Œæˆäº†1317çš„ä¸Šä¸€ä¸ªä»»åŠ¡ï¼Œååˆ†é«˜å…´ï¼Œå¯æ˜¯è€ƒéªŒè¿˜æ²¡æœ‰ç»“æŸ è¯´è¯é—´1317ç»™äº†æ‰˜ç±³ n ä¸ªè‡ªç„¶æ•° a1â€¦ an, æ‰˜ç±³å¯ä»¥é€‰å‡ºä¸€äº›å¸¦å›å®¶ï¼Œä½†æ˜¯ä»–é€‰å‡ºçš„æ•°éœ€è¦æ»¡è¶³ä¸€äº›æ¡ä»¶ è®¾æ‰˜ç±³é€‰å‡ºæ¥äº†k ä¸ªæ•° b1,b2â€¦ bk, è®¾è¿™ä¸ªæ•°åˆ— b çš„ç»™å€¼ä¸º b ä¸­æ‰€æœ‰æ•°æŒ‰ä½ä¸çš„ç»“æœï¼Œå¦‚æœä½ èƒ½æ‰¾åˆ°ä¸€ä¸ªæ•´é™¤ b çš„æœ€å¤§çš„ 2v,(vâ‰¥ 0)ï¼Œ åˆ™è®¾å®š v ä¸ºè¿™ä¸ªæ•°åˆ—çš„ç»™ä»·ï¼Œå¦‚æœä¸å­˜åœ¨è¿™æ ·çš„ vï¼Œåˆ™ç»™ä»·å€¼ä¸º -1, 1317 å¸Œæœ›æ‰˜ç±³åœ¨æœ€å¤§åŒ–ç»™ä»·çš„æƒ…å†µä¸‹ï¼Œæœ€å¤§åŒ– k è¾“å…¥æè¿°:1ç¬¬ä¸€è¡Œè¾“å…¥ä¸€ä¸ªæ•´æ•° n, ç¬¬äºŒè¡Œè¾“å…¥ a1...an è¾“å‡ºæè¿°:1ç¬¬ä¸€è¡Œè¾“å‡ºæœ€å¤§çš„æ•´æ•° k, ç¬¬äºŒè¡Œè¾“å‡º k ä¸ªæ•´æ•° b1... bk, æŒ‰åŸæ•°åˆ—çš„ç›¸å¯¹é¡ºåºè¾“å‡º (å¦‚æœè¡Œæœ«æœ‰é¢å¤–ç©ºæ ¼å¯èƒ½ä¼šæ ¼å¼é”™è¯¯) ç¤ºä¾‹1 è¾“å…¥ å¤åˆ¶ 12 51 2 3 4 5 è¾“å‡º å¤åˆ¶ 12 24 5 å¤‡æ³¨:1nâ‰¤ 105, a1... an &lt; 231 é¢˜ç›®æ¯’ç˜¤è¯»äº†åŠå¤© ç»™ä½ ä¸€ä¸ª n ä¸ªæ•° a1 â€¦an,é€‰å‡ ä¸ªæ•° b1â€¦bk ç„¶åå…¨éƒ¨&amp;å b=b1&amp;b2â€¦&amp;bk, b&amp;2^v==0, væœ€å¤§å°±æ˜¯å½“å‰é€‰çš„è¿™ä¸ªbåºåˆ—çš„å€¼ï¼› æ±‚ Væœ€å¤§çš„æƒ…å†µä¸‹Kæœ€å¤§ã€‚ é¢˜è§£ ï¼šä»æœ€é«˜ä½ä¸º1 &amp;åˆ°æœ€ä½ä½æ˜¯1 ä¸€è·¯ä¸‹æ¥å°±è¡Œã€‚v çš„å€¼æ˜¯æŒ‰ä½äºä¹‹åæœ€åä¸€ä½ä¸º 1çš„ä½ç½®ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 #include&lt;bits/stdc++.h&gt;using namespace std;long long n;typedef long long ll;const int maxn=1e5+5;ll a[maxn],x[maxn];int main() &#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%lld&quot;,&amp;a[i]); &#125; for(int i=0; i&lt;=31; i++) &#123; //é¢„å¤„ç†ä¸‹æœ€é«˜ä½ä½ç½®çš„å€¼ x[i]=1&lt;&lt;i; &#125; int k=0,flag=0,bi=0; ll v=0,m=-1; for(int i=31; i&gt;=0; i--) &#123;//ä»æœ€é«˜ä¸ºå¤„ç†åˆ°æœ€ä½ä½ int t=0; flag=0; for(int j=0; j&lt;n; j++) &#123; if((a[j]&amp;x[i])==x[i]) &#123; //æŠŠé«˜äºæœ€é«˜ä½çš„å€¼å…¨éƒ¨é€‰ä¸Š if(t==0) &#123; flag=a[j]; &#125; else &#123; flag&amp;=a[j]; &#125; t++; &#125; &#125; int pos=0; while(flag&gt;0&amp;&amp;(flag&amp;1)==0) &#123; //åˆ¤æ–­v çš„ä½ç½® pos++; flag&gt;&gt;=1; &#125; if(pos&gt;m||(pos==m&amp;&amp;t&gt;k)) &#123; //æ›´æ–°å€¼ m=pos; v=flag&lt;&lt;pos; k=t; &#125; &#125; printf(&quot;%d\n&quot;,k); for(int i=0; i&lt;n; i++) &#123; if((a[i]&amp;v)==v) &#123; //æŠŠæ‰€æœ‰èƒ½æŒ‰ä½äºæˆ v çš„å…¨éƒ¨è¾“å‡ºã€‚ k--; printf(&quot;%lld%c&quot;,a[i],k==0?&apos;\n&apos;:&apos; &apos;); &#125; &#125; return 0;&#125; æœ‰ç‚¹éš¾æ‡‚ï¼Œçœ‹ä¸æ‡‚ç•™è¨€ã€‚ D é“¾æ¥ï¼šhttps://www.nowcoder.com/acm/contest/156/D æ¥æºï¼šç‰›å®¢ç½‘ æ—¶é—´é™åˆ¶ï¼šC/C++ 1ç§’ï¼Œå…¶ä»–è¯­è¨€2ç§’ ç©ºé—´é™åˆ¶ï¼šC/C++ 262144Kï¼Œå…¶ä»–è¯­è¨€524288K 64bit IO Format: %lld é¢˜ç›®æè¿° æ‰˜ç±³æ²¡æœ‰å®Œæˆä¸Šä¸€ä¸ªä»»åŠ¡ï¼Œå‡†å¤‡æ–½å±•é»‘é­”æ³•æ¨å€’ 1317 é»‘é­”æ³•å’’è¯­è¢«æè¿°ä¸ºä¸€ä¸ª é•¿ä¸º n çš„ï¼Œä»…åŒ…å«å°å†™è‹±æ–‡å­—æ¯ â€˜aâ€™â€¦â€™iâ€™ çš„å­—ç¬¦ä¸²ï¼Œåœ¨æ‰˜ç±³æ‰€åœ¨çš„æ˜Ÿçƒï¼Œé­”æ³•é€ æˆçš„æ¯æ¬¡æœ‰æ•ˆä¼¤å®³éƒ½æ˜¯æ¥è‡ªä»–çš„ä¸€ä¸ªå­åºåˆ—ï¼Œå¯¹äºæ¯ä¸€ä¸ª â€˜aâ€™â€¦ â€˜iâ€™ çš„æ’åˆ—(å…± 9! ç§)ï¼Œè‹¥ä½œä¸ºå’’è¯­çš„å­åºåˆ—å‡ºç°, å°±ä¼šé€ æˆ 1 çš„ä¼¤å®³ è€Œå’’è¯­çš„æ€»ä¼¤å®³ä¸ºæ‰€æœ‰ â€˜aâ€™â€¦ â€˜iâ€™ çš„æ’åˆ—é€ æˆçš„ä¼¤å®³å€¼ä¹‹å’Œï¼Œæ‰˜ç±³èƒ½æ‰“å‡ºå¤šå°‘ç‚¹çš„ä¼¤å®³ï¼Œæ˜¯å¦èƒ½å‡»è´¥ 1317 å‘¢ï¼Ÿ è¾“å…¥æè¿°:1ä¸€è¡Œè¾“å…¥ä¸€ä¸ªå­—ç¬¦ä¸² s è¾“å‡ºæè¿°:1ä¸€è¡Œè¾“å‡ºä¸€ä¸ªæ•°ï¼Œè¡¨ç¤ºä¼¤å®³å€¼ ç¤ºä¾‹1 è¾“å…¥ å¤åˆ¶ 1aabcdefghi è¾“å‡º å¤åˆ¶ 11 å¤‡æ³¨:1|s| â‰¤ 3000 ä¼˜é›…çš„æš´åŠ›ã€‚ å…¨æ’åˆ—æ‰€æœ‰æƒ…å†µï¼ŒäºŒåˆ†æŸ¥æ‰¾è¿™ç§æƒ…å†µåœ¨å­—ç¬¦ä¸²é‡Œé¢å¯ä¸å¯è¡Œï¼Œç„¶åä¸€ä¸ªä¸ªåŠ ä¸Šã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=4e5+5;char ch[maxn];int n[maxn];vector&lt;int&gt; v[10];int dp[maxn][9];int main() &#123; int ans[9]= &#123;0,1,2,3,4,5,6,7,8&#125;; int k=0; do &#123; for(int i=0; i&lt;9; i++) &#123; dp[k][i]=ans[i]; &#125; k++; &#125; while(next_permutation(ans,ans+9)); cin&gt;&gt;ch; int l=strlen(ch); for(int i=0; i&lt;l; i++) &#123; n[i]=ch[i]-&apos;a&apos;; v[n[i]].push_back(i); &#125; int res=0; for(int i=0; i&lt;k; i++) &#123; int p=-1; for(int j=0; j&lt;9; j++) &#123; int num=dp[i][j]; if(upper_bound(v[num].begin(),v[num].end(),p)==v[num].end()) &#123; break; &#125; int t=upper_bound(v[num].begin(),v[num].end(),p)-v[num].begin(); p=v[num][t]; if(j==8) &#123; res++; &#125; &#125; &#125; cout&lt;&lt;res&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ä¸€äº›å‡½æ•°è¦è®°çš„å‡½æ•°ç¬”è®°]]></title>
    <url>%2F2018%2F07%2F25%2F%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%E8%A6%81%E8%AE%B0%E7%9A%84%E5%87%BD%E6%95%B0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[__builtin_popcount() æ±‚äºŒè¿›åˆ¶ 1çš„ä¸ªæ•°ã€‚ double add(double a,double b) { if(abs(a+b)&lt;eps *(abs(a)+abs(b))) return 0; return a+b; } ä¸€ä¸ª å‘é‡æ“ä½œç»“æ„ä½“ã€‚ const double eps =1e-8; struct P { double x,y; P() {} P(double x,double y):x(x),y(y) {} P operator + (P p) { return P(add(x,p.x),add(y,p.y)); } P operator - (P p) { return P(add(x,-p.x),add(y,-p.y)); } P operator (double d) { return P(xd,yd); } double dot (P p) { //å‘é‡ç§¯ return add(xp.x,yp.y); } double det(P p) { //æ•°é‡ç§¯ return add(xp.y,-y*p.x); } }; double Distance(P a,P b) { return sqrt((a.x-b.x)(a.x-b.x)+(a.y-b.y)(a.y-b.y)); } double InterArea(P a,double R,P b,double r) { if(R=R+r) //ä¸¤åœ†ç›¸ç¦»ï¼Œç›¸äº¤é¢ç§¯ä¸º0 return 0; if(dis&lt;=R-r) //ä¸¤åœ†å†…å«ï¼Œç›¸äº¤é¢ç§¯ä¸ºå°åœ†çš„é¢ç§¯ return PIrr; //ä¸¤åœ†ç›¸äº¤æ—¶ double angle1=acos((RR+disdis-rr)/(2.0Rdis)); //å¤§åœ†çš„é‚£ä¸ªè§’ double angle2=acos((rr+disdis-RR)/(2.0rdis)); //å°åœ†çš„é‚£ä¸ªè§’ double s=Rangle1R+rangle2r; s-=Rdissin(angle1); return s; } å…¨æ’åˆ— ä¸€å®šè¦æ’åº #includeusing namespace std;typedef long long ll;const int maxn=4e5+5;int n[maxn];int dp[maxn][9];int main() {int ans[9]= {0,1,2,3,4,5,6,7,8};int k=0;do {for(int i=0; i&lt;9; i++) {dp[k][i]=ans[i];}k++;} while(next_permutation(ans,ans+9));return 0;} hypot() æ±‚ä¸‰è§’æ–œè¾¹]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018æ­ç”µå¤šæ ¡ç¬¬ä¸€åœº-2018 Multi-University Training Contest 1]]></title>
    <url>%2F2018%2F07%2F23%2F2018%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%80%E5%9C%BA-2018%20Multi-University%20Training%20Contest%201%2F</url>
    <content type="text"><![CDATA[å› ä¸ºå»äº†èººä¸Šæµ·ï¼Œå¯¼è‡´ä¸¤åœºç‰›å®¢å¤šæ ¡æ²¡æœ‰æ‰“ã€‚è¿™åœºæ­ç”µå¤šæ ¡åœ¨åŠªåŠ›ä¹Ÿåªèƒ½å†™5é¢˜ï¼Œæœ‰äº†å¤§ä½¬è®²é¢˜è§£æˆ‘å°±è¿‡ä¸€ä¸‹ã€‚ Maximum Multiple Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 0 Accepted Submission(s): 0 Problem Description Given an integer n, Chiaki would like to find three positive integers x, y and z such that: n=x+y+z, xâˆ£n, yâˆ£n, zâˆ£n and xyz is maximum. Input There are multiple test cases. The first line of input contains an integer T (1â‰¤Tâ‰¤106), indicating the number of test cases. For each test case: The first line contains an integer n (1â‰¤nâ‰¤106). Output For each test case, output an integer denoting the maximum xyz. If there no such integers, output âˆ’1 instead. Sample Input 1 3 1 2 3 Sample Output 1 -1 -1 1 n/s+n/t+n/k=n; æ±‚å¾— s=3 t=3 k=3 /s=2 t=1 k=1;è¿™ä¸¤ç§æƒ…å†µæœ€å°ï¼Œç„¶åæš´åŠ›å°±è¡Œäº† æˆ‘çš„å†™æ³•æ˜¯æ‰“äº†ä¸ªè¡¨ï¼Œæ•°æ®èŒƒå›´ä¸å¤§ã€‚ 100112345678910111213141516171819202122232425262728293031323334353637383940 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxn=1e6+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int t,n;long long a[maxn];int main() &#123; memset(a,-1,sizeof(a)); for(long long i=1;i*4&lt;=maxn;i++)&#123; a[i*4]=i*i*i*2; &#125; for(long long i=1;i*3&lt;=maxn;i++)&#123; a[i*3]=i*i*i; &#125; cin&gt;&gt;t; while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); printf(&quot;%lld\n&quot;,a[n]); &#125; return 0;&#125; 1002Balanced Sequence Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 0 Accepted Submission(s): 0 Problem Description Chiaki has n strings s1,s2,â€¦,sn consisting of â€˜(â€˜ and â€˜)â€™. A string of this type is said to be balanced: if it is the empty string if A and B are balanced, AB is balanced, if A is balanced, (A) is balanced. Chiaki can reorder the strings and then concatenate them get a new string t. Let f(t) be the length of the longest balanced subsequence (not necessary continuous) of t. Chiaki would like to know the maximum value of f(t) for all possible t. Input There are multiple test cases. The first line of input contains an integer T, indicating the number of test cases. For each test case: The first line contains an integer n (1â‰¤nâ‰¤105) â€” the number of strings. Each of the next n lines contains a string si (1â‰¤|si|â‰¤105) consisting of (&#39; and)â€™. It is guaranteed that the sum of all |si| does not exceeds 5Ã—106. Output For each test case, output an integer denoting the answer. Sample Input 1 2 1 )()(()( 2 ) )( Sample Output 1 4 2 å…ˆå¤„ç†å­—ç¬¦ä¸² æŠŠä»–ç®€åŒ–æœ€åæ‰€æœ‰å­—ç¬¦ä¸²éƒ½ä¼šå˜æˆ )))((( åƒè¿™æ ·çš„å½¢å¼ã€‚ ç„¶åè´ªå¿ƒä¸€ä¸‹æ¯æ¬¡é€‰å·¦è¾¹æœ€é•¿æˆ–è€…å³è¾¹æœ€é•¿ï¼Œéƒ½æ²¡æœ‰å½±å“ï¼Œåæ­£æ˜¯å¾€ä¸¤è¾¹æ·»åŠ ï¼Œåªè¦ä¿è¯é€‰çš„è¿™ä¸ªæ˜¯ä¸€ç§çš„æœ€å¤§çš„å°±è¡Œã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const int maxn=1e5+25;int t,n;stack&lt;char&gt; s;char ch[maxn];int dp1[maxn],dp2[maxn],ans;struct three &#123; int d1,d2,n;&#125; d[maxn];bool cmp(three &amp;a,three &amp;b)&#123; if(a.d1==b.d1)&#123; return a.d2&gt;b.d2; &#125; return a.d1&gt;b.d1;&#125;int main() &#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; ans=0; scanf(&quot;%d&quot;,&amp;n); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%s&quot;,ch); int pos=0; while(ch[pos]!=&apos;\0&apos;) &#123; if(ch[pos]==&apos;)&apos;) &#123; if(s.size()==0||s.top()==&apos;)&apos;) &#123; s.push(&apos;)&apos;); &#125; else &#123; ans+=2; s.pop(); &#125; &#125; else if(ch[pos]==&apos;(&apos;) &#123; s.push(&apos;(&apos;); &#125; pos++; &#125; int a1=0,a2=0; if(s.size()==0) &#123; i--; n--; &#125; else &#123; while(s.size()&gt;0) &#123; if(s.top()==&apos;)&apos;)a2++; else a1++; s.pop(); &#125; d[i].d1=a1; d[i].d2=a2; d[i].n=i; &#125; &#125; sort(d,d+n,cmp); int k1=d[0].d1,k2=d[0].d2; for(int i=1; i&lt;n; i++) &#123; int k=max(min(k1,d[i].d2),min(k2,d[i].d1)); ans+=2*k; k1=k1-k+d[i].d1; k2=k2-k+d[i].d2; &#125; printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125; 1003Triangle Partition Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 132768/132768 K (Java/Others) Total Submission(s): 0 Accepted Submission(s): 0Special Judge Problem Description Chiaki has 3n points p1,p2,â€¦,p3n. It is guaranteed that no three points are collinear. Chiaki would like to construct n disjoint triangles where each vertex comes from the 3n points. Input There are multiple test cases. The first line of input contains an integer T, indicating the number of test cases. For each test case: The first line contains an integer n (1â‰¤nâ‰¤1000) â€” the number of triangle to construct. Each of the next 3n lines contains two integers xi and yi (âˆ’109â‰¤xi,yiâ‰¤109). It is guaranteed that the sum of all n does not exceed 10000. Output For each test case, output n lines contain three integers ai,bi,ci (1â‰¤ai,bi,ciâ‰¤3n) each denoting the indices of points the i-th triangle use. If there are multiple solutions, you can output any of them. Sample Input 1 1 1 1 2 2 3 3 5 Sample Output 11 2 3 æ²¡å•¥å¥½è®²çš„ï¼Œæ’ä¸ªåºä»å·¦åˆ°å³åæ­£ä¸ä¼šäº¤å‰ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344 #include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;typedef pair&lt;char, int &gt; PCI;typedef pair&lt;int, int&gt; PII;typedef pair&lt;LL, LL&gt; PLL;const int MAX = 1e4+7;const int INF = 0x3f3f3f3f;const int mod=1e9+7;int N, M, K, T;struct node &#123; int x, y, id; bool operator&lt;(const node&amp; b) const &#123; return x &lt; b.x; &#125;&#125;;node a[MAX];vector&lt;int&gt; v[MAX];int main() &#123; scanf(&quot;%d&quot;,&amp;T); while(T--) &#123; scanf(&quot;%d&quot;,&amp;N); for(int i = 1; i &lt;= 3*N; i++) &#123; scanf(&quot;%d %d&quot;, &amp;a[i].x, &amp;a[i].y); a[i].id = i; &#125; sort(a+1, a+N*3+1); for(int i = 1; i &lt;= 3*N; i+=3) &#123; printf(&quot;%d %d %d\n&quot;,a[i].id, a[i+1].id, a[i+2].id); &#125; &#125; return 0;&#125; 1004 hiaki has an array of n positive integers. You are told some facts about the array: for every two elements ai and aj in the subarray al..r (lâ‰¤i&lt;jâ‰¤r), aiâ‰ ajholds. Chiaki would like to find a lexicographically minimal array which meets the facts. Input There are multiple test cases. The first line of input contains an integer T, indicating the number of test cases. For each test case: The first line contains two integers n and m (1â‰¤n,mâ‰¤105) â€” the length of the array and the number of facts. Each of the next m lines contains two integers li and ri (1â‰¤liâ‰¤riâ‰¤n). It is guaranteed that neither the sum of all n nor the sum of all m exceeds 106. Output For each test case, output n integers denoting the lexicographically minimal array. Integers should be separated by a single space, and no extra spaces are allowed at the end of lines. Sample Input 1 3 2 1 1 2 4 2 1 2 3 4 5 2 1 3 2 4 Sample Output 1 1 2 1 2 1 2 1 2 3 1 1 é˜Ÿå‹å†™çš„ï¼Œçœ‹äº†ä¸€ä¸‹ï¼Œè´ªå¿ƒï¼Œæ¯æ¬¡æ”¾æœ€å°çš„å°±è¡Œã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 #include &lt;bits/stdc++.h&gt;#define fi first#define se second#define lson l,m,rt&lt;&lt;1#define rson m+1,r,rt&lt;&lt;1|1#define lowbit(x) x&amp;-x#define MP make_pair#define debug(x) cout&lt;&lt;x&lt;&lt;&quot;= &quot;&lt;&lt;x&lt;&lt;endl;#define FIN freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt;pii;typedef pair&lt;ll,ll&gt;pll;const int mod=1e9+7;const int inf=0x3f3f3f3f;const ll infll=0x3f3f3f3f3f3f3f3f;const int MX=1e5+7;int n,m;struct node &#123; int l,r; bool operator&lt;(const node&amp;A)const &#123; if(l==A.l) return r&lt;A.r; return l&lt;A.l; &#125;&#125; a[MX];int ans[MX];bool vis[MX];int main() &#123; int T; cin&gt;&gt;T; while(T--) &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=m; i++) &#123; scanf(&quot;%d%d&quot;,&amp;a[i].l,&amp;a[i].r); &#125; sort(a+1,a+m+1); priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q; for(int i=1; i&lt;=n; i++)&#123; ans[i]=1;vis[i]=0; q.push(i); &#125; int l=a[1].l,r=a[1].l; for(int i=1;i&lt;=m;i++)&#123; for(;l&lt;a[i].l;l++)&#123; if(vis[l]) q.push(ans[l]); &#125; for(;r&lt;=a[i].r;r++)&#123; if(r&gt;=a[i].l)&#123; ans[r]=q.top();q.pop(); vis[r]=1; &#125; &#125; &#125; for(int i=1; i&lt;=n; i++) &#123; printf(&quot;%d&quot;,ans[i]); if(i==n) printf(&quot;\n&quot;); else printf(&quot; &quot;); &#125; &#125; return 0;&#125; 1007Chiaki Sequence Revisited Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 428 Accepted Submission(s): 69 Problem Description Chiaki is interested in an infinite sequence a1,a2,a3,â€¦, which is defined as follows: an={1anâˆ’anâˆ’1+anâˆ’1âˆ’anâˆ’2n=1,2nâ‰¥3 Chiaki would like to know the sum of the first n terms of the sequence, i.e. âˆ‘i=1nai. As this number may be very large, Chiaki is only interested in its remainder modulo (109+7). Input There are multiple test cases. The first line of input contains an integer T (1â‰¤Tâ‰¤105), indicating the number of test cases. For each test case: The first line contains an integer n (1â‰¤nâ‰¤1018). Output For each test case, output an integer denoting the answer. Sample Input 1 10 1 2 3 4 5 6 7 8 9 10 Sample Output 1 1 2 4 6 9 13 17 21 26 32 æ‰“ä¸ªè¡¨æ‰¾è§„å¾‹ï¼Œ 1 2 3 4 5 6 7 8 9 10 2 2 1 3 1 2 1 4 1 2 å„ä¸ªæ•°å‡ºç°çš„æ¬¡æ•°å°±æ˜¯è¿™æ ·ï¼Œç„¶åå°±æ˜¯lowbitï¼ˆiï¼‰æ¬¡ï¼Œç„¶åäºŒåˆ†æ‰¾ åˆ°å“ªä¸ªæ•°å‡ºç°çš„æ•°æ¬¡æ•°æ€»å’Œä¸ºn ç„¶åå†çœ‹ä¸€ä¸‹ æ¯æ¬¡æ‰¾çš„çš„æ•°ï¼Œx,ä½ ä¼šå‘ç°ï¼Œxæ€»æ˜¯åœ¨n/2é™„è¿‘ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include &lt;complex&gt;#include &lt;functional&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxn=1e7+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;long long m,n;long long sum(ll x) &#123; ll ans=1,k=1; while(x&gt;0) &#123;// cout&lt;&lt;x&lt;&lt;endl; if(x%2==1)ans+=x/2*k+1*k; else &#123; ans+=x/2*k; &#125; k++; x/=2; &#125; return ans;&#125;long long js(ll x) &#123; ll res=0,k=1,ans,p=1; while(x&gt;0) &#123; if(x%2==1) &#123; ans=x/2+1; &#125; else &#123; ans=x/2; &#125; ans%=mod; res+=ans*ans%mod*p%mod*k%mod; res%=mod; k++; p=p*2%mod; x/=2; &#125; return res%mod;&#125;int main() &#123; int t; cin&gt;&gt;t; while(t--) &#123; scanf(&quot;%lld&quot;,&amp;n); ll l=0,r=n; if(n&gt;200)&#123; l=n/2-100; r=n/2+100; &#125; while(l&lt;r-1) &#123; ll mid=(l+r)/2; if(sum(mid)&gt;n) &#123; r=mid; &#125; else l=mid; &#125;// cout&lt;&lt;l&lt;&lt;endl; printf(&quot;%lld\n&quot;,(js(l)+(n-sum(l))*(l+1)%mod+1)%mod); &#125; return 0;&#125; 1011Time Zone Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 1646 Accepted Submission(s): 289 Problem Description Chiaki often participates in international competitive programming contests. The time zone becomes a big problem. Given a time in Beijing time (UTC +8), Chiaki would like to know the time in another time zone s. Input There are multiple test cases. The first line of input contains an integer T (1â‰¤Tâ‰¤106), indicating the number of test cases. For each test case: The first line contains two integers a, b (0â‰¤aâ‰¤23,0â‰¤bâ‰¤59) and a string s in the format of â€œUTC+Xâ€™â€™, â€œUTC-Xâ€™â€™, â€œUTC+X.Yâ€™â€™, or â€œUTC-X.Yâ€™â€™ (0â‰¤X,X.Yâ‰¤14,0â‰¤Yâ‰¤9). Output For each test, output the time in the format of hh:mm (24-hour clock). Sample Input 1 3 11 11 UTC+8 11 12 UTC+9 11 23 UTC+0 Sample Output 1 11:11 12:12 03:23 æ³¨æ„ç²¾åº¦ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxn=1e7+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int t;int main() &#123; cin&gt;&gt;t; int h,m; double ut; while(t--) &#123; scanf(&quot;%d%d UTC%lf&quot;,&amp;h,&amp;m,&amp;ut); int u=ut*100; int k=abs(u); if(k%10&gt;5)k=k/10+1; else k=k/10; if(u&gt;0)u=k; else u=-k;// cout&lt;&lt;u&lt;&lt;endl; m+=u%10*6; if(m&lt;0) &#123; m+=60; h--; &#125; h+=m/60; m=m%60;// cout&lt;&lt;h&lt;&lt;endl; m=m%60; u=u/10-8; h+=u; if(h&lt;0)h+=24; h=h%24; printf(&quot;%02d:%02d\n&quot;,h,m); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 496 (Div. 3) E2 - Median on Segments (General Case Edition)ï¼ˆæ€ç»´+ç”¨bit ä½æ±‚å‰ç¼€åˆï¼‰]]></title>
    <url>%2F2018%2F07%2F16%2FCodeforces%20Round%20496%20(Div.%203)%20E2%20-%20Median%20on%20Segments%20(General%20Case%20Edition)%EF%BC%88%E6%80%9D%E7%BB%B4%2B%E7%94%A8bit%20%E4%BD%8D%E6%B1%82%E5%89%8D%E7%BC%80%E5%90%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[è¿™é¢˜çœ‹äº†åˆ«äººçš„åšå®¢ï¼Œçœ‹çš„æˆ‘ä¸€è„¸æ‡µé€¼ã€‚ æ€è·¯ï¼šå¾ˆå·§ç§’çš„è½¬æ¢ï¼Œæˆ‘ä»¬æŠŠ&lt;= m æ•°è®°ä¸º-1, &gt;mçš„æ•° è®°ä¸º1ï¼Œ æ±‚å…¶å‰ç¼€å’Œ, æˆ‘ä»¬å°†é—®é¢˜è½¬å˜æˆæ±‚ä»¥&gt; m çš„æ•°ä½œä¸ºä¸­ä½æ•°çš„åŒºé—´ä¸ªæ•°ï¼Œ ç­”æ¡ˆå°±å˜ä¸ºans(m-1) - ans(m )ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸Šé¢æ±‚å¾—çš„å‰ç¼€ç”¨bitå°±èƒ½æ±‚å‡ºç­”æ¡ˆã€‚ æˆ‘ç‰¹ä¹ˆè¿˜ä¸çŸ¥é“æ˜¯è¿™æ ·å†™çš„ä¹ˆï¼Œæˆ‘æ˜¯ä¸çŸ¥é“æ€ä¹ˆç”¨å‰ç¼€ã€‚ç„¶åçº ç»“äº†åŠå¤©ï¼Œæ˜¯å’±çš„åŸºç¡€ä¸å¥½ã€‚ æ‰€ä»¥é‡ç‚¹æ˜¯æ€ä¹ˆç”¨bitä½æ¥å¤„ç†å‰ç¼€å’Œå‘¢ï¼Ÿ åªå¯æ„ä¼šä¸å¯è¨€ä¼  12 5 41 4 5 60 4 é¦–å…ˆä¼ ä¸ª å½“ k =4 æ—¶ å°±æ˜¯ -1 -2 -1 0 -1 é¦–å…ˆ çŸ¥é“ å‰ç¼€å’Œä¸ºè´Ÿæ•°çš„ä¸­å«è‚¯å®šæ˜¯&lt;=4ä¸ºæ­£æ•°çš„ä¸€å®šæ˜¯&gt;4 ç»“ç‚¹å›¾å¦‚ä¸‹ï¼Œè‡³äº8ä»¥ä¸Šçš„ç»“ç‚¹å°±ä¸ç”»äº†ï¼Œç”»äº†ä¹Ÿæ²¡ç”¨å‰ç¼€åˆæœ€å¤§å€¼ä¸ä¼šè¶…è¿‡8ï¼› é¦–å…ˆ 0 +n+1=5 ï¼ˆåˆå§‹å€¼éƒ½ä¸º-1ï¼‰ å’Œè¿™ä¸ªä»¥åçš„ç»“ç‚¹å€¼ ++ï¼› ä¹Ÿå°±æ˜¯ 6 8ç»“ç‚¹ éƒ½åŠ 1ï¼› ä¸‹ä¸€ä¸ªå€¼ -1 æŠŠæ‰€æœ‰ -1+n=4 ä¸€ä¸‹çš„ç»“ç‚¹ çš„å€¼éƒ½åŠ èµ·æ¥ã€‚ ç„¶å æŠŠ å°äº -1+n çš„ç»“ç‚¹å’Œéƒ½åŠ ä¸€ï¼Œä¹Ÿå°±æ˜¯ 4 8éƒ½åŠ 1ï¼› åé¢çš„éƒ½æ˜¯åŒæ ·çš„é“ç† 1234567891011121314151617181920212223242526272829303132333435363738394041424344 #include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+5;const int N=2*maxn;int n,m,a[maxn];int v[N];void jl(int x) &#123; for(int i=x; i&lt;N; i+=i&amp;-i) &#123; //è¿™ä¸ªæ˜¯æ¥ä¿ç•™çš„å‰ç¼€å’Œï¼Œå‡å¦‚ å½“å‰ä½ç½®çš„å‰ç¼€åˆ æ˜¯ -1 ï¼Œå› ä¸ºå¯èƒ½å‡ºç°è´Ÿæ•°çš„æƒ…å†µæ‰€ä»¥åŠ ä¸Š n // ç„¶åæ¯” -1 + n å‘ä¸Šè·³è½¬çš„ç»“ç‚¹ éƒ½åŠ ä¸Š1 v[i]++; &#125;&#125;long long s(int x) &#123; long long sum=0; for(int i=x; i&gt;0; i-=i&amp;-i) &#123; sum+=v[i]; // è®¡ç®—å‰ç¼€å’Œï¼Œä»ä¸Šå¾€ä¸‹åŠ ï¼Œè¿™æ ·ä¼šæŠŠå°äºå½“å‰ç»“ç‚¹çš„å€¼éƒ½åŠ èµ·æ¥ã€‚ &#125; return sum;&#125;long long cal(int k)&#123; memset(v,0,sizeof(v)); jl(n+1); int dp=0; long long sum=0; for(int i=0;i&lt;n;i++)&#123; if(a[i]&lt;=k)dp-=1; else dp+=1; sum+=s(dp+n); jl(dp+n+1); &#125; return sum;&#125;int main() &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0; i&lt;n; i++)scanf(&quot;%d&quot;,&amp;a[i]); cout&lt;&lt;cal(m-1)-cal(m)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 45 (Rated for Div. 2)]]></title>
    <url>%2F2018%2F06%2F10%2FEducational%20Codeforces%20Round%2045%20(Rated%20for%20Div.%202)%2F</url>
    <content type="text"><![CDATA[A ,B ä¸¤é¢˜å°±ç›´æ¥ç»™ä»£ç äº†ï¼Œæ²¡å•¥è®²çš„ A: 123456789101112131415161718 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;using LL = long long;ll n,m,a,b;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;a&gt;&gt;b; ll k=n/m; if(n%m==0) &#123; cout&lt;&lt;0&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;min((n-k*m)*b,((k+1)*m-n)*a)&lt;&lt;endl; &#125; return 0;&#125; B: 1234567891011121314151617181920212223 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;using LL = long long;const int maxn=2e5+25;int n,a[maxn],k;int main() &#123; cin&gt;&gt;n&gt;&gt;k; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; sort(a, a+n); int mx=1e7+25,ans=0;; for(int i=n-2;i&gt;=0;i--) &#123; int *temp=upper_bound(a,a+n,a[i]); if(temp==a+n)ans++; else if(a[i]+k&lt;*temp||a[i]==*temp)ans++; &#125; cout&lt;&lt;ans+1&lt;&lt;endl;; return 0;&#125; http://codeforces.com/contest/990/problem/C æ‹¬å·åŒ¹é…ã€‚æ¯ä¸ªå­—ç¬¦ä¸²ä¿ç•™å‰ç¼€å’Œ ä¾‹å¦‚ ((() å‰ç¼€å’Œ 2 ())) å‰ç¼€å’Œ -2ï¼› æ¯æ¬¡åªè¦æŠŠä¸¤ä¸ªæ•°å‰ç¼€å’ŒåŠ èµ·æ¥ç­‰äº0çš„æ•°é‡æƒ³æˆå°±æ˜¯å¯ä»¥åŒ¹é…çš„æ•°é‡ã€‚ ä¿ç•™è´Ÿæ•°å‰ç¼€å’Œçš„æ—¶å€™ä¸€å®šè¦æ˜¯è¿™ä¸ªå‰ç¼€å’Œçš„æ—¶å€™ä¸€å®šæ˜¯æœ€å°çš„é‚£ä¸ªï¼Œä¸ç„¶æœ¬èº«å°±æ˜¯é”™çš„ã€‚ ä¾‹å¦‚ )))(( ())( 123456789101112131415161718192021222324252627282930 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;using LL = long long;const int maxn=3e5+25;ll n,mx=0;char ch[maxn];map&lt;ll,ll&gt; mp;int main() &#123; cin&gt;&gt;n; for(ll j=0; j&lt;n; j++) &#123; scanf(&quot;%s&quot;,ch); ll flag=0,k=0,l=strlen(ch); for(ll i=0; i&lt;l; i++) &#123; if(ch[i]==&apos;(&apos;)k++; else k--; if(k&lt;0)flag=min(k,flag); &#125; if(flag&lt;0&amp;&amp;k&gt;flag)continue; else &#123; mp[k]++; mx=max(k,mx); &#125; &#125; ll sum=0; for(int i=0; i&lt;=mx; i++) sum+=mp[i]*mp[-i]; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125; D:http://codeforces.com/contest/990/problem/D é¢˜ç›®æ„æ€æ˜¯ï¼Œç»™ä½ Nä¸ªé¡¶ç‚¹ï¼Œç„¶åæ€ä¹ˆè¿è®©ä»–å¯ä»¥æœ‰ï¼Œa,ä¸ªè”é€šå¿«ï¼Œç„¶åè¿çš„çš„çŸ©é˜µçš„åçŸ©é˜µ åˆšå¥½æœ‰bä¸ªè”é€šå¿«ã€‚ ä¾‹å¦‚ 3 1 2 çŸ©é˜µ æ˜¯ 001 001 110 ä»–å°±æ˜¯ è¿™ä¸ªæ ·å­ åçŸ©é˜µå°±æ˜¯ 010 100 000 å›¾å°±æ˜¯ è¿™ä¸ªæ ·å­æ‰€ä»¥æ»¡è¶³æ¡ä»¶ã€‚ çœ‹èµ·æ¥æŒºéš¾çš„ï¼Œå®é™…ä¸Šå°±æ˜¯ä¸ªå‚»é€¼é¢˜ï¼Œå°±æ˜¯æ²¡è¿çš„è¾¹ä¸€å®šå¯ä»¥è¿ä¸Šï¼Œæ‰€ä»¥æ— è®ºä½ ä¸€ç§è¿æˆå•¥æ ·å¦ä¸€ç§å¿…ç„¶æ˜¯å…¨éƒ¨è”é€š æ‰€ä»¥ï¼Œa,bå¿…é¡»æœ‰ä¸€ä¸ªæ˜¯ 1 ï¼Œå¦‚æœæ²¡æœ‰å°±ä¸å¯è¡Œï¼Œç„¶åç‰¹åˆ¤ä¸€ä¸‹ 2 3 ä¸¤ä¸ª éƒ½æ˜¯ 1çš„æƒ…å†µï¼Œä¸ºä»€ä¹ˆè¦ç‰¹åˆ¤å‘¢ï¼Œè‡ªå·±ç”»ä¸ªå›¾è¯•è¯•å°±çŸ¥é“äº†ã€‚ ç„¶åå°±ç®€å•äº†ï¼ŒçŸ©é˜µå…¶å®åªè¦å§ ä¸æ˜¯ 1 çš„çš„é‚£ä¸ªè”é€šå¿«æ•°é‡åˆ†æˆ 1 1 1 1 n-a è¿™æ ·çš„å‡ ä¸ªè”é€šå—å°±è¡Œäº†ã€‚ æ‰€ä»¥åªè¦è¿ n-aæ¡è¾¹ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738 #include &lt;bits/stdc++.h&gt;using namespace std;const int Maxn = 1005;int n, a, b;char B[Maxn][Maxn];int main() &#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;a, &amp;b); if(a!=1&amp;&amp;b!=1)printf(&quot;NO\n&quot;); else if((n==2||n==3)&amp;&amp;a==1&amp;&amp;b==1)printf(&quot;NO\n&quot;); else &#123; char ca=&apos;1&apos;,cb=&apos;0&apos;; if(a&lt;b) &#123; swap(a,b); swap(ca,cb); &#125; int k=n-a; for(int i=0; i&lt;n; i++) &#123; for(int j=0; j&lt;n; j++) &#123; if(i==j)B[i][j]=&apos;0&apos;; else B[i][j]=cb; &#125; &#125; for(int i=0; i&lt;k; i++) &#123; B[i][i+1]=B[i+1][i]=ca; &#125; printf(&quot;YES\n&quot;); for(int i=0; i&lt;n; i++) &#123; for(int j=0; j&lt;n; j++) printf(&quot;%c&quot;,B[i][j]); printf(&quot;\n&quot;); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ä¸­å—å¤šæ ¡èµ›å…«]]></title>
    <url>%2F2018%2F06%2F06%2F%E4%B8%AD%E5%8D%97%E5%A4%9A%E6%A0%A1%E8%B5%9B%E5%85%AB%2F</url>
    <content type="text"><![CDATA[CSU2128 2130 2135 2136 Aé¢˜ CSU2128 2128: Wellsâ€™s Travel PlanSubmit Page Summary Time Limit: 3 Sec Memory Limit: 128 Mb Submitted: 39 Solved: 3 DescriptionWellsæ¥åˆ°äº†ä¸€ä¸ªæœªçŸ¥çš„æ¢¦å¹»å›½åº¦ï¼Œè¿™ä¸ªå›½åº¦æœ‰ 2N ä¸ªåŸå¸‚ï¼Œåˆ†å¸ƒä¸ºä¸€ä¸ª 2*N çš„çŸ©é˜µã€‚æœ‰äº›åŸå¸‚æ˜¯æ— æ³•åˆ°è¾¾çš„ã€‚ä¸€ä¸ªåŸå¸‚å¯ä»¥åˆ°è¾¾ä¸ä¹‹æ›¼å“ˆé¡¿è·ç¦»ä¸º 1 çš„åŸå¸‚ã€‚ å¤§å®¶éƒ½çŸ¥é“æ‰“acmæ²¡æœ‰å¤ªå¤šçš„è‡ªç”±æ—¶é—´å‡ºå»ç©ï¼Œä½†Wellsä»ç„¶æƒ³çŸ¥é“ï¼Œå¦‚æœåœ¨ä»ç¬¬ l ä¸ªåŸå¸‚å‡ºå‘åˆ°ç¬¬ r ä¸ªåŸå¸‚çš„æœ€å°‘éœ€è¦ç»è¿‡å¤šå°‘åŸå¸‚ã€‚ åŸå¸‚çš„åˆ†å¸ƒå¦‚ä¸‹å›¾: 1, 2, 3, â€¦.N N+1,N+2,N+3â€¦.N*2 Inputç¬¬ä¸€è¡Œä¸¤ä¸ªæ­£æ•´æ•° nï¼Œmï¼Œm ä¸ºè¯¢é—®æ•° æ¥ä¸‹æ¥ä¸¤è¡Œï¼Œæ¯è¡Œæ˜¯ä¸€ä¸ªé•¿åº¦ä¸º N çš„å­—ç¬¦ä¸²ï¼Œè¡¨ç¤ºåŸå¸‚èƒ½å¦ç»è¿‡ã€‚ è‹¥ä¸º Xï¼Œè¡¨ç¤ºä¸èƒ½ç»è¿‡ï¼Œè‹¥ä¸º Pï¼Œè¡¨ç¤ºå¯ä»¥ç»è¿‡ã€‚ æ¥ä¸‹æ¥ m è¡Œï¼Œæ¯è¡Œä¸¤ä¸ªæ•´æ•° l,rï¼Œæè¿°ä¸€ä¸ªè¯¢é—®ã€‚ Outputå¯¹äºæ¯ä¸ªè¯¢é—®è¾“å‡ºä¸€è¡Œï¼Œl åˆ° r çš„éœ€è¦ç»è¿‡çš„æœ€å°‘åŸå¸‚ä¸ªæ•°(ä¸åŒ…æ‹¬èµ·ç‚¹ï¼Œä½†åŒ…æ‹¬ç»ˆç‚¹)ï¼Œè‹¥æ— æ³•åˆ°è¾¾è¾“å‡º-1ã€‚ Sample Input13 4 XPX PPP 1 4 4 2 6 5 6 4 Sample Output1-1 2 1 2 Hintå¯¹äºæ‰€æœ‰æ•°æ®,_n_, _m_ &lt; =2 * 105. Aé¢˜ æœ¬æ¥åº”è¯¥æ˜¯ç”¨å€å¢ï¼Œä½†æ˜¯æš´åŠ›è¿˜æ˜¯èƒ½å¡æé™è¿‡ã€‚ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define pi acos(-1.0)#define e 2.718#define lowbit(x) (x&amp;(-x))using namespace std;typedef unsigned long long ull;typedef long long ll;const int N=4e5+9;const long long mod=1e9+7;const int maxn=2e5+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,m;int mp[3][maxn];char ch[maxn];set&lt;int&gt; s[3];int main() &#123; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)&amp;&amp;n&amp;&amp;m) &#123; scanf(&quot;%s&quot;,ch); s[0].clear(); s[1].clear(); for(int i=0; i&lt;n; i++) &#123; if(ch[i]==&apos;X&apos;) &#123; s[0].insert(i); mp[0][i]=-1; &#125; else mp[0][i]=0; &#125; scanf(&quot;%s&quot;,ch); for(int i=0; i&lt;n; i++) &#123; if(ch[i]==&apos;X&apos;) &#123; s[1].insert(i); mp[1][i]=-1; &#125; else mp[1][i]=0; &#125; for(int i=0; i&lt;m; i++) &#123; int a,b; int p=0,sum=0; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); a--; b--; if(a%n&gt;b%n)swap(a,b); int ka=a/n,va=a%n,kb=b/n,vb=b%n; if(mp[ka][va]==-1||mp[kb][vb]==-1)sum=-1; else &#123; set&lt;int&gt;::iterator ite; ite=s[ka].upper_bound(va); if(ite!=s[ka].end())p=*ite; else p=INF; while(p&lt;=vb) &#123; sum+=p-va; ka=!ka; va=p-1; if(mp[ka][va]==-1) &#123; sum=-1; break; &#125; ite=s[ka].lower_bound(p); if(ite!=s[ka].end())p=*ite; else p=INF; if(p-1==va) &#123; sum=-1; break; &#125; &#125; if(sum!=-1) &#123; sum+=vb-va; if(kb!=ka)sum+=1; &#125; &#125; printf(&quot;%d\n&quot;,sum); &#125; &#125; return 0;&#125; C é¢˜ CSU 2130 C(2130):Permutations Submit Page Summary Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 57 Solved: 20 Description ç»™å®šä¸¤ä¸ª1~nçš„æ’åˆ—A, Bã€‚æ¯æ¬¡å¯ä»¥æŠŠAçš„æœ€åä¸€ä¸ªæ•°å–å‡ºï¼Œæ’å…¥åˆ°Açš„ä»»ä½•ä¸€ä¸ªä½ç½®ï¼ˆæœ€å‰é¢æˆ–è€…ä»»ä½•ä¸¤ä¸ªæ•°ä¸­é—´ï¼‰ã€‚é—®æœ€å°‘å‡ æ¬¡å¯ä»¥æŠŠAè½¬åŒ–ä¸ºBã€‚ Input ç¬¬ä¸€è¡Œä¸ºä¸€ä¸ªæ•´æ•°nã€‚ç¬¬äºŒè¡Œä¸º1~nçš„ä¸€ä¸ªæ’åˆ—ï¼Œè¡¨ç¤ºAã€‚ç¬¬ä¸‰è¡Œä¸º1~nçš„ä¸€ä¸ªæ’åˆ—ï¼Œè¡¨ç¤ºBã€‚ Output ä¸€ä¸ªæ•´æ•°å³æœ€å°‘æ“ä½œæ¬¡æ•°ã€‚ Sample Input 5 1 5 2 3 4 1 2 3 4 5 Sample Output 3 Hint 30%ï¼šn &lt;=100 50%ï¼šn &lt;=1000 100%: n &lt;= 200000 æœ€å‰é¢é¡ºåºæ­£ç¡®çš„å°±æ˜¯ä¸ç”¨å˜æ¢çš„ï¼Œæ‰€ä»¥ç›´æ¥å‡å»å°±è¡Œäº†ã€‚ã€‚ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define pi acos(-1.0)#define e 2.718#define lowbit(x) (x&amp;(-x))using namespace std;typedef unsigned long long ull;typedef long long ll;const int N=4e5+9;const long long mod=1e9+7;const int maxn=1e7+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;int a[maxn],b[maxn];map&lt;int,int &gt; m;int main() &#123; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; for(int i=0; i&lt;n; i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d&quot;,&amp;b[i]); m[b[i]]=i; &#125; int k=m[a[0]],ans=1; for(int i=1; i&lt;n; i++) &#123; if(m[a[i]]&gt;k) &#123; ans++; k=m[a[i]]; &#125; else break; &#125; cout&lt;&lt;n-ans&lt;&lt;endl; &#125; return 0;&#125; H é¢˜ H(2135):Appositive BodySubmitPage Summary Time Limit: 10 Sec Memory Limit: 512 Mb Submitted: 29 Solved: 7 DescriptionYuki Nagato is an aliencreated by the Data Overmind, and possesses supernatural powers as a result.Two of her abilities are to observe the universe and to transcend time and space. As we know, it is unstable ofthe universe if there are more than one active bodies which are actually thesame individual at the same time. Nagato defines them as _appositivebodies_. Of course, Nagato can tell whether there are any appositivebodies of one as soon as she observes. Now, you become able totravel through time and space by some special chance. But before taking action,you have to make sure you wonâ€™t destabilize the universe, so you can ask Nagatofor some help, including whether there is an appositive body of you at yourdestination. However, it is inconvenient to make a request every time, so youdecide to study this method. At this time, you are able todescribe the universe abstractly, with several points in a 4-dimension vector,which are the space rectangular coordinates _x_, _y_ and _z_,and the time _t_. After filtered, these points seem to bein alignment. What you need to do now is to check whether these points arecentrosymmetric in four dimensional space. If they are, it means there is yourappositive body at your destination. InputInput consists of severaltest cases, for each test case: First line: a integer _n_ (1 â‰¤ _n_ â‰¤ 107), the count ofpoints. Next _n_ lines:each line has four integers _x_, _y_, _z_, _t_ (âˆ’108 â‰¤ _x_, _y_, _z_, _t_ â‰¤ 108), the coordinate of apoint. OutputFor each test case, output aline: if these points are centrosymmetric in four dimensional space, outputâ€existâ€. Otherwise, output â€œnot existâ€. Sample Input14 10 0 0 0 1-1 0 3 4 14 8 2 2 15 8 -1 -2 13 10 0 0 0 11 1 1 1 11 1 1 1 14 10 0 0 0 11 1 1 1 11 1 1 1 10 0 0 0 Sample Output1exist 1not exist 1exist æ’ä¸ªåºï¼Œç„¶å åˆ¤æ–­ ç¬¬ I ä¸ª åŠ ä¸Š N-I-1ä¸ªçš„xyzt,æ˜¯ä¸æ˜¯å…¨éƒ¨ç­‰äº2èƒŒå¹³å‡æ•°å°±è¡Œ æš´åŠ›ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define pi acos(-1.0)#define e 2.718#define lowbit(x) (x&amp;(-x))using namespace std;typedef unsigned long long ull;typedef long long ll;const int N=4e5+9;const long long mod=1e9+7;const int maxn=1e7+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;struct four &#123; double x,y,z,t;&#125; f[maxn];bool cmp(const four &amp;a,const four &amp;b) &#123; if(a.t==b.t) &#123; if(a.x==b.x) &#123; if(a.y==b.y) &#123; return a.z&lt;b.z; &#125; else return a.y&lt;b.y; &#125; else return a.x&lt;b.x; &#125; else return a.t&lt;b.t;&#125;long double cl(long double t)&#123; return t*2/n;&#125;int main() &#123; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; long double x,y,z,t; x=y=z=t=0; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%lf%lf%lf%lf&quot;,&amp;f[i].x,&amp;f[i].y,&amp;f[i].z,&amp;f[i].t); x+=f[i].x; y+=f[i].y; z+=f[i].z; t+=f[i].t; &#125; x=cl(x); y=cl(y); z=cl(z); t=cl(t);// cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;t&lt;&lt;endl; int flag=1; sort(f,f+n,cmp); for(int i=0; i&lt;=(n-1)/2; i++) &#123; if(abs(f[i].x+f[n-i-1].x-x)&gt;eps|| abs(f[i].y+f[n-i-1].y-y)&gt;eps|| abs(f[i].z+f[n-i-1].z-z)&gt;eps|| abs(f[i].t+f[n-i-1].t-t)&gt;eps)&#123; flag=0; &#125; &#125; puts(flag?&quot;exist&quot;:&quot;not exist&quot;); &#125; return 0;&#125; Ié¢˜ I(2136):ç»Ÿå¸…ä¸‰å†›! Submit Page Summary Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 7 Solved: 1 Description Wellsæœ€è¿‘è¿·ä¸Šäº†ä¸€æ¬¾æ”»åŸçš„ç­–ç•¥æ¸¸æˆï¼Œç‚¹å°±å»å°±èƒ½å½“å¤§å…ƒå¸…ç»Ÿå¸…ä¸‰å†›ï¼ æ¸¸æˆç•Œé¢ä¸»è¦æ˜¯ä¸€ä¸ªå¹³é¢(åæ ‡å¯ä»¥ä¸ºæµ®ç‚¹æ•°)ï¼Œç„¶è€ŒWellså‘ç°è¿™æ¸¸æˆæ˜¯ä¸ªéª—å±€ï¼Œå…¶å®åªç»™äº†ä¸€ä¸ªå†›é˜Ÿã€‚ Wellsåˆå§‹æœ‰ä¸€ä¸ªå†›é˜Ÿï¼Œä»…åŒ…å«nä¸ªå£«å…µï¼Œæ¯ä¸ªå£«å…µæœ‰ä¸€ä¸ªåˆå§‹ä½ç½®ï¼ˆx,yï¼‰å’Œä¸€ä¸ªåŠ³ç´¯æŒ‡æ•°Wiï¼Œæ¯ä¸ªé˜Ÿå‘˜å¯ä»¥ç§»åŠ¨ï¼Œæ˜¾ç„¶å¯¹äºæ¯ä¸ªé˜Ÿå‘˜çš„ç§»åŠ¨æ˜¯éœ€è¦æ¶ˆè€—ä¸€äº›ä½“åŠ›çš„ï¼Œè‹¥ç¬¬iä¸ªé˜Ÿå‘˜ä»ä½ç½®ï¼ˆx1,y1ï¼‰ç§»åŠ¨åˆ°ï¼ˆx2,y2ï¼‰çš„ä½“åŠ›æ¶ˆè€—ä¸ºWi*(|x2-x1|+|y2-y1|)ã€‚ Wellså¸Œæœ›å…ˆå°†é˜Ÿä¼é›†åˆèµ·æ¥ï¼Œä¸”å¸Œæœ›æ•´ä¸ªé˜Ÿä¼ä¸€æ¬¡é›†åˆçš„ä½“åŠ›æ¶ˆè€—è¶Šå°‘è¶Šå¥½ã€‚æ˜¾ç„¶èƒ½é‡æ¶ˆè€—çš„å¤šå°‘ç›´æ¥å–å†³ä¸Wellså¯¹äºä¼šå’Œç‚¹ï¼ˆx,yï¼‰çš„é€‰æ‹©ï¼Œç„¶è€ŒWellså¤ªæ‡’äº†ï¼Œå¸Œæœ›ä½ å¸®ä»–æ‰¾å‡ºæŸä¸ªæ—¶åˆ»çš„æœ€ä½³ä¼šå’Œç‚¹ã€‚ Input å¯¹äºæ¯ç»„æ•°æ®ï¼š ç¬¬ä¸€è¡Œï¼šä¸€ä¸ªæ•´æ•°Nï¼Œè¡¨ç¤ºå£«å…µæ•°ç›®ã€‚ ç¬¬äºŒè¡Œï¼šä¸€å…±Nä¸ªæ•´æ•°ï¼Œå…¶ä¸­çš„ç¬¬iä¸ªæ•°Wiè¡¨ç¤ºç¬¬iä¸ªé˜Ÿå‘˜çš„åŠ³ç´¯æŒ‡æ•°ã€‚(N&lt;=106)(N&lt;=106) æ¥ä¸‹æ¥Nè¡Œï¼šæ¯ä¸€è¡Œä¸¤ä¸ªæ•´æ•°Xå’ŒYï¼Œè¡¨ç¤ºç¬¬iä¸ªå£«å…µçš„å½“å‰çš„æ¨ªåæ ‡å’Œçºµåæ ‡ã€‚(âˆ’109&lt;=X,Y&lt;=109)(âˆ’109&lt;=X,Y&lt;=109) Output ä¸€ä¸ªå®æ•°ã€‚è¡¨ç¤ºæ‰€æœ‰é˜Ÿå‘˜é›†åˆåˆ°æœ€ä½³æ”»å‡»ä½ç½®çš„ä½“åŠ›æ¶ˆè€—æ€»å’Œï¼Œç­”æ¡ˆä¿ç•™ä¸¤ä½å°æ•°ã€‚ Sample Input 1 1 0 0 Sample Output 0.00 I è¿™é¢˜æ¯”è¾ƒæ¯’ç˜¤ï¼Œå†™äº†åŠå¤©ä¸‰åˆ†å‘ç°ç²¾åº¦æœ‰é—®é¢˜ï¼Œåæ¥ä»”ç»†æƒ³äº†ä¸‹ï¼Œæ ¹æœ¬ä¸å¯èƒ½æ˜¯å°æ•°ï¼Œ ä»–æ±‚çš„æ˜¯æ›¼å“ˆé¡¿è·ç¦»ï¼Œå¯ä»¥æŠŠXï¼ŒYåˆ†å¼€ç®—ã€‚ ä»å·¦å¾€å³èµ°åˆ°æŸä¸ªç‚¹ å·¦è¾¹çš„W &gt; å³è¾¹Wçš„å’Œå°±å¯ä»¥äº†ï¼Œé‚£ä¸ªæ—¶å€™ç»å¯¹å°±æ˜¯ä¸´ç•Œå€¼ å› ä¸ºå†å¾€å·¦èµ°ä¸€å®šæ˜¯å¢çš„æ¯”å‡çš„å°‘ Yè½´ä¹Ÿæ˜¯åŒç† 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define pi acos(-1.0)#define e 2.718#define lowbit(x) (x&amp;(-x))using namespace std;typedef unsigned long long ull;typedef long long ll;const int N=4e5+9;const long long mod=1e9+7;const int maxn=1e7+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;struct P&#123; int x,w,y;&#125;p[maxn];bool cmp(const P &amp; a,const P &amp; b)&#123; return a.x&lt;b.x;&#125;bool cmp2(const P &amp;a,const P &amp; b)&#123; return a.y&lt;b.y;&#125;long long jsx(int l)&#123; long long s1=0,s2=0; for(int i=0;i&lt;n;i++) &#123; s1+=abs(p[i].w*(p[i].x-p[l].x)); &#125; for(int i=0;i&lt;n;i++) &#123; s2+=abs(p[i].w*(p[i].x-p[l-1].x)); &#125; return min(s1,s2);&#125;long long jsy(int l)&#123; long long s1=0,s2=0; for(int i=0;i&lt;n;i++) &#123; s1+=abs(p[i].w*(p[i].y-p[l].y)); &#125; for(int i=0;i&lt;n;i++) &#123; s2+=abs(p[i].w*(p[i].y-p[l-1].y)); &#125; return min(s1,s2);&#125;int main() &#123; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;p[i].w); long long aw=0; for(int i=0;i&lt;n;i++) &#123; scanf(&quot;%d%d&quot;,&amp;p[i].x,&amp;p[i].y); aw+=p[i].w; &#125; sort(p,p+n,cmp); long long l=0,r=aw-p[0].w,sum=0; for(int i=1;i&lt;n;i++) &#123; l+=p[i-1].w; r-=p[i].w; if(r&lt;=l) &#123; sum+=jsx(i); break; &#125; &#125; sort(p,p+n,cmp2); l=0;r=aw-p[0].w; for(int i=1;i&lt;n;i++) &#123; l+=p[i-1].w; r-=p[i].w; if(r&lt;=l) &#123; sum+=jsy(i); break; &#125; &#125; printf(&quot;%lld.00\n&quot;,sum); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æœ€å°ç”Ÿæˆæ ‘Prim&&Kruskal ç®—æ³• è¯¦ç»†ç¬”è®°]]></title>
    <url>%2F2018%2F06%2F06%2F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91Prim%26%26Kruskal%20%E7%AE%97%E6%B3%95%20%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[POJ 1258 Agri-Net http://poj.org/problem?id=1258ï¼› ä¸¤ç§ç®—æ³• Prim Kruskal. å…ˆè¯´Prim åˆå§‹åŒ– æƒå€¼ï¼Œéšä¾¿ä¸€ä¸ªé¡¶ç‚¹åšèµ·ç‚¹ï¼Œä¸º0 å…¶å®ƒçš„ä¸ºæœ€å¤§å€¼ã€‚ æ‰¾åˆ°æƒå€¼æœ€å°çš„é¡¶ç‚¹ï¼Œä¸”æ²¡æœ‰åŠ å…¥é›†åˆã€‚ æŠŠé¡¶ç‚¹æƒå€¼åŠ åˆ°ç»“æœï¼ŒæŠŠå®šç‚¹åŠ å…¥é›†åˆã€‚ æš´åŠ›æšä¸¾ é¡¶ç‚¹è¿æ¥çš„æ‰€æœ‰çš„è¾¹ï¼Œæ›´æ–°æ‰€æœ‰èƒ½å¤Ÿè¿æ¥ä¸Šé¡¶ç‚¹çš„æƒå€¼ã€‚ é‡å¤å‰3æ­¥ï¼Œç›´åˆ°æ‰€æœ‰ç‚¹å…¨éƒ¨åŠ å…¥é›†åˆã€‚ ä»¥ä¸Šå›¾å°±æ˜¯ é¦–å…ˆæ‰¾åˆ°çš„æ˜¯ 0èŠ‚ç‚¹ ä¸€å¼€å§‹æƒå€¼æ˜¯0ï¼Œæ‰€ä»¥res +=0ï¼›ç„¶åæš´åŠ›æ‰€æœ‰èƒ½å¤Ÿè¿æ¥çš„ç‚¹å°±æ˜¯ 1ï¼Œå’Œ2ï¼Œ ç„¶åæ›´æ–° mincost[2]=min(INF,2)ï¼Œç»“æœç­‰äº2ï¼›åŒç† mincost[1]=10; å…¶å®ƒç‚¹çš„æƒå€¼ä¸å˜ã€‚ ç„¶ååˆå¼€å§‹æ‰¾æ‰¾åˆ° 2 é¡¶ç‚¹ï¼Œç„¶åæš´åŠ›æ‰€æœ‰ç‚¹ï¼Œè¿™æ¬¡æ›´æ–°çš„å°±æ˜¯3 4 5é¡¶ç‚¹ã€‚ç„¶åä¸æ–­é‡å¤å°±è¡Œäº† æœ€åè¿æ¥èµ·æ¥çš„æ ‘æ˜¯è¿™ä¸ªæ ·å­çš„ã€‚ ä¸‹é¢æ˜¯ä»£ç  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxv=1e3+25; //æœ€å¤§é¡¶ç‚¹æ•°const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int cost[maxv][maxv]; // cost[u][v] è¡¨ç¤º u åˆ° v çš„æƒå€¼å¦‚æœæ²¡æœ‰è¾¹æƒå€¼ä¸ºæ— ç©·å¤§ï¼ˆINFï¼‰;int mincost[maxv]; //æ¯ä¸ªç‚¹çš„æœ€å°æƒå€¼ï¼Œèµ·ç‚¹è‡ªå·±ä¸º0ï¼Œå…¶å®ƒä¸ºè‡ªå·±è¿æ¥åˆ°é›†åˆæœ€å°æƒå€¼ï¼›bool used[maxv]; //è¡¨ç¤ºé¡¶ç‚¹ æ˜¯å¦å·²ç»è¿æ¥ä¸Šï¼›int V; //é¡¶ç‚¹æ•°ç›®ï¼›int prim() &#123; for(int i=0; i&lt;V; i++) &#123; mincost[i]=INF; //å¼€å§‹çš„æ—¶å€™å…¨éƒ¨åˆå§‹åŒ–ä¸ºæ— ç©·å¤§ã€‚ used[i]=false; //åˆå§‹åŒ– ï¼Œå…¨éƒ¨æ²¡æœ‰è¿æ¥ã€‚ &#125; mincost[0]=0; //ä»¥ 0 èŠ‚ç‚¹ä¸ºèµ·ç‚¹å¼€å§‹è¿æ¥ã€‚ int res = 0; //æƒå€¼å’Œ while(1) &#123; int v=-1; //é€‰æ‹©çš„èŠ‚ç‚¹ï¼Œå¼€å§‹ä¸º-1ï¼Œç„¶åå¼€å§‹æ‰¾å·²ç»ç¡®å®šæ˜¯æœ€å°çš„è·ç¦» for(int u=0; u&lt;V; u++) &#123; if(!used[u]&amp;&amp; (v == -1 || mincost[u]&lt;mincost[v]))v=u; //å¦‚æœ v==-1æˆ–è€…ä¸æ˜¯æœ€å°è·ç¦»çš„æ—¶å€™æ›´æ–°vã€‚ &#125; if(v==-1)break; //åªæœ‰åœ¨æ‰€æœ‰çš„ç‚¹éƒ½å·²ç»åŠ å…¥é›†åˆ v==-1ã€‚è·³å‡ºå¾ªç¯ã€‚ used[v]=true; //æŠŠé¡¶ç‚¹åŠ å…¥é›†åˆã€‚ res+=mincost[v]; //æŠŠè¾¹çš„é•¿åº¦åŠ åˆ°ç»“æœé‡Œ for(int u=0; u&lt;V; u++) &#123; mincost[u]=min(mincost[u],cost[v][u]); //ä»å½“å‰ç‚¹åˆ°å…¶å®ƒç‚¹çš„è·ç¦»å¦‚æœæ¯”å…¶ä»–è·¯çŸ­å°±æ›´æ–°ã€‚ &#125; &#125; return res;&#125;int main() &#123; int m; scanf(&quot;%d%d&quot;,&amp;V,&amp;m); //è¾“å…¥é¡¶ç‚¹æ•°å’Œè¾¹æ•°ã€‚ æ³¨æ„å®šç‚¹æ˜¯ä» 0 åˆ°V-1ã€‚ for(int i=0; i&lt;m; i++) &#123; int u,v,w; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); cost[u][v]=cost[v][u]=w; &#125; printf(&quot;%d\n&quot;,prim());//ä¸‹é¢æ˜¯POJ 1258 ä¸»ç¨‹åºä»£ç ã€‚ /* while(cin&gt;&gt;V) &#123; for(int i=0; i&lt;V; i++) &#123; for(int j=0; j&lt;V; j++) &#123; cin&gt;&gt;cost[i][j]; &#125; &#125; printf(&quot;%d\n&quot;,prim()); &#125; */ return 0;&#125; æ¥ä¸‹æ¥æ˜¯Kruskal ä»£ç  è¿™ä¸ªç®—æ³•å…¶å®å’ŒPrim ç®—æ³•å·®è·ä¸å¤§ï¼Œè¿™ä¸ªæ˜¯ç›´æ¥æŠŠè¾¹æ’åº æ‰¾åˆ°æœ€å°çš„è¾¹ åˆ¤æ–­è¾¹çš„ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯ä¸æ˜¯è¿æ¥åˆ°åŒä¸€é¢—æ ‘ä¸Šï¼Œæ˜¯è·³è¿‡ï¼Œä¸æ˜¯è¿æ¥ä¸¤ä¸ªé¡¶ç‚¹çš„æ ¹èŠ‚ç‚¹ï¼Œç»“æœåŠ ä¸Šè¾¹ã€‚ é‡å¤ä¸Šé¢ä¸¤æ­¥ï¼Œç›´åˆ°è¿æ¥N-1æ¡è¾¹ï¼Œå› ä¸ºNä¸ªé¡¶ç‚¹è¦N-1æ¡è¾¹å°±èƒ½è¿æ¥èµ·æ¥ã€‚ å¯¹äºè¿™ä¸ªå›¾ï¼Œé¦–å…ˆå°±æ‰¾åˆ°ï¼ˆ2ï¼Œ3 ï¼‰è¿™æ¡è¾¹è¿èµ·æ¥ï¼Œç„¶åå°±æ˜¯ï¼ˆ4 5ï¼‰ï¼Œç„¶åï¼ˆ0 2ï¼‰ï¼Œè¿™æ—¶å€™æœ‰2æ£µæ ‘ ï¼ˆ0 2 3 ï¼‰å’Œï¼ˆ4 5ï¼‰ç„¶åæ¥ç€è¿ ï¼ˆ2 5ï¼‰ï¼ˆ5 6 ï¼‰ï¼ˆ1 4ï¼‰å°±å…¨éƒ¨è¿æ¥ä¸Šäº† ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxv=1e3+25; //æœ€å¤§é¡¶ç‚¹æ•°const int maxm=1e6+25; //æœ€å¤§è¾¹æ•°const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int V,m; //é¡¶ç‚¹æ•°ç›®ï¼›struct edge &#123; int u,v,cost; //èŠ‚ç‚¹ç”¨æ¥ ä¿å­˜æ¯ä¸ªè¾¹çš„æƒ…å†µ&#125;;bool cmp(const edge &amp; a,const edge &amp; b) &#123; return a.cost&lt;b.cost; //ç”¨äºæ’åºï¼Œç›¸å½“äºé‡è½½å°äºå·ã€‚&#125;edge es[maxm];int par[maxv]; // par[i]==j. i çš„ æ ¹èŠ‚ç‚¹ä¸º j;int find(int x) &#123; //å¯»æ‰¾æ ¹èŠ‚ç‚¹ if(x==par[x])return x; //å¦‚æœæ ¹èŠ‚ç‚¹å°±æ˜¯è‡ªå·±ç›´æ¥è¿”å›è‡ªå·± else return par[x]=find(par[x]); //å¦‚æœæ ¹èŠ‚ç‚¹ä¸æ˜¯è‡ªå·±ï¼Œç»§ç»­å¯»æ‰¾è‡ªå·±ä¸Šä¸€ä¸ªèŠ‚ç‚¹çš„æ ¹èŠ‚ç‚¹ã€‚&#125;void unit(int x,int y) &#123; x=find(x); //æ‰¾åˆ° x çš„æ ¹èŠ‚ç‚¹ y=find(y); par[x]=y; //æŠŠ x çš„æ ¹èŠ‚ç‚¹ è¿æ¥ä¸Š y.&#125;void init(int n) &#123; for(int i=0; i&lt;=n; i++)par[i]=i; //åˆå§‹åŒ–çš„æ—¶å€™æ ¹èŠ‚ç‚¹éƒ½æ˜¯è‡ªå·±ï¼›&#125;int Kruskal() &#123; sort(es,es+m,cmp); //æŒ‰ è¾¹çš„æƒå€¼æ’åºï¼› init(V); int res=0,se=0; //se ä¿å­˜è¾¹æ•°ã€‚ for(int i= 0; i&lt;m; i++) &#123; edge e =es[i]; if(find(e.u)!=find(e.v)) &#123; //å¦‚æœæ ¹èŠ‚ç‚¹ä¸ç›¸åŒå°±è¿æ¥ unit(e.u,e.v); res+=e.cost; if(++se==V-1)return res; //å¦‚æœè¿äº†V-1æ¡è¾¹å°±è·³å‡ºï¼› &#125; &#125; return res;&#125;int main() &#123; scanf(&quot;%d%d&quot;,&amp;V,&amp;m); //è¾“å…¥é¡¶ç‚¹æ•°å’Œè¾¹æ•°ã€‚ æ³¨æ„å®šç‚¹æ˜¯ä» 0 åˆ°V-1ã€‚ for(int i=0; i&lt;m; i++) &#123; int u,v,w; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); es[i].u=u; es[i].v=v; es[i].cost=w; &#125; printf(&quot;%d\n&quot;,Kruskal()); // POJ 1285 AC ä¸»ç¨‹åºä»£ç  /* while(cin&gt;&gt;V) &#123; int k=0; for(int i=0; i&lt;V; i++) &#123; for(int j=0; j&lt;V; j++) &#123; cin&gt;&gt;es[k].cost; es[k].u=i; es[k].v=j; k++; &#125; &#125; m=k; printf(&quot;%d\n&quot;,Kruskal()); &#125;*/ return 0;&#125;]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç‰›å®¢ç»ƒä¹ èµ›19]]></title>
    <url>%2F2018%2F06%2F04%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B19%2F</url>
    <content type="text"><![CDATA[é“¾æ¥ï¼šhttps://www.nowcoder.com/acm/contest/111/Aæ¥æºï¼šç‰›å®¢ç½‘ æ—¶é—´é™åˆ¶ï¼šC/C++ 1ç§’ï¼Œå…¶ä»–è¯­è¨€2ç§’ç©ºé—´é™åˆ¶ï¼šC/C++ 524288Kï¼Œå…¶ä»–è¯­è¨€1048576K64bit IO Format: %lld é¢˜ç›®æè¿° ä½œä¸ºæ•…äº‹ä¸»è§’çš„æ‰˜ç±³æ˜¯ä¸€åè€å¸ˆã€‚ ä¸€å¤©ï¼Œä»–æ­£åœ¨ä¸ºè§£æç®—æœ¯è¡¨è¾¾å¼çš„è¯¾ç¨‹å‡†å¤‡è¯¾ä»¶ã€‚ åœ¨è¯¾ç¨‹çš„ç¬¬ä¸€éƒ¨åˆ†ï¼Œä»–åªæƒ³ä¸“æ³¨äºè§£ææ‹¬å·ã€‚ ä»–ä¸ºä»–çš„å­¦ç”Ÿå‘æ˜äº†ä¸€ä¸ªæœ‰è¶£çš„æ­£ç¡®æ‹¬å·åºåˆ—çš„å‡ ä½•è¡¨ç¤ºï¼Œå¦‚ä¸‹å›¾æ‰€ç¤º: å‡ ä½•è¡¨ç¤ºçš„å®šä¹‰ï¼š 1. å¯¹äºä¸€ä¸ªæ‹¬å·åºåˆ—Aï¼Œæˆ‘ä»¬å®šä¹‰g(A)æ˜¯Açš„å‡ ä½•è¡¨ç¤ºå½¢å¼,åˆ™ â€œ()â€çš„è¡¨ç¤ºæ˜¯ä¸€ä¸ª1*1çš„æ–¹å—ï¼Œé«˜åº¦ä¸º1; 2.å¯¹äºä¸€ä¸ªæ‹¬å·åºåˆ—Aï¼Œâ€(A)â€çš„è¡¨ç¤ºæ˜¯ç”±ä¸€ä¸ªæ¯”g(A)å®½2ä¸ªå•ä½é«˜1ä¸ªå•ä½çš„çŸ©å½¢åŒ…å›´g(A)ï¼Œå®ƒçš„é«˜åº¦ä¸ºA+1;3.å¯¹äºä¸¤ä¸ªæ‹¬å·åºåˆ—Aå’ŒBï¼ŒA+Bçš„å‡ ä½•è¡¨ç¤ºå½¢å¼ä¸ºæŠŠg(B)æ”¾ç½®åœ¨g(A)å³è¾¹çš„ä¸€ä¸ªå•ä½ï¼Œä¸”é«˜åº¦ä¸ºAå’ŒBçš„é«˜åº¦çš„è¾ƒå¤§å€¼ã€‚å…¶ä¸­+æŒ‡çš„æ˜¯å­—ç¬¦ä¸²çš„è¿æ¥ç¬¦ã€‚ åœ¨å®Œæˆè¯¾ä»¶åï¼Œæ‰˜ç±³è€å¸ˆå¼€å§‹ç©ä»–åšå¥½çš„å›¾ç‰‡ã€‚ ä»–å°†å›¾åƒçš„æœ‰é™åŒºåŸŸäº¤æ›¿åœ°æ¶‚æˆé»‘è‰²å’Œç™½è‰²ï¼Œä½¿æœ€å¤–é¢çš„åŒºåŸŸå…¨éƒ¨æ¶‚æˆé»‘è‰²ã€‚ å¯¹äºä¸Šé¢çš„ä¾‹å­ï¼Œè¿™ä¸ªç€è‰²å¦‚ä¸‹æ‰€ç¤ºï¼š ç°åœ¨ç»™ä½ ä¸€ä¸ªåˆæ³•çš„æ‹¬å·åºåˆ—ã€‚ è¯·è®¡ç®—é¢œè‰²ä¸ºé»‘è‰²çš„åŒºåŸŸçš„é¢ç§¯ã€‚ è¾“å…¥æè¿°: è¾“å…¥çš„ç¬¬ä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•°Tï¼Œè¡¨ç¤ºæŒ‡å®šæµ‹è¯•ç”¨ä¾‹çš„æ•°é‡ã€‚æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹å‰é¢éƒ½æœ‰ä¸€ä¸ªç©ºç™½è¡Œã€‚æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹ç”±ä¸€ä¸ªåˆæ³•æ‹¬å·åºåˆ—ç»„æˆã€‚ æ¯è¡ŒåªåŒ…å«å­—ç¬¦â€™(â€˜å’Œâ€™)â€™ã€‚ è¾“å‡ºæè¿°: å¯¹äºæ¯ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œè¾“å‡ºä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•°,è¡¨ç¤ºç›¸åº”å‡ ä½•è¡¨ç¤ºçš„é»‘è‰²éƒ¨åˆ†çš„é¢ç§¯ã€‚ ç¤ºä¾‹1 è¾“å…¥ å¤åˆ¶ 2 ((())) (())(()(())) è¾“å‡º å¤åˆ¶ 10 20 è¯´æ˜ ç¬¬äºŒä¸ªæµ‹è¯•æ¡ˆä¾‹æ˜¯ä¸Šå›¾ä¸­æ˜¾ç¤ºçš„æ¡ˆä¾‹ã€‚ å¤‡æ³¨: 1â‰¤Tâ‰¤10 ä¸€ä¸ªåˆæ³•æ‹¬å·åºåˆ—é•¿åº¦â‰¤4 x 105 è¿™é¢˜ä¸»è¦æ˜¯å¤„ç†ä¸‰ä¸ªé—®é¢˜ ä¸€ä¸ªæ˜¯é•¿æ–¹ä½“çš„é«˜åº¦ï¼Œä¸€ä¸ªé•¿åº¦ï¼Œç™½è‰²è¿˜æ˜¯é»‘è‰²ã€‚ é¦–å…ˆé¢„å¤„ç†ï¼Œé¢œè‰²ï¼Œå’Œé«˜åº¦ é¢œè‰²ï¼Œåˆ¤æ–­æ˜¯ç¬¬å‡ ä¸ªå¥‡å¶å°±è¡Œäº†ï¼Œç¬¬ä¸€ä¸ªè‚¯å®šæ˜¯é»‘è‰²ï¼Œç¬¬äºŒä¸ªå°±æ˜¯ç™½è‰²ã€‚ æ³¨æ„å¤„ç†çš„æ—¶å€™æ¯åŒ¹é…ä¸€ä¸ªâ€™)â€™ æ•°é‡å°±è¦å‡1ï¼› é•¿æ–¹ä½“çš„é«˜ï¼Œç”¨ä¸€æ£µæ ‘å°±è¡Œäº†ï¼Œç„¶åæ¯ä¸ªâ€˜ï¼ˆâ€™çš„åº¦å°±æ˜¯æ¯ä¸ªé•¿æ–¹å½¢çš„é«˜åº¦ã€‚ é•¿åº¦å®¹æ˜“å¤„ç† ç›´æ¥æ‰¾åˆ°åŒ¹é…çš„æ‹¬å·ç›´æ¥è·ç¦» -1 å°±æ˜¯é•¿æ–¹ä½“é•¿åº¦ æˆ‘ç”¨æ ˆæ¥ä¿å­˜ â€˜ï¼ˆâ€™çš„ä½ç½®ã€‚ é‡è§â€™(â€™å‹å…¥æ ˆ ï¼Œé‡è§â€˜)â€™å¼¹å‡º ï¼Œè®¡ç®—è·ç¦»ã€‚å¦‚æœæ˜¯ç™½è‰²å°±æ˜¯å‡å»è¿™ä¸ªé•¿æ–¹å½¢çš„é¢ç§¯ï¼Œé»‘è‰²å°±åŠ ä¸Šã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxn=1e7+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int a[maxn];int p[maxn],b[maxn];char ch[maxn];int n;stack&lt;int&gt; s;int main() &#123; scanf(&quot;%d&quot;,&amp;n); while(n--) &#123; scanf(&quot;%s&quot;,ch); int l=strlen(ch); a[0]=1; int x=1,y=0; p[0]=-1; b[0]=1; int k=0; for(int i=1; i&lt;l; i++) &#123; if(ch[i]==&apos;(&apos;) &#123; a[i]=a[i-1]+1; p[i]=k; k=i; b[k]=1; &#125; else &#123; b[p[k]]=max(b[p[k]],b[k]+1); k=p[k]; a[i]=a[i-1]-1; &#125; &#125;// for(int i=0;i&lt;l;i++)// printf(&quot;%d%c&quot;,b[i],i+1==l?&apos;\n&apos;:&apos; &apos;); long long flag=1,sum=0; for(int i=0; i&lt;l; i++) &#123; if(ch[i]==&apos;(&apos;) &#123; s.push(i); &#125; else &#123; int k=s.top(); s.pop(); if(a[k]%2==1)sum=sum+(i-k)*(b[k]); else sum-=(i-k)*(b[k]); &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125; Dï¼š é“¾æ¥ï¼šhttps://www.nowcoder.com/acm/contest/111/Dæ¥æºï¼šç‰›å®¢ç½‘ æ—¶é—´é™åˆ¶ï¼šC/C++ 1ç§’ï¼Œå…¶ä»–è¯­è¨€2ç§’ç©ºé—´é™åˆ¶ï¼šC/C++ 524288Kï¼Œå…¶ä»–è¯­è¨€1048576K 64bit IO Format: %lld é¢˜ç›®æè¿° æ­¤æ—¶çš„æ‰˜ç±³è€å¸ˆå·²ç»å‡ºä»»CEOï¼Œè¿å¨¶ç™½å¯Œç¾ï¼Œèµ°å‘äº†äººç”Ÿå·…å³°ï¼äºæ˜¯è¿™ä¸ªæš‘å‡ï¼Œæ‰˜ç±³è€å¸ˆæ‰“ç®—åœ¨åŒ—äº¬ä¸€ä¸ªååƒ»çš„å°å†œæ‘é‡Œåº¦è¿‡ä»–çš„å‡æœŸã€‚ ç”±äºè¿™é‡Œä»€ä¹ˆéƒ½æ²¡æœ‰ï¼Œäºæ˜¯ä»–å»è¶…å¸‚é€‰äº†å¾ˆå¤šç”Ÿæ´»ç”¨å“ï¼Œæ›´å¤šçš„æ˜¯åƒçš„ï¼Œç„¶åæ¨ç€å †æ»¡é›¶é£Ÿçš„è´­ç‰©è½¦åˆ°æŸœå°ç­‰å¾…ç»“è´¦ã€‚ å½“ç„¶ï¼Œæˆ‘ä»¬éƒ½çŸ¥é“ä»–çš„é’±åŒ…é‡Œæœ‰å¾ˆå¤šé’±ã€‚ä½†æ˜¯ï¼Œä½œä¸ºä¸€åä¸ºç”Ÿæ´»ç²¾æ‰“ç»†ç®—çš„ç”·å­©å­ï¼Œä»–æ›´æ„¿æ„ä½¿ç”¨å…¶ä»–æ”¯ä»˜æ–¹å¼å¦‚ï¼šé¥­åˆ¸ï¼Œç¤¼åˆ¸ï¼Œä¸åŒç±»å‹çš„ä¼˜æƒ åˆ¸ç­‰ã€‚ä½†æ˜¯é¥­åˆ¸åªèƒ½ç”¨äºè´­ä¹°é£Ÿç‰©ï¼Œè€Œç¤¼åˆ¸é€šå¸¸åªé™äºæŸç§ç±»å‹çš„ç¤¼ç‰©ã€‚ ç°åœ¨ç»™ä½ æ‰˜ç±³è´­ç‰©è½¦ä¸­ç‰©å“çš„æ•°é‡Nå’Œæ¯ä»¶ç‰©å“çš„ä»·æ ¼ã€‚ä¹Ÿä¼šç»™å‡ºä»–é’±åŒ…ä¸­çš„ä»£é‡‘åˆ¸æ•°é‡Mä»¥åŠå…è®¸ä½¿ç”¨çš„ä¿¡æ¯ ã€‚ åœ¨ä¸ºä»–çš„è´­ç‰©ä»˜æ¬¾æ—¶ï¼Œæ‰˜ç±³å¯èƒ½ä½¿ç”¨ä»£é‡‘åˆ¸çš„é‡‘é¢è¶…è¿‡ä»–æ‰€è´­ç‰©å“çš„æˆæœ¬ã€‚ä¹Ÿå¯ä»¥åœ¨å¤šå¼ ä»£é‡‘åˆ¸ä¹‹é—´æ‹†åˆ†å•†å“çš„æˆæœ¬ï¼Œå¹¶ä½¿ç”¨ä»£é‡‘åˆ¸æ”¯ä»˜å¤šä»¶å•†å“ã€‚ è¯·ä½ è®¡ç®—æ‰˜ç±³éœ€è¦ä¸ºè´­ç‰©æ”¯ä»˜çš„é¢å¤–ç°é‡‘çš„æœ€å°é‡‘é¢ã€‚ è¾“å…¥æè¿°:1è¾“å…¥çš„ç¬¬ä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•°Tï¼Œç”¨äºæŒ‡å®šæµ‹è¯•ç”¨ä¾‹çš„æ•°é‡ã€‚ æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹å‰é¢éƒ½æœ‰ä¸€ä¸ªç©ºç™½è¡Œã€‚ æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹ä»åŒ…å«ä¸¤ä¸ªæ­£æ•´æ•°N(ç‰©å“æ•°é‡)å’ŒM(åˆ¸æ•°é‡)çš„è¡Œå¼€å§‹ã€‚ æ¥ä¸‹æ¥ä¸€è¡ŒåŒ…å«Nä¸ªæ•°å­—ï¼Œç¬¬iä¸ªæ•°å­—è¡¨ç¤ºæ‰˜ç±³è´­ç‰©è½¦é‡Œç¬¬iä»¶ç‰©å“çš„ä»·æ ¼ã€‚ æ¥ä¸‹æ¥ä¸€è¡ŒåŒ…å«Mä¸ªæ•°å­—ï¼Œç¬¬iä¸ªæ•°å­—è¡¨ç¤ºç¬¬iå¼ åˆ¸çš„é‡‘é¢ã€‚ æ¥ä¸‹æ¥æœ‰Mè¡Œï¼Œå½“ä¸­çš„ç¬¬ i è¡Œæè¿°ç¬¬ i å¼ å·å¯ä»¥ä¹°å“ªäº›å•†å“ã€‚æ¯è¡Œçš„ç¬¬ä¸€ä¸ªæ•°å­—æ˜¯ K,ä»£è¡¨ç¬¬ i å¼ å·å¯ä»¥ä¸º K ä»¶å•†å“ä»˜æ¬¾ï¼Œæ¥ä¸‹æ¥è¿˜æœ‰ K ä¸ªæ•°ï¼Œæ˜¯è¿™ K ä»¶å•†å“çš„ç¼–å· è¾“å‡ºæè¿°:1å¯¹äºæ¯ä¸ªæµ‹è¯•ç”¨ä¾‹è¾“å‡ºæ•°å­—ï¼Œè¡¨ç¤ºæ‰˜ç±³éœ€è¦æ”¯ä»˜å¤šå°‘ç°é‡‘ã€‚ æœ€å¤§æµæ¨¡æ¿é¢˜ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxn=2e2+25;const int maxm=4e3+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,m,T;int a[maxn],b[maxm];struct edge &#123; int to,cap,rev;&#125;;vector &lt;edge&gt; G[maxn+maxm];bool used[maxn+maxm];int level[maxn+maxm];int iter[maxn+maxm];void bfs(int s) &#123; memset(level,-1,sizeof(level)); queue&lt;int&gt; que; level[s]=0; que.push(s); while(!que.empty()) &#123; int v= que.front(); que.pop(); for(int i=0; i&lt;G[v].size(); i++) &#123; edge &amp; e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0) &#123; level[e.to]=level[v] + 1; que.push(e.to); &#125; &#125; &#125;&#125;void add(int from,int to,int cap) &#123; edge eg; eg.to=to; eg.cap=cap; eg.rev=G[to].size(); G[from].push_back(eg); eg.to=from; eg.cap=0; eg.rev=G[from].size()-1; G[to].push_back(eg);&#125;//int dfs(int v,int t,int f) &#123;// if(v == t)return f;// used[v]=true;// for(int i = 0; i &lt; G[v].size(); i++) &#123;// edge &amp;e=G[v][i];// if(!used[e.to]&amp;&amp;e.cap&gt;0) &#123;// int d=dfs(e.to,t,min(f,e.cap));// if(d&gt;0) &#123;// e.cap-=d;// G[e.to][e.rev].cap+=d;// return d;// &#125;// &#125;// &#125;// return 0;//&#125;int dfs(int v,int t,int f) &#123; if(v == t)return f; for(int &amp;i = iter[v]; i &lt; G[v].size(); i++) &#123; edge &amp;e=G[v][i]; if(e.cap&gt;0 &amp;&amp; level[v]&lt;level[e.to]) &#123; int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0) &#123; e.cap-=d; G[e.to][e.rev].cap+=d; return d; &#125; &#125; &#125; return 0;&#125;/*int maxflow(int s,int t) &#123; int flow=0; for(;;) &#123; memset(used,0,sizeof(used)); int f=dfs(s,t,INF); if(f==0)return flow; flow += f; &#125;&#125;*/int maxflow(int s,int t) &#123; int flow=0; for(;;) &#123; bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while((f = dfs(s,t,INF))&gt;0) &#123; flow +=f; &#125; &#125;&#125;int main() &#123; scanf(&quot;%d&quot;,&amp;T); while(T--) &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int sum=0; for(int i=0;i&lt;=m+n+1;i++)G[i].clear(); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); sum+=a[i]; add(i,n+m+1,a[i]); &#125; for(int j=1; j&lt;=m; j++) &#123; scanf(&quot;%d&quot;,&amp;b[j]); add(0,n+j,b[j]); &#125; for(int i=1; i&lt;=m; i++) &#123; int k; scanf(&quot;%d&quot;,&amp;k); for(int j=0; j&lt;k; j++) &#123; int x; scanf(&quot;%d&quot;,&amp;x); add(n+i,x,a[x]); &#125; &#125; cout&lt;&lt;sum-maxflow(0,n+m+1)&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP]]></title>
    <url>%2F2018%2F05%2F23%2FKMP%2F</url>
    <content type="text"><![CDATA[KMPç®—æ³•ï¼Œåˆšæ¥è§¦åˆ°è¿™ä¸ªç®—æ³•æœ¬æ¥ä¸€çœ‹æ˜¯çœ‹ä¸€çœ¼å°±ä¼šäº†ï¼Œä½†æ˜¯è¿‡äº†ä¸€æ®µæ—¶é—´åè€Œä¸ä¼šäº†ï¼Œæå¾—æˆ‘åˆé‡æ–°å›æ¥å­¦äº†ä¸€æ¬¡ã€‚ å…¶å®KMPç®—æ³•æŒºç®€å•çš„ï¼Œè¿™ä¸ªç®—æ³•çš„æ ¸å¿ƒæˆ‘æ„Ÿè§‰å°±æ˜¯åœ¨å¤„ç†next æ•°ç»„ä¸Šã€‚ æˆ‘å…ˆè®²ä¸€ä¸‹ä¸€ç§å¤„ç†æ–¹å¼å§ï¼Œ next [0]=-1,è¿™ä¸ªä¸ç”¨å¤šè¯´ï¼Œç¬¬ä¸€ä¸ªè‚¯å®šæ˜¯æ²¡æœ‰åŒ¹é…å¥½çš„ã€‚ k=-1; ,i=0ä¸¤ä¸ªåˆå§‹åŒ– ï¼Œk,è¡¨ç¤ºçš„æ˜¯åŒ¹é…åˆ°çš„ä½ç½® ï¼Œiï¼Œè¡¨ç¤ºçš„æ˜¯ä½ æ­£åœ¨ä¸ºé‚£ä¸ªä½ç½®æ ‡è®°nextã€‚ 123456789101112131415161718192021222324252627282930313233343536 #include&lt;bits/stdc++.h&gt;using namespace std; void getnext(const char * str,int * next) &#123; next[0]=-1; int i=0,k=-1; while(str[i]!=&apos;\0&apos;) &#123; while(k!=-1&amp;&amp;str[i]!=str[k])k=next[k];// åœ¨ä½ åŒ¹é…è¿™ä¸ª i ä¹‹å‰é¦–å…ˆå¯»æ‰¾åˆ°å‰é¢ä¸€ä¸ªæœ€å¤§åŒ¹é…ä½ç½®ï¼Œ //å¦‚æœ ä¸åŒ¹é…å°±ä¸€ç›´å¾€å‰é¢å›æº¯ï¼Œç›´åˆ°èƒ½å¤ŸåŒ¹é…ã€‚ i++; k++; if(str[i]==str[k])next[i]=next[k]; //å½“å‰ä½ç½®æ˜¯ç›¸ç­‰çš„ è¿™ä¸ªä¸åŒ¹é… åŒæ · Kçš„ä½ç½®ä¹Ÿæ²¡æ³•åŒ¹é…ï¼Œæ‰€ä»¥ next [i]å¯ä»¥ç›´æ¥ç­‰äºnext[k]. else next[i]=k; &#125;&#125;int kmp(const char *s,const char * c)&#123; int lc=strlen(c),ls=strlen(s); int *next=new int[lc+1]; getnext(c,next); int j=0,i=0; while(i&lt;ls) &#123; while(j!=-1&amp;&amp;s[i]!=c[j])j=next[j]; i++,j++; if(j==lc)return 1; &#125; return 0;&#125; int main() &#123; int next[1000]; char ch[]=&quot;abaabc&quot;,s[]=&quot;ababaababcb&quot;; cout&lt;&lt;kmp(s,ch)&lt;&lt;endl;&#125;]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DPå­¦ä¹ ç¬”è®°ï¼Œé¢˜ç›® Traveling by Stagecoach POJ 2686 é¢˜è§£]]></title>
    <url>%2F2018%2F05%2F19%2FDP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8C%E9%A2%98%E7%9B%AE%20Traveling%20by%20Stagecoach%20POJ%20%202686%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Traveling by Stagecoach POJ 2686ï¼Œé¢˜è§£ã€‚ ä½œä¸ºä¸€åèœé¸Ÿï¼Œè¯´çŠ¶å‹DPï¼Œè¿˜æ˜¯æœ‰ç‚¹å‹‰å¼ºï¼Œé¡¶å¤šåšä¸ªå­¦ä¹ ç¬”è®°ã€‚ é¦–å…ˆï¼Œä»€ä¹ˆæ˜¯DPï¼ŒçŠ¶æ€è½¬ç§»ï¼Œå…¶å®å°±æ˜¯ä»å·²ç»ç¡®å®šçš„çŠ¶æ€ï¼Œåˆ°ä¸€ä¸ªçŠ¶æ€ã€‚ çŠ¶å‹DPï¼Œæˆ‘ç†è§£çš„å°±æ˜¯ ç”¨ ä¸€ä¸ªæ•°çš„äºŒè¿›åˆ¶è¡¨è¾¾çŠ¶æ€ã€‚ 1ï¼Œè¡¨ç¤º æœ‰ ï¼Œ0 è¡¨ç¤ºæ—  æ¯”å¦‚ 4è€Œè¿›åˆ¶è¡¨ç¤º 100 ï¼Œ è¯´æ˜ 3å· ä½ç½®è¡¨ç¤º æœ‰ ï¼Œå…¶å®ƒçš„éƒ½è¡¨ç¤ºæ²¡æœ‰ã€‚ é¢˜ç›® Traveling by Stagecoach POJ 2686 å¼€ä¸€ä¸ªDPã€Sã€‘[M]. S æ˜¯ç¥¨çš„ä½¿ç”¨çŠ¶å†µ ï¼Œ Mï¼Œæ˜¯åœ¨å“ªä¸€ä¸ªåŸå¸‚ã€‚å€¼å°±æ˜¯æœ€å°èŠ±è´¹ã€‚ æŠŠä¸€ä¸ªç¥¨éƒ½æ²¡æœ‰ç”¨çš„ï¼Œèµ·ç‚¹ æ ‡è®°ä¸º0,ä¹Ÿå°±æ˜¯ DP[1&lt;&lt;n-1][a]==0. æš´åŠ›æšä¸¾ æ‰€æœ‰ å¯ä»¥ç”¨çš„ç¥¨ ï¼Œ(S&gt;&gt;i)&amp;1 è¡¨ç¤ºç¬¬ I å¼ ç¥¨å¯ä¸å¯ä»¥ç”¨ã€‚ å†æš´åŠ›æšä¸¾ å½“å‰è¿™ä¸ªSä¸‹æ‰€æœ‰çš„ å¯ä»¥åˆ°çš„åŸå¸‚ï¼Œdp[S][v]!=INFï¼Œå½“å‰Sä¸‹vè¿™ä¸ªåŸå¸‚å¯ä¸å¯ä»¥åˆ°è¾¾ã€‚ ç„¶åå†æš´åŠ›æ‰€æœ‰ vï¼Œ è¿™ä¸ªåŸå¸‚æ‰€æœ‰çš„è·¯ï¼Œç„¶åä½¿ç”¨ç¬¬ iå¼ ç¥¨ã€‚d[v][u]&gt;=0ã€‚V å’Œuä¸­é—´çš„è·¯ã€‚ ç„¶å¦‚æœç”¨è¿™å¼ ç¥¨ï¼Œèµ°è¿™æ¡è·¯ åˆ°ç›®çš„åœ°çš„å€¼å°å°±è¦†ç›–å‰é¢çš„å€¼S&amp;~(1&lt;&lt;i)ä½¿ç”¨ç¬¬iå¼ ç¥¨åçš„çŠ¶æ€ï¼Œd[v][u],ä» våŸå¸‚åˆ°uåŸå¸‚çš„è·¯ã€‚ dp[S&amp;~(1&lt;&lt;i)][u]=min(dp[S&amp;~(1&lt;&lt;i)][u],dp[S][v]+(double)d[v][u]*1.0/t[i])ã€‚ ACä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;stdio.h&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxn=9;const int maxm=31;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,m,a,b,p,u,v,c;int t[maxn];int d[maxm][maxm];double dp[1&lt;&lt;maxn][maxm];int main() &#123; ios_base::sync_with_stdio(false); cin.tie(0);// freopen(&quot;123.txt&quot;,&quot;r&quot;,stdin); while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;p&gt;&gt;a&gt;&gt;b) &#123; int k=(1&lt;&lt;n)-1; if(n==0&amp;&amp;m==0&amp;&amp;p==0&amp;&amp;a==0&amp;&amp;b==0)return 0; for(int i=0; i&lt;n; i++)cin&gt;&gt;t[i]; memset(d,-1,sizeof(d)); while(p--) &#123; cin&gt;&gt;u&gt;&gt;v&gt;&gt;c; d[u][v]=c; d[v][u]=c; &#125; for(int i=0; i&lt;=k; i++)fill(dp[i],dp[i]+m+1,INF); dp[k][a]=0; double res=INF; for(int S=k; S&gt;=0; S--) &#123; res=min(res,dp[S][b]); for(int i=0; i&lt;n; i++) &#123; if((S&gt;&gt;i)&amp;1) &#123; for(v =1; v&lt;=m; v++) &#123; if(dp[S][v]!=INF) &#123; for(u=1; u&lt;=m; u++) &#123; if(d[v][u]&gt;=0) &#123; dp[S&amp;~(1&lt;&lt;i)][u]=min(dp[S&amp;~(1&lt;&lt;i)][u],dp[S][v]+(double)d[v][u]*1.0/t[i]); &#125; &#125; &#125; &#125; &#125; &#125; &#125; if(res==INF) &#123; printf(&quot;Impossible\n&quot;); &#125; else &#123; printf(&quot;%.3f\n&quot;,res); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 æ¹˜æ½­é‚€è¯·èµ› éƒ¨åˆ†é¢˜è§£]]></title>
    <url>%2F2018%2F05%2F14%2F2018%20%E6%B9%98%E6%BD%AD%E9%82%80%E8%AF%B7%E8%B5%9B%20%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[2018 æ¹˜æ½­é‚€è¯·èµ› é¢˜è§£ A C F G K .å…¶å®ƒé¢˜è§£ï¼Œåç»­æ·»åŠ  A é¢˜ æ²¡å•¥å¥½è®²çš„ï¼Œç­¾åˆ°é¢˜ ä»åé¢å¾€å‰é¢æ•°ï¼Œå¤§äºä¸ªæ•°çš„æ—¶å€™ç›´æ¥è¾“å‡ºå°±è¡Œäº†ã€‚ ACä»£ç ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;const long long mod=1e9+7;const int maxn=2e5+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int main() &#123; int n,a[maxn]; long long sum=0; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) &#123; sum=0; for(int i=0; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; for(int i=n; i&gt;=0; i--) &#123; sum+=a[i]; if(sum&gt;=i) &#123; printf(&quot;%d\n&quot;,i); break; &#125; &#125; &#125; return 0;&#125; Cé¢˜ é¢˜ç›®çš„æ„æ€å°±æ˜¯æ‰¾ä¸€ä¸ªåŒºé—´æ¯” ä¸€ä¸ªæ•°å¤§çš„æ•°çš„ä¸ªæ•°è¦ä¸å°äºè¿™ä¸ªæ•°ã€‚æ±‚è¿™ä¸ªæ•°æœ€å¤§æ˜¯å¤šå°‘ã€‚ è¿™ä¸€é¢˜å°±æ˜¯ä¸€ä¸ªåŒºåŸŸæ ‘ï¼ˆå¤§ä½¬ä»¬å‘Šè¯‰æˆ‘ä¹Ÿå«ä¸»å¸­æ ‘ï¼Œç„¶è€Œæˆ‘è¿™ä¸ªèœé¸¡ä¸çŸ¥é“å•¥æ˜¯ä¸»å¸­æ ‘ï¼‰ï¼Œä¸€èˆ¬çº¿æ®µæ ‘ç»´æŠ¤çš„æ˜¯ä¸€ä¸ªå€¼ã€‚è¿™é¢˜æ¯ä¸ªèŠ‚ç‚¹ç»´æŠ¤çš„æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œè¿™ä¸ªé¢˜æ²¡æœ‰ä¿®æ”¹åªæœ‰æŸ¥è¯¢ã€‚ æ¯æ¬¡æŸ¥è¯¢åœ¨åŒ…å«è¿™ä¸ªåŒºé—´å°±äºŒåˆ†æŸ¥æ‰¾å¤§äºè¿™ä¸ªæ•°çš„ä¸ªæ•°ï¼Œ å¦‚æœ ä¸åŒ…å«è¿”å›é›¶ã€‚ å¦‚æœæœ‰ä¸€éƒ¨åˆ†åœ¨è¿™ä¸ªåŒºé—´å°±ç»§ç»­å¾€ä¸‹æ‰¾ï¼Œç„¶åè¿”å›ä¸¤ä¸ªå„¿å­çš„ä¸ªæ•°å’Œã€‚ å¤æ‚åº¦æ˜¯ï¼ˆnlogn+m log^3 nï¼‰; ACä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;const long long mod=1e9+7;const int maxn=1e7+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;const int sz=(1&lt;&lt;18)-1;int n,m;int a[maxn];vector&lt;int&gt; dat[sz];void init(int k,int l,int r) &#123; dat[k].clear(); if(r-l==1)dat[k].push_back(a[l]); else &#123; int lch=k*2+1,rch=k*2+2,md=(l+r)/2; init(lch,l,md); init(rch,md,r); dat[k].resize(r-l); merge(dat[lch].begin(),dat[lch].end(),dat[rch].begin(),dat[rch].end(),dat[k].begin()); &#125;&#125;int query(int i,int j,int x,int k,int l,int r) &#123; if(j&lt;=l||r&lt;=i)return 0; else if(i&lt;=l&amp;&amp;r&lt;=j) &#123; return dat[k].end()-lower_bound(dat[k].begin(),dat[k].end(),x); &#125; else &#123; int lch=2*k+1,rch=2*k+2,md=(l+r)/2; return query(i,j,x,lch,l,md)+query(i,j,x,rch,md,r); &#125;&#125;int main() &#123; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)) &#123; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; init(0,0,n); int l,r,R,L,x; for(int i=0; i&lt;m; i++) &#123; scanf(&quot;%d%d&quot;,&amp;l,&amp;r); l--; L=1; R=n; while(R-L&gt;1) &#123; x=(R+L)/2; int c=query(l,r,x,0,0,n); if(c&gt;=x)L=x; else R=x; &#125; printf(&quot;%d\n&quot;,L); &#125; &#125; return 0;&#125; Fé¢˜ ä¸€ä¸ªsort å°±è¿‡äº†æ²¡å•¥éš¾çš„ï¼Œå°±æ˜¯æ³¨æ„å€¼çˆ†äº†double è¦ç”¨long doubleã€‚ ACä»£ç ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;const long long mod=1e9+7;const int maxn=1e3+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;struct two &#123; long double val; int id;&#125; k[maxn];bool cmp(two &amp; a,two &amp;b) &#123; if(a.val==b.val)return a.id&lt;b.id; return a.val&lt;b.val;&#125;int main() &#123; int n; long long a,b,c,d; while(~scanf(&quot;%lld&quot;,&amp;n)) &#123; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c); long double t=0; t=a*1.0; t+=b*1.0; t=t/(t+c*1.0); k[i].id=i; k[i].val=t; &#125; sort(k,k+n,cmp); for(int i=0; i&lt;n; i++) &#123; printf(&quot;%d%c&quot;,k[i].id+1,i+1==n?&apos;\n&apos;:&apos; &apos;); &#125; &#125; return 0;&#125; Gé¢˜ æ‰¾è§„å¾‹ï¼Œè¿™ä¸ªå˜åŒ–å¯ä»¥ä¿è¯ ä¸¤ä¸ªa,bä¸€å®šå¯ä»¥æ¶ˆå»ï¼Œa,b,çš„ä½ç½®å¯ä»¥äº¤æ¢ï¼Œæ‰€ä»¥é¢˜ç›®å°±å˜æˆäº†æ‰¾ä¸¤ä¸ªå­—ç¬¦ä¸²å¯¹åº”çš„ï¼Œc ,å·¦å³ä¸¤è¾¹çš„a,bå¥‡å¶æ˜¯ä¸æ˜¯ä¸€æ ·çš„ã€‚ å¦‚æœcä¸ªæ•°ä¸ç›¸ç­‰ç›´æ¥è¾“å‡ºnoï¼› ç›¸ç­‰ åˆ¤æ–­ ï¼Œä»¥cä¸ºåˆ†éš”ç¬¦çš„åŒºé—´ a,b,çš„å¥‡å¶ç›¸ä¸ç›¸ç­‰ã€‚ ACä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;const long long mod=1e9+7;const int maxn=1e4+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;struct two &#123; int x,y;&#125; k[maxn],k2[maxn];int main() &#123; char a[maxn],b[maxn]; int flag,c; while(~scanf(&quot;%s%s&quot;,&amp;a,&amp;b)) &#123; int la=strlen(a),lb=strlen(b); memset(k,0,sizeof(k)); memset(k2,0,sizeof(k2)); c=0; flag=1; int pa,pb; pa=pb=0; for(int i=0; i&lt;la; i++) &#123; if(a[i]==&apos;a&apos;) &#123; k[pa].x=(k[pa].x+1)%2; &#125; if(a[i]==&apos;b&apos;) &#123; k[pa].y=(k[pa].y+1)%2; &#125; if(a[i]==&apos;c&apos;) &#123; pa++; c++; &#125; &#125; for(int i=0; i&lt;lb; i++) &#123; if(b[i]==&apos;a&apos;) &#123; k2[pb].x=(k2[pb].x+1)%2; &#125; if(b[i]==&apos;b&apos;) &#123; k2[pb].y=(k2[pb].y+1)%2; &#125; if(b[i]==&apos;c&apos;) &#123; pb++; c--; &#125; &#125; int l=max(pa,pb); if(c!=0)flag=0; for(int i=0; i&lt;=l; i++) &#123; if(k[i].x!=k2[i].x||k[i].y!=k2[i].y) &#123; flag=0; &#125; if(!flag)break; &#125; if(flag)printf(&quot;Yes\n&quot;); else printf(&quot;No\n&quot;); &#125; return 0;&#125; Ké¢˜ å°±æ˜¯ä¸€ä¸ªæ‰¾å› å­çš„é¢˜ 2018 å› å­ 1 ï¼Œ2018 ï¼Œ2 ï¼Œ1009ï¼› æ‰€ä»¥ æ‰€æœ‰çš„ å¥‡æ•°å¯ä»¥å’Œæ‰€æœ‰çš„ 2018çš„å€æ•°åŒ¹é…ã€‚ 2018 å¯ä»¥å’Œæ‰€æœ‰çš„æ•°åŒ¹é…ï¼Œ å¶æ•° å¯ä»¥å’Œæ‰€æœ‰ 1009 çš„å€æ•°åŒ¹é… 1009 å¯ä»¥å’Œæ‰€æœ‰ å¶æ•°åŒ¹é…ï¼› æ³¨æ„ä¸€ä¸‹ï¼Œå…¶ä¸­é‡å¤ç®—çš„å°±è¡Œã€‚ ACä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;const long long mod=1e9+7;const int maxn=2e5+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int main() &#123; long long sum=0,a,b,c,d; while(scanf(&quot;%lld%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c,&amp;d)!=EOF) &#123; sum=0; long long x1,x2,x1009,x2018,y1,y2,y1009,y2018; x2=x1=(b-a+1)/2; if((b-a)%2==0) &#123; if(a&amp;1)x1++; else x2++; &#125; x1009=(a%1009==0)+b/1009-a/1009; x2018=(a%2018==0)+b/2018-a/2018; y2=y1=(d-c+1)/2; if((d-c)%2==0) &#123; if(c&amp;1)y1++; else y2++; &#125; y1009=(c%1009==0)+d/1009-c/1009; y2018=(c%2018==0)+d/2018-c/2018; sum+=(x1-x1009+x2018)*y2018; sum+=x2018*(y1+y2); sum+=(x2-x2018)*(y1009); sum+=(x1009-x2018)*y2; printf(&quot;%lld\n&quot;,sum); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bit ä½ï¼Œæ ‘çŠ¶æ•°ç»„å­¦ä¹ ç¬”è®°ã€‚]]></title>
    <url>%2F2018%2F04%2F25%2Fbit%20%E4%BD%8D%EF%BC%8C%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%82%2F</url>
    <content type="text"><![CDATA[ç»™ä¸€ä¸ªåˆå§‹å€¼å…¨ä¸º0çš„æ•°åˆ—a1,a2,â€¦,an. ç»™å®š iï¼Œæ±‚a1+a2+..+ai. ç»™å®ši,x æ‰§è¡Œai+x; å›¾ä¸å¥½çœ‹è§è°…ï¼š å¦‚å›¾æ‰€ç¤ºï¼Œ1èŠ‚ç‚¹ç»´æŠ¤çš„æ˜¯a1æœ¬èº«çš„å’Œ 2èŠ‚ç‚¹ç»´æŠ¤çš„æ˜¯ a1åˆ°a2 çš„å’Œ 3èŠ‚ç‚¹ç»´æŠ¤çš„æ˜¯a3çš„å’Œ 4èŠ‚ç‚¹ç»´æŠ¤çš„æ˜¯a1åˆ°a4 çš„å’Œ ä¸ºå•¥ä¼šæœ‰äº›èŠ‚ç‚¹ç»´æŠ¤çš„å€¼çš„ä¸ªæ•°ä¸åŒå‘¢ï¼Ÿ å¾ˆç®€å• ï¼Œå°±æ˜¯çœ‹æœ€åä¸€ä¸ª1çš„ä½ç½®ï¼Œ2ï¼šäºŒè¿›åˆ¶0010 æœ€åä¸€ä¸ª1æ˜¯ç¬¬2ä¸ªä½ç½®æ‰€ä»¥ç»´æŠ¤2çš„2-1æ¬¡æ–¹ä¸ªå€¼ã€‚4ï¼š0100ç»´æŠ¤2çš„3-1æ¬¡æ–¹ä¸ªå€¼ã€‚ åŠ æ³•ï¼ŒæŠŠæœ‰ç»´æŠ¤è‡ªå·±çš„å€¼éƒ½åŠ ä¸ŠXå°±è¡Œäº† åŠ æ³•ï¼šä¾‹å­åœ¨a3ä¸Š+Xå°±æ˜¯åœ¨3èŠ‚ç‚¹ä¸Š+Xï¼Œ4èŠ‚ç‚¹+Xï¼Œ8èŠ‚ç‚¹+Xã€‚çœ‹ä¸€çœ¼ä¸Šå›¾ï¼Œå°±çŸ¥é“ï¼Œå°±æ˜¯æŒ‰ç®­å¤´ä¸€ä¸ªä¸ªå‘ä¸ŠèŠ‚ç‚¹è½¬ç§»ã€‚ æ€ä¹ˆå®ç°è¿™ç§è½¬ç§»å‘¢ï¼Ÿ 3çš„äºŒè¿›åˆ¶æ˜¯0011.4æ˜¯ 0100ï¼Œ8æ˜¯1000. å°±æ˜¯æŠŠåŠ ä¸Šæœ€åä¸€ä¸ª1æ‰€åœ¨ä½ç½®çš„å€¼ï¼Œ0011 +0001ï¼ˆæœ€åä¸€ä¸ªä½ç½®æ˜¯æœ€åä¸€ä¸ªï¼‰=0100ï¼› 0100+0100ï¼ˆæœ€åä¸€ä¸ª1ä½ç½®æ˜¯ç¬¬3ä¸ªï¼‰=1000ï¼› ä»¥æ­¤ç±»æ¨ï¼Œåœ¨a5ä¹Ÿæ˜¯ä¸€æ ·,0101+0001=0110(6); 0110+0010=1000(8); æ€ä¹ˆå®ç°ï¼Œå°±æ˜¯i+=i&amp;-i; i&amp;-iå¯ä»¥æŠŠè‡ªå·±æœ€åä¸€ä¸ª1çš„ä½ç½®ç®—å‡ºæ¥ï¼Œæ€ä¹ˆæ¥çš„å°±è‡ªå·±å»ç™¾åº¦å§ã€‚ æ±‚å’Œï¼šæ¯”å¦‚ å‰5ä¸ªçš„å’Œï¼Œå°±æ˜¯ï¼ˆ1åˆ°4ï¼‰+5 ä¹Ÿå°±æ˜¯4èŠ‚ç‚¹åŠ 5èŠ‚ç‚¹çš„å’Œã€‚ å‰7ä¸ªçš„å’Œå°±æ˜¯7+ï¼ˆ5åˆ°6ï¼‰+ï¼ˆ1åˆ°4ï¼‰çš„å’Œï¼Œä¹Ÿå°±æ˜¯4èŠ‚ç‚¹åŠ 6èŠ‚ç‚¹åŠ 7èŠ‚ç‚¹çš„å’Œã€‚ è‡³äºæ€ä¹ˆå®ç°å‘¢å¦‚æœç»†å¿ƒçš„è¯ä¸éš¾å‘ç°ï¼Œå…¶å®å°±æ˜¯ä»æœ€åä¸€ä¸ª1æ…¢æ…¢ä¸€ä¸ªä¸ªå˜æˆ0çš„èŠ‚ç‚¹å…¨åŠ ä¸Š å¦‚ 7çš„äºŒè¿›åˆ¶æ˜¯0111 å‰7ä¸ªçš„å’Œå°±æ˜¯ 0111+ 0110+0100 å‰ 5ï¼ˆ0101ï¼‰ä¸ªçš„å’Œ 0101 +0100 æŒ‰ä½è¿ç®—å°±æ˜¯ i-=i&amp;-i. ä»£ç éå¸¸ç®€å•ã€‚ å¤æ‚åº¦ Oï¼ˆlog Nï¼‰; includeusing namespace std;const int maxn=1&lt;0) { s +=bit[i]; i-=i&amp;-i; } return s;}void add(int i,int x){ while(i&lt;=n) { bit[i]+=x; i+=i&amp;-i; }}]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GITåŸºæœ¬æ“ä½œï¼Œå’Œåˆ«äººä¸€èµ·åšé¡¹ç›®]]></title>
    <url>%2F2018%2F04%2F16%2FGIT%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%92%8C%E5%88%AB%E4%BA%BA%E4%B8%80%E8%B5%B7%E5%81%9A%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[GitåŸºæœ¬æ“ä½œ GITæ•™ç¨‹ï¼šhttps://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 GITä¸‹è½½ï¼š åœ¨è‡ªå·±çš„ç”µè„‘ä¸Šï¼Œå®‰è£…Gitä¸‹è½½é¡µé¢ï¼šhttps://git-scm.com/downloadsä¸‹è½½å®‰è£…ï¼Œä¸€è·¯ä¸‹ä¸€æ­¥å³å¯ã€‚ GitHub Desktopä¸‹è½½åœ°å€ï¼šhttps://desktop.github.com GIT ç®€å•çš„ä½¿ç”¨ï¼š 1ã€ æ³¨å†Œç äº‘ï¼š ç äº‘æ³¨å†Œé¡µé¢ï¼šhttps://gitee.com/signup åº”è¯¥ä¸éœ€è¦æˆ‘å¤šè¯´ 2ã€ä½ éœ€è¦è®¿é—®ä»“åº“ï¼ˆæ˜¯ä¸ªç½‘å€ï¼‰ï¼š å¦‚æœä½ éœ€è¦åˆ›å»ºè‡ªå·±æœ‰ä¸€ä¸ªä¸“é—¨çš„åˆ†æ”¯è¿˜éœ€è¦forkï¼› ç‚¹å‡»fork åä¼šè®©ä½ é€‰æ‹©è‡ªå·±ï¼Œç„¶å ç‚¹å‡»ç¡®å®š ï¼Œå·¦ä¸Šè§’å˜æˆä½ è‡ªå·±çš„åå­—å°±å¯¹äº†ã€‚ å·¦ä¸Šè§’å˜æˆä½ è‡ªå·±çš„åå­—å°±å¯¹äº† å·¦ä¸Šè§’å˜æˆä½ è‡ªå·±çš„åå­—å°±å¯¹äº† å·¦ä¸Šè§’å˜æˆä½ è‡ªå·±çš„åå­—å°±å¯¹äº† ä¸€å®šè¦è®°ä½ ï¼Œé‚£ä¸ªçº¢åœˆé‡Œé¢æ˜¯è‡ªå·±çš„ç äº‘æ˜µç§°ã€‚ä¸ç„¶ä½ å°±ç­‰ç€ä¸€ç›´è®¤è¯å¤±è´¥å§ã€‚ ç‚¹å‡»çš„ã€å…‹éš†/ä¸‹è½½ã€‘ï¼Œç‚¹å‡»ã€å¤åˆ¶ã€‘æŒ‰é’®å¤åˆ¶ä¸‹é¢çš„è¿æ¥ï¼Œæˆ‘ä»¬æŠŠè¿™ä¸ªè¿æ¥ç§°ä¸ºã€è¿æ¥â‘ ã€‘ 3ã€å¼€å§‹clone ï¼š ç¬¬ä¸€ç§ï¼š è¦æ‰“å¼€çš„æ˜¯Git Bash Here ä¸æ˜¯ Git GUI here ä¸Šå›¾æŒ‡é”™äº† ç„¶åå¼€å§‹å…‹éš†å°±è¡Œäº†ï¼Œè¾“å…¥ å‘½ä»¤ git clone åšå®Œè¿™äº›ä½ å°±ä¼šå‘ç°ä½ å½“å‰æ–‡ä»¶å¤¹ä¸‹é¢å¤šäº†ä½ cloneå‡ºæ¥çš„æ–‡ä»¶å¤¹ï¼Œä¹Ÿå°±æ˜¯ä½ çš„æœ¬åœ°ä»“äº†ã€‚ ç¬¬äºŒç§ï¼š æ‰“å¼€cmdçª—å£ æŒ‰Winé”®+Rï¼Œè¾“å…¥cmdï¼ŒæŒ‰ã€ç¡®å®šã€‘ 1åœ¨cmdçª—å£ä¸­åˆ‡æ¢æ–‡ä»¶å¤¹ éšä¾¿æ‰¾ä¸€ä¸ªæ–‡ä»¶å¤¹ æ¯”å¦‚dç›˜ä¸­123æ–‡ä»¶å¤¹ï¼Œé‚£ä¹ˆè¾“å…¥D: æ•²å›è½¦ï¼Œcd 123 æ•²å›è½¦å³å¯åˆ‡æ¢ 1è¿™ä¸ªæ˜¯è½¬æ¢åˆ°ä½ è¦è½¬æ¢åˆ°ä½ è¦cloneçš„ç›®å½•ä¸‹ ç„¶åè¾“å…¥ 12 1git config --global user.name &quot;æ³¨å†Œç äº‘æ—¶ç”¨çš„æ˜µç§°&quot; 12 1git config --global user.email &quot;æ³¨å†Œç äº‘æ—¶ç”¨çš„é‚®ç®±&quot; è¿™ä¸ªæ˜¯ç™»å½• ç‰¹åˆ«æé†’ï¼šè½¬åˆ°çš„ç›®å½•æ˜¯ä»“åº“ä¸‹ï¼Œä¸æ˜¯ä½ åŸæœ¬cloneçš„ç›®å½•ä¸‹ï¼Œæ˜¯åˆ°cloneå‡ºæ¥çš„é‚£ä¸ªæ–‡ä»¶å¤¹ç›®å½•ä¸‹ã€‚åˆ«å’Œå‰é¢cloneçš„ç›®å½•ä¸€æ ·ã€‚ ç‰¹åˆ«æé†’ï¼šè½¬åˆ°çš„ç›®å½•æ˜¯ä»“åº“ä¸‹ï¼Œä¸æ˜¯ä½ åŸæœ¬cloneçš„ç›®å½•ä¸‹ï¼Œæ˜¯åˆ°cloneå‡ºæ¥çš„é‚£ä¸ªæ–‡ä»¶å¤¹ç›®å½•ä¸‹ã€‚åˆ«å’Œå‰é¢cloneçš„ç›®å½•ä¸€æ ·ã€‚ ç‰¹åˆ«æé†’ï¼šè½¬åˆ°çš„ç›®å½•æ˜¯ä»“åº“ä¸‹ï¼Œä¸æ˜¯ä½ åŸæœ¬cloneçš„ç›®å½•ä¸‹ï¼Œæ˜¯åˆ°cloneå‡ºæ¥çš„é‚£ä¸ªæ–‡ä»¶å¤¹ç›®å½•ä¸‹ã€‚åˆ«å’Œå‰é¢cloneçš„ç›®å½•ä¸€æ ·ã€‚ å’Œç¬¬ä¸€ç§çš„åŒºåˆ«æ˜¯ç”¨çš„æ˜¯è‡ªå·±ç”µè„‘å¸¦çš„å‘½ä»¤è¡Œã€‚ä¸æ˜¯gitç»™çš„ã€‚ 4.ä¸Šä¼  ä¸Šå» ä¸€æ ·çš„æœ‰ä¸¤ç§æ“ä½œæˆ‘å°±ä¹‹è¯´ä¸€ç§ï¼Œå¦ä¸€ç§è‡ªå·±ç…§ç€ä¸Šé¢ä¸¤ç§è¿›è¡Œæ“ä½œã€‚ å…ˆè¿›è¡Œä¿®æ”¹ ä¿®æ”¹å è¿›å…¥å‘½ä»¤è¡Œ æ“ä½œ è½¬åˆ°ä»“åº“ä½ç½®ä¹Ÿå°±æ˜¯ä½ cloneå‡ºæ¥çš„æ–‡ä»¶å¤¹ã€‚è¿™ä¸ªæ˜¯cloneå‡ºæ¥çš„æ–‡ä»¶å¤¹ä½ç½®ï¼ˆæœ¬åœ°ä»“çš„ä½ç½®ï¼‰ï¼Œä¸æ˜¯cloneåˆ°çš„ä½ç½®ã€‚git add -A .git commit -m â€œå§“åâ€git push ç¬¬ä¸€æ¬¡push éœ€è¦ç™»é™† ï¼Œè¾“å…¥å¯†ç çš„æ—¶å€™ è¾“å…¥ä»€ä¹ˆéƒ½çœ‹ä¸è§ä¸ç”¨ç®¡ï¼Œä¹Ÿæœ‰å¯èƒ½å¼¹å‡ºä¸€ä¸ªçª—å£è®©ä½ ç™»é™†ã€‚ å‘Šè¯‰å¤§å®¶ä¸€ç§ç”¨GitHub Desktop è¿™ä¸ªä¸œè¥¿è¿›è¡Œç®€å•æ“ä½œï¼› ä¸‹è½½åœ°å€https://desktop.github.com ç„¶åå®‰è£…å¥½å°±è¡Œã€‚ å®‰è£…å¥½å ç›´æ¥ç™»é™†ï¼Œæ·»åŠ ä»“åº“ ç„¶åé€‰ä¸­ ä½ åŸæœ¬clone çš„æ–‡ä»¶å¤¹å°±å¯ä»¥äº†ï¼Œ å¦‚æœ ä½ æäº¤çš„æ˜¯è‡ªå·±çš„ï¼Œè¯·æ³¨æ„ é‚£ä¸ªåˆ†æ”¯è¦æäº¤å¯¹äº† // æ³¨æ„ç¬¬ä¸€æ¬¡æäº¤ è¦ç™»é™† ï¼Œç™»é™†çš„ç”¨æˆ·åæ˜¯é‚£ä¸ªä¸ªäººä¸»é¡µ åç§°ä¸‹é¢çš„é‚£å‡ ä¸ªè‹±æ–‡ã€‚ æäº¤Pull Request åˆ°ä»“åº“ ç„¶åå°±OKäº†ï¼Œè¿™æ ·å°±å¯ä»¥æ„‰å¿«çš„å’Œåˆ«äººä¸€èµ·åšé¡¹ç›®äº†]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018æ¹–å—å¤šæ ¡ç¬¬ä¸‰åœº]]></title>
    <url>%2F2018%2F04%2F16%2F2018%E6%B9%96%E5%8D%97%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%89%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[2018 ä¸­å—å¤šæ ¡ ç¬¬ä¸‰åœº A(2063): Good Versus Evil SubmitPage Summary TimeLimit: 5 Sec MemoryLimit: 512 Mb Submitted: 85 Solved: 15 Description Middle Earth is about to go to war. The forces of goodwill have many battles with the forces of evil. Different races will certainlybe involved. Each race has a certain â€˜worthâ€™ when battling against others. Onthe side of good we have the following races, with their associated worth: Hobbits - 1 Men - 2 Elves - 3 Dwarves - 3 Eagles - 4 Wizards - 10 On the side of evil we have: Orcs - 1 Men - 2 Wargs - 2 Goblins - 2 Uruk Hai - 3 Trolls - 5 Wizards - 11 Although weather, location, supplies and valor play apart in any battle, if you add up the worth of the side of good and compare itwith the worth of the side of evil, the side with the larger worth will tend towin. Thus, given the count of each of the races on the side of good, followedby the count of each of the races on the side of evil, determine which sidewins. Input The first line of input will contain an integer greaterthan 0 signifying the number of battles to process. Information for each battlewill consist of two lines of data as follows. First, there will be a linecontaining the count of each race on the side of good. Each entry will beseparated by a single space. The values will be ordered as follows: Hobbits,Men, Elves, Dwarves, Eagles, Wizards. The next line will contain the count ofeach race on the side of evil in the following order: Orcs, Men, Wargs, Goblins,Uruk Hai, Trolls, Wizards. All values are non-negative integers. The resultingsum of the worth for each side will not exceed the limit of a 32-bit integer. Output For each battle, print â€œBattleâ€ followed by a singlespace, followed by the battle number starting at 1, followed by a â€œ:â€, followedby a single space. Then print â€œGood triumphs over Evilâ€ if good wins. Printâ€œEvil eradicates all trace of Goodâ€ if evil wins. If there is a tie, then printâ€œNo victor on this battle fieldâ€. Sample Input 3 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 10 0 1 1 1 1 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 Sample Output Battle 1: Evileradicates all trace of Good Battle 2: Goodtriumphs over Evil Battle 3: Novictor on this battle field è¿™ç§ç®€å•é¢˜åªè¦çœ‹æ‡‚é¢˜å°±èƒ½å†™å‡ºæ¥ï¼Œé™¤äº†é¢˜é¢ä¸Šæ˜¯7ä¸ªæ•°çš„é‚£ä¸ª æƒå€¼ 11 å®é™…ä¸Šæ˜¯ 10ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; int a[]= &#123;1,2,3,3,4,10&#125;,b[]= &#123;1,2,2,2,3,5,10&#125;; long long n,x; long sum1,sum2; cin&gt;&gt;n; for(int j=1; j&lt;=n; j++) &#123; sum1=sum2=0; for(int i=0; i&lt;6; i++) &#123; cin&gt;&gt;x; sum1+=x*a[i]; &#125; for(int i=0; i&lt;7; i++) &#123; cin&gt;&gt;x; sum2+=x*b[i]; &#125; printf(&quot;Battle %d: &quot;,j); if(sum1&gt;sum2) &#123; cout&lt;&lt;&quot;Good triumphs over Evil\n&quot;; &#125; else if(sum1&lt;sum2) &#123; cout&lt;&lt;&quot;Evil eradicates all trace of Good\n&quot;; &#125; else &#123; cout&lt;&lt;&quot;No victor on this battle field\n&quot;; &#125; &#125; return 0;&#125; B(2064): Magic Multiple SubmitPage Summary TimeLimit: 5 Sec MemoryLimit: 512 Mb Submitted: 28 Solved: 18 Description The Elvish races of Middle Earth believed that certainnumbers were more significant than others. When using a particular quantity nof metal to forge a particular sword, they believed that sword would be mostpowerful if the thickness k were chosen according to the following rule: Givena nonnegative integer n, what is the smallest k such that the decimalrepresentations of the integers in the sequence: n, 2n, 3n, 4n, 5n, â€¦, kncontain all ten digits (0 through 9) at least once? Lord Elrond of Rivendell hascommissioned you with the task to develop an algorithm to find the optimalthickness (k) for any given quantity of metal (n). Input Input will consist of a single integer n per line. Theend of input will be signaled by end of file. The input integer will be between1 and 200,000,000, inclusive. Output The output will consist of a single integer per line,indicating the value of k needed such that every digit from 0 through 9 is seenat least once. Sample Input 1 10 123456789 3141592 Sample Output 10 9 3 5 ä¸€ä¸ªæ•°çš„1 åˆ° Kå€ä¸­ 0-9å…¨éƒ¨å‡ºç°è¿‡ï¼Œæš´åŠ›Kå€å°±è¡Œäº†ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int a[10];int l;void check(long long x)&#123; while(x&gt;0) &#123; if(a[x%10]==0) &#123; l++; a[x%10]=1; &#125; x/=10; &#125;&#125; int main()&#123; long long n; long sum1,sum2; while (cin&gt;&gt;n) &#123; l=0; memset(a,0,sizeof(a)); int i=1; for (; l!=10; i++) &#123; check(i*n); &#125; cout&lt;&lt;i-1&lt;&lt;endl; &#125; return 0;&#125; DescriptionSarumanâ€™s army of orcs andother dark minions continuously mine and harvest lumber out of the landsurrounding his mighty tower for N continuous days. On day number i, Sarumaneither chooses to spend resources on mining coal and harvesting more lumber, oron raising the level (i.e., height) of his tower. He levels up his tower by oneunit only on days where the binary representation of i contains a total numberof 1â€™s that is an exact multiple of 3. Assume that the initial level of histower on day 0 is zero. For example, Saruman will level up his tower on day 7(binary 111), next on day 11 (binary 1011) and then day 13, day 14, day 19, andso on. Saruman would like to forecast the level of his tower after N days. Canyou write a program to help? InputThe input file will containmultiple input test cases, each on a single line. Each test case consists of apositive integer N &lt; 1016, as described above. The input ends on end offile. OutputFor each test case, outputone line: â€œDay N: Level = Lâ€, where N is the input N, and L is the number oflevels after N days. Sample Input12 119 164 Sample Output1Day 2: Level = 0 1Day 19: Level = 5 1Day 64: Level = 21 è¿™ä¸€é¢˜å°±æ˜¯ä»2è¿›åˆ¶ ç¬¬ä¸€ä¸ªæ‰¾ï¼Œä¸€ä¸ªä¸ªå¾€ä¸‹æ‰¾ï¼Œæ‰¾å…¶ä¸­ 1 çš„ä¸ªæ•°æ˜¯3çš„å€æ•°å°±è¡Œäº†ã€‚ è¿˜æœ‰ä¸€ç§æœ¬èº«å°±æ˜¯ 3çš„å€æ•°è¦é¢å¤–åŠ ä¸€å‰é¢åªæ˜¯å¤„ç†æ‰€æœ‰æ¯”Nå°çš„æ•°ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int l;long long gcd(long long a,long long b)&#123; return (b==0)?a:gcd(b,a%b);&#125;long long C(long long n,long long m)&#123; long long x=1,y=1; if(n-m&lt;m)m=n-m; for(int i=0; i&lt;m; i++) &#123; x*=(n-i); y*=1+i; int t=gcd(x,y); x/=t; y/=t; &#125; return x/y;&#125; int main()&#123; int a[1000]; long long n,k,sum; while (cin&gt;&gt;n) &#123; sum=0; k=n; long long l=1,t=0; while(n&gt;0) &#123; a[l++]=(n&amp;1); n&gt;&gt;=1; &#125; for(int i=l-1; i&gt;0; i--) &#123; if(a[i]) //å¦‚æœå½“å‰ä½ä¸º1 &#123; for(int j=3; j-t&lt;=i-1;j+=3) //å½“å‰ä½æ•°å‡1,è¿˜èƒ½æ‰¾å‡ºæ˜¯3çš„å€æ•°ä¸ª 1 if(j-t&gt;=0)sum+=C(i-1,j-t); t++; &#125; &#125; if(t&gt;0&amp;&amp;t%3==0)sum+=1; //å¤„ç†æœ¬èº«å°±æ˜¯3çš„å€æ•°æƒ…å†µã€‚ printf(&quot;Day %lld: Level = %lld\n&quot;,k,sum); &#125; return 0;&#125; H(2070): Seating Chart SubmitPage Summary TimeLimit: 10 Sec MemoryLimit: 512 Mb Submitted: 41 Solved: 15 Description Bilboâ€™s birthday is coming up, and Frodo and Sam are incharge of all the party planning! They have invited all the hobbits of MiddleEarth to the party, and everyone will be sitting in a single row at anextremely long dining table. However, due to poor communication, Frodo and Samhave each independently put together a seating chart for all the hobbits at thedining table. Help Frodo and Sam find out how similar their seating charts areby counting the total number of distinct pairs of hobbits who appear indifferent orders in the two charts. Input The input filewill contain multiple test cases. Each test case begins with a single linecontaining an integer N(1â‰¤Nâ‰¤100,000)N(1â‰¤Nâ‰¤100,000)indicating thenumber of hobbits. The next two lines represent Frodoâ€™s and Samâ€™s seatingcharts, respectively. Each seating chart is specified as a single line of Nunique alphabetical strings; the set of strings in each line are guaranteed tobe identical. The end-of-input is denoted by a line containing the number 0. Output For each input test case, output a single integerdenoting, out of the N choose 2 distinct pairs of hobbits, how many pairsappear in different orders in Frodoâ€™s and Samâ€™s seating arrangements. Sample Input 3 Frodo Sam Bilbo Sam Frodo Bilbo 5 A B C D E B A D E C 0 Sample Output 1 3 è¿™ä¸€é¢˜å°±æ˜¯ä¸€é“æ±‚é€†åºæ•°ï¼Œé€†åºæ•°æ€ä¹ˆæ±‚å°±è‡ªå·±æ‰¾æ¨¡æ¿å§ï¼Œå¦å¤–è¿™ä¸ªé¢˜è¶…äº†int è¦ç”¨longlongã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;map&gt;using namespace std;const int maxn=1e6+5;int a[maxn];map&lt;string,int&gt;m;long long n=0;//å…¨å±€å˜é‡ï¼Œç”¨äºç»Ÿè®¡é€†åºå¯¹æ•°void merge(int a[],int first,int mid,intlast)&#123; int *temp = new int[last-first+1];//ä¸´æ—¶æ•°ç»„ï¼Œç”¨äºä¸´æ—¶å­˜æ”¾æ¯”è¾ƒåçš„æ•°å­— int i=first,j=mid+1,k=0; while(i&lt;=mid&amp;&amp;j&lt;=last)//éå†æ¯”è¾ƒå·¦å³ä¸¤ä¸ªéƒ¨åˆ† &#123; if(a[i]&lt;=a[j]) temp[k++] = a[i++]; //å·¦åŠéƒ¨åˆ†å…ƒç´ å°äºå³åŠéƒ¨åˆ†çš„å…ƒç´ ï¼Œå°†å·¦è¾¹è¯¥å…ƒç´ å­˜å…¥ä¸´æ—¶æ•°ç»„ else &#123; temp[k++] = a[j++]; n=n+(mid-i+1);//ç»Ÿè®¡å·¦åŠè¾¹èƒ½å’Œå³åŠè¾¹è¯¥å…ƒç´ æ„æˆçš„é€†åºå¯¹æ•° &#125; &#125; while(i&lt;=mid) temp[k++]=a[i++]; while(j&lt;=last) temp[k++]=a[j++]; for(i=0; i &lt; k; i++) a[first + i] = temp[i];//ä»ä¸´æ—¶æ•°ç»„å–å‡ºæ”¾å›åŸæ•°ç»„&#125;void mergesort(int a[],int first,int last)&#123; if(first &lt; last) &#123; int mid = (first+last)/2; mergesort(a,first,mid);//é€’å½’æ’åºå·¦åŠéƒ¨åˆ† mergesort(a,mid+1,last);//é€’å½’æ’åºå³åŠéƒ¨åˆ† merge(a,first,mid,last);//å°†å¤„ç†åçš„ä¸¤ä¸ªéƒ¨åˆ†åˆå¹¶ &#125;&#125;int main()&#123; int N; string k; while (cin&gt;&gt;N&amp;&amp;N) &#123; m.clear(); for(int i=0;i&lt;N;i++) &#123; cin&gt;&gt;k; m[k]=i; &#125; for(int i=0;i&lt;N;i++) &#123; cin&gt;&gt;k; a[i]=m[k]; &#125; mergesort(a,0,N-1); cout&lt;&lt;n&lt;&lt;endl; n=0; &#125; return 0;&#125; J(2072): Temple Build SubmitPage Summary TimeLimit: 10 Sec MemoryLimit: 512 Mb Submitted: 8 Solved: 1 Description The Dwarves of Middle Earth are renowned for theirdelving and smithy ability, but they are also master builders. During the timeof the dragons, the dwarves found that above ground the buildings that weremost resistant to attack were truncated square pyramids (a square pyramid thatdoes not go all the way up to a point, but instead has a flat square on top).The dwarves knew what the ideal building shape should be based on the heightthey wanted and the size of the square base at the top and bottom. Theytypically had three different sizes of cubic bricks with which to work. Theirgoal was to maximize the volume of such a building based on the followingrules: The building is constructed of layers; each layer is asingle square of bricks of a single size. No part of any brick may extend outfrom the ideal shape, either to the sides or at the top. The resultingstructure will have jagged sides and may be shorter than the ideal shape, butit must fit completely within the ideal design. The picture at the right is avertical cross section of one such tower. There is no limit on how many bricksof each type can be used. Input Each line of input will contain six entries, eachseparated by a single space. The entries represent the ideal temple height, thesize of the square base at the bottom, the size of the square base at the top(all three as non-negative integers less than or equal to one million), thenthree sizes of cubic bricks (all three as non-negative integers less than orequal to ten thousand). Input is terminated upon reaching end of file. Output For each line of input, output the maximum possiblevolume based on the given rules, one output per line. Sample Input 500000 800000300000 6931 11315 5000 Sample Output 160293750000000000 è¿™ä¸€é¢˜å°±æ˜¯ä¸€ä¸ªï¼Œdpï¼Œdp[0]=0.dp[i]=max(dp[i-a[j]]+V[a[j]])(0&lt;=j&lt;3); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt; using namespace std;const int maxn=1e7+5;long long dp[maxn];int main()&#123; long long h,d,t,a[3],ans; while(cin&gt;&gt;h&gt;&gt;d&gt;&gt;t&gt;&gt;a[0]&gt;&gt;a[1]&gt;&gt;a[2]) &#123; ans=0; memset(dp,-1,sizeof(dp)); dp[0]=0; for(int i=0;i&lt;=h;i++) &#123; if(dp[i]!=-1) &#123; for(int j=0;j&lt;3;j++) &#123; if(i+a[j]&lt;=h) &#123; doubleb=1.0*d-1.0*(i+a[j])/h*(d-t); int cnt=floor(b/a[j]); long longv=cnt*cnt*pow(a[j],3); if(dp[i+a[j]]==-1)dp[i+a[j]]=dp[i]+v; elsedp[i+a[j]]=max(dp[i+a[j]],dp[i]+v); // æˆ‘æ˜¯ä»ä¸€ä¸ªçŠ¶æ€è·³æ‰€æœ‰å®ƒå¯ä»¥è·³åˆ°çš„çŠ¶æ€ã€‚ ans=max(ans,dp[i+a[j]]); &#125; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; L(2074): Tongues SubmitPage Summary TimeLimit: 5 Sec MemoryLimit: 512 Mb Submitted: 44 Solved: 18 Description Gandalfâ€™s writings have long been available for study,but no one has yet figured out what language they are written in. Recently, dueto programming work by a hacker known only by the code name ROT13, it has beendiscovered that Gandalf used nothing but a simple letter substitution scheme,and further, that it is its own inverseâ€”the same operation scrambles themessage as unscrambles it. This operation is performed by replacing vowels inthe sequence (a i y e o u) with the vowel three advanced, cyclicly, whilepreserving case (i.e., lower or upper). Similarly, consonants are replaced fromthe sequence (b k x z n h d c w g p v j q t s r l m f) by advancing tenletters. So for instance the phrase One ring to rule them all. translates toIta dotf ni dyca nsaw ecc. The fascinating thing about this transformation isthat the resulting language yields pronounceable words. For this problem, youwill write code to translate Gandalfâ€™s manuscripts into plain text. Input The input file will contain multiple test cases. Eachtest case consists of a single line containing up to 100 characters,representing some text written by Gandalf. All characters will be plain ASCII,in the range space (32) to tilde (126), plus a newline terminating each line.The end of the input is denoted by the end-of-file. Output For each input test case, print its translation intoplaintext. The output should contain exactly the same number of lines andcharacters as the input. Sample Input Ita dotf ni dycansaw ecc. Sample Output One ring to rulethem all. å­—ç¬¦ä¸²æ›¿æ¢ï¼ŒXJBæš´åŠ›å°±è¡Œ,å°±æ˜¯è€—ç¥ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt; using namespace std;const int maxn=1e2+5;char s[maxn];int main()&#123;//b k x z n h d c w g //p v j q t s r l m f char c1[]=&#123;&quot;bkxznhdcwg&quot;&#125;; char c2[]=&#123;&quot;pvjqtsrlmf&quot;&#125;; char a[500]=&#123;0&#125;; for(int i=0;i&lt;strlen(c1);i++) &#123; a[c1[i]]=c2[i]; a[c1[i]-(&apos;a&apos;-&apos;A&apos;)]=c2[i]-(&apos;a&apos;-&apos;A&apos;); &#125; for(int i=0;i&lt;strlen(c1);i++) &#123; a[c2[i]]=c1[i]; a[c2[i]-(&apos;a&apos;-&apos;A&apos;)]=c1[i]-(&apos;a&apos;-&apos;A&apos;); &#125; strcpy(c1,&quot;aiy&quot;); strcpy(c2,&quot;eou&quot;); for(int i=0;i&lt;strlen(c1);i++) &#123; a[c1[i]]=c2[i]; a[c1[i]-(&apos;a&apos;-&apos;A&apos;)]=c2[i]-(&apos;a&apos;-&apos;A&apos;); &#125; for(int i=0;i&lt;strlen(c1);i++) &#123; a[c2[i]]=c1[i]; a[c2[i]-(&apos;a&apos;-&apos;A&apos;)]=c1[i]-(&apos;a&apos;-&apos;A&apos;); &#125; while(~scanf(&quot;%c&quot;,&amp;s[0])) &#123; int i=0; while(s[i++]!=&apos;\n&apos;) &#123; scanf(&quot;%c&quot;,&amp;s[i]); &#125; i=0; do &#123; if(a[s[i]]==0) &#123; printf(&quot;%c&quot;,s[i]); &#125; else printf(&quot;%c&quot;,a[s[i]]); &#125;while(s[i++]!=&apos;\n&apos;); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è´ªå¿ƒ]]></title>
    <url>%2F2018%2F03%2F17%2F%E8%B4%AA%E5%BF%83%2F</url>
    <content type="text"><![CDATA[Problem B: æ´—è¡£ Time Limit: 2 Sec Memory Limit: 128 MBSubmit: 148 Solved: 26 [Submit][Status][Web Board] Description durongæœ‰Nä»¶è¡£æœè¦æ´—ï¼Œ ä½†æ˜¯ä»–çš„ç¬¬iä»¶è¡£æœå¿…é¡»åœ¨[st, en) æ—¶é—´æ´—ï¼Œ åŒä¸€æ´—è¡£æœºä¸èƒ½åŒæ—¶æ´—å¤šä»¶è¡£æœï¼Œä»–æƒ³ï¼Œè¦æ´—å®ŒNä»¶è¡£æœï¼Œè‡³å°‘éœ€è¦å¤šå°‘ä¸ªæ´—è¡£æœºå‘¢ï¼Ÿ Input å¤šç»„è¾“å…¥ ç¬¬ä¸€è¡Œä¸€ä¸ªæ•´æ•°nï¼ˆn &lt;= 100000ï¼‰, ä»£è¡¨è¡£æœçš„ä¸ªæ•° æ¥ä¸‹æ¥nè¡Œ, æ¯è¡Œä¸¤ä¸ªæ•´æ•°st, enï¼ˆ1 &lt;= st &lt; en &lt;= 1000000000ï¼‰ï¼Œä»£è¡¨ç¬¬iä»¶è¡£æœåœ¨stå¼€å§‹æ´—ï¼Œenæ´—å®Œ Output è¾“å‡ºä¸€ä¸ªæ•´æ•°å’Œæ¢è¡Œç¬¦ï¼Œä»£è¡¨è‡³å°‘éœ€è¦çš„æ´—è¡£æœºä¸ªæ•° Sample Input1234 31 23 42 8 Sample Output12 è´ªå¿ƒï¼Œå…ˆæ’åºï¼Œç„¶ååˆ°ä¸€ä¸ªæ—¶é—´ç‚¹èƒ½åŠ å°±åŠ ï¼Œå¦‚æœè¿‡äº†ä¸€ä¸ªå‡å»ä¸€ä¸ªå°±è¡Œäº†ï¼Œæ¯æ¬¡è·³è·ƒä¸€ä»¶è¡£æœçš„æ—¶é—´é•¿åº¦å°±è¡Œäº†ï¼Œå¤æ‚åº¦åªæœ‰æ’åºçš„å¤æ‚åº¦NlogN #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;queue&gt; using namespace std; const int maxn=1e5+10; int n; int main() { ` int`st[maxn],en[maxn],sz,ez,ans,cou; ` while`( scanf ( &quot;%d&quot; ,&amp;n)!=EOF) ` {` ` for`( int i=0;i&lt;n;i++){ ` scanf`( &quot;%d%d&quot; ,&amp;st[i],&amp;en[i]); ` }` ` sort(st,st+n);` ` sort(en,en+n);` ` ans=cou=ez=0;` ` for`( int i=0;i&lt;n;i++) ` {` ` cou++;` ` while`(en[ez]&lt;=st[i]) ` {` ` ez++;` ` couâ€”;` ` }` ` if`(cou&gt;ans)ans=cou; ` }` ` printf`( &quot;%d\n&quot; ,ans); ` }` ` return`0; }]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æœ€å¤§ç”Ÿæˆæ ‘]]></title>
    <url>%2F2018%2F03%2F17%2F%E6%9C%80%E5%A4%A7%E7%94%9F%E6%88%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Problem A: ç¾åŒºé‡å»ºTime Limit: 3 Sec Memory Limit: 128 MBSubmit: 123 Solved: 32[Submit][Status][Web Board] Descriptionåœ¨ä¸€åœºåœ°éœ‡ä¹‹åï¼ŒåŸæœ¬ç¾ä¸½çš„Cå›½å˜æˆäº†ä¸€ç‰‡åºŸå¢Ÿï¼Œä½†æ˜¯è¿™å¹¶æ²¡æœ‰å‡»å®äººä»¬çš„æ„å¿—ï¼Œåœ¨å„æ–¹çš„æ”¯æŒä¸‹æ•‘æ´é˜Ÿé©¬ä¸Šå¼€å§‹äº†ç¾åŒºé‡å»ºã€‚å·²çŸ¥Cå›½ä¸€å…±ç”±Nä¸ªåŸå¸‚ï¼ˆç¼–å·ä»1~Nï¼‰ç»„æˆï¼Œåœ¨è¿™Nä¸ªåŸå¸‚ä¹‹é—´æœ‰Mæ¡é“è·¯è¿é€šç€å„ä¸ªåŸå¸‚ï¼Œç°åœ¨è¦å°†ç‰©èµ„è¿å¾€å„ä¸ªåŸå¸‚ï¼Œä½†æ˜¯æ¯æ¡é“è·¯éƒ½æœ‰å…¶æœ€å¤§æ‰¿é‡é‡Wï¼Œä¹Ÿå°±æ˜¯è¯´å¦‚æœä¸€è¾†è½¦æ‰€è¿è½½çš„è´§ç‰©é‡é‡å¤§äºWçš„è¯æ˜¯æ— æ³•é€šè¿‡è¿™æ¡è·¯çš„ã€‚ä¸ºäº†é˜²æ­¢é“è·¯å´©å¡ŒåŒæ—¶æé«˜æ•ˆç‡ï¼Œæˆ‘ä»¬éƒ½ä¼šå»èµ°æ‰¿é‡é‡å°½å¯èƒ½å¤§çš„é“è·¯ï¼Œç°åœ¨æ•‘æ´é˜Ÿçš„é˜Ÿé•¿æƒ³çŸ¥é“å¦‚æœè¦å°†è´§ç‰©ä»ä»»æ„ä¸€ä¸ªåŸå¸‚è¿å¾€å…¶ä»–N-1ä¸ªåŸå¸‚ï¼Œä¸€æ¬¡æ‰€èƒ½è¿è¾“çš„æœ€å¤§é‡é‡æ˜¯å¤šå°‘ï¼Œä½ èƒ½å‘Šè¯‰ä»–å—ï¼Ÿ Inputè¾“å…¥ç¬¬ä¸€è¡Œä¸ºä¸€ä¸ªæ•´æ•°T(T&lt;=10ï¼‰ï¼Œè¡¨ç¤ºæœ‰Tç»„æ ·ä¾‹ï¼› ç¬¬äºŒè¡Œä¸ºä¸¤ä¸ªæ•´æ•°N(N&lt;=10^5)å’ŒM(M&lt;=10^6)ï¼Œåˆ†åˆ«è¡¨ç¤ºåŸå¸‚çš„æ•°é‡å’Œé“è·¯çš„æ•°é‡ï¼› æ¥ä¸‹æ¥Mè¡Œæ¯è¡Œæœ‰ä¸‰ä¸ªæ•´æ•°,u,v,wï¼Œï¼ˆu,v&lt;=Nï¼Œw&lt;=10^9ï¼‰ è¡¨ç¤ºuå’Œvä¹‹é—´æœ‰ä¸€æ¡æ‰¿é‡é‡ä¸ºwçš„é“è·¯ï¼ˆé“è·¯æ˜¯åŒå‘çš„ï¼Œå³å¯ä»¥ä»uèµ°åˆ°vï¼Œä¹Ÿå¯ä»¥ä»vèµ°åˆ°uï¼ŒåŒæ—¶æ•°æ®ä¿è¯ä»»æ„ä¸¤ä¸ªåŸå¸‚ä¹‹é—´è‡³å¤šåªä¼šæœ‰ä¸€æ¡é“è·¯ï¼‰ã€‚ Outputæ¯ç»„æ ·ä¾‹è¾“å‡ºä¸€è¡Œ Case #X: Yï¼ŒXè¡¨ç¤ºç¬¬å‡ ç»„æ ·ä¾‹ï¼ŒYä¾¿æ˜¯æ‰€è¦æ±‚çš„ç­”æ¡ˆã€‚ Sample Input11 4 6 1 2 2 1 3 1 1 4 9 2 4 8 2 3 10 3 4 4 Sample Output1Case #1: 8 HINTæ ·ä¾‹è§£é‡Šï¼š å¦‚æœè¦å°†ç‰©èµ„ä»1è¿è¾“åˆ°2ï¼Œé‚£ä¹ˆèµ°1-4-2è¿™æ¡è·¯å¾„æ‰€å³èƒ½è¿è¾“çš„æœ€å¤§é‡é‡ä¸º8ï¼› å¦‚æœè¦å°†ç‰©èµ„ä»1è¿è¾“åˆ°3ï¼Œé‚£ä¹ˆèµ°1-4-2-3è¿™æ¡è·¯å¾„å³æ‰€èƒ½è¿è¾“çš„æœ€å¤§é‡é‡ä¸º8ï¼› å¦‚æœè¦å°†ç‰©èµ„ä»1è¿è¾“åˆ°4ï¼Œé‚£ä¹ˆèµ°1-4è¿™æ¡è·¯å¾„å³æ‰€èƒ½è¿è¾“çš„æœ€å¤§é‡é‡ä¸º9ï¼› å¦‚æœè¦å°†ç‰©èµ„ä»2è¿è¾“åˆ°3ï¼Œé‚£ä¹ˆèµ°2-3è¿™æ¡è·¯å¾„å³æ‰€èƒ½è¿è¾“çš„æœ€å¤§é‡é‡ä¸º10ï¼› å¦‚æœè¦å°†ç‰©èµ„ä»2è¿è¾“åˆ°4ï¼Œé‚£ä¹ˆèµ°2-4è¿™æ¡è·¯å¾„å³æ‰€èƒ½è¿è¾“çš„æœ€å¤§é‡é‡ä¸º8ï¼› å¦‚æœè¦å°†ç‰©èµ„ä»3è¿è¾“åˆ°4ï¼Œé‚£ä¹ˆèµ°3-2-4è¿™æ¡è·¯å¾„å³æ‰€èƒ½è¿è¾“çš„æœ€å¤§é‡é‡ä¸º8ï¼› æ•…ç­”æ¡ˆä¸º8ã€‚ å¾ˆè£¸çš„ä¸€é“æœ€å¤§ç”Ÿæˆæ ‘ï¼Œæ±‚æœ€å¤§ç”Ÿæˆæ ‘çš„æœ€å¤§æƒè¾¹ï¼Œæ³¨æ„è·³å‡ºå°±ä¸ä¼šè¶…æ—¶ã€‚ #include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;int t,n,m,i,j;using namespace std; struct s{` int`a,b,c;}k[1000005]; const int maxn=1000005; bool bmp(s a, s b){` return`a.c&gt;b.c;} int par[maxn];void init(){` for`( int i=0;i&lt;=n;i++){` par[i]=i;` }}int find( int x){` if`(par[x]==x) return x;` else`{` return`par[x]=find(par[x]);` }`}void unite( int x, int y){` x=find(x);` y=find(y);` if`(x==y) return ;` else`{` par[y]=x;` }} int main(){` scanf`( &quot;%d&quot; ,&amp;t);` for`(i=0;i&lt;t;i++)` {` scanf ( &quot;%d%d&quot; ,&amp;n,&amp;m);` init();` for (j=0;j&lt;m;j++)` scanf`( &quot;%d%d%d&quot; ,&amp;k[j].a,&amp;k[j].b,&amp;k[j].c);` sort(k,k+m,bmp);` int res=0,l=0;` for`(j=0;j&lt;m;j++)` {` if (find(k[j].a)!=find(k[j].b))` {` unite(k[j].a,k[j].b);` res=k[j].c;` if (++l==n-1) break ;` }` if (l==n-1) break ;` }` printf ( &quot;Case #%d: %d\n&quot; ,i+1,res);` }` return 0;}]]></content>
      <tags>
        <tag>CSDNè¿ç§»</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[简单做个实验分析一下 new/new[] 和 delete/delete[]]]></title>
    <url>%2F2020%2F03%2F14%2F%E7%AE%80%E5%8D%95%E5%81%9A%E4%B8%AA%E5%AE%9E%E9%AA%8C%E5%88%86%E6%9E%90%E4%B8%80%E4%B8%8B-new-new%5B%5D-%E5%92%8C-delete-delete%5B%5D%2F</url>
    <content type="text"><![CDATA[先来介绍下流程。 new/new[],他的流程是先开辟了一个空间，然后调用了构造函数。 delete/delete[]先调用析构函数，然后释放内存。 那么如果new/delete和new[]/deletep[]没有配对会出现什么问题。对于这个问题我做了简单的实验。 非基础类型也就是自己写的类。先说下结论 delete释放new[]只会调用第一个的析构函数，导致内存泄漏。 delete[]释放new会出bug。 测试如下123456789101112131415161718192021222324252627class A&#123; int a;public: A():a(0xffff)&#123; cout&lt;&lt;"A()\n"; &#125; ~A()&#123; cout&lt;&lt;"~A()\n"; &#125; virtual void func()&#123; cout&lt;&lt;"func\n"; &#125;&#125;;int main() &#123; A *b=new A[4]; delete [] b; b =new A(); delete b; b=new A[4]; delete b; A *a=new A(); delete[] a; return 0;&#125; 输出结果是123456789101112131415161718A()A()A()A()~A()~A()~A()~A()//4个析构A()~A()//一个析构A()A()A()A()~A()//一个析构A()Process finished with exit code -1073741819 (0xC0000005)//直接RE了 问题已经看出来，那么是为什呢。我们去看看内存。看到了吗，十分明显的一个数字，表示分配了多少个，后面很明显吧。一个虚函数指针，和一个值。然后执行下一行释放内存。看出内存的变化了吗，全部都释放掉了，前面那个4 也没了。执行到这，用new创建的明显没有一个表示多少个的。执行下一行然后没了被释放了。 执行后面错误的。看看用delele删除new[]。 执行完后，他们全部都在，我都怀疑内存到底有没有释放。很显然全部都还没有释放掉。 然后后面那个为啥会RE不用我说了吧。前面那个表述个数的数字这么大。。你想怎么搞。。。 小问题1不要慌对于这个实验，如果把虚函数删掉，就不会是内存错误而是一个非常大的循环。至于为什么自己思考。 结论：用new参数的非基础类型，只会开辟一个对象内存空间，new[]还会保存一个数组大小。delete[]删除的时候会根据 删除地址前面的4个字节表示的数字大小来删除后面的对象。 为了保证正确性，我来做个有意思的事，我们来手写一个new[]。12345678910111213141516171819202122232425class A&#123; int a;public: A():a(0xffff)&#123; cout&lt;&lt;"A()\n"; &#125; ~A()&#123; cout&lt;&lt;"~A()\n"; &#125; virtual void func()&#123; cout&lt;&lt;"func\n"; &#125;&#125;;int main() &#123; void *p=::operator new(sizeof(A)*4+sizeof(int));//这个可以用malloc来是一样的结果。 int *size=(int *)p; *size=4;//这个设置一下大小 A *a=(A *)(size+1);//这个就是new[] 的实现 new(a)A(); new(a+1)A(); new(a+2)A(); new(a+3)A(); delete[] a;//显然这个是释放 return 0;&#125; 理论上delete []也能手写实现，具体怎么实现读者自己动手操作，切忌拿来主义。 基本类型对于基本类型和非基本类型有什么区别呢？？？，emmmm好像没啥区别。但是他确实不一样。1234567891011121314int main() &#123; int *b=new int[4]&#123;0xfff,0xffff,0xfff,0xfff&#125;; delete [] b; b =new int(); delete b; b=new int[4]&#123;0xfff,0xffff,0xfff,0xfff&#125;; delete b; int *a=new int(); delete[] a; return 0;&#125; 运行这个你会发现，没有任何问题！！！！，确实就是，没有任何问题。为什么会这样???。我们照着前面那个的来。看到了吗，没有那个表示数组长度的东西了。delete之后内存变了。 后面的自己看，你会发现，用delet删除new[]完全没问题。。。delet[]删除new,好像也没啥问题。 那么问题来了，他们是怎么知道要释放多少内存的。这个就比较复杂了。他和free是一个性质，内存分配是交给操作系统完成的，具体怎么操作的还是和内核有关。应该也能很清楚的看见，每次释放内存，改变的不仅仅是你需要的的内存大小，而是一整块内存。所以用delete/delete[]释放内存的时候，实际上是直接把那一块内存释放了。 结论:对于基础类型，用delete/delete[]删除实际上是一样的,主要原因应该还是因为，他没有调用构造和析构的必要。如果一个类里面封装了一个指针，然后new了一个对象，如果不调用析构函数，就会出现内存泄漏。]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 对象布局]]></title>
    <url>%2F2020%2F02%2F18%2FC%2B%2B-%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[关于C++对象布局 看了大佬的博客,大佬的博客过于久远格式比较清奇，我整理了，顺便改了程序能够在 64位机运行。 单一的一般继承通俗的讲，一层层下去。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;using namespace std;class Parent&#123;public: long iparent;//因为是64位机，所以改成了 long Parent() : iparent(10) &#123;&#125; virtual void f() &#123; cout &lt;&lt; " Parent::f()" &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; " Parent::g()" &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; " Parent::h()" &lt;&lt; endl; &#125;&#125;;class Child : public Parent&#123;public: long ichild; Child() : ichild(100) &#123;&#125; virtual void f() &#123; cout &lt;&lt; "Child::f()" &lt;&lt; endl; &#125; virtual void g_child() &#123; cout &lt;&lt; "Child::g_child()" &lt;&lt; endl; &#125; virtual void h_child() &#123; cout &lt;&lt; "Child::h_child()" &lt;&lt; endl; &#125;&#125;;class GrandChild : public Child&#123;public: long igrandchild; GrandChild() : igrandchild(1000) &#123;&#125; virtual void f() &#123; cout &lt;&lt; "GrandChild::f()" &lt;&lt; endl; &#125; virtual void g_child() &#123; cout &lt;&lt; "GrandChild::g_child()" &lt;&lt; endl; &#125; virtual void h_grandchild() &#123; cout &lt;&lt; "GrandChild::h_grandchild()" &lt;&lt; endl; &#125;&#125;;typedef void (*Fun)(void);int main()&#123; GrandChild gc; long **pVtab = (long **)&amp;gc; Fun pFun; cout &lt;&lt; "[0] GrandChild::_vptr-&gt;" &lt;&lt; endl; for (int i = 0; (Fun)pVtab[0][i] != NULL; i += 2) &#123; pFun = (Fun)pVtab[0][i]; cout &lt;&lt; " [" &lt;&lt; i &lt;&lt; "] "; pFun(); &#125; printf("start offet:%llx\n", pVtab); cout &lt;&lt; "[1] Parent.iparent = " &lt;&lt; (long)((pVtab[1])) &lt;&lt; endl; cout &lt;&lt; "[2] Child.ichild = " &lt;&lt; (long)(pVtab[2]) &lt;&lt; endl; cout &lt;&lt; "[3] GrandChild.igrandchild = " &lt;&lt; (long)(pVtab[3]) &lt;&lt; endl;&#125; 输出结果12345678[0] GrandChild::_vptr-&gt; [0] GrandChild::f() [2] Parent::h() [4] Child::h_child()start offet:7ffee4956f80[1] Parent.iparent = 10[2] Child.ichild = 100[3] GrandChild.igrandchild = 1000 顺便我们用gdb 看一下。12345678910111213141516171819202122GNU gdb (Debian 7.12-6) 7.12.0.20161007-gitlist40 &#123;41 pFun = (Fun)pVtab[0][i];42 cout &lt;&lt; " [" &lt;&lt; i &lt;&lt; "] ";43 pFun();44 &#125;45 printf("start offet:%llx\n", pVtab);46 cout &lt;&lt; "[1] Parent.iparent = " &lt;&lt; (long)((pVtab[1])) &lt;&lt; endl;47 cout &lt;&lt; "[2] Child.ichild = " &lt;&lt; (long)(pVtab[2]) &lt;&lt; endl;48 cout &lt;&lt; "[3] GrandChild.igrandchild = " &lt;&lt; (long)(pVtab[3]) &lt;&lt; endl;49 &#125;p pVtab$1 = (long **) 0x7fffffffcb90x /10xg 0x7fffffffcb900x7fffffffcb90: 0x0000555555755ce0(你可以继续找下去可以找到具体函数地址) 0x000000000000000a(10)0x7fffffffcba0: 0x0000000000000064(100) 0x00000000000003e8(1000)0x7fffffffcbb0: 0x000000000000008e 0x000055555555509a0x7fffffffcbc0: 0x00007fffffffcb90 0x0000000655554bf00x7fffffffcbd0: 0x00007fffffffccc0 0x0000000000000000 多重继承12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;iostream&gt;using namespace std;class Base1&#123;public: long ibase1; Base1() : ibase1(0x10) &#123;&#125; virtual void f() &#123; cout &lt;&lt; "Base1::f()" &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; "Base1::g()" &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; "Base1::h()" &lt;&lt; endl; &#125;&#125;;class Base2&#123;public: long ibase2; Base2() : ibase2(0x20) &#123;&#125; virtual void f() &#123; cout &lt;&lt; "Base2::f()" &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; "Base2::g()" &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; "Base2::h()" &lt;&lt; endl; &#125;&#125;;class Base3&#123;public: long ibase3; Base3() : ibase3(0x30) &#123;&#125; virtual void f() &#123; cout &lt;&lt; "Base3::f()" &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; "Base3::g()" &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; "Base3::h()" &lt;&lt; endl; &#125;&#125;;class Derive : public Base1, public Base2, public Base3&#123;public: long iderive; Derive() : iderive(0x100) &#123;&#125; virtual void f() &#123; cout &lt;&lt; "Derive::f()" &lt;&lt; endl; &#125; virtual void g1() &#123; cout &lt;&lt; "Derive::g1()" &lt;&lt; endl; &#125;&#125;;typedef void (*Fun)(void);int main()&#123; Derive d; long **pVtab = (long **)&amp;d; Fun pFun; cout&lt;&lt;hex; cout &lt;&lt; "[0] Base1::_vptr-&gt;" &lt;&lt; endl; pFun = (Fun)pVtab[0][0]; cout &lt;&lt; " [0] "; pFun(); pFun = (Fun)pVtab[0][1]; cout &lt;&lt; " [1] "; pFun(); pFun = (Fun)pVtab[0][2]; cout &lt;&lt; " [2] "; pFun(); pFun = (Fun)pVtab[0][3]; cout &lt;&lt; " [3] "; pFun(); pFun = (Fun)pVtab[0][4]; cout &lt;&lt; " [4] "; cout &lt;&lt; pFun &lt;&lt; endl; cout &lt;&lt; "[1] Base1.ibase1 = " &lt;&lt; (long)(pVtab[1]) &lt;&lt; endl; long s = sizeof(Base1) / 8; cout &lt;&lt; "[" &lt;&lt; s &lt;&lt; "] Base2::_vptr-&gt;" &lt;&lt; endl; pFun = (Fun)pVtab[s][0]; cout &lt;&lt; " [0] "; pFun(); cout &lt;&lt; " [1] "; pFun=(Fun)pVtab[s][1]; pFun(); pFun = (Fun)pVtab[s][2]; cout &lt;&lt; " [2] "; pFun(); pFun = (Fun)pVtab[s][3]; cout &lt;&lt; " [3] "; cout &lt;&lt; pFun &lt;&lt; endl; cout &lt;&lt; "[" &lt;&lt; s + 1 &lt;&lt; "] Base2.ibase2 = " &lt;&lt; (long)(pVtab[s + 1]) &lt;&lt; endl; s = s + sizeof(Base2) / 8; cout &lt;&lt; "[" &lt;&lt; s &lt;&lt; "] Base3::_vptr-&gt;" &lt;&lt; endl; pFun = (Fun)pVtab[s][0]; cout &lt;&lt; " [0] "; pFun(); pFun = (Fun)pVtab[s][1]; cout &lt;&lt; " [1] "; pFun(); pFun = (Fun)pVtab[s][2]; cout &lt;&lt; " [2] "; pFun(); pFun = (Fun)pVtab[s][3]; cout &lt;&lt; " [3] "; cout &lt;&lt; pFun &lt;&lt; endl; s++; cout &lt;&lt; "[" &lt;&lt; s &lt;&lt; "] Base3.ibase3 = " &lt;&lt; (long)pVtab[s] &lt;&lt; endl; s++; cout &lt;&lt; "[" &lt;&lt; s &lt;&lt; "] Derive.iderive = " &lt;&lt; (long)pVtab[s] &lt;&lt; endl;&#125; 运行结果1234567891011121314151617181920[0] Base1::_vptr-&gt; [0] Derive::f() [1] Base1::g() [2] Base1::h() [3] Derive::g1() [4] 1//这个表示最后一个[1] Base1.ibase1 = 10[2] Base2::_vptr-&gt; [0] Derive::f() [1] Base2::g() [2] Base2::h() [3] 1[3] Base2.ibase2 = 20[4] Base3::_vptr-&gt; [0] Derive::f() [1] Base3::g() [2] Base3::h() [3] 0[5] Base3.ibase3 = 30[6] Derive.iderive = 100 用GDB看看1234567891011121314151617181920212223-exec p pVtab$1 = (long **) 0x7fffffffcb80-exec x /10xg 0x7fffffffcb800x7fffffffcb80: 0x0000555555756c50 0x00000000000000100x7fffffffcb90: 0x0000555555756c80 0x00000000000000200x7fffffffcba0: 0x0000555555756ca8 0x00000000000000300x7fffffffcbb0: 0x0000000000000100 0x00000000000000000x7fffffffcbc0: 0x000055555555583e 0x00007fffffffcb80-exec x /10xg 0x0000555555756c500x555555756c50 &lt;_ZTV6Derive+16&gt;: 0x000055555555583e 0x00005555555555be0x555555756c60 &lt;_ZTV6Derive+32&gt;: 0x00005555555555f6 0x00005555555558820x555555756c70 &lt;_ZTV6Derive+48&gt;: 0xfffffffffffffff0 0x0000555555756d380x555555756c80 &lt;_ZTV6Derive+64&gt;: 0x000055555555587b 0x000055555555568c0x555555756c90 &lt;_ZTV6Derive+80&gt;: 0x00005555555556c4 0xffffffffffffffe0-exec x /10xg 0x000055555555583e (不知道为啥其他查看其他几个虚表，和这个值不一样，但是也指向这个函数)0x55555555583e &lt;Derive::f()&gt;: 0x10ec8348e5894855 0x57358d48f87d89480x55555555584e &lt;Derive::f()+16&gt;: 0x18083d8d48000001 0x48fffff453e800200x55555555585e &lt;Derive::f()+32&gt;: 0x201791058b48c289 0xe8d78948c68948000x55555555586e &lt;Derive::f()+48&gt;: 0x48c3c990fffff45e 0xef8348c3eb20ef830x55555555587e &lt;_ZThn16_N6Derive1fEv+3&gt;: 0xe589485590bdeb10 0xf87d894810ec8348 重复继承123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;iostream&gt;using namespace std;class B&#123;public: long ib; char cb;public: B() : ib(0), cb('B') &#123; &#125; virtual void f() &#123; cout &lt;&lt; "B::f()" &lt;&lt; endl; &#125; virtual void Bf() &#123; cout &lt;&lt; "B::Bf()" &lt;&lt; endl; &#125;&#125;;class B1 : public B&#123;public: long ib1; char cb1;public: B1() : ib1(11), cb1('1') &#123; &#125; virtual void f() &#123; cout &lt;&lt; "B1::f()" &lt;&lt; endl; &#125; virtual void f1() &#123; cout &lt;&lt; "B1::f1()" &lt;&lt; endl; &#125; virtual void Bf1() &#123; cout &lt;&lt; "B1::Bf1()" &lt;&lt; endl; &#125;&#125;;class B2 : public B&#123;public: long ib2; char cb2;public: B2() : ib2(12), cb2('2') &#123; &#125; virtual void f() &#123; cout &lt;&lt; "B2::f()" &lt;&lt; endl; &#125; virtual void f2() &#123; cout &lt;&lt; "B2::f2()" &lt;&lt; endl; &#125; virtual void Bf2() &#123; cout &lt;&lt; "B2::Bf2()" &lt;&lt; endl; &#125;&#125;;class D : public B1, public B2&#123;public: long id; char cd;public: D() : id(100), cd('D') &#123; &#125; virtual void f() &#123; cout &lt;&lt; "D::f()" &lt;&lt; endl; &#125; virtual void f1() &#123; cout &lt;&lt; "D::f1()" &lt;&lt; endl; &#125; virtual void f2() &#123; cout &lt;&lt; "D::f2()" &lt;&lt; endl; &#125; virtual void Df() &#123; cout &lt;&lt; "D::Df()" &lt;&lt; endl; &#125;&#125;;typedef void (*Fun)(void);int main()&#123; long **pVtab = NULL; Fun pFun = NULL; D d; pVtab = (long **)&amp;d; cout &lt;&lt; "[0] D::B1::_vptr-&gt;" &lt;&lt; endl; pFun = (Fun)pVtab[0][0]; cout &lt;&lt; " [0] "; pFun(); pFun = (Fun)pVtab[0][1]; cout &lt;&lt; " [1] "; pFun(); pFun = (Fun)pVtab[0][2]; cout &lt;&lt; " [2] "; pFun(); pFun = (Fun)pVtab[0][3]; cout &lt;&lt; " [3] "; pFun(); pFun = (Fun)pVtab[0][4]; cout &lt;&lt; " [4] "; pFun(); pFun = (Fun)pVtab[0][5]; cout &lt;&lt; " [5] 0x" &lt;&lt; pFun &lt;&lt; endl; cout &lt;&lt; "[1] B::ib = " &lt;&lt; (long)pVtab[1] &lt;&lt; endl; cout &lt;&lt; "[2] B::cb = " &lt;&lt; static_cast&lt;char&gt;((long)(pVtab[2])) &lt;&lt; endl; cout &lt;&lt; "[3] B1::ib1 = " &lt;&lt; (long)pVtab[3] &lt;&lt; endl; cout &lt;&lt; "[4] B1::cb1 = " &lt;&lt; (static_cast&lt;char&gt;((long)(pVtab[4]))) &lt;&lt; endl; cout &lt;&lt; "[5] D::B2::_vptr-&gt;" &lt;&lt; endl; pFun = (Fun)pVtab[5][0]; cout &lt;&lt; " [0] "; pFun(); pFun = (Fun)pVtab[5][1]; cout &lt;&lt; " [1] "; pFun(); pFun = (Fun)pVtab[5][2]; cout &lt;&lt; " [2] "; pFun(); pFun = (Fun)pVtab[5][3]; cout &lt;&lt; " [3] "; pFun(); pFun = (Fun)pVtab[5][4]; cout &lt;&lt; " [4] 0x" &lt;&lt; pFun &lt;&lt; endl; cout &lt;&lt; "[6] B::ib = " &lt;&lt; (long)pVtab[6] &lt;&lt; endl; cout &lt;&lt; "[7] B::cb = " &lt;&lt; (static_cast&lt;char&gt;((long)pVtab[7])) &lt;&lt; endl; cout &lt;&lt; "[8] B2::ib2 = " &lt;&lt; (long)pVtab[8] &lt;&lt; endl; cout &lt;&lt; "[9] B2::cb2 = " &lt;&lt; (static_cast&lt;char&gt;((long)pVtab[9])) &lt;&lt; endl; cout &lt;&lt; "[10] D::id = " &lt;&lt; (long)pVtab[10] &lt;&lt; endl; cout &lt;&lt; "[11] D::cd = " &lt;&lt; (static_cast&lt;char&gt;((long)pVtab[11])) &lt;&lt; endl;&#125; 输出结果1234567891011121314151617181920212223[0] D::B1::_vptr-&gt; [0] D::f() [1] B::Bf() [2] D::f1() [3] B1::Bf1() [4] D::f2() [5] 0x1[1] B::ib = 0[2] B::cb = B[3] B1::ib1 = 11[4] B1::cb1 = 1[5] D::B2::_vptr-&gt; [0] D::f() [1] B::Bf() [2] D::f2() [3] B2::Bf2() [4] 0x0[6] B::ib = 0[7] B::cb = B[8] B2::ib2 = 12[9] B2::cb2 = 2[10] D::id = 100[11] D::cd = D GDB调试 1234567x /12x 0x7fffffffcb600x7fffffffcb60: 0x0000555555756c58 0x00000000000001230x7fffffffcb70: 0x0000555555756c55 0x00000000000001110x7fffffffcb80: 0x0000000000000011 0x0000555555756c980x7fffffffcb90: 0x0000000000000123 0x00005555555555550x7fffffffcba0: 0x0000000000000212 0x0000555555555a220x7fffffffcbb0: 0x0000000000000100 0x0000000000000033 虚拟继承大佬偷懒了，那我们完了啊。 对于这个虚拟继承，和64位机好像有点不一样，我也不知道为啥。如果有人看懂了回来私信我（留个言也行）。告诉我为啥。 我贴一个自己的实验。不保证正确性。]]></content>
      <categories>
        <category>计算机语言</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 虚拟继承对象布局]]></title>
    <url>%2F2020%2F02%2F18%2FC%2B%2B-%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[自己做实验的时候发现和一些文章上面的有点不一样。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;using namespace std;class B&#123;public: long ib; long cb;//全都定义成 long 这个方便看内存，不然不是对齐的public: B() :ib(0x1010), cb(0x1010) &#123;&#125; virtual void f() &#123; cout &lt;&lt; "B::f()" &lt;&lt; endl; &#125; virtual void Bf() &#123; cout &lt;&lt; "B::Bf()" &lt;&lt; endl; &#125;&#125;;class B1 : virtual public B&#123;public: long ib1; long cb1;public: B1() :ib1(0x1111111), cb1(0x1111) &#123;&#125; //virtual void f() &#123; cout &lt;&lt; "B1::f()" &lt;&lt; endl; &#125; //为什么要注释掉呢，后面说，不注释掉是失败的 是运行不了的 virtual void f1() &#123; cout &lt;&lt; "B1::f1()" &lt;&lt; endl; &#125; virtual void Bf1() &#123; cout &lt;&lt; "B1::Bf1()" &lt;&lt; endl; &#125;&#125;;int main()&#123; typedef void(*Fun)(void); long long** pVtab = NULL; Fun pFun = NULL; B1 bb1; cout&lt;&lt;hex; pVtab = (long long**)&amp;bb1; cout&lt;&lt;"offset:"&lt;&lt;(long)pVtab-(long)(B*)&amp;bb1&lt;&lt;endl;//因为存在偏移 (B*)&amp;bb1 是不等于 &amp;bb1 这个地址的。 cout &lt;&lt; "[0] B1::_vptr-&gt;" &lt;&lt; endl; for(int i=0;(Fun) pVtab[0][i]!=NULL;i++)&#123; cout&lt;&lt;"\t["&lt;&lt;i&lt;&lt;"]\t"; pFun=(Fun)pVtab[0][i]; pFun(); &#125; cout &lt;&lt; "[2] B1::ib1 = "; cout &lt;&lt; (long)pVtab[1]&lt;&lt; endl; //B1::ib1 cout &lt;&lt; "[3] B1::cb1 = "; cout &lt;&lt; (long)pVtab[2] &lt;&lt; endl; //B1::cb1 cout &lt;&lt; "[3] B::_vptr-&gt;" &lt;&lt; endl; for(int i=0;i&lt;2;i++)&#123; //就是这个地方，如果前面不注释掉就会报错 //还有你没有没有注意到细节 ，我这个地方写的是 &lt;2 并不是 函数为 空？ cout&lt;&lt;"\t["&lt;&lt;i&lt;&lt;"]\t"; pFun=(Fun)(pVtab[3][i]); pFun(); &#125; cout &lt;&lt; "[4] B::ib1 = "; cout &lt;&lt; (long)pVtab[4]&lt;&lt; endl; //B1::ib1 cout &lt;&lt; "[5] B::cb1 = "; cout &lt;&lt; (long)*(pVtab+5) &lt;&lt; endl; //B1::cb1 return 0;&#125; 输出结果1234567891011offset:ffffffffffffffe8[0] B1::_vptr-&gt; [0] B1::f1() [1] B1::Bf1()[2] B1::ib1 = 1111111[3] B1::cb1 = 1111[3] B::_vptr-&gt; [0] B::f() [1] B::Bf()[4] B::ib1 = 1010[5] B::cb1 = 1010 GDB 调试 查看内存，有意思的来了。12345678(gdb) p pVtab$1 = (long long **) 0x7ffdf9b52fc0 //一个B1对象的具体内存(gdb) x /10xg 0x7ffdf9b52fc00x7ffdf9b52fc0: 0x0000562080dd6d08(这个是第一个虚表指针) 0x00000000011111110x7ffdf9b52fd0: 0x0000000000001111 0x0000562080dd6d38(第二个虚表指针）0x7ffdf9b52fe0: 0x0000000000001010 0x00000000000010100x7ffdf9b52ff0: 0x0000562080bd61c0 0x0000562080bd617e0x7ffdf9b53000: 0x00007ffdf9b52fc0 0x0000000200000000 有的文章里面说，虚拟继承每个基类会创建一个虚表，实际上并没有，只是多了一个虚表指针并没有那么多神奇的玩意。你可以发现两个地址挨着非常近。我们查看 0x0000562080dd6d08这个的内存。123456gdb) x /10xg 0x0000562080dd6d080x562080dd6d08 &lt;vtable for B1+24&gt;: 0x0000562080bd6146 0x0000562080bd617e0x562080dd6d18 &lt;vtable for B1+40&gt;: 0x0000000000000000 0x00000000000000000x562080dd6d28 &lt;vtable for B1+56&gt;: 0xffffffffffffffe8 0x0000562080dd6d780x562080dd6d38 &lt;vtable for B1+72&gt;: 0x0000562080bd607e（第二个虚表指针在这???） 0x0000562080bd60b60x562080dd6d48 &lt;VTT for B1&gt;: 0x0000562080dd6d08(有没有发现这个地址就是第一个虚表指针，并没有NULL，所以我那个地方写的是i&lt;2) 0x0000562080dd6d38 看到了吗，实际上全都在B1的虚表里面，只是指针指向的位置不一样。还有个更有意思的。有没有发现有两个0x0000000000000000目前不知道是啥。0xffffffffffffffe8这个刚好就是偏移量，并没有什么指针直接指向他。所以我不知道虚基表指针是啥，也没看到一个指针算进对象的空间。 然后再继续看这两个虚表指针的内容。12345678910111213(gdb) x /10xg 0x0000562080bd6146 //不出意外是个函数0x562080bd6146 &lt;B1::f1()&gt;: 0x10ec8348e5894855 0xfb358d48f87d89480x562080bd6156 &lt;B1::f1()+16&gt;: 0x0f003d8d48000000 0x48fffff97be800200x562080bd6166 &lt;B1::f1()+32&gt;: 0x200e89058b48c289 0xe8d78948c68948000x562080bd6176 &lt;B1::f1()+48&gt;: 0x90c3c990fffff976 0x10ec8348e58948550x562080bd6186 &lt;B1::Bf1()+8&gt;: 0xcc358d48f87d8948 0x0ec83d8d48000000(gdb) x /10xg 0x0000562080bd607e //第二个指针也是0x562080bd607e &lt;B::f()&gt;: 0x10ec8348e5894855 0xb4358d48f87d89480x562080bd608e &lt;B::f()+16&gt;: 0x0fc83d8d48000001 0x48fffffa43e800200x562080bd609e &lt;B::f()+32&gt;: 0x200f51058b48c289 0xe8d78948c68948000x562080bd60ae &lt;B::f()+48&gt;: 0x90c3c990fffffa3e 0x10ec8348e58948550x562080bd60be &lt;B::Bf()+8&gt;: 0x83358d48f87d8948 0x0f903d8d48000001 然后就是更有意思的。记得我们原本注释的吗，我们把他取消注释再来GDB调试。123(gdb) x /10xg 0x000055aec160519d //因为重新运行了地址不一样，我们像那样看第二个虚指针第一项的值0x55aec160519d &lt;virtual thunk to B1::f()&gt;: 0xebe87a0349178b4c 0xec8348e5894855c0//看到了 virtual thunk ，这个告诉我们这个已经被重写了，然后又会调用B1::f() 是不是发现这个布局很像这种写法。123class B&#123; A a;&#125; 当然只是有点像，到了菱形继承就差距很大了。我们继续探索。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;using namespace std;#include &lt;iostream&gt;using namespace std;class B&#123;public: long ib;public: B() : ib(0xbbbbb) &#123;&#125; virtual void f() &#123; cout &lt;&lt; "B::f()" &lt;&lt; endl; &#125; virtual void Bf() &#123; cout &lt;&lt; "B::Bf()" &lt;&lt; endl; &#125;&#125;;class B1 : virtual public B&#123;public: long ib1;public: B1() : ib1(0x1111) &#123; &#125; virtual void f()&#123;cout &lt;&lt; "B1::f()" &lt;&lt; endl;&#125; virtual void f1() &#123; cout &lt;&lt; "B1::f1()" &lt;&lt; endl; &#125; virtual void Bf1() &#123; cout &lt;&lt; "B1::Bf1()" &lt;&lt; endl; &#125;&#125;;class B2 : virtual public B&#123;public: long ib2;public: B2() : ib2(0x2222) &#123; &#125;// virtual void f()&#123;cout &lt;&lt; "B2::f()" &lt;&lt; endl;&#125; virtual void f2() &#123; cout &lt;&lt; "B2::f2()" &lt;&lt; endl; &#125; virtual void Bf2() &#123; cout &lt;&lt; "B2::Bf2()" &lt;&lt; endl; &#125;&#125;;class D : public B1, public B2&#123;public: long id;public: D() : id(0xdddd) &#123; &#125; virtual void f() &#123; cout &lt;&lt; "D::f()" &lt;&lt; endl; &#125; virtual void f1() &#123; cout &lt;&lt; "D::f1()" &lt;&lt; endl; &#125; virtual void f2() &#123; cout &lt;&lt; "D::f2()" &lt;&lt; endl; &#125; virtual void Df() &#123; cout &lt;&lt; "D::Df()" &lt;&lt; endl; &#125;&#125;;int main()&#123; typedef void(*Fun)(void); long long** pVtab = NULL; Fun pFun = NULL; D d; cout&lt;&lt;"D size:"&lt;&lt;sizeof(d)&lt;&lt;endl; cout&lt;&lt;"B1 size:"&lt;&lt;sizeof(B1)&lt;&lt;endl; cout&lt;&lt;"D address:"&lt;&lt;&amp;d&lt;&lt;endl; cout&lt;&lt;"B1 address:"&lt;&lt;(B1*)&amp;d&lt;&lt;endl; cout&lt;&lt;"B1-B2 offset:"&lt;&lt;(long)(B1*)&amp;d-(long)(B2*)&amp;d&lt;&lt;endl; cout&lt;&lt;"B2-B offset:"&lt;&lt;(long)(B2*)&amp;d-(long)(B*)&amp;d&lt;&lt;endl; cout&lt;&lt;"B address:"&lt;&lt;(B*)&amp;d&lt;&lt;endl; pVtab = (long long**)&amp;d; cout&lt;&lt;hex; cout &lt;&lt; "[0] B1::_vptr-&gt;" &lt;&lt; endl; for(int i=0;i&lt;5;i++)&#123; cout&lt;&lt;"\t["&lt;&lt;i&lt;&lt;"]\t"; pFun=(Fun)pVtab[0][i]; pFun(); &#125; cout &lt;&lt; "[1] B1::ib1 = "; cout &lt;&lt; (long)pVtab[1]&lt;&lt; endl; cout &lt;&lt; "[2] B2::_vptr-&gt;" &lt;&lt; endl; for(int i=0;i&lt;2;i++)&#123; cout&lt;&lt;"\t["&lt;&lt;i&lt;&lt;"]\t"; pFun=(Fun)pVtab[2][i]; pFun(); &#125; cout &lt;&lt; "[3] B2::ib2 = "; cout &lt;&lt; (long)pVtab[3]&lt;&lt; endl; cout &lt;&lt; "[4] B::ib = "; cout &lt;&lt; (long)pVtab[4]&lt;&lt; endl; cout &lt;&lt; "[5] B::_vptr-&gt;" &lt;&lt; endl; for(int i=1;i&lt;2;i++)&#123; cout&lt;&lt;"\t["&lt;&lt;i&lt;&lt;"]\t"; pFun=(Fun)pVtab[5][i]; pFun(); &#125; cout &lt;&lt; "[6] B::ib = "; cout &lt;&lt; (long)pVtab[6]&lt;&lt; endl; return 0;&#125; 运行结果12345678910111213141516171819202122D size:56B1 size:32D address:0x7fff13a26610B1 address:0x7fff13a26610B1-B2 offset:-16B2-B offset:-24B address:0x7fff13a26638[0] B1::_vptr-&gt; [0] D::f() [1] D::f1() [2] B1::Bf1() [3] D::f2() [4] D::Df()[1] B1::ib1 = 1111[2] B2::_vptr-&gt; [0] D::f2() [1] B2::Bf2()[3] B2::ib2 = 2222[4] B::ib = dddd[5] B::_vptr-&gt; [1] B::Bf()[6] B::ib = bbbbb GDB查看内存。123456(gdb) x /10xg pVtab0x7ffc64cadc10: 0x000055c32e665b88(B1的虚指针) 0x00000000000011110x7ffc64cadc20: 0x000055c32e665bc8（B2的虚指针） 0x00000000000022220x7ffc64cadc30: 0x000000000000dddd（D的数据） 0x000055c32e665bf8(B的虚指针)0x7ffc64cadc40: 0x00000000000bbbbb 0x00000000000000000x7ffc64cadc50: 0x0000000000000000 0x00007ffc64cadc10 看到这应该都清楚了。显然B布局到了最后面。大概就是因为这个所以才能实现只有一份拷贝吧。具体详细分析，自己进去看吧，就是把东西结合起来。为了方便查看偏移量 我GDB 调试 10进制1234567891011121314151617181920212223242526(gdb) x /10g pVtab0x7ffd2687ea70: 94162329979784 43690x7ffd2687ea80: 94162329979848 87380x7ffd2687ea90: 56797 941623299798960x7ffd2687eaa0: 768955 00x7ffd2687eab0: 0 140725249895024(gdb) x /10dg 941623299797840x55a3e03acb88 &lt;vtable for D+24&gt;: 94162327877818 941623278778820x55a3e03acb98 &lt;vtable for D+40&gt;: 94162327877436 941623278779380x55a3e03acba8 &lt;vtable for D+56&gt;: 94162327878000 24（不知道具体怎么排列的，但是知道有就行了）0x55a3e03acbb8 &lt;vtable for D+72&gt;: -16 941623299801840x55a3e03acbc8 &lt;vtable for D+88&gt;: 94162327877993 94162327877624(gdb) x /10dg 941623299798480x55a3e03acbc8 &lt;vtable for D+88&gt;: 94162327877993 941623278776240x55a3e03acbd8 &lt;vtable for D+104&gt;: 0 -400x55a3e03acbe8 &lt;vtable for D+120&gt;: -40 941623299801840x55a3e03acbf8 &lt;vtable for D+136&gt;: 94162327877873 941623278771840x55a3e03acc08 &lt;VTT for D&gt;: 94162329979784 94162329979992(gdb) x /10dg 941623299798960x55a3e03acbf8 &lt;vtable for D+136&gt;: 94162327877873 941623278771840x55a3e03acc08 &lt;VTT for D&gt;: 94162329979784 941623299799920x55a3e03acc18 &lt;VTT for D+16&gt;: 94162329980048 941623299800880x55a3e03acc28 &lt;VTT for D+32&gt;: 94162329980136 941623299798960x55a3e03acc38 &lt;VTT for D+48&gt;: 94162329979848 40 看了好多博客，都搞不懂，自己做出来的和他们有点不一样。结论你们自己得吧，告辞。]]></content>
      <categories>
        <category>计算机语言</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT6.828(六)Lab6:Network Driver(default final project)]]></title>
    <url>%2F2020%2F02%2F18%2FMIT-6.828-(%E5%85%AD)-Lab-6-Network-Driver-(default-final-project)%2F</url>
    <content type="text"><![CDATA[这是最后一个实验，做完这个一个基本的内核就做完了。这章需要自己去看的东西特么的多，所以大部分，我们就看看实现了什么，不会专门一个个细节的看了。 Lab 6: Network Driver (default final project)IntroductionLab6 是最后一个实验了，做完这个，一个简单的内核就已经实现了，现在你可以自己做自己的内核。现在，你有一个文件系统，操作系统没有网络堆栈。在这个实验室里你要编写一个网络接口卡的驱动程序。该卡将基于Intel 82540EM芯片，也被称为E1000上。 Getting Started先切换个分支。 除了编写驱动程序之外，您还需要创建一个系统调用接口来授予对驱动程序的访问权限。您将实现缺少的网络服务器代码，以在网络堆栈和驱动程序之间传输数据包。您还将通过完成Web服务器将所有内容捆绑在一起。使用新的Web服务器，您将能够从文件系统提供文件。 您必须从头开始编写许多内核设备驱动程序代码。与以前的实验相比，本实验提供的指导要少得多：没有框架文件，没有任何固定的系统调用接口，许多设计决策都由您自己决定。因此，我们建议您在开始任何练习之前，先阅读整个作业记录。许多学生发现本实验比以前的实验困难得多，因此请相应地计划您的时间。最终你会发现这个主要难点就是看文档写驱动。根据他的推荐让我们先看看整个任务，直接用谷歌流浪器，翻译整个页面，然后大致看看。 看完之后发现并没有什么卵用，还是不懂，还是慢慢来。 QEMU’s virtual network我们将使用QEMU的用户模式网络堆栈，因为它不需要运行任何管理权限。QEMU的文档在这里有更多关于user-net的信息。我们已经更新了makefile，以启用QEMU的用户模式网络堆栈和虚拟E1000网卡。 默认情况下，QEMU提供运行在IP 10.0.2.2上的虚拟路由器，并将为JOS分配IP地址10.0.2.15。为了简单起见，我们将这些默认值硬编码到net/ns.h中的网络服务器中。我们简单看一下这个文件12345678910111213141516171819202122#include &lt;inc/ns.h&gt;#include &lt;inc/lib.h&gt;#define IP "10.0.2.15" //IP#define MASK "255.255.255.0" //ZIYANMA#define DEFAULT "10.0.2.2" //这是个虚拟路由#define TIMER_INTERVAL 250 //应该是时间中断时间// Virtual address at which to receive page mappings containing client requests.//在这个虚拟地址接收 包含客户端请求的 页面映射。#define QUEUE_SIZE 20#define REQVA (0x0ffff000 - QUEUE_SIZE * PGSIZE)/* timer.c */ void timer(envid_t ns_envid, uint32_t initial_to);/* input.c */ /*这两个函数是我们的目标，就是为了实现这两个函数*/void input(envid_t ns_envid);/* output.c */void output(envid_t ns_envid); 尽管QEMU的虚拟网络允许JOS进行到Internet的任意连接，但JOS的10.0.2.15地址在QEMU内部运行的虚拟网络外部没有任何意义（即QEMU充当NAT），因此我们无法直接连接到服务器即使在运行QEMU的主机中，也可以在JOS内部运行。为了解决这个问题，我们将QEMU配置为在主机上某个端口上运行服务器，该服务器仅连接到JOS中的某个端口，并在真实主机和虚拟网络之间来回穿梭数据。 您将在端口7（回显）和80（http）上运行JOS服务器。为避免在共享的Athena机器上发生冲突，makefile会根据您的用户ID为这些机器生成转发端口。要查找QEMU将要转发到您的开发主机上的端口，请运行make which-ports。为了方便起见，makefile还提供make nc-7和make nc-80，使您可以直接与在终端中这些端口上运行的服务器进行交互。（这些目标仅连接到正在运行的QEMU实例；您必须单独启动QEMU本身。）通俗点来讲，就是 这个JOS服务器用的是 7 和80端口，但是你的虚拟机上面可能已经用了，所以帮你转发到另一个端口了。 Packet Inspection生成文件还配置QEMU的网络堆栈，以将所有传入和传出数据包记录到您的实验室目录中的qemu.pcap。 要获取捕获的数据包的hex/ASCII，请使用tcpdump，如下所示：tcpdump -XXnr qemu.pcap或者，您可以使用Wireshark以图形方式检查pcap文件。Wireshark还知道如何解码和检查数百种网络协议。如果您使用的是Athena，则必须使用Wireshark的前身ethereal，它位于sipbnet locker。 Debugging the E1000我们很幸运能够使用仿真硬件。由于E1000在软件中运行，因此仿真的E1000可以以用户可读的格式向我们报告其内部状态以及遇到的任何问题。通常，使用裸机编写驱动程序的开发人员将无法获得这种奢侈。 E1000可以产生很多调试输出，因此您必须启用特定的日志记录通道。您可能会发现有用的一些渠道是： FlagMeaning tx 日志包发送操作 txerr记录传输环错误 rx将更改记录到RCTL rxfilter传入数据包的日志过滤 rxerr日志接收振铃错误 unknown日志读取和写入未知寄存器 eeprom从EEPROM读取日志 interrupt记录中断和更改到中断寄存器。 例如，要启用tx和txerr日志记录，请使用make E1000_DEBUG=tx,txerr ...。 注意： E1000_DEBUG标志仅在6.828版本的QEMU中起作用。 您可以进一步使用软件仿真的硬件进行调试。如果您陷入困境并且不了解E1000为什么没有按预期方式做出响应，则可以在hw/net/e1000.c中查看QEMU的E1000实现。 The Network Server从头开始编写网络堆栈是一项艰巨的工作。相反，我们将使用lwIP，这是一个开源的轻量级TCP/IP协议套件，其中包括一个网络堆栈。您可以在此处找到有关lwIP的更多信息 。就此而言，就我们而言，lwIP是一个黑箱，它实现了BSD套接字接口，并具有一个数据包输入端口和一个数据包输出端口。 网络服务器实际上是四个环境的组合： 核心网络服务器环境（包括套接字调用分派器和lwIP） 输入环境 输出环境 计时器环境 下图显示了不同的环境及其关系。该图显示了包括设备驱动程序在内的整个系统，稍后将进行介绍。在本实验中，您将实现以绿色突出显示的部分。这个地方已经告诉你我们要实现什么了 实现E1000驱动里面的TX 用于传输数据,RX用于发送数据。 实现发送环境和输出环境，时钟环境已经帮我们实现好了，我们后面会去看看 http 服务器，这些事具体应用服务器了。The Core Network Server Environment核心网络服务器环境由套接字调用分派器和lwIP本身组成。套接字调用调度程序的工作方式与文件服务器完全相同。用户环境使用存根（可在lib/nsipc.c中找到）将IPC消息发送到核心网络环境。如果查看 lib/nsipc.c，您会发现我们找到核心网络服务器的方式与找到文件服务器的方式相同：i386_init使用NS_TYPE_NS创建NS环境，因此我们扫描envs，寻找这种特殊的环境类型。对于每个用户环境IPC，网络服务器中的调度程序代表用户调用lwIP提供的相应BSD套接字接口功能。我们来简单看看这些东西。大部分都是一样的，我们就看看就行。123456789101112131415161718192021222324252627282930313233343536373839404142434445// Virtual address at which to receive page mappings containing client requests.#define REQVA 0x0ffff000union Nsipc nsipcbuf __attribute__((aligned(PGSIZE)));// Send an IP request to the network server, and wait for a reply.// The request body should be in nsipcbuf, and parts of the response// may be written back to nsipcbuf.// type: request code, passed as the simple integer IPC value.// Returns 0 if successful, &lt; 0 on failure.static intnsipc(unsigned type) //和 文件发送一模一样，自己看看&#123; static envid_t nsenv; if (nsenv == 0) nsenv = ipc_find_env(ENV_TYPE_NS); static_assert(sizeof(nsipcbuf) == PGSIZE); if (debug) cprintf("[%08x] nsipc %d\n", thisenv-&gt;env_id, type); ipc_send(nsenv, type, &amp;nsipcbuf, PTE_P|PTE_W|PTE_U); return ipc_recv(NULL, NULL, NULL);&#125;/*struct sockaddr &#123; u8_t sa_len; u8_t sa_family; char sa_data[14];&#125;;*/intnsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen) //接受函数&#123; int r; nsipcbuf.accept.req_s = s; nsipcbuf.accept.req_addrlen = *addrlen; if ((r = nsipc(NSREQ_ACCEPT)) &gt;= 0) &#123; struct Nsret_accept *ret = &amp;nsipcbuf.acceptRet; memmove(addr, &amp;ret-&gt;ret_addr, ret-&gt;ret_addrlen); *addrlen = ret-&gt;ret_addrlen; &#125; return r;&#125; 再看看init.c，多了这么几行，看架势是创建了一个网络服务器。1234#if !defined(TEST_NO_NS) // Start ns. ENV_CREATE(net_ns, ENV_TYPE_NS);#endif 不出意外我们在net/serv.c成功找到了umian12345678910111213141516171819202122232425262728293031323334353637383940414243voidumain(int argc, char **argv)&#123; envid_t ns_envid = sys_getenvid(); binaryname = "ns"; // fork off the timer thread which will send us periodic messages timer_envid = fork();//创建定时器 if (timer_envid &lt; 0) panic("error forking"); else if (timer_envid == 0) &#123; timer(ns_envid, TIMER_INTERVAL); return; &#125; // fork off the input thread which will poll the NIC driver for input // packets input_envid = fork();//输入环境 if (input_envid &lt; 0) panic("error forking"); else if (input_envid == 0) &#123; input(ns_envid); return; &#125; // fork off the output thread that will send the packets to the NIC // driver output_envid = fork();//输出环境 if (output_envid &lt; 0) panic("error forking"); else if (output_envid == 0) &#123; output(ns_envid); return; &#125; // lwIP requires a user threading library; start the library and jump // into a thread to continue initialization. thread_init();//线程初始化 //做实现开始之前回来好好分析一下 thread_create(0, "main", tmain, 0);//线程创建 thread_yield();//线程调度？？？ // never coming here!&#125; 常规用户环境不会nsipc_*直接使用呼叫。相反，它们使用lib/ sockets.c中的函数，该函数提供了基于文件描述符的套接字API。因此，用户环境通过文件描述符引用套接字，就像它们引用磁盘文件一样。多个操作（connect，accept等）特定于插座，但是read，write和 close经过在正常文件描述符设备分派代码lib/fd.c。就像文件服务器为所有打开的文件维护内部唯一ID的方式一样，lwIP还会为所有打开的套接字生成唯一的ID。在文件服务器和网络服务器中，我们都使用存储在其中的信息将struct Fd每个环境的文件描述符映射到这些唯一的ID空间。 我们去看看lib/sockets.c和前面的文件服务调用的接口也是一样的。 即使文件服务器和网络服务器的IPC调度程序看起来似乎相同，也存在关键区别。BSD套接字调用like accept和recv可以无限期阻塞。如果调度程序要让lwIP执行这些阻塞调用之一，则调度程序也将阻塞，并且整个系统一次只能有一个未完成的网络调用。由于这是不可接受的，因此网络服务器使用用户级线程来避免阻塞整个服务器环境。对于每个传入的IPC消息，调度程序都会创建一个线程并在新创建的线程中处理请求。如果线程阻塞，则只有该线程进入睡眠状态，而其他线程继续运行。 除了核心网络环境外，还有三个帮助程序环境。除了接受来自用户应用程序的消息外，核心网络环境的调度程序还接受来自输入和计时器环境的消息。核心服务器环境，本质上就是一个文件服务器，他负责和高层的数据交换，比如说，http要用socket.c,就调用socket.c里面的一个操作，然后进行转发传到输入/输出环境,他在在E1000来进行硬件操作。 The Output Environment为用户环境套接字调用提供服务时，lwIP将生成数据包供网卡传输。LwIP将使用NSREQ_OUTPUTIPC消息将每个要发送的数据包发送到输出帮助程序环境，并将该数据包附加在IPC消息的page参数中。输出环境负责接受这些消息，并通过即将创建的系统调用接口将数据包转发到设备驱动程序。 The Input Environment网卡收到的数据包需要注入lwIP。对于设备驱动程序收到的每个数据包，输入环境（使用您将实现的内核系统调用）将数据包拉出内核空间，然后使用NSREQ_INPUTIPC消息将数据包发送到核心服务器环境。 数据包输入功能与核心网络环境分开，因为JOS使其难以同时接受IPC消息以及轮询或等待来自设备驱动程序的数据包。我们select 在JOS中没有系统调用，该调用允许环境监视多个输入源以标识准备好处理哪些输入。 如果你看看net/input.c和net/output.c你会看到，都需要执行。这主要是因为实现取决于您的系统调用接口。在实现驱动程序和系统调用接口之后，将为两个帮助程序环境编写代码。 The Timer Environment计时器环境会定期向NSREQ_TIMER核心网络服务器发送消息类型，通知其计时器已过期。lwIP使用此线程的计时器消息来实现各种网络超时。 通过这些我们大致知道这个网络的流程了，实际上核心服务器和文件服务器是一模一样的，让我们再做一次实际上也就是把上次的代码在看一遍。至于输出环境，输入环境和时钟环境，就是让我们实现的东西。 前置代码分析到这个地方，我们已经知道了基本的结构，但是我们还是对代码没啥了解。所以我们来看看多的代码做了什么。一如既往，一切的起点，肯定init,前面我们已经看过一点了。12345678// Lab 6 hardware initialization functions//多了这些东西，看注释事硬件初始化time_init(); //这个后面第一个实验就会讲是什么，是给内核添加时钟的概念用的pci_init(); //这个是 PCI初始化，也就是搜索所有 用PCI连接的硬件#if !defined(TEST_NO_NS) // Start ns. ENV_CREATE(net_ns, ENV_TYPE_NS);//这个说过了就是核心环境启动，而且通过这个fork 除了 输入/输出/时钟环境#endif 我们知道这些之后，我们再去看看net里面的东西.我靠一进去看里面的lwip目录，我靠那么多东西，看个鬼，告辞。我们还是继续看看serv.c,这个input.c和output.c,是输入输出，后面主要要做的。一开始我们已经看了一部分，我们直接看看这个线程。123thread_init();thread_create(0, "main", tmain, 0);thread_yield(); 1234567891011121314151617181920212223242526272829303132333435//lwpic/jos/thread.cvoidthread_init(void) &#123; threadq_init(&amp;thread_queue);//进去看这个函数 max_tid = 0;&#125;//lwpic/jos/threadq.hstatic inline void threadq_init(struct thread_queue *tq)&#123; tq-&gt;tq_first = 0; tq-&gt;tq_last = 0;&#125;struct thread_context;//一个这个表示一个进程struct thread_queue //一个线程池，或许应该叫线程队列&#123; struct thread_context *tq_first; struct thread_context *tq_last;&#125;;struct thread_context &#123; //线程结构题 也就是TCB thread_id_t tc_tid; //线程ID void *tc_stack_bottom;//线程栈 char tc_name[name_size];//线程名 void (*tc_entry)(uint32_t);//线程指令地址 ，实现过线程这个很好理解 uint32_t tc_arg;//参数 struct jos_jmp_buf tc_jb;//这个可以简单理解为 保存CPU的内容 volatile uint32_t *tc_wait_addr; volatile char tc_wakeup; void (*tc_onhalt[THREAD_NUM_ONHALT])(thread_id_t); int tc_nonhalt; struct thread_context *tc_queue_link;&#125;; 然后我们运行了线程创建1234567891011121314151617181920212223242526272829303132333435intthread_create(thread_id_t *tid, const char *name, void (*entry)(uint32_t), uint32_t arg) &#123; struct thread_context *tc = malloc(sizeof(struct thread_context));//分配一个空间 if (!tc) return -E_NO_MEM; memset(tc, 0, sizeof(struct thread_context)); thread_set_name(tc, name);//这个不用多说了 tc-&gt;tc_tid = alloc_tid();//自己看 tc-&gt;tc_stack_bottom = malloc(stack_size);//每个线程应该有独立的栈，但是一个进程的线程内存是共享的，因为共用一个页表。 很明显的能够看出来，TCB没有页表，所以内存都是共享的，所以理论上来说，是可以跨线程访问栈的。 if (!tc-&gt;tc_stack_bottom) &#123; free(tc); return -E_NO_MEM; &#125; void *stacktop = tc-&gt;tc_stack_bottom + stack_size; // Terminate stack unwinding stacktop = stacktop - 4; memset(stacktop, 0, 4); memset(&amp;tc-&gt;tc_jb, 0, sizeof(tc-&gt;tc_jb)); tc-&gt;tc_jb.jb_esp = (uint32_t)stacktop;//初始化栈顶 tc-&gt;tc_jb.jb_eip = (uint32_t)&amp;thread_entry;//初始化入口，函数指针 tc-&gt;tc_entry = entry; tc-&gt;tc_arg = arg;//参数 threadq_push(&amp;thread_queue, tc);//加入线程队列 if (tid) *tid = tc-&gt;tc_tid; return 0;&#125; 然后调用了线程调度1234567891011121314151617voidthread_yield(void) &#123; struct thread_context *next_tc = threadq_pop(&amp;thread_queue);//弹出了一个线程 if (!next_tc) return; if (cur_tc) &#123; if (jos_setjmp(&amp;cur_tc-&gt;tc_jb) != 0) return; threadq_push(&amp;thread_queue, cur_tc);//保存当前线程 &#125; cur_tc = next_tc; jos_longjmp(&amp;cur_tc-&gt;tc_jb, 1);//将下一个线程对应的thread_context结构的tc_jb字段恢复到CPU继续执行&#125;//所以从这个地方就跑去了运行线程main函数了。 1234567static voidtmain(uint32_t arg) &#123; serve_init(inet_addr(IP), inet_addr(MASK), inet_addr(DEFAULT));//初始化了一点东西 serve();//然后就是这个服务了&#125; serve()里面主要是和另外两个环境通信。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748voidserve(void) &#123; int32_t reqno; uint32_t whom; int i, perm; void *va; while (1) &#123; // ipc_recv will block the entire process, so we flush // all pending work from other threads. We limit the // number of yields in case there's a rogue thread. for (i = 0; thread_wakeups_pending() &amp;&amp; i &lt; 32; ++i) thread_yield(); perm = 0; va = get_buffer(); reqno = ipc_recv((int32_t *) &amp;whom, (void *) va, &amp;perm);//在这个地方进行通信 if (debug) &#123; cprintf("ns req %d from %08x\n", reqno, whom); &#125; // first take care of requests that do not contain an argument page if (reqno == NSREQ_TIMER) &#123;//这个就是如果通信来自时钟 process_timer(whom); put_buffer(va); continue; &#125; // All remaining requests must contain an argument page if (!(perm &amp; PTE_P)) &#123; cprintf("Invalid request from %08x: no argument page\n", whom); continue; // just leave it hanging... &#125; // Since some lwIP socket calls will block, create a thread and // process the rest of the request in the thread. struct st_args *args = malloc(sizeof(struct st_args)); if (!args) panic("could not allocate thread args structure"); args-&gt;reqno = reqno; args-&gt;whom = whom; args-&gt;req = va; thread_create(0, "serve_thread", serve_thread, (uint32_t)args);//给他创建一个线程去处理。 thread_yield(); // let the thread created run &#125;&#125; 在serve()经历了一大堆，最终处理事件的函数是serve_thread了,可以在里面明确的看出是啥。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970static voidserve_thread(uint32_t a) &#123; struct st_args *args = (struct st_args *)a; union Nsipc *req = args-&gt;req; int r; switch (args-&gt;reqno) &#123; case NSREQ_ACCEPT: &#123; struct Nsret_accept ret; ret.ret_addrlen = req-&gt;accept.req_addrlen; r = lwip_accept(req-&gt;accept.req_s, &amp;ret.ret_addr, &amp;ret.ret_addrlen); memmove(req, &amp;ret, sizeof ret); break; &#125; case NSREQ_BIND: r = lwip_bind(req-&gt;bind.req_s, &amp;req-&gt;bind.req_name, req-&gt;bind.req_namelen); break; case NSREQ_SHUTDOWN: r = lwip_shutdown(req-&gt;shutdown.req_s, req-&gt;shutdown.req_how); break; case NSREQ_CLOSE: r = lwip_close(req-&gt;close.req_s); break; case NSREQ_CONNECT: r = lwip_connect(req-&gt;connect.req_s, &amp;req-&gt;connect.req_name, req-&gt;connect.req_namelen); break; case NSREQ_LISTEN: r = lwip_listen(req-&gt;listen.req_s, req-&gt;listen.req_backlog); break; case NSREQ_RECV: // Note that we read the request fields before we // overwrite it with the response data. r = lwip_recv(req-&gt;recv.req_s, req-&gt;recvRet.ret_buf, req-&gt;recv.req_len, req-&gt;recv.req_flags); break; case NSREQ_SEND: r = lwip_send(req-&gt;send.req_s, &amp;req-&gt;send.req_buf, req-&gt;send.req_size, req-&gt;send.req_flags); break; case NSREQ_SOCKET: r = lwip_socket(req-&gt;socket.req_domain, req-&gt;socket.req_type, req-&gt;socket.req_protocol); break; case NSREQ_INPUT: jif_input(&amp;nif, (void *)&amp;req-&gt;pkt); r = 0; break; default: cprintf("Invalid request code %d from %08x\n", args-&gt;whom, args-&gt;req); r = -E_INVAL; break; &#125; if (r == -1) &#123; char buf[100]; snprintf(buf, sizeof buf, "ns req type %d", args-&gt;reqno); perror(buf); &#125; if (args-&gt;reqno != NSREQ_INPUT) ipc_send(args-&gt;whom, r, 0, 0); put_buffer(args-&gt;req); sys_page_unmap(0, (void*) args-&gt;req); free(args);&#125; 然后就从其中调用了lwip的一些函数,这个里面有一个socket.c和lib/socket.c有点不一样，也不知道有啥区别，个人觉得是lib/socket.c是系统里面的调用给用户用的这个文件里面的应该是进行底层调用的。具体就不分析了，有兴趣的自己去看看。 其他三个环境后面再看。 Part A: Initialization and transmitting packets您的内核没有时间概念，因此我们需要添加它。当前，硬件每10毫秒产生一次时钟中断。在每个时钟中断处，我们都可以增加一个变量以指示时间提前了10ms。这是在kern/ time.c中实现的，但尚未完全集成到您的内核中。不着急做实验，我们先去看看kern/ time.c1234567891011121314151617181920212223242526#include &lt;kern/time.h&gt;#include &lt;inc/assert.h&gt;static unsigned int ticks;voidtime_init(void)//初始化时钟&#123; ticks = 0;&#125;// This should be called once per timer interrupt. A timer interrupt// fires every 10 ms.voidtime_tick(void)//时间增加&#123; ticks++; if (ticks * 10 &lt; ticks) panic("time_tick: time overflowed");&#125;unsigned inttime_msec(void)&#123; return ticks * 10;//返回时间&#125; 看了这个练习1就简单了。练习1就是让我们把他加入内核。我们已经在内核里面初始化了，现在我们需要时钟跳动。那么什么时候时钟增加呢。我们已经实现了时钟中断，所以我们在这个时候调用就行了。另外一个添加一个系统调用获取时钟就行了。1234567891011121314151617181920 case IRQ_OFFSET + IRQ_TIMER:&#123; lapic_eoi(); time_tick();//时钟中断 时钟增加 sched_yield(); break; &#125; // Return the current time.static intsys_time_msec(void)//获取时钟&#123; // LAB 6: Your code here. //panic("sys_time_msec not implemented"); return time_msec();&#125;//这个绝对不要完了再syscall()里面添加 case SYS_time_msec: return sys_time_msec(); 我们现在可以实现是时钟环境，我们去看看net/time.c12345678910111213141516171819202122232425262728293031#include "ns.h"voidtimer(envid_t ns_envid, uint32_t initial_to) &#123; int r; uint32_t stop = sys_time_msec() + initial_to; binaryname = "ns_timer"; while (1) &#123; while((r = sys_time_msec()) &lt; stop &amp;&amp; r &gt;= 0) &#123;//没到到时间 sys_yield(); &#125; if (r &lt; 0) panic("sys_time_msec: %e", r); ipc_send(ns_envid, NSREQ_TIMER, 0, 0);//到了时钟就给核心服务程序发了一个信息 while (1) &#123; uint32_t to, whom; to = ipc_recv((int32_t *) &amp;whom, 0, 0); if (whom != ns_envid) &#123; cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom); continue; &#125; stop = sys_time_msec() + to;//时钟改变 break; &#125; &#125;&#125; The Network Interface Card编写驱动程序需要深入了解硬件和提供给软件的接口。该实验文本将提供有关如何与E1000进行交互的高级概述，但是您在编写驱动程序时需要充分利用Intel的手册。练习2让我门看看手册。因为是全英文的又不能翻译所以没看。后面告诉我们需要什么我们去看什么。 后面才是真的魔鬼。 PCI InterfaceE1000是PCI设备，这意味着它已插入主板上的PCI总线。PCI总线具有地址，数据和中断线，并允许CPU与PCI设备进行通信，并且PCI设备可以读写存储器。在使用PCI设备之前，需要先对其进行发现和初始化。发现是遍历PCI总线以查找连接的设备的过程。初始化是分配I/O和内存空间以及协商设备要使用的IRQ线的过程。 我们在kern/pci.c中为您提供了PCI代码。要在引导过程中执行PCI初始化，PCI代码将遍历PCI总线以查找设备。找到设备后，它将读取其供应商ID和设备ID，并将这两个值用作搜索pci_attach_vendor阵列的键。该数组由以下struct pci_driver条目组成 ：1234struct pci_driver &#123; uint32_t key1, key2; int (*attachfn) (struct pci_func *pcif);&#125;; 如果发现的设备的供应商ID和设备ID与阵列中的条目匹配，则PCI代码将调用该条目的attachfn来执行设备初始化。（设备也可以通过类来标识，这是kern/pci.c中其他驱动程序表的作用。） Attach函数通过PCI函数进行初始化。尽管E1000仅提供一种功能，但PCI卡可以提供多种功能。这是我们在JOS中表示PCI功能的方式：12345678910111213struct pci_func &#123; struct pci_bus *bus; uint32_t dev; uint32_t func; uint32_t dev_id; uint32_t dev_class; uint32_t reg_base[6]; uint32_t reg_size[6]; uint8_t irq_line;&#125;; 以上结构反映了开发人员手册第4.1节表4-1中的某些条目。(大家可以去看看)后三个条目 struct pci_func对我们特别有意义，因为它们记录了设备的协商内存，I/O和中断资源。在reg_base与reg_size阵列包含多达六个基地址寄存器或条信息。reg_base存储用于内存映射的I/O区域（或用于I/O端口资源的基本I/O端口）的基本内存地址， reg_size包含来自的相应基本值的字节大小或I/O端口数reg_base，并irq_line包含分配给设备的IRQ线路用于中断。E1000 BAR的具体含义在表4-2的后半部分给出。 调用设备的附加功能时，已找到该设备但尚未启用。这意味着PCI代码尚未确定分配给设备的资源，例如地址空间和IRQ线，因此该struct pci_func结构的最后三个元素尚未填写。attach函数应调用 pci_func_enable，将启用设备，协商这些资源并填写struct pci_func。 看到这个时候应该和我一样云里雾里的，这他妈都在讲些啥啊。我们简单来说，我们现在需要把设备启动，然后把供应商ID和设备ID对上号，然后需要一个函数启动这个设备。怎么初始化，怎么启动，先不去管他。我们来分析pci_init怎么执行的。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192intpci_init(void)&#123; static struct pci_bus root_bus;//这是个总线结构体就是他提供的。 /* struct pci_bus &#123; struct pci_func *parent_bridge; uint32_t busno;//总线号，因为可能存在多总线 &#125;; struct pci_func &#123; struct pci_bus *bus; // Primary bus for bridges 主要的总线 uint32_t dev;//这些介绍全在文档里面 uint32_t func;// uint32_t dev_id;// uint32_t dev_class; uint32_t reg_base[6]; uint32_t reg_size[6]; uint8_t irq_line; &#125;; */ memset(&amp;root_bus, 0, sizeof(root_bus)); return pci_scan_bus(&amp;root_bus);//然后开始扫描&#125;static intpci_scan_bus(struct pci_bus *bus)&#123; int totaldev = 0; struct pci_func df; memset(&amp;df, 0, sizeof(df)); df.bus = bus; for (df.dev = 0; df.dev &lt; 32; df.dev++) &#123; uint32_t bhlc = pci_conf_read(&amp;df, PCI_BHLC_REG);//在df里面找PCI_BHLC_REG ，具体就不用去关心了 if (PCI_HDRTYPE_TYPE(bhlc) &gt; 1) // Unsupported or no device不支持设备或者没有这个设备 continue; totaldev++;//设备数+1 struct pci_func f = df; for (f.func = 0; f.func &lt; (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1); f.func++) &#123; struct pci_func af = f; af.dev_id = pci_conf_read(&amp;f, PCI_ID_REG);//读取ID if (PCI_VENDOR(af.dev_id) == 0xffff) continue; uint32_t intr = pci_conf_read(&amp;af, PCI_INTERRUPT_REG);//读取中断 af.irq_line = PCI_INTERRUPT_LINE(intr); af.dev_class = pci_conf_read(&amp;af, PCI_CLASS_REG);//读取class if (pci_show_devs)//打印获取到的设备信息 pci_print_func(&amp;af); pci_attach(&amp;af);//这个函数我们进去看看 &#125; &#125; return totaldev;&#125;static intpci_attach(struct pci_func *f)&#123; return pci_attach_match(PCI_CLASS(f-&gt;dev_class), PCI_SUBCLASS(f-&gt;dev_class), &amp;pci_attach_class[0], f) || pci_attach_match(PCI_VENDOR(f-&gt;dev_id), PCI_PRODUCT(f-&gt;dev_id), &amp;pci_attach_vendor[0], f);&#125;pci_attach_match(uint32_t key1, uint32_t key2, struct pci_driver *list, struct pci_func *pcif)&#123; uint32_t i; for (i = 0; list[i].attachfn; i++) &#123; if (list[i].key1 == key1 &amp;&amp; list[i].key2 == key2) &#123;//如果匹配上了 int r = list[i].attachfn(pcif);//这样去运行了 if (r &gt; 0) return r; if (r &lt; 0) cprintf("pci_attach_match: attaching " "%x.%x (%p): e\n", key1, key2, list[i].attachfn, r); &#125; &#125; return 0;&#125; 简单思考了下，pci_init 应该就是扫描了一下总线把总线里面的所有设备，然后初始化了他们，然后返回了总共的设备数量。在 pci_attach 我们调用了pci_attach_vendor，我们看到这个东西，现在里面啥都没有。所以我们现在要做的就是把我们的网卡驱动添进去初始化。练习3然我们添加他，并添加初始化函数。我们运行内核很容易看出来网卡的信息。同样我们在文档5.1节的表里找到了这个东西那么还有个问题，厂商号、设备号有了，怎么初始化？？？？实验的要求是让我写在e1000.h和e1000.c先不管这些，我们先把函数定义好。先在e1000.h里面定义123456789101112#include &lt;kern/pci.h&gt;int e1000_init(struct pci_func *pcif);//记得先把在 pic.c里面添加头文件 #include &lt;kern/e1000.h&gt; //然后修改pci_driver// pci_attach_vendor matches the vendor ID and device ID of a PCI device. key1// and key2 should be the vendor ID and device ID respectively#define PCI_E1000_VENDOR_ID 0x8086#define PCI_E1000_DEVICE_ID 0x100Estruct pci_driver pci_attach_vendor[] = &#123; &#123; PCI_E1000_VENDOR_ID, PCI_E1000_DEVICE_ID, &amp;e1000_init&#125;, &#123; 0, 0, 0 &#125;,&#125;; 在我万般无奈的时候看到了一句练习里面的提示For now, just enable the E1000 device via pci_func_enable. We&#39;ll add more initialization throughout the lab.你他妈在逗我,告辞，两行解决。1234567uint32_t *pci_e1000;inte1000_init(struct pci_func *pcif)&#123; pci_func_enable(pcif); return 1;&#125; 因为会用到其他头文件的的函数，所以先把头文件加入好，最终会用到123#include &lt;kern/e1000.h&gt;#include &lt;kern/pmap.h&gt;#include &lt;inc/string.h&gt; 出现头文件问题自己去看看少了啥。 软件通过内存映射的I/O（MMIO）与E1000通信。您在JOS中已经看过两次了：CGA控制台和LAPIC都是通过写入和读取“内存”来控制和查询的设备。但是这些读和写操作不会存储到DRAM中。他们直接去这些设备。 pci_func_enable与E1000协商MMIO区域，并将其基数和大小存储在BAR 0（即 reg_base[0]和reg_size[0]）中。这是分配给设备的一系列物理内存地址，这意味着您必须做一些事情才能通过虚拟地址访问它。由于MMIO区域分配了很高的物理地址（通常大于3GB），KADDR因此由于JOS的256MB限制，您不能使用它来访问它。因此，您必须创建一个新的内存映射。我们将使用MMIOBASE上方的区域（您 mmio_map_region在实验4中将确保我们不会覆盖LAPIC使用的映射）。由于PCI设备初始化发生在JOS创建用户环境之前，因此您可以在其中创建映射，kern_pgdir并且该映射将始终可用。 练习4 实现mmio_map_region为E1000的BAR 0创建虚拟内存映射,lapic = mmio_map_region(lapicaddr, 4096);仿着这个写一个。然后让我们打印状态，但是状态在哪。后面给了提示提示：您将需要很多常量，例如寄存器的位置和位掩码的值。尝试将这些内容从开发人员手册中复制出来很容易出错，而错误可能导致痛苦的调试会话。我们建议改用QEMU的e1000_hw.h标头作为指导。我们不建议逐字复制它，因为它定义的内容远远超出您的实际需要，并且可能无法按照您需要的方式进行定义，但这是一个很好的起点。我们下载那个文件，然后ctrl+f查找statu找到了这个#define E1000_STATUS 0x00008 /* Device Status - RO */，所以添进去就行了。 所以随便添加一点就行了。1234567891011uint32_t *pci_e1000;#define E1000_STATUS 0x00008 /* Device Status - RO 建议写到头文件里面*/inte1000_init(struct pci_func *pcif)&#123; pci_func_enable(pcif); pci_e1000 = mmio_map_region(pcif-&gt;reg_base[0], pcif-&gt;reg_size[0]); cprintf("the E1000 status register: [%08x]\n", *(pci_e1000+(E1000_STATUS&gt;&gt;2))); return 1;&#125; DMA您可以想象通过写入和读取E1000的寄存器来发送和接收数据包，但这会很慢，并且需要E1000在内部缓冲数据包数据。相反，E1000使用直接内存访问或DMA直接从内存读取和写入数据包数据，而无需使用CPU。驱动程序负责为发送和接收队列分配内存，设置DMA描述符，并使用这些队列的位置配置E1000，但之后的所有操作都是异步的。为了发送数据包，驱动程序将其复制到发送队列中的下一个DMA描述符中，并通知E1000另一个数据包可用。当有时间发送数据包时，E1000会将数据从描述符中复制出来。同样，当E1000接收到一个数据包时，它会将其复制到接收队列中的下一个DMA描述符中，驱动程序可以在下一次机会读取该描述符。 在高层，接收和发送队列非常相似。两者都由一系列描述符组成。尽管这些描述符的确切结构有所不同，但是每个描述符都包含一些标志和包含数据包数据的缓冲区的物理地址（或者是要发送给卡的数据包数据，或者是OS为卡分配的缓冲区，用于将接收到的数据包写入卡）。 队列被实现为圆形阵列，这意味着当卡或驱动程序到达阵列的末尾时，它会回绕到开头。两者都有一个头指针和一个尾指针队列的内容是这两个指针之间的描述符。硬件始终从头消耗描述符并移动头指针，而驱动程序总是向描述符添加描述符并移动尾指针。传输队列中的描述符表示等待发送的数据包（因此，在稳定状态下，传输队列为空）。对于接收队列，队列中的描述符是卡可以接收数据包的空闲描述符（因此，在稳定状态下，接收队列由所有可用的接收描述符组成）。在不混淆E1000的情况下正确更新尾部寄存器非常棘手；小心！这个队列是个圈，也就是取个模指向这些数组的指针以及描述符中的数据包缓冲区的地址都必须是物理地址， 因为硬件无需通过MMU即可直接在物理RAM之间进行DMA操作。简单来说就是给一块内存用作缓冲区，让硬件能够直接访问DMA Transmitting PacketsE1000的发送和接收功能基本上彼此独立，因此我们可以一次完成一个工作。我们将首先攻击发送数据包的原因仅仅是因为我们无法在不发送“我在这里！”的情况下测试接收。数据包优先。 首先，您必须按照14.5节中所述的步骤初始化要传输的卡（不必担心这些小节）。传输初始化的第一步是设置传输队列。队列的精确结构在3.4节中描述，描述符的结构在3.3.3节中描述。我们将不会使用E1000的TCP卸载功能，因此您可以专注于“旧版传输描述符格式”。您现在应该阅读这些部分，并熟悉这些结构。 C Structures您会发现使用C struct来描述E1000的结构很方便。如您所见struct Trapframe，使用C struct 等结构可以 使您精确地在内存中布置数据。C可以在字段之间插入填充，但是E1000的结构布局使得这不成问题。如果确实遇到字段对齐问题，请查看GCC的“打包”属性。 例如，请考虑手册表3-8中给出并在此处复制的旧版传输描述符： 63 48 47 40 39 32 31 24 23 16 15 0 +---------------------------------------------------------------+ | Buffer address | +---------------+-------+-------+-------+-------+---------------+ | Special | CSS | Status| Cmd | CSO | Length | +---------------+-------+-------+-------+-------+---------------+ 结构的第一个字节从右上角开始，因此要将其转换为C struct，从右到左，从上到下读取。如果布局正确，您会发现所有字段甚至都非常适合标准大小的类型：12345678910struct tx_desc&#123; uint64_t addr; uint16_t length; uint8_t cso; uint8_t cmd; uint8_t status; uint8_t css; uint16_t special;&#125;; 您的驱动程序将必须为传输描述符数组和传输描述符指向的数据包缓冲区保留内存。有多种方法可以执行此操作，从动态分配页面到简单地在全局变量中声明页面都可以。无论您选择什么，请记住E1000直接访问物理内存，这意味着它访问的任何缓冲区必须在物理内存中是连续的。 还有多种处理数据包缓冲区的方法。我们建议最简单的方法是，在驱动程序初始化期间为每个描述符为数据包缓冲区保留空间，并简单地将数据包数据复制到这些预分配的缓冲区中或从其中复制出来。以太网数据包的最大大小为1518字节，这限制了这些缓冲区的大小。更复杂的驱动程序可以动态分配数据包缓冲区（例如，以在网络使用率较低时减少内存开销），甚至可以传递用户空间直接提供的缓冲区（一种称为“零复制”的技术），但是最好还是从简单开始。 练习5执行第14.5节（但不包括其小节）中描述的初始化步骤。使用第13节作为初始化过程所引用的寄存器的参考，并使用3.3.3和3.4节作为发送描述符和发送描述符数组的参考。请注意对发送描述符数组的对齐要求以及对该数组长度的限制。由于TDLEN必须对齐128字节，每个传输描述符为16字节，因此您的传输描述符数组将需要8个传输描述符的某个倍数。但是，请勿使用超过64个的描述符，否则我们的测试将无法测试传输环溢出。对于TCTL.COLD，您可以假定为全双工操作。对于TIPG，请参阅第13.4.34节的表13-77中描述的IEEE 802.3标准IPG的默认值（不要使用第14.5节的表中的值）。 。。。对于这个，我真看不懂是啥。按照14.5节的描述初始化。步骤如下： 分配一块内存用作发送描述符队列，起始地址要16字节对齐。用基地址填充(TDBAL/TDBAH) 寄存器。 设置(TDLEN)寄存器，该寄存器保存发送描述符队列长度，必须128字节对齐。 设置(TDH/TDT)寄存器，这两个寄存器都是发送描述符队列的下标。分别指向头部和尾部。应该初始化为0。 初始化TCTL寄存器。设置TCTL.EN位为1，设置TCTL.PSP位为1。设置TCTL.CT为10h。设置TCTL.COLD为40h。 设置TIPG寄存器。我们先把这些东西加e1000.h中,在把结构定义出来。123456789101112131415161718192021222324252627282930313233#define E1000_TCTL 0x00400 /* TX Control - RW */#define E1000_TDBAL 0x03800 /* TX Descriptor Base Address Low - RW */#define E1000_TDBAH 0x03804 /* TX Descriptor Base Address High - RW */#define E1000_TDLEN 0x03808 /* TX Descriptor Length - RW */#define E1000_TDH 0x03810 /* TX Descriptor Head - RW */#define E1000_TDT 0x03818 /* TX Descripotr Tail - RW */#define E1000_TIPG 0x00410 /* TX Inter-packet gap -RW */#define E1000_TCTL_EN 0x00000002 /* enable tx */#define E1000_TCTL_BCE 0x00000004 /* busy check enable */#define E1000_TCTL_PSP 0x00000008 /* pad short packets */#define E1000_TCTL_CT 0x00000ff0 /* collision threshold */#define E1000_TCTL_COLD 0x003ff000 /* collision distance */#define E1000_TXD_CMD_RS 0x08000000 /* Report Status */#define E1000_TXD_STAT_DD 0x00000001 /* Descriptor Done */#define E1000_TXD_CMD_EOP 0x01000000 /* End of Packet */#define TX_MAX 64 //发送包的最大数量#define BUFSIZE 2048struct tx_desc&#123; uint64_t addr; uint16_t length; uint8_t cso; uint8_t cmd; uint8_t status; uint8_t css; uint16_t special;&#125;__attribute__((packed));struct tx_desc tx_list[TX_MAX];//描述符struct packets&#123; char buffer[BUFSIZE];//16对齐&#125;__attribute__((packed));struct packets tx_buf[TX_MAX];//缓冲区 具体实现，我只是看别人的看懂了。。。。12345678910111213141516171819202122232425//这个初始化函数是要在前面那个初始化e1000_init里面调用，不然不会运行voide1000_transmit_init()&#123; //初始化 memset(tx_list, 0, sizeof(struct tx_desc)*TX_MAX); memset(tx_buf, 0, sizeof(struct packets)*TX_MAX); for(int i=0; i&lt;TX_MAX; i++)&#123; tx_list[i].addr = PADDR(tx_buf[i].buffer); tx_list[i].cmd = (E1000_TXD_CMD_EOP&gt;&gt;24) | (E1000_TXD_CMD_RS&gt;&gt;24); tx_list[i].status = E1000_TXD_STAT_DD; &#125; //填充E1000_TDBAL/E1000_TDBAH pci_e1000[E1000_TDBAL&gt;&gt;2] = PADDR(tx_list); pci_e1000[E1000_TDBAH&gt;&gt;2] = 0; //设置长度 pci_e1000[E1000_TDLEN&gt;&gt;2] = TX_MAX*sizeof(struct tx_desc); //初始化头尾 pci_e1000[E1000_TDH&gt;&gt;2] = 0; pci_e1000[E1000_TDT&gt;&gt;2] = 0; //设置寄存器的值 pci_e1000[E1000_TCTL&gt;&gt;2] |= (E1000_TCTL_EN | E1000_TCTL_PSP | (E1000_TCTL_CT &amp; (0x10&lt;&lt;4)) | (E1000_TCTL_COLD &amp; (0x40&lt;&lt;12))); pci_e1000[E1000_TIPG&gt;&gt;2] |= (10) | (4&lt;&lt;10) | (6&lt;&lt;20);&#125; 现在，传输已初始化，您将必须编写代码以传输数据包，并使其通过系统调用可在用户空间访问。要传输数据包，您必须将其添加到传输队列的末尾，这意味着将数据包数据复制到下一个数据包缓冲区，然后更新TDT（传输描述符末尾）寄存器以通知卡中存在另一个数据包。传输队列。（请注意，TDT是传输描述符数组的索引，而不是字节偏移量；文档对此并不十分清楚。） 但是，发送队列只有这么大。如果卡落后于传输数据包并且传输队列已满怎么办？为了检测到这种情况，您需要E1000的一些反馈。不幸的是，您不能只使用TDH（发送描述符头）寄存器。该文档明确指出，从软件读取该寄存器是不可靠的。但是，如果您在发送描述符的命令字段中设置了RS位，则当卡已在该描述符中发送了数据包时，卡将在描述符的状态字段中将DD位置为1。如果已将描述符的DD位置1，则可以安全地回收该描述符并使用它传输另一个数据包。 如果用户呼叫您的传输系统调用，但未设置下一个描述符的DD位，表明传输队列已满怎么办？您必须决定在这种情况下该怎么做。您可以简单地丢弃数据包。网络协议对此具有一定的弹性，但是如果丢弃大量的数据包，则该协议可能无法恢复。您可以改为告诉用户环境必须重试，就像您对所做的一样sys_ipc_try_send。这样做的好处是可以推迟生成数据的环境。 前面已经初始化了发送，现在就是要你实现发送功能。练习6通过检查下一个描述符是否空闲，将包数据复制到下一个描述符并更新TDT，编写一个函数来发送数据包。确保处理传输队列已满。123456789101112131415intfit_txd_for_E1000_transmit(void *addr, int length)&#123; int tail = pci_e1000[E1000_TDT&gt;&gt;2];//取队尾 struct tx_desc *tx_next = &amp;tx_list[tail];//获取结构体 if(length &gt; sizeof(struct packets))//长度不能超过最大值 length = sizeof(struct packets); if((tx_next-&gt;status &amp; E1000_TXD_STAT_DD) == E1000_TXD_STAT_DD)&#123;//通过这个标志位实现判断 memmove(KADDR(tx_next-&gt;addr), addr, length); tx_next-&gt;status &amp;= !E1000_TXD_STAT_DD; tx_next-&gt;length = (uint16_t)length; pci_e1000[E1000_TDT&gt;&gt;2] = (tail + 1)%TX_MAX; return 0; &#125; return -1;&#125; 练习7 将他在系统调用里面调用。这个就简单了。添加一个新的系统调用，自己命名就行。12345678static intsys_packet_try_send(void *addr, uint32_t len)&#123; user_mem_assert(curenv, addr, len, PTE_U); return fit_txd_for_E1000_transmit(addr, len);&#125;//添加case 注意这个SYS_packet_try_send 是没有的 要在syscall.h 的头文件里面的enum 添加了。 case (SYS_packet_try_send): return sys_packet_try_send((void *)a1,a2); 在这个地方添加之后要写到lib/syscall.c里面12345int sys_packet_try_send(void *data_va, int len)&#123; return (int) syscall(SYS_packet_try_send, 0 , (uint32_t)data_va, len, 0, 0, 0);&#125;//还要在 inc/lib.h里面声明 int sys_packet_try_send(void *data_va, int len); 到这里就有系统调用发送东西了。 Transmitting Packets: Network Server现在，您已经在设备驱动程序的发送端有了一个系统调用接口，是时候发送数据包了。输出帮助程序环境的目标是循环执行以下操作：接受NSREQ_OUTPUT来自核心网络服务器的IPC消息，并使用上面添加的系统调用将伴随这些IPC消息的数据包发送到网络设备驱动程序。该NSREQ_OUTPUT IPC的由发送low_level_output功能在 net/lwip/jos/jif/jif.c，该胶合的LWIP的堆书的网络系统。每个IPC都将包含一个页面，该页面由union Nsipc其struct jif_pkt pkt字段中包含数据包 （请参见inc / ns.h）。 struct jif_pkt1234struct jif_pkt &#123; int jp_len; char jp_data [0]; &#125;; jp_len表示数据包的长度。IPC页面上的所有后续字节专用于数据包内容。jp_data在结构的末尾使用零长度数组是一种常见的C技巧，用于表示没有预定长度的缓冲区。由于C不会进行数组边界检查，因此只要您确保该结构后面有足够的未使用内存，就可以将其jp_data用作任何大小的数组。 当设备驱动程序的传输队列中没有更多空间时，请注意设备驱动程序，输出环境和核心网络服务器之间的交互。核心网络服务器使用IPC将数据包发送到输出环境。如果由于发送数据包系统调用而导致输出环境暂停，因为驱动程序没有更多的缓冲区可容纳新数据包，则核心网络服务器将阻止等待输出服务器接受IPC调用。盗个图 这就是整个的流程了。最终实现也简单。练习8实现output.c123456789101112131415161718192021#include "ns.h"extern union Nsipc nsipcbuf;voidoutput(envid_t ns_envid)&#123; binaryname = "ns_output"; // LAB 6: Your code here: // - read a packet from the network server // - send the packet to the device driver envid_t from_env; int perm; while(1)&#123; if( ipc_recv(&amp;from_env, &amp;nsipcbuf, &amp;perm) != NSREQ_OUTPUT) continue; while(sys_packet_try_send(nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len)&lt;0) sys_yield(); &#125;&#125; Part B: Receiving packets and the web server我都不想说话了，整个和前面那个基本上一模一样。我直接给代码了e100..h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#ifndef JOS_KERN_E1000_H#define JOS_KERN_E1000_H#include &lt;kern/pci.h&gt;#define E1000_STATUS 0x00008 /* Device Status - RO */int e1000_init(struct pci_func *pcif); #define E1000_TCTL 0x00400 /* TX Control - RW */#define E1000_TDBAL 0x03800 /* TX Descriptor Base Address Low - RW */#define E1000_TDBAH 0x03804 /* TX Descriptor Base Address High - RW */#define E1000_TDLEN 0x03808 /* TX Descriptor Length - RW */#define E1000_TDH 0x03810 /* TX Descriptor Head - RW */#define E1000_TDT 0x03818 /* TX Descripotr Tail - RW */#define E1000_TIPG 0x00410 /* TX Inter-packet gap -RW */#define E1000_TCTL_EN 0x00000002 /* enable tx */#define E1000_TCTL_BCE 0x00000004 /* busy check enable */#define E1000_TCTL_PSP 0x00000008 /* pad short packets */#define E1000_TCTL_CT 0x00000ff0 /* collision threshold */#define E1000_TCTL_COLD 0x003ff000 /* collision distance */#define E1000_TXD_CMD_RS 0x08000000 /* Report Status */#define E1000_TXD_STAT_DD 0x00000001 /* Descriptor Done */#define E1000_TXD_CMD_EOP 0x01000000 /* End of Packet */#define TX_MAX 64#define BUFSIZE 2048struct tx_desc&#123; uint64_t addr; uint16_t length; uint8_t cso; uint8_t cmd; uint8_t status; uint8_t css; uint16_t special;&#125;__attribute__((packed));struct tx_desc tx_list[TX_MAX];struct packets&#123; char buffer[BUFSIZE];&#125;__attribute__((packed));struct packets tx_buf[TX_MAX];void e1000_transmit_init();intfit_txd_for_E1000_transmit(void *addr, int length);#define RX_MAX 128#define E1000_RCTL_EN 0x00000002 /* enable */#define E1000_RCTL_SBP 0x00000004 /* store bad packet */#define E1000_RCTL_UPE 0x00000008 /* unicast promiscuous enable */#define E1000_RCTL_MPE 0x00000010 /* multicast promiscuous enab */#define E1000_RCTL_LPE 0x00000020 /* long packet enable */#define E1000_RCTL_LBM_NO 0x00000000 /* no loopback mode */#define E1000_RCTL_BAM 0x00008000 /* broadcast enable */#define E1000_RCTL_SZ_2048 0x00000000 /* rx buffer size 2048 */#define E1000_RCTL_SECRC 0x04000000 /* Strip Ethernet CRC */#define E1000_RXD_STAT_DD 0x01 /* Descriptor Done */#define E1000_RXD_STAT_EOP 0x02 /* End of Packet */#define E1000_RCTL 0x00100 /* RX Control - RW */#define E1000_RDBAL 0x02800 /* RX Descriptor Base Address Low - RW */#define E1000_RDBAH 0x02804 /* RX Descriptor Base Address High - RW */#define E1000_RDLEN 0x02808 /* RX Descriptor Length - RW */#define E1000_RDH 0x02810 /* RX Descriptor Head - RW */#define E1000_RDT 0x02818 /* RX Descriptor Tail - RW */#define E1000_MTA 0x05200 /* Multicast Table Array - RW Array */#define E1000_RA 0x05400 /* Receive Address - RW Array */#define E1000_RAH_AV 0x80000000 /* Receive descriptor valid */struct rx_desc&#123; uint64_t addr; uint16_t length; uint16_t pcs; uint8_t status; uint8_t errors; uint16_t special;&#125;__attribute__((packed));struct rx_desc rx_list[RX_MAX];int read_rxd_after_E1000_receive(void *addr);struct packets rx_buf[RX_MAX];void e1000_receive_init();int read_rxd_after_E1000_receive(void *addr);#endif // SOL &gt;= 6 最终的e1000.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;kern/e1000.h&gt;#include &lt;kern/pmap.h&gt;#include &lt;inc/string.h&gt;// LAB 6: Your driver code hereuint32_t *pci_e1000;inte1000_init(struct pci_func *pcif)&#123; pci_func_enable(pcif); pci_e1000 = mmio_map_region(pcif-&gt;reg_base[0], pcif-&gt;reg_size[0]); cprintf("the E1000 status register: [%08x]\n", *(pci_e1000+(E1000_STATUS&gt;&gt;2))); e1000_transmit_init(); e1000_receive_init(); return 1;&#125;voide1000_transmit_init()&#123; memset(tx_list, 0, sizeof(struct tx_desc)*TX_MAX); memset(tx_buf, 0, sizeof(struct packets)*TX_MAX); for(int i=0; i&lt;TX_MAX; i++)&#123; tx_list[i].addr = PADDR(tx_buf[i].buffer); tx_list[i].cmd = (E1000_TXD_CMD_EOP&gt;&gt;24) | (E1000_TXD_CMD_RS&gt;&gt;24); tx_list[i].status = E1000_TXD_STAT_DD; &#125; pci_e1000[E1000_TDBAL&gt;&gt;2] = PADDR(tx_list); pci_e1000[E1000_TDBAH&gt;&gt;2] = 0; pci_e1000[E1000_TDLEN&gt;&gt;2] = TX_MAX*sizeof(struct tx_desc); pci_e1000[E1000_TDH&gt;&gt;2] = 0; pci_e1000[E1000_TDT&gt;&gt;2] = 0; pci_e1000[E1000_TCTL&gt;&gt;2] |= (E1000_TCTL_EN | E1000_TCTL_PSP | (E1000_TCTL_CT &amp; (0x10&lt;&lt;4)) | (E1000_TCTL_COLD &amp; (0x40&lt;&lt;12))); pci_e1000[E1000_TIPG&gt;&gt;2] |= (10) | (4&lt;&lt;10) | (6&lt;&lt;20);&#125;intfit_txd_for_E1000_transmit(void *addr, int length)&#123; int tail = pci_e1000[E1000_TDT&gt;&gt;2]; struct tx_desc *tx_next = &amp;tx_list[tail]; if(length &gt; sizeof(struct packets)) length = sizeof(struct packets); if((tx_next-&gt;status &amp; E1000_TXD_STAT_DD) == E1000_TXD_STAT_DD)&#123; memmove(KADDR(tx_next-&gt;addr), addr, length); tx_next-&gt;status &amp;= !E1000_TXD_STAT_DD; tx_next-&gt;length = (uint16_t)length; pci_e1000[E1000_TDT&gt;&gt;2] = (tail + 1)%TX_MAX; return 0; &#125; return -1;&#125;voide1000_receive_init()&#123; for(int i=0; i&lt;RX_MAX; i++)&#123; memset(&amp;rx_list[i], 0, sizeof(struct rx_desc)); memset(&amp;rx_buf[i], 0, sizeof(struct packets)); rx_list[i].addr = PADDR(rx_buf[i].buffer); &#125; pci_e1000[E1000_MTA&gt;&gt;2] = 0; pci_e1000[E1000_RDBAL&gt;&gt;2] = PADDR(rx_list); pci_e1000[E1000_RDBAH&gt;&gt;2] = 0; pci_e1000[E1000_RDLEN&gt;&gt;2] = RX_MAX*sizeof(struct rx_desc); pci_e1000[E1000_RDH&gt;&gt;2] = 0; pci_e1000[E1000_RDT&gt;&gt;2] = RX_MAX - 1; pci_e1000[E1000_RCTL&gt;&gt;2] = (E1000_RCTL_EN | E1000_RCTL_BAM | E1000_RCTL_SZ_2048 | E1000_RCTL_SECRC); pci_e1000[E1000_RA&gt;&gt;2] = 0x52 | (0x54&lt;&lt;8) | (0x00&lt;&lt;16) | (0x12&lt;&lt;24); pci_e1000[(E1000_RA&gt;&gt;2) + 1] = (0x34) | (0x56&lt;&lt;8) | E1000_RAH_AV;&#125;intread_rxd_after_E1000_receive(void *addr)&#123; int head = pci_e1000[E1000_RDH&gt;&gt;2]; int tail = pci_e1000[E1000_RDT&gt;&gt;2]; tail = (tail + 1) % RX_MAX; struct rx_desc *rx_hold = &amp;rx_list[tail]; if((rx_hold-&gt;status &amp; E1000_TXD_STAT_DD) == E1000_TXD_STAT_DD)&#123; int len = rx_hold-&gt;length; memcpy(addr, rx_buf[tail].buffer, len); pci_e1000[E1000_RDT&gt;&gt;2] = tail; return len; &#125; return -1;&#125; 添加 系统调用的就不贴了都一样。input.c1234567891011121314151617181920212223242526272829303132333435363738#include "ns.h"extern union Nsipc nsipcbuf;voidsleep(int msec)//简单的延迟函数&#123; unsigned now = sys_time_msec(); unsigned end = now + msec; if ((int)now &lt; 0 &amp;&amp; (int)now &gt; -MAXERROR) panic("sys_time_msec: %e", (int)now); while (sys_time_msec() &lt; end) sys_yield();&#125;voidinput(envid_t ns_envid)&#123; binaryname = "ns_input"; // LAB 6: Your code here: // - read a packet from the device driver // - send it to the network server // Hint: When you IPC a page to the network server, it will be // reading from it for a while, so don't immediately receive // another packet in to the same physical page. char my_buf[2048]; int length; while(1)&#123; while((length = sys_packet_try_recv(my_buf))&lt;0) sys_yield(); nsipcbuf.pkt.jp_len=length; memcpy(nsipcbuf.pkt.jp_data, my_buf, length); ipc_send(ns_envid, NSREQ_INPUT, &amp;nsipcbuf, PTE_U | PTE_P); sleep(50); &#125;&#125; 到这个地方基本上已经全部结束了。最后让你实现http的部分代码。我也直接给了，因为如果要理解要看全部的http源码。1234567891011121314static intsend_data(struct http_request *req, int fd)&#123; // LAB 6: Your code here. int n; char buf[BUFFSIZE]; while((n=read(fd,buf,(long)sizeof(buf)))&gt;0)&#123; if(write(req-&gt;sock,buf,n)!=n)&#123; die("Failed to send file to client"); &#125; &#125; return n; //panic("send_data not implemented");&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243static intsend_file(struct http_request *req)&#123; int r; off_t file_size = -1; int fd; // open the requested url for reading // if the file does not exist, send a 404 error using send_error // if the file is a directory, send a 404 error using send_error // set file_size to the size of the file // LAB 6: Your code here. if ((fd = open(req-&gt;url, O_RDONLY)) &lt; 0) &#123; send_error(req, 404); goto end; &#125; struct Stat stat; fstat(fd, &amp;stat); if (stat.st_isdir) &#123; send_error(req, 404); goto end; &#125; //panic("send_file not implemented"); if ((r = send_header(req, 200)) &lt; 0) goto end; if ((r = send_size(req, file_size)) &lt; 0) goto end; if ((r = send_content_type(req)) &lt; 0) goto end; if ((r = send_header_fin(req)) &lt; 0) goto end; r = send_data(req, fd);end: close(fd); return r;&#125; 至此all is over 。]]></content>
      <categories>
        <category>操作系统</category>
        <category>MIT6.828</category>
      </categories>
      <tags>
        <tag>MIT6.282</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT6.828 (五)Lab5:File system, Spawn and Shell]]></title>
    <url>%2F2020%2F02%2F18%2FMIT-6.828-(%E4%BA%94)-Lab-5-File-system%2C-Spawn-and-Shell%2F</url>
    <content type="text"><![CDATA[重要的前面基本上已经做了，现在就剩下lab5了。对于这个实验本身要你写的代码不多，但是要自己去看的贼他妈的多。原谅我复制粘贴别人的。 Lab 5: File system, Spawn and Shell在本实验中，我们将实现spawn库调用用以加载和运行磁盘上的可执行文件。然后，JOS内核和库构成的操作系统将足以在控制台上运行shell了。这些功能需要一个文件系统，本实验将介绍了一个简单的读/写文件系统。 切换一下分支，会多出来几个文件，文件干啥的好好看看。 fs/fs.c 操作文件系统在磁盘上的结构，理解成文件储存结构 fs/bc.c 基于用户级页错误处理机制的块缓存。 fs/ide.c 最小化的基于PIO（非中断驱动的）的IDE磁盘驱动。磁盘驱动知道怎么调用就行 fs/serv.c 文件系统服务端代码，客户端用户环境通过IPC与之交互，你就当做内核进行系统调用吧 lib/fd.c 实现通常的UNIX风格的文件描述符接口。 lib/file.c 磁盘文件类型的驱动，实现为文件系统IPC客户端。 lib/console.c 控制台I/O文件类型的驱动 lib/spawn.c spawn库调用实现 这些文件后面都会要看一看的不用慌。 开场让我先试试水，还能不能运行lab4的pingpong,primes,forktree，要先把kern/init.c中的ENV_CREATE(fs_fs)和lib/exit.c的close_all()注释掉。我们去看看他做了啥。我们先看看init.c里面的初始化函数。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647voidi386_init(void)&#123; // Initialize the console. // Can't call cprintf until after we do this! cons_init(); cprintf("6828 decimal is %o octal!\n", 6828); // Lab 2 memory management initialization functions mem_init(); // Lab 3 user environment initialization functions env_init(); trap_init(); // Lab 4 multiprocessor initialization functions mp_init(); lapic_init(); // Lab 4 multitasking initialization functions pic_init(); // Acquire the big kernel lock before waking up APs // Your code here: lock_kernel(); // Starting non-boot CPUs boot_aps(); //上个实验都是一样的，后面才开始不同 // Start fs. ENV_CREATE(fs_fs, ENV_TYPE_FS);//这肯定是运行了一个 程序是啥呢？看不出来，但是根据输出 //最后推断出来是 fs/serv.c 里面的umain#if defined(TEST) // Don't touch -- used by grading script! ENV_CREATE(TEST, ENV_TYPE_USER);#else // Touch all you want. ENV_CREATE(user_icode, ENV_TYPE_USER);//这个后面再说#endif // TEST* // Should not be necessary - drains keyboard because interrupt has given up. kbd_intr();//不用管。 // Schedule and run the first user environment! sched_yield();&#125; 看完之后，发现就是多了一个进程而已，其他都没怎么变。那个进程应该是运行了serv.c，我们简单看一下main函数，具体做了啥，后面再说。12345678910111213141516voidumain(int argc, char **argv)&#123; static_assert(sizeof(struct File) == 256);//检查结构 binaryname = "fs"; cprintf("FS is running\n"); // Check that we are able to do I/O outw(0x8A00, 0x8A00); cprintf("FS can do I/O\n");//检查一下FS serve_init();//服务初始化 fs_init();//fs初始化 fs_test();//测试 serve();//运行服务&#125; closeall()1234567891011121314151617181920intclose(int fdnum)&#123; struct Fd *fd; int r; if ((r = fd_lookup(fdnum, &amp;fd)) &lt; 0) return r; else return fd_close(fd, 1);&#125;voidclose_all(void)&#123; int i; for (i = 0; i &lt; MAXFD; i++) close(i);&#125; 应该就是关闭所有文件的意思。把这两行注释掉，就可以正常运行lab4的测试。 后面是一大堆理论慢慢看。 File system preliminaries我们将要实现的文件系统虽然比真实的文件系统简单的多，但是也足以提供一些基本的特性：创建、读、写、删除组织在目录结构层次中的文件。 我们现在（目前为止）只开发单用户操作系统，它提供足够的保护来捕捉错误，但不能保护可疑的用户程序之间的干扰。因此，我们的文件系统不支持文件所有权或权限的UNIX概念。我们的文件系统目前还不支持像大多数UNIX文件系统那样的硬链接，符号链接，时间戳或特殊的设备文件。 On-Disk File System Structure大多数UNIX文件系统将可用磁盘空间分为两种主要类型的区域：inode区域和数据区域。 UNIX文件系统为文件系统中的每个文件分配一个inode;文件的inode保存关于文件的关键元数据，例如其stat属性和指向其数据块的指针。数据区域被划分成更大（通常为8KB或更多）的数据块，文件系统在其中存储文件数据和目录元数据。目录条目包含文件名和指向inode的指针;如果文件系统中的多个目录条目引用该文件的inode，则文件被称为硬链接。由于我们的文件系统不支持硬链接，所以我们不需要这种级别的重定向，因此可以方便的简化：我们的文件系统根本不会使用inode，而只是在（唯一）的目录条目中存储所有的文件（或子目录）的元数据。 文件和目录逻辑上都是由一系列数据块组成的，这些数据块可能散布在整个磁盘上，就像用户环境的虚拟地址空间的页面可以分散在整个物理内存中一样。文件系统环境隐藏数据块布局的细节，仅呈现在文件任意偏移量处读/写字节序列的接口。文件系统环境将对目录的所有修改作为文件创建和删除等操作内部处理的一部分。我们的文件系统允许用户环境直接读取目录元数据（例如，read），这意味着用户环境可以自己执行目录扫描操作（例如，实现ls程序），而不必依赖额外特殊的对文件系统的调用。对目录扫描方法的缺点，以及大多数现代UNIX变体阻止它的原因在于它使应用程序依赖于目录元数据的格式，使得在不更改或至少重新编译应用程序的情况下难以更改文件系统的内部布局。 简单来讲，我们文件系统就只有一个数据结构保存文件，没有索引。 Sectors and Blocks大多数磁盘不能以字节粒度执行读取和写入，而是以扇区为单位执行读取和写入操作。在JOS中，扇区为512字节。文件系统实际上以块为单位分配和使用磁盘存储。请注意两个术语之间的区别：扇区大小是磁盘硬件的属性，而块大小是操作系统使用磁盘的一个方面。文件系统的块大小必须是底层磁盘扇区大小的倍数。 UNIX xv6文件系统使用512字节的块大小，与底层磁盘的扇区大小相同。然而，大多数现代文件系统使用更大的块大小，因为存储空间已经变得更便宜，并且以更大的粒度来管理存储效率更高。我们的文件系统将使用4096字节的块大小，方便地匹配处理器的页面大小。 简单来讲，磁盘默认512字节是一个扇区，我们系统4096字节一个块，也就是8个扇区一个块。 Superblocks文件系统通常将某些磁盘块保留在磁盘上的“易于查找”位置（例如起始或最后），以保存描述整个文件系统属性的元数据，例如块大小，磁盘大小，找到根目录所需的任何元数据，文件系统上次挂载的时间，文件系统上次检查错误的时间等等。这些特殊块称为超级块。 我们的文件系统将只有一个超级块，它将始终位于磁盘上的块1。它的布局由struct Super在inc/fs.h中定义。块0通常保留用于保存引导加载程序和分区表，因此文件系统通常不使用第一个磁盘块。许多“真正的”文件系统具有多个超级块，这几个副本在磁盘的几个广泛间隔的区域，以便如果其中一个被损坏或磁盘在该区域中产生媒体错误，则仍然可以找到其他超级块，并将其用于访问文件系统。 简单来讲，块0我们用了，在前面讲过，块1就是保存了一些磁盘布局，尤其是根目录。中间可能会有一些块用于磁盘恢复，还有位图。12345struct Super &#123; uint32_t s_magic; // Magic number: FS_MAGIC 啥编号 uint32_t s_nblocks; // Total number of blocks on disk 总共块数 struct File s_root; // Root directory node 根目录&#125;; File Meta-data描述文件系统中的文件的元数据的布局由inc/fs.h中的struct File定义。该元数据包括文件的名称，大小，类型（常规文件或目录）以及指向包含该文件的块的指针。如上所述，我们没有inode，所以元数据存储在磁盘上的目录条目中。与大多数“真实”文件系统不同，为简单起见，我们将使用这个struct File来表示在磁盘和内存中出现的文件元数据。 struct File中的f_direct数组包含存储文件前10个（NDIRECT）块的块号的空间，这前10个块被称之为文件的直接块。对于大小为10 * 4096 = 40KB的小文件，这意味着所有文件块的块号将直接适用于struct File本身。然而，对于较大的文件，我们需要一个地方来保存文件的其他块号。因此，对于大于40KB的任何文件，我们分配一个额外的磁盘块，称为文件的间接块，最多容纳4096/4 = 1024个附加块号。因此，我们的文件系统允许文件的大小可达1034个块，或者刚刚超过四兆字节大小。为了支持更大的文件，“真实”文件系统通常也支持双重和三重间接块。简单来讲，储存文件我们用 struct File，小于10个块我们直接储存，超过10个块开一个间接块标记那几个块123456789101112131415struct File &#123; char f_name[MAXNAMELEN]; // filename 文件名 off_t f_size; // file size in bytes 文件大小 uint32_t f_type; // file type 文件类型 // Block pointers. // A block is allocated iff its value is != 0. uint32_t f_direct[NDIRECT]; // direct blocks 直接块 uint32_t f_indirect; // indirect block 间接块 // Pad out to 256 bytes; must do arithmetic in case we're compiling // fsformat on a 64-bit machine. //填满256字节，能够 64位机上运行 sizeof(struct File)刚好256. uint8_t f_pad[256 - MAXNAMELEN - 8 - 4*NDIRECT - 4];&#125; __attribute__((packed)); // required only on some 64-bit machines Directories versus Regular Files我们的文件系统中的struct File可以表示常规文件或目录;这两种类型的“文件”通过struct File中的类型字段进行区分。文件系统以完全相同的方式管理常规文件和目录文件，除了它不解释与常规文件相关联的数据块的内容，而文件系统将目录文件的内容解释为一系列描述目录中的文件和子目录的struct File。123// File types#define FTYPE_REG 0 // Regular file 文件#define FTYPE_DIR 1 // Directory 目录 我们的文件系统中的超级块包含一个struct File（其实struct Super中的根字段），它保存文件系统根目录的元数据。根目录文件的内容是描述位于文件系统根目录下的文件和目录的struct File序列。根目录中的任何子目录可以依次包含表示子子目录的更多的struct File，依此类推。 简单来讲，没啥可讲，够简单了 The File System本lab的目标不是实现整个文件系统，而是仅实现某些关键组件。特别是，需要实现将块读入块高速缓存并将其刷新回磁盘;分配磁盘块;将文件偏移映射到磁盘块;并在IPC接口中中实现读，写和打开。因为你不会自己实现所有的文件系统，所以你需要熟悉提供的代码和各种文件系统接口。看到那几个打出标记的了么，重点要考的。 Disk Access我们操作系统中的文件系统环境需要能够访问磁盘，但是我们还没有在内核中实现任何磁盘访问功能。而不是采取传统的单内核操作系统的策略将IDE磁盘驱动器添加到内核中，允许文件系统以系统调用访问它，而是将IDE磁盘驱动器作为用户级文件系统的一部分。我们仍然需要稍微修改内核，以便设置文件系统环境具有实现磁盘访问所需的权限。用人话来讲，我们是把磁盘访问放在用户环境，让用户能访问磁盘，但是还需要改一改内核 只要我们依靠轮询，基于“可编程I/O”（programmed I/O, PIO）的磁盘访问并且不使用磁盘中断，就很容易在用户空间中实现磁盘访问。也可以在用户态下实现中断驱动的设备驱动（例如，L3和L4内核），但是由于内核必须field设备中断并将其分配到正确的用户态环境，所以更为困难。 x86处理器使用EFLAGS寄存器中的IOPL位来确定是否允许保护模式代码执行特殊的设备I/O指令，如IN和OUT指令。由于我们需要访问的所有IDE磁盘寄存器位于x86的I/O空间中，而不是内存映射，因此为文件系统环境提供“I/O特权”是我们唯一需要做的，以便允许文件系统访问这些寄存器。实际上，EFLAGS寄存器中的IOPL位为内核提供了一种简单的“全或无”方法来控制用户态代码能否访问I/O空间。在我们的实现中，我们希望文件系统环境能够访问I/O空间，但是我们不希望任何其他环境能够访问I/O空间。用人话来讲，设置 EFLAGS 中的IOPL 可以让用户访问 I/O 练习1让我们实现上述问题。我们只需要添加一句话。1234567891011121314151617voidenv_create(uint8_t *binary, enum EnvType type)&#123; // LAB 3: Your code here. struct Env * e; int r=env_alloc(&amp;e,0); if(r!=0)&#123; cprintf("%e\n",r); panic("env_create:error"); &#125; load_icode(e,binary); e-&gt;env_type=type; // If this is the file server (type == ENV_TYPE_FS) give it I/O privileges. // LAB 5: Your code here. if(type==ENV_TYPE_FS)e-&gt;env_tf.tf_eflags|=FL_IOPL_MASK; //添加这一句即可。&#125; Question 1要不要，考虑切换用户进程的权限问题。不需要，用户环境切换的时候，eflags寄存器的状态有CPU压入内核栈，最后由env_pop_tf的iret指令恢复eflags寄存器状态。 后面告诉你两个指令可以恢复初始化。 The Block Cache在我们的文件系统中，我们将在处理器的虚拟内存系统的帮助下实现一个简单的“缓冲区缓存”（实际上只是块缓存）。块缓存的代码在fs/bc.c中。 我们的文件系统将限于处理大小为3GB或更小的磁盘。我们保留一个大的，固定的3GB区域的文件系统环境的地址空间，从0x10000000（DISKMAP）~0xD0000000（DISKMAP + DISKMAX），作为磁盘的“内存映射”版本。例如，磁盘块0映射为虚拟地址0x10000000，磁盘块1映射到虚拟地址0x10001000，依此类推。fs/bc.c中的diskaddr函数实现了从磁盘块号到虚拟地址的转换（以及一些理性检查）。 由于我们的文件系统环境具有独立于系统中所有其他环境的虚拟地址空间的虚拟地址空间，文件系统环境唯一需要做的就是实现文件访问，因此保留大部分文件系统环境的这个地址空间。由于现代磁盘大于3GB，因此在32位计算机上这样实现真正的文件系统将会很尴尬。这样的缓冲区高速缓存管理方法在具有64位地址空间的机器上仍然是合理的。 当然，将整个磁盘读入内存需要很长时间，因此我们将实现一种按需分页的形式，其中我们只在磁盘映射区域中分配页面，并从磁盘读取相应的块，以响应这个区域的页面错误。这样，我们可以假装整个磁盘都在内存中。 简单来讲，我们保留了一个3GB 的内存用来做磁盘映射，因为读取整个磁盘要很长的时间，所以我们就用分页形式。 练习2让我实现在fs/bc.c里面的bc_pgfault和flush_block。都在一个文件里面，我们直接看看文件。在看这个文件之前我们先看看ide.c ide.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/* * Minimal PIO-based (non-interrupt-driven) IDE driver code. * For information about what all this IDE/ATA magic means, * see the materials available on the class references page. *///最小化的基于PIO（非中断驱动的）的IDE磁盘驱动。#include "fs.h"#include &lt;inc/x86.h&gt;//下面这没有注释也不知道干啥的#define IDE_BSY 0x80#define IDE_DRDY 0x40#define IDE_DF 0x20#define IDE_ERR 0x01static int diskno = 1;static intide_wait_ready(bool check_error)&#123; int r; while (((r = inb(0x1F7)) &amp; (IDE_BSY|IDE_DRDY)) != IDE_DRDY) /* do nothing */; //这个应该是检查磁盘是不是准备好的 if (check_error &amp;&amp; (r &amp; (IDE_DF|IDE_ERR)) != 0)//检查是否出错？ return -1; return 0;&#125;boolide_probe_disk1(void)&#123; int r, x; // wait for Device 0 to be ready ide_wait_ready(0); // switch to Device 1 outb(0x1F6, 0xE0 | (1&lt;&lt;4)); // check for Device 1 to be ready for a while for (x = 0; x &lt; 1000 &amp;&amp; ((r = inb(0x1F7)) &amp; (IDE_BSY|IDE_DF|IDE_ERR)) != 0; x++) /* do nothing */; // switch back to Device 0 outb(0x1F6, 0xE0 | (0&lt;&lt;4)); cprintf("Device 1 presence: %d\n", (x &lt; 1000)); return (x &lt; 1000);&#125;voidide_set_disk(int d)&#123; if (d != 0 &amp;&amp; d != 1) panic("bad disk number"); diskno = d;&#125;//前面也不知道是啥，不过不重要重要的是下面两个函数intide_read(uint32_t secno, void *dst, size_t nsecs) //参数三个，扇区号，虚拟地址，已经读取扇区个数&#123; int r; assert(nsecs &lt;= 256); ide_wait_ready(0);//判断是不是等待//后面看不懂了 outb(0x1F2, nsecs); outb(0x1F3, secno &amp; 0xFF); outb(0x1F4, (secno &gt;&gt; 8) &amp; 0xFF); outb(0x1F5, (secno &gt;&gt; 16) &amp; 0xFF); outb(0x1F6, 0xE0 | ((diskno&amp;1)&lt;&lt;4) | ((secno&gt;&gt;24)&amp;0x0F)); outb(0x1F7, 0x20); // CMD 0x20 means read sector for (; nsecs &gt; 0; nsecs--, dst += SECTSIZE) &#123; if ((r = ide_wait_ready(1)) &lt; 0) return r; insl(0x1F0, dst, SECTSIZE/4); &#125; return 0;&#125;intide_write(uint32_t secno, const void *src, size_t nsecs)//写入扇区，写入内容，写入扇区个数&#123; int r; assert(nsecs &lt;= 256); ide_wait_ready(0); outb(0x1F2, nsecs); outb(0x1F3, secno &amp; 0xFF); outb(0x1F4, (secno &gt;&gt; 8) &amp; 0xFF); outb(0x1F5, (secno &gt;&gt; 16) &amp; 0xFF); outb(0x1F6, 0xE0 | ((diskno&amp;1)&lt;&lt;4) | ((secno&gt;&gt;24)&amp;0x0F)); outb(0x1F7, 0x30); // CMD 0x30 means write sector for (; nsecs &gt; 0; nsecs--, src += SECTSIZE) &#123; if ((r = ide_wait_ready(1)) &lt; 0) return r; outsl(0x1F0, src, SECTSIZE/4); &#125; return 0;&#125; 看完这个文件，主要要记住的就是那两个函数后面用的上。int ide_read(uint32_t secno, void *dst, size_t nsecs)int ide_write(uint32_t secno, const void *src, size_t nsecs) bc123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include "fs.h"// 基于用户级页错误处理机制的块缓存。// Return the virtual address of this disk block.void*diskaddr(uint32_t blockno) //看的出来是返回对应块号的虚拟地址&#123; if (blockno == 0 || (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks)) panic("bad block number %08x in diskaddr", blockno); return (char*) (DISKMAP + blockno * BLKSIZE);&#125;// Is this virtual address mapped?boolva_is_mapped(void *va)//这个应该是判断这个页有没有映射&#123; return (uvpd[PDX(va)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(va)] &amp; PTE_P);&#125;// Is this virtual address dirty?boolva_is_dirty(void *va)//这个虚拟地址是不是修改了&#123; return (uvpt[PGNUM(va)] &amp; PTE_D) != 0;&#125;// Fault any disk block that is read in to memory by// loading it from disk. 这个应该就是缺页处理了static voidbc_pgfault(struct UTrapframe *utf)&#123; void *addr = (void *) utf-&gt;utf_fault_va;//获取缺页地址 uint32_t blockno = ((uint32_t)addr - DISKMAP) / BLKSIZE;//对应块号 int r; // Check that the fault was within the block cache region判断地址合不合法 if (addr &lt; (void*)DISKMAP || addr &gt;= (void*)(DISKMAP + DISKSIZE)) panic("page fault in FS: eip %08x, va %08x, err %04x", utf-&gt;utf_eip, addr, utf-&gt;utf_err); // Sanity check the block number. 检查块号合不合法 if (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks) panic("reading non-existent block %08x\n", blockno); // Allocate a page in the disk map region, read the contents // of the block from the disk into that page. // Hint: first round addr to page boundary. fs/ide.c has code to read // the disk. fs/ide.c 有代码去读取硬盘 // // LAB 5: you code here: //经过练习的提示，我们应该要页对齐然后再分配内存 addr=ROUNDDOWN(addr,PGSIZE); if(sys_page_alloc(0,addr,PTE_SYSCALL)&lt;0)panic("error page alloc"); //分配一个页 //分配完页之后，我们需要把磁盘里面的内容读出来，练习提示了我们 函数是按扇区来的 //而我们是按块来的，还有页，第blockno*8 个扇区，读8个扇区 ide_read(blockno*8,addr,8);//把页磁盘里面的值读出来 // Clear the dirty bit for the disk block page since we just read the // block from disk 刚加入的还没有修改，所以还是干净的 if ((r = sys_page_map(0, addr, 0, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; 0) panic("in bc_pgfault, sys_page_map: %e", r); // Check that the block we read was allocated. (exercise for // the reader: why do we do this *after* reading the block // in?) 检查这个是不是已经分配了 if (bitmap &amp;&amp; block_is_free(blockno)) panic("reading free block %08x\n", blockno);&#125;// Flush the contents of the block containing VA out to disk if// necessary, then clear the PTE_D bit using sys_page_map.// If the block is not in the block cache or is not dirty, does// nothing. 把VA地址的内容写到磁盘，如果没有修改就什么都不要做// Hint: Use va_is_mapped, va_is_dirty, and ide_write. 这三个是可以用的// Hint: Use the PTE_SYSCALL constant when calling sys_page_map. 用 sys_page_map清楚 修改位// Hint: Don't forget to round addr down.不要忘记页对齐voidflush_block(void *addr)&#123; uint32_t blockno = ((uint32_t)addr - DISKMAP) / BLKSIZE;//获取块号 if (addr &lt; (void*)DISKMAP || addr &gt;= (void*)(DISKMAP + DISKSIZE))//检查地址 panic("flush_block of bad va %08x", addr); // LAB 5: Your code here. addr=ROUNDDOWN(addr,PGSIZE);//页对齐 if(!va_is_mapped(addr)||!va_is_dirty(addr))return ;//检查地址是不是已经映射了和修改 如果没有映射，或者是修改说明没有做任何改变，那么什么都不用做 ide_write(blockno*8,addr,8); //修改了就要写入 sys_page_map(0,addr,0,addr,PTE_SYSCALL);// 清楚修改标志 //panic("flush_block not implemented");&#125;// Test that the block cache works, by smashing the superblock and// reading it back. 测试缓存是不是工作。static voidcheck_bc(void)&#123; struct Super backup; // back up super block memmove(&amp;backup, diskaddr(1), sizeof backup); // smash it strcpy(diskaddr(1), "OOPS!\n"); flush_block(diskaddr(1)); assert(va_is_mapped(diskaddr(1))); assert(!va_is_dirty(diskaddr(1))); // clear it out sys_page_unmap(0, diskaddr(1)); assert(!va_is_mapped(diskaddr(1))); // read it back in assert(strcmp(diskaddr(1), "OOPS!\n") == 0); // fix it memmove(diskaddr(1), &amp;backup, sizeof backup); flush_block(diskaddr(1)); // Now repeat the same experiment, but pass an unaligned address to // flush_block. // back up super block memmove(&amp;backup, diskaddr(1), sizeof backup); // smash it strcpy(diskaddr(1), "OOPS!\n"); // Pass an unaligned address to flush_block. flush_block(diskaddr(1) + 20); assert(va_is_mapped(diskaddr(1))); // Skip the !va_is_dirty() check because it makes the bug somewhat // obscure and hence harder to debug. //assert(!va_is_dirty(diskaddr(1))); // clear it out sys_page_unmap(0, diskaddr(1)); assert(!va_is_mapped(diskaddr(1))); // read it back in assert(strcmp(diskaddr(1), "OOPS!\n") == 0); // fix it memmove(diskaddr(1), &amp;backup, sizeof backup); flush_block(diskaddr(1)); cprintf("block cache is good\n");&#125;voidbc_init(void)//初始化磁盘&#123; struct Super super; set_pgfault_handler(bc_pgfault);//设置缺页处理手段 check_bc();//检查磁盘缓冲 // cache the super block by reading it once 第一次加载，在这个时候把根目录取到内存了，在这之后我们就可以通过super 访问磁盘状态了 memmove(&amp;super, diskaddr(1), sizeof super)&#125; 我们现在就有缺页处理，和刷新缓存的功能了。 fs/fs.c中的fs_init函数是如何使用块缓存的主要示例。在初始化块缓存之后，它将指针存储在super全局变量的磁盘映射区域中。此后，我们可以简单地从struct Super中读取，就像它们在内存中一样，我们的页面错误处理程序将根据需要从磁盘读取它们。我们看看fs_init()1234567891011121314151617181920// Initialize the file systemvoidfs_init(void)&#123; static_assert(sizeof(struct File) == 256);//检查File 对不对 // Find a JOS disk. Use the second IDE disk (number 1) if available if (ide_probe_disk1()) //这个是找盘？看注释是看有没有1号盘，有就用1号没有0号？ ide_set_disk(1); else ide_set_disk(0); bc_init();//这个讲过了 // Set "super" to point to the super block. super = diskaddr(1);//在bc_init里面实际上已经有了 也不知道这两个有啥区别 check_super(); // Set "bitmap" to the beginning of the first bitmap block. bitmap = diskaddr(2);//位图 我们接下来就要讲了 check_bitmap(); The Block Bitmap在fs_init设置位图指针之后，我们可以将位图视为一个打包数组的位，每一个位对应于磁盘上的每个块。参见例如block_is_free，它在位图中检查给定的块是否被标记为空闲。练习3实现fs/fs.c里面的alloc_block。我们简单看看相关函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// --------------------------------------------------------------// Super block// --------------------------------------------------------------// Validate the file system super-block. 检查super是否正常voidcheck_super(void)&#123; if (super-&gt;s_magic != FS_MAGIC)//不知道干啥的 panic("bad file system magic number"); if (super-&gt;s_nblocks &gt; DISKSIZE/BLKSIZE)//检查文件系统是不是正常大小 panic("file system is too large"); cprintf("superblock is good\n");&#125;// --------------------------------------------------------------// Free block bitmap// --------------------------------------------------------------// Check to see if the block bitmap indicates that block 'blockno' is free.// Return 1 if the block is free, 0 if not. 看的出来是检查一个块号是不是空闲额，1空闲0不空闲boolblock_is_free(uint32_t blockno)&#123; if (super == 0 || blockno &gt;= super-&gt;s_nblocks) return 0; if (bitmap[blockno / 32] &amp; (1 &lt;&lt; (blockno % 32))) return 1; return 0;&#125;// Mark a block free in the bitmap //把一个块号释放掉voidfree_block(uint32_t blockno)&#123; // Blockno zero is the null pointer of block numbers. if (blockno == 0) //记住0是不能用的 panic("attempt to free zero block"); //uint32_t *bitmap; bitmap 定义是 32位，每位代表一个块 bitmap[blockno/32] |= 1&lt;&lt;(blockno%32);&#125;// Search the bitmap for a free block and allocate it. When you// allocate a block, immediately flush the changed bitmap block// to disk.// 暴力搜索第一个块号然后分配。// Return block number allocated on success,// -E_NO_DISK if we are out of blocks.//// Hint: use free_block as an example for manipulating the bitmap. 使用free_block 作为一个列子intalloc_block(void)//看了上面那个这个实现就简单额。&#123; // The bitmap consists of one or more blocks. A single bitmap block // contains the in-use bits for BLKBITSIZE blocks. There are // super-&gt;s_nblocks blocks in the disk altogether. //告诉你总共有 super-&gt;s_nblocks 这么多个块 // LAB 5: Your code here. for(int i=0;i&lt;super-&gt;s_nblocks;i++)&#123;//直接暴力所有块 if(block_is_free(i))&#123; //检查是不是空闲 bitmap[i/32] ^= (1&lt;&lt;(i%32)); //不懂异或 的可以用 bitmap[i/32]&amp;=~(1&lt;&lt;(i%32); 代替 flush_block(diskaddr(i));//刷新缓存。 return i; &#125; &#125; //panic("alloc_block not implemented"); return -E_NO_DISK;&#125;// Validate the file system bitmap.//// Check that all reserved blocks -- 0, 1, and the bitmap blocks themselves --// are all marked as in-use. 检查位图，没有我们需要操作的地方，看一下就行voidcheck_bitmap(void)&#123; uint32_t i; // Make sure all bitmap blocks are marked in-use 检查位图块都被使用了 for (i = 0; i * BLKBITSIZE &lt; super-&gt;s_nblocks; i++) assert(!block_is_free(2+i)); // Make sure the reserved and root blocks are marked in-use. assert(!block_is_free(0)); assert(!block_is_free(1)); cprintf("bitmap is good\n");&#125; File Operations我们在fs/fs.c中提供了各种函数，以实现解释和管理struct File，扫描和管理目录条目所需的基本功能，并从文件系统的根目录开始遍历以解析绝对路径名。阅读fs/fs.c中的所有代码，并确保您了解每个函数执行的操作。刚才我们已经看了一部分了，然后还是短短的一部分。练习4 我们需要实现file_block_walk 和 file_get_block，这两个功能十分重要。file_block_walk这个是找到文件里面第filebno块号地址，是指向块号的地址，并不是块的具体地址，file_get_block功能是找到 filebno对应的块号是多少，并返回块号地址，这个是具体地址基本上所有文件操作都要通过上述两个函数。 file_block_walk和file_get_block1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// Find the disk block number slot for the 'filebno'th block in file 'f'.// Set '*ppdiskbno' to point to that slot. // The slot will be one of the f-&gt;f_direct[] entries,// or an entry in the indirect block.// When 'alloc' is set, this function will allocate an indirect block// if necessary.//在f 文件里面找到第 filebno 块对应的地址，储存到*ppdiskbno，可能在 f-&gt;f_direct[] 里面//或者 间接块里面，如果我们 分配位置设置了，就分配一个// Returns:// *ppdiskbno 储存的是块号// 0 on success (but note thatppdiskbno might equal 0).分配冲个返回0// -E_NOT_FOUND if the function needed to allocate an indirect block, but// alloc was 0. 没有找到 且没有设置分配位// -E_NO_DISK if there's no space on the disk for an indirect block.没空间了// -E_INVAL if filebno is out of range (it's &gt;= NDIRECT + NINDIRECT).//超出范围// Analogy: This is like pgdir_walk for files.和pgdir_walk很像// Hint: Don't forget to clear any block you allocate.不要忘记清楚你分配的块static intfile_block_walk(struct File *f, uint32_t filebno, uint32_t **ppdiskbno, bool alloc)//f 文件 fileno文件中的第几块 ppdiskbno储存地址 alloc是否可以分配间接块&#123; // LAB 5: Your code here. //NDIRECT NINDIRECT 两个在fs.h 里面有定义 if(filebno&gt;=NDIRECT+NINDIRECT)return -E_INVAL;//文件块数超出了最大值 if(filebno&lt;NDIRECT)&#123;//如果在直接块里面 ，就直接返回地址 if(ppdiskbno)&#123; *ppdiskbno=&amp;f-&gt;f_direct[filebno]; &#125; return 0; &#125; //如果没有在直接块里面，那么就只能在间接块里，然后我们怎么判断有没有间接块呢？？？ //在这个文件里面搜索 `f_indirectf`，发现在 file_truncate_blocks函数的前面 //有说明 f-&gt;f_indirect != 0代表没有 特么这个函数不告诉我，别问我经历了什么 if((f-&gt;f_indirect)==0)&#123;//判断没有间接块 if(alloc==0)return -E_NOT_FOUND;//没有设置分配位，就返回没有找到 int r=alloc_block();//分配一个块 if(r&lt;=0)return -E_NO_DISK; f-&gt;f_indirect=r;//间接快块号 memset(diskaddr(f-&gt;f_indirect), 0, BLKSIZE);//出事化为0 flush_block(diskaddr(f-&gt;f_indirect));//刷新缓存 &#125; if (ppdiskbno)//只是返回地址，没有具体的值。 *ppdiskbno = &amp;((uint32_t *)diskaddr(f-&gt;f_indirect))[filebno-NDIRECT];//此时 *ppdiskbno 是块号 return 0; //panic("file_block_walk not implemented");&#125;// Set *blk to the address in memory where the filebno'th// block of file 'f' would be mapped.//设置 *blk 为 在 f 文件连 的第 fileno 的地址。明显是要用到上一个函数。// Returns 0 on success, &lt; 0 on error. Errors are:返回0成功// -E_NO_DISK if a block needed to be allocated but the disk is full. 没有空间了返回 // -E_INVAL if filebno is out of range. 超出范围//// Hint: Use file_block_walk and alloc_block. 使用这两个函数intfile_get_block(struct File *f, uint32_t filebno, char **blk)&#123; // LAB 5: Your code here. uint32_t *ppdiskbno,blockno； int r=0; //首先得知道对应磁盘中的块号是多少， //通过这个函数 ppdiskbno 就是指向对应磁盘块号的地址，也就是 *ppdiskbno 存的是块号。 if ((r = file_block_walk(f, filebno, &amp;ppdiskbno, true)) &lt; 0) return r; if ((*ppdiskbno)==0) &#123;//块号是 0 说明还没有分配块 if ((r = alloc_block()) &lt; 0)//分配一个块 return r; blockno = r; *ppdiskbno = blockno;//指向那个块 flush_block(diskaddr(*ppdiskbno));//刷新缓存 &#125; if (blk) *blk = (char *)diskaddr(*ppdiskbno);//块号在磁盘中的地址 是 *blk存的是虚拟地址指针 return 0; //panic("file_get_block not implemented");&#125; 看懂上面两个函数，其他的就都简单了。我们来看看其他函数。 fs.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304// Try to find a file named "name" in dir. If so, set *file to it.// 在目录里面找一个name 的文件// Returns 0 and sets *file on success, &lt; 0 on error. Errors are:// -E_NOT_FOUND if the file is not found 没找到static intdir_lookup(struct File *dir, const char *name, struct File **file)&#123; int r; uint32_t i, j, nblock; char *blk; struct File *f; // Search dir for name. // We maintain the invariant that the size of a directory-file // is always a multiple of the file system's block size. assert((dir-&gt;f_size % BLKSIZE) == 0); nblock = dir-&gt;f_size / BLKSIZE; for (i = 0; i &lt; nblock; i++) &#123; if ((r = file_get_block(dir, i, &amp;blk)) &lt; 0) return r; f = (struct File*) blk; for (j = 0; j &lt; BLKFILES; j++)//就是简单的一个个比较 if (strcmp(f[j].f_name, name) == 0) &#123; *file = &amp;f[j]; return 0; &#125; &#125; return -E_NOT_FOUND;&#125;// Set *file to point at a free File structure in dir. The caller is// responsible for filling in the File fields. 在目录里面添加一个文件static intdir_alloc_file(struct File *dir, struct File **file)&#123; int r; uint32_t nblock, i, j; char *blk; struct File *f; assert((dir-&gt;f_size % BLKSIZE) == 0); nblock = dir-&gt;f_size / BLKSIZE; for (i = 0; i &lt; nblock; i++) &#123; if ((r = file_get_block(dir, i, &amp;blk)) &lt; 0) return r; f = (struct File*) blk; for (j = 0; j &lt; BLKFILES; j++) if (f[j].f_name[0] == '\0') &#123; *file = &amp;f[j];//找到第一个能放 文件描述符的位置 return 0; &#125; &#125; dir-&gt;f_size += BLKSIZE;//文件大小增加 if ((r = file_get_block(dir, i, &amp;blk)) &lt; 0)//不知道为啥还要在找一次 return r; f = (struct File*) blk; *file = &amp;f[0]; return 0;&#125;// Skip over slashes.static const char* //跳过斜杠的第一个字符skip_slash(const char *p)&#123; while (*p == '/') p++; return p;&#125;// Evaluate a path name, starting at the root. 一个路径 从根目录开始// On success, set *pf to the file we found 成功设置文件指针pf 和 路径指针pdir// and set *pdir to the directory the file is in.// If we cannot find the file but find the directory // it should be in, set *pdir and copy the final path// element into lastelem.如果我们没有找到一个文件但是找到了路径，那么就把路径指过去，再复制最后一个元素static intwalk_path(const char *path, struct File **pdir, struct File **pf, char *lastelem)&#123; const char *p; char name[MAXNAMELEN]; struct File *dir, *f; int r; // if (*path != '/') // return -E_BAD_PATH; path = skip_slash(path); f = &amp;super-&gt;s_root; dir = 0; name[0] = 0; if (pdir) *pdir = 0; *pf = 0; while (*path != '\0') &#123; dir = f; p = path; while (*path != '/' &amp;&amp; *path != '\0') path++; if (path - p &gt;= MAXNAMELEN) return -E_BAD_PATH; memmove(name, p, path - p); name[path - p] = '\0'; path = skip_slash(path); if (dir-&gt;f_type != FTYPE_DIR) return -E_NOT_FOUND; if ((r = dir_lookup(dir, name, &amp;f)) &lt; 0) &#123; if (r == -E_NOT_FOUND &amp;&amp; *path == '\0') &#123; if (pdir) *pdir = dir; if (lastelem) strcpy(lastelem, name); *pf = 0; &#125; return r; &#125; &#125; if (pdir) *pdir = dir; *pf = f; return 0;&#125;// --------------------------------------------------------------// File operations// --------------------------------------------------------------// Create "path". On success set *pf to point at the file and return 0.// On error return &lt; 0. 在path 创建文件，*pf指向文件？？？？intfile_create(const char *path, struct File **pf)&#123; char name[MAXNAMELEN]; int r; struct File *dir, *f; if ((r = walk_path(path, &amp;dir, &amp;f, name)) == 0) return -E_FILE_EXISTS; if (r != -E_NOT_FOUND || dir == 0) return r; if ((r = dir_alloc_file(dir, &amp;f)) &lt; 0) return r; strcpy(f-&gt;f_name, name); *pf = f; file_flush(dir); return 0;&#125;// Open "path". On success set *pf to point at the file and return 0.// On error return &lt; 0. 打开文件，pf 指向文件intfile_open(const char *path, struct File **pf)&#123; return walk_path(path, 0, pf, 0);&#125;// Read count bytes from f into buf, starting from seek position// offset. This meant to mimic the standard pread function.// Returns the number of bytes read, &lt; 0 on error.//这个函数要看懂，其实就是在 f 里面读 count 个文件到buf里面，offset 你可以理解成光标ssize_tfile_read(struct File *f, void *buf, size_t count, off_t offset)&#123; int r, bn; off_t pos; char *blk; if (offset &gt;= f-&gt;f_size)//判断光标是不是文件尾 return 0; count = MIN(count, f-&gt;f_size - offset);//最多能写这么多个 for (pos = offset; pos &lt; offset + count; ) &#123; if ((r = file_get_block(f, pos / BLKSIZE, &amp;blk)) &lt; 0) return r; bn = MIN(BLKSIZE - pos % BLKSIZE, offset + count - pos); memmove(buf, blk + pos % BLKSIZE, bn);//读取 pos += bn; buf += bn; &#125; return count;&#125;// Write count bytes from buf into f, starting at seek position// offset. This is meant to mimic the standard pwrite function.// Extends the file if necessary.// Returns the number of bytes written, &lt; 0 on error.//在光标后面写 count 个文件intfile_write(struct File *f, const void *buf, size_t count, off_t offset)&#123; int r, bn; off_t pos; char *blk; // Extend file if necessary if (offset + count &gt; f-&gt;f_size)//判断需不需要扩大文件 if ((r = file_set_size(f, offset + count)) &lt; 0) return r; for (pos = offset; pos &lt; offset + count; ) &#123; if ((r = file_get_block(f, pos / BLKSIZE, &amp;blk)) &lt; 0) return r; bn = MIN(BLKSIZE - pos % BLKSIZE, offset + count - pos); memmove(blk + pos % BLKSIZE, buf, bn);//复制 这个时候写完其实还是在内存里面，并没有写到磁盘 pos += bn; buf += bn; &#125; return count;&#125;// Remove a block from file f. If it's not there, just silently succeed.// Returns 0 on success, &lt; 0 on error. 从f 里面删除块 第filebnostatic intfile_free_block(struct File *f, uint32_t filebno)&#123; int r; uint32_t *ptr; if ((r = file_block_walk(f, filebno, &amp;ptr, 0)) &lt; 0) return r; if (*ptr) &#123; free_block(*ptr); *ptr = 0; &#125; return 0;&#125;// Remove any blocks currently used by file 'f',// but not necessary for a file of size 'newsize'.// For both the old and new sizes, figure out the number of blocks required,// and then clear the blocks from new_nblocks to old_nblocks.// If the new_nblocks is no more than NDIRECT, and the indirect block has// been allocated (f-&gt;f_indirect != 0), then free the indirect block too.// (Remember to clear the f-&gt;f_indirect pointer so you'll know// whether it's valid!)// Do not change f-&gt;f_size.//把新大小到 旧的大小之间的块全部删除。如果不需要间接块了，把他也删了，不用修改文件大小static voidfile_truncate_blocks(struct File *f, off_t newsize)&#123; int r; uint32_t bno, old_nblocks, new_nblocks; old_nblocks = (f-&gt;f_size + BLKSIZE - 1) / BLKSIZE; new_nblocks = (newsize + BLKSIZE - 1) / BLKSIZE; for (bno = new_nblocks; bno &lt; old_nblocks; bno++) if ((r = file_free_block(f, bno)) &lt; 0) cprintf("warning: file_free_block: %e", r); if (new_nblocks &lt;= NDIRECT &amp;&amp; f-&gt;f_indirect) &#123; free_block(f-&gt;f_indirect); f-&gt;f_indirect = 0; &#125;&#125;// Set the size of file f, truncating or extending as necessary. 设置文件大小intfile_set_size(struct File *f, off_t newsize)&#123; if (f-&gt;f_size &gt; newsize) file_truncate_blocks(f, newsize); f-&gt;f_size = newsize; flush_block(f); return 0;&#125;// Flush the contents and metadata of file f out to disk.// Loop over all the blocks in file.// Translate the file block number into a disk block number// and then check whether that disk block is dirty. If so, write it out.//刷新文件 写入到磁盘了voidfile_flush(struct File *f)&#123; int i; uint32_t *pdiskbno; for (i = 0; i &lt; (f-&gt;f_size + BLKSIZE - 1) / BLKSIZE; i++) &#123; if (file_block_walk(f, i, &amp;pdiskbno, 0) &lt; 0 || pdiskbno == NULL || *pdiskbno == 0) continue; flush_block(diskaddr(*pdiskbno)); &#125; flush_block(f); if (f-&gt;f_indirect) flush_block(diskaddr(f-&gt;f_indirect));&#125;// Sync the entire file system. A big hammer. 刷新 整个文件系统voidfs_sync(void)&#123; int i; for (i = 1; i &lt; super-&gt;s_nblocks; i++) flush_block(diskaddr(i));&#125; 终于看完了。看完之后告诉你，实际上没啥卵用。 The file system interface现在我们的文件系统环境已经具有必要的功能，我们必须让其他希望使用文件系统的用户环境可以访问文件系统。由于其他用户环境不能直接调用文件系统环境中的函数，因此我们将通过远程过程调用（RPC）即在JOS的IPC机制上封装构建的对文件系统环境的访问接口。如下图所示，对文件系统服务器的调用（比如说，read）： Regular env FS env +---------------+ +---------------+ | read | | file_read | | (lib/fd.c) | | (fs/fs.c) | ...|.......|.......|...|.......^.......|............... | v | | | | RPC mechanism | devfile_read | | serve_read | | (lib/file.c) | | (fs/serv.c) | | | | | ^ | | v | | | | | fsipc | | serve | | (lib/file.c) | | (fs/serv.c) | | | | | ^ | | v | | | | | ipc_send | | ipc_recv | | | | | ^ | +-------|-------+ +-------|-------+ | | +-------------------+ 简单来讲，就是我要访问磁盘，先通过IPC发给另一个进程，然后另一个进程帮我访问，就是这样了 虚线以下的所有内容都只是从常规用户环境到文件系统环境的读取请求的机制。从最开始，read适用于任何文件描述符，并且简单地分发到适当的设备读取函数，在这种情况下为devfile_read我们可以有更多的设备类型，如管道。devfile_read专门实现为读取磁盘文件。lib/file.c中的devfile_read和其他devfile_*函数实现了客户端FS操作，并且都以大致相同的方式工作，在request结构体中封装参数，调用fsipc发送IPC请求，并解包和返回结果。 fsipc函数简单地处理向服务器发送请求并接收回复的常见细节。 文件系统服务器代码可以在fs/serv.c中找到。它在serve函数中循环，无休止地通过IPC接收请求，将该请求分发到适当的处理函数，并通过IPC发送结果。在read示例中，serve函数将请求分发到serve_read，它将处理read请求指定的IPC细节，例如解包request结构体，最后调用file_read来实际执行文件读取。 回想一下，JOS的IPC机制允许用户环境发送一个32位数字，并且可选地共享一个页面。要从客户端发送请求到服务器，我们使用32位数字作为请求类型（文件系统服务器RPC也是像系统调用编号那样编号），并将参数存储在通过IPC共享页面的Fsipc联合类型中的request结构体中。在客户端，我们总是在fsipcbuf共享页面;在服务器端，我们将传入请求页映射到fsreq（0x0ffff000）。简单来说，32位作为请求类型，页放到fsreq，并且储存到request`结构体中 服务器还通过IPC发回响应。我们使用32位数字作为函数的返回码。对于大多数RPC，这些是他们返回的全部内容。FSREQ_READ和FSREQ_STAT也返回数据，它们只是将数据写入客户端发送请求的页面。无需在响应IPC中发送此页面，因为客户端首先与文件系统服务器共享。此外，在其回复中，FSREQ_OPEN与客户端共享一个新的Fd page。我们将很快返回到文件描述符页面。练习5和练习6 让我们实现serve_read和serve_write，devfile_write，我们直接一起看了。在做之前了解一下1234567891011121314151617181920212223242526// The file system server maintains three structures// for each open file.//服务器的三层 结构// 1. The on-disk 'struct File' is mapped into the part of memory// that maps the disk. This memory is kept private to the file// server. //磁盘文件层 就是 struct File，前面我已经看过了// 2. Each open file has a 'struct Fd' as well, which sort of// corresponds to a Unix file descriptor. This 'struct Fd' is kept// on *its own page* in memory, and it is shared with any// environments that have the file open. // 每个开放的文件都有他自己的 描述 struct Fd，供所有环境使用// 3. 'struct OpenFile' links these other two structures, and is kept// private to the file server. The server maintains an array of// all open files, indexed by "file ID". (There can be at most// MAXOPEN files open concurrently.) The client uses file IDs to// communicate with the server. File IDs are a lot like// environment IDs in the kernel. Use openfile_lookup to translate// file IDs to struct OpenFile. struct OpenFile' 将两者联系起来，并保持私有// 客服端通过id与 服务器通信，就像进程ID，使用 openfile_lookup 可以获得对应OpenFilestruct OpenFile &#123; uint32_t o_fileid; // file id struct File *o_file; // mapped descriptor for open file int o_mode; // open mode struct Fd *o_fd; // Fd page&#125;; 我们先看看read是怎么执行的吧。 readread一开始在file.c 里面调用devfile_read，我们看看怎么实现的。123456789101112131415161718192021222324252627282930313233343536373839// Read at most 'n' bytes from 'fd' at the current position into 'buf'.//cong fd 读n 个字节到buf 里面。// Returns:// The number of bytes successfully read.// &lt; 0 on error.static ssize_tdevfile_read(struct Fd *fd, void *buf, size_t n)&#123; // fd 应该是打开的文件，buf，保存读出来的值，n是读的大小 返回了读了几个值 // Make an FSREQ_READ request to the file system server after // filling fsipcbuf.read with the request arguments. The // bytes read will be written back to fsipcbuf by the file // system server. int r; fsipcbuf.read.req_fileid = fd-&gt;fd_file.id; //fsipcbuf 作为信息传递 fsipcbuf.read.req_n = n; if ((r = fsipc(FSREQ_READ, NULL)) &lt; 0)//fsipc 就是分配函数 return r; assert(r &lt;= n); assert(r &lt;= PGSIZE); memmove(buf, fsipcbuf.readRet.ret_buf, r);//返回的值在ret_buf 里面 return r;&#125;static intfsipc(unsigned type, void *dstva) //这个时候dstva 应该是空&#123; static envid_t fsenv; if (fsenv == 0) fsenv = ipc_find_env(ENV_TYPE_FS); static_assert(sizeof(fsipcbuf) == PGSIZE); if (debug) cprintf("[%08x] fsipc %d %08x\n", thisenv-&gt;env_id, type, *(uint32_t *)&amp;fsipcbuf); ipc_send(fsenv, type, &amp;fsipcbuf, PTE_P | PTE_W | PTE_U); return ipc_recv(NULL, dstva, NULL);//目前来说 这个dstva 是个空值，所以实际上没啥返回值。 写回是通过共享页面实现的。共享了这个fsipcbuf&#125; 然后就发送到了我们原本说的serv.c里面去了。serv.c最终运行了serve。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162voidserve(void)&#123; uint32_t req, whom; int perm, r; void *pg; while (1) &#123; //明显是个无限循环，所以这个进程值在这运行 perm = 0; //在这等待接收，我们现在这种情况，就是接收到了 刚才发送的那个 req = ipc_recv((int32_t *) &amp;whom, fsreq, &amp;perm); if (debug) cprintf("fs req %d from %08x [page %08x: %s]\n", req, whom, uvpt[PGNUM(fsreq)], fsreq); // All requests must contain an argument page if (!(perm &amp; PTE_P)) &#123; cprintf("Invalid request from %08x: no argument page\n", whom); continue; // just leave it hanging... &#125; pg = NULL; if (req == FSREQ_OPEN) &#123; r = serve_open(whom, (struct Fsreq_open*)fsreq, &amp;pg, &amp;perm); &#125; else if (req &lt; ARRAY_SIZE(handlers) &amp;&amp; handlers[req]) &#123; //这个写法非常骚气， r = handlers[req](whom, fsreq);//这个时候根据req分配了函数。我们现在也就是serve_read &#125; else &#123; cprintf("Invalid request code %d from %08x\n", req, whom); r = -E_INVAL; &#125; ipc_send(whom, r, pg, perm); sys_page_unmap(0, fsreq); &#125;&#125;// 所以我们就跑到了这个函数// Read at most ipc-&gt;read.req_n bytes from the current seek position// in ipc-&gt;read.req_fileid. Return the bytes read from the file to// the caller in ipc-&gt;readRet, then update the seek position. Returns// the number of bytes successfully read, or &lt; 0 on error.//Fsipc 里面存了我们所需要的东西。intserve_read(envid_t envid, union Fsipc *ipc)&#123; struct Fsreq_read *req = &amp;ipc-&gt;read;//请求 struct Fsret_read *ret = &amp;ipc-&gt;readRet;//返回的结果 if (debug) cprintf("serve_read %08x %08x %08x\n", envid, req-&gt;req_fileid, req-&gt;req_n); // Lab 5: Your code here: int r=0; struct OpenFile *o; //openfile_lookup这个函数是查找 打开的文件 if ((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;o)) &lt; 0) return r; r=file_read(o-&gt;o_file,ret,req-&gt;req_n,o-&gt;o_fd-&gt;fd_offset); if(r&gt;=0)o-&gt;o_fd-&gt;fd_offset+=r; return r;&#125; write看完read，write也是一样的照搬就行了。 123456789101112131415161718192021// Write at most 'n' bytes from 'buf' to 'fd' at the current seek position.//// Returns:// The number of bytes successfully written.// &lt; 0 on error.static ssize_tdevfile_write(struct Fd *fd, const void *buf, size_t n)&#123; // Make an FSREQ_WRITE request to the file system server. Be // careful: fsipcbuf.write.req_buf is only so large, but // remember that write is always allowed to write *fewer* // bytes than requested. // LAB 5: Your code here if ( n &gt; sizeof (fsipcbuf.write.req_buf)) n = sizeof (fsipcbuf.write.req_buf); fsipcbuf.write.req_fileid = fd-&gt;fd_file.id; fsipcbuf.write.req_n = n; memmove(fsipcbuf.write.req_buf, buf, n); //先把写的内容复制 return fsipc(FSREQ_WRITE, NULL);//然后发送过去 //panic("devfile_write not implemented");&#125; 123456789101112131415161718192021// Write req-&gt;req_n bytes from req-&gt;req_buf to req_fileid, starting at// the current seek position, and update the seek position// accordingly. Extend the file if necessary. Returns the number of// bytes written, or &lt; 0 on error.intserve_write(envid_t envid, struct Fsreq_write *req)&#123; if (debug) cprintf("serve_write %08x %08x %08x\n", envid, req-&gt;req_fileid, req-&gt;req_n); // LAB 5: Your code here. int r=0; struct OpenFile *o; if ((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;o)) &lt; 0) return r; //前面肯定一样的 r=file_write(o-&gt;o_file,req-&gt;req_buf,req-&gt;req_n,o-&gt;o_fd-&gt;fd_offset);//不同的就只有这，这调用的是file_write if(r&gt;=0)o-&gt;o_fd-&gt;fd_offset+=r; return r; //panic("serve_write not implemented");&#125; 其他函数的调用过程自行分析了。 Spawning Processes我们已经给你提供了生成一个新的用户环境spawn的代码（参见lib/spawn.c），将文件系统中的程序镜像加载到用户环境中，然后启动运行此程序的子环境。然后，父进程继续独立于该子进程运行。spawn函数就像UNIX中fork后面紧接着在子进程中执行exec。 我们实现了spawn而不是一个UNIX风格的exec，因为在exkernel方式下，在用户空间不借助内核的特殊帮助中更容易实现spawn。想想你在用户空间实现exec时必须做什么，并确保你明白为什么更难。练习7 只要我们实现sys_env_set_trapframe。我们先看看spawn 做了啥123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134// Spawn a child process from a program image loaded from the file system. // 从文件加载了一个子进程// prog: the pathname of the program to run. 文件路径// argv: pointer to null-terminated array of pointers to strings, 参数// which will be passed to the child as its command-line arguments.// Returns child envid on success, &lt; 0 on failure.intspawn(const char *prog, const char **argv)&#123; unsigned char elf_buf[512]; struct Trapframe child_tf; envid_t child; int fd, i, r; struct Elf *elf; struct Proghdr *ph; int perm; // This code follows this procedure: // 后面虽然有一大堆，但是大部分没啥用 // - Open the program file. // // - Read the ELF header, as you have before, and sanity check its // magic number. (Check out your load_icode!) // 读取ELF // - Use sys_exofork() to create a new environment. // 创建进程 // - Set child_tf to an initial struct Trapframe for the child. // 设置tf // - Call the init_stack() function above to set up // the initial stack page for the child environment. // 初始化堆栈，有兴趣的自己看看看 后面都是写细节了 // - Map all of the program's segments that are of p_type // ELF_PROG_LOAD into the new environment's address space. // Use the p_flags field in the Proghdr for each segment // to determine how to map the segment: // // * If the ELF flags do not include ELF_PROG_FLAG_WRITE, // then the segment contains text and read-only data. // Use read_map() to read the contents of this segment, // and map the pages it returns directly into the child // so that multiple instances of the same program // will share the same copy of the program text. // Be sure to map the program text read-only in the child. // Read_map is like read but returns a pointer to the data in // *blk rather than copying the data into another buffer. // // * If the ELF segment flags DO include ELF_PROG_FLAG_WRITE, // then the segment contains read/write data and bss. // As with load_icode() in Lab 3, such an ELF segment // occupies p_memsz bytes in memory, but only the FIRST // p_filesz bytes of the segment are actually loaded // from the executable file - you must clear the rest to zero. // For each page to be mapped for a read/write segment, // allocate a page in the parent temporarily at UTEMP, // read() the appropriate portion of the file into that page // and/or use memset() to zero non-loaded portions. // (You can avoid calling memset(), if you like, if // page_alloc() returns zeroed pages already.) // Then insert the page mapping into the child. // Look at init_stack() for inspiration. // Be sure you understand why you can't use read_map() here. // // Note: None of the segment addresses or lengths above // are guaranteed to be page-aligned, so you must deal with // these non-page-aligned values appropriately. // The ELF linker does, however, guarantee that no two segments // will overlap on the same page; and it guarantees that // PGOFF(ph-&gt;p_offset) == PGOFF(ph-&gt;p_va). // // - Call sys_env_set_trapframe(child, &amp;child_tf) to set up the // correct initial eip and esp values in the child. // // - Start the child process running with sys_env_set_status(). if ((r = open(prog, O_RDONLY)) &lt; 0) return r; fd = r; // Read elf header elf = (struct Elf*) elf_buf; //readn 在fd.c里面 可以看看底层调用了 dev_read 应该就是前面实现的那个函数 if (readn(fd, elf_buf, sizeof(elf_buf)) != sizeof(elf_buf)//读取elf 头部 || elf-&gt;e_magic != ELF_MAGIC) &#123; close(fd); cprintf("elf magic %08x want %08x\n", elf-&gt;e_magic, ELF_MAGIC); return -E_NOT_EXEC; &#125; // Create new child environment if ((r = sys_exofork()) &lt; 0) return r; child = r; //复制进程 // Set up trap frame, including initial stack.初始化tf child_tf = envs[ENVX(child)].env_tf; child_tf.tf_eip = elf-&gt;e_entry; if ((r = init_stack(child, argv, &amp;child_tf.tf_esp)) &lt; 0) return r; // Set up program segments as defined in ELF header. 这个很眼熟吧 ph = (struct Proghdr*) (elf_buf + elf-&gt;e_phoff); for (i = 0; i &lt; elf-&gt;e_phnum; i++, ph++) &#123; if (ph-&gt;p_type != ELF_PROG_LOAD) continue; perm = PTE_P | PTE_U; if (ph-&gt;p_flags &amp; ELF_PROG_FLAG_WRITE) perm |= PTE_W; if ((r = map_segment(child, ph-&gt;p_va, ph-&gt;p_memsz, fd, ph-&gt;p_filesz, ph-&gt;p_offset, perm)) &lt; 0) goto error; &#125; close(fd); fd = -1; // Copy shared library state. if ((r = copy_shared_pages(child)) &lt; 0) panic("copy_shared_pages: %e", r); child_tf.tf_eflags |= FL_IOPL_3; // devious: see user/faultio.c if ((r = sys_env_set_trapframe(child, &amp;child_tf)) &lt; 0)//在这个地方调用了sys_env_set_trapframe 我们可以看到 child_tf 前面已经帮我们设置好了。 panic("sys_env_set_trapframe: %e", r); if ((r = sys_env_set_status(child, ENV_RUNNABLE)) &lt; 0) panic("sys_env_set_status: %e", r); return child;error: sys_env_destroy(child); close(fd); return r;&#125; 因为传进来的tf已经设置好了，所以我们直接改就行了123456789101112131415161718192021222324// Set envid's trap frame to 'tf'.// tf is modified to make sure that user environments always run at code// protection level 3 (CPL 3), interrupts enabled, and IOPL of 0.//// Returns 0 on success, &lt; 0 on error. Errors are:// -E_BAD_ENV if environment envid doesn't currently exist,// or the caller doesn't have permission to change envid.static intsys_env_set_trapframe(envid_t envid, struct Trapframe *tf)&#123; // LAB 5: Your code here. // Remember to check whether the user has supplied us with a good // address! struct Env *child; if((envid2env(envid,&amp;child,1))&lt;0)&#123; return -E_BAD_ENV; &#125;//判断进程id 是不是有效的 child-&gt;env_tf=*tf;//直接指过去 child-&gt;env_tf.tf_cs |= 0x3; //修改一下提示要求的值 child-&gt;env_tf.tf_eflags &amp;= (~FL_IOPL_MASK); child-&gt;env_tf.tf_eflags |= FL_IF; return 0; //panic("sys_env_set_trapframe not implemented");&#125; 设置完后记得添加syscall.12 case SYS_env_set_trapframe:return sys_env_set_trapframe((envid_t)a1,(struct Trapframe*)a2); 说一下我测试的时候发现，测试文件里面有一个单词和代码不一样。在grade-lab5里面有一个environments单词和代码里面差了一个a,我修改了一下，如果没错的话，当我没说。environments和environmeants搜了一下单词意思好像是一样的。1234567@test(10, "spawn via spawnhello")def test_spawn(): r.user_test("spawnhello") r.match('i am parent environment 00001001', 'hello, world', 'i am environment 00001002', 'No runnable environmeants in the system!') Sharing library state across fork and spawnUNIX文件描述符是一个普遍的概念，它包括管道，控制台I/O等。在JOS中，每一个这样的设备类型的都具有相应的struct Dev，该结构体中有指向实现该设备类型读/写等操作的函数指针。lib/fd.c在struct Dev之上实现了一般的类UNIX文件描述符接口。每个struct Fd表示其设备类型，并且lib/fd.c中的大多数函数简单地将操作分发到合适的struct Dev中的函数。 lib/fd.c还在每个应用程序环境的地址空间虚拟地址FDTABLE开始中处护文件描述符表区域。该区域为应用程序可以一次能最多打开MAXFD（当前为32）个文件描述符的每个文件描述符保留一个页面（4KB）大小的地址空间。在任何时候，当且仅当相应的文件描述符被使用时，文件描述符表页会被映射。每个文件描述符还有一个在FILEDATA开始的区域可选的“数据页”，如果选择了数据区域，设备就可以使用该区域。 我们想在fork和spawn之间共享文件描述符状态，但文件描述符状态保存在用户空间内存中。现在，fork完成之后，内存将被标记为copy-on-write，所以状态将被重复而不是共享。 （这意味着环境将无法在他们没有打开自己的文件中查找，并且管道将在fork之后也不能运行。）spawn完成之后，内存将被丢弃，完全不会被复制。（有效地，spawn的用户环境在没有打开的文件描述符状态下开始运行。） 我们将更改fork，让fork时了解某些区域的内存是由“库操作系统”使用，应始终共享。而不是在某个地方硬编码一个区域列表，我们将在页表项中设置一个未使用的位（就像我们在fork中使用PTE_COW位一样）来确定共享区域。 我们已经在inc/lib.h中定义了一个新的PTE_SHARE位。该位是Intel和AMD手册中标记为“可用于软件使用”的三个PTE位之一。我们约定，如果一个页表项中该位置位，应该在fork和spawn中直接将该PTE从父对象复制到子环境。请注意，这不同于标记PTE为copy-on-write：如第一段所述，我们要确保共享页面更新。简单来说，就是我们定义了一个PTE_SHARE位，表示分享这个页，分享的这个页不用写时复制。练习8 就是修改了这些东西。添加一个if就行了。12345678910111213141516171819202122static intduppage(envid_t envid, unsigned pn)&#123; int r; // LAB 4: Your code here. void* vaddr=(void*)(pn*PGSIZE); if(uvpt[pn]&amp;PTE_SHARE)&#123;//多添加这个if就行了 if((r=sys_page_map(0,vaddr,envid,vaddr,uvpt[pn]&amp;PTE_SYSCALL))&lt;0)return r; &#125; else if((uvpt[pn] &amp; PTE_W) || (uvpt[pn] &amp; PTE_COW))&#123; if ((r = sys_page_map(0, vaddr, envid, vaddr, PTE_P | PTE_U | PTE_COW)) &lt; 0) return r; if ((r = sys_page_map(0, vaddr, 0, vaddr, PTE_P | PTE_U | PTE_COW)) &lt; 0) return r; &#125; else if((r = sys_page_map(0, vaddr, envid, vaddr, PTE_P | PTE_U)) &lt; 0) &#123; return r; &#125; //panic("duppage not implemented"); return 0;&#125; 另外一个直接暴力找就行了没啥太大的区别。1234567891011121314// Copy the mappings for shared pages into the child address space.static intcopy_shared_pages(envid_t child)&#123; // LAB 5: Your code here. int r=0,pn=0; for (pn=PGNUM(UTEXT); pn&lt;PGNUM(USTACKTOP); pn++)&#123; if ((uvpd[pn &gt;&gt; 10] &amp; PTE_P) &amp;&amp;uvpt[pn] &amp; PTE_SHARE) if ( (r = sys_page_map(thisenv-&gt;env_id, (void *)(pn*PGSIZE), child, (void *)(pn*PGSIZE), uvpt[pn] &amp; PTE_SYSCALL )) &lt; 0) return r; &#125; return 0;&#125; The keyboard interface倒着之后，实验让我们做的东西非常简单，但是又有好多东西还没搞清楚。 为了使shell工作，我们需要一种方法在shell中输入。 QEMU一直在显示我们在CGA显示器和串行端口的输出内容，但到目前为止，我们只能在内核监视器中输入。在QEMU中，在图形窗口中的输入显示为从键盘输入到JOS，从控制台的输入显示为串行端口上的字符。kern/console.c包含键盘和串行驱动程序，从lab1开始内核监视器就一直在使用，但现在你需要将它们附加到系统的其余部分。练习9让我们添加kbd_intr处理IRQ_OFFSET+IRQ_KBD和 serial_intr处理IRQ_OFFSET+IRQ_SERIAL。直接在trap_dispatch添加就行了。12345678910case IRQ_OFFSET+IRQ_KBD:&#123; lapic_eoi(); kbd_intr(); break;&#125;case IRQ_OFFSET+IRQ_SERIAL:&#123; lapic_eoi(); serial_intr(); break;&#125; 我们在lib/console.c中为你实现了控制台输入/输出文件类型。kbd_intr和serial_intr用最近读取的输入填充缓冲区，控制台文件类型清空缓冲区（默认情况下，控制台文件类型用于stdin/stdout，除非用户重定向它们）。 The Shell运行make run-icode或make run-icode-nox命令。这将运行您的内核并启动user/icode。icode spawn init，它将控制台设置为文件描述符0和1（标准输入和标准输出）。然后spawn sh，shell程序。你应该能够运行以下命令： echo hello world | catcat lorem |catcat lorem |numcat lorem |num |num |num |num |numlsfd 请注意，用户库例程cprintf直接打印到控制台，而不使用文件描述符代码。这适用于调试，但不适合与其他程序进行管道通信。要将输出打印到特定文件描述符（例如，1，标准输出），请使用fprintf（1，“...”，...）。 printf（“...”，...）是打印到FD 1的快捷方式。有关示例，请参阅user/lsfd.c。练习10 让我们实现user/sh.c里面的&lt;重定向,里面就有&gt;的重定向，复制一下就没了。123456789// LAB 5: Your code here.if ((fd = open(t, O_RDONLY)) &lt; 0) &#123; cprintf("open %s for write: %e", t, fd); exit();&#125;if (fd != 1) &#123; dup(fd, 0); close(fd);&#125; 到这里我们就做完了所有练习了。然而我并不知道后面发生了什么。所以我们来分析用户文件。直接make qemu,会输出下面这些东西。123456789101112131415/*在这之前的一大堆 都是 内核，和文件系统造成的*/icode: read /motdThis is /motd, the message of the day.Welcome to the JOS kernel, now with a file system!icode: close /motdicode: spawn /initicode: exitinginit: runninginit: data seems okayinit: bss seems okayinit: args: 'init' 'initarg1' 'initarg2'init: running shinit: starting sh 我们首先进入了user/icode.c这个文件里面的umain，也就是内核里面的那个环境创建运行的那个。1234567891011121314151617181920212223242526272829#include &lt;inc/lib.h&gt;voidumain(int argc, char **argv)&#123; int fd, n, r; char buf[512+1]; binaryname = "icode"; cprintf("icode startup\n"); cprintf("icode: open /motd\n");//这几个值都看到了 if ((fd = open("/motd", O_RDONLY)) &lt; 0)//打开根目录下的/motd panic("icode: open /motd: %e", fd); //我门可以找到find 找到motd 文件在 ./fs/ 目录下，所以fs 就是我们的根目录 cprintf("icode: read /motd\n"); while ((n = read(fd, buf, sizeof buf-1)) &gt; 0)//读取了buf 个字符 sys_cputs(buf, n);//输出了他 cprintf("icode: close /motd\n"); close(fd); cprintf("icode: spawn /init\n"); if ((r = spawnl("/init", "init", "initarg1", "initarg2", (char*)0)) &lt; 0) panic("icode: spawn /init: %e", r); //用spawnl创建了init ，所以接下来我们去了init cprintf("icode: exiting\n");&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;inc/lib.h&gt;struct &#123; char msg1[5000]; char msg2[1000];&#125; data = &#123; "this is initialized data", "so is this"&#125;;char bss[6000];intsum(const char *s, int n)&#123; int i, tot = 0; for (i = 0; i &lt; n; i++) tot ^= i * s[i]; return tot;&#125;voidumain(int argc, char **argv)&#123; int i, r, x, want; char args[256]; //前面一大堆是初始化用的 cprintf("init: running\n"); want = 0xf989e; if ((x = sum((char*)&amp;data, sizeof data)) != want) cprintf("init: data is not initialized: got sum %08x wanted %08x\n", x, want); else cprintf("init: data seems okay\n"); if ((x = sum(bss, sizeof bss)) != 0) cprintf("bss is not initialized: wanted sum 0 got %08x\n", x); else cprintf("init: bss seems okay\n"); // output in one syscall per line to avoid output interleaving strcat(args, "init: args:"); for (i = 0; i &lt; argc; i++) &#123; strcat(args, " '"); strcat(args, argv[i]); strcat(args, "'"); &#125; cprintf("%s\n", args); cprintf("init: running sh\n"); // being run directly from kernel, so no file descriptors open yet close(0);//因为根目录是在内二上，所以没有文件打开。 if ((r = opencons()) &lt; 0)//打开控制台？？ panic("opencons: %e", r); if (r != 0) panic("first opencons used fd %d", r); if ((r = dup(0, 1)) &lt; 0)//把0复制到了 1 panic("dup: %e", r); while (1) &#123; cprintf("init: starting sh\n"); r = spawnl("/sh", "sh", (char*)0);//这个时候又跑了sh if (r &lt; 0) &#123; cprintf("init: spawn sh: %e\n", r); continue; &#125; wait(r);//然后无线循环这个程序 &#125;&#125; sh里面就是我们的shell了，告辞。]]></content>
      <categories>
        <category>操作系统</category>
        <category>MIT6.828</category>
      </categories>
      <tags>
        <tag>MIT6.828</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT6.828(四)Lab4:Preemptive Multitasking]]></title>
    <url>%2F2020%2F02%2F18%2FMIT-6.828-(%E5%9B%9B)-Lab-4-Preemptive-Multitasking%2F</url>
    <content type="text"><![CDATA[为了方便查看最终源码，我将代码放到了我的github上。后面会把前面lab的也会添加进去。lab4有很多细节，所以有些东西我会分一下测试程序。 Lab 4: Preemptive Multitasking PartA: 为JOS增添多处理器支持特性。 实现round-robin scheduling循环调度。 添加一个基本的环境（进程）管理系统调用（创建和销毁环境，分配和映射内存）。 PartB: 实现一个类Unix的fork(),其允许一个用户模式的环境能创建一份它自身的拷贝。 PartC: 支持进程间通信（inter-process communication, IPC） 支持硬件时钟中断和抢占 做个大致介绍让你明白要做啥。然后就让你切换到lab4，每个lab 必须做的事情，然后会多出来一些文件。每个文件的作用看翻译应该就能明白，在我的github每个文件最前面也有注释。 Part A: Multiprocessor Support and Cooperative Multitasking先是一堆介绍，就是告诉你要实现轮转调度。后面会为你实现抢占式调度。还有要多CPU 支持。 Multiprocessor Support我们将让 JOS 支持对称多处理器（symmetric multiprocessing，SMP），具体是什么东西自己去看讲操作系统的书。CPU功能基本都是一样的，但是在引导过程中可以分为两类： 引导处理器（BSP）：负责初始化系统和引导操作系统; 应用程序处理器（AP）：只有在操作系统启动并运行后，BSP才会激活应用程序处理器。 在我们前面所做过的所有实验都是在BSP上面，现在我们要做的就是在BSP上启动AP。对于哪一个CPU是BSP是硬件决定的。每个CPU都有自己的APIC，也就是LAPIC。APIC 一句话来说就是可编程中断。 根据LAPIC识别码(APIC ID)区别我们的代码运行在哪个CPU上。（cpunum()） 从BSP向APs发送STARTUP处理器间中断（IPI）去唤醒其他的CPU。（lapic_startap()） 在Part C，我们编写LAPIC的内置定时器来触发时钟中断，以支持抢占式多任务（pic_init()）。 对于这些我们来看看这个文件kern/lapic.c，一如既往，我们不用知道具体实现，知道一些重要的东西就行。 lapic.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185// The local APIC manages internal (non-I/O) interrupts.// See Chapter 8 &amp; Appendix C of Intel processor manual volume 3./*Kernel code driving the local APIC unit in each processor内核代码 用来读取每个处理器地方APIC单元。不知道是用来干啥的 */#include &lt;inc/types.h&gt;#include &lt;inc/memlayout.h&gt;#include &lt;inc/trap.h&gt;#include &lt;inc/mmu.h&gt;#include &lt;inc/stdio.h&gt;#include &lt;inc/x86.h&gt;#include &lt;kern/pmap.h&gt;#include &lt;kern/cpu.h&gt;// Local APIC registers, divided by 4 for use as uint32_t[] indices. // LAPIC 寄存器 用4分成一个个索引。#define ID (0x0020/4) // ID#define VER (0x0030/4) // Version#define TPR (0x0080/4) // Task Priority#define EOI (0x00B0/4) // EOI#define SVR (0x00F0/4) // Spurious Interrupt Vector 伪中断向量 #define ENABLE 0x00000100 // Unit Enable 单元可用#define ESR (0x0280/4) // Error Status 错误信息#define ICRLO (0x0300/4) // Interrupt Command #define INIT 0x00000500 // INIT/RESET 初始化 #define STARTUP 0x00000600 // Startup IPI 开始IPI #define DELIVS 0x00001000 // Delivery status #define ASSERT 0x00004000 // Assert interrupt (vs deassert) #define DEASSERT 0x00000000 #define LEVEL 0x00008000 // Level triggered #define BCAST 0x00080000 // Send to all APICs, including self. #define OTHERS 0x000C0000 // Send to all APICs, excluding self. #define BUSY 0x00001000 #define FIXED 0x00000000#define ICRHI (0x0310/4) // Interrupt Command [63:32]#define TIMER (0x0320/4) // Local Vector Table 0 (TIMER) #define X1 0x0000000B // divide counts by 1 #define PERIODIC 0x00020000 // Periodic#define PCINT (0x0340/4) // Performance Counter LVT#define LINT0 (0x0350/4) // Local Vector Table 1 (LINT0)#define LINT1 (0x0360/4) // Local Vector Table 2 (LINT1)#define ERROR (0x0370/4) // Local Vector Table 3 (ERROR) #define MASKED 0x00010000 // Interrupt masked#define TICR (0x0380/4) // Timer Initial Count#define TCCR (0x0390/4) // Timer Current Count#define TDCR (0x03E0/4) // Timer Divide Configurationphysaddr_t lapicaddr; // Initialized in mpconfig.cvolatile uint32_t *lapic;static voidlapicw(int index, int value)&#123; lapic[index] = value; lapic[ID]; // wait for write to finish, by reading&#125;voidlapic_init(void) //这个到很part C 才会用到，用于抢占式调度&#123; if (!lapicaddr) return; // lapicaddr is the physical address of the LAPIC's 4K MMIO //映射这个地址能让我用虚拟地址访问 // region. Map it in to virtual memory so we can access it. lapic = mmio_map_region(lapicaddr, 4096); // Enable local APIC; set spurious interrupt vector. 开启 伪中断 lapicw(SVR, ENABLE | (IRQ_OFFSET + IRQ_SPURIOUS)); // The timer repeatedly counts down at bus frequency // from lapic[TICR] and then issues an interrupt. // If we cared more about precise timekeeping, //重负时间中断，可以用外面时钟来校准 // TICR would be calibrated using an external time source. lapicw(TDCR, X1); lapicw(TIMER, PERIODIC | (IRQ_OFFSET + IRQ_TIMER)); lapicw(TICR, 10000000); // Leave LINT0 of the BSP enabled so that it can get // interrupts from the 8259A chip. //不懂啥意思 // According to Intel MP Specification, the BIOS should initialize // BSP's local APIC in Virtual Wire Mode, in which 8259A's // INTR is virtually connected to BSP's LINTIN0. In this mode, // we do not need to program the IOAPIC. if (thiscpu != bootcpu) lapicw(LINT0, MASKED); // Disable NMI (LINT1) on all CPUs 这个也不知道 lapicw(LINT1, MASKED); // Disable performance counter overflow interrupts // on machines that provide that interrupt entry. if (((lapic[VER]&gt;&gt;16) &amp; 0xFF) &gt;= 4) lapicw(PCINT, MASKED); // Map error interrupt to IRQ_ERROR. 映射错误中断 lapicw(ERROR, IRQ_OFFSET + IRQ_ERROR); // Clear error status register (requires back-to-back writes). 清楚寄存器 lapicw(ESR, 0); lapicw(ESR, 0); // Ack any outstanding interrupts. lapicw(EOI, 0); // Send an Init Level De-Assert to synchronize arbitration ID's. lapicw(ICRHI, 0); lapicw(ICRLO, BCAST | INIT | LEVEL); while(lapic[ICRLO] &amp; DELIVS) ; // Enable interrupts on the APIC (but not on the processor).启用 中断 lapicw(TPR, 0);&#125;intcpunum(void) //这个用到的非常多，返回当前CPU是第几个&#123; if (lapic) return lapic[ID] &gt;&gt; 24; return 0;&#125;// Acknowledge interrupt. 确认中断，没怎么用到voidlapic_eoi(void)&#123; if (lapic) lapicw(EOI, 0);&#125;// Spin for a given number of microseconds.// On real hardware would want to tune this dynamically.static voidmicrodelay(int us)&#123;&#125;#define IO_RTC 0x70// Start additional processor running entry code at addr. 启动额外处理器 后面就会用到// See Appendix B of MultiProcessor Specification.voidlapic_startap(uint8_t apicid, uint32_t addr)&#123; int i; uint16_t *wrv; // "The BSP must initialize CMOS shutdown code to 0AH // and the warm reset vector (DWORD based at 40:67) to point at // the AP startup code prior to the [universal startup algorithm]." outb(IO_RTC, 0xF); // offset 0xF is shutdown code outb(IO_RTC+1, 0x0A); wrv = (uint16_t *)KADDR((0x40 &lt;&lt; 4 | 0x67)); // Warm reset vector wrv[0] = 0; wrv[1] = addr &gt;&gt; 4; // "Universal startup algorithm." // Send INIT (level-triggered) interrupt to reset other CPU. lapicw(ICRHI, apicid &lt;&lt; 24); lapicw(ICRLO, INIT | LEVEL | ASSERT); microdelay(200); lapicw(ICRLO, INIT | LEVEL); microdelay(100); // should be 10ms, but too slow in Bochs! // Send startup IPI (twice!) to enter code. // Regular hardware is supposed to only accept a STARTUP // when it is in the halted state due to an INIT. So the second // should be ignored, but it is part of the official Intel algorithm. // Bochs complains about the second one. Too bad for Bochs. for (i = 0; i &lt; 2; i++) &#123; lapicw(ICRHI, apicid &lt;&lt; 24); lapicw(ICRLO, STARTUP | (addr &gt;&gt; 12)); microdelay(200); &#125;&#125;voidlapic_ipi(int vector)&#123; lapicw(ICRLO, OTHERS | FIXED | vector); while (lapic[ICRLO] &amp; DELIVS) ;&#125; 看了上面的，其实啥都不知道，就耽误了下时间。。。。LAPIC的 hole 开始于物理地址0xFE000000(4GB之下的32MB)，但是这地址太高我们无法访问通过过去的直接映射(虚拟地址0xF0000000映射0x0，即只有256MB)。但是JOS虚拟地址映射预留了4MB空间在MMIOBASE处，我们需要分配映射空间。练习 1 要我们实现 kern/pmap.c 里的mmio_map_region，刚才我们上面那个文件有一句lapic = mmio_map_region(lapicaddr, 4096);。和我们实现过的boot_map_region很像，照着来就行了。12345678910111213141516171819202122232425262728293031323334353637383940//// Reserve size bytes in the MMIO region and map [pa,pa+size) at this// location. Return the base of the reserved region. size does *not*// have to be multiple of PGSIZE.// 映射 size 大小的 空间，必须页对齐。void *mmio_map_region(physaddr_t pa, size_t size)&#123; // Where to start the next region. Initially, this is the // beginning of the MMIO region. Because this is static, its // value will be preserved between calls to mmio_map_region // (just like nextfree in boot_alloc). //这个和boot_alloc 是一样的，下一次进入这个函数地址就是上一个地址 的后面 static uintptr_t base = MMIOBASE; // Reserve size bytes of virtual memory starting at base and // map physical pages [pa,pa+size) to virtual addresses 映射pa 到base // [base,base+size). Since this is device memory and not 因为不是DRAM 内存 // regular DRAM, you'll have to tell the CPU that it isn't 你不许告诉CPU是不安全的去高速缓存直接访问这个内存。 // safe to cache access to this memory. Luckily, the page 幸运的是 页表提供这种模板 // tables provide bits for this purpose; simply create the 简单的用了两个标志位PTE_PCD|PTE_PWT // mapping with PTE_PCD|PTE_PWT (cache-disable and // write-through) in addition to PTE_W. (If you're interested // in more details on this, see section 10.5 of IA32 volume // 3A.) // // Be sure to round size up to a multiple of PGSIZE and to //确保也对其 没有溢出 MMIOLIM 不然就是 panic // handle if this reservation would overflow MMIOLIM (it's // okay to simply panic if this happens). // // Hint: The staff solution uses boot_map_region. // // Your code here: size = ROUNDUP(size, PGSIZE);//页对齐然后映射 后面这个标志位，就是前面设定的 //个人感觉如果这个地方溢出了应该要判断一下，但是好像并没有这个测试所以好像没啥问题。 boot_map_region(kern_pgdir, base, size, pa, PTE_W | PTE_PWT | PTE_PCD); base += size; return (void *)base-size; //github 上面和这个不一样但是差距也不大。 //panic("mmio_map_region not implemented");&#125; Application Processor Bootstrap在我们启动APs之前BSP需要收集他们的信息。比如数量，APICID 和他们映射的地址。kern/mpconfig.c里面的mp_init就是干这个的。我们去看看他在哪调用的，这些东西肯定是在初始化函数里面。 i386_init123456789101112131415161718192021222324252627282930313233343536373839voidi386_init(void)&#123; // Initialize the console. // Can't call cprintf until after we do this! cons_init(); cprintf("6828 decimal is %o octal!\n", 6828); // Lab 2 memory management initialization functions mem_init(); // Lab 3 user environment initialization functions env_init(); trap_init(); //在这之前都是没有变的。 // Lab 4 multiprocessor initialization functions mp_init(); //这个就是收集信息。 lapic_init();//初始化自己lapic 这个时候其他CPU还没有启动，此时还是BSP // Lab 4 multitasking initialization functions pic_init(); //多作业初始化，等会要看看 // Acquire the big kernel lock before waking up APs // Your code here: lock_kernel(); //这个是我写的，是后面的，不用着急。 // Starting non-boot CPUs boot_aps(); //这个地方就是引导程序了。#if defined(TEST) // Don't touch -- used by grading script! ENV_CREATE(TEST, ENV_TYPE_USER);#else // Touch all you want. ENV_CREATE(user_primes, ENV_TYPE_USER); #endif // TEST* // Schedule and run the first user environment!开始调度 sched_yield();&#125; 看完后我们去看看mp_init()。并没有要我们实现，过一眼就行了，由于注释太少，所以没看懂。知道他把所有CPU信息收集完就行了。boot_aps() 是引导其他CPU启动的。他和bootloader 差不多。所以他也是从实模式开始的。我们将kern/mpentry.S加载到0x7000，很眼熟…,好像只要是没有用的页对齐的低于640的地址都可以。然后欧美就去看看他做了啥。 boot_aps123456789101112131415161718192021222324252627// Start the non-boot (AP) processors.static voidboot_aps(void)&#123; extern unsigned char mpentry_start[], mpentry_end[]; //那段代码的开始和结束 void *code; struct CpuInfo *c; // Write entry code to unused memory at MPENTRY_PADDR #define MPENTRY_PADDR 0x7000 code = KADDR(MPENTRY_PADDR); //找到这个地址 在memlayout 里面宏定义了。 memmove(code, mpentry_start, mpentry_end - mpentry_start);//把代码复制进去 // Boot each AP one at a time for (c = cpus; c &lt; cpus + ncpu; c++) &#123; //CPUS 是啥 NCPU 是啥？？？ 就是前面那个我们没有讲的文件里面收集的，cpus 是 所有CPUS的数组，ncpu 是个数 if (c == cpus + cpunum()) // We've started already. 不是自己这个CPU continue; // Tell mpentry.S what stack to use 这个是每个CPU的栈，现在还没有映射，等会要做的就是这个 mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE; // Start the CPU at mpentry_start lapic_startap(c-&gt;cpu_id, PADDR(code)); //这个就是开始启动CPUS4了 // Wait for the CPU to finish some basic setup in mp_main() while(c-&gt;cpu_status != CPU_STARTED) //等待这个CPU启动玩 ; //在 mp_main里有这么一行 xchg(&amp;thiscpu-&gt;cpu_status, CPU_STARTED); // tell boot_aps() we're up &#125;&#125; 然后我们去看看mp_main()在哪进入的。我们能够看出boot_aps,让我慢慢跑去了mpentry_start。 mpentry_start12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/* See COPYRIGHT for copyright information. *//*Assembly-language entry code for non-boot CPUs 汇编代码启动 非引导CPU 应该不会要动，这种东西一般都是固定的*/#include &lt;inc/mmu.h&gt;#include &lt;inc/memlayout.h&gt;#################################################################### entry point for APs#################################################################### Each non-boot CPU ("AP") is started up in response to a STARTUP# IPI from the boot CPU. Section B.4.2 of the Multi-Processor# Specification says that the AP will start in real mode with CS:IP# set to XY00:0000, where XY is an 8-bit value sent with the# STARTUP. Thus this code must start at a 4096-byte boundary.# 代码必须从4096开始运行，和那个bootloader 没多大差距，除了我们能控制在哪运行# Because this code sets DS to zero, it must run from an address in# the low 2^16 bytes of physical memory.## boot_aps() (in init.c) copies this code to MPENTRY_PADDR (which# satisfies the above restrictions). Then, for each AP, it stores the# address of the pre-allocated per-core stack in mpentry_kstack, sends# the STARTUP IPI, and waits for this code to acknowledge that it has# started (which happens in mp_main in init.c).## This code is similar to boot/boot.S except that# - it does not need to enable A20# - it uses MPBOOTPHYS to calculate absolute addresses of its# symbols, rather than relying on the linker to fill them#define RELOC(x) ((x) - KERNBASE)#define MPBOOTPHYS(s) ((s) - mpentry_start + MPENTRY_PADDR) //这个是因为BSP已经是在保护模式下了没法直接访问，当前CPU又在实模式，是不能访问呢 1M以上的内存，所以要映射一下。.set PROT_MODE_CSEG, 0x8 # kernel code segment selector.set PROT_MODE_DSEG, 0x10 # kernel data segment selector.code16 .globl mpentry_startmpentry_start: cli xorw %ax, %ax movw %ax, %ds movw %ax, %es movw %ax, %ss lgdt MPBOOTPHYS(gdtdesc) movl %cr0, %eax orl $CR0_PE, %eax movl %eax, %cr0 ljmpl $(PROT_MODE_CSEG), $(MPBOOTPHYS(start32)).code32start32: movw $(PROT_MODE_DSEG), %ax movw %ax, %ds movw %ax, %es movw %ax, %ss movw $0, %ax movw %ax, %fs movw %ax, %gs # Set up initial page table. We cannot use kern_pgdir yet because # we are still running at a low EIP. movl $(RELOC(entry_pgdir)), %eax movl %eax, %cr3 # Turn on paging. movl %cr0, %eax orl $(CR0_PE|CR0_PG|CR0_WP), %eax movl %eax, %cr0 # Switch to the per-cpu stack allocated in boot_aps() movl mpentry_kstack, %esp movl $0x0, %ebp # nuke frame pointer # Call mp_main(). (Exercise for the reader: why the indirect call?) 在这个地方我们跑去了 mp_main movl $mp_main, %eax call *%eax # If mp_main returns (it shouldn't), loop.spin: jmp spin# Bootstrap GDT.p2align 2 # force 4 byte alignmentgdt: SEG_NULL # null seg SEG(STA_X|STA_R, 0x0, 0xffffffff) # code seg SEG(STA_W, 0x0, 0xffffffff) # data seggdtdesc: .word 0x17 # sizeof(gdt) - 1 .long MPBOOTPHYS(gdt) # address gdt.globl mpentry_endmpentry_end: nop 再看看mp_main1234567891011121314151617181920212223// Setup code for APsvoidmp_main(void)&#123; // We are in high EIP now, safe to switch to kern_pgdir lcr3(PADDR(kern_pgdir)); //加载内核页 cprintf("SMP: CPU %d starting\n", cpunum()); lapic_init();//这三个初始化一些东西，应该看的出初始化了啥。 env_init_percpu(); trap_init_percpu(); xchg(&amp;thiscpu-&gt;cpu_status, CPU_STARTED); // tell boot_aps() we're up // Now that we have finished some basic setup, call sched_yield() // to start running processes on this CPU. But make sure that // only one CPU can enter the scheduler at a time! // // Your code here: lock_kernel();//这个是内核锁，后面会讲的。 // Remove this after you finish Exercise 6 //for (;;); sched_yield();&#125; 我们练习2让我们再开一些内存给他启动用。这个地方我在思考，运行完之后难道不用把这块内存重新加入内存空闲列表吗？？在我们page_init 后面继续添加几行就可以了。1234567// LAB 4:// Change your code to mark the physical page at MPENTRY_PADDR// as in use// 把MPENTRY_PADDR这块地址也在空闲列表里面删除。uint32_t range_mpentry = PGNUM(MPENTRY_PADDR);pages[range_mpentry+1].pp_link=pages[range_mpentry].pp_link;pages[range_mpentry].pp_link=NULL; Question boot.S中，由于尚没有启用分页机制，所以我们能够指定程序开始执行的地方以及程序加载的地址；但是，在mpentry.S的时候，由于主CPU已经处于保护模式下了，因此是不能直接指定物理地址的，给定线性地址，映射到相应的物理地址是允许的。 Per-CPU State and Initialization在多处理器CPU中，知道自己是哪个CPU十分重要。前面我们已经分析过怎么获取所有CPU的信息 (假装我们知道过程)。kern/cpu.h里面定义了各种我们想要的信息。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*Kernel-private definitions for multiprocessor support多处理器支持的私有内核定义应该是 定义了 多处理器的一些操作 */#ifndef JOS_INC_CPU_H#define JOS_INC_CPU_H#include &lt;inc/types.h&gt;#include &lt;inc/memlayout.h&gt;#include &lt;inc/mmu.h&gt;#include &lt;inc/env.h&gt;// Maximum number of CPUs#define NCPU 8// Values of status in struct Cpuenum &#123; //这个是CPU状态 CPU_UNUSED = 0, CPU_STARTED, CPU_HALTED,&#125;;// Per-CPU statestruct CpuInfo &#123; //CPU信息 uint8_t cpu_id; // Local APIC ID; index into cpus[] below 第几个CPU volatile unsigned cpu_status; // The status of the CPU 状态 struct Env *cpu_env; // The currently-running environment. 当前运行的环境 struct Taskstate cpu_ts; // Used by x86 to find stack for interrupt cpu中断栈&#125;;// Initialized in mpconfig.cextern struct CpuInfo cpus[NCPU]; //这几个就是收集到的信息...extern int ncpu; // Total number of CPUs in the system 数量extern struct CpuInfo *bootcpu; // The boot-strap processor (BSP) BSP的信息extern physaddr_t lapicaddr; // Physical MMIO address of the local APIC 物理地址// Per-CPU kernel stacksextern unsigned char percpu_kstacks[NCPU][KSTKSIZE]; ///每个CPU的内核栈 int cpunum(void); //获取自己这个CPU的id#define thiscpu (&amp;cpus[cpunum()]) //指向自己这个CPUvoid mp_init(void); //收集所有CPU信息void lapic_init(void);//中断初始化void lapic_startap(uint8_t apicid, uint32_t addr);//CPU启动void lapic_eoi(void);//Acknowledge interrupt.void lapic_ipi(int vector);//不知道是啥#endif 每个CPU独有的属性： Per-CPU kernel stack，因为不同的CPU可能同时陷入到内核，因此每个CPU需要有不同的内核栈防止彼此之间的干扰。数组percpu_kstacks[NCPU][KSTKSIZE]给NCPU个CPU保留了内核栈的空间。在lab2中，将物理地址bootstack映射到BSP的内核栈的虚拟地址KSTACKTOP-KSTKSIZE。相似的，在本次实验中，你将映射每个CPU的内核栈到这个区域，并且每个栈之间相隔一个guard pages作为缓冲。CPU0的栈将从KSTACKTOP向下增长，CPU 1的栈将在CPU 0的栈增长方向的底部之后的KSTKGAP字节开始。 Per-CPU TSS and TSS descriptor，每个CPU的都需要任务状态段用以区分不同的CPU内核栈的位置。CPU i的TSS在cpus[i].cpu_ts中存储，相应的TSS描述符在GDT表项gdt[(GD_TSS0 &gt;&gt; 3) + i]中。定义在kern/trap全局变量ts将不会再使用。 Per-CPU current environment pointer，由于每个CPU可以同时运行不同的用户环境，我们定义符号curenv表示cpus[cpunum()].cpu_env(或者是thiscpu-&gt;cpu_env)，指向正在当前CPU上运行的用户环境。 Per-CPU system registers，包括系统寄存器在内的所有寄存器对每个CPU来说都是私有的。因此，初始化这些寄存器的指令，如lcr3(), ltr(), lgdt(), lidt()等等必须在每个CPU上执行一次。函数env_init_percpu()和trap_init_percpu()就是为了实现这个功能。 练习3 让我实现内存每个CPU的栈分配，在kern/pmap.c中的mem_init_mp()。 mem_init_mp1234567891011121314151617181920212223242526272829// Modify mappings in kern_pgdir to support SMP// - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)//映射去支持SMP 映射地址是 [KSTACKTOP-PTSIZE, KSTACKTOP)static voidmem_init_mp(void)&#123; // Map per-CPU stacks starting at KSTACKTOP, for up to 'NCPU' CPUs. //映射地址从 KSTACKTOP 开始 // For CPU i, use the physical memory that 'percpu_kstacks[i]' refers 每个CPU i 的物理地址是 'percpu_kstacks[i] // to as its kernel stack. CPU i's kernel stack grows down from virtual // address kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP), and is 开始地址是 kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP) // divided into two pieces, just like the single stack you set up in // mem_init: 这个是不是很眼熟，和前面单CPU是一样的 有一块是不用映射的，这样如果栈溢出，就直接RE // * [kstacktop_i - KSTKSIZE, kstacktop_i) // -- backed by physical memory // * [kstacktop_i - (KSTKSIZE + KSTKGAP), kstacktop_i - KSTKSIZE) // -- not backed; so if the kernel overflows its stack, // it will fault rather than overwrite another CPU's stack. // Known as a "guard page". // Permissions: kernel RW, user NONE // // LAB 4: Your code here: for (size_t i = 0; i &lt; NCPU; i++) &#123; /* code 直接映射即可 */ boot_map_region(kern_pgdir,KSTACKTOP-i*(KSTKSIZE+KSTKGAP)-KSTKSIZE,KSTKSIZE,PADDR(percpu_kstacks[i]),PTE_W); &#125; &#125; 练习 4 让我们实现每个CPU的中断初始化，在 kern/trap.c中的trap_init_percpu()。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// Initialize and load the per-CPU TSS and IDT 初始化每个CPU的TSS 和IDTvoidtrap_init_percpu(void)&#123; // The example code here sets up the Task State Segment (TSS) and // the TSS descriptor for CPU 0. But it is incorrect if we are // running on other CPUs because each CPU has its own kernel stack. // Fix the code so that it works for all CPUs. //已经有了一个TSS描述关于CPU 0，但是我们需要初始化多个CPU的 // Hints: // - The macro "thiscpu" always refers to the current CPU's // struct CpuInfo; 用thiscpu 指向当前CPU 的CPUinfo // - The ID of the current CPU is given by cpunum() or // thiscpu-&gt;cpu_id; 获取ID // - Use "thiscpu-&gt;cpu_ts" as the TSS for the current CPU, // rather than the global "ts" variable; 获取ts // - Use gdt[(GD_TSS0 &gt;&gt; 3) + i] for CPU i's TSS descriptor;获取 TSS 描述 // - You mapped the per-CPU kernel stacks in mem_init_mp() 映射的堆栈 // - Initialize cpu_ts.ts_iomb to prevent unauthorized environments // from doing IO (0 is not the correct value!) 初始化 cpu_ts.ts_iomb // // ltr sets a 'busy' flag in the TSS selector, so if you // accidentally load the same TSS on more than one CPU, you'll 每个CPU的TSS 不一样 // get a triple fault. If you set up an individual CPU's TSS 如果相同的TSS 就会报错 // wrong, you may not get a fault until you try to return from // user space on that CPU. // // LAB 4: Your code here int i=thiscpu-&gt;cpu_id;//直接把 ts 改成thiscpu-&gt;cpu_ts thiscpu-&gt;cpu_ts.ts_esp0=KSTACKTOP-i*(KSTKSIZE+KSTKGAP);//地址要变 thiscpu-&gt;cpu_ts.ts_ss0=GD_KD; thiscpu-&gt;cpu_ts.ts_iomb = sizeof(struct Taskstate); //初始化gdt 根据前面的来就行了 gdt[(GD_TSS0 &gt;&gt; 3) + i] = SEG16(STS_T32A, (uint32_t) (&amp;(thiscpu-&gt;cpu_ts)), sizeof(struct Taskstate) - 1, 0); gdt[(GD_TSS0 &gt;&gt; 3) + i].sd_s = 0; // // Setup a TSS so that we get the right stack // // when we trap to the kernel. // ts.ts_esp0 = KSTACKTOP; // ts.ts_ss0 = GD_KD; // ts.ts_iomb = sizeof(struct Taskstate); // // Initialize the TSS slot of the gdt. // gdt[GD_TSS0 &gt;&gt; 3] = SEG16(STS_T32A, (uint32_t) (&amp;ts), // sizeof(struct Taskstate) - 1, 0); // gdt[GD_TSS0 &gt;&gt; 3].sd_s = 0; // Load the TSS selector (like other segment selectors, the // bottom three bits are special; we leave them 0) ltr(GD_TSS0+8*i); //每个占3位 也就是 1&lt;&lt;3=8 // Load the IDT lidt(&amp;idt_pd);&#125; 运行make qemu CPUS=4就会出现官网上的那些东西。 Locking大内核锁，简单来讲，就是当一个CPU进入内核的时候，内核锁住，因为多个CPU同是在内核里面运行可能出错。可以自行百度一下。在kern/spinlock.h定义了那些锁。我们去看看。 kern/spinlock.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116// Mutual exclusion spin locks./* 头文件 介绍过了 ，这个也不用多说了吧*/#include &lt;inc/types.h&gt;#include &lt;inc/assert.h&gt;#include &lt;inc/x86.h&gt;#include &lt;inc/memlayout.h&gt;#include &lt;inc/string.h&gt;#include &lt;kern/cpu.h&gt;#include &lt;kern/spinlock.h&gt;#include &lt;kern/kdebug.h&gt;// The big kernel lockstruct spinlock kernel_lock = &#123;#ifdef DEBUG_SPINLOCK .name = "kernel_lock"#endif&#125;;#ifdef DEBUG_SPINLOCK// Record the current call stack in pcs[] by following the %ebp chain. 这个不知道用来噶啥的没用熬过 static voidget_caller_pcs(uint32_t pcs[])&#123; uint32_t *ebp; int i; ebp = (uint32_t *)read_ebp(); for (i = 0; i &lt; 10; i++)&#123; if (ebp == 0 || ebp &lt; (uint32_t *)ULIM) break; pcs[i] = ebp[1]; // saved %eip ebp = (uint32_t *)ebp[0]; // saved %ebp &#125; for (; i &lt; 10; i++) pcs[i] = 0;&#125;// Check whether this CPU is holding the lock. 检查当前CPU是否有锁static intholding(struct spinlock *lock)&#123; return lock-&gt;locked &amp;&amp; lock-&gt;cpu == thiscpu;&#125;#endifvoid__spin_initlock(struct spinlock *lk, char *name)//初始化锁的样子&#123; lk-&gt;locked = 0;#ifdef DEBUG_SPINLOCK lk-&gt;name = name; lk-&gt;cpu = 0;#endif&#125;// Acquire the lock.// Loops (spins) until the lock is acquired.// Holding a lock for a long time may cause// other CPUs to waste time spinning to acquire it.//锁住内核voidspin_lock(struct spinlock *lk)&#123;#ifdef DEBUG_SPINLOCK if (holding(lk)) panic("CPU %d cannot acquire %s: already holding", cpunum(), lk-&gt;name);#endif // The xchg is atomic. // It also serializes, so that reads after acquire are not // reordered before it. while (xchg(&amp;lk-&gt;locked, 1) != 0) //如果是已经锁住的，就一直等待 asm volatile ("pause"); // Record info about lock acquisition for debugging.#ifdef DEBUG_SPINLOCK lk-&gt;cpu = thiscpu; //锁住的CPU变成自己 get_caller_pcs(lk-&gt;pcs);#endif&#125;// Release the lock. 解除锁voidspin_unlock(struct spinlock *lk)&#123;#ifdef DEBUG_SPINLOCK if (!holding(lk)) &#123; int i; uint32_t pcs[10]; // Nab the acquiring EIP chain before it gets released memmove(pcs, lk-&gt;pcs, sizeof pcs); cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", cpunum(), lk-&gt;name, lk-&gt;cpu-&gt;cpu_id); for (i = 0; i &lt; 10 &amp;&amp; pcs[i]; i++) &#123; struct Eipdebuginfo info; if (debuginfo_eip(pcs[i], &amp;info) &gt;= 0) cprintf(" %08x %s:%d: %.*s+%x\n", pcs[i], info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name, pcs[i] - info.eip_fn_addr); else cprintf(" %08x\n", pcs[i]); &#125; panic("spin_unlock"); &#125; lk-&gt;pcs[0] = 0; lk-&gt;cpu = 0;#endif // The xchg instruction is atomic (i.e. uses the "lock" prefix) with // respect to any other instruction which references the same memory. // x86 CPUs will not reorder loads/stores across locked instructions // (vol 3, 8.2.2). Because xchg() is implemented using asm volatile, // gcc will not reorder C statements across the xchg. xchg(&amp;lk-&gt;locked, 0);//释放内核&#125; 里面用的上的函数，也就两个spin_lock和spin_unlock，他们在spinlock.h里面用lock_kernel和unlock_kernel调用。在代码中总共有4处使用了大内核锁： 在i386_init()函数中，BSP先获得大内核锁然后再启动其余的CPU 在mp_main()函数中，在初始化AP后获得大内核锁，然后调用sched_yield()开始在这个AP上运行用户环境。 在trap()函数中，从用户态陷入到内核态必须获得大内核锁，通过检查tf_cs的低位确定这个陷入发生在用户态还是在内核态 在env_run()函数中，在切换到用户态之前释放大内核锁，不要太早也不要太晚，否则就会体验一把竞争或者死锁的情况。 练习5就是让我们在这几个地方调用。第一个 i386_init 里面12345// Acquire the big kernel lock before waking up APs// Your code here:lock_kernel();// Starting non-boot CPUs 在这个启动之前调用lock_kernel();boot_aps(); 第二个 mp_main里面12345678910// Now that we have finished some basic setup, call sched_yield()// to start running processes on this CPU. But make sure that// only one CPU can enter the scheduler at a time!//// Your code here:lock_kernel();//锁住内核// Remove this after you finish Exercise 6//for (;;); 这个可以注释掉了，虽然说是练习 6，等会注释也是一样的 后面是调度程序sched_yield(); 第三个trap123456if ((tf-&gt;tf_cs &amp; 3) == 3) &#123; // Trapped from user mode. 如果是从用户模式过来就锁住内核。 // Acquire the big kernel lock before doing any // serious kernel work. // LAB 4: Your code here. lock_kernel(); 第4个env_run() 这个函数跑用户态去了，所以要释放内核。12unlock_kernel(); //在转移之前释放内核env_pop_tf(&amp;curenv-&gt;env_tf); 其实还用很多锁住内核，和释放内核，但是我们实验并没有让我们实现。 Question 2没解决告辞。 Round-Robin Scheduling实现轮转调度。 kern/sched.c中的sched_yield()函数负责选取一个新用户环境运行。从刚刚运行的用户环境开始以循环的方式依次搜索envs[]数组（如果之前没有运行过的用户环境，就从数组的第一个元素开始），选择发现的第一个状态为ENV_RUNNABLE的用户环境，然后调用env_run()跳转到选中的用户环境上运行。 sched_yield()不能同时在两个CPU上运行相同的用户环境。通过判断用户环境的状态就可以确定该环境是否正在运行 我们已经实现了一个新的系统调用sys_yield()，用户环境可以调用以执行内核态的sched_yield()实现以自动放弃CPU的控制权。 练习6 让我们实现这个调度程序。 sched_yield123456789101112131415161718192021222324252627282930313233343536373839404142// Choose a user environment to run and run it. 选择一个环境去运行他voidsched_yield(void)&#123; struct Env *idle; // Implement simple round-robin scheduling. // 实现简单的轮转调度 // Search through 'envs' for an ENV_RUNNABLE environment in // circular fashion starting just after the env this CPU was // last running. Switch to the first such environment found. // 从当前运行环境开始 找到下面第一个环境。 // If no envs are runnable, but the environment previously // running on this CPU is still ENV_RUNNING, it's okay to // choose that environment. //如果没有其他程序是 就绪状态 就继续运行自己 // Never choose an environment that's currently running on // another CPU (env_status == ENV_RUNNING). If there are // no runnable environments, simply drop through to the code // below to halt the cpu. //永远不会运行其他CPU 上正在运行的环境，如果没有可以运行的CPU 就是停止 这个CPU // LAB 4: Your code here. int i, nxenvid; if (curenv) nxenvid = ENVX(curenv-&gt;env_id); else nxenvid = 0; //如果是第一调度是 0 //枚举所有进程，看有没有能够运行的，有的运行。 for (i = 0; i &lt; NENV; i++) &#123; if (envs[(nxenvid + i) % NENV].env_status == ENV_RUNNABLE)&#123; envs[(nxenvid + i) % NENV].env_cpunum=cpunum(); env_run(&amp;envs[(nxenvid + i) % NENV]); &#125; &#125; if (curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)&#123;//没有其他的就运行当前的环境 curenv-&gt;env_cpunum=cpunum(); env_run(curenv); &#125; // sched_halt never returns 当前环境如果都不可运行了就直接 停止CPU sched_halt();&#125; 实现了sched_yield我们还需要在系统调用里面使用他，不然就不会从一个环境里面出来。在syscall.c 里面定义了一个调用他的syscall。然后我们需要使用他。123456789101112131415161718192021// Deschedule current environment and pick a different one to run.static voidsys_yield(void)&#123; sched_yield();&#125; //在syscall()里面加入 SYS_yield switch (syscallno) &#123; case (SYS_cputs): sys_cputs((const char *)a1, a2); return 0; case (SYS_cgetc): return sys_cgetc(); case (SYS_getenvid): return sys_getenvid(); case (SYS_env_destroy): return sys_env_destroy(a1); case (SYS_yield)://多加入这一行 sys_yield(); return 0; 再在mp_main最后调用一下注释掉无线循环。123// Remove this after you finish Exercise 6//for (;;);sched_yield(); 然后我们需要验证一下，要在init里面添加测试样例。123456789101112#if defined(TEST) // Don't touch -- used by grading script! ENV_CREATE(TEST, ENV_TYPE_USER);#else // Touch all you want. // ENV_CREATE(user_primes, ENV_TYPE_USER);//把这个歌注释掉，添加下面 3个进程 ENV_CREATE(user_yield, ENV_TYPE_USER); ENV_CREATE(user_yield, ENV_TYPE_USER); ENV_CREATE(user_yield, ENV_TYPE_USER);#endif // TEST* 然后运行make qemu CPUS=2可以看到和官网上说的一样的结果。为什么会出现这种结果可以查看user/yield.c1234567891011121314151617// yield the processor to other environments#include &lt;inc/lib.h&gt;voidumain(int argc, char **argv)&#123; int i; cprintf("Hello, I am environment %08x.\n", thisenv-&gt;env_id); for (i = 0; i &lt; 5; i++) &#123; sys_yield(); cprintf("Back in environment %08x, iteration %d.\n", thisenv-&gt;env_id, i); &#125; cprintf("All done in environment %08x.\n", thisenv-&gt;env_id);&#125; Question 3这个问题是，为什么lrc3切换了页表但是，对于进程的e指针还是不用变，因为[UENVS， UENVS+PTSIZE)的映射物理地址都是一样的。 Question 4为什么要保存，寄存器的状态。特么还要问么。告辞。因为不保存下来就无法正确地恢复到原来的环境。 System Calls for Environment Creation现在我们的系统已经能够环境运行了但是还是不能用户创建进程，在unix中我们用的fork函数创建进程，所以我们现在要实现一个简单fork函数。为了实现这个函数，我们需要下面这些系统调用。 sys_exofork：这个系统调用将创建一个新的空白用户环境，没有映射的用户空间且无法运行。在调用函数时新用户环境的寄存器状态与父进程相同。在父用户环境中，会返回子用户环境的envid_t（如果用户环境分配失败，返回一个负值的错误码）。而子用户环境中，会返回0。（由于子用户环境开始标记为不可运行，sys_exofork实际上是不会返回到子用户环境直到父用户环境标记子用户环境可以运行…） sys_env_set_status：这个系统调用将特定用户环境的状态设置为ENV_RUNNABLE或者ENV_NOT_RUNNABLE。一旦一个新的用户环境的地址空间和所有寄存器都完全初始化，这个系统调用用来标记这个用户环境准备运行。 sys_page_alloc：分配一个页的物理内存，并将其映射到给定用户环境地址空间的给定虚拟地址。 sys_page_map：从一个用户环境拷贝一个页的映射到另外一个用户环境，这样就完成了内存共享，使新旧的映射都是指同一页的物理内存。 sys_page_unmap：取消给定用户环境给定虚拟地址的映射。 以上所有的系统调用都接收用户环境ID，JOS内核支持将0作为当前运行的用户环境的ID的惯例，这个惯例通过kern/env.c中的envid2env()实现。我们需要实现fork 来通过 user/dumbfork.c。我们先去看看这个程序做了啥。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// Ping-pong a counter between two processes.// Only need to start one of these -- splits into two, crudely.#include &lt;inc/string.h&gt;#include &lt;inc/lib.h&gt;envid_t dumbfork(void);voidumain(int argc, char **argv)&#123; envid_t who; int i; // fork a child process who = dumbfork();//可以简单认为这就是个fork 函数 // print a message and yield to the other a few times for (i = 0; i &lt; (who ? 10 : 20); i++) &#123; cprintf("%d: I am the %s!\n", i, who ? "parent" : "child"); sys_yield();//输出完后就调度 &#125;&#125;voidduppage(envid_t dstenv, void *addr)&#123; int r; // This is NOT what you should do in your fork. if ((r = sys_page_alloc(dstenv, addr, PTE_P|PTE_U|PTE_W)) &lt; 0)//开辟了一个空间 panic("sys_page_alloc: %e", r); if ((r = sys_page_map(dstenv, addr, 0, UTEMP, PTE_P|PTE_U|PTE_W)) &lt; 0)//映射了空间 panic("sys_page_map: %e", r); memmove(UTEMP, addr, PGSIZE);//复制一份 if ((r = sys_page_unmap(0, UTEMP)) &lt; 0)//取消映射。 panic("sys_page_unmap: %e", r);&#125;envid_tdumbfork(void)&#123; envid_t envid; uint8_t *addr; int r; extern unsigned char end[]; // Allocate a new child environment. // The kernel will initialize it with a copy of our register state, // so that the child will appear to have called sys_exofork() too - // except that in the child, this "fake" call to sys_exofork() // will return 0 instead of the envid of the child. envid = sys_exofork(); if (envid &lt; 0) panic("sys_exofork: %e", envid); if (envid == 0) &#123; // We're the child. // The copied value of the global variable 'thisenv' // is no longer valid (it refers to the parent!). // Fix it and return 0. thisenv = &amp;envs[ENVX(sys_getenvid())];//如果是儿子就把新环境重新指向一下 return 0; &#125; // We're the parent. // Eagerly copy our entire address space into the child. // This is NOT what you should do in your fork implementation. for (addr = (uint8_t*) UTEXT; addr &lt; end; addr += PGSIZE)//如果是父亲我们需要拷贝一份地址 duppage(envid, addr);//这个韩式自己看一下 // Also copy the stack we are currently running on. duppage(envid, ROUNDDOWN(&amp;addr, PGSIZE));//复制栈 // Start the child environment running if ((r = sys_env_set_status(envid, ENV_RUNNABLE)) &lt; 0)//唤醒儿子 panic("sys_env_set_status: %e", r); return envid;&#125; 简单来讲解释写了一个简单的fork程序通过系统调用把内存复制了一份（这个时候还没有写时复制，所以是直接copy内存的），然后输出了一些值。在我们写系统调用fork之前需要看看envid2env。123456789101112131415161718192021222324252627282930313233343536373839404142434445//// Converts an envid to an env pointer. 把id 转换成env// If checkperm is set, the specified environment must be either the// current environment or an immediate child of the current environment.//需不需要判断是当前进程或者子进程// RETURNS// 0 on success, -E_BAD_ENV on error. //0成功其他出错// On success, sets *env_store to the environment. //成功设置环境// On error, sets *env_store to NULL.//不成功保存NULL//intenvid2env(envid_t envid, struct Env **env_store, bool checkperm)&#123; struct Env *e; //如果id是 0直接返回当前环境 // If envid is zero, return the current environment. if (envid == 0) &#123; *env_store = curenv; return 0; &#125; // Look up the Env structure via the index part of the envid, // then check the env_id field in that struct Env // to ensure that the envid is not stale // (i.e., does not refer to a _previous_ environment // that used the same slot in the envs[] array). e = &amp;envs[ENVX(envid)]; if (e-&gt;env_status == ENV_FREE || e-&gt;env_id != envid) &#123;//如果进程已经释放，就GG *env_store = 0; return -E_BAD_ENV; &#125; // Check that the calling environment has legitimate permission // to manipulate the specified environment. // If checkperm is set, the specified environment // must be either the current environment // or an immediate child of the current environment.//判断是不是自己或者子进程 if (checkperm &amp;&amp; e != curenv &amp;&amp; e-&gt;env_parent_id != curenv-&gt;env_id) &#123; *env_store = 0; return -E_BAD_ENV; &#125; *env_store = e; return 0;&#125; 所以说说上面就是判断一下进程是不是可用的。如果chekperm是1还需要检查是不是当前进程是不是当前进程或子进程。练习7实现前面说额那几个函数了。第一个sys_exofork123456789101112131415161718192021222324// Allocate a new environment. 分配一个新的进程，你可以理解成PCB// Returns envid of new environment, or &lt; 0 on error. Errors are: // -E_NO_FREE_ENV if no free environment is available. 没有进程可以用了返回// -E_NO_MEM on memory exhaustion. 没有内存了返回static envid_tsys_exofork(void)&#123; // Create the new environment with env_alloc(), from kern/env.c.用env_alloc分配进程 // It should be left as env_alloc created it, except that 设置成ENV_NOT_RUNNABLE // status is set to ENV_NOT_RUNNABLE, and the register set is copied //寄存器复制当前环境 // from the current environment -- but tweaked so sys_exofork // will appear to return 0. 需要把返回值设置成0 // LAB 4: Your code here. struct Env*child=NULL; int r=env_alloc(&amp;child,curenv-&gt;env_id); if(r!=0)return r; child-&gt;env_tf=curenv-&gt;env_tf; //复制tf，这个tf当前运行的位置应该是fork 之后的第一条语句 child-&gt;env_status=ENV_NOT_RUNNABLE; //设置环境 //cprintf("status:%d\n",child-&gt;env_status); child-&gt;env_tf.tf_regs.reg_eax = 0;//返回值变成0 return child-&gt;env_id; //父亲返回的是儿子的id //panic("sys_exofork not implemented");&#125; 下面就是sys_env_set_status更改进程状态。123456789101112131415161718192021222324252627// Set envid's env_status to status, which must be ENV_RUNNABLE// or ENV_NOT_RUNNABLE. 更改的状态必须是 ENV_RUNNABLE 和ENV_NOT_RUNNABLE//// Returns 0 on success, &lt; 0 on error. Errors are: 失败返回&lt;0// -E_BAD_ENV if environment envid doesn't currently exist,// or the caller doesn't have permission to change envid. //如果环境不存在或者进程错误// -E_INVAL if status is not a valid status for an environment. 如果值错了static intsys_env_set_status(envid_t envid, int status)&#123; // Hint: Use the 'envid2env' function from kern/env.c to translate an // envid to a struct Env. 用envid2env来检查进程 // You should set envid2env's third argument to 1, which will // check whether the current environment has permission to set // envid's status. //我们讲检查当前环境是否正确 // LAB 4: Your code here. struct Env * env=NULL; int r=envid2env(envid,&amp;env,1);//检查进程id是不是对的 if(r&lt;0)return -E_BAD_ENV; else &#123; if(status!=ENV_NOT_RUNNABLE&amp;&amp;status!=ENV_RUNNABLE)return -E_INVAL;//检查环境值是不是对的 env-&gt;env_status=status; &#125; return 0; //panic("sys_env_set_status not implemented");&#125; 然后就是关于内存的sys_page_alloc，sys_page_map,sys_page_unmap，都差不多。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113// Allocate a page of memory and map it at 'va' with permission// 'perm' in the address space of 'envid'. 分配一个页的内存映射 envid// The page's contents are set to 0. 页面内容设置为 0，也就是初始化为0// If a page is already mapped at 'va', that page is unmapped as a// side effect. 如果va是已经映射的就需要，取消映射//// perm -- PTE_U | PTE_P must be set, PTE_AVAIL | PTE_W may or may not be set, PTE_U | PTE_P权限必须设置 PTE_AVAIL | PTE_W 可以不设置// but no other bits may be set. See PTE_SYSCALL in inc/mmu.h.// 其他权限 PTE_SYSCALL 也许可以被设置，意味着超过这个权限都是错的。// Return 0 on success, &lt; 0 on error. Errors are: 失败返回 负数// -E_BAD_ENV if environment envid doesn't currently exist,// or the caller doesn't have permission to change envid.//环境id错误// -E_INVAL if va &gt;= UTOP, or va is not page-aligned.//地址不在用户状态或者不是页对齐// -E_INVAL if perm is inappropriate (see above). 权限错误// -E_NO_MEM if there's no memory to allocate the new page,//没有内存了// or to allocate any necessary page tables.static intsys_page_alloc(envid_t envid, void *va, int perm)&#123; // Hint: This function is a wrapper around page_alloc() and // page_insert() from kern/pmap.c. 可以使用page_alloc和page_insert // Most of the new code you write should be to check the // parameters for correctness. // If page_insert() fails, remember to free the page you // allocated!//如果插入失败记得释放内存 // LAB 4: Your code here. 后面就照着提示一个个判断就行了 struct Env * env; if(envid2env(envid,&amp;env,1)&lt;0)return -E_BAD_ENV;//判断进程 if((uintptr_t)va&gt;=UTOP||PGOFF(va))return -E_INVAL;//判断地址 int flag=PTE_U | PTE_P; if((perm &amp; ~(PTE_SYSCALL))!=0||(perm&amp;flag)!=flag)return -E_INVAL;//判断权限 struct PageInfo* pi=page_alloc(1);//分配一个页 if(pi==NULL)return -E_NO_MEM; if(page_insert(env-&gt;env_pgdir,pi,va,perm)&lt;0)&#123;//映射上去 page_free(pi); return -E_NO_MEM; &#125; return 0; //panic("sys_page_alloc not implemented");&#125;// Map the page of memory at 'srcva' in srcenvid's address space// at 'dstva' in dstenvid's address space with permission 'perm'.// Perm has the same restrictions as in sys_page_alloc, except// that it also must not grant write access to a read-only// page.//这个是把 源 虚拟地址映射到 目的 虚拟地址 // Return 0 on success, &lt; 0 on error. Errors are://一堆错误提示// -E_BAD_ENV if srcenvid and/or dstenvid doesn't currently exist,// or the caller doesn't have permission to change one of them.// -E_INVAL if srcva &gt;= UTOP or srcva is not page-aligned,// or dstva &gt;= UTOP or dstva is not page-aligned.// -E_INVAL is srcva is not mapped in srcenvid's address space.// -E_INVAL if perm is inappropriate (see sys_page_alloc).// -E_INVAL if (perm &amp; PTE_W), but srcva is read-only in srcenvid's// address space.// -E_NO_MEM if there's no memory to allocate any necessary page tables.static intsys_page_map(envid_t srcenvid, void *srcva, envid_t dstenvid, void *dstva, int perm)&#123; // Hint: This function is a wrapper around page_lookup() and // page_insert() from kern/pmap.c. // Again, most of the new code you write should be to check the // parameters for correctness. // Use the third argument to page_lookup() to // check the current permissions on the page. // LAB 4: Your code here. int r=0; struct Env * srccur=NULL,*dstcur=NULL; r=envid2env(srcenvid,&amp;srccur,1); if(r&lt;0)return -E_BAD_ENV; r=envid2env(dstenvid,&amp;dstcur,1);//判断两个进程 if(r&lt;0)return -E_BAD_ENV; if((uintptr_t)srcva &gt;= UTOP||(uintptr_t)dstva &gt;= UTOP||PGOFF(srcva)|| PGOFF(dstva))return -E_INVAL;//判断页地址和目的地址 pte_t * store=NULL; struct PageInfo* pg=NULL; if((pg=page_lookup(srccur-&gt;env_pgdir,srcva,&amp;store))==NULL)return -E_INVAL;//查看一个页 int flag=PTE_U | PTE_P; if((perm &amp; ~(PTE_SYSCALL))!=0||(perm&amp;flag)!=flag)return -E_INVAL; if((perm&amp;PTE_W)&amp;&amp;!(*store&amp;PTE_W))return E_INVAL;//判断权限 if (page_insert(dstcur-&gt;env_pgdir, pg, dstva, perm) &lt; 0) //插入到一个页 return -E_NO_MEM; return 0; //panic("sys_page_map not implemented");&#125;// Unmap the page of memory at 'va' in the address space of 'envid'.// If no page is mapped, the function silently succeeds.//取消一个进程 对va 的映射。// Return 0 on success, &lt; 0 on error. Errors are:// -E_BAD_ENV if environment envid doesn't currently exist,// or the caller doesn't have permission to change envid.// -E_INVAL if va &gt;= UTOP, or va is not page-aligned.static intsys_page_unmap(envid_t envid, void *va)&#123; // Hint: This function is a wrapper around page_remove(). // LAB 4: Your code here. struct Env *env; int r=envid2env(envid,&amp;env,1); if(r&lt;0)return -E_BAD_ENV; if((uintptr_t)va&gt;=UTOP||PGOFF(va))return -E_INVAL; page_remove(env-&gt;env_pgdir,va); return 0; //panic("sys_page_unmap not implemented");&#125; 然后就可以运行了。最后不要忘记把他填到syscall里面。12345678910case SYS_exofork: return sys_exofork();case SYS_env_set_status: return sys_env_set_status((envid_t)a1, (int)a2);case SYS_page_alloc: return sys_page_alloc((envid_t)a1, (void *)a2, (int)a3); case SYS_page_map: return sys_page_map((envid_t)a1, (void *)a2, (envid_t)a3, (void *)a4, (int)a5); case SYS_page_unmap: return sys_page_unmap((envid_t)a1, (void *)a2); 然后就完成了PART A了。 Part B: Copy-on-Write Fork写时复制，对于这个机制应该都很清楚。大部分程序fork之后就调用了exec所以，我门，并没有复制内存，也就是少了dumbfork里面的memmove(UTEMP, addr, PGSIZE);。但是这样做就有了个缺陷，如果没有调用exec，子进程又访问了就要进行缺页中断。所以这次我我们的任务就是实现这些东西。 User-level page fault handling一个用户级写时拷贝的fork函数需要知道哪些page fault是在写保护页时触发的，写时复制只是用户级缺页中断处理的一种。通常建立地址空间以便page fault提示何时需要执行某些操作。例如大多数Unix内核初始只给新进程的栈映射一个页，以后栈增长会导致page fault从而映射新的页。一个典型的Unix内核必须记录在进程地址空间的不同区域发生page fault时，应该执行什么操作。例如栈上缺页，会实际分配和映射新的物理内存。BSS区域缺页会分配新的物理页，填充0，然后映射。这种设计在定义他们的内存区域的时候具有极大的灵活度。 Setting the Page Fault Handler为了处理自己的缺页中断，用户环境需要在JOS内核中注册缺页中断处理程序的入口。用户环境通过sys_env_set_pgfault_upcall系统调用注册它的缺页中断入口。我们在Env结构体中增加了一个新成员env_pgfault_upcall来记录这一信息。练习8就是让你实现缺页中断的入口，就是你用写时复制，如果修改了该怎么处理，调用哪个程序去处理。我们需要去实现这个sys_env_set_pgfault_upcall。12345678910111213141516171819// Set the page fault upcall for 'envid' by modifying the corresponding struct// Env's 'env_pgfault_upcall' field. When 'envid' causes a page fault, the// kernel will push a fault record onto the exception stack, then branch to// 'func'.//参数传进去一个函数指针，直接把处理缺页中断的变量指向就可以了// Returns 0 on success, &lt; 0 on error. Errors are:// -E_BAD_ENV if environment envid doesn't currently exist,// or the caller doesn't have permission to change envid.static intsys_env_set_pgfault_upcall(envid_t envid, void *func)&#123; // LAB 4: Your code here. struct Env * env; if(envid2env(envid,&amp;env,1)&lt;0)return -E_BAD_ENV;//先判断进程可不可以用 env-&gt;env_pgfault_upcall=func;//意思就是处理中断的时候用func 这个函数。 return 0; //panic("sys_env_set_pgfault_upcall not implemented");&#125; 千万别忘记把这个添进syscall，我这个地方忘记添加了，找了半天不知道为啥。12case SYS_env_set_pgfault_upcall: return sys_env_set_pgfault_upcall(a1,(void *)a2); Normal and Exception Stacks in User Environments在正常运行期间，用户进程运行在用户栈上，开始运行时栈顶寄存器ESP指向USTACKTOP，压入堆栈的数据位于[USTACKTOP-PGSIZE ~ USTACKTOP-1]之间的页。当一个页错误出现在用户模式下，内核重启用户环境让其在用户异常栈上运行指定的用户级缺页处理程序。我们将使JOS代替用户环境实现自动的“栈切换”，就如同x86处理器代替JOS内核实现从用户模式到内核模式的栈切换。 JOS的用户异常栈的大小为一个页，初始栈顶定义在UXSTACKTOP。因此有效的用户异常栈的区间是[UXSTACKTOP-PGSIZE ~ UXSTACKTOP-1]。运行在异常栈上的用户级的页错误处理程序可以使用JOS的常规的系统调用，来映射新的页或者调整映射，来修复导致页错误的问题。然后用户级别页错误处理程序通过一个汇编语言stub返回到原始栈的错误代码处。 每一个想要支持用户级别页错误处理的用户环境都需要为自己的异常栈分配内存，这就用到了在part A中引入的sys_page_alloc()系统调用函数。这个时候我们就需要一个新的栈，叫做用户异常栈。 Invoking the User Page Fault Handler我们现在需要修改kern/trap.c里面的用户模式的缺页错误，因为现在我们有了用户的缺页处理函数。现在我们如果设置了，缺页处理函数，就调用缺页处理函数，没有我们就销毁这个进程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283voidpage_fault_handler(struct Trapframe *tf)&#123; uint32_t fault_va; // Read processor's CR2 register to find the faulting address fault_va = rcr2(); // Handle kernel-mode page faults. // LAB 3: Your code here. if(tf-&gt;tf_cs &amp;&amp; 0x01 == 0) &#123; panic("page_fault in kernel mode, fault address %d\n", fault_va); &#125; // We've already handled kernel-mode exceptions, so if we get here, // the page fault happened in user mode. // Call the environment's page fault upcall, if one exists. Set up a // page fault stack frame on the user exception stack (below // UXSTACKTOP), then branch to curenv-&gt;env_pgfault_upcall. // 建立一个用户异常栈 在 UXSTACKTOP 然后跳转到 curenv-&gt;env_pgfault_upcall 运行 // The page fault upcall might cause another page fault, in which case // we branch to the page fault upcall recursively, pushing another // page fault stack frame on top of the user exception stack. // 可能出现多级中断 // It is convenient for our code which returns from a page fault // (lib/pfentry.S) to have one word of scratch space at the top of the // trap-time stack; it allows us to more easily restore the eip/esp. In // the non-recursive case, we don't have to worry about this because // the top of the regular user stack is free. In the recursive case, // this means we have to leave an extra word between the current top of // the exception stack and the new stack frame because the exception // stack _is_ the trap-time stack. // // If there's no page fault upcall, the environment didn't allocate a // page for its exception stack or can't write to it, or the exception // stack overflows, then destroy the environment that caused the fault. // Note that the grade script assumes you will first check for the page // fault upcall and print the "user fault va" message below if there is // none. The remaining three checks can be combined into a single test. // // Hints: // user_mem_assert() and env_run() are useful here. // To change what the user environment runs, modify 'curenv-&gt;env_tf' // (the 'tf' variable points at 'curenv-&gt;env_tf'). // LAB 4: Your code here. struct UTrapframe *utf; if (curenv-&gt;env_pgfault_upcall) &#123; //如果已经有了异常栈，我们就直接在后面添加一个UTrapframe，否则就先把跳到异常栈。 这是为了处理多级中断 if (tf-&gt;tf_esp &gt;= UXSTACKTOP-PGSIZE &amp;&amp; tf-&gt;tf_esp &lt; UXSTACKTOP) &#123; // 异常模式下陷入 utf = (struct UTrapframe *)(tf-&gt;tf_esp - sizeof(struct UTrapframe) - 4); &#125; else &#123; // 非异常模式下陷入 utf = (struct UTrapframe *)(UXSTACKTOP - sizeof(struct UTrapframe)); &#125; // 检查异常栈是否溢出 user_mem_assert(curenv, (const void *) utf, sizeof(struct UTrapframe), PTE_P|PTE_W); utf-&gt;utf_fault_va = fault_va; utf-&gt;utf_err = tf-&gt;tf_trapno; utf-&gt;utf_regs = tf-&gt;tf_regs; utf-&gt;utf_eflags = tf-&gt;tf_eflags; // 保存陷入时现场，用于返回 utf-&gt;utf_eip = tf-&gt;tf_eip; utf-&gt;utf_esp = tf-&gt;tf_esp; // 再次转向执行 curenv-&gt;env_tf.tf_eip = (uint32_t) curenv-&gt;env_pgfault_upcall; // 异常栈 curenv-&gt;env_tf.tf_esp = (uint32_t) utf; env_run(curenv); &#125; else &#123; // Destroy the environment that caused the fault. 没有定义就直接销毁 cprintf("[%08x] user fault va %08x ip %08x\n", curenv-&gt;env_id, fault_va, tf-&gt;tf_eip); print_trapframe(tf); env_destroy(curenv); &#125;&#125; User-mode Page Fault Entrypoint接下来，就需要实现汇编例程负责调用C的缺页异常处理程序并恢复执行原来出错的指令。这个汇编例程（lib/pfentry.S中的_pgfault_upcall）就是需要使用sys_env_set_pgfault_upcall()系统调用注册到内核的处理程序。这个练习我没看懂。所以我就直接 贴别人的代码了12345678910111213141516 // Struct PushRegs size = 32 addl $8, %esp // esp+8 -&gt; PushRegs over utf_fault_va utf_errmovl 0x20(%esp), %eax // eax = (esp+0x20 -&gt; utf_eip )subl $4, 0x28(%esp) // for trap time eip 保留32bit, esp+48 = utf_espmovl 0x28(%esp), %edx // %edx = utf_esp-4 movl %eax, (%edx) // %eax = eip ----&gt; esp-4 以至于ret可以直接读取其继续执行的地址popal // after popal esp-&gt;utf_eipaddl $4, %esp // esp+4 -&gt; utf_eflagspopflpopl %espret // 这里十分巧妙， ret会读取esp指向的第一个内容， 也就是我们第一步写入的eip 练习11 就是让你实现lib/pgfault.c.里面的set_pgfault_handler。 123456789101112131415161718192021222324//// Set the page fault handler function. 设置那个缺页处理// If there isn't one yet, _pgfault_handler will be 0.// The first time we register a handler, we need to// allocate an exception stack (one page of memory with its top// at UXSTACKTOP), and tell the kernel to call the assembly-language// _pgfault_upcall routine when a page fault occurs. 如果是第一次分配页我们需要分配一个异常栈。//voidset_pgfault_handler(void (*handler)(struct UTrapframe *utf))&#123; int r; if (_pgfault_handler == 0) &#123; // First time through! // LAB 4: Your code here. if ((r = sys_page_alloc(thisenv-&gt;env_id, (void *)(UXSTACKTOP - PGSIZE), PTE_P | PTE_W | PTE_U)) &lt; 0) panic("set_pgfault_handler: %e", r); sys_env_set_pgfault_upcall(thisenv-&gt;env_id, _pgfault_upcall); &#125; // Save handler pointer for assembly to call. _pgfault_handler = handler;&#125; Implementing Copy-on-Write Fork最后就是实现写时复制了。前面我们有一个测试程序，user/dumbfork，这个里面已经有了模板，我们现在要做的就是实现一个差不多的fork。他的基本流程是： 父进程将pgfault()函数作为C语言实现的页错误处理，会用到上面的实现的set_pgfault_handler()函数进行设置。父进程调用sys_exofork()创建一个子进程环境。 在UTOP之下的在地址空间里的每一个可写或copy-on-write的页，父进程就会调用duppage，它会将copy-on-write页映射到子进程的地址空间，然后重新映射copy-on-write页到自己的地址空间。[注意这里的顺序十分重要！先将子进程的页标记为COW，然后将父进程的页标记为COW。知道为什么吗？你可以尝试思考将该顺序弄反会是造成怎样的麻烦]。duppage将COW的页的PTEs设置为不能写的，然后在PTE的avail域设置PTE_COW来区别 copy-on-write pages及真正的只读页 异常栈并不是如上重新映射，在子进程中需要为异常栈分配一个新的页。由于缺页异常处理程序将执行实际的拷贝,而且缺页异常处理程序在异常栈上运行,异常栈不应该被设置为cow。fork()同样要解决在内存中的页，但页既不可写也不是copy-on-write。 父进程为子进程设置用户页错误入口。 子进程现在可以运行，然后父进程将其标记为可运行。 每次这两进程中的一个向一个尚未写过的copy-on-write页写时，就会产生一个页错误。下面是用户页错误处理的控制流： 内核传播页错误到_pgfault_upcall，调用fork()的pgfault()处理流程。 pgfault()检查错误代码中的FEC_WR（即是写导致的），以及页对应的PTE标记为PTE_COW。没有的话，panic。 pgfault()分配一个映射在一个临时位置的新的页，然后将错误页中的内容复制进去。然后页错误处理程序映射新的页到引起page fault的虚拟地址，并设置PTE具有读写权限。 用户级的lib/fork.c必须访问用户环境的页表完成以上的几个操作(例如将一个页对应的PTE标记为PTE_COW)。内核映射用户环境的页表到虚拟地址UVPT的用意就在于此。它使用了一种聪明的手段让用户代码很方便的检索PTE。lib/entry.S设置uvpt和uvpd使得lib/fork.c中的用户代码能够轻松地检索页表信息。练习12就是让我们实现fork.c里面的fork, duppage 和 pgfault。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141// implement fork from user space#include &lt;inc/string.h&gt;#include &lt;inc/lib.h&gt;// PTE_COW marks copy-on-write page table entries.// It is one of the bits explicitly allocated to user processes (PTE_AVAIL).#define PTE_COW 0x800//// Custom page fault handler - if faulting page is copy-on-write,// map in our own private writable copy.// 用户处理缺页static voidpgfault(struct UTrapframe *utf)&#123; void *addr = (void *) utf-&gt;utf_fault_va; uint32_t err = utf-&gt;utf_err; int r; // Check that the faulting access was (1) a write, and (2) to a // copy-on-write page. If not, panic. // Hint: 检查是不是因为因为写入导致的错误，不是就paic // Use the read-only page table mappings at uvpt // (see &lt;inc/memlayout.h&gt;). uvpt 和uvpd 在memlayout 这个里面有定义，很久之前我们就看过了。 一个页目录一个是页表的。 // LAB 4: Your code here. if (!( (err &amp; FEC_WR) &amp;&amp; (uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_COW) )) panic("Neither the fault is a write nor copy-on-write page.\n");//如果不是因为这个原因 就panic // Allocate a new page, map it at a temporary location (PFTEMP), // copy the data from the old page to the new page, then move the new // page to the old page's address. // Hint: 分配一个页面给他，然后复制一份就这样 // You should make three system calls. // LAB 4: Your code here. if((r = sys_page_alloc(0, PFTEMP, PTE_U | PTE_P | PTE_W)) &lt; 0)&#123; panic("sys_page_alloc: %e\n", r);//分配了一个页 &#125; addr = ROUNDDOWN(addr, PGSIZE);//页对齐 memcpy((void *)PFTEMP, addr, PGSIZE);//把这个写时复制的页内容复制一遍 if ((r = sys_page_map(0, (void *)PFTEMP, 0, addr, PTE_P | PTE_U | PTE_W)) &lt; 0) panic("sys_page_map: %e\n", r);//把当前映射的 地址 指向PFTEMP 新分配的页 if ((r = sys_page_unmap(0, (void *)PFTEMP)) &lt; 0) //取消PFTEMP 的映射，这样就把虚拟地址指向了一个新的页。 panic("sys_page_unmap: %e\n", r); //panic("pgfault not implemented");&#125;//// Map our virtual page pn (address pn*PGSIZE) into the target envid// at the same virtual address. If the page is writable or copy-on-write,// the new mapping must be created copy-on-write, and then our mapping must be// marked copy-on-write as well. (Exercise: Why do we need to mark ours// copy-on-write again if it was already copy-on-write at the beginning of// this function?)//把 我们虚拟页 pn*PGSIZE映射到 相同的虚拟地址，如果原本就是写时复制那么新的也要标记成 写时复制// Returns: 0 on success, &lt; 0 on error.// It is also OK to panic on error.//static intduppage(envid_t envid, unsigned pn)&#123; int r; // LAB 4: Your code here. void* vaddr=(void*)(pn*PGSIZE); if((uvpt[pn] &amp; PTE_W) || (uvpt[pn] &amp; PTE_COW))&#123; if ((r = sys_page_map(0, vaddr, envid, vaddr, PTE_P | PTE_U | PTE_COW)) &lt; 0) return r;//映射当前页为写时符合 if ((r = sys_page_map(0, vaddr, 0, vaddr, PTE_P | PTE_U | PTE_COW)) &lt; 0) return r;//把自己当前页页标记成写时复制。 &#125; else if((r = sys_page_map(0, vaddr, envid, vaddr, PTE_P | PTE_U)) &lt; 0) &#123; return r;//如果当前页已经是写时复制 就不需要更改了 &#125; //panic("duppage not implemented"); return 0;&#125;//// User-level fork with copy-on-write. 写时复制// Set up our page fault handler appropriately.设置缺页处理// Create a child. 创建一个儿子// Copy our address space and page fault handler setup to the child. 复制空间和设置缺页处理// Then mark the child as runnable and return. 标记儿子为 runable//// Returns: child's envid to the parent, 0 to the child, &lt; 0 on error.// It is also OK to panic on error. 父亲返回 儿子id 儿子返回 0 返回 &lt;0 出错//// Hint:// Use uvpd, uvpt, and duppage. 使用 uvpd, uvpt, 和 duppage// Remember to fix "thisenv" in the child process.// Neither user exception stack should ever be marked copy-on-write,// so you must allocate a new page for the child's user exception stack.// 不用把异常栈标记为写时复制 所以必须分配新的一页给儿子envid_tfork(void)&#123; // LAB 4: Your code here. envid_t cenvid; unsigned pn; int r; set_pgfault_handler(pgfault); //设置 缺页处理 if ((cenvid = sys_exofork()) &lt; 0)&#123; //创建了一个进程。 panic("sys_exofork failed"); return cenvid; &#125; if(cenvid&gt;0)&#123;//如果是 父亲进程 for (pn=PGNUM(UTEXT); pn&lt;PGNUM(USTACKTOP); pn++)&#123; //复制UTEXT 到USTACKTOP的页 if ((uvpd[pn &gt;&gt; 10] &amp; PTE_P) &amp;&amp; (uvpt[pn] &amp; PTE_P)) if ((r = duppage(cenvid, pn)) &lt; 0) return r; &#125; if ((r = sys_page_alloc(cenvid, (void *)(UXSTACKTOP-PGSIZE), PTE_U | PTE_P | PTE_W)) &lt; 0) //分配一个新的页 return r; extern void _pgfault_upcall(void); //缺页处理 if ((r = sys_env_set_pgfault_upcall(cenvid, _pgfault_upcall)) &lt; 0) return r; //为儿子设置一个缺页处理分支 if ((r = sys_env_set_status(cenvid, ENV_RUNNABLE)) &lt; 0)//设置成可运行 return r; return cenvid; &#125; else &#123; thisenv = &amp;envs[ENVX(sys_getenvid())];//如果是儿子就直接运行。 return 0; &#125; //panic("fork not implemented"); &#125;// Challenge!intsfork(void)&#123; //这个挑战的内容，我没看懂要做什么。 panic("sfork not implemented"); return -E_INVAL;&#125; Part C: Preemptive Multitasking and Inter-Process communication (IPC)现在我们要实现抢占式调度和进程间通信。 Clock Interrupts and Preemption运行user/spin会死循环。123456789101112131415161718192021222324252627282930// Test preemption by forking off a child process that just spins forever.// Let it run for a couple time slices, then kill it.#include &lt;inc/lib.h&gt;voidumain(int argc, char **argv)&#123; envid_t env; cprintf("I am the parent. Forking the child...\n"); if ((env = fork()) == 0) &#123; cprintf("I am the child. Spinning...\n"); while //(1) 在这个地方死循环了 /* do nothing */; &#125; cprintf("I am the parent. Running the child...\n"); sys_yield(); sys_yield(); sys_yield(); sys_yield(); sys_yield(); sys_yield(); sys_yield(); sys_yield(); cprintf("I am the parent. Killing the child...\n"); sys_env_destroy(env);//如果是抢占式 就会在这个地方给毁了子进程。&#125; 实现抢占式，必须要有硬件的支持。 Interrupt discipline外部中断（即，设备中断）被称为IRQ。有16个可能的IRQ，编号从0到15.IRQ编号到IDT表项的映射不是固定的。picirq.c中的pic_init将0~15的IRQ编号映射到IDT表项 ，[IRQ_OFFSET ~ IRQ_OFFSET +15]。 在inc/trap.h中，IRQ_OFFSET的值是32.因此IDT表项[32~ 47]对应0~15的IRQ编号。例如，时钟中断是IRQ 0，因此IDT[32]包含内核中的时钟中断处理例程的地址。IRQ_OFFSET的选择主要是为了设备中断不与处理器异常重叠。 在JOS中，对比xv6 Unix，我们做了关键的简化。在内核中的时候，外部设备中断基本上是关闭的（像xv6一样，在用户空间打开）。外部设备中断由%eflags寄存器上的FL_IF标志位控制。当这个位置位，外部中断使能。这个位可以通过几种途径修改，由于我们的简化，我们仅通过在进入内核时候保存%eflags寄存器，退出内核时恢复%eflags寄存器这个过程来修改FL_IF标志位。 应该确保在用户态FL_IF标志位是置位的，这样中断才能传递给处理器，并最终被中断代码处理。否则，中断被屏蔽或忽略，直到重新启用中断。Bootloader最初几条指令就屏蔽了中断，到目前为止，我们从来没有重新启用它们。练习 13 要我像当初实现内部中断一样，实现这几个外部中断。一样的没啥区别。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354TRAPHANDLER_NOEC(IRQ0, IRQ_OFFSET)TRAPHANDLER_NOEC(IRQ1, IRQ_OFFSET+1)TRAPHANDLER_NOEC(IRQ2, IRQ_OFFSET+2)TRAPHANDLER_NOEC(IRQ3, IRQ_OFFSET+3)TRAPHANDLER_NOEC(IRQ4, IRQ_OFFSET+4)TRAPHANDLER_NOEC(IRQ5, IRQ_OFFSET+5)TRAPHANDLER_NOEC(IRQ6, IRQ_OFFSET+6)TRAPHANDLER_NOEC(IRQ7, IRQ_OFFSET+7)TRAPHANDLER_NOEC(IRQ8, IRQ_OFFSET+8)TRAPHANDLER_NOEC(IRQ9, IRQ_OFFSET+9)TRAPHANDLER_NOEC(IRQ10, IRQ_OFFSET+10)TRAPHANDLER_NOEC(IRQ11, IRQ_OFFSET+11)TRAPHANDLER_NOEC(IRQ12, IRQ_OFFSET+12)TRAPHANDLER_NOEC(IRQ13, IRQ_OFFSET+13)TRAPHANDLER_NOEC(IRQ14, IRQ_OFFSET+14)TRAPHANDLER_NOEC(IRQ15, IRQ_OFFSET+15)void IRQ0();void IRQ1();void IRQ2();void IRQ3();void IRQ4();void IRQ5();void IRQ6();void IRQ7();void IRQ8();void IRQ9();void IRQ10();void IRQ11();void IRQ12();void IRQ13();void IRQ14();void IRQ15();// trap_init SETGATE(idt[IRQ_OFFSET], 0, GD_KT, IRQ0, 0); SETGATE(idt[IRQ_OFFSET+1], 0, GD_KT, IRQ1, 0); SETGATE(idt[IRQ_OFFSET+2], 0, GD_KT, IRQ2, 0); SETGATE(idt[IRQ_OFFSET+3], 0, GD_KT, IRQ3, 0); SETGATE(idt[IRQ_OFFSET+4], 0, GD_KT, IRQ4, 0); SETGATE(idt[IRQ_OFFSET+5], 0, GD_KT, IRQ5, 0); SETGATE(idt[IRQ_OFFSET+6], 0, GD_KT, IRQ6, 0); SETGATE(idt[IRQ_OFFSET+7], 0, GD_KT, IRQ7, 0); SETGATE(idt[IRQ_OFFSET+8], 0, GD_KT, IRQ8, 0); SETGATE(idt[IRQ_OFFSET+9], 0, GD_KT, IRQ9, 0); SETGATE(idt[IRQ_OFFSET+10], 0, GD_KT, IRQ10, 0); SETGATE(idt[IRQ_OFFSET+11], 0, GD_KT, IRQ11, 0); SETGATE(idt[IRQ_OFFSET+12], 0, GD_KT, IRQ12, 0); SETGATE(idt[IRQ_OFFSET+13], 0, GD_KT, IRQ13, 0); SETGATE(idt[IRQ_OFFSET+14], 0, GD_KT, IRQ14, 0); SETGATE(idt[IRQ_OFFSET+15], 0, GD_KT, IRQ15, 0); // Per-CPU setup 还需要开启这个中断，在env_alloc里面。123// Enable interrupts while in user mode.// LAB 4: Your code here.e-&gt;env_tf.tf_eflags |= FL_IF; Handling Clock Interrupts在user/spin程序中，子进程开始运行之后就进入死循环，内核不会再获取控制权。我们现在需要对硬件编程以每隔一定的时间生成时钟中断，这样会强制将控制权返回给内核，内核可以切换到不同的用户环境上运行。 i386_init()函数调用lapic_init和pic_init，设置时钟以及中断控制器生成中断，现在需要编写代码处理这些中断。这个时候材质 lapic_init 和pic_init 是用来干啥的。后来发现lapicw(TICR, 10000000);这个是设置中断时间具体细节就不知道了，应该和嵌入式有关。练习 14让我们trap_dispatch里面实现调度，也就是抢占式调度。12345case IRQ_OFFSET + IRQ_TIMER:&#123; lapic_eoi(); sched_yield(); break; &#125; Inter-Process communication (IPC)最后一个就是进程通信。我们到目前为止，都是假装一个电脑就只有一个进程，现在我们要开始烤炉两个进程之间的相互影响。我们需要实现一个简单的进程通信。 IPC in JOS我们需要实现两个系统调用sys_ipc_recv 和 sys_ipc_try_send并且我们已经用ipc_recv和ipc_send封装好了他(C语言里面有封装的概念？？)，我们发送的信息是一个32位的值和可选的一个单页映射。允许用户环境在消息中传递页面映射提供了一种传输更多的数据的有效的方法，而不仅仅是单个32位整数，并且还允许用户环境轻松地建立共享内存布局。 Sending and Receiving Messages用户环境调用sys_ipc_recv接收消息。此系统调用会调度当前环境，使得在收到消息之前不再运行它。当用户环境等待接收消息时，任何其他用户环境都可以向其发送消息– 而不仅仅是特定的环境，而不仅仅是与接收消息的用户环境具有的父/子关系的用户环境。换而言之，在PartA中实现的权限检查不再适用于IPC，因为IPC系统调用是精心设计的，以便是“安全的”：用户环境不能仅仅通过发送消息而导致另一个环境故障（除非目标环境也是错误的）。 用户环境以接收消息的用户环境的id以及待发送的值为参数调用sys_ipc_try_send发送一个值。如果接收消息的用户环境是否正在接收消息（该用户环境调用sys_ipc_recv系统调用，但还没有接收到值），sys_ipc_try_send系统调用传送消息并返回0，否则返回-E_IPC_NOT_RECV表示目标环境当前不希望接收到一个值。 用户空间的库函数ipc_recv负责调用sys_ipc_recv,然后在当前环境的struct Env中查找有关接收到的值的信息。 类似的，用户空间的库函数ipc_send否则反复调用sys_ipc_try_send直到消息发送成功。 Transferring Pages当用户环境使用有效的dstva参数（低于UTOP）调用sys_ipc_recv时，环境表示它愿意接收页面映射。如果发送者发送一个页面，那么该页面应该在接收者的地址空间中的dstva映射。如果接收者已经在dstva上映射了一个页面，那么之前的页映射被取消。 当用户环境以有效的srcva（在UTOP下面）以及权限perm为参数调用sys_ipc_try_send时，这意味着发送者想要将当前映射到srcva的页面发送给接收者。在成功的IPC之后，发送方在其地址空间中的srcva保持页面的原始映射，但是接收方在其地址空间最初指定的dstva处获得了与发送者同一物理页的映射。因此，该页面在发送者和接收者之间共享。 如果发送者或接收者没有指示一个页面应该被传送，那么没有页面被传送。在任何IPC之后，内核将接收者的Env结构中的新字段env_ipc_perm设置为接收到的页面的权限，如果没有接收到页面，则为零。 Implementing IPC介绍了这么多东西其实也就是为了最后这个。练习15 实现sys_ipc_recv和sys_ipc_recv。 sys_ipc_recv12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// Try to send 'value' to the target env 'envid'.// If srcva &lt; UTOP, then also send page currently mapped at 'srcva',// so that receiver gets a duplicate mapping of the same page.// 发过 srcva &lt; UTOP 把他对应的物理页送过去// The send fails with a return value of -E_IPC_NOT_RECV if the// target is not blocked, waiting for an IPC.// 失败返回 E_IPC_NOT_RECV 如果目标是不堵塞的就等待IPC// The send also can fail for the other reasons listed below.//// Otherwise, the send succeeds, and the target's ipc fields are// updated as follows: //如果发送成功更新下面这些东西// env_ipc_recving is set to 0 to block future sends; 设置 0来阻塞// env_ipc_from is set to the sending envid;//设置发送的ID// env_ipc_value is set to the 'value' parameter; 设置值// env_ipc_perm is set to 'perm' if a page was transferred, 0 otherwise.设置发送页面权限// The target environment is marked runnable again, returning 0 标记目标环境为runnable// from the paused sys_ipc_recv system call. (Hint: does the// sys_ipc_recv function ever actually return?)暂停sys_ipc_recv//// If the sender wants to send a page but the receiver isn't asking for one,// then no page mapping is transferred, but no error occurs.// The ipc only happens when no errors occur.// 如果当前进程发送了一个页，但是 目标进程没有要求一个页，然后没有 页会被发送，不会产生错误。// Returns 0 on success, &lt; 0 on error.// Errors are:// -E_BAD_ENV if environment envid doesn't currently exist.// (No need to check permissions.)//如果进程错误// -E_IPC_NOT_RECV if envid is not currently blocked in sys_ipc_recv,// or another environment managed to send first.//目标没有接受// -E_INVAL if srcva &lt; UTOP but srcva is not page-aligned.//页地址错误// -E_INVAL if srcva &lt; UTOP and perm is inappropriate//页权限错误// (see sys_page_alloc).// -E_INVAL if srcva &lt; UTOP but srcva is not mapped in the caller's// address space.//页没有映射// -E_INVAL if (perm &amp; PTE_W), but srcva is read-only in the// current environment's address space.//页只读// -E_NO_MEM if there's not enough memory to map srcva in envid's// address space.//没有足够的空间static intsys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)&#123; // LAB 4: Your code here. struct Env* env; if(envid2env(envid,&amp;env,0)&lt;0)return -E_BAD_ENV;//环境 if(env-&gt;env_ipc_recving==0)return -E_IPC_NOT_RECV;//是否阻塞 env-&gt;env_ipc_perm = 0;//权限 unsigned flag= PTE_P | PTE_U; if((uintptr_t)srcva&lt;UTOP)&#123;//页地址小于UTOP if(PGOFF(srcva))return -E_INVAL;//不是页对齐 if ((perm &amp; ~(PTE_SYSCALL)) || ((perm &amp; flag) != flag))return -E_INVAL;//权限错误 if (user_mem_check(curenv, (const void *)srcva, PGSIZE, PTE_U) &lt; 0)//页不存在 return -E_INVAL; if (perm&amp; PTE_W&amp;&amp;user_mem_check(curenv, (const void *)srcva, PGSIZE, PTE_U |PTE_W) &lt; 0)//页权限错误 return -E_INVAL; if((uintptr_t)(env-&gt;env_ipc_dstva)&lt;UTOP)&#123;//接受页的地址 env-&gt;env_ipc_perm=perm; struct PageInfo *pi = page_lookup(curenv-&gt;env_pgdir, srcva, 0); if (page_insert(env-&gt;env_pgdir, pi, env-&gt;env_ipc_dstva, perm) &lt; 0)//映射一下，映射失败返回没有内存了。 return -E_NO_MEM; &#125; &#125; //设置一下值 env-&gt;env_ipc_recving = false; env-&gt;env_ipc_from = curenv-&gt;env_id; env-&gt;env_ipc_value = value; env-&gt;env_status = ENV_RUNNABLE; env-&gt;env_tf.tf_regs.reg_eax = 0; return 0; //panic("sys_ipc_try_send not implemented");&#125; sys_ipc_recv12345678910111213141516171819202122232425// Block until a value is ready. Record that you want to receive// using the env_ipc_recving and env_ipc_dstva fields of struct Env,// mark yourself not runnable, and then give up the CPU.// 在等到接受之前一直 阻塞，释放CPU// If 'dstva' is &lt; UTOP, then you are willing to receive a page of data.// 'dstva' is the virtual address at which the sent page should be mapped.//如果 dstva &lt;UTOP 标示你愿意接受一个页。送过来的页将映射到dstva// This function only returns on error, but the system call will eventually// return 0 on success.// Return &lt; 0 on error. Errors are:// -E_INVAL if dstva &lt; UTOP but dstva is not page-aligned.//只有这样会保存static intsys_ipc_recv(void *dstva)&#123; // LAB 4: Your code here. if((dstva &lt; (void *)UTOP) &amp;&amp; PGOFF(dstva))//报错 return -E_INVAL; curenv-&gt;env_ipc_recving = true; curenv-&gt;env_ipc_dstva = dstva; curenv-&gt;env_status = ENV_NOT_RUNNABLE; sched_yield(); //panic("sys_ipc_recv not implemented"); return 0;&#125; 最后别忘了，syscall12345case SYS_ipc_try_send: return sys_ipc_try_send((envid_t)a1, (uint32_t)a2, (void *)a3, (unsigned)a4); case SYS_ipc_recv: return sys_ipc_recv((void *)a1); default: 然后让我们实现lib/ipc.c里面的ipc_recv和ipc_send。 ipc.c12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// User-level IPC library routines#include &lt;inc/lib.h&gt;// Receive a value via IPC and return it. 接受一个IPC// If 'pg' is nonnull, then any page sent by the sender will be mapped at// that address. 如果pg非空会发送他// If 'from_env_store' is nonnull, then store the IPC sender's envid in// *from_env_store. 如果from_env_store非空就会把发送进程的id 放到 from_env_store// If 'perm_store' is nonnull, then store the IPC sender's page permission// in *perm_store (this is nonzero iff a page was successfully// transferred to 'pg'). 如果perm_store非空就会储存页权限在这// If the system call fails, then store 0 in *fromenv and *perm (if// they're nonnull) and return the error. 如果错了就会把0存到fromenv和perm如果他们非空。// Otherwise, return the value sent by the sender 否则返回值//// Hint:// Use 'thisenv' to discover the value and who sent it. 用thisenv发现是谁送的// If 'pg' is null, pass sys_ipc_recv a value that it will understand// as meaning "no page". (Zero is not the right value, since that's// a perfectly valid place to map a page.)int32_tipc_recv(envid_t *from_env_store, void *pg, int *perm_store)&#123; // LAB 4: Your code here. pg = (pg == NULL ? (void *)UTOP : pg); int r; if ((r = sys_ipc_recv(pg)) &lt; 0) &#123;//UTOP 相当于没有地址会返回0 if (from_env_store != NULL) *from_env_store = 0; if (perm_store != NULL) *perm_store = 0; return r; &#125; //如果pg==NULL 后面这两个值都毫无意义 if (from_env_store != NULL) *from_env_store = thisenv-&gt;env_ipc_from; if (perm_store != NULL) *perm_store = thisenv-&gt;env_ipc_perm; return thisenv-&gt;env_ipc_value; //panic("ipc_recv not implemented"); return 0;&#125;// Send 'val' (and 'pg' with 'perm', if 'pg' is nonnull) to 'toenv'.// This function keeps trying until it succeeds.// It should panic() on any error other than -E_IPC_NOT_RECV.// 如果不是 E_IPC_NOT_RECV 就报错。// Hint:// Use sys_yield() to be CPU-friendly.// If 'pg' is null, pass sys_ipc_try_send a value that it will understand// as meaning "no page". (Zero is not the right value.) voidipc_send(envid_t to_env, uint32_t val, void *pg, int perm)&#123; // LAB 4: Your code here. int r; while((r=sys_ipc_try_send(to_env,val, (pg == NULL ? (void *)UTOP : pg),perm))&lt;0)&#123; if(r!=-E_IPC_NOT_RECV)panic("sys_ipc_try_send: %e\n", r); sys_yield();//释放CPU &#125;//一直发送直到成功... //panic("ipc_send not implemented");&#125;// Find the first environment of the given type. We'll use this to// find special environments.// Returns 0 if no such environment exists.envid_tipc_find_env(enum EnvType type)&#123; int i; for (i = 0; i &lt; NENV; i++) if (envs[i].env_type == type) return envs[i].env_id; return 0;&#125;]]></content>
      <categories>
        <category>操作系统</category>
        <category>MIT6.828</category>
      </categories>
      <tags>
        <tag>MIT6.828</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT6.828(三)Lab3:User Environments]]></title>
    <url>%2F2020%2F02%2F18%2FMIT-6.828-(%E4%B8%89)-Lab-3-User-Environments%2F</url>
    <content type="text"><![CDATA[(最近有点事，做的比较慢。哦，不，抄的比较慢。。。) Lab 3: User EnvironmentsIntroduction在这个实验中，我们将实现操作系统的一些基本功能，来实现用户环境下的进程的正常运行。你将会加强JOS内核的功能，为它增添一些重要的数据结构，用来记录用户进程环境的一些信息；创建一个单一的用户环境，并且加载一个程序运行它。你也可以让JOS内核能够完成用户环境所作出的任何系统调用，以及处理用户环境产生的各种异常。 Getting Started照着官网上做就行了。然后会多出他说的那些文件，后面用到的时候再说。 Part A: User Environments and Exception Handling让我们看看inc/env.h的文件，里面有用户环境的一些基本定义。我们直接分析分析一下。内核使用Env数据结构来跟踪每个用户环境。 在本实验中，最初只会创建一个环境，但您需要设计JOS内核以支持多个环境; lab4将通过允许用户环境fork其他环境来利用此功能。 env.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* See COPYRIGHT for copyright information. */#ifndef JOS_INC_ENV_H#define JOS_INC_ENV_H#include &lt;inc/types.h&gt;#include &lt;inc/trap.h&gt;#include &lt;inc/memlayout.h&gt;typedef int32_t envid_t; //用户环境ID 变量，32位的。// An environment ID 'envid_t' has three parts://// +1+---------------21-----------------+--------10--------+// |0| Uniqueifier | Environment |// | | | Index |// +------------------------------------+------------------+// \--- ENVX(eid) --///// The environment index ENVX(eid) equals the environment's index in the// 'envs[]' array. The uniqueifier distinguishes environments that were// created at different times, but share the same environment index.// 这个ENV(eid) 可以获取在envs 数组里面的第几个。// All real environments are greater than 0 (so the sign bit is zero).// envid_ts less than 0 signify errors. The envid_t == 0 is special, and// stands for the current environment. 所有的 环境是大于0 的，envid_ts小于0是错误的 ，envid_t == 0 标示当前正在运行//最大能支持同时活跃的进程数量#define LOG2NENV 10#define NENV (1 &lt;&lt; LOG2NENV)#define ENVX(envid) ((envid) &amp; (NENV - 1))// Values of env_status in struct Envenum &#123; ENV_FREE = 0,//空闲 ENV_DYING,//僵尸进程 ENV_RUNNABLE,//准备就绪 ENV_RUNNING,//运行态 ENV_NOT_RUNNABLE//阻塞状态&#125;;// Special environment types 环境的特殊类型enum EnvType &#123; ENV_TYPE_USER = 0,&#125;;// 环境结构体 就是一个PCB 对这个有兴趣的同志可以看看我 的剖析 linux1.0 源码，这个就是简化版的那个东西。struct Env &#123; struct Trapframe env_tf; // Saved registers 储存寄存器，用于恢复状态 struct Env *env_link; // Next free Env 下一个空闲结构体 envid_t env_id; // Unique environment identifier 独立的标识符 envid_t env_parent_id; // env_id of this env's parent 父亲标识符 enum EnvType env_type; // Indicates special system environments 用于区别出来某特定的用户环境 unsigned env_status; // Status of the environment 前面定义的那几个状态 uint32_t env_runs; // Number of times environment has run 运行的次数 // Address space pde_t *env_pgdir; // Kernel virtual address of page dir 这个变量存放着这个环境的页目录的虚拟地址&#125;;#endif // !JOS_INC_ENV_H 分析完后，就去看 kern/env.c。这个文件先不看完，就看看他定义了什么东西。123struct Env *envs = NULL; // All environments 所有的环境struct Env *curenv = NULL; // The current env 当前环境static struct Env *env_free_list; // Free environment list 空闲环境列表 后面有一大堆介绍。Trapframe这个里面具体有啥，我们后面用到的时候再看。 Allocating the Environments Array前两个 结构体，在kern/env.h 里面有进行扩展，现在练习让我们，为他分配一个空间并映射，就是像上次为kern_pages分配空间一样，并进行映射。12345//////////////////////////////////////////////////////////////////////// Make 'envs' point to an array of size 'NENV' of 'struct Env'.// LAB 3: Your code here.envs=(struct Env*)boot_alloc(NENV*sizeof(struct Env));memset(envs,0,NENV*sizeof(struct Env)); 这个 和，上次实验是一样的，和分配kern_pgdir是一模一样的。12345678//////////////////////////////////////////////////////////////////////// Map the 'envs' array read-only by the user at linear address UENVS// (ie. perm = PTE_U | PTE_P).// Permissions:// - the new image at UENVS -- kernel R, user R// - envs itself -- kernel RW, user NONE// LAB 3: Your code here.boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U); 另外再复习一下上节课的内存分配 (下面又是盗的图，哈哈~ )。 Creating and Running Environments现在你需要去编写 kern/env.c 文件来运行一个用户环境了。由于你现在没有文件系统，所以必须把内核设置成能够加载内核中的静态二进制程序映像文件。Lab3 里面的 GNUmakefile 文件在obj/user/目录下面生成了一系列的二进制映像文件。如果你看一下 kern/Makefrag 文件，你会发现一些奇妙的地方，这些地方把二进制文件直接链接到内核可执行文件中，只要这些文件是.o文件。其中在链接器命令行中的-b binary 选项会使这些文件被当做二进制执行文件链接到内核之后。在kern/ini.c中的i386_init(),你会看到代码运行的环境中，这些二进制图像之一。然而，关键的功能设置用户环境是不完整的;您需要填写他们进来。我们照着他的意思去看看，发现相较于前几次实验，多了几行。1234567891011121314 // Lab 3 user environment initialization functions env_init(); trap_init();#if defined(TEST) // Don't touch -- used by grading script! 这些不要碰，是从来测试的 ENV_CREATE(TEST, ENV_TYPE_USER); //env_create#else // Touch all you want. ENV_CREATE(user_hello, ENV_TYPE_USER);#endif // TEST* // We only have one user environment for now, so just run it. env_run(&amp;envs[0]); 在 kern/env.h 里面可以看见这个宏的原型，就当他运行了几个不同的测试吧。我没找到这几个在哪。12345678#define ENV_PASTE3(x, y, z) x ## y ## z#define ENV_CREATE(x, type) \ do &#123; \ extern uint8_t ENV_PASTE3(_binary_obj_, x, _start)[]; \ env_create(ENV_PASTE3(_binary_obj_, x, _start), \ type); \ &#125; while (0) 不出意外，我们的任务 就是补充多出来的这几个函数了。 env_init(): 初始化所有的在envs数组中的 Env结构体，并把它们加入到 env_free_list中。 还要调用 env_init_percpu，这个函数要配置段式内存管理系统，让它所管理的段，可能具有两种访问优先级其中的一种，一个是内核运行时的0优先级，以及用户运行时的3优先级。 env_setup_vm(): 为一个新的用户环境分配一个页目录表，并且初始化这个用户环境的地址空间中的和内核相关的部分。 region_alloc(): 为用户环境分配物理地址空间 load_icode(): 分析一个ELF文件，类似于boot loader做的那样，我们可以把它的内容加载到用户环境下。 env_create(): 利用env_alloc函数和load_icode函数，加载一个ELF文件到用户环境中 env_run(): 在用户模式下，开始运行一个用户环境。 现在开始，补充kern/env.c, env_init()12345678910111213141516171819202122// Mark all environments in 'envs' as free, set their env_ids to 0,// and insert them into the env_free_list. 把所有env 加入 空闲列表，然后设置 id=0// Make sure the environments are in the free list in the same order// they are in the envs array (i.e., so that the first call to// env_alloc() returns envs[0]). 就是顺序从 0 递增 //voidenv_init(void)&#123; // Set up envs array // LAB 3: Your code here. //上面分析过 要从0 开始，所以我们倒着遍历。 env_free_list=NULL; for (size_t i=NENV-1;i&gt;=0;i--)&#123; envs[i]-&gt;env_id=0; envs[i]-&gt;env_status=ENV_FREE; envs[i]-&gt;env_link=env_free_list; env_free_list=&amp;envs[i]; &#125; // Per-CPU part of the initialization env_init_percpu();&#125; 在env_init() 中调用了env_init_percpu() 不知道这个是干啥的。根据注释，是初始化了GDT和段描述符。1234567891011121314151617181920// Load GDT and segment descriptors.voidenv_init_percpu(void)&#123; lgdt(&amp;gdt_pd); // The kernel never uses GS or FS, so we leave those set to // the user data segment. asm volatile("movw %%ax,%%gs" : : "a" (GD_UD|3)); asm volatile("movw %%ax,%%fs" : : "a" (GD_UD|3)); // The kernel does use ES, DS, and SS. We'll change between // the kernel and user data segments as needed. asm volatile("movw %%ax,%%es" : : "a" (GD_KD)); asm volatile("movw %%ax,%%ds" : : "a" (GD_KD)); asm volatile("movw %%ax,%%ss" : : "a" (GD_KD)); // Load the kernel text segment into CS. asm volatile("ljmp %0,$1f\n 1:\n" : : "i" (GD_KT)); // For good measure, clear the local descriptor table (LDT), // since we don't use it. lldt(0);&#125; env_setup_vm()初始化完 之后，因为trap()是下一个的暂时不用管，所以我们直接跳到create_env，创建这个第一个要干的肯定是分配内存,最开始要做的是分配一个页目录。这个页目录，肯定是要复制内核的一部分，因为内核那一部分，你是绝对不能动的。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//// Initialize the kernel virtual memory layout for environment e. 初始化内核虚拟布局// Allocate a page directory, set e-&gt;env_pgdir accordingly, 分配一个页目录给e-&gt;env_pgdir// and initialize the kernel portion of the new environment's address space// Do NOT (yet) map anything into the user portion// of the environment's virtual address space.//初始化内核部分，不用映射 用户部分。// Returns 0 on success, &lt; 0 on error. Errors include:// -E_NO_MEM if page directory or table could not be allocated.//成功返回 0 否则返回 -E_NO_MEMstatic intenv_setup_vm(struct Env *e)&#123; int i; struct PageInfo *p = NULL; // Allocate a page for the page directory 分配了一个页目录 if (!(p = page_alloc(ALLOC_ZERO))) return -E_NO_MEM; // Now, set e-&gt;env_pgdir and initialize the page directory. //现在设置 e-&gt;env_pgdir 然后初始化页面目录 // Hint: // - The VA space of all envs is identical above UTOP // (except at UVPT, which we've set below).va 所有 envs 的虚拟地址 都是相同的在UTOP上面 // See inc/memlayout.h for permissions and layout. // Can you use kern_pgdir as a template? Hint: Yes. 可以用kern_pgdir做一个模板 // (Make sure you got the permissions right in Lab 2.) // - The initial VA below UTOP is empty. 初始化 虚拟地址在 UTOP 是空的 // - You do not need to make any more calls to page_alloc. 你不需要去做任何的page_alloc // - Note: In general, pp_ref is not maintained for // physical pages mapped only above UTOP, but env_pgdir // is an exception -- you need to increment env_pgdir's // pp_ref for env_free to work correctly. // - The functions in kern/pmap.h are handy. // 自己翻译吧，只可意会不可言传 // LAB 3: Your code here. p-&gt;pp_ref++; e-&gt;env_pgdir=(pde_t *)page2kva(p); memcpy(e-&gt;env_pgdir, kern_pgdir, PGSIZE); // UVPT maps the env's own page table read-only. // Permissions: kernel R, user R e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U; return 0;&#125; region_alloc分配完页目录，然后就是要给用户创建空间。只有一个页目录，肯定是不行的，你必须要给用户程序使用的空间。123456789101112131415161718192021222324252627282930//// Allocate len bytes of physical memory for environment env,// and map it at virtual address va in the environment's address space.// Does not zero or otherwise initialize the mapped pages in any way.// Pages should be writable by user and kernel.// Panic if any allocation attempt fails.//分配len 字节的 物理空间给 用户环境env，映射他的虚拟地址在环境的地址空间，不要用任何方式初始化页面。权限是内核用户可写，出错就 panicstatic voidregion_alloc(struct Env *e, void *va, size_t len)&#123; // LAB 3: Your code here. // (But only if you need it for load_icode.) // // Hint: It is easier to use region_alloc if the caller can pass // 'va' and 'len' values that are not page-aligned. // You should round va down, and round (va + len) up. // (Watch out for corner-cases!) void *start=ROUNDDOWN(va,PGSIZE),*end=ROUNDUP(va+len,PGSIZE); for (void * addr=start;addr&lt;end;addr+=PGSIZE)&#123; struct PageInfo* p=page_alloc(0); if(p==NULL)&#123; panic("region alloc failed: No more page to be allocated.\n"); &#125; else &#123; if(page_insert(e-&gt;env_pgdir,p,addr, PTE_U | PTE_W)==-E_NO_MEM)&#123; panic("region alloc failed: page table couldn't be allocated.\n"); &#125; &#125; &#125;&#125; 写个函数之前，我们先去看看trap.h load_icode因为目前并没有文件系统，所以我们要需要分配的堆栈，并不是来自文件加载出来的。为了方便实验，JOS让我们像加载操作系统一样加载这些文件。这个里面用到了Trapframe,我去看了看这个东西，对于某个字段是干啥的完全没有注释所以我也不知道该分析。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//// Set up the initial program binary, stack, and processor flags// for a user process. 初始化进程的 二进制 栈 和 处理器// This function is ONLY called during kernel initialization,// before running the first user-mode environment.//这个程序只能调用在内核初始化，在运行第一个用户模式环境// This function loads all loadable segments from the ELF binary image// into the environment's user memory, starting at the appropriate// virtual addresses indicated in the ELF program header. 加载所有的 可装载程序 从 ELF二进制映象文件到内存，开始在适当的虚拟地址在ELF 的头部// At the same time it clears to zero any portions of these segments 段中任何部分初始化为0// that are marked in the program header as being mapped// but not actually present in the ELF file - i.e., the program's bss section.//// All this is very similar to what our boot loader does, except the boot// loader also needs to read the code from disk. Take a look at// boot/main.c to get ideas. 很像boot loader 做的，可以参考//// Finally, this function maps one page for the program's initial stack.//这个函数映射一个页为了初始化堆栈// load_icode panics if it encounters problems.// - How might load_icode fail? What might be wrong with the given input?//static voidload_icode(struct Env *e, uint8_t *binary)&#123; // Hints: // Load each program segment into virtual memory // at the address specified in the ELF segment header.加载每个程序段到虚拟内存 在 具体的ELF 头文件 // You should only load segments with ph-&gt;p_type == ELF_PROG_LOAD. 只需要加载ph-&gt;p_type == ELF_PROG_LOAD // Each segment's virtual address can be found in ph-&gt;p_va 每个段的虚拟地址可以在ph-&gt;p_va找到 // and its size in memory can be found in ph-&gt;p_memsz. 大小是 ph-&gt;p_memsz // The ph-&gt;p_filesz bytes from the ELF binary, starting at 文件开始在binary + ph-&gt;p_offset，应该被复制到 虚拟地址 ph-&gt;p_va。 // 'binary + ph-&gt;p_offset', should be copied to virtual address // ph-&gt;p_va. Any remaining memory bytes should be cleared to zero.其他剩下的空间初始化为0 // (The ELF header should have ph-&gt;p_filesz &lt;= ph-&gt;p_memsz.) 头部文件应该 ph-&gt;p_filesz &lt;= ph-&gt;p_memsz // Use functions from the previous lab to allocate and map pages. //使用这个前面所写的函数 // All page protection bits should be user read/write for now. 所有页都是用户可读写的 // ELF segments are not necessarily page-aligned, but you can ELF 段可能不是页对齐。 // assume for this function that no two segments will touch // the same virtual page.假设这个函数 不会两个段在同一个虚拟页 // // You may find a function like region_alloc useful. 你可以发现 region_alloc是有用的 // // Loading the segments is much simpler if you can move data // directly into the virtual addresses stored in the ELF binary. // So which page directory should be in force during // this function? 如果你可以直接移动数据存到ELF 序列里面 架子段就很容易，所以 页目录应当使用在这个函数 // // You must also do something with the program's entry point, // to make sure that the environment starts executing there. // What? (See env_run() and env_pop_tf() below.) // 你必须对程序入口指针做点什么 确保 后面用的上。 // LAB 3: Your code here. //根据，分析 首先需要做的一件事 应该是讲binary 转换成 ELF，参照bootmain。 struct Proghdr *ph, *eph; struct Elf * ELF=(struct Elf *)binary; if (ELFHDR-&gt;e_magic != ELF_MAGIC)panic("The loaded file is not ELF format!\n"); ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR-&gt;e_phoff); eph = ph + ELFHDR-&gt;e_phnum; //装载 用户目录 lcr3(PADDR(e-&gt;env_pgdir)); //第二部应该是加载段到内存 for(;ph&lt;eph;ph++)&#123; //加载条件是 ph-&gt;p_type == ELF_PROG_LOAD，地址是 ph-&gt;p_va 大小ph-&gt;p_memsz if(ph-&gt;p_type == ELF_PROG_LOAD)&#123; if (ph-&gt;p_filesz &gt; ph-&gt;p_memsz) panic("load_icode failed: p_memsz &lt; p_filesz.\n"); region_alloc(e, ph-&gt;p_va,ph-&gt;p_memsz); //复制ph-&gt;p_filesz bytes ，其他的补0 memset(ph-&gt;p_va,0,ph-&gt;p_memsz); memcpy(ph-&gt;p_va,binary + ph-&gt;p_offset,ph-&gt;p_filesz); &#125; &#125; lcr3(PADDR(kern_pgdir)); //最后是入口地址 这个实在 inc/trap.h 里面定义的 e-&gt;env_tf.tf_eip = ELFHDR-&gt;e_entry; // Now map one page for the program's initial stack // at virtual address USTACKTOP - PGSIZE. 这个函数刚写过 // LAB 3: Your code here. gion_alloc(e, (void *)(USTACKTOP - PGSIZE), PGSIZE);&#125; 在写enc_creat之前，我们先来分析一下，我们并不需要写 env_alloc，这个函数你可以理解为初始化一个env。 我们不需要知道过分的细节，但是需要了解他做了什么。 env_alloc1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//// Allocates and initializes a new environment.// On success, the new environment is stored in *newenv_store.// 分配了一个新的 环境，成功 就存在了 *newenv_store// Returns 0 on success, &lt; 0 on failure. Errors include: 失败返回两种// -E_NO_FREE_ENV if all NENV environments are allocated// -E_NO_MEM on memory exhaustion//intenv_alloc(struct Env **newenv_store, envid_t parent_id)&#123; int32_t generation; int r; struct Env *e; //首先判断空闲 环境 if (!(e = env_free_list)) return -E_NO_FREE_ENV; //设置页目录 // Allocate and set up the page directory for this environment. if ((r = env_setup_vm(e)) &lt; 0) return r; // Generate an env_id for this environment. 设置 env_id generation = (e-&gt;env_id + (1 &lt;&lt; ENVGENSHIFT)) &amp; ~(NENV - 1); if (generation &lt;= 0) // Don't create a negative env_id. generation = 1 &lt;&lt; ENVGENSHIFT; e-&gt;env_id = generation | (e - envs); // Set the basic status variables. 设置基础信息 e-&gt;env_parent_id = parent_id; e-&gt;env_type = ENV_TYPE_USER; e-&gt;env_status = ENV_RUNNABLE; e-&gt;env_runs = 0; // Clear out all the saved register state, // to prevent the register values // of a prior environment inhabiting this Env structure // from "leaking" into our new environment. 清空寄存器状态 memset(&amp;e-&gt;env_tf, 0, sizeof(e-&gt;env_tf)); // Set up appropriate initial values for the segment registers. // GD_UD is the user data segment selector in the GDT, and // GD_UT is the user text segment selector (see inc/memlayout.h). // The low 2 bits of each segment register contains the // Requestor Privilege Level (RPL); 3 means user mode. When // we switch privilege levels, the hardware does various // checks involving the RPL and the Descriptor Privilege Level // (DPL) stored in the descriptors themselves. 设置初始值 e-&gt;env_tf.tf_ds = GD_UD | 3; e-&gt;env_tf.tf_es = GD_UD | 3; e-&gt;env_tf.tf_ss = GD_UD | 3; e-&gt;env_tf.tf_esp = USTACKTOP; e-&gt;env_tf.tf_cs = GD_UT | 3; // You will set e-&gt;env_tf.tf_eip later. 这个很眼熟吧，就是上个函数用的，这个就是入口地址 // commit the allocation 空闲环境 指向另一个。 env_free_list = e-&gt;env_link; *newenv_store = e; cprintf("[%08x] new env %08x\n", curenv ? curenv-&gt;env_id : 0, e-&gt;env_id); return 0;&#125; env_create函数作用就是根据binary 创建一个env 。1234567891011121314151617181920//// Allocates a new env with env_alloc, loads the named elf// binary into it with load_icode, and sets its env_type.// This function is ONLY called during kernel initialization,// before running the first user-mode environment.// The new env's parent ID is set to 0.// 分配一个新的env 通过env_alloc 加载elf，设置他的its env_type 这个函数只在内核初始化抵用，在跑第一个用户环境，父亲设置为 0voidenv_create(uint8_t *binary, enum EnvType type)&#123; // LAB 3: Your code here. struct Env * e; int r=env_alloc(&amp;e,0); if(r!=0)&#123; cprintf("%e\n",r); panic("env_create:error"); &#125; load_icode(e,binary); e-&gt;env_type=type;&#125; env_run这个就是真正的用户环境运行了。123456789101112131415161718192021222324252627282930313233343536373839/// Context switch from curenv to env e. 上下文切换到 e// Note: if this is the first call to env_run, curenv is NULL.//如果第一个调用 curenv 是空的// This function does not return.//voidenv_run(struct Env *e)&#123; // Step 1: If this is a context switch (a new environment is running): 如果有上下文切换 // 1. Set the current environment (if any) back to 第一步当前环境 就绪状态 // ENV_RUNNABLE if it is ENV_RUNNING (think about // what other states it can be in), // 2. Set 'curenv' to the new environment, 当前运行变成 新的环境 // 3. Set its status to ENV_RUNNING, 设置他的状态为 运行 // 4. Update its 'env_runs' counter, 更新计数 // 5. Use lcr3() to switch to its address space. 修改地址空间 // Step 2: Use env_pop_tf() to restore the environment's 第二部 使用那个啥恢复环境 // registers and drop into user mode in the // environment. // Hint: This function loads the new environment's state from 这个函数重新加载 新的用户转台 从啥 // e-&gt;env_tf. Go back through the code you wrote above // and make sure you have set the relevant parts of // e-&gt;env_tf to sensible values. 确保 那个哈是个真确的值 // LAB 3: Your code here. if(curenv!=NULL&amp;&amp;curenv-&gt;env_status==ENV_RUNNING)&#123; curenv-&gt;env_status=ENV_RUNNABLE; &#125; curenv=e; // if(&amp;curenv-&gt;env_tf==NULL)cprintf("***"); e-&gt;env_status=ENV_RUNNING; e-&gt;env_runs++; lcr3(PADDR(curenv-&gt;env_pgdir)); cprintf("%x\n",curenv-&gt;env_tf.tf_eip); env_pop_tf(&amp;curenv-&gt;env_tf); panic("env_run not yet implemented");//这个注释不注释没啥影响，因为我们现在就运行了一个 env，上面那个函数已经转移了，等他再来运行这一行，说明整个操作系统已经结束了。&#125; 我们再分析分析这个文件里面一些其他的函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//// Frees env e and all memory it uses.//voidenv_free(struct Env *e)&#123; pte_t *pt; uint32_t pdeno, pteno; physaddr_t pa; // If freeing the current environment, switch to kern_pgdir // before freeing the page directory, just in case the page // gets reused. if (e == curenv) lcr3(PADDR(kern_pgdir)); //切换到内核 // Note the environment's demise. cprintf("[%08x] free env %08x\n", curenv ? curenv-&gt;env_id : 0, e-&gt;env_id);//打印信息 // Flush all mapped pages in the user portion of the address space static_assert(UTOP % PTSIZE == 0); //刷新所有映射 for (pdeno = 0; pdeno &lt; PDX(UTOP); pdeno++) &#123; // only look at mapped page tables if (!(e-&gt;env_pgdir[pdeno] &amp; PTE_P)) continue; // find the pa and va of the page table pa = PTE_ADDR(e-&gt;env_pgdir[pdeno]); pt = (pte_t*) KADDR(pa); // unmap all PTEs in this page table 取消所有映射 for (pteno = 0; pteno &lt;= PTX(~0); pteno++) &#123; if (pt[pteno] &amp; PTE_P) page_remove(e-&gt;env_pgdir, PGADDR(pdeno, pteno, 0)); &#125; // free the page table itself e-&gt;env_pgdir[pdeno] = 0; page_decref(pa2page(pa)); &#125; // free the page directory 把页目录删掉 pa = PADDR(e-&gt;env_pgdir); e-&gt;env_pgdir = 0; page_decref(pa2page(pa)); // return the environment to the free list e-&gt;env_status = ENV_FREE; e-&gt;env_link = env_free_list; env_free_list = e;&#125;//// Frees environment e.//voidenv_destroy(struct Env *e)&#123; env_free(e); cprintf("Destroyed the only environment - nothing more to do!\n"); while (1) monitor(NULL);&#125;//// Restores the register values in the Trapframe with the 'iret' instruction.// This exits the kernel and starts executing some environment's code.//// This function does not return. //voidenv_pop_tf(struct Trapframe *tf) //这个就是跳转，&#123; asm volatile( "\tmovl %0,%%esp\n" "\tpopal\n" "\tpopl %%es\n" "\tpopl %%ds\n" "\taddl $0x8,%%esp\n" /* skip tf_trapno and tf_errcode */ "\tiret\n" : : "g" (tf) : "memory"); panic("iret failed"); /* mostly to placate the compiler */&#125; 一旦你完成上述子函数的代码，并且在QEMU下编译运行，系统会进入用户空间，并且开始执行hello程序，直到它做出一个系统调用指令int。但是这个系统调用指令不能成功运行，因为到目前为止，JOS还没有设置相关硬件来实现从用户态向内核态的转换功能。当CPU发现，它没有被设置成能够处理这种系统调用中断时，它会触发一个保护异常，然后发现这个保护异常也无法处理，从而又产生一个错误异常，然后又发现仍旧无法解决问题，所以最后放弃，我们把这个叫做”triple fault”。通常来说，接下来CPU会复位，系统会重启。 所以我们马上要来解决这个问题，不过解决之前我们可以使用调试器来检查一下程序要进入用户模式时做了什么。使用make qemu-gdb 并且在 env_pop_tf 处设置断点，这条指令应该是即将进入用户模式之前的最后一条指令。然后进行单步调试，处理会在执行完iret 指令后进入用户模式。然后依旧可以看到进入用户态后执行的第一条指令了，该指令是一个cmp指令，开始于文件 lib/entry.S 中。 现在使用 b *0x... 设置一个断点在hello文件（obj/user/hello.asm）中的sys_cputs函数中的 int $0x30 指令处。这个int指令是一个系统调用，用来展示一个字符到控制台。如果你的程序运行不到这个int指令，说明有错误。其实不用上面那么麻烦，直接运行make qemu-gdb 然后输入c指令，最终make gdb 会停在 int $0x30,然后qemu 会显示错误”triple fault”。 (后面大部分都是理论文字，大部分都是翻译过来的，所以直接照搬了大佬门博客里面的。英语水平不好，怕翻译了看不懂) Handling Interrupts and Exceptions 到目前为止，当程序运行到第一个系统调用int $0x30 时，就会进入错误的状态，因为现在系统无法从用户态切换到内核态。所以你需要实现一个基本的异常/系统调用处理机制，使得内核可以从用户态转换为内核态。你应该先熟悉一下X86的异常中断机制。 Basics of Protected Control Transfer&emsp;异常(Exception)和中断(Interrupts)都是“受到保护的控制转移方法”，都会使处理器从用户态转移为内核态。在Intel的术语中，一个中断指的是由外部异步事件引起的处理器控制权转移，比如外部IO设备发送来的中断信号。一个异常则是由于当前正在运行的指令所带来的同步的处理器控制权的转移，比如除零溢出异常。 &emsp;为了能够确保这些控制的转移能够真正被保护起来，处理器的中断/异常机制通常被设计为：用户态的代码无权选择内核中的代码从哪里开始执行。处理器可以确保只有在某些条件下，才能进入内核态。在X86上，有两种机制配合工作来提供这种保护： 中断向量表：处理器保证中断和异常只能够引起内核进入到一些特定的，被事先定义好的程序入口点，而不是由触发中断的程序来决定中断程序入口点。 &emsp;X86允许多达256个不同的中断和异常，每一个都配备一个独一无二的中断向量。一个向量指的就是0到255中的一个数。一个中断向量的值是根据中断源来决定的：不同设备，错误条件，以及对内核的请求都会产生出不同的中断和中断向量的组合。CPU将使用这个向量作为这个中断在中断向量表中的索引，这个表是由内核设置的，放在内核空间中，和GDT很像。通过这个表中的任意一个表项，处理器可以知道：需要加载到EIP寄存器中的值，这个值指向了处理这个中断的中断处理程序的位置。 需要加载到CS寄存器中的值，里面还包含了这个中断处理程序的运行特权级。（即这个程序是在用户态还是内核态下运行。） 任务状态段:处理器还需要一个地方来存放，当异常/中断发生时，处理器的状态，比如EIP和CS寄存器的值。这样的话，中断处理程序一会可以重新返回到原来的程序中。这段内存自然也要保护起来，不能被用户态的程序所篡改。 正因为如此，当一个x86处理器要处理一个中断，异常并且使运行特权级从用户态转为内核态时，它也会把它的堆栈切换到内核空间中。一个叫做 “任务状态段（TSS）”的数据结构将会详细记录这个堆栈所在的段的段描述符和地址。处理器会把SS，ESP，EFLAGS，CS，EIP以及一个可选错误码等等这些值压入到这个堆栈上。然后加载中断处理程序的CS，EIP值，并且设置ESP，SS寄存器指向新的堆栈。 尽管TSS非常大，并且还有很多其他的功能，但是JOS仅仅使用它来定义处理器从用户态转向内核态所采用的内核堆栈，由于JOS中的内核态指的就是特权级0，所以处理器用TSS中的ESP0，SS0字段来指明这个内核堆栈的位置，大小。 Types of Exceptions and Interrupts &emsp;所有的由X86处理器内部产生的异常的向量值是0到31之间的整数。比如，页表错所对应的向量值是14.而大于31号的中断向量对应的是软件中断，由int指令生成；或者是外部中断，由外部设备生成。&emsp;在这一章，我们将扩展JOS的功能，使它能够处理0~31号内部异常。在下一章会让JOS能够处理48号软件中断，主要被用来做系统调用。在Lab 4中会继续扩展JOS使它能够处理外部硬件中断，比如时钟中断。 An Example让我们试一下除0 处理器会首先切换自己的堆栈，切换到由TSS的SS0，ESP0字段所指定的内核堆栈区，这两个字段分别存放着GD_KD和KSTACKTOP的值。 处理器把异常参数压入到内核堆栈中，起始于地址KSTACKTOP： 因为我们要处理的是除零异常，它的中断向量是0，处理器会读取IDT表中的0号表项，并且把CS:EIP的值设置为0号中断处理函数的地址值。 中断处理函数开始执行处理中断。 对于某些特定类型的x86异常，除了上面图中要保存5五个字之外，还要再压入一个字，叫做错误码。比如页错误，就是其中一个实例。当压入错误码之后，内核堆栈的状态如下： Nested Exceptions and Interrupts处理器在用户态下和内核态下都可以处理异常或中断。只有当处理器从用户态切换到内核态时，才会自动地切换堆栈，并且把一些寄存器中的原来的值压入到堆栈上，并且调用IDT指定的合适的异常处理程序。但如果处理器已经由于正在处理中断而处在内核态下时（CS寄存器的低两位已经都是0），此时CPU只会向内核堆栈压入更多的值。通过这种方式，内核就可处理嵌套中断。 如果处理器已经在内核态下并且遇到嵌套中断，因为它不需要切换堆栈，所以它不需要存储原来的SS，ESP寄存器的值。如果这个异常类型不压入错误码，此时内核堆栈的就像下面这个样子：这里有一个重要的警告,如果处理器在内核态下接受一个异常，而且由于一些原因，比如堆栈空间不足，不能把当前的状态信息（寄存器的值）压入到内核堆栈中时，那么处理器是无法恢复到原来的状态了，它会自动重启。 Setting Up the IDT(又要准备干活了) 你现在应该有了建立IDT表以及JOS处理异常的基本信息。我们现在只需要开始建立表就行了。是否记得lab 2里面的内存分布，最低的那一页就是存这个的。然后我们去看看inc/trap.h,那个kern/trap.h自己看看就行了。如果想知道各个中断具体是啥看这个。 trap.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#ifndef JOS_INC_TRAP_H#define JOS_INC_TRAP_H// Trap numbers// These are processor defined: 这是各种中断 对于这些建议大家学学嵌入式，手写个CPU（我的github 上有个简单的...） 下面各种错误还是大家自行百度，我解释几个常用的#define T_DIVIDE 0 // divide error 除0#define T_DEBUG 1 // debug exception #define T_NMI 2 // non-maskable interrupt 非屏蔽中断？？？#define T_BRKPT 3 // breakpoint 断点#define T_OFLOW 4 // overflow 溢出#define T_BOUND 5 // bounds check 边界检查？#define T_ILLOP 6 // illegal opcode 非法操作码 #define T_DEVICE 7 // device not available 设备不可用#define T_DBLFLT 8 // double fault /* #define T_COPROC 9 */ // reserved (not generated by recent processors)#define T_TSS 10 // invalid task switch segment 无效任务段切换#define T_SEGNP 11 // segment not present 段不存在#define T_STACK 12 // stack exception 栈异常#define T_GPFLT 13 // general protection fault#define T_PGFLT 14 // page fault 页错误/* #define T_RES 15 */ // reserved#define T_FPERR 16 // floating point error 浮点错误#define T_ALIGN 17 // aligment check 对齐检查#define T_MCHK 18 // machine check #define T_SIMDERR 19 // SIMD floating point error// These are arbitrarily chosen, but with care not to overlap 下面可以任意选择，但是不要重叠// processor defined exceptions or interrupt vectors. 应该就是 自定义 异常#define T_SYSCALL 48 // system call#define T_DEFAULT 500 // catchall#define IRQ_OFFSET 32 // IRQ 0 corresponds to int IRQ_OFFSET 外部中断// Hardware IRQ numbers. We receive these as (IRQ_OFFSET+IRQ_WHATEVER)#define IRQ_TIMER 0#define IRQ_KBD 1#define IRQ_SERIAL 4#define IRQ_SPURIOUS 7#define IRQ_IDE 14#define IRQ_ERROR 19#ifndef __ASSEMBLER__#include &lt;inc/types.h&gt;//保存通用寄存器的值struct PushRegs &#123; /* registers as pushed by pusha */ uint32_t reg_edi; uint32_t reg_esi; uint32_t reg_ebp; uint32_t reg_oesp; /* Useless */ uint32_t reg_ebx; uint32_t reg_edx; uint32_t reg_ecx; uint32_t reg_eax;&#125; __attribute__((packed));//任务段struct Trapframe &#123; struct PushRegs tf_regs; uint16_t tf_es; uint16_t tf_padding1; uint16_t tf_ds; uint16_t tf_padding2; uint32_t tf_trapno; /* below here defined by x86 hardware 下面是x86 硬件定义的 */ uint32_t tf_err; uintptr_t tf_eip; uint16_t tf_cs; uint16_t tf_padding3; uint32_t tf_eflags; /* below here only when crossing rings, such as from user to kernel 不知道是啥*/ uintptr_t tf_esp; uint16_t tf_ss; uint16_t tf_padding4;&#125; __attribute__((packed));#endif /* !__ASSEMBLER__ */#endif /* !JOS_INC_TRAP_H */ 最后你要实现的控制流的效果如下：每一个中断或异常都有相应定义在trapentry.S中中断处理程序,trap_init()将用这些中断处理程序的地址初始化IDT。每一个处理程序都应该在堆栈上构建一个结构体struct Trapframe，并且调用trap()函数指向这个结构体，trap()然后处理异常/中断，给他分配一个中断处理函数。 练习4 要你编辑上面说这些东西。我们跟着他走，TRAPHANDLER_NOEC和TRAPHANDLER_NOEC，我们看看是啥。 TRAPHANDLER_NOEC和TRAPHANDLER_NOEC在这个文件里面，也就是为每个中断创建一个函数，然后调用trap()1234567891011121314151617181920212223242526272829303132333435#################################################################### exceptions/interrupts###################################################################/* TRAPHANDLER defines a globally-visible function for handling a trap. 定义了一个全局可见的函数，用来处理trap * It pushes a trap number onto the stack, then jumps to _alltraps. * Use TRAPHANDLER for traps where the CPU automatically pushes an error code. * 他会把 陷阱号自推入堆栈，然后跳转 _alltraps，使用这个可以自动推入 错误码。 * You shouldn't call a TRAPHANDLER function from C, but you may * need to _declare_ one in C (for instance, to get a function pointer * during IDT setup). You can declare the function with * void NAME(); 如果你想在C里面用要声明一下 * where NAME is the argument passed to TRAPHANDLER. */ /* 翻译过来 就是创建了一个 函数，name ，然后做了下面这些事*/#define TRAPHANDLER(name, num) \ .globl name; /* define global symbol for 'name' 第一全局符号name */ \ .type name, @function; /* symbol type is function 符号类型是函数*/ \ .align 2; /* align function definition 对齐函数定义 */ \ name: /* function starts here 函数定义 */ \ pushl $(num); \ jmp _alltraps/* Use TRAPHANDLER_NOEC for traps where the CPU doesn't push an error code. * It pushes a 0 in place of the error code, so the trap frame has the same * format in either case. 这个 和上面的区别就是不会 压入 错误码，用0来替代了？？ */#define TRAPHANDLER_NOEC(name, num) \ .globl name; \ .type name, @function; \ .align 2; \ name: \ pushl $0; \ pushl $(num); \ jmp _alltraps inc/trap.h已经分析过了。然后他说 我们需要实现_alltraps。还需要在trap_init() 里面实现初始化入口定义。然后SETGATE会帮助我们。所以我们去看看STEGATE干了啥.由于我并不知道他在哪，所以我们用grep搜一下。发现在mmu.h里面，上次我们分析了一部分，因为后面的没有用上，我就注释了一部分。如果已经知道的了就直接跳过。 123456789101112131415161718192021222324252627282930313233343536373839404142// Set up a normal interrupt/trap gate descriptor. 设置一个正常中断陷阱入口 描述符// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate. 1是trap 0是interrupt // see section 9.6.1.3 of the i386 reference: "The difference between //看看那个啥 // an interrupt gate and a trap gate is in the effect on IF (the //中断门和陷阱门有啥不一样在IF（中断允许的标志）上面 // interrupt-enable flag). An interrupt that vectors through an//中断向量通过 中断门重置 IF 从而组织其他中断中断当前中断。 // interrupt gate resets IF, thereby preventing other interrupts from // interfering with the current interrupt handler. A subsequent IRET // 然后然后用IRET 恢复。 // instruction restores IF to the value in the EFLAGS image on the // stack. An interrupt through a trap gate does not change IF." //说的简单点，中断不能再次中断，trap 可以被中断。// - sel: Code segment selector for interrupt/trap handler 代码段地址// - off: Offset in code segment for interrupt/trap handler //代码段偏移// - dpl: Descriptor Privilege Level - 特权等级// the privilege level required for software to invoke //软件等级// this interrupt/trap gate explicitly using an int instruction.//int 指令调用？#define SETGATE(gate, istrap, sel, off, dpl) \&#123; \ (gate).gd_off_15_0 = (uint32_t) (off) &amp; 0xffff; \ (gate).gd_sel = (sel); \ (gate).gd_args = 0; \ (gate).gd_rsv1 = 0; \ (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32; \ (gate).gd_s = 0; \ (gate).gd_dpl = (dpl); \ (gate).gd_p = 1; \ (gate).gd_off_31_16 = (uint32_t) (off) &gt;&gt; 16; \&#125;// Set up a call gate descriptor. //建立呼叫门描述？？？ 和上面好像没啥差距，就是少了个istrap#define SETCALLGATE(gate, sel, off, dpl) \&#123; \ (gate).gd_off_15_0 = (uint32_t) (off) &amp; 0xffff; \ (gate).gd_sel = (sel); \ (gate).gd_args = 0; \ (gate).gd_rsv1 = 0; \ (gate).gd_type = STS_CG32; \ (gate).gd_s = 0; \ (gate).gd_dpl = (dpl); \ (gate).gd_p = 1; \ (gate).gd_off_31_16 = (uint32_t) (off) &gt;&gt; 16; \&#125; 后面就是告诉你_alltraps 要实现啥。我们还是先实现第一个trapentry.S.12345678910111213141516171819202122232425262728293031323334353637383940414243.text/* * Lab 3: Your code here for generating entry points for the different traps. */ /* 我现在也不知道为啥这个是这个 那个是那个*/TRAPHANDLER_NOEC(t_divide, T_DIVIDE)TRAPHANDLER_NOEC(t_debug, T_DEBUG)TRAPHANDLER_NOEC(t_nmi, T_NMI)TRAPHANDLER_NOEC(t_brkpt, T_BRKPT)TRAPHANDLER_NOEC(t_oflow, T_OFLOW)TRAPHANDLER_NOEC(t_bound, T_BOUND)TRAPHANDLER_NOEC(t_illop, T_ILLOP)TRAPHANDLER_NOEC(t_device, T_DEVICE)TRAPHANDLER(t_dblflt, T_DBLFLT)TRAPHANDLER(t_tss, T_TSS)TRAPHANDLER(t_segnp, T_SEGNP)TRAPHANDLER(t_stack, T_STACK)TRAPHANDLER(t_gpflt, T_GPFLT)TRAPHANDLER(t_pgflt, T_PGFLT)TRAPHANDLER_NOEC(t_fperr, T_FPERR)TRAPHANDLER(t_align, T_ALIGN)TRAPHANDLER_NOEC(t_mchk, T_MCHK)TRAPHANDLER_NOEC(t_simderr, T_SIMDERR)TRAPHANDLER_NOEC(t_syscall, T_SYSCALL)/* * Lab 3: Your code here for _alltraps */ _alltraps: pushl %ds pushl %es pushal /* push all general registers */ movl $GD_KD, %eax movw %ax, %ds movw %ax, %es push %esp call trap 然后 trap_init()；12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void t_divide();void t_debug();void t_nmi();void t_brkpt();void t_oflow();void t_bound();void t_illop();void t_device();void t_dblflt();void t_tss();void t_segnp();void t_stack();void t_gpflt();void t_pgflt();void t_fperr();void t_align();void t_mchk();void t_simderr();void t_syscall();voidtrap_init(void)&#123; extern struct Segdesc gdt[]; // LAB 3: Your code here. SETGATE(idt[T_DIVIDE], 0, GD_KT, t_divide, 0); SETGATE(idt[T_DEBUG], 0, GD_KT, t_debug, 0); SETGATE(idt[T_NMI], 0, GD_KT, t_nmi, 0); SETGATE(idt[T_BRKPT], 0, GD_KT, t_brkpt, 3); SETGATE(idt[T_OFLOW], 0, GD_KT, t_oflow, 0); SETGATE(idt[T_BOUND], 0, GD_KT, t_bound, 0); SETGATE(idt[T_ILLOP], 0, GD_KT, t_illop, 0); SETGATE(idt[T_DEVICE], 0, GD_KT, t_device, 0); SETGATE(idt[T_DBLFLT], 0, GD_KT, t_dblflt, 0); SETGATE(idt[T_TSS], 0, GD_KT, t_tss, 0); SETGATE(idt[T_SEGNP], 0, GD_KT, t_segnp, 0); SETGATE(idt[T_STACK], 0, GD_KT, t_stack, 0); SETGATE(idt[T_GPFLT], 0, GD_KT, t_gpflt, 0); SETGATE(idt[T_PGFLT], 0, GD_KT, t_pgflt, 0); SETGATE(idt[T_FPERR], 0, GD_KT, t_fperr, 0); SETGATE(idt[T_ALIGN], 0, GD_KT, t_align, 0); SETGATE(idt[T_MCHK], 0, GD_KT, t_mchk, 0); SETGATE(idt[T_SIMDERR], 0, GD_KT, t_simderr, 0); SETGATE(idt[T_SYSCALL], 0, GD_KT, t_syscall, 3); // Per-CPU setup trap_init_percpu();&#125; 用这个可以过了，但是我看到一个非常骚的操作，也就是挑战.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#define TRAPHANDLER(name, num, ec, user) \.text; \ .globl name; /* define global symbol for 'name' */ \ .type name, @function; /* symbol type is function */ \ .align 2; /* align function definition */ \ name: /* function starts here */ \ .if ec==0; \ pushl $0; \ .endif; \ pushl $(num); \ jmp _alltraps; \.data; \ .long num, name, user.data .globl trapEntry trapEntry:.textTRAPHANDLER(trapEntry0, T_DIVIDE, 0, 0);TRAPHANDLER(trapEntry1, T_DEBUG, 0, 0);TRAPHANDLER(trapEntry2, T_NMI, 0, 0);TRAPHANDLER(trapEntry3, T_BRKPT, 0, 3);TRAPHANDLER(trapEntry4, T_OFLOW, 0, 0);TRAPHANDLER(trapEntry5, T_BOUND, 0, 0);TRAPHANDLER(trapEntry6, T_ILLOP, 0, 0);TRAPHANDLER(trapEntry7, T_DEVICE, 0, 0);TRAPHANDLER(trapEntry8, T_DBLFLT, 1, 0);TRAPHANDLER(trapEntry10, T_TSS, 1, 0);TRAPHANDLER(trapEntry11, T_SEGNP, 1, 0);TRAPHANDLER(trapEntry12, T_STACK, 1, 0);TRAPHANDLER(trapEntry13, T_GPFLT, 1, 0);TRAPHANDLER(trapEntry14, T_PGFLT, 1, 0);TRAPHANDLER(trapEntry16, T_FPERR, 0, 0);TRAPHANDLER(trapEntry17, T_ALIGN, 1, 0);TRAPHANDLER(trapEntry18, T_MCHK, 0, 0);TRAPHANDLER(trapEntry19, T_SIMDERR, 0, 0);//TRAPHANDLER(trapEntry20, T_SYSCALL, 1, 3);.data .long 0, 0, 0/* * Lab 3: Your code here for _alltraps */.text_alltraps: pushl %ds pushl %es pushal /* push all general registers */ movw $GD_KD, %ax movw %ax, %ds movw %ax, %es pushl %esp call trapvoidtrap_init(void)&#123; extern struct Segdesc gdt[]; extern long trapEntry[][3]; // trapEntry[][0]: interrupt/exception vector // trapEntry[][1]: interrupt/exception handler trapEntry point // trapEntry[][2]: DPL for (int i = 0; trapEntry[i][1] != 0; i++ ) SETGATE(idt[trapEntry[i][0]], 0, GD_KT, trapEntry[i][1], trapEntry[i][2]); // Per-CPU setup trap_init_percpu();&#125; 神仙写法，看不懂，但是大致能理解啥意思。骚不过，骚不过，真的骚不过。 Question第一个没有必要回答了吧。不同中断处理不同。第二个问题，好像问user/softint为啥会产生 trap 13 中断。查看user/softint.c123456789// buggy program - causes an illegal software interrupt#include &lt;inc/lib.h&gt;voidumain(int argc, char **argv)&#123; asm volatile("int $14"); // page fault&#125; 调用int $14产生了一个软中断。当异常或中断是由int n,int 3,int 0指令产生时，处理器才会检查中断或陷阱门的DPL。此时CPL数值上必须小于或等于DPL。这个限制可以防止特权级为3的应用程序使用软件中断访问重要的异常处理过程。当用户级使用软件中断时会引发一个General Protection Exception，即trap 13。 Part B: Page Faults, Breakpoints Exceptions, and System Calls我们现在已经有了处理一部分中断的能力了，然我们来看看他做了啥。在中断最后一个函数_alltraps调用了trap(),然后我们去了kern/trap()里面。我们来分析分析。1234567891011121314151617181920212223242526272829303132333435363738394041voidtrap(struct Trapframe *tf)&#123; // The environment may have set DF and some versions // of GCC rely on DF being clear CLD 清除DF 复位 干啥的也不知道 asm volatile("cld" ::: "cc"); // Check that interrupts are disabled. If this assertion // fails, DO NOT be tempted to fix it by inserting a "cli" in // the interrupt path. 看中断有没有关了 assert(!(read_eflags() &amp; FL_IF));//检查EFLAGS寄存器的IF标志位是否置0，即忽略可屏蔽的外部中断 cprintf("Incoming TRAP frame at %p\n", tf); if ((tf-&gt;tf_cs &amp; 3) == 3) &#123;//if语句判断TrapFrame中的cs寄存器的CPL是否等于3，即是否是从用户态触发的中断 //如果从用户态触发的中断，检查当前进程是否存在，这个应该是检查monitor下是不能出现中断的，然后更新当前进程的env_tf域，并最终将tf指针更新为进程的env_tf域的指针，这么做的原因会在下一篇文章[启动用户进程，产生中断、系统调用的过程分析]中说明 // Trapped from user mode. assert(curenv); // Copy trap frame (which is currently on the stack) // into 'curenv-&gt;env_tf', so that running the environment // will restart at the trap point. curenv-&gt;env_tf = *tf; // The trapframe on the stack should be ignored from here on. tf = &amp;curenv-&gt;env_tf; &#125; // Record that tf is the last real trapframe so // print_trapframe can print some additional information. //更新last_tf last_tf = tf; // Dispatch based on what type of trap occurred //于发生的中断的类型进行分发。 trap_dispatch(tf); // Return to the current environment, which should be running. //回到进程的用户态 assert(curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING); env_run(curenv);&#125; 也就是说 ，我们在 trap_dispatch()对中断进行了分配。 Handling Page Faults缺页故障的中断向量为14(T_PGFLT)是一个很重要的异常，因为我们在后续的实验中，非常依赖于能够处理缺页中断的能力。当缺页中断发生时，系统会把引起中断的线性地址存放到控制寄存器CR2中。在trap.c中，已经提供了一个能够处理这种缺页异常的函数page_fault_handler()。所以我们就要分配到这个函数。这个if else 或者switch 判断一下就行，没啥说的不需要先做任何操作。1234switch(tf-&gt;tf_trapno) &#123; case (T_PGFLT): page_fault_handler(tf); break; 就这样就行了。接着我们去看看 page_fault_handler()123456789101112131415161718192021222324voidpage_fault_handler(struct Trapframe *tf)&#123; uint32_t fault_va; // Read processor's CR2 register to find the faulting address fault_va = rcr2(); // Handle kernel-mode page faults. // LAB 3: Your code here. if(tf-&gt;tf_cs &amp;&amp; 0x01 == 0) &#123; //发生在内核态 就报错，因为如果是内核态出错，说明内核出问题了 panic("page_fault in kernel mode, fault address %d\n", fault_va); &#125; // We've already handled kernel-mode exceptions, so if we get here, // the page fault happened in user mode. // Destroy the environment that caused the fault. //如果是用户态，就删除这个进程 cprintf("用户态内存出错 ：[%08x] user fault va %08x ip %08x\n", curenv-&gt;env_id, fault_va, tf-&gt;tf_eip); print_trapframe(tf); env_destroy(curenv);&#125; 后面还会继续完善，当我们完成系统调用 The Breakpoint Exception断点异常的中断向量为3(T_BRKPT)，这个异常可以让调试器能够给程序加上断点。加断点的基本原理就是把要加断点的语句用一个1字节的INT 3软件中断指令替换，执行到INT 3时，会触发软中断。在JOS中，我们将通过把这个异常转换成一个伪系统调用，这样的话任何用户环境都可以使用这个伪系统调用来触发JOS kernel monitor。如果将JOS kernel monitor当做原始的调试器的话，断点异常的这种用法实际上是合理的。lib/panic.c中panic()函数的用户态实现就是在展示panic信息之后，调用int 3。 这个我也每个搞懂，为啥是调用monitor. 123case (T_BRKPT): monitor(tf); break; 后面的挑战，是要我们实现，单步调试啥的。我不会告辞。 Question 问你为啥运行breakpoint(怎么运行这个，前面有个练习是说了 run-name)可以是General Protection 也可以是是Breakpoint.这个是由trap_init 初始化的时候做的。和练习二是一样的问题。SETGATE(idt[T_BRKPT], 0, GD_KT, t_brkpt, 3);把最后这个3 换成0，你再跑一下就知道为啥了。DPL字段代表的含义是段描述符优先级（Descriptor Privileged Level），如果我们想要当前执行的程序能够跳转到这个描述符所指向的程序哪里继续执行的话，有个要求，就是要求当前运行程序的CPL，RPL的最大值需要小于等于DPL，否则就会出现优先级低的代码试图去访问优先级高的代码的情况，就会触发general protection exception。那么我们的测试程序首先运行于用户态，它的CPL为3，当异常发生时，它希望去执行 int 3指令，这是一个系统级别的指令，用户态命令的CPL一定大于 int 3 的DPL，所以就会触发general protection exception，但是如果把IDT这个表项的DPL设置为3时，就不会出现这样的现象了，这时如果再出现异常，肯定是因为我们还没有编写处理break point exception的程序所引起的，所以是break point exception。 简单来说，就是breakpoint假如设置在内核态，用户态就需要保护一下，进入内核态。 这个和上面差不多。System calls用户程序通过系统调用让内核帮它做事。当用户程序触发系统调用，处理器进入内核态。处理器和内核合作保存该用户程序当前的状态，然后由内核将执行相应的代码完成系统调用，最终回到用户程序继续执行。而用户程序到底是如何引起内核的注意，以及它如何说明它希望操作系统做什么事情的方法是有很多不同的实现方式的。 在JOS内核中，我们会采用int指令触发一个处理器的中断。特别的，我们用int $0x30来代表系统调用中断。注意，中断0x30不是通过硬件产生的，应该允许用户代码能够产生0x30中断。 应用程序会把系统调用号以及系统调用的参数放到寄存器中。通过这种方法，内核就不需要去查询用户程序的堆栈或指令流了。系统调用号存放到%eax中，参数则存放在%edx,%ecx,%ebx,%edi, 和 %esi 中。内核会把返回值送到%eax中。在lib/syscall.c中的syscall()函数就是触发一个系统调用的代码。不用说了，我们先去看看。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// System call stubs.#include &lt;inc/syscall.h&gt;#include &lt;inc/lib.h&gt;/* 来自一个大佬* 在JOS中所有系统调用通过syscall这个函数进行：执行int T_SYSCALL，把函数参数存入若干指定的寄存器* 并指定函数返回值返回到寄存器ax中* 用第一个参数num来确定到底是哪个系统调用* 参数num == SYS_cputs，check == 0，a1 == b-&gt;buf， a2 == b-&gt;idx，剩下a3、a4、a5都为0*/static inline int32_tsyscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)&#123; int32_t ret; asm volatile("int %1\n" //汇编指令模板，%1是占位符，对应后面的T_SYSCALL : "=a" (ret) //=表示在汇编里只能改变该C变量的值，而不能取它的值 //ret值与%ax相联系，即指令执行完后ax的值存入变量ret : "i" (T_SYSCALL), //中断向量T_SYSCALL，是立即数 "a" (num), //输入参数num，指令执行前先将num变量的值存入%ax "d" (a1), //输入参数a1，指令执行前先将a1变量的值存入%dx "c" (a2), //参数a2存入%cx "b" (a3), //参数a3存入%bx "D" (a4), //参数a4存入%di "S" (a5), //参数a5存入%si : "cc", "memory"); //向gcc声明在这条汇编语言执行后，标志寄存器eflags和内存可能发生改变 //加入“memory”，告诉GCC内存已经被修改，GCC得知这个信息后， //就会在这段指令之前，插入必要的指令将前面因为优化缓存到寄存器中 //的变量值先写回内存，如果以后又要使用这些变量再重新读取。 if(check &amp;&amp; ret &gt; 0) panic("syscall %d returned %d (&gt; 0)", num, ret); return ret;&#125;//下面是各个函数。 //输出？？ 在控制台输入输出 是要进入内核态的voidsys_cputs(const char *s, size_t len)&#123; syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);&#125;//获取？？？intsys_cgetc(void)&#123; return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);&#125;//删除？？？intsys_env_destroy(envid_t envid)&#123; return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);&#125;//获取id？？？envid_tsys_getenvid(void)&#123; return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);&#125; 看完之后来做练习7，那个啥，让我们去把这个加入异常，我们原本就已经加入进去了，不用管。后面我就看不懂了…，我发现系统内核里面还有个kern/syscall.c这个是干啥的。到底调用哪个。。。别人说kern/syscall.c是外壳，但是我个人感觉inc/syscall.c才是。我觉得应该是inc/syscall.c调用了kern/syscal.c不知道对不对，我单步调试，并查看hello.asm文件其中调用了sys_getenvid 。将断点打到0x800b15可以看见。要在lib/libmain.c里面调用sys_getenvid。先不用管这个是啥，下个实验会讲，先把这个添进去调试。1234567891011121314151617voidlibmain(int argc, char **argv)&#123; // set thisenv to point at our Env structure in envs[]. // LAB 3: Your code here. thisenv = &amp;envs[ENVX(sys_getenvid())]; // save the name of the program so that panic() can use it if (argc &gt; 0) binaryname = argv[0]; // call user main routine umain(argc, argv); // exit gracefully exit();&#125; 123456789101112131415161718 800b15: 55 push %ebp 800b16: 89 e5 mov %esp,%ebp 800b18: 57 push %edi 800b19: 56 push %esi 800b1a: 53 push %ebx//// The last clause tells the assembler that this can// potentially change the condition codes and arbitrary// memory locations.asm volatile("int %1\n" 800b1b: ba 00 00 00 00 mov $0x0,%edx 800b20: b8 02 00 00 00 mov $0x2,%eax 800b25: 89 d1 mov %edx,%ecx 800b27: 89 d3 mov %edx,%ebx 800b29: 89 d7 mov %edx,%edi 800b2b: 89 d6 mov %edx,%esi 800b2d: cd 30 int $0x30 能够明显的看见调用额 int30,所以应该是 用户通过inc/syscall.c进行系统调用。后面就比较简单了。前面也已经提示你了，所以我们直接调用就可以了。123456789case (T_SYSCALL): ret_code = syscall( tf-&gt;tf_regs.reg_eax, tf-&gt;tf_regs.reg_edx, tf-&gt;tf_regs.reg_ecx, tf-&gt;tf_regs.reg_ebx, tf-&gt;tf_regs.reg_edi, tf-&gt;tf_regs.reg_esi); tf-&gt;tf_regs.reg_eax = ret_code; 在sysycall里面判断信号,分别调用哪几个函数。 123456789101112131415161718192021222324// Dispatches to the correct kernel function, passing the arguments.int32_tsyscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)&#123; // Call the function corresponding to the 'syscallno' parameter. // Return any appropriate return value. // LAB 3: Your code here. // panic("syscall not implemented"); switch (syscallno) &#123; case (SYS_cputs): sys_cputs((const char *)a1, a2); return 0; case (SYS_cgetc): return sys_cgetc(); case (SYS_getenvid): return sys_getenvid(); case (SYS_env_destroy): return sys_env_destroy(a1); default: return -E_INVAL; &#125;&#125; 大家多用gdb 调试自己查看程序运行过程，这样可以理解更快。 挑战我就不看了，一般都是做不出来的，主要是没时间查看相关资料。 User-mode startup上一个实验已经把代码给了，最后那一块如果好好理解了的话，这个基本上就能直接过了。用户程序真正开始运行的地方是在lib/entry.S文件中。该文件中，首先会进行一些设置，然后就会调用lib/libmain.c 文件中的 libmain() 函数。你首先要修改一下 libmain() 函数，使它能够初始化全局指针 thisenv，让它指向当前用户环境的 Env 结构体。然后 libmain() 函数就会调用 umain，这个 umain 程序恰好是 user/hello.c 中被调用的函数。在之前的实验中我们发现，hello.c程序只会打印 hello, world 这句话，然后就会报出 page fault 异常，原因就是 thisenv-&gt;env_id 这条语句。现在你已经正确初始化了这个 thisenv的值，再次运行就应该不会报错了。 不理解的可以继续单步调试。断点打在f0103003 Page faults and memory protection这个练习，我们已经做了一点了，前那个函数分配page_fault_handler的时候我已经把page_fault_handler 完善了。这里就是告诉你 内核如果缺页，说明内核出问题了，不能继续运行了，必须报错panic。如果是用户能解决就解决，解决不了就删除。1234567891011121314151617181920212223voidpage_fault_handler(struct Trapframe *tf)&#123; uint32_t fault_va; // Read processor's CR2 register to find the faulting address fault_va = rcr2(); // Handle kernel-mode page faults. // LAB 3: Your code here. if(tf-&gt;tf_cs &amp;&amp; 0x01 == 0) &#123; panic("page_fault in kernel mode, fault address %d\n", fault_va); &#125; // We've already handled kernel-mode exceptions, so if we get here, // the page fault happened in user mode. // Destroy the environment that caused the fault. cprintf("[%08x] user fault va %08x ip %08x\n", curenv-&gt;env_id, fault_va, tf-&gt;tf_eip); print_trapframe(tf); env_destroy(curenv);&#125; 然后根据题目的要求，我们还要继续完善 kern/pmap.c 文件中的 user_mem_assert , user_mem_check 函数，通过观察 user_mem_assert 函数我们发现，它调用了 user_mem_check 函数。而 user_mem_check 函数的功能是检查一下当前用户态程序是否有对虚拟地址空间 [va, va+len] 的 perm| PTE_P 访问权限。自然我们要做的事情应该是，先找到这个虚拟地址范围对应于当前用户态程序的页表中的页表项，然后再去看一下这个页表项中有关访问权限的字段，是否包含 perm | PTE_P，只要有一个页表项是不包含的，就代表程序对这个范围的虚拟地址没有 perm|PTE_P 的访问权限。以上就是这段代码的大致思想。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//这个函数分析 先挖个坑，做下个实验之前，来填一下。//// Check that an environment is allowed to access the range of memory// [va, va+len) with permissions 'perm | PTE_P'. 检查内存权限// Normally 'perm' will contain PTE_U at least, but this is not required. 权限至少是PTE_u// 'va' and 'len' need not be page-aligned; you must test every page that// contains any of that range. You will test either 'len/PGSIZE',// 'len/PGSIZE + 1', or 'len/PGSIZE + 2' pages.// 这个地方告诉你 ，va 和len 肯能不是页对齐的， 需要你搞一下。// A user program can access a virtual address if (1) the address is below// ULIM, and (2) the page table gives it permission. These are exactly// the tests you should implement here.// 地址 应该在ULIM之下 权限应该对// If there is an error, set the 'user_mem_check_addr' variable to the first// erroneous virtual address. 如果出错了 把 user_mem_check_addr地址指向第一个出错的//// Returns 0 if the user program can access this range of addresses,// and -E_FAULT otherwise.//intuser_mem_check(struct Env *env, const void *va, size_t len, int perm)&#123; // LAB 3: Your code here. char * end = NULL; char * start = NULL; start = ROUNDDOWN((char *)va, PGSIZE); //这个地方是页对齐 end = ROUNDUP((char *)(va + len), PGSIZE); pte_t *cur = NULL; //虚拟地址对应的 物理地址 for(; start &lt; end; start += PGSIZE) &#123; cur = pgdir_walk(env-&gt;env_pgdir, (void *)start, 0); //遍历这个虚拟地址 //检查地址位置 ，权限 if((int)start &gt; ULIM || cur == NULL || ((uint32_t)(*cur) &amp; perm) != perm) &#123; if(start == ROUNDDOWN((char *)va, PGSIZE)) &#123; //这个的意思是如果一开场就错了说明出错在va user_mem_check_addr = (uintptr_t)va; &#125; else &#123; user_mem_check_addr = (uintptr_t)start; &#125; return -E_FAULT; &#125; &#125; return 0;&#125; 1234567891011121314// Print a string to the system console.// The string is exactly 'len' characters long.// Destroys the environment on memory errors.static voidsys_cputs(const char *s, size_t len)&#123; // Check that the user has permission to read memory [s, s+len). // Destroy the environment if not:. //刚才我们已经写过了检查的函数，调用就可以了。 // LAB 3: Your code here. user_mem_assert(curenv, s, len, 0); // Print the string supplied by the user. cprintf("%.*s", len, s);&#125; 最终的trap_dispatch1234567891011121314151617181920212223242526272829303132333435static voidtrap_dispatch(struct Trapframe *tf)&#123; // Handle processor exceptions. // LAB 3: Your code here. // Unexpected trap: The user process or the kernel has a bug. switch(tf-&gt;tf_trapno) &#123; case (T_PGFLT): page_fault_handler(tf); break; case (T_BRKPT): monitor(tf); break; case (T_SYSCALL): // print_trapframe(tf); int32_t ret_code = syscall( tf-&gt;tf_regs.reg_eax, tf-&gt;tf_regs.reg_edx, tf-&gt;tf_regs.reg_ecx, tf-&gt;tf_regs.reg_ebx, tf-&gt;tf_regs.reg_edi, tf-&gt;tf_regs.reg_esi); tf-&gt;tf_regs.reg_eax = ret_code; break; default: // Unexpected trap: The user process or the kernel has a bug. print_trapframe(tf); if (tf-&gt;tf_cs == GD_KT) panic("unhandled trap in kernel"); else &#123; env_destroy(curenv); return; &#125; &#125;&#125; 如果文章有错误或者看不懂，缺了啥的可以留言。]]></content>
      <categories>
        <category>操作系统</category>
        <category>MIT6.828</category>
      </categories>
      <tags>
        <tag>MIT6.828</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT6.828(二)Lab2:Memory management]]></title>
    <url>%2F2020%2F02%2F18%2FMIT-6.828-(%E4%BA%8C)-Lab-2-Memory-management%2F</url>
    <content type="text"><![CDATA[Lab 2: Memory management做这个实验之前首先需要知道什么是分页。分段在这个实验里面没用到过。 前面是一大堆教你怎么获取lab2资源的，我不知道怎么弄，后来乱搞了一下，就把lab1的覆盖掉了，变成了lab2。这个我相信就我不懂。 Part 1: Physical Page Management第一个是物理页面管理。12345boot_alloc() //这个是系统加载前做个物理内存分配，也就初始化用了一下mem_init() // 顾名思义，内存初始化page_init() //页面初始化page_alloc() //真正的分配物理页面page_free() // 页面释放 首先，我们先观察一下init.c文件，这个是内核初始化调用的，上个实验已经清楚了。 init.c123456789101112131415161718192021222324voidi386_init(void)&#123; extern char edata[], end[]; //这是内核数据 也就是加载ELF 里面的BSS段，全局变量和静态变量。 // Before doing anything else, complete the ELF loading process. // Clear the uninitialized global data (BSS) section of our program. // This ensures that all static/global variables start out zero. memset(edata, 0, end - edata);//初始化为0 // Initialize the console. // Can't call cprintf until after we do this! //这个应该知道吧，上个实验讲过，初始化printf之内的 cons_init(); cprintf("6828 decimal is %o octal!\n", 6828); //不说了因为切换到lab2 又开始输出XX可以回去改一下。改也没事，这个实验用不上。 // Lab 2 memory management initialization functions mem_init(); //这个就是这次实验的核心，主要就是这个 后面的就不管了。 // Drop into the kernel monitor. while (1) monitor(NULL);&#125; 看 mem_init()我们先看看kern/pmap.h 和inc/memlayout.h里面有什么，没看懂就算了，我也没看懂，大致知道有些啥就行了。补充一个inc/mmu.h 不用知道具体实现，但是一些东西后面用的超多。 mmu.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318#ifndef JOS_INC_MMU_H#define JOS_INC_MMU_H/* * This file contains definitions for the x86 memory management unit (MMU), * including paging- and segmentation-related data structures and constants, * the %cr0, %cr4, and %eflags registers, and traps. * 这个文件 定义了X86 的内存管理单元，包括分段报函数，还有一些啥寄存器，和陷阱，先不管这些。 *//* * * Part 1. Paging data structures and constants. *重点就是这个页的结构 ，主要就是这个 其他的以后再说 */// A linear address 'la' has a three-part structure as follows:// 三部分结构 一个 链接地址 页目录 页表 偏移地址 ，如果这三个不知道，亲!这边建议重修操作系统和计算机组成原理。 然后 PDX PTX PGOFF 知道是做啥的了吧// +--------10------+-------10-------+---------12----------+// | Page Directory | Page Table | Offset within Page |// | Index | Index | |// +----------------+----------------+---------------------+// \--- PDX(la) --/ \--- PTX(la) --/ \---- PGOFF(la) ----/// \---------- PGNUM(la) ----------///// The PDX, PTX, PGOFF, and PGNUM macros decompose linear addresses as shown.// To construct a linear address la from PDX(la), PTX(la), and PGOFF(la),// use PGADDR(PDX(la), PTX(la), PGOFF(la)).// page number field of address#define PGNUM(la) (((uintptr_t) (la)) &gt;&gt; PTXSHIFT)// page directory index#define PDX(la) ((((uintptr_t) (la)) &gt;&gt; PDXSHIFT) &amp; 0x3FF)// page table index#define PTX(la) ((((uintptr_t) (la)) &gt;&gt; PTXSHIFT) &amp; 0x3FF)// offset in pag #define PGOFF(la) (((uintptr_t) (la)) &amp; 0xFFF)// construct linear address from indexes and offset 通过3个值 构建虚拟地址 #define PGADDR(d, t, o) ((void*) ((d) &lt;&lt; PDXSHIFT | (t) &lt;&lt; PTXSHIFT | (o)))// Page directory and page table constants. 页目录其实就是一个页表 下面是他们包含了啥#define NPDENTRIES 1024 // page directory entries per page directory#define NPTENTRIES 1024 // page table entries per page table#define PGSIZE 4096 // bytes mapped by a page 一个页的大小#define PGSHIFT 12 // log2(PGSIZE)#define PTSIZE (PGSIZE*NPTENTRIES) // bytes mapped by a page directory entry#define PTSHIFT 22 // log2(PTSIZE)#define PTXSHIFT 12 // offset of PTX in a linear address#define PDXSHIFT 22 // offset of PDX in a linear address#define PTE_P 0x001 // Present 对应物理页面是否存在#define PTE_W 0x002 // Writeable 对应物理页面是否可写#define PTE_U 0x004 // User 对应物理页面用户态是否可以访问#define PTE_PWT 0x008 // Write-Through 对应物理页面在写入时是否写透(即向更低级储存设备写入)#define PTE_PCD 0x010 // Cache-Disable 对应物理页面是否能被放入高速缓存#define PTE_A 0x020 // Accessed 对应物理页面是否被访问#define PTE_D 0x040 // Dirty 对应物理页面是否被写#define PTE_PS 0x080 // Page Size 对应物理页面的页面大小#define PTE_G 0x100 // Global 这个我也不知道// The PTE_AVAIL bits aren't used by the kernel or interpreted by the// hardware, so user processes are allowed to set them arbitrarily.#define PTE_AVAIL 0xE00 // Available for software use// Flags in PTE_SYSCALL may be used in system calls. (Others may not.) 这两个没用到过#define PTE_SYSCALL (PTE_AVAIL | PTE_P | PTE_W | PTE_U)// Address in page table or page directory entry //取页表入口地址#define PTE_ADDR(pte) ((physaddr_t) (pte) &amp; ~0xFFF)0xFFF//后面的东西 用的比较少，感兴趣的自己去送人头吧// Control Register flags#define CR0_PE 0x00000001 // Protection Enable#define CR0_MP 0x00000002 // Monitor coProcessor#define CR0_EM 0x00000004 // Emulation#define CR0_TS 0x00000008 // Task Switched#define CR0_ET 0x00000010 // Extension Type#define CR0_NE 0x00000020 // Numeric Errror#define CR0_WP 0x00010000 // Write Protect#define CR0_AM 0x00040000 // Alignment Mask#define CR0_NW 0x20000000 // Not Writethrough#define CR0_CD 0x40000000 // Cache Disable#define CR0_PG 0x80000000 // Paging#define CR4_PCE 0x00000100 // Performance counter enable#define CR4_MCE 0x00000040 // Machine Check Enable#define CR4_PSE 0x00000010 // Page Size Extensions#define CR4_DE 0x00000008 // Debugging Extensions#define CR4_TSD 0x00000004 // Time Stamp Disable#define CR4_PVI 0x00000002 // Protected-Mode Virtual Interrupts#define CR4_VME 0x00000001 // V86 Mode Extensions// Eflags register#define FL_CF 0x00000001 // Carry Flag#define FL_PF 0x00000004 // Parity Flag#define FL_AF 0x00000010 // Auxiliary carry Flag#define FL_ZF 0x00000040 // Zero Flag#define FL_SF 0x00000080 // Sign Flag#define FL_TF 0x00000100 // Trap Flag#define FL_IF 0x00000200 // Interrupt Flag#define FL_DF 0x00000400 // Direction Flag#define FL_OF 0x00000800 // Overflow Flag#define FL_IOPL_MASK 0x00003000 // I/O Privilege Level bitmask#define FL_IOPL_0 0x00000000 // IOPL == 0#define FL_IOPL_1 0x00001000 // IOPL == 1#define FL_IOPL_2 0x00002000 // IOPL == 2#define FL_IOPL_3 0x00003000 // IOPL == 3#define FL_NT 0x00004000 // Nested Task#define FL_RF 0x00010000 // Resume Flag#define FL_VM 0x00020000 // Virtual 8086 mode#define FL_AC 0x00040000 // Alignment Check#define FL_VIF 0x00080000 // Virtual Interrupt Flag#define FL_VIP 0x00100000 // Virtual Interrupt Pending#define FL_ID 0x00200000 // ID flag// Page fault error codes#define FEC_PR 0x1 // Page fault caused by protection violation#define FEC_WR 0x2 // Page fault caused by a write#define FEC_U 0x4 // Page fault occured while in user mode/* * * Part 2. Segmentation data structures and constants. * */#ifdef __ASSEMBLER__/* * Macros to build GDT entries in assembly. */#define SEG_NULL \ .word 0, 0; \ .byte 0, 0, 0, 0#define SEG(type,base,lim) \ .word (((lim) &gt;&gt; 12) &amp; 0xffff), ((base) &amp; 0xffff); \ .byte (((base) &gt;&gt; 16) &amp; 0xff), (0x90 | (type)), \ (0xC0 | (((lim) &gt;&gt; 28) &amp; 0xf)), (((base) &gt;&gt; 24) &amp; 0xff)#else // not __ASSEMBLER__#include &lt;inc/types.h&gt;// Segment Descriptorsstruct Segdesc &#123; unsigned sd_lim_15_0 : 16; // Low bits of segment limit unsigned sd_base_15_0 : 16; // Low bits of segment base address unsigned sd_base_23_16 : 8; // Middle bits of segment base address unsigned sd_type : 4; // Segment type (see STS_ constants) unsigned sd_s : 1; // 0 = system, 1 = application unsigned sd_dpl : 2; // Descriptor Privilege Level unsigned sd_p : 1; // Present unsigned sd_lim_19_16 : 4; // High bits of segment limit unsigned sd_avl : 1; // Unused (available for software use) unsigned sd_rsv1 : 1; // Reserved unsigned sd_db : 1; // 0 = 16-bit segment, 1 = 32-bit segment unsigned sd_g : 1; // Granularity: limit scaled by 4K when set unsigned sd_base_31_24 : 8; // High bits of segment base address&#125;;// Null segment#define SEG_NULL &#123; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 &#125;// Segment that is loadable but faults when used#define SEG_FAULT &#123; 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0 &#125;// Normal segment#define SEG(type, base, lim, dpl) \&#123; ((lim) &gt;&gt; 12) &amp; 0xffff, (base) &amp; 0xffff, ((base) &gt;&gt; 16) &amp; 0xff, \ type, 1, dpl, 1, (unsigned) (lim) &gt;&gt; 28, 0, 0, 1, 1, \ (unsigned) (base) &gt;&gt; 24 &#125;#define SEG16(type, base, lim, dpl) (struct Segdesc) \&#123; (lim) &amp; 0xffff, (base) &amp; 0xffff, ((base) &gt;&gt; 16) &amp; 0xff, \ type, 1, dpl, 1, (unsigned) (lim) &gt;&gt; 16, 0, 0, 1, 0, \ (unsigned) (base) &gt;&gt; 24 &#125;#endif /* !__ASSEMBLER__ */// Application segment type bits#define STA_X 0x8 // Executable segment#define STA_E 0x4 // Expand down (non-executable segments)#define STA_C 0x4 // Conforming code segment (executable only)#define STA_W 0x2 // Writeable (non-executable segments)#define STA_R 0x2 // Readable (executable segments)#define STA_A 0x1 // Accessed// System segment type bits#define STS_T16A 0x1 // Available 16-bit TSS#define STS_LDT 0x2 // Local Descriptor Table#define STS_T16B 0x3 // Busy 16-bit TSS#define STS_CG16 0x4 // 16-bit Call Gate#define STS_TG 0x5 // Task Gate / Coum Transmitions#define STS_IG16 0x6 // 16-bit Interrupt Gate#define STS_TG16 0x7 // 16-bit Trap Gate#define STS_T32A 0x9 // Available 32-bit TSS#define STS_T32B 0xB // Busy 32-bit TSS#define STS_CG32 0xC // 32-bit Call Gate#define STS_IG32 0xE // 32-bit Interrupt Gate#define STS_TG32 0xF // 32-bit Trap Gate/* * * Part 3. Traps. * */#ifndef __ASSEMBLER__// Task state segment format (as described by the Pentium architecture book)struct Taskstate &#123; uint32_t ts_link; // Old ts selector uintptr_t ts_esp0; // Stack pointers and segment selectors uint16_t ts_ss0; // after an increase in privilege level uint16_t ts_padding1; uintptr_t ts_esp1; uint16_t ts_ss1; uint16_t ts_padding2; uintptr_t ts_esp2; uint16_t ts_ss2; uint16_t ts_padding3; physaddr_t ts_cr3; // Page directory base uintptr_t ts_eip; // Saved state from last task switch uint32_t ts_eflags; uint32_t ts_eax; // More saved state (registers) uint32_t ts_ecx; uint32_t ts_edx; uint32_t ts_ebx; uintptr_t ts_esp; uintptr_t ts_ebp; uint32_t ts_esi; uint32_t ts_edi; uint16_t ts_es; // Even more saved state (segment selectors) uint16_t ts_padding4; uint16_t ts_cs; uint16_t ts_padding5; uint16_t ts_ss; uint16_t ts_padding6; uint16_t ts_ds; uint16_t ts_padding7; uint16_t ts_fs; uint16_t ts_padding8; uint16_t ts_gs; uint16_t ts_padding9; uint16_t ts_ldt; uint16_t ts_padding10; uint16_t ts_t; // Trap on task switch uint16_t ts_iomb; // I/O map base address&#125;;// Gate descriptors for interrupts and trapsstruct Gatedesc &#123; unsigned gd_off_15_0 : 16; // low 16 bits of offset in segment unsigned gd_sel : 16; // segment selector unsigned gd_args : 5; // # args, 0 for interrupt/trap gates unsigned gd_rsv1 : 3; // reserved(should be zero I guess) unsigned gd_type : 4; // type(STS_&#123;TG,IG32,TG32&#125;) unsigned gd_s : 1; // must be 0 (system) unsigned gd_dpl : 2; // descriptor(meaning new) privilege level unsigned gd_p : 1; // Present unsigned gd_off_31_16 : 16; // high bits of offset in segment&#125;;// Set up a normal interrupt/trap gate descriptor.// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate. // see section 9.6.1.3 of the i386 reference: "The difference between // an interrupt gate and a trap gate is in the effect on IF (the // interrupt-enable flag). An interrupt that vectors through an // interrupt gate resets IF, thereby preventing other interrupts from // interfering with the current interrupt handler. A subsequent IRET // instruction restores IF to the value in the EFLAGS image on the // stack. An interrupt through a trap gate does not change IF."// - sel: Code segment selector for interrupt/trap handler// - off: Offset in code segment for interrupt/trap handler// - dpl: Descriptor Privilege Level -// the privilege level required for software to invoke// this interrupt/trap gate explicitly using an int instruction.#define SETGATE(gate, istrap, sel, off, dpl) \&#123; \ (gate).gd_off_15_0 = (uint32_t) (off) &amp; 0xffff; \ (gate).gd_sel = (sel); \ (gate).gd_args = 0; \ (gate).gd_rsv1 = 0; \ (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32; \ (gate).gd_s = 0; \ (gate).gd_dpl = (dpl); \ (gate).gd_p = 1; \ (gate).gd_off_31_16 = (uint32_t) (off) &gt;&gt; 16; \&#125;// Set up a call gate descriptor.#define SETCALLGATE(gate, sel, off, dpl) \&#123; \ (gate).gd_off_15_0 = (uint32_t) (off) &amp; 0xffff; \ (gate).gd_sel = (sel); \ (gate).gd_args = 0; \ (gate).gd_rsv1 = 0; \ (gate).gd_type = STS_CG32; \ (gate).gd_s = 0; \ (gate).gd_dpl = (dpl); \ (gate).gd_p = 1; \ (gate).gd_off_31_16 = (uint32_t) (off) &gt;&gt; 16; \&#125;// Pseudo-descriptors used for LGDT, LLDT and LIDT instructions.struct Pseudodesc &#123; uint16_t pd_lim; // Limit uint32_t pd_base; // Base address&#125; __attribute__ ((packed));#endif /* !__ASSEMBLER__ */#endif /* !JOS_INC_MMU_H */ memlayout.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196#ifndef JOS_INC_MEMLAYOUT_H#define JOS_INC_MEMLAYOUT_H#ifndef __ASSEMBLER__#include &lt;inc/types.h&gt;#include &lt;inc/mmu.h&gt;#endif /* not __ASSEMBLER__ *//* * This file contains definitions for memory management in our OS, * which are relevant to both the kernel and user-mode software. */// Global descriptor numbers 一些全局描述用的东西，下面好像没怎么用到过#define GD_KT 0x08 // kernel text#define GD_KD 0x10 // kernel data#define GD_UT 0x18 // user text#define GD_UD 0x20 // user data#define GD_TSS0 0x28 // Task segment selector for CPU 0/*1. 将虚拟内存共计4G的空间的最高位置的256M预留，用来作为物理内存的映射，在JOS的内存使用中不会直接使用这段空间。在JOS中使用的某个页面，会通过mmu映射到这段空间，再通过映射和实际的物理内存相对应。这也是JOS最多只能管理256M物理内存的原因。 （这我现在还没理解什么意思，映射难道不是通过页表吗？）2. ULIM是区分内核和用户空间的位置。该位置以上为内核空间，用户程序不可见；而紧随其下的空间保存了用户空间的虚拟页表(UVPT)与环境参数，然后是异常处理栈，再其下为用户栈，向下增长。3. 用户的程序数据与堆的位置从UTEXT=0x00800000=8M处开始。其下用于用户程序的临时页面映射时使用。同时避开了最下面的1M空间，因为该空间内640K-1M处为系统预留空间，无法使用，因此0-640K的内存与其上无法连续，使用起来会比较复杂。4. 用于用户临时页面映射的空间为4M-8M处。而8M位置向下的4K为PFTEMP的空间，用于用户页面分配出错(page-fault)处理时作为映射空间。5. 内核栈大小为KSTKSIZE=(8*PGSIZE)=32KB.*//*这个是虚拟内存，映射的时候会用上 * Virtual memory map: Permissions * kernel/user * * 4 Gig --------&gt; +------------------------------+ * | | RW/-- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ * : . : * : . : * : . : * |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/-- * | | RW/-- * | Remapped Physical Memory | RW/-- * | | RW/-- * KERNBASE, ----&gt; +------------------------------+ 0xf0000000 --+ * KSTACKTOP | CPU0's Kernel Stack | RW/-- KSTKSIZE | * | - - - - - - - - - - - - - - -| | * | Invalid Memory (*) | --/-- KSTKGAP | * +------------------------------+ | * | CPU1's Kernel Stack | RW/-- KSTKSIZE | * | - - - - - - - - - - - - - - -| PTSIZE * | Invalid Memory (*) | --/-- KSTKGAP | * +------------------------------+ | * : . : | * : . : | * MMIOLIM ------&gt; +------------------------------+ 0xefc00000 --+ * | Memory-mapped I/O | RW/-- PTSIZE * ULIM, MMIOBASE --&gt; +------------------------------+ 0xef800000 * | Cur. Page Table (User R-) | R-/R- PTSIZE * UVPT ----&gt; +------------------------------+ 0xef400000 * | RO PAGES | R-/R- PTSIZE * UPAGES ----&gt; +------------------------------+ 0xef000000 * | RO ENVS | R-/R- PTSIZE * UTOP,UENVS ------&gt; +------------------------------+ 0xeec00000 * UXSTACKTOP -/ | User Exception Stack | RW/RW PGSIZE * +------------------------------+ 0xeebff000 * | Empty Memory (*) | --/-- PGSIZE * USTACKTOP ---&gt; +------------------------------+ 0xeebfe000 * | Normal User Stack | RW/RW PGSIZE * +------------------------------+ 0xeebfd000 * | | * | | * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ * . . * . . * . . * |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| * | Program Data &amp; Heap | * UTEXT --------&gt; +------------------------------+ 0x00800000 * PFTEMP -------&gt; | Empty Memory (*) | PTSIZE * | | * UTEMP --------&gt; +------------------------------+ 0x00400000 --+ * | Empty Memory (*) | | * | - - - - - - - - - - - - - - -| | * | User STAB Data (optional) | PTSIZE * USTABDATA ----&gt; +------------------------------+ 0x00200000 | * | Empty Memory (*) | | * 0 ------------&gt; +------------------------------+ --+ * * (*) Note: The kernel ensures that "Invalid Memory" is *never* mapped. * "Empty Memory" is normally unmapped, but user programs may map pages * there if desired. JOS user programs map pages temporarily at UTEMP. */// All physical memory mapped at this address 所有的物理内存映射在此地址#define KERNBASE 0xF0000000// At IOPHYSMEM (640K) there is a 384K hole for I/O. From the kernel,// IOPHYSMEM can be addressed at KERNBASE + IOPHYSMEM. The hole ends// at physical address EXTPHYSMEM. 这个 就是上次实验说的 空洞#define IOPHYSMEM 0x0A0000#define EXTPHYSMEM 0x100000// Kernel stack. 这个是栈，后面用的上的#define KSTACKTOP KERNBASE#define KSTKSIZE (8*PGSIZE) // size of a kernel stack#define KSTKGAP (8*PGSIZE) // size of a kernel stack guard// Memory-mapped IO. #define MMIOLIM (KSTACKTOP - PTSIZE)#define MMIOBASE (MMIOLIM - PTSIZE)#define ULIM (MMIOBASE)/* * User read-only mappings! Anything below here til UTOP are readonly to user. * They are global pages mapped in at env allocation time. */// User read-only virtual page table (see 'uvpt' below)#define UVPT (ULIM - PTSIZE)// Read-only copies of the Page structures#define UPAGES (UVPT - PTSIZE)// Read-only copies of the global env structures#define UENVS (UPAGES - PTSIZE)/* * Top of user VM. User can manipulate VA from UTOP-1 and down! */// 这个地方就是用户态了，也不知道具体有什么用，我现在就知道大致分布，不知道后面实验会不会讲// Top of user-accessible VM#define UTOP UENVS// Top of one-page user exception stack#define UXSTACKTOP UTOP// Next page left invalid to guard against exception stack overflow; then:// Top of normal user stack#define USTACKTOP (UTOP - 2*PGSIZE)// Where user programs generally begin#define UTEXT (2*PTSIZE)// Used for temporary page mappings. Typed 'void*' for convenience#define UTEMP ((void*) PTSIZE)// Used for temporary page mappings for the user page-fault handler// (should not conflict with other temporary page mappings)#define PFTEMP (UTEMP + PTSIZE - PGSIZE)// The location of the user-level STABS data structure#define USTABDATA (PTSIZE / 2)#ifndef __ASSEMBLER__//下面这两个 一个 是页目录 一个页表typedef uint32_t pte_t;typedef uint32_t pde_t;#if JOS_USER/* * The page directory entry corresponding to the virtual address range * [UVPT, UVPT + PTSIZE) points to the page directory itself. Thus, the page * directory is treated as a page table as well as a page directory. * * One result of treating the page directory as a page table is that all PTEs * can be accessed through a "virtual page table" at virtual address UVPT (to * which uvpt is set in lib/entry.S). The PTE for page number N is stored in * uvpt[N]. (It's worth drawing a diagram of this!) * * A second consequence is that the contents of the current page directory * will always be available at virtual address (UVPT + (UVPT &gt;&gt; PGSHIFT)), to * which uvpd is set in lib/entry.S. */extern volatile pte_t uvpt[]; // VA of "virtual page table"extern volatile pde_t uvpd[]; // VA of current page directory#endif/* * Page descriptor structures, mapped at UPAGES. * Read/write to the kernel, read-only to user programs. * * Each struct PageInfo stores metadata for one physical page. * Is it NOT the physical page itself, but there is a one-to-one * correspondence between physical pages and struct PageInfo's. * You can map a struct PageInfo * to the corresponding physical address * with page2pa() in kern/pmap.h. */ //页 的数据结构struct PageInfo &#123; // Next page on the free list.下一页 struct PageInfo *pp_link; // pp_ref is the count of pointers (usually in page table entries) // to this page, for pages allocated using page_alloc. // Pages allocated at boot time using pmap.c's // boot_alloc do not have valid reference count fields. // 页表计数器 uint16_t pp_ref;&#125;;#endif /* !__ASSEMBLER__ */#endif /* !JOS_INC_MEMLAYOUT_H */ kern/pmap.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/* See COPYRIGHT for copyright information. */#ifndef JOS_KERN_PMAP_H#define JOS_KERN_PMAP_H#ifndef JOS_KERNEL# error "This is a JOS kernel header; user programs should not #include it"#endif#include &lt;inc/memlayout.h&gt;#include &lt;inc/assert.h&gt;//这个几个扩展变量范围到了具体定义再说extern char bootstacktop[], bootstack[];extern struct PageInfo *pages;extern size_t npages;extern pde_t *kern_pgdir;/* This macro takes a kernel virtual address -- an address that points above * KERNBASE, where the machine's maximum 256MB of physical memory is mapped -- * and returns the corresponding physical address. It panics if you pass it a * non-kernel virtual address. 将虚拟地址转换成物理地址 */#define PADDR(kva) _paddr(__FILE__, __LINE__, kva)static inline physaddr_t_paddr(const char *file, int line, void *kva)&#123;//具体分析不过来告辞 if ((uint32_t)kva &lt; KERNBASE) _panic(file, line, "PADDR called with invalid kva %08lx", kva); return (physaddr_t)kva - KERNBASE;&#125;/* This macro takes a physical address and returns the corresponding kernel * virtual address. It panics if you pass an invalid physical address. */ //这个是物理地址转换成虚拟地址#define KADDR(pa) _kaddr(__FILE__, __LINE__, pa)static inline void*_kaddr(const char *file, int line, physaddr_t pa)&#123; if (PGNUM(pa) &gt;= npages) _panic(file, line, "KADDR called with invalid pa %08lx", pa); return (void *)(pa + KERNBASE);&#125;enum &#123; // For page_alloc, zero the returned physical page. ALLOC_ZERO = 1&lt;&lt;0,&#125;;// 后面就是几个函数的声明，后面会看到的void mem_init(void);void page_init(void);struct PageInfo *page_alloc(int alloc_flags);void page_free(struct PageInfo *pp);int page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm);void page_remove(pde_t *pgdir, void *va);struct PageInfo *page_lookup(pde_t *pgdir, void *va, pte_t **pte_store);void page_decref(struct PageInfo *pp);void tlb_invalidate(pde_t *pgdir, void *va);static inline physaddr_tpage2pa(struct PageInfo *pp)&#123; //将 PagaInfo 转换成真正的物理地址 return (pp - pages) &lt;&lt; PGSHIFT;&#125;static inline struct PageInfo*pa2page(physaddr_t pa)&#123; // 或得物理地址的数据结构 if (PGNUM(pa) &gt;= npages) panic("pa2page called with invalid pa"); return &amp;pages[PGNUM(pa)];&#125;static inline void*page2kva(struct PageInfo *pp)&#123; //将页的数据结构转换成虚拟地址 return KADDR(page2pa(pp));&#125;pte_t *pgdir_walk(pde_t *pgdir, const void *va, int create);#endif /* !JOS_KERN_PMAP_H */ 接下来我们就开始看内存怎么初始化的了。这个时候就要打开kern/pmap.c，看里面的mem_int();我们一段一段的来。先看看定义了啥12345678 // These variables are set by i386_detect_memory() size_t npages; // Amount of physical memory (in pages) 物理内存的页数 static size_t npages_basemem; // Amount of base memory (in pages) basemem的页数// These variables are set in mem_init() 这几个变量就是原本pmap.h扩展的那几个pde_t *kern_pgdir; // Kernel's initial page directory 内核初始化页目录struct PageInfo *pages; // Physical page state array 物理内存页表数组static struct PageInfo *page_free_list; // Free list of physical pages 空闲页表描述结构体指针 然后我们直接跟着 mem_init()的过程走。123456 uint32_t cr0; //定义了两个变量，干啥的还不清楚接着走 size_t n; // Find out how much memory the machine has (npages &amp; npages_basemem). i386_detect_memory(); //这个是查看有多少个页 还有个页基础内存 这个函数并没有要我们实现的意思就不管他了，看看，也就是帮我们查看有多少内存，不过不知道为啥这个查出来只有 128 M 少了一半。 // Remove this line when you're ready to test this function.// panic("mem_init: This function is not finished\n"); 这个注释就行了... 后面运行了这个 boot_alloc 作用很明显，就是创建一个页目录。1234//////////////////////////////////////////////////////////////////////// create initial page directory.kern_pgdir = (pde_t *) boot_alloc(PGSIZE);memset(kern_pgdir, 0, PGSIZE); boot_alloc()12345678910111213141516171819202122232425262728293031323334353637383940// This simple physical memory allocator is used only while JOS is setting// up its virtual memory system. page_alloc() is the real allocator.// 这个只是简单的物理内存分配，在建立虚拟存储系统的时候使用，page_alloc 才是真正的内存分配// If n&gt;0, allocates enough pages of contiguous physical memory to hold 'n'// bytes. Doesn't initialize the memory. Returns a kernel virtual address.//当n&gt;0 分配一个n字节的内存内存，返回一个虚拟地址// If n==0, returns the address of the next free page without allocating// anything. 如果n==0 返回 下一个空闲的页啥都不做//// If we're out of memory, boot_alloc should panic. 如果超出内存 就panic// This function may ONLY be used during initialization, 函数只用于初始化// before the page_free_list list has been set up.static void *boot_alloc(uint32_t n)&#123; static char *nextfree; // virtual address of next byte of free memory char *result; // Initialize nextfree if this is the first time. // 'end' is a magic symbol automatically generated by the linker, // which points to the end of the kernel's bss segment: // the first virtual address that the linker did *not* assign // to any kernel code or global variables. 在这之前，通过ELF 文件我们已经加载了一部分内存 //所以我们如果是第一次分配内存，就要先找到上一次的，没有要我们实现他已经帮我们写好了 if (!nextfree) &#123; extern char end[]; nextfree = ROUNDUP((char *) end, PGSIZE); &#125; // Allocate a chunk large enough to hold 'n' bytes, then update // nextfree. Make sure nextfree is kept aligned // to a multiple of PGSIZE. 分配n 字节，分配的空间要是PGSIZE的倍数。 // // LAB 2: Your code here. result = nextfree; nextfree=ROUNDUP(nextfree+n,PGSIZE); if((uint32_t)nextfree - KERNBASE &gt; (npages*PGSIZE))//如果分配超出内存panic panic("Out of memory!\n"); return result; //没有就返回这个&#125; 看代码实现还是挺容易理解的。kern_pgdir = (pde_t *) boot_alloc(PGSIZE)这句就相当于直接在后面开了一个PGSIZE大小的作为初始化页目录，然后把他初始化为0了。PGSIZE =4096的定义是在上一次的实验。也就是4096个字节，所以kern_pgdir占4096B 一个页表项是4B,所以总共是1024个页表。（这个时候我在想们是不是 每个页表也是 1024 个页,一个页 4KB 这样内存就是 102410244KB 就是4G，不知道是不是这样，纯属猜测。）后面有这么一段12345678//////////////////////////////////////////////////////////////////////// Recursively insert PD in itself as a page table, to form// a virtual page table at virtual address UVPT.// (For now, you don't have understand the greater purpose of the// following line.)// Permissions: kernel R, user Rkern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;//后面这两个参要看mmu.h 自己本身就是页表，所以把自己插入进去。大家可以试试输出这个几个值看看，再对照前面那个内存。紧接着 就是分配页了12345678910//////////////////////////////////////////////////////////////////////// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.// The kernel uses this array to keep track of physical pages: for// each physical page, there is a corresponding struct PageInfo in this// array. 'npages' is the number of physical pages in memory. Use memset// to initialize all fields of each struct PageInfo to 0.// Your code goes here:// 把每个页的结构存下来，放到pages里面，npages 是 页表的个数，知道这些 也就简单了。pages=(struct PageInfo *) boot_alloc(npages *sizeof(struct PageInfo));memset(pages,0,npages*sizeof(struct PageInfo));//初始化 大家自行输出 这个空间的大小。如果没错的话，n=32768 ,PageInfo=8 256KB。这是最后一次使用boot_alloc,他的作用也就干了两件事，一件事是分配页目录，第二个是为每个页分配数据结构。 接着就运行了page_init()这个时候你需要知道空闲列表，前面加载内核的时候有一部分内存是不能用的。1234567891011////////////////////////////////////////////////////////////////////// // Now that we've allocated the initial kernel data structures, we set // up the list of free physical pages. Once we've done so, all further // memory management will go through the page_* functions. In // particular, we can now map memory using boot_map_region // or page_insert 我们已经初始化了数据结构现在，需要知道空闲列表，以后使用内存就通过page_*函数，尤其是的是我们可以用 boot_map_region 和page_insert 进行映射。 page_init(); check_page_free_list(1); check_page_alloc(); check_page(); 接下来我们就要实现 page_init() page_init()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// --------------------------------------------------------------// Tracking of physical pages.// The 'pages' array has one 'struct PageInfo' entry per physical page.// Pages are reference counted, and free pages are kept on a linked list.// --------------------------------------------------------------//追踪物理内存，pages 保存的每一个页的信息，有些页实际上是不能用的。//// Initialize page structure and memory free list.初始化页面结构和空闲内存// After this is done, NEVER use boot_alloc again. ONLY use the page// allocator functions below to allocate and deallocate physical// memory via the page_free_list.//从这以后 就再也不会用 boot_alloc 只有page分配函数在 page_free_list 上面进行操作了，你也可以理解为，这个时候就开始了真正的分页了，后面所有的操作都是虚拟地址映射。voidpage_init(void)&#123; // The example code here marks all physical pages as free.实例代码帮你把所有页都变成了空闲页 // However this is not truly the case. What memory is free? 然后其中有些不是空闲的 // 1) Mark physical page 0 as in use. 0号页 他存了实模式下面的IDT 和BIOS 结构虽然我们从未用过，但是你还是要留下。 // This way we preserve the real-mode IDT and BIOS structures // in case we ever need them. (Currently we don't, but...) // 2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE) // is free. 就是这一段低地址的其他部分是可以用的。 // 3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must // never be allocated. 不是有一块是给IO 用的 内存空洞，不能分配 // 4) Then extended memory [EXTPHYSMEM, ...). 然后就是扩展内存，有一部分已经被内核用了，我一直在思考，那个页表不也是被用了么，为啥这个地方没有考虑。也没有大佬可以问...也就自己猜测一下，应该也被算进那个内核内存额。 // Some of it is in use, some is free. Where is the kernel // in physical memory? Which pages are already in use for // page tables and other data structures? // // Change the code to reflect this. // NB: DO NOT actually touch the physical memory corresponding to // free pages! size_t i; for (i = 0; i &lt; npages; i++) &#123; pages[i].pp_ref = 0; pages[i].pp_link = page_free_list; page_free_list = &amp;pages[i]; //不知道为啥这个list是倒过来连接的 &#125; // 根据上面他给的提示写，1) 是 0 号 页是实模式的IDT 和 BIOS 不应该添加到空闲页，所以 pages[1].pp_link=pages[0].pp_link; pages[0].pp_ref = 1;//可以不同设置，因为这个 页都没有进free list 永远都不可能用去分配 pages[0].pp_link=NULL; //2)是说那一块可以用，也就是上一次实验说的低地址，所以不用做修改 //3)是说 上节课讲的有一部分 是不能用的，存IO的那一块，他告诉你地址是从[IOPHYSMEM,EXTPHYSMEM) size_t range_io=PGNUM(IOPHYSMEM),range_ext=PGNUM(EXTPHYSMEM); pages[range_ext].pp_link=pages[range_io].pp_link; for (i = range_io; i &lt; range_ext; i++) pages[i].pp_link = NULL; //4)后面分配了一些内存页面给内核，所以那一块也是不能用的，看了半天，和上面是连续的...突然发现，大佬写额代码里面 是直接 找到了 boot_alloc(0),瞬间明白..这个直接把页表的空间也算上去了，所以准确来说应该是内核+页表+页目录的内存（可能内核包括页表和页目录..）。 size_t free_top = PGNUM(PADDR(boot_alloc(0))); pages[free_top].pp_link = pages[range_ext].pp_link; for(i = range_ext; i &lt; free_top; i++) pages[i].pp_link = NULL;&#125; 后面就要实现两个函数一个是内存分配page_alloc，一个是内存释放page_free。 page_alloc12345678910111213141516171819202122232425262728//// Allocates a physical page. If (alloc_flags &amp; ALLOC_ZERO), fills the entire// returned physical page with '\0' bytes. Does NOT increment the reference// count of the page - the caller must do these if necessary (either explicitly// or via page_insert).// 分配 一个页 然后返回一个页结构，如果 啥 就初始化为0 不用增加 计数。// Be sure to set the pp_link field of the allocated page to NULL so// page_free can check for double-free bugs.// 有两种 检查// Returns NULL if out of free memory.// // Hint: use page2kva and memsetstruct PageInfo *page_alloc(int alloc_flags)&#123; // Fill this function in //这个就是真正的内存分配函数了 if(page_free_list)&#123; //是否有空闲=页 struct PageInfo *allocated = page_free_list; page_free_list = allocated-&gt;pp_link;// 有就把这个取出来 allocated-&gt;pp_link = NULL; if (alloc_flags &amp; ALLOC_ZERO) //需不需要初始化？？？？ memset(page2kva(allocated), 0, PGSIZE); return allocated; &#125; else return NULL; //return 0;&#125; page_free()123456789101112131415//// Return a page to the free list. 把page 重新加入 空闲列表// (This function should only be called when pp-&gt;pp_ref reaches 0.)//voidpage_free(struct PageInfo *pp)&#123; // Fill this function in // Hint: You may want to panic if pp-&gt;pp_ref is nonzero or // pp-&gt;pp_link is not NULL. // 前面两个提示你了，一个判断 pp_ref 是不是非0 ，一个是pp_link 是不是非空 if(pp-&gt;pp_ref &gt; 0||pp-&gt;pp_link != NULL)panic("Page table entries point to this physical page."); pp-&gt;pp_link = page_free_list; page_free_list = pp;&#125; 到此 物理内存分配实验全部结束了，总的来说其实就干了三件事： 建了了一个页目录，对所有页建了一个数据结构 把所有空闲的空间建成了一个空闲链表。 提供了一个物理内存，释放一个物理内存 这个是从我第一个资源获取那里面一个大佬那盗过来的。 Part 2: Virtual Memory首先这个实验让你 先试试水，让你了解下物理地址和虚拟地址的差距。在虚拟内存里面都是连续的空间，转换成了物理地址就是一页一页的了。本来还有分段操作，但是呢这个里面没有用上，给禁用了。是否记得 那年夏天我们所做过的 Lab 1 part3 用了一个简单的页表，就映射了 4MB，而现在我们要映射256MB。Question 1 肯定是虚拟地址啊。 然后讲了KADDR，PADDR，前面代码那个啥文件里面有，看一下就可以知道了。后面又扯了一大堆，看一看了解一下就行了。然后又继续我的看源码大业了。这次函数并没有在 mem_init() 里面使用，但是呢写了一些测试的东西。我们就照着实验上来一个个实现函数。12345pgdir_walk()boot_map_region()page_lookup()page_remove()page_insert() 这个函数看懂了会受益很大的。 pgdir_walk()123456789101112131415161718192021222324252627282930313233343536373839404142// Given 'pgdir', a pointer to a page directory, pgdir_walk returns// a pointer to the page table entry (PTE) for linear address 'va'.// This requires walking the two-level page table structure.// 给一个 页目录 返回一个页表项，两级页表结构// The relevant page table page might not exist yet. 相关页表可能不存在// If this is true, and create == false, then pgdir_walk returns NULL.如果真的不存在 且create 标志为false 就返回NULL// Otherwise, pgdir_walk allocates a new page table page with page_alloc. 否则用paga_alloc创建一个// - If the allocation fails, pgdir_walk returns NULL. 创建失败返回NULL// - Otherwise, the new page's reference count is incremented, 否则新的页引用次数++// the page is cleared,页清空// and pgdir_walk returns a pointer into the new page table page.返回页指针//// Hint 1: you can turn a PageInfo * into the physical address of the// page it refers to with page2pa() from kern/pmap.h. 你可以通过 page2pa() 转换成物理地址，//这个去里面看看 就知道为什么了。// Hint 2: the x86 MMU checks permission bits in both the page directory// and the page table, so it's safe to leave permissions in the page// directory more permissive than strictly necessary.// x86 MMU 检查页目录 和页表，所以 页目录比 页表权限更严格// Hint 3: look at inc/mmu.h for useful macros that manipulate page// table and page directory entries.//去 mmu.h 看看有用的宏 pte_t *pgdir_walk(pde_t *pgdir, const void *va, int create)&#123; // Fill this function in struct PageInfo * np; //这可能有点绕 //PDX 是页目录里面的索引， pgdir 是 页目录，用一个 指针指向这个地址 pte_t * pd_entry =&amp;pgdir[PDX(va)]; //PTE_P 判断是不是已经存在该页，是的话就直接返回，返回的这个地址，就是页地址+偏移地址 if(*pd_entry &amp; PTE_P) //如果这个项存在就直接返回页地址，看了半天，如果PTX(va) 只取了页偏移地址，所以 这个时候返回的实际上是一个 页的地址，而不是页表的入口地址。这个地方返回的值应该有点欠缺。 return (pte_t *)KADDR(PTE_ADDR(*pd_entry))+PTX(va);//PTE_ADDR 取页表项里面的值 然后转换成虚拟地址 + 上偏移量就是页表的位置 就相当于替换了虚拟地址里面的 页目录索引。 else if(create == true &amp;&amp; (np=page_alloc(ALLOC_ZERO)))&#123; //如果可以创建就创建一个 np-&gt;pp_ref++; // page2pa 把PageInfo 结构转换成 物理地址。 *pd_entry=page2pa(np)|PTE_P|PTE_U|PTE_W; //设置一些值 return (pte_t *)KADDR(PTE_ADDR(*pd_entry)) + PTX(va); &#125; else return NULL;&#125; boot_map_region()123456789101112131415161718192021222324//// Map [va, va+size) of virtual address space to physical [pa, pa+size)// in the page table rooted at pgdir. Size is a multiple of PGSIZE, and// va and pa are both page-aligned. 页对齐，把pa 映射到 va// Use permission bits perm|PTE_P for the entries. 使用这个权限？//// This function is only intended to set up the ``static'' mappings// above UTOP. As such, it should *not* change the pp_ref field on the// mapped pages.//这个函数 建立一个静态映射，只用在 UTOP 以上，不应该改变映射区域// Hint: the TA solution uses pgdir_walkstatic voidboot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)&#123; // Fill this function in uintptr_t vStep; pte_t *ptep; for(vStep=0;vStep&lt;size;vStep+=PGSIZE)&#123; // 不知道为啥我总感觉 pgdir_walk 总感觉返回的是具体页，而不是页表入口地址。可能pa就是一个页表入口地址吧...也有可能页表本身也是一个页，这地方直接当做一级页表用了，也不是没有可能 ptep=pgdir_walk(pgdir,(void *)va+vStep,true);//找到 va虚拟地址对应的页表入口地址 if(ptep)*ptep=pa|perm|PTE_P;//然后把这个入口地址 指向 物理地址 pa pa+=PGSIZE; &#125;&#125; page_lookup()1234567891011121314151617181920212223242526//// Return the page mapped at virtual address 'va'.// If pte_store is not zero, then we store in it the address// of the pte for this page. This is used by page_remove and// can be used to verify page permissions for syscall arguments,// but should not be used by most callers.//如果 pte_store 不是0 将物理页对应的页表项指针存储于其中// Return NULL if there is no page mapped at va.//如果没有映射 返回空// Hint: the TA solution uses pgdir_walk and pa2page.//struct PageInfo *page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)&#123; // Fill this function in //就当做 ptep 指向页表入口地址 pte_t *ptep =pgdir_walk(pgdir,va,false); if(ptep&amp;&amp;(*ptep&amp;PTE_P))&#123; if(pte_store)&#123; *pte_store=ptep; &#125; //返回对应PageInfo return pa2page(PTE_ADDR(*ptep)); &#125; return NULL;&#125; page_remove()123456789101112131415161718192021222324252627//// Unmaps the physical page at virtual address 'va'.// If there is no physical page at that address, silently does nothing.//如果没有映射物理地址就啥都不做// Details:// - The ref count on the physical page should decrement. ref应该--// - The physical page should be freed if the refcount reaches 0. 如果到0应该释放// - The pg table entry corresponding to 'va' should be set to 0.页表 入口地址应该置0// (if such a PTE exists)// - The TLB must be invalidated if you remove an entry from // the page table.// TLB 应该删除入口地址// Hint: The TA solution is implemented using page_lookup,// tlb_invalidate, and page_decref.//voidpage_remove(pde_t *pgdir, void *va)&#123; // Fill this function in pte_t* pte_store; struct PageInfo *pgit=page_lookup(pgdir, va, &amp;pte_store); if(pgit)&#123; page_decref(pgit); *pte_store=0; tlb_invalidate(pgdir,va);//这个函数是不用我们实现的 &#125;&#125; page_insert()1234567891011121314151617181920212223242526272829303132333435363738//// Map the physical page 'pp' at virtual address 'va'.// The permissions (the low 12 bits) of the page table entry// should be set to 'perm|PTE_P'.//// Requirements// - If there is already a page mapped at 'va', it should be page_remove()d.如果一级存在就需要 把他删除// - If necessary, on demand, a page table should be allocated and inserted// into 'pgdir'. 如果有必要，一个页表需要被分配，插入到 pgdir里面// - pp-&gt;pp_ref should be incremented if the insertion succeeds. ref应该递增// - The TLB must be invalidated if a page was formerly present at 'va'.// TLB 应该被删除 如果存在va 的页// Corner-case hint: Make sure to consider what happens when the same// pp is re-inserted at the same virtual address in the same pgdir.// However, try not to distinguish this case in your code, as this// frequently leads to subtle bugs; there's an elegant way to handle// everything in one code path.// 极端意识 确保在相同的页表再次插入到页目录中，翻译不过来告辞。// RETURNS:// 0 on success// -E_NO_MEM, if page table couldn't be allocated//// Hint: The TA solution is implemented using pgdir_walk, page_remove,// and page2pa.//intpage_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)&#123; // Fill this function in pte_t *ptep=pgdir_walk(pgdir, va, true); if(ptep)&#123; pp-&gt;pp_ref++; if(*ptep&amp;PTE_P)page_remove(pgdir, va);//如果已经有了 就先删了.. *ptep = page2pa(pp) | perm | PTE_P; return 0; &#125; return -E_NO_MEM;&#125; Permissions and Fault Isolation现在 就是让你映射内核区域了。 123456789101112131415161718192021222324252627282930313233343536373839//////////////////////////////////////////////////////////////////////// Map 'pages' read-only by the user at linear address UPAGES// Permissions:// - the new image at UPAGES -- kernel R, user R// (ie. perm = PTE_U | PTE_P)// - pages itself -- kernel RW, user NONE// Your code goes here: //仔细分析了下，好像是把 UPAGES 虚拟内存 指向 pages。映射大小是 PTSIZE 一个页表的大小 4M，boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U|PTE_P);//////////////////////////////////////////////////////////////////////// Use the physical memory that 'bootstack' refers to as the kernel// stack. The kernel stack grows down from virtual address KSTACKTOP.// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)// to be the kernel stack, but break this into two pieces:// * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory// * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if// the kernel overflows its stack, it will fault rather than// overwrite memory. Known as a "guard page".// Permissions: kernel RW, user NONE// 使用物理内存 bootstack 指向 内核的栈，内核的栈 从KSTACKTOP 开始向下增长//分了两块，第一块[KSTACKTOP-KSTKSIZE, KSTACKTOP)，这一块需要映射//[KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE)这一块不映射，这样如果炸栈了就直接报RE错误，而不是覆盖低地址的数据。// Your code goes here:// 因为是从高到底，所以映射就从 KSTACKTOP-KSTKSIZE 到 KSTACKTOP。boot_map_region(kern_pgdir, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);//////////////////////////////////////////////////////////////////////// Map all of physical memory at KERNBASE.// Ie. the VA range [KERNBASE, 2^32) should map to// the PA range [0, 2^32 - KERNBASE)// We might not have 2^32 - KERNBASE bytes of physical memory, but// we just set up the mapping anyway.// Permissions: kernel RW, user NONE// Your code goes here://这个就是内核态，里面可以通用的内存，总共256Mboot_map_region(kern_pgdir, KERNBASE, 0x10000000, 0, PTE_W); //到此位置实验要写的代码已经写完成了。 这个时候运行已经没什么问题了。 这个也是盗的： Question: 2. 到目前为止页目录表中已经包含多少有效页目录项？他们都映射到哪里？ 3BD号页目录项，指向的是kern_pgdir 3BC号页目录项，指向的是pages数组 3BF号页目录项，指向的是bootstack 3C0~3FF号页目录项，指向的是kernel 3. 如果我们把kernel和user environment放在一个相同的地址空间中。为什么用户程序不同读取，写入内核的内存空间？用什么机制保护内核的地址范围。 用户程序不能去随意修改内核中的代码，数据，否则可能会破坏内核，造成程序崩溃。 正常的操作系统通常采用两个部件来完成对内核地址的保护，一个是通过段机制来实现的，但是JOS中的分段功能并没有实现。二就是通过分页机制来实现，通过把页表项中的 Supervisor/User位置0，那么用户态的代码就不能访问内存中的这个页。 4. 这个操作系统的可以支持的最大数量的物理内存是多大？ 由于这个操作系统利用一个大小为4MB的空间UPAGES来存放所有的页的PageInfo结构体信息，每个结构体的大小为8B，所以一共可以存放512K个PageInfo结构体，所以一共可以出现512K个物理页，每个物理页大小为4KB，自然总的物理内存占2GB。 5. 如果现在的物理内存页达到最大个数，那么管理这些内存所需要的额外空间开销有多少？ 这里不太明白，参考别的答案是，首先需要存放所有的PageInfo，需要4MB，需要存放页目录表，kern_pgdir，4KB，还需要存放当前的页表，大小为2MB。所以总的开销就是6MB + 4KB。 6. 回顾entry.S文件中，当分页机制开启时，寄存器EIP的值仍旧是一个小的值。在哪个位置代码才开始运行在高于KERNBASE的虚拟地址空间中的？当程序位于开启分页之后到运行在KERNBASE之上这之间的时候，EIP的值是小的值，怎么保证可以把这个值转换为真实物理地址的？ 在entry.S文件中有一个指令 jmp *%eax，这个指令要完成跳转，就会重新设置EIP的值，把它设置为寄存器eax中的值，而这个值是大于KERNBASE的，所以就完成了EIP从小的值到大于KERNBASE的值的转换。 在entry_pgdir这个页表中，也把虚拟地址空间[0, 4MB)映射到物理地址空间[0, 4MB)上，所以当访问位于[0, 4MB)之间的虚拟地址时，可以把它们转换为物理地址。Address Space Layout Alternatives 进程的虚拟地址空间的布局不是只有我们讨论的这种唯一的情况，我们也可以把内核映射到低地址处。但是JOS之所以要这么做，是为了保证x86的向后兼容性。 只要我们能够仔细设计，虽然很难，但是我们也能设计出来一种内核的布局方式，使得进程的地址空间就是从0到4GB，无需为内核预留一部分空间，但是仍然能够保证，用户进程不会破坏操作系统的指令，数据。]]></content>
      <categories>
        <category>操作系统</category>
        <category>MIT6.828</category>
      </categories>
      <tags>
        <tag>MIT6.828</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT6.828(一)Lab1:Booting a PC]]></title>
    <url>%2F2020%2F02%2F18%2FMIT-6.828-(%E4%B8%80)-Lab-1-Booting-a-PC%2F</url>
    <content type="text"><![CDATA[获取完资源就开始干了。我这里就做了个大概的内容分析，具体的还是跟着那几个大佬吧 前面一大堆都是没用的，就是告诉一些作业的提交。 Part 1: PC Bootstrap这个并没有要你做啥，就是让你 熟悉下汇编。 然后让你知道怎么运行那个内核的，这些都是些不用讲的东西，看看就行了。说一下，这个内核退出说是ctrl+a x,意思是先按ctrl+a,再按x 然后就开始来重点了，第一个是让你知道现在计算机内存的分布。 The PC’s Physical Address Space（PC的物理地址空间） The ROM BIOS后面就比较直接了，直接让你去运行这个内核，一步步来看他是怎么运行的。 就是让你这样运行两个终端，跑GDB 调试，第一个运行make qemu-gdb,第二个运行make gdb。不出意外，在make gdb 里面出现的第一条指令是跳转指令。跳到了哪里去，这个地址官方是给了你解释的，就是段地址*16加偏移地纸，很显然，他的地址是在BIOS中。然后回让你一步步执行看发生了什么。不难发现，计算机的运行最先开始的是 BIOS。 后面一步步，执行的内容我就看不懂，只知道他就做了一些初始化工作，想了解的去看看大佬的博客吧。 Part 2: The Boot Loader初始化完成BIOS 之后，就运行Boot Loader，就是引导操作系统，这个东西一直都是放在计算机磁盘的第一个扇区（也用可能是其他的引导，这个百度搜一搜能搜出来，另外一个最常见的就是U盘启动，学计算机的重装系统至少也有十次八次了吧，所以这个很容易理解，我们重装系统的步骤不就是现在BIOS里面选了U盘引导，干的就是这个了）。然后BIOS会把这个运行的引导程序装入到内存0x7c00-0x7dff。我不知道现代操作系统是不是这，但是这个系统是的。这个引导系统主要就干了两件事： 实模式转换成保护模式，区别百度一下有讲解的，另外发现了另一个操作系统学习资源,好像文档还挺齐全的。 引导加载程序通过x86的特殊I / O指令直接访问IDE磁盘设备寄存器，从而从硬盘读取内核。 后面会让你去看源码，知道怎么运行的Boot Loader，这个各位就自己翻翻博客吧，我就不细讲了，贴个自己的大致介绍。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;inc/mmu.h&gt;# Start the CPU: switch to 32-bit protected mode, jump into C.# The BIOS loads this code from the first sector of the hard disk into# memory at physical address 0x7c00 and starts executing in real mode# with %cs=0 %ip=7c00..set PROT_MODE_CSEG, 0x8 # kernel code segment selector.set PROT_MODE_DSEG, 0x10 # kernel data segment selector.set CR0_PE_ON, 0x1 # protected mode enable flag.globl startstart: # 开始程序首先关了中断，和串处理操作的移动指针(这个暂时不用管) .code16 # Assemble for 16-bit mode cli # Disable interrupts cld # String operations increment#初始化 数据段 扩展段 和 栈 的段寄存器 用于保护模式 # Set up the important data segment registers (DS, ES, SS). xorw %ax,%ax # Segment number zero movw %ax,%ds # -&gt; Data Segment movw %ax,%es # -&gt; Extra Segment movw %ax,%ss # -&gt; Stack Segment # Enable A20: # For backwards compatibility with the earliest PCs, physical # address line 20 is tied low, so that addresses higher than # 1MB wrap around to zero by default. This code undoes this.seta20.1: #开启A20为了兼容 低版本的 处理器 inb $0x64,%al # Wait for not busy testb $0x2,%al jnz seta20.1 movb $0xd1,%al # 0xd1 -&gt; port 0x64 outb %al,$0x64seta20.2: inb $0x64,%al # Wait for not busy testb $0x2,%al jnz seta20.2 movb $0xdf,%al # 0xdf -&gt; port 0x60 outb %al,$0x60 # Switch from real to protected mode, using a bootstrap GDT # and segment translation that makes virtual addresses # identical to their physical addresses, so that the # effective memory map does not change during the switch. lgdt gdtdesc # 存放 GDT表信息 movl %cr0, %eax # 用或操作 把最后一位置1 开启保护模式 orl $CR0_PE_ON, %eax movl %eax, %cr0 # Jump to next instruction, but in 32-bit code segment. # Switches processor into 32-bit mode. ljmp $PROT_MODE_CSEG, $protcseg # 这个时候跳到了 32模式下了 .code32 # Assemble for 32-bit modeprotcseg: # 这个修改一些寄存器的值，具体做了啥也不清楚 应该是规定的一些操作 # Set up the protected-mode data segment registers movw $PROT_MODE_DSEG, %ax # Our data segment selector movw %ax, %ds # -&gt; DS: Data Segment movw %ax, %es # -&gt; ES: Extra Segment movw %ax, %fs # -&gt; FS movw %ax, %gs # -&gt; GS movw %ax, %ss # -&gt; SS: Stack Segment # 简单来讲 上面 就是初始化了一些寄存器，然后就去 boot main 里面了 # Set up the stack pointer and call into C. movl $start, %esp call bootmain # If bootmain returns (it shouldn't), loop.spin: # 这个翻译上面英文就好 jmp spin# Bootstrap GDT.p2align 2 # force 4 byte alignmentgdt: # GDT 表信息，具体的不清楚 SEG_NULL # null seg SEG(STA_X|STA_R, 0x0, 0xffffffff) # code seg SEG(STA_W, 0x0, 0xffffffff) # data seggdtdesc: .word 0x17 # sizeof(gdt) - 1 .long gdt # address gdt 由上面这注释，应该很容易得出他问的问题的答案。 后面有一个让你运行一个C语言指针程序，那个有点基础应该就看得懂。就不多说了。 main.c里面，主要是加载ELF文件，也就是你的操作系统，什么是ELF，这个可以在百度百科里面了解到。 boot main.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;inc/x86.h&gt;#include &lt;inc/elf.h&gt;/********************************************************************** * This a dirt simple boot loader, whose sole job is to boot * an ELF kernel image from the first IDE hard disk. * * DISK LAYOUT * * This program(boot.S and main.c) is the bootloader. It should * be stored in the first sector of the disk. * * * The 2nd sector onward holds the kernel image. * * * The kernel image must be in ELF format. * * BOOT UP STEPS * * when the CPU boots it loads the BIOS into memory and executes it * * * the BIOS intializes devices, sets of the interrupt routines, and * reads the first sector of the boot device(e.g., hard-drive) * into memory and jumps to it. * * * Assuming this boot loader is stored in the first sector of the * hard-drive, this code takes over... * * * control starts in boot.S -- which sets up protected mode, * and a stack so C code then run, then calls bootmain() * * * bootmain() in this file takes over, reads in the kernel and jumps to it. **********************************************************************/#define SECTSIZE 512#define ELFHDR ((struct Elf *) 0x10000) // scratch spacevoid readsect(void*, uint32_t);void readseg(uint32_t, uint32_t, uint32_t);voidbootmain(void)&#123; struct Proghdr *ph, *eph; // read 1st page off disk 把内核的起始地址第一个页加载到内存,ELFHDR处 一页为 512*8=4M readseg((uint32_t) ELFHDR, SECTSIZE*8, 0);//一般是操作系统映象文件的elf 头部 // is this a valid ELF? 是一个ELF文件 就继续否侧失败 if (ELFHDR-&gt;e_magic != ELF_MAGIC) goto bad; //加载 程序表头到 ph // load each program segment (ignores ph flags) ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR-&gt;e_phoff); eph = ph + ELFHDR-&gt;e_phnum;//这个是 表未 e_phnum 存的是表项个数 for (; ph &lt; eph; ph++) //这个就是把表里面的都加载到内存 // p_pa is the load address of this segment (as well // as the physical address) readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset); // call the entry point from the ELF header // note: does not return! ((void (*)(void)) (ELFHDR-&gt;e_entry))();//e_entry 是程序运行的入口 也就是在这个时候 操作系统开始加载了bad: //具体干啥的 我不知道 如果没猜错 就是执行 没有加载到系统的操作， outw(0x8A00, 0x8A00); outw(0x8A00, 0x8E00); while (1) /* do nothing */;&#125;// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.// Might copy more than asked // 顾名思义 ，就是加载 偏移量为 offset 的 连续 count 个字节 到地址 pavoidreadseg(uint32_t pa, uint32_t count, uint32_t offset)&#123; uint32_t end_pa; end_pa = pa + count; // round down to sector boundary pa &amp;= ~(SECTSIZE - 1); // translate from bytes to sectors, and kernel starts at sector 1 offset = (offset / SECTSIZE) + 1; // If this is too slow, we could read lots of sectors at a time. // We'd write more to memory than asked, but it doesn't matter -- // we load in increasing order. while (pa &lt; end_pa) &#123; // Since we haven't enabled paging yet and we're using // an identity segment mapping (see boot.S), we can // use physical addresses directly. This won't be the // case once JOS enables the MMU. readsect((uint8_t*) pa, offset); pa += SECTSIZE; offset++; &#125;&#125;voidwaitdisk(void)&#123; // 判磁盘是不是准备 好了 // wait for disk reaady while ((inb(0x1F7) &amp; 0xC0) != 0x40) /* do nothing */;&#125;voidreadsect(void *dst, uint32_t offset)&#123; // wait for disk to be ready waitdisk(); outb(0x1F2, 1); // count = 1 outb(0x1F3, offset); outb(0x1F4, offset &gt;&gt; 8); outb(0x1F5, offset &gt;&gt; 16); outb(0x1F6, (offset &gt;&gt; 24) | 0xE0); outb(0x1F7, 0x20); // cmd 0x20 - read sectors // wait for disk to be ready waitdisk(); // read a sector 读一个扇区 insl(0x1F0, dst, SECTSIZE/4);&#125; 后面几步还是要自己好好坐一坐，我没有做什么详细的介绍。一如既往大佬博客,像我这样的菜鸡是无法理解的。 最后让你做个测试，运行Boot Loader 前看下0x00100000处的8个内存字，运行后再看一下,发现原本是 全是 0，后面就有了一大堆乱七八糟的值。这个不是很明显吗，看我上面main.c的注释，明显有个函数把硬盘里面的值读到了内存。 Part 3: The Kernel后面的实验，这个大佬的GitHub就全都有了。 我做个简单的笔记。1movl %eax, %cr0 这条语句实现了，映射，将高地址映射到了物理地址的低地址，这是因为计算机希望操作系统是运行在高地址，用户运行在低地址，详细内容，下一次实验会讲清楚。 练习8 让你完善那个printf里面的%o也就是8进制输出。 这个很容易了，把前面16进制输出复制一遍就行了，不做详细介绍了。 然后你需要回答4个问题 printf之间的关系依旧找大佬的博客 12345671 if (crt_pos &gt;= CRT_SIZE) &#123;2 int i;3 memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));4 for (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)5 crt_buf[i] = 0x0700 | ' ';6 crt_pos -= CRT_COLS;7 &#125; 解释这个，看起来就是如果超过了一页，就把最前面的那一行删掉？？，然后继续输出下一行？？？不知道理解对没。 这个是个重点 ，这个实验很容易看出来C语言压栈的顺序是从后往前压栈。 这个不说了，就是按格式输出 这个就是，我们经常用的printf，如果少了一个参数会咋样，通过看内存应该就知道，会输出一个随机值。多一个多的其实就没啥用。 这个就是压栈是从后往前压，所以可以实现，多个参数。如果是从前往后压该怎么办？我还不知道怎么处理。 练习9 问啥时候初始化堆栈，这个看看大佬的博客就行.练习10 这个就是让你明白是怎么调用函数的，又是怎么返回的。 一般来说，栈基地址指向的是栈底，栈指针指向的是栈顶。大概调用一个函数就是这么干的，怎么返回的就不用我说了吧。调用参数也就是通过栈来的，如果超过了五个参数我也不知道会发生啥，反正这上面没说。练习 11 也就是让你写个输出栈里面的内容。 练习 12 让你实现一个调试信息的指令。改三个地方。前两个都在kern/monitor.c。第一个12345static struct Command commands[] = &#123; &#123; "help", "Display this list of commands", mon_help &#125;, &#123; "kerninfo", "Display information about the kernel", mon_kerninfo &#125;, &#123;"backtrace","Display stack backtrace", mon_backtrace&#125;, &#125;; 后面那个是多加的，前面那两个很眼熟吧。1234567891011121314151617181920intmon_backtrace(int argc, char **argv, struct Trapframe *tf)&#123; // Your code here. // return 0; uint32_t ebp,eip,*p; struct Eipdebuginfo info; ebp=read_ebp(); while(ebp!=0)&#123; p=(uint32_t*)ebp; eip=p[1]; cprintf("ebp %x eip %x args %08x %08x %08x %08x %08x\n",ebp,p[1],p[2],p[3],p[4],p[5],p[6]); if(debuginfo_eip(eip,&amp;info)==0)&#123; int fn_offset=eip-info.eip_fn_addr; cprintf("%s:%d:%.*s+%d\n",info.eip_file,info.eip_line,info.eip_fn_namelen,info.eip_fn_name,fn_offset); &#125; ebp=p[0]; &#125; return 0;&#125; 这个也很眼熟吧，前面改过。到这个地方实际上已经能够运行了，只是没有行号。 最后一个在kern/kdebug.c123456stab_binsearch(stabs, &amp;lfun, &amp;rfun, N_SLINE, addr - info-&gt;eip_fn_add r); if (lfun &lt;= rfun)&#123; info-&gt;eip_line = stabs[lfun].n_desc;&#125; 这个具体原理我也不知道，抄别人的。百度能搜到。到此，实验一就全部完成了，目前我能了解的就这么多。]]></content>
      <categories>
        <category>操作系统</category>
        <category>MIT6.828</category>
      </categories>
      <tags>
        <tag>MIT6.828</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[manjaro18 xfce版 终端字体间距贼大]]></title>
    <url>%2F2020%2F02%2F18%2Fmanjaro18-xfce%E7%89%88-%E7%BB%88%E7%AB%AF%E5%AD%97%E4%BD%93%E9%97%B4%E8%B7%9D%E8%B4%BC%E5%A4%A7%2F</url>
    <content type="text"><![CDATA[manjaro18 xfce版 终端字体间距贼大 12sudo pacman -S wqy-bitmapfontsudo pacman -S wqy-zenhei]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT6.828(零)提前做好送人头准备随时跑路]]></title>
    <url>%2F2020%2F02%2F17%2FMIT6.828(%E9%9B%B6)%E6%8F%90%E5%89%8D%E5%81%9A%E5%A5%BD%E9%80%81%E4%BA%BA%E5%A4%B4%E5%87%86%E5%A4%87%E9%9A%8F%E6%97%B6%E8%B7%91%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[被某个大佬带入坑，看看了评价好像确实不错，所以就开始干了。首先第一件事就是搜索资源，像我这么菜的，要是没人告诉我怎么做，基本上是没啥希望的。 资源第一个肯定就是官方的了，另外还有，2019的. 然后就是一些比较好的大佬的资源。知乎超级详细的某个大佬2014 大佬github这个也是有些应该够用了，也许够了，嗯，也许够了，因为我也只是刚开始。。 虚拟机如果做的事 2018年之前的 随便用啥系统 ，如果事 2019 的建议 用manjaro 。 如果用的虚拟机注意下，内存要大于 4G ，如果小了的话，这个内核是运行不了的 环境搭建安装环境，这文章确实够用了 然后祝你好运。。。]]></content>
      <categories>
        <category>操作系统</category>
        <category>MIT6.828</category>
      </categories>
      <tags>
        <tag>MIT6.828</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux0.11-sched.h、sched.c内核源码分析]]></title>
    <url>%2F2019%2F12%2F12%2Flinux0.11-sched.h%E3%80%81sched.c%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[这篇文章 只是学习笔记，如有错误或疑问，欢迎指出。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332#ifndef _SCHED_H#define _SCHED_H#define NR_TASKS 64 //系统最多的进程数#define HZ 100 // 系统时钟频率 100HZ#define FIRST_TASK task[0] //任务0是 比较特殊 init()#define LAST_TASK task[NR_TASKS-1] //任务数组里面最后一个#include &lt;linux/head.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/mm.h&gt;#include &lt;signal.h&gt;#if (NR_OPEN &gt; 32)#error "Currently the close-on-exec-flags are in one word, max 32 files/proc"#endif//前面说过的 几种状态 当前版本只有这么几个#define TASK_RUNNING 0#define TASK_INTERRUPTIBLE 1#define TASK_UNINTERRUPTIBLE 2#define TASK_ZOMBIE 3#define TASK_STOPPED 4#ifndef NULL#define NULL ((void *) 0)#endif// 几个具体的函数 后面会在sched.c 里面会讲实现// 复制 进程 目录页表extern int copy_page_tables(unsigned long from, unsigned long to, long size);//释放页表所指定的 内存 和页表本身extern int free_page_tables(unsigned long from, unsigned long size);//初始化调度extern void sched_init(void);//调度程序extern void schedule(void);//异常中断处理 ，设置中断调用门，并开启中断extern void trap_init(void);//显示出错信息，然后死循环extern void panic(const char * str);//在 tty 上显示制定长度信息extern int tty_write(unsigned minor,char * buf,int count);// 定义一个函数指针类型typedef int (*fn_ptr)();//这个暂时不用管 是数学处理器使用的结构，我也不知道具体是干啥的struct i387_struct &#123; long cwd; long swd; long twd; long fip; long fcs; long foo; long fos; long st_space[20]; /* 8*10 bytes for each FP-reg = 80 bytes */&#125;;// 任务状态段数据结构 也不知道干啥的struct tss_struct &#123; long back_link; /* 16 high bits zero */ long esp0; long ss0; /* 16 high bits zero */ long esp1; long ss1; /* 16 high bits zero */ long esp2; long ss2; /* 16 high bits zero */ long cr3; long eip; long eflags; long eax,ecx,edx,ebx; long esp; long ebp; long esi; long edi; long es; /* 16 high bits zero */ long cs; /* 16 high bits zero */ long ss; /* 16 high bits zero */ long ds; /* 16 high bits zero */ long fs; /* 16 high bits zero */ long gs; /* 16 high bits zero */ long ldt; /* 16 high bits zero */ long trace_bitmap; /* bits: trace 0, bitmap 16-31 */ struct i387_struct i387;&#125;;//1ong 1eader会话首领。//long start_time进程开始运行时刻。//unsigned short used_math 标志：是否使用了协处理器。//int tty进程使用tty的子设备号。-1表示没有使用。//unsigned short umask文件创建属性屏蔽位。//struct minode*pwd 当前工作目录i节点结构。//struct m inode*root 根目录i节点结构。//struct m inode*executable执行文件i节点结构。//unsigned 1ong close_on_exec执行时关闭文件句柄位图标志。（参见include/fcntl.h）//struct file*filp[NR_OPEN]进程使用的文件表结构。//struct desc_struct 1dt[3]本任务的局部表描述符。0-空，1-代码段cs，2-数据和堆栈段ds&amp;ss。// 重头戏，也就是我们说的 PCBstruct task_struct &#123;/* these are hardcoded - don't touch */ long state; /* -1 unrunnable, 0 runnable, &gt;0 stopped */ long counter; long priority; long signal; //信号执行属性结构，对应信号将要执行的操作 struct sigaction sigaction[32]; // 进程信号屏蔽码，计算机组成原理上面 有详细解释 long blocked; /* bitmap of masked signals *//* various fields */ // 任务执行退出码，给父进程用的 int exit_code; //代码段信息 开始 结束 数据段信息 总长度 堆栈地址 unsigned long start_code,end_code,end_data,brk,start_stack; // 自己 父亲（新版本中 懂事直接用 父亲指针 指向他的PCB） 组号，会话号，会话首领 long pid,father,pgrp,session,leader; //unsigned short uid 用户标识号（用户id）。//euid 有效用户id。suid 保存的用户id。// gid组标识号（组id）egid有效组id。sgid保存的组id。 unsigned short uid,euid,suid; unsigned short gid,egid,sgid;//1ong alarm报警定时值（滴答数）。 long alarm;//1ong utime用户态运行时间（滴答数）。//long stime系统态运行时间（滴答数）。//1ong cutime子进程用户态运行时间。// 1ong cstime子进程系统态运行时间。// start_time 开始运行时间 long utime,stime,cutime,cstime,start_time; // 是否使用了协处理器 unsigned short used_math;/* file system info */// tty 设备 -1 表示没有用 int tty; /* -1 if no tty, so it must be signed */ // 文件穿件属性屏蔽位 unsigned short umask; // 当前工作目录i 节点结构 struct m_inode * pwd; // 更目录 i 节点结构 struct m_inode * root; // 执行文件 i 节点结构 struct m_inode * executable; // 关闭文件句柄位 图标志 unsigned long close_on_exec; // 进程使用的文件表 结构 struct file * filp[NR_OPEN];/* ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss */// 任务局部表描述符， 0 空 1代码段 2 数据和堆栈段 ds &amp;ssstruct desc_struct ldt[3];/* tss for this task */ // 本进程的任务状态信息结构 struct tss_struct tss;&#125;;/* * INIT_TASK is used to set up the first task table, touch at * your own risk!. Base=0, limit=0x9ffff (=640kB) */// 这个 用于 设置第一个任务表 别动就行#define INIT_TASK \/* state etc */ &#123; 0,15,15, \/* signals */ 0,&#123;&#123;&#125;,&#125;,0, \/* ec,brk... */ 0,0,0,0,0,0, \/* pid etc.. */ 0,-1,0,0,0, \/* uid etc */ 0,0,0,0,0,0, \/* alarm */ 0,0,0,0,0,0, \/* math */ 0, \/* fs info */ -1,0022,NULL,NULL,NULL,0, \/* filp */ &#123;NULL,&#125;, \ &#123; \ &#123;0,0&#125;, \/* ldt */ &#123;0x9f,0xc0fa00&#125;, \ &#123;0x9f,0xc0f200&#125;, \ &#125;, \/*tss*/ &#123;0,PAGE_SIZE+(long)&amp;init_task,0x10,0,0,0,0,(long)&amp;pg_dir,\ 0,0,0,0,0,0,0,0, \ 0,0,0x17,0x17,0x17,0x17,0x17,0x17, \ _LDT(0),0x80000000, \ &#123;&#125; \ &#125;, \&#125;//任务指针数组extern struct task_struct *task[NR_TASKS]; //上一个使用过 协处理器的进程extern struct task_struct *last_task_used_math;//当前进程extern struct task_struct *current;//开机时开始技术滴答数 10ms/滴答extern long volatile jiffies;//开机时间。从 1970:0:0:0 开始计时 秒为单位extern long startup_time;//当前时间#define CURRENT_TIME (startup_time+jiffies/HZ)// 添加定时器 到时间执行函数extern void add_timer(long jiffies, void (*fn)(void));// 不可中断的等待睡眠extern void sleep_on(struct task_struct ** p);// 可中断的extern void interruptible_sleep_on(struct task_struct ** p);//唤醒程序extern void wake_up(struct task_struct ** p);/* * Entry into gdt where to find first TSS. 0-nul, 1-cs, 2-ds, 3-syscall * 4-TSS0, 5-LDT0, 6-TSS1 etc ... *///#define FIRST_TSS_ENTRY 4#define FIRST_LDT_ENTRY (FIRST_TSS_ENTRY+1)#define _TSS(n) ((((unsigned long) n)&lt;&lt;4)+(FIRST_TSS_ENTRY&lt;&lt;3))#define _LDT(n) ((((unsigned long) n)&lt;&lt;4)+(FIRST_LDT_ENTRY&lt;&lt;3))#define ltr(n) __asm__("ltr %%ax"::"a" (_TSS(n)))#define lldt(n) __asm__("lldt %%ax"::"a" (_LDT(n)))#define str(n) \__asm__("str %%ax\n\t" \ "subl %2,%%eax\n\t" \ "shrl $4,%%eax" \ :"=a" (n) \ :"a" (0),"i" (FIRST_TSS_ENTRY&lt;&lt;3))/* * switch_to(n) should switch tasks to task nr n, first * checking that n isn't the current task, in which case it does nothing. * This also clears the TS-flag if the task we switched to has used * tha math co-processor latest. *///这是一个很重要的跳转 ，用于上下文切换/*switch_to（n）将切换当前任务到任务nr，即n。首先检测任务n不是当前任务，*如果是则什么也不做退出。如果我们切换到的任务最近（上次运行）使用过数学 *协处理器的话，则还需复位控制寄存器cr0中的TS标志。*///跳转到一个任务的TSS段选择符组成的地址处会造成CPU进行任务切换操作。//输入：%0-指向tmp；%1-指向tmp.b处，用于存放新TSS的选择符；//dx-新任务n的TSS段选择符；ecx-新任务n的任务结构指针task[n]。//其中临时数据结构tmp用 跳转（farjump）指令的操作数。该操作数由4字节偏移//地址和2字节的段选择符组成。因此tmp中a的值是32位偏移值，而b的低2字节是新TSS段的//选择符（高2字节不用）。跳转到TSS段选择符会造成任务切换到该TSS对应的进程。对于造成任务//切换的长跳转，a值无用。177行上的内存间接跳转指令使用6字节操作数作为跳转目的地的长指针，//其格式为：jmp16位段选择符：32位偏移值。但在内存中操作数的表示顺序与这里正好相反。//任务切换回来之后，在判断原任务上次执行是否使用过协处理器时，是通过将原任务指针与保存在//last_task used math变量中的上次使用过协处理器任务指针进行比较而作出的，参见文件//kernel/sched.c中有关math state restore）函数的说明。#define switch_to(n) &#123;\struct &#123;long a,b;&#125; __tmp; \/* * __asm__("cmpl %%ecx,_current\n\t" \ 比较是不是当前运行的进程 "je 1f\n\t" \ 是的话啥都不做 "movw %%dx,%1\n\t" \ 将新任务TSS 的16位 选择符存入 __tmp.b中 "xchgl %%ecx,_current\n\t" \ //current=task[n] ecx=被换出的任务 "ljmp %0\n\t" \ 跳到 *&amp;__tmp,任务切换 这个时候已经不在这里了必须要等到那个任务 执行完后 重新回到这里 "cmpl %%ecx,_last_task_used_math\n\t" \ //原任务使用过协处理器吗 "jne 1f\n\t" \ //没有则跳转 退出 "clts\n" \ //使用过，清楚cr0任务切换 "1:" \ //标志 TS ::"m" (*&amp;__tmp.a),"m" (*&amp;__tmp.b), \ "d" (_TSS(n)),"c" ((long) task[n])); \&#125; * */__asm__("cmpl %%ecx,_current\n\t" \ "je 1f\n\t" \ "movw %%dx,%1\n\t" \ "xchgl %%ecx,_current\n\t" \ "ljmp %0\n\t" \ "cmpl %%ecx,_last_task_used_math\n\t" \ "jne 1f\n\t" \ "clts\n" \ "1:" \ ::"m" (*&amp;__tmp.a),"m" (*&amp;__tmp.b), \ "d" (_TSS(n)),"c" ((long) task[n])); \&#125;#define PAGE_ALIGN(n) (((n)+0xfff)&amp;0xfffff000)#define _set_base(addr,base) \__asm__("movw %%dx,%0\n\t" \ "rorl $16,%%edx\n\t" \ "movb %%dl,%1\n\t" \ "movb %%dh,%2" \ ::"m" (*((addr)+2)), \ "m" (*((addr)+4)), \ "m" (*((addr)+7)), \ "d" (base) \ :"dx")#define _set_limit(addr,limit) \__asm__("movw %%dx,%0\n\t" \ "rorl $16,%%edx\n\t" \ "movb %1,%%dh\n\t" \ "andb $0xf0,%%dh\n\t" \ "orb %%dh,%%dl\n\t" \ "movb %%dl,%1" \ ::"m" (*(addr)), \ "m" (*((addr)+6)), \ "d" (limit) \ :"dx")#define set_base(ldt,base) _set_base( ((char *)&amp;(ldt)) , base )#define set_limit(ldt,limit) _set_limit( ((char *)&amp;(ldt)) , (limit-1)&gt;&gt;12 )#define _get_base(addr) (&#123;\unsigned long __base; \__asm__("movb %3,%%dh\n\t" \ "movb %2,%%dl\n\t" \ "shll $16,%%edx\n\t" \ "movw %1,%%dx" \ :"=d" (__base) \ :"m" (*((addr)+2)), \ "m" (*((addr)+4)), \ "m" (*((addr)+7))); \__base;&#125;)#define get_base(ldt) _get_base( ((char *)&amp;(ldt)) )#define get_limit(segment) (&#123; \unsigned long __limit; \__asm__("lsll %1,%0\n\tincl %0":"=r" (__limit):"r" (segment)); \__limit;&#125;)#endif 关于 sleep_on wait。这是两个 帮助 理解 的图片重点 是 sleep 可wake注意 进程 本身代码段 和PCB 不是 同一个东西。 sleep_on 中 调用 了 schedule();等到 他返回的时候 ，你换这个进程已经唤醒了，也就是 说 ，当前进程唤醒之后，实际上还在sleep on() 里面. wake() 只是 把 PCB 调入了唤醒状态 ，实际上 ，代码段 并没有执行，他还需要等待调度，wake() 只是修改了状态，并不是立马调度。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514/* * linux/kernel/sched.c * * (C) 1991 Linus Torvalds *//* * 'sched.c' is the main kernel file. It contains scheduling primitives * (sleep_on, wakeup, schedule etc) as well as a number of simple system * call functions (type getpid(), which just extracts a field from * current-task */#include &lt;linux/sched.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/sys.h&gt;#include &lt;linux/fdreg.h&gt;#include &lt;asm/system.h&gt;#include &lt;asm/io.h&gt;#include &lt;asm/segment.h&gt;#include &lt;signal.h&gt;// 读取 nr 在信号位图中 对应的二进制数值#define _S(nr) (1&lt;&lt;((nr)-1))// 除了 下面两个 信号 其他都是可阻塞的信号#define _BLOCKABLE (~(_S(SIGKILL) | _S(SIGSTOP)))//内核调试函数 不用详细解释了把void show_task(int nr,struct task_struct * p)&#123; int i,j = 4096-sizeof(struct task_struct);// 进程Nr 的 进程号 状态 以及 堆栈空闲字节数 printk("%d: pid=%d, state=%d, ",nr,p-&gt;pid,p-&gt;state); i=0; while (i&lt;j &amp;&amp; !((char *)(p+1))[i])//检查指定任务结构以后等于 0的字节数 i++; printk("%d (of %d) chars free in kernel stack\n\r",i,j);&#125;//调用前面那个函数 ，非空进程就打印void show_stat(void)&#123; int i; for (i=0;i&lt;NR_TASKS;i++) if (task[i]) show_task(i,task[i]);&#125;//频率 / HZ#define LATCH (1193180/HZ)extern void mem_use(void);//时钟中断处理 具体见 system_call.sextern int timer_interrupt(void);//系统 中断处理 具体见 system_call.sextern int system_call(void);// 任务堆栈段 ，任务内核态堆栈结构union task_union &#123;//任务联合，任务结构体 和stack字符数组成员 struct task_struct task; //任务数据结构和内核态堆栈 在同意内存页 char stack[PAGE_SIZE]; //所以 ss 可以或得其数据段选择符号&#125;;//初始化任务结构 就是第一个进程任务static union task_union init_task = &#123;INIT_TASK,&#125;;//从开机开始算起的滴答数时间值全局变量（10ms/滴答）。系统时钟中断每发生一次即一个滴答。//前面的限定符volatile，英文解释是易改变的、不稳定的意思。这个限定词的含义是向编译器//指明变量的内容可能会由于被其他程序修改而变化。通常在程序中中明一个变量时，编译器会//尽量把它存放在通用寄存器中，例如ebx，以提高访问效率。当CPU把其值放到ebx中后一般//就不会再关心该变量对应内存位置中的内容。若此时其他程序（例如内核程序或一个中断过程）//修改了内存中该变量的值，ebx中的值并不会随之更新。为了解决这种情况就创建了volatile//限定符，让代码在引用该变量时一定要从指定内存位置中取得其值。这里即是要求gcc不要对//jiffies 进行优化处理，也不要挪动位置，并且需要从内存中取其值。因为时钟中断处理过程//等程序会修改它的值。long volatile jiffies=0;//讲过了 开机时间long startup_time=0;// 当前任务 一开始就是第一个任务 现在是init()程序struct task_struct *current = &amp;(init_task.task);//使用过协处理器任务指针struct task_struct *last_task_used_math = NULL;//任务列表，一开始 就是 init（）struct task_struct * task[NR_TASKS] = &#123;&amp;(init_task.task), &#125;;// 用户堆栈//定义用户堆栈，共1K项，容量4K字节。在内核初始化操作过程中被用作内核栈，初始化完成//以后将被用作任务0的用户态堆栈。在运行任务0之前它是内核栈，以后用作任务0和1的用//户态栈。下面结构用于设置堆栈ss:esp（数据段选择符，指针），见head.s，第23行。//ss被设置为内核数据段选择符（0x10），指针esp指在user_stack数组最后一项后面。这是//因为IntelCPU执行堆栈操作时是先递减堆栈指针sp值，然后在sp指针处保存入栈内容。long user_stack [ PAGE_SIZE&gt;&gt;2 ] ;struct &#123; long * a; short b; &#125; stack_start = &#123; &amp; user_stack [PAGE_SIZE&gt;&gt;2] , 0x10 &#125;;/* * 'math_state_restore()' saves the current math information in the * old math state array, and gets the new ones from the current task *//* * 将党建内容 保存 到 老处理器状态数组中 * 并回将当前任务的协处理器内容加载到协处理器中 * *///此函数用于上下文切换 ， 当任务 被调度交换以后，该函数用以保存协处理器状态（上下文）// 并恢复新的调度进来的当前任务的协处理器转台void math_state_restore()&#123; // 任务没有改变 就直接返回 if (last_task_used_math == current) return; //在发送协处理器命令之前要发 wait 指令，如果上一个任务使用了协处理器 就要保存 __asm__("fwait"); if (last_task_used_math) &#123; __asm__("fnsave %0"::"m" (last_task_used_math-&gt;tss.i387)); &#125; //协处理器指向自己 last_task_used_math=current; //如果第一用 就初始化 协处理器 否则 直接回复状态 if (current-&gt;used_math) &#123; __asm__("frstor %0"::"m" (current-&gt;tss.i387)); &#125; else &#123; __asm__("fninit"::);//像协处理器发送初始化命令 current-&gt;used_math=1;//表示自己使用协处理器 &#125;&#125;/* * 'schedule()' is the scheduler function. This is GOOD CODE! There * probably won't be any reason to change this, as it should work well * in all circumstances (ie gives IO-bound processes good response etc). * The one thing you might take a look at is the signal-handler code here. * * NOTE!! Task 0 is the 'idle' task, which gets called when no other * tasks can run. It can not be killed, and it cannot sleep. The 'state' * information in task[0] is never used. *//* * 上面告诉 你 schedule 是个很好的东西 没有要改的必要，任何环境下都能工作。 * 你只需要注意信号处理代码即可 * * 注意!! 任务0 比是一个闲置任务，只有没有其他任务运行的时候你才能调用 ， * 他不能杀死 也不能睡眠，他的state 从来不用。 * */void schedule(void)&#123; int i,next,c; struct task_struct ** p; //指向任务结构指针的指针/* check alarm, wake up any interruptible tasks that have got a signal *//* 检测到alarm（进程的报警定时器），唤醒任何已经得到信号的可中断任务*////从后往前遍历 任务，跳过 空指针 for(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p) if (*p) &#123; // 如果设置了警报，且经过 过期，就设置signal然后清除alarm if ((*p)-&gt;alarm &amp;&amp; (*p)-&gt;alarm &lt; jiffies) &#123; (*p)-&gt;signal |= (1&lt;&lt;(SIGALRM-1)); (*p)-&gt;alarm = 0; &#125; //如果信号位图中被阻塞的信号外还有其他信号，并且任务处于可中断转台，酒吧任务变为就绪 // ~(_BLOCKABLE &amp; (*p)-&gt;blocked))用于忽略阻塞信号 if (((*p)-&gt;signal &amp; ~(_BLOCKABLE &amp; (*p)-&gt;blocked)) &amp;&amp; (*p)-&gt;state==TASK_INTERRUPTIBLE) (*p)-&gt;state=TASK_RUNNING; &#125;/* this is the scheduler proper: */ //调度的核心 while (1) &#123; c = -1; next = 0; i = NR_TASKS; p = &amp;task[NR_TASKS]; while (--i) &#123; //如果是空指针就跳过 if (!*--p) continue; //比较所有 就绪状态 counter 的大小，找到最大的 if ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c) c = (*p)-&gt;counter, next = i; &#125; //如果找到了就跳出去 if (c) break; // 如果最大的counter = 0 就更新 counter ，就是下面这个算法 ，就是当前值 /2 +priority ......好敷衍的感觉 for(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p) if (*p) (*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; 1) + (*p)-&gt;priority; &#125; //下面这个就是跳转执行 如果next=0 实际上又回到了这个函数 switch_to(next);&#125;//暂停当前进程，调度下一个//调用当前函数 会使当前 进程进入睡眠 直到 收到一个信号int sys_pause(void)&#123; current-&gt;state = TASK_INTERRUPTIBLE; schedule(); return 0;&#125;/* * 函数 将当前 进程 睡眠 等待wakeup * * */// **p 是 等待队列头指针的指针void sleep_on(struct task_struct **p)&#123; struct task_struct *tmp; //如果等待队列是空指针 则 无效 if (!p) return; // 如果 当前是任务 0 就死机了 if (current == &amp;(init_task.task)) panic("task[0] trying to sleep"); tmp = *p; *p = current; //把当前状态 阻塞，直到调用wakeup current-&gt;state = TASK_UNINTERRUPTIBLE; //调度 schedule(); //当调度 完成之后 重新唤醒这个进程 代码在这继续执行 if (tmp) //如果后面还有进程就把 下一个也唤醒 tmp-&gt;state=0;&#125;/* * 举个例子 ，如果有误欢迎指出 * * A sleep 调用 B 然后再 sleep 调用 C 然后C调用wake 唤醒了B ，如果A B 在同一个队列 ，B 也会唤醒A * * */void interruptible_sleep_on(struct task_struct **p)&#123; struct task_struct *tmp; if (!p) return; if (current == &amp;(init_task.task)) panic("task[0] trying to sleep"); tmp=*p; *p=current; //前面都是一样的.. //设置当前中断等待状态repeat: current-&gt;state = TASK_INTERRUPTIBLE; schedule(); //如果当前执行的 进程 并不是 当前等待进程队列的第一个 那么 就把他重新丢回去，再调度一次 if (*p &amp;&amp; *p != current) &#123; (**p).state=0; goto repeat; &#125; *p=NULL; if (tmp) tmp-&gt;state=0;&#125;// 直接唤醒void wake_up(struct task_struct **p)&#123; if (p &amp;&amp; *p) &#123; (**p).state=0; *p=NULL; &#125;&#125;/* * 后面的代码 有兴趣的可以自己搜索 理解一下... * * *//* * OK, here are some floppy things that shouldn't be in the kernel * proper. They are here because the floppy needs a timer, and this * was the easiest way of doing it. */static struct task_struct * wait_motor[4] = &#123;NULL,NULL,NULL,NULL&#125;;static int mon_timer[4]=&#123;0,0,0,0&#125;;static int moff_timer[4]=&#123;0,0,0,0&#125;;unsigned char current_DOR = 0x0C;int ticks_to_floppy_on(unsigned int nr)&#123; extern unsigned char selected; unsigned char mask = 0x10 &lt;&lt; nr; if (nr&gt;3) panic("floppy_on: nr&gt;3"); moff_timer[nr]=10000; /* 100 s = very big :-) */ cli(); /* use floppy_off to turn it off */ mask |= current_DOR; if (!selected) &#123; mask &amp;= 0xFC; mask |= nr; &#125; if (mask != current_DOR) &#123; outb(mask,FD_DOR); if ((mask ^ current_DOR) &amp; 0xf0) mon_timer[nr] = HZ/2; else if (mon_timer[nr] &lt; 2) mon_timer[nr] = 2; current_DOR = mask; &#125; sti(); return mon_timer[nr];&#125;//等待制定软驱马达启动一段时间然后返回。void floppy_on(unsigned int nr)&#123; cli(); //这个是禁止中断 while (ticks_to_floppy_on(nr)) sleep_on(nr+wait_motor); sti();&#125;//置关闭相应 的软驱马达停转 3s 不设置 是 100svoid floppy_off(unsigned int nr)&#123; moff_timer[nr]=3*HZ;&#125;//软盘定时处理子程序void do_floppy_timer(void)&#123; int i; unsigned char mask = 0x10; for (i=0 ; i&lt;4 ; i++,mask &lt;&lt;= 1) &#123; if (!(mask &amp; current_DOR)) continue; if (mon_timer[i]) &#123; if (!--mon_timer[i]) wake_up(i+wait_motor); &#125; else if (!moff_timer[i]) &#123; current_DOR &amp;= ~mask; outb(current_DOR,FD_DOR); &#125; else moff_timer[i]--; &#125;&#125;#define TIME_REQUESTS 64// 定时器链表结构和定时器数组static struct timer_list &#123; long jiffies; void (*fn)(); struct timer_list * next;&#125; timer_list[TIME_REQUESTS], * next_timer = NULL;// 添加定时器输入时间 和相应的处理函数指针void add_timer(long jiffies, void (*fn)(void))&#123; struct timer_list * p; if (!fn) return; cli(); if (jiffies &lt;= 0) (fn)(); else &#123; for (p = timer_list ; p &lt; timer_list + TIME_REQUESTS ; p++) if (!p-&gt;fn) break; if (p &gt;= timer_list + TIME_REQUESTS) panic("No more time requests free"); p-&gt;fn = fn; p-&gt;jiffies = jiffies; p-&gt;next = next_timer; next_timer = p; while (p-&gt;next &amp;&amp; p-&gt;next-&gt;jiffies &lt; p-&gt;jiffies) &#123; p-&gt;jiffies -= p-&gt;next-&gt;jiffies; fn = p-&gt;fn; p-&gt;fn = p-&gt;next-&gt;fn; p-&gt;next-&gt;fn = fn; jiffies = p-&gt;jiffies; p-&gt;jiffies = p-&gt;next-&gt;jiffies; p-&gt;next-&gt;jiffies = jiffies; p = p-&gt;next; &#125; &#125; sti();&#125;//时间中断处理函数void do_timer(long cpl)&#123; extern int beepcount; extern void sysbeepstop(void); if (beepcount) if (!--beepcount) sysbeepstop(); if (cpl) current-&gt;utime++; else current-&gt;stime++; if (next_timer) &#123; next_timer-&gt;jiffies--; while (next_timer &amp;&amp; next_timer-&gt;jiffies &lt;= 0) &#123; void (*fn)(void); fn = next_timer-&gt;fn; next_timer-&gt;fn = NULL; next_timer = next_timer-&gt;next; (fn)(); &#125; &#125; if (current_DOR &amp; 0xf0) do_floppy_timer(); if ((--current-&gt;counter)&gt;0) return; current-&gt;counter=0; if (!cpl) return; schedule();&#125;// 这个是设置报警时间（秒）//seconds 大于0 设置新时间 并返回 老时间还差多少秒。否则返回 0int sys_alarm(long seconds)&#123; int old = current-&gt;alarm; if (old) old = (old - jiffies) / HZ; current-&gt;alarm = (seconds&gt;0)?(jiffies+HZ*seconds):0; return (old);&#125;//后面这是一大堆获取当前的一些值的函数int sys_getpid(void)&#123; return current-&gt;pid;&#125;int sys_getppid(void)&#123; return current-&gt;father;&#125;int sys_getuid(void)&#123; return current-&gt;uid;&#125;int sys_geteuid(void)&#123; return current-&gt;euid;&#125;int sys_getgid(void)&#123; return current-&gt;gid;&#125;int sys_getegid(void)&#123; return current-&gt;egid;&#125;//降低优先权int sys_nice(long increment)&#123; if (current-&gt;priority-increment&gt;0) current-&gt;priority -= increment; return 0;&#125;// 这是一个内核初始化程序void sched_init(void)&#123; int i; struct desc_struct * p; if (sizeof(struct sigaction) != 16) panic("Struct sigaction MUST be 16 bytes"); set_tss_desc(gdt+FIRST_TSS_ENTRY,&amp;(init_task.task.tss)); set_ldt_desc(gdt+FIRST_LDT_ENTRY,&amp;(init_task.task.ldt)); p = gdt+2+FIRST_TSS_ENTRY; for(i=1;i&lt;NR_TASKS;i++) &#123; task[i] = NULL; p-&gt;a=p-&gt;b=0; p++; p-&gt;a=p-&gt;b=0; p++; &#125;/* Clear NT, so that we won't have troubles with that later on */ __asm__("pushfl ; andl $0xffffbfff,(%esp) ; popfl"); ltr(0); lldt(0); outb_p(0x36,0x43); /* binary, mode 3, LSB/MSB, ch 0 */ outb_p(LATCH &amp; 0xff , 0x40); /* LSB */ outb(LATCH &gt;&gt; 8 , 0x40); /* MSB */ set_intr_gate(0x20,&amp;timer_interrupt); outb(inb_p(0x21)&amp;~0x01,0x21); set_system_gate(0x80,&amp;system_call);&#125;]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>UNIX</tag>
        <tag>linux</tag>
        <tag>源码</tag>
        <tag>进程调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-4. 寻找两个有序数组的中位数]]></title>
    <url>%2F2019%2F12%2F12%2Fleetcode-4.-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[这题挺有意思的，一开始想了半天怎么处理细节，想了半天，没想出来，要不暴力所有情况，结果特么还跑的飞快。 这题看一眼肯定知道是二分，两个有序数组，找合并之后的中位数。难搞的就是会出现相同数字，和数组长度是偶数。所以我就搞了一个函数 直接找第 k 个在哪，然后第K个在哪，因为 第 k个可能在第一个数组，又有可能在第二个数组，所以要找两次，找的时候把引用换一下就行了。贼麻烦，细节太难处理了，细节处理我打在代码注释里。 思想就是 在一个数组里面二分中间值位置，通过在另一个数组里面二分找小于等于当前值的数量和自己的下标相加可以得到在两个数组合并之后的位置。12345678910111213141516171819202122232425262728293031323334353637383940414243const int INF=0x3f3f3f3f;class Solution &#123;public: inline int get(int k,vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2)&#123; int l=0,r=nums1.size()-1; while(l&lt;=r)&#123; int mid=(l+r)/2; int num=lower_bound(nums2.begin(),nums2.end(),nums1[mid])-nums2.begin(); //找第二个数组里面小于等于num[mid]的个数 if(mid+num&lt;=k)&#123; //如果加起来的位置小于 k 说明这个数可能是要找的 因为可能出现很多个相同的数字所以不能简单的判等于 int t1=upper_bound(nums2.begin(),nums2.end(),nums1[mid])-nums2.begin(); //当前这个值加上相同的个数 int t2=upper_bound(nums1.begin(),nums1.end(),nums1[mid])-nums1.begin(); //当前这个值加上相同的在num2里面的个数 if(t1+t2-1&gt;=k)return nums1[mid]; //两个数相加 -1 就是 位置，下标从 0 开始 /* 举个例子 * &#123;1,1,3,3&#125; &#123;1,1,3,3&#125; * 假设你要找 k=6 * mid = 2 num1[mid]=3 num=2 mid+num=4 &lt;6 * 然后 t1 = 4 t2 = 4 t1+t2-1=7 7&gt;=6 所以 4-7 之间都是相同的数 * 所以实际上 3 是找到的答案 * * */ l=mid+1; &#125; else r=mid-1; &#125; return -INF; &#125; inline int Max(int k,vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2)&#123; // 因为我如果没有在num1 里面找到 下标刚好为 k 的值就会返回-INF，所以直接取个MAX 就是答案 // 交换一下引用就相当于从 num2 里面找排名第k的值了 return max(get(k,nums1,nums2),get(k,nums2,nums1)); &#125; double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int k=(nums1.size()+nums2.size())/2; if((nums1.size()+nums2.size())%2==0)&#123; //如果偶数个 就找 两个值 int t1=Max(k,nums1,nums2),t2=Max(k-1,nums1,nums2); return (Max(k,nums1,nums2)+Max(k-1,nums1,nums2))/2.0; &#125; else return Max(k,nums1,nums2); &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统-进程管理]]></title>
    <url>%2F2019%2F12%2F12%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[大部分基知识看看就行 定义进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的独立单位 进程是程序的一次执行过程，一个程序执行多次那是不同的进程 是正在运行的程序的抽象，或者说是对CPU的一个抽象 将一个CPU变换成多个虚拟的CPU 系统资源以进程为单位分配，如内存、文件等，操作系统为每个独立的进程分配了独立的地址空间 操作系统将CPU调度给需要的进程，即将CPU的控制权交给某个进程就称为调度 特点 结构性：由数据段、程序段、PCB构成 动态性：可以被动态地创建、执行、撤销 并发性：同一时间内有多个进程在运行 独立性：独立运行以及获得OS资源的基本单位 异步性：异步执行 状态 运行状态 进程已经占有CPU，在CPU上运行 就绪状态 具备运行条件，但是由于无CPU，暂时不能运行 阻塞状态 等待信号不能运行 三态转换 五态转换 Linux 下的进程状态版本不同可能状态不同 可运行态 就绪(TASK_RUNNING)：在就绪队列中等待调度。 运行：已经在运行的进程 阻塞状态 可中断阻塞态(TASK_INTERRUPTIBLE)： 进程处于某个等待队列中，它能够被信号（signal）或中断唤醒。等待资源的请求满足时，也被唤醒。 不可中断阻塞态（TASK_UNINTERRUPTIBLE）：进程处于某个等待队列中，不能被信号或中断唤醒，只有等待的资源被满足时才被唤醒。例如当进程打开一个设备文件时，使用TASK_UNINTERRUPTIBLE. 僵死状态(TASK_ZOMBIE):进程已经停止，但还没有释放进程控制块 停止态（TASK_STOPPED）:该状态表示进程的执行被暂停。例如正在接受调试的进程处于这种状态。 死亡态(TASK_DEAD):处于僵死进程的控制块由其父进程回收后的状态。进程控制块（PCB）作用：描述进程状态、资源、和与相关进程关系的数据结构。创建进程时创建PCB；进程撤销后PCB同时撤销。 源码部分解析源码下载，去Linux官网下载即可，可以下载内核代码，如果嫌下载太慢可以去：http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/上面没有 0.11的内核，需要去其他地方下载 文件在：$你的内核目录$/include/linux/sched.h如果找不到 ，可以用find -name sched.h 命令寻找 建议用学习的时候用，Linux低一点的版本，虽然少了很多新东西，但是学习起来更简单。Linux 1.0 源码前面介绍的几种状态的定义123456#define TASK_RUNNING 0#define TASK_INTERRUPTIBLE 1#define TASK_UNINTERRUPTIBLE 2#define TASK_ZOMBIE 3#define TASK_STOPPED 4#define TASK_SWAPPING 5 到了 linux 2.6.38,代码明显复杂了许多，而且使用二进制的第几位来表示状态。123456789101112131415161718192021222324252627#define TASK_RUNNING 0#define TASK_INTERRUPTIBLE 1#define TASK_UNINTERRUPTIBLE 2#define __TASK_STOPPED 4#define __TASK_TRACED 8/* in tsk-&gt;exit_state */#define EXIT_ZOMBIE 16#define EXIT_DEAD 32/* in tsk-&gt;state again */#define TASK_DEAD 64#define TASK_WAKEKILL 128#define TASK_WAKING 256#define TASK_STATE_MAX 512#define TASK_STATE_TO_CHAR_STR "RSDTtZXxKW"extern char ___assert_task_state[1 - 2*!!( sizeof(TASK_STATE_TO_CHAR_STR)-1 != ilog2(TASK_STATE_MAX)+1)];/* Convenience macros for the sake of set_task_state */#define TASK_KILLABLE (TASK_WAKEKILL | TASK_UNINTERRUPTIBLE)#define TASK_STOPPED (TASK_WAKEKILL | __TASK_STOPPED)#define TASK_TRACED (TASK_WAKEKILL | __TASK_TRACED)/* Convenience macros for the sake of wake_up */#define TASK_NORMAL (TASK_INTERRUPTIBLE | TASK_UNINTERRUPTIBLE)#define TASK_ALL (TASK_NORMAL | __TASK_STOPPED | __TASK_TRACED) linux1.0 里面的PCB 结构体,写了一部分其他，具体的自己可以去搜索 sched.h 的源码剖析，可以用grep -rn &quot;内柔&quot;查找函数实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119// 前面所介绍的 几种 状态#define TASK_RUNNING 0#define TASK_INTERRUPTIBLE 1#define TASK_UNINTERRUPTIBLE 2#define TASK_ZOMBIE 3#define TASK_STOPPED 4#define TASK_SWAPPING 5#ifndef NULL#define NULL ((void *) 0) //空指针#endif#ifdef __KERNEL__//调度程序初始化函数 实现 在（kernel/sched.c）extern void sched_init(void);//显示extern void show_state(void);// 异常中断初始化函数 实现在(kernel/traps.c)extern void trap_init(void);//进程调度函数。实现在(kernel/sched.c),asmlinkage void schedule(void);#endif /* __KERNEL__ */struct task_struct &#123;/* these are hardcoded - don't touch */ //运行状态 volatile long state; /* -1 unrunnable, 0 runnable, &gt;0 stopped */ // 时间片 long counter; // 运行优先数 ，任务开始运行时counter = priority，越大运行越长。 long priority; //信号。是位图，每个比特位代表一种信号，信号值=位偏移值+1 unsigned long signal; //进程信号屏蔽码（对应信号位图） unsigned long blocked; /* bitmap of masked signals */ unsigned long flags; /* per process flags, defined below */ int errno; int debugreg[8]; /* Hardware debugging registers *//* various fields */ //下一个 以及上一个 进程 struct task_struct *next_task, *prev_task; struct sigaction sigaction[32]; unsigned long saved_kernel_stack; unsigned long kernel_stack_page; int exit_code, exit_signal; int elf_executable:1; int dumpable:1; int swappable:1; int did_exec:1; //代码段信息 unsigned long start_code,end_code,end_data,start_brk,brk,start_stack,start_mmap; unsigned long arg_start, arg_end, env_start, env_end; //long pid 进程标识号(进程号) int pid,pgrp,session,leader; int groups[NGROUPS]; /* * pointers to (original) parent process, youngest child, younger sibling, * older sibling, respectively. (p-&gt;father can be replaced with * p-&gt;p_pptr-&gt;pid) */ // p_pptr 父亲进程 struct task_struct *p_opptr,*p_pptr, *p_cptr, *p_ysptr, *p_osptr; //等待的儿子 struct wait_queue *wait_chldexit; /* for wait4() */ /* * For ease of programming... Normal sleeps don't need to * keep track of a wait-queue: every task has an entry of its own */ // long pid 进程标识号(进程号)。 // unsigned short euid 有效用户id。// unsigned short suid 保存的用户id。// unsigned short gid 组标识号（组id）。// unsigned short egid 有效组id。// unsigned short sgid 保存的组id。 unsigned short uid,euid,suid; unsigned short gid,egid,sgid; unsigned long timeout; unsigned long it_real_value, it_prof_value, it_virt_value; unsigned long it_real_incr, it_prof_incr, it_virt_incr;// long utime 用户态运行时间（滴答数）。// long stime 系统态运行时间（滴答数）。// long cutime 子进程用户态运行时间。// long cstime 子进程系统态运行时间。 long utime,stime,cutime,cstime,start_time; unsigned long min_flt, maj_flt; unsigned long cmin_flt, cmaj_flt; struct rlimit rlim[RLIM_NLIMITS]; unsigned short used_math; unsigned short rss; /* number of resident pages */ char comm[16]; struct vm86_struct * vm86_info; unsigned long screen_bitmap;/* file system info */ int link_count; int tty; /* -1 if no tty, so it must be signed */ unsigned short umask; struct inode * pwd; struct inode * root; struct inode * executable; struct vm_area_struct * mmap; struct shm_desc *shm; struct sem_undo *semun; struct file * filp[NR_OPEN]; fd_set close_on_exec;/* ldt for this task - used by Wine. If NULL, default_ldt is used */ struct desc_struct *ldt;/* tss for this task */ struct tss_struct tss;#ifdef NEW_SWAP unsigned long old_maj_flt; /* old value of maj_flt */ unsigned long dec_flt; /* page fault count of the last time */ unsigned long swap_cnt; /* number of pages to swap on next pass */ short swap_table; /* current page table */ short swap_page; /* current page */#endif NEW_SWAP struct vm_area_struct *stk_vma;&#125;; 通常PCB 会有 原语：完成某种特定功能的一段程序，具有不可分割性或不可中断性，即原语的执行必须是连续的，在执行过程中不允许被中断。又称原子操作。 进程控制操作完成进程各状态之间的转换，由具有特定功能的原语（其实就是程序，只是这些程序不许与被中断）完成。关于进程控制的原语如下： 进程创建原语 进程撤销原语 阻塞原语 唤醒原语 激活原语 改变进程优先级 是否 看见sched.h里面又一部分 函数的声明。在sched.c里面有 具体的实现 sched_init调度初始化，初始化很多都看不懂，知道他是干啥的就行。1234567891011121314151617181920212223242526272829sched_init(void)&#123; int i; struct desc_struct * p; bh_base[TIMER_BH].routine = timer_bh; if (sizeof(struct sigaction) != 16) panic("Struct sigaction MUST be 16 bytes"); set_tss_desc(gdt+FIRST_TSS_ENTRY,&amp;init_task.tss); set_ldt_desc(gdt+FIRST_LDT_ENTRY,&amp;default_ldt,1); set_system_gate(0x80,&amp;system_call); p = gdt+2+FIRST_TSS_ENTRY; for(i=1 ; i&lt;NR_TASKS ; i++) &#123; task[i] = NULL; p-&gt;a=p-&gt;b=0; p++; p-&gt;a=p-&gt;b=0; p++; &#125;/* Clear NT, so that we won't have troubles with that later on */ __asm__("pushfl ; andl $0xffffbfff,(%esp) ; popfl"); load_TR(0); load_ldt(0); outb_p(0x34,0x43); /* binary, mode 2, LSB/MSB, ch 0 */ outb_p(LATCH &amp; 0xff , 0x40); /* LSB */ outb(LATCH &gt;&gt; 8 , 0x40); /* MSB */ if (request_irq(TIMER_IRQ,(void (*)(int)) do_timer)!=0) panic("Could not allocate timer IRQ!");&#125; show_task和show_state着两个不用多说吧123456789101112131415161718192021222324252627282930313233343536373839static void show_task(int nr,struct task_struct * p)&#123; static char * stat_nam[] = &#123; "R", "S", "D", "Z", "T", "W" &#125;; // 6 种状态 printk("%-8s %3d ", p-&gt;comm, (p == current) ? -nr : nr); if (((unsigned) p-&gt;state) &lt; sizeof(stat_nam)/sizeof(char *)) printk(stat_nam[p-&gt;state]); else printk(" "); if (p == current) printk(" current "); else printk(" %08lX ", ((unsigned long *)p-&gt;tss.esp)[3]); printk("%5lu %5d %6d ", p-&gt;tss.esp - p-&gt;kernel_stack_page, p-&gt;pid, p-&gt;p_pptr-&gt;pid); if (p-&gt;p_cptr) printk("%5d ", p-&gt;p_cptr-&gt;pid); else printk(" "); if (p-&gt;p_ysptr) printk("%7d", p-&gt;p_ysptr-&gt;pid); else printk(" "); if (p-&gt;p_osptr) printk(" %5d\n", p-&gt;p_osptr-&gt;pid); else printk("\n");&#125;void show_state(void) //调用上面那个信息&#123; int i; printk(" free sibling\n"); printk(" task PC stack pid father child younger older\n"); for (i=0 ; i&lt;NR_TASKS ; i++) if (task[i]) show_task(i,task[i]);&#125; 重头戏]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Splay 树学习笔记]]></title>
    <url>%2F2019%2F11%2F12%2FSplay-%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[介绍Splay 树 是一种平衡二叉树，实现比较简单，可以在均摊复杂度$log(n)$对树进行修改和查询。在学这个之前得知道什么是二叉搜索树，二叉搜索树很简单，就是在树上不断把比他大的儿子往右边放，把比他小的儿子往左边放。很显然这种策略是可以被卡到$O(n)$的复杂度，所以就出现对这颗树进行修改的平衡二叉树，Splay 树就是其中一种 实现实现网上已经有很多了，我根据自己理解，写一些记录。 先说一下基础的首先是定义变量123456int ch[maxn][2];//左右儿子int fa[maxn]; //父亲int size[maxn]; //字树大小int cnt[maxn]; //关键字出现次数int key[maxn]; //关键字int sz,root; // 树的大小 根节点 然后是几个简单的函数，清除和判断是不是右儿子1234567inline void clear(int x)&#123; ch[x][0]=ch[x][1]=fa[x]=size[x]=cnt[x]=key[x];&#125;inline int get(int x)&#123; return ch[fa[x]][1]==x;&#125; 因为更新之后节点的左右儿子会变，所以就顶一个更新函数123456789inline void update(int x)&#123; if(x)&#123; size[x]=cnt[x]; if(ch[x][0]) size[x]+=size[ch[x][0]]; if(ch[x][1]) size[x]+=size[ch[x][1]]; &#125;&#125; 核心算法： rotate，旋转操作。选择也很简单，在网上盗了大佬的图。看了这两个图，应该就明白了吧，旋转就是这么简单。如果是右儿子就要换一下旋转。123456789101112inline void rotate(int x)&#123; int old=fa[x],oldf=fa[old],which=get(x); ch[old][which]=ch[x][which^1]; // 是做儿子 把自己右儿子 给父亲的左耳子 否则反之 fa[ch[old][which]]=old; // 把交换的儿子父亲设置成父亲 fa[old]=x; //把父亲节点变儿子节点 ch[x][which^1]=old; fa[x]=oldf; //把自己父亲设置成父亲的父亲 if (oldf) ch[oldf][ch[oldf][1]==old]=x; // 变成父亲的父亲节点的儿子 update(old);update(x);&#125; 然后就是伸展操作，这个算法能实现 均摊$O(log(n))$的复杂度，靠的就是这个。每次查询一个值，通过不断的rotate 把他变为根节点，同样，每次查询都会把路径上的深度减小。这个自己画个图理解一下。。。。123456inline void splay(int x)&#123; for (int p;(p=fa[x]);rotate(x)) if (fa[p]) rotate((get(x)==get(p)?p:x));// 判断三点共线就先选择父亲，保证消减深度 root=x;&#125; 这地方理解了后面就都是打酱油的角色了。查找12345678910111213141516inline int find(int v)&#123; int ans=0,now=root; while (1)&#123; if (v&lt;key[now]) //如果小于 就往左找 now=ch[now][0]; else&#123; ans+=(ch[now][0]?size[ch[now][0]]:0) //大于加上左子树的大小 if (v==key[now]) &#123; splay(now); return ans+1; &#125; ans+=cnt[now]; now=ch[now][1]; &#125; &#125;&#125; 查询第 x 小12345678910111213inline int findx(int x)&#123; int now=root; while (1)&#123; if (ch[now][0]&amp;&amp;x&lt;=size[ch[now][0]]) now=ch[now][0]; else&#123; int temp=(ch[now][0]?size[ch[now][0]]:0)+cnt[now]; if (x&lt;=temp) return key[now]; x-=temp;now=ch[now][1]; &#125; &#125;&#125; 插入1234567891011121314151617181920212223242526272829303132333435inline void insert(int x)&#123; if(root==0)&#123; //root=0相当于 建树 sz++; ch[sz][0]=ch[sz][1]=fa[sz]=0; key[sz]=x; cnt[sz]=1; size[sz]=1; root=sz; return; &#125; int now=root,p=0; while (1)&#123; if(key[now]==x)&#123; //如果已经存在就直接+1 cnt[now]++; update(now); update(p); splay(now); break; &#125; p=now; now=ch[now][key[now]&lt;x]; if (now==0)&#123; //如果不存在就建一个节点 sz++; ch[sz][0]=ch[sz][1]=0; key[sz]=x; size[sz]=1; cnt[sz]=1; fa[sz]=p; ch[p][key[p]&lt;x]=sz; update(p); splay(sz); break; &#125; &#125;&#125; 查询前驱和后继1234567891011inline int pre()&#123; int now=ch[root][0]; while (ch[now][1]) now=ch[now][1]; return now;&#125;inline int next()&#123; int now=ch[root][1]; while (ch[now][0]) now=ch[now][0]; return now;&#125; 删除操作 这个地方解释一下，有两个儿子的情况，首先find 把值直接提到根节点，如果要删除这个节点，也就是这个值的个数是1的情况，这个时候直接把他的前驱提到根节点，然后删了原来那个节点。 把前驱提到根节点最后一定是下图，要删除的那个点一定没有左儿子，所以可以直接删除。12345678910111213141516171819202122232425inline void del(int x)&#123; int whatever=find(x); if (cnt[root]&gt;1) &#123;cnt[root]--;update(root);return;&#125; //Only One Point if (!ch[root][0]&amp;&amp;!ch[root][1]) &#123;clear(root);root=0;return;&#125; //Only One Child if (!ch[root][0])&#123; int oldroot=root; root=ch[root][1]; fa[root]=0; clear(oldroot); return; &#125; else if (!ch[root][1])&#123; int oldroot=root;root=ch[root][0];fa[root]=0;clear(oldroot);return; &#125; //Two Children int leftbig=pre(),oldroot=root; splay(leftbig); fa[ch[oldroot][1]]=root; ch[root][1]=ch[oldroot][1]; clear(oldroot); update(root); return;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FWT快速沃尔什变换-简解及证明]]></title>
    <url>%2F2019%2F09%2F09%2FFWT%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2-%E7%AE%80%E8%A7%A3%E5%8F%8A%E8%AF%81%E6%98%8E%2F</url>
    <content type="text"><![CDATA[FWT简介FWT 用来求卷积，和FFT很像.三个公式 C_k=\sum_{i|j=k}A_i * B_j C_k=\sum_{i\&j=k}A_i * B_j C_k=\sum_{i\ xor\ j=k}A_i * B_j三种卷积，对于三种只详解其中一种。 1.或(or)卷积根据对FTT的理解，首先第一步转换成点值，对$C_k=\sum_{i\ +\ j=k}A_i * B_j$来说，就有点值相同相乘$y_c=y_a * y_b$ y 表示在取某个值的时候多项式的取值。 对于上述这个卷积明显不合适，所以我们需要构造一个新的式子$FWT$满足$FWT(C)=FWT(A) * FWT(B)$。满足或(or)卷积的式子就是$FWT(A)[i]=\sum_{j|i=i}A[j]$,如何来的就不知道了，但是可以证明这个是对的。就相当于$FWT(A|B)=FWT(A) * FWT(B)$,对于公式证明，还不清楚，但是暴力打个表，用数学归纳法证明见大佬博客，倒是没有错. \sum_{i|k=k}C_i=\sum_{i|j=k}(\sum_{t|i=i}A_t*\sum_{p|j=j}B_p) \sum_{i|k=k}(\sum_{o|l=i}A_o * B_l)=\sum_{i|j=k}((\sum_{t|i=i}A_t) * (\sum_{p|j=j}B_p))上式不难看出是相同的,可以简单理解下，右边拆开里面的$A_t * B_p$肯定都是在左边的子集内。 知道上述满足了，就简单了。对于FFT先变成点集,然后逆变换回来，上述同FFT，先变成$FWT$,然后逆变换回来。那么问题来了，求$FWT$,不也是$O(n^2)$,这个时候就是FWT的核心了。对于或卷积的$FWT$有如下式子 FWT(A) = \begin{cases} FWT(A_0,A_1+A_0) & [A]>1\\ A, & [A]=1 \end{cases}$A_0$为前半段，$A_1$为后半段。这个很容易证明，就假设有4项$\{a_0,a_1,a_2,a_3\}$,然后使用分治处理第一次，可以得到$\{a_0,a_0+a_1,a_2,a_2+a_3\}$，然后第二次就是$\{a_0,a_0+a_1,a_0+a_2,a_0+a_1+a_2+a_3\}$，$A$求完了，举了这个栗子应该就明白了，这个$A$的长度要是$2^k$,这个很容易解决，不足的地方补0就行了。逆变换就是把+变成-就好了。 2.和(and)卷积这些都简单过一下$FWT$式子为$FWT(A)[i]=\sum_{j\&amp;i=i}A[j]$有如下式子 FWT(A)=\begin{cases}(FWT(A_0+A_1),FWT(A_1)) & [A]\gt1 \\ A & [A]=1\end{cases}3.异或(xor)卷积对于异或卷积有那么一点不一样，构建的式子有点差距。$FWT$式子为$FWT(A)[i]=\sum_{i=0}^{n}=(-1)^{|(i|x)|}A[j]$ |x| 二进制1的个数 FWT(A)=\begin{cases}(FWT(A_0)+FWT(A_1),FWT(A_0)-FWT(A_1)) & n>1\\A & [A]=1\end{cases}对于这个的逆变换有点差别 IFWT(A)=(\frac{IFWT(A_0)+IFWT(A_1)}{2},\frac{IFWT(A_0)-IFWT(A_1)}{2})不用变符号直接除2就行了。]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>FFT/NTT/FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树链剖分原理和实现]]></title>
    <url>%2F2019%2F08%2F24%2F%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[转自大佬: banananana另一位大佬:ivanovcraft 树链剖分原理和实现树链剖分就是将树分割成多条链，然后利用数据结构（线段树、树状数组等）来维护这些链。 首先就是一些必须知道的概念：重结点：子树结点数目最多的结点；轻节点：父亲节点中除了重结点以外的结点；重边：父亲结点和重结点连成的边；轻边：父亲节点和轻节点连成的边；重链：由多条重边连接而成的路径；轻链：由多条轻边连接而成的路径；树链剖分 比如上面这幅图中，用黑线连接的结点都是重结点，其余均是轻结点，2-11就是重链，2-5就是轻链，用红点标记的就是该结点所在链的起点，也就是我们👇提到的top结点，还有每条边的值其实是进行dfs时的执行序号。 算法中定义了以下的数组用来存储上边提到的概念：12345678名称 解释siz[u] 保存以u为根的子树节点个数top[u] 保存当前节点所在链的顶端节点son[u] 保存重儿子dep[u] 保存结点u的深度值faz[u] 保存结点u的父亲节点tid[u] 保存树中每个节点剖分以后的新编号（DFS的执行顺序）rnk[u] 保存当前节点在树中的位置 除此之外，还包括两种性质：如果(u, v)是一条轻边，那么size(v) &lt; size(u)/2；从根结点到任意结点的路所经过的轻重链的个数必定都小与O(logn)；首先定义以下数组：123456789const int MAXN = (100000 &lt;&lt; 2) + 10;//Heavy-light Decomposition STARTS FORM HEREint siz[MAXN];//number of sonint top[MAXN];//top of the heavy linkint son[MAXN];//heavy son of the nodeint dep[MAXN];//depth of the nodeint faz[MAXN];//father of the nodeint tid[MAXN];//ID -&gt; DFSIDint rnk[MAXN];//DFSID -&gt; ID 算法大致需要进行两次的DFS，第一次DFS可以得到当前节点的父亲结点（faz数组）、当前结点的深度值（dep数组）、当前结点的子结点数量（size数组）、当前结点的重结点（son数组）12345678910111213141516171819202122232425void dfs1(int u, int father, int depth) &#123; /* * u: 当前结点 * father: 父亲结点 * depth: 深度 */ // 更新dep、faz、siz数组 dep[u] = depth; faz[u] = father; siz[u] = 1; // 遍历所有和当前结点连接的结点 for (int i = head[u]; i; i = edg[i].next) &#123; int v = edg[i].to; // 如果连接的结点是当前结点的父亲结点，则不处理 if (v != faz[u]) &#123; dfs1(v, u, depth + 1); // 收敛的时候将当前结点的siz加上子结点的siz siz[u] += siz[v]; // 如果没有设置过重结点son或者子结点v的siz大于之前记录的重结点son，则进行更新 if (son[u] == -1 || siz[v] &gt; siz[son[u]]) &#123; son[u] = v; &#125; &#125; &#125;&#125; 第二次DFS的时候则可以将各个重结点连接成重链，轻节点连接成轻链，并且将重链（其实就是一段区间）用数据结构（一般是树状数组或线段树）来进行维护，并且为每个节点进行编号，其实就是DFS在执行时的顺序（tid数组），以及当前节点所在链的起点（top数组），还有当前节点在树中的位置（rank数组）。123456789101112131415161718192021222324void dfs2(int u, int t) &#123; /** * u：当前结点 * t：起始的重结点 */ top[u] = t; // 设置当前结点的起点为t tid[u] = cnt; // 设置当前结点的dfs执行序号 rnk[cnt] = u; // 设置dfs序号对应成当前结点 cnt++; // 如果当前结点没有处在重链上，则不处理 if (son[u] == -1) &#123; return; &#125; // 将这条重链上的所有的结点都设置成起始的重结点 dfs2(son[u], t); // 遍历所有和当前结点连接的结点 for (int i = head[u]; i; i = edg[i].next) &#123; int v = edg[i].to; // 如果连接结点不是当前结点的重子结点并且也不是u的父亲结点，则将其的top设置成自己，进一步递归 if (v != son[u] &amp;&amp; v != faz[u])&#123; dfs2(v, v); &#125; &#125;&#125; 而修改和查询操作原理是类似的，以查询操作为例，其实就是个LCA，不过这里使用了top来进行加速，因为top可以直接跳转到该重链的起始结点，轻链没有起始结点之说，他们的top就是自己。需要注意的是，每次循环只能跳一次，并且让结点深的那个来跳到top的位置，避免两个一起跳从而插肩而过。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657INT64 query_path(int x, int y) &#123; /** * x：结点x * y：结点y * 查询结点x到结点y的路径和 */ INT64 ans = 0; int fx = top[x], fy = top[y]; // 直到x和y两个结点所在链的起始结点相等才表明找到了LCA while (fx != fy) &#123; if (dep[fx] &gt;= dep[fy]) &#123; // 已经计算了从x到其链中起始结点的路径和 ans += query(1, tid[fx], tid[x]); // 将x设置成起始结点的父亲结点，走轻边，继续循环 x = faz[fx]; &#125; else &#123; ans += query(1, tid[fy], tid[y]); y = faz[fy]; &#125; fx = top[x], fy = top[y]; &#125; // 即便找到了LCA，但是前面也只是分别计算了从一开始到最终停止的位置和路径和 // 如果两个结点不一样，表明仍然需要计算两个结点到LCA的路径和 if (x != y) &#123; if (tid[x] &lt; tid[y]) &#123; ans += query(1, tid[x], tid[y]); &#125; else &#123; ans += query(1, tid[y], tid[x]); &#125; &#125; else ans += query(1, tid[x], tid[y]); return ans;&#125;void update_path(int x, int y, int z) &#123; /** * x：结点x * y：结点y * z：需要加上的值 * 更新结点x到结点y的值 */ int fx = top[x], fy = top[y]; while(fx != fy) &#123; if (dep[fx] &gt; dep[fy]) &#123; update(1, tid[fx],tid[x], z); x = faz[fx]; &#125; else &#123; update(1, tid[fy], tid[y], z); y = faz[fy]; &#125; fx = top[x], fy = top[y]; &#125; if (x != y) if (tid[x] &lt; tid[y]) update(1, tid[x], tid[y], z); else update(1, tid[y], tid[x], z); else update(1, tid[x], tid[y], z);&#125; 个人写法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172int n, m, r, rt, mod, v[maxn], head[maxn], cnt, fa[maxn], size[maxn], d[maxn], son[maxn], top[maxn], id[maxn], rk[maxn];//fa 父亲节点 size 大小 d 深度 son 重儿子 ， top 链顶端 id dfs序 rk dfs序对应的节点vector&lt;int&gt; G[maxn];void add(int x, int y) &#123; G[x].emplace_back(y);&#125;void dfs1(int x) &#123; size[x] = 1; d[x] = d[fa[x]] + 1; for (auto u:G[x]) &#123; if (u != fa[x]) &#123; fa[u] = x; dfs1(u); size[x] += size[u]; if (size[son[x]] &lt; size[u]) &#123; son[x] = u; &#125; &#125; &#125;&#125;void dfs2(int x, int tp) &#123; top[x] = tp; id[x] = ++cnt; rk[cnt] = x; if (son[x]) &#123; dfs2(son[x], tp); &#125; for (auto u:G[x]) &#123; if (u != fa[x] &amp;&amp; u != son[x]) &#123; dfs2(u, u); &#125; &#125;&#125;inline int sum(int x, int y) &#123; int res = 0; while (top[x] != top[y]) &#123; if (d[top[x]] &lt; d[top[y]]) &#123; swap(x, y); &#125; //TODO res = (res + query(id[top[x]], id[x], rt)) % mod; x = fa[top[x]]; &#125; if (id[x] &gt; id[y]) &#123; swap(x, y); &#125; // TODO res = (res + query(id[x], id[y], rt)) % mod; return res;&#125;inline void updates(int x, int y, int c) &#123; while (top[x] != top[y]) &#123; if (d[top[x]] &lt; d[top[y]]) &#123; swap(x, y); &#125; //TODO update(id[top[x]], id[x], c, rt); x = fa[top[x]]; &#125; if (id[x] &gt; id[y]) &#123; swap(x, y); &#125; // TODO update(id[x], id[y], c, rt);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第十场) J Wood Processing]]></title>
    <url>%2F2019%2F08%2F23%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E5%8D%81%E5%9C%BA%EF%BC%89J%20Wood%20Processing%2F</url>
    <content type="text"><![CDATA[题意: $n$快木板，合成$k$块木板。相同高度可以合并，不同高度，需要把高的木板砍成和低的木板一样高。问合成$k$块最少浪费多大木板面积。题解: dp[i][j] 表示前j个合成i个木板最小花费面积。转移方程为 dp[i][j]=min(dp[i-1][k]+sum[j]-sum[k]+h[k+1] * (w[j]-w[k]),dp[i][j])其中$w$表示表示宽度前缀和，$sum$表示面积前缀和，转移的贡献就是， 假设从$k$转移优于$l$，有如下: dp[i-1][k]+sum[j]-sum[k]-h[k+1] * (w[j]-[k])=dp[i-1][l]+sum[j]-sum[l]+h[l+1] * (w[j]-w[l])合并同类项化简， \frac{(dp[i-1][k]-sum[k]+h[k+1] * w[k])-(dp[i-1][l]-sum[l]+h[l+1] * w[l])}{w[k]-w[l]}]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>斜率优化DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斜率优化DP]]></title>
    <url>%2F2019%2F08%2F23%2F%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96DP%2F</url>
    <content type="text"><![CDATA[什么是斜率优化DP？顾名思义，用斜率优化的DP。推荐一波博客这个大哥将的不错。斜率优化DP，一开始会化成一个式子，像 \frac{f(j)-f(k)}{g(j)-g(k)}]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>斜率优化DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[出神入化的分块 Educational Codeforces Round 71 (Rated for Div. 2) E Remainder Problem]]></title>
    <url>%2F2019%2F08%2F23%2F%E5%87%BA%E7%A5%9E%E5%85%A5%E5%8C%96%E7%9A%84%E5%88%86%E5%9D%97%2F</url>
    <content type="text"><![CDATA[Educational Codeforces Round 71 (Rated for Div. 2) E Remainder Problem题意: 两种操作，一种$a_x+y$,第二种查询 \sum_{i=y}^{5e5}a_i,(i\%x==y)所有模$x$等于$y$位置的和.题解: $\%x=y$ 这不就是分块么，就是分块的性质啊，直接处理不就OK了？？，想什么线段树。真6.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include "bits/stdc++.h" using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a)); const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e3 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8; #ifndef ONLINE_JUDGEclock_t prostart = clock();#endif void f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125; //typedef __int128 LLL; template&lt;typename T&gt;void read(T &amp;w) &#123;//读入 char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125; template&lt;typename T&gt;void output(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125; int n, m; const int B = 1e3;LL q[maxn][maxn];LL a[maxn * 1000]; int main() &#123; f(); read(n); while (n--) &#123; int op, x, y; scanf("%d%d%d", &amp;op, &amp;x, &amp;y); if (op == 1) &#123; a[x] += y; for (int i = 1; i &lt;= B; i++) &#123; q[i][x % i] += y; &#125; &#125; else &#123; if (x &lt;= B) &#123; printf("%lld\n", q[x][y]); &#125; else &#123; LL res = 0; while (y &lt;= 500000) &#123; res += a[y]; y += x; &#125; printf("%lld\n", res); &#125; &#125; &#125; #ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>分块</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>出神入化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 10 1011 Make Rounddog Happy]]></title>
    <url>%2F2019%2F08%2F22%2F2019-Multi-University-Training-Contest-10-1011-Make-Rounddog-Happy%2F</url>
    <content type="text"><![CDATA[HDU 6701 Make Rounddog Happy题意 ： 给你$n$个数，和$k$,找到区间[l,r] $max(a_l,\dots,a_r)-(r-l+1)&lt;=k$ 的数量（区间内不能出现有相同数字）。题解： 相当于找区间长度大于区间最大值-k 的区间数量，第一个想到入手的肯定就是区间最大值，然后枚举左边或右边的边界，然后找另外一边的的上界。假设寻找区间最大值，st表能够实现$O(1)$的查找，假设我们找到[l,r]区间的最大值下标为MID，这个MID很显然不会恰好在正中间，那么我们肯定是向里边界近的方向枚举，然后查询另一端的情况。(这个叫启发式分治 队友告诉我是$O(nlog(n))$) 。假设枚举右端下标为当前下标i,另一端的情况怎么获取呢，$O(n)$找肯定不行，另一端上界up肯定是$i-a[MID]-k$,下届呢？从i开始第一个出现相同数字的位置。这个可以$O(n)$ 预处理出来，每个位置上的数上一次出现的位置可以直接求出来，然后从某一个位置到第一个出现相同值的下标肯定是单调的，所以能$O(n)$预处理出第一个从i位置往前最长不出现相同值的位置，和向后最长不出现相同值的位置 这个地方卡了点常，我用2个ST表卡极限时间过了，实际上两个数组就能解决，找区间最大值实际上也能用单调栈解决可以不用ST表。画个图理解一下如果是，枚举左边一样的处理。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 3e5 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;//typedef __int128 LLL;void read(int &amp;w) &#123;//读入 char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125;void output(LL x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125;const int MXN = 3e5 + 10;int a[maxn];int pre[maxn], nxt[maxn];int dp[MXN][20], pos[MXN][20];int lg[maxn];void init(int n) &#123; int LOG = lg[n] + 1; for (int j = 1; j &lt; LOG; ++j) &#123; if ((1 &lt;&lt; (j - 1)) &gt; n) break; for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) &#123; if (dp[i][j - 1] &gt;= dp[i + (1 &lt;&lt; (j - 1))][j - 1]) &#123; dp[i][j] = dp[i][j - 1]; pos[i][j] = pos[i][j - 1]; &#125; else &#123; dp[i][j] = dp[i + (1 &lt;&lt; (j - 1))][j - 1]; pos[i][j] = pos[i + (1 &lt;&lt; (j - 1))][j - 1]; &#125; &#125; &#125;&#125;inline int query(int l, int r) &#123; int k = lg[r - l + 1]; if (dp[l][k] &gt;= dp[r - (1 &lt;&lt; k) + 1][k]) return pos[l][k]; return pos[r - (1 &lt;&lt; k) + 1][k];&#125;inline int query1(int l, int r) &#123; return pre[r];&#125;inline int query2(int l, int r) &#123; return nxt[l];&#125;int n, k;LL ans = 0;void solve(int l, int r) &#123; if (l &gt; r) return; if (l == r) &#123; if (a[l] - 1 &lt;= k) ++ans; return; &#125; int MID = query(l, r);//最大值的位置 if (r - MID &gt; MID - l) &#123; int up = min(query2(MID, r) - 1, r), low; for (int i = MID; i &gt;= l; --i) &#123;//枚举左端点 up = min(nxt[i] - 1, up); low = i + (a[MID] - k) - 1; low = max(low, MID); if (up &lt; MID)break; if (low &gt; up)continue; else &#123; ans += up - low + 1; &#125; &#125; &#125; else &#123; int up, low = max(query1(l, MID) + 1, l); for (int i = MID; i &lt;= r; ++i) &#123;//枚举右端点 low = max(pre[i] + 1, low); up = i - (a[MID] - k) + 1; up = min(up, MID); if (low &gt; MID)break; if (low &gt; up)continue; else &#123; ans += up - low + 1; &#125; &#125; &#125; solve(l, MID - 1); solve(MID + 1, r);&#125;int p[maxn];int main() &#123; f(); int T; read(T); for (int i = 1; i &lt;= 3e5; i++) &#123; lg[i] = log2(i); &#125; while (T--) &#123; read(n); read(k); for (int i = 1; i &lt;= n; i++) &#123; read(a[i]); dp[i][0] = a[i]; pos[i][0] = i; &#125; for (int i = 1; i &lt;= n; i++) &#123; p[i] = 0; &#125; for (int i = 1; i &lt;= n; i++) &#123; pre[i] = p[a[i]]; if (i != 1)pre[i] = max(pre[i], pre[i - 1]); p[a[i]] = i; &#125; for (int i = 1; i &lt;= n; i++) &#123; p[i] = n + 1; &#125; for (int i = n; i &gt;= 1; i--) &#123; nxt[i] = p[a[i]]; if (i != n)nxt[i] = min(nxt[i], nxt[i + 1]); p[a[i]] = i; &#125; for (int i = 1; i &lt;= n; ++i) &#123;// dp1[i][0] = pre[i];// dp2[i][0] = nxt[i]; &#125; init(n); ans = 0; solve(1, n); output(ans); puts(""); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>分治</category>
      </categories>
      <tags>
        <tag>启发式分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治算法]]></title>
    <url>%2F2019%2F08%2F22%2F%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[分治算法，顾名思义，分而治之。分治算法，每次将区间减半，化为[l,mid],[mid+1,r]区间，再用解决的两个区间来跟新[l,r],非常典型的例子就是归并排序。归并排序，每次对[l,mid],[mid+1,r]处理，然后$O(n)$合并两个数组，层数$O(logn)$,每层合并$O(n)$复杂度稳定$O(nlog(n))$。 CDQ分治典型例题:洛谷 3810 三维偏序洛谷 3157 动态逆序对本校OJ的某个题，链接失效很正常 三维偏序三维逆序对是个很裸的题，直接对$x$排序，排序之后像归并排序一样，分治$y$，然后用树状数组更新$z$。就是把归并排序处理逆序对的方法从枚举变成了树状数组。树状数组更新z其实也可以改成用cdq分治处理，换成其他$O(nlog(n))$的算法都可以。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157// luogu-judger-enable-o2#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;//typedef __int128 LLL;template&lt;typename T&gt;void read(T &amp;w) &#123;//读入 char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125;template&lt;typename T&gt;void output(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125;LL bit[maxn + 1], n, k;LL sum(int i) &#123; LL s = 0; while (i &gt; 0) &#123; s += bit[i]; i -= i &amp; -i; &#125; return s;&#125;void add(int i, LL x) &#123; while (i &lt;= k) &#123; bit[i] += x; i += i &amp; -i; &#125;&#125;struct node &#123; int x, y, z, ans, cnt; bool operator==(const node t) const &#123; return x == t.x &amp;&amp; y == t.y &amp;&amp; z == t.z; &#125;&#125; dat[maxn];int ans[maxn];bool cmp1(node &amp;a, node &amp;b) &#123; if (a.x == b.x)return a.y == b.y ? a.z &lt; b.z : a.y &lt; b.y; return a.x &lt; b.x;&#125;bool cmp2(node &amp;a, node &amp;b) &#123; return a.y == b.y ? a.z &lt; b.z : a.y &lt; b.y;&#125;void cdq(int l, int r) &#123; if (r == l)return; cdq(l, mid); cdq(mid + 1, r); sort(dat + l, dat + mid + 1, cmp2); sort(dat + mid + 1, dat + r + 1, cmp2); int j = mid + 1; int i = l; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (dat[i].y &lt;= dat[j].y) &#123; add(dat[i].z, dat[i].cnt); i++; &#125; else &#123; dat[j].ans += sum(dat[j].z); j++; &#125; &#125; while (i &lt;= mid) &#123; add(dat[i].z, dat[i].cnt); i++; &#125; while (j &lt;= r) &#123; dat[j].ans += sum(dat[j].z); j++; &#125; for (i = l; i &lt;= mid; i++)add(dat[i].z, -dat[i].cnt);&#125;int main() &#123; f(); read(n); read(k); k++; for (int i = 1; i &lt;= n; i++) &#123; read(dat[i].x); read(dat[i].y); read(dat[i].z); &#125; sort(dat + 1, dat + n + 1, cmp1); int cnt = 0, num = 0; for (int i = 1; i &lt;= n; i++) &#123; cnt++; if (dat[i] == dat[i + 1])continue; ++num; dat[num].x = dat[i].x; dat[num].y = dat[i].y; dat[num].z = dat[i].z; dat[num].cnt = cnt; cnt = 0; &#125; cdq(1, num); for (int i = 1; i &lt;= num; i++) &#123; ans[dat[i].ans + dat[i].cnt - 1] += dat[i].cnt; &#125; for (int i = 0; i &lt; n; i++)printf("%d\n", ans[i]);#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; endl;#endif return 0;&#125; 动态逆序对解法1：对于动态逆序对，和三维偏序是一个问题。对于每一种删除操作，我们添加一个时间轴$t$,然后把下标当作一维度，就变成了三维，如样例 ：1 5 3 4 2 变成1231 2 3 4 5 下标1 5 3 4 2 值1 1 1 1 1 时间 每次修改，在$t$时间删除了值a,那么把他的时间变成对应修改时间。如样例删除顺序5 1 4 2，没有删除初始化为一个比较大的值，要在树状数组范围内。1231 2 3 4 5 1 5 3 4 23 2 inf 4 5 删除时间 然后不难发现，每次删除一个数的贡献，就是原二维逆序对的基础上，加上一个约束条件 $t_i &lt; t_j$ 。然后用总逆序对数量减去这个当前的时间的贡献就是答案。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193// luogu-judger-enable-o2#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;//typedef __int128 LLL;template&lt;typename T&gt;void read(T &amp;w) &#123;//读入 char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125;template&lt;typename T&gt;void output(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125;struct node &#123; int x, y, z;&#125; dat[maxn];bool cmp1(node &amp;o1, node &amp;o2) &#123; return o1.x == o2.x ? (o1.y == o2.y ? o1.z &lt; o2.z : o1.y &lt; o2.y) : o1.x &gt; o2.x;&#125;bool cmp2(node &amp;o1, node &amp;o2) &#123; return (o1.y == o2.y ? o1.z &lt; o2.z : o1.y &lt; o2.y);&#125;bool cmp3(node &amp;o1, node &amp;o2) &#123; return o1.y &gt; o2.y;&#125;int a[maxn];vector&lt;int&gt; v;LL bit[maxn + 1], n;LL sum(int i) &#123; LL s = 0; while (i &gt; 0) &#123; s += bit[i]; i -= i &amp; -i; &#125; return s;&#125;void add(int i, LL x) &#123; while (i &lt;= n) &#123; bit[i] += x; i += i &amp; -i; &#125;&#125;LL ans[maxn];void cdq(int l, int r) &#123; if (r == l)return; cdq(l, mid); cdq(mid + 1, r); sort(dat + l, dat + mid + 1, cmp2); sort(dat + mid + 1, dat + r + 1, cmp2); int i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (dat[i].y &lt; dat[j].y) &#123; add(dat[i].z, 1); i++; &#125; else &#123; ans[dat[j].z] += sum(dat[j].z); j++; &#125; &#125; while (i &lt;= mid) &#123; add(dat[i].z, 1); i++; &#125; while (j &lt;= r) &#123; ans[dat[j].z] += sum(dat[j].z); j++; &#125; for (i = l; i &lt;= mid; i++)add(dat[i].z, -1); i = l; j = mid + 1; sort(dat + l, dat + mid + 1, cmp3); sort(dat + mid + 1, dat + r + 1, cmp3); while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (dat[i].y &gt; dat[j].y) &#123; ans[dat[i].z] += sum(dat[i].z);// add(dat[i].z, 1); i++; &#125; else &#123;// ans[dat[j].z] += sum(dat[j].z); add(dat[j].z, 1); j++; &#125; &#125; while (j &lt;= r) &#123;// ans[dat[j].z] += sum(dat[j].z); add(dat[j].z, 1); j++; &#125; while (i &lt;= mid) &#123; ans[dat[i].z] += sum(dat[i].z);// add(dat[i].z, 1); i++; &#125; for (j = mid + 1; j &lt;= r; j++)add(dat[j].z, -1);&#125;int main() &#123; f(); int m; read(n); read(m); LL res = 0; for (int i = 1; i &lt;= n; i++) &#123; dat[i].x = i; read(dat[i].y);// res += sum(dat[i].y);// add(dat[i].y, 1); a[i] = 1; &#125;// mem(bit, 0); for (int j = 0; j &lt; m; ++j) &#123; int x; read(x); a[x] = m - j + 1; &#125; for (int i = 1; i &lt;= n; ++i) &#123; dat[i].z = a[dat[i].y]; &#125; sort(dat + 1, dat + n + 1, cmp1); for (int i = 1; i &lt;= n; i++) &#123;// dat[i].x = i;// read(dat[i].y); res += sum(dat[i].y); add(dat[i].y, 1);// a[i] = 1; &#125; mem(bit, 0); cdq(1, n); for (int i = 0; i &lt; m; i++) &#123; printf("%lld\n", res); res -= ans[m + 1 - i]; &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; endl;#endif return 0;&#125; 解法2原本我们这个写法是直接标记修改时间，这次我们变成添加一个相反的值。在原有的节点上，我们添加一个值，记录个数，删除久相当于添加一个个数为-1的节点。例子就变成了12341 1 2 2 3 4 4 5 5 1 1 5 5 3 4 4 2 21 3 1 2 inf 1 4 1 5 删除时间1 -1 1 -1 1 1 -1 1 -1 个数 然后算贡献就可以直接算贡献了，很显然这种写法多了一个常数？那么为什么也要贴出来呢？，因为这个写法添加和删除都可以直接在上面做修改，添加就相当于加了一个个数为1的节点。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189// luogu-judger-enable-o2#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;//typedef __int128 LLL;template&lt;typename T&gt;void read(T &amp;w) &#123;//读入 char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125;template&lt;typename T&gt;void output(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125;struct node &#123; int x, y, z, cnt;&#125; dat[maxn];bool cmp1(node &amp;o1, node &amp;o2) &#123; if (o1.x == o2.x)return o1.y == o2.y ? o1.z &gt; o2.z : o1.y &lt; o2.y; return o1.x &lt; o2.x;&#125;bool cmp2(node &amp;o1, node &amp;o2) &#123; return o1.y == o2.y ? o1.z &gt; o2.z : o1.y &gt; o2.y;&#125;bool cmp3(node &amp;o1, node &amp;o2) &#123; return o1.y == o2.y ? o1.z &lt; o2.z : o1.y &lt; o2.y;&#125;int pos[maxn];int bit[maxn];int n, m;LL sum2(int i) &#123; int s = 0; while (i &gt; 0) &#123; s += bit[i]; i -= i &amp; -i; &#125; return s;&#125;void add(int i, int x) &#123; while (i &lt;= m + 1) &#123; bit[i] += x; i += i &amp; -i; &#125;&#125;LL ans[maxn];void cdq(int l, int r) &#123; if (r == l)return; cdq(l, mid); cdq(mid + 1, r); sort(dat + l, dat + mid + 1, cmp2); sort(dat + mid + 1, dat + r + 1, cmp2); int i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (dat[i].y &gt;= dat[j].y) &#123; add(dat[i].z, dat[i].cnt); i++; &#125; else &#123; ans[dat[j].z] += sum2(dat[j].z) * dat[j].cnt; j++; &#125; &#125; while (i &lt;= mid) &#123; add(dat[i].z, dat[i].cnt); i++; &#125; while (j &lt;= r) &#123; ans[dat[j].z] += sum2(dat[j].z) * dat[j].cnt; j++; &#125; for (i = l; i &lt;= mid; i++)add(dat[i].z, -dat[i].cnt); sort(dat + l, dat + mid + 1, cmp3); sort(dat + mid + 1, dat + r + 1, cmp3); i = l; j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (dat[i].y &gt; dat[j].y) &#123; add(dat[j].z, dat[j].cnt); j++; &#125; else &#123;// if (dat[i].z == 2) &#123;// bug;// &#125; ans[dat[i].z] += sum2(dat[i].z) * dat[i].cnt; i++; &#125; &#125; while (i &lt;= mid) &#123;// if (dat[i].z == 2) &#123;// bug;// &#125; ans[dat[i].z] += sum2(dat[i].z) * dat[i].cnt; i++; &#125; while (j &lt;= r) &#123; add(dat[j].z, dat[j].cnt); j++; &#125; for (i = mid + 1; i &lt;= r; i++)add(dat[i].z, -dat[i].cnt);&#125;int main() &#123; f(); read(n); read(m); LL res = 0; for (int i = 1; i &lt;= n; i++) &#123; read(dat[i].y); dat[i].x = i; pos[dat[i].y] = i; dat[i].cnt = 1; dat[i].z = 1; &#125; for (int i = 1; i &lt;= m; i++) &#123; int x; read(x); dat[i + n].x = pos[x]; dat[i + n].y = dat[pos[x]].y; dat[i + n].z = i + 1; dat[i + n].cnt = -1; &#125; sort(dat + 1, dat + n + m + 1, cmp1); cdq(1, n + m); res = ans[1] / 2; for (int i = 2; i &lt;= m + 1; i++) &#123; printf("%lld\n", res); res += ans[i];// debug(ans[i]); &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; endl;#endif return 0;&#125; 我校那题做练习，如果失效了就别做了，想试试可以留言。启发式分治恕我直言，不说话分治很容易出现一种情况，你需要找的mid不是刚好在一半的位置，。。然后你就往离边界近的方向枚举。然后确定另一半的临界值。这个队友告诉我是$O(nlog(n))$但是我不确定。例题，可以去我的启发式分治题标签里面找]]></content>
      <categories>
        <category>ACM</category>
        <category>分治</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 9 1007 Rikka with Travels]]></title>
    <url>%2F2019%2F08%2F19%2F2019-Multi-University-Training-Contest-9-1007%2F</url>
    <content type="text"><![CDATA[HDU 6686 Rikka with Travels题意: 在一颗树上选择两条不相交的路径的可能性有多少，路径长度定义为路径的顶点数。题解:初步思考，观察样例可以发现，求的是两条路径的有序对，[2,1],[1,2]不是同一种。我们假设已经知道你选择的一条路径长度为l,只需要找到把这条路径在树中移除，余下的森林的最长路径是多少，假设是$r$,对于长度为$l$的路径有多条，然后分别求出对应的$r$就是贡献，然后将所有的$l$的贡献，求和就是答案。很显然这么求就对超时，而且也无从下手。那么我们继续优化，对于一颗树，我们每次拆一条边。求出左边的最长直径为L,右边的最长直径为R,可以发现左边这颗子树的路径可能有$1,2,\cdots,L$，右边有$1,2,\cdots,R$, 我们可以知道，把区间$l=[1,L]$的贡献跟新为$R$,$l=[1,R]$ 更新为$L$，写出暴力修改就是 f[i]=max(f[i],R),1]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>杭电多校</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第八场)Just Jump]]></title>
    <url>%2F2019%2F08%2F14%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5(%E7%AC%AC%E5%85%AB%E5%9C%BA)J.Just-Jump%2F</url>
    <content type="text"><![CDATA[2019牛客暑期多校训练营(第八场)Just Jump题意： 终点位置为$L$，中间点是$1,2,\cdots,L-1$ ，开始位置在$0$，每次必须走至少$d$步,在第。$t_i$步不能出现在 $p_i$ 这个位置，问从 $0$ 到 $L$ ，有多少种走法。 题解：解法挺简单的，先算出没有$m$个约束的情况下，求一个值，这个 $f[i] =\sum_{j=0}^{i-d}f[i]$ 。然后容斥搞一下，$m$个限制，那么问题来了，怎么求刚好走 $t_i$ 步到 $p_i$ 。 这篇博客的意义就在这了,先推荐个基神博客。 这个求一个最后应该就等于$C_{p_i-dt_i+t_i-1}^{t_i-1}$。 我们现在应该是对应这种情况 用插板法，就是从$n+m$个空隙里面，选出$m-1$个位置出来，现在这就是多了个要求，相邻两个间隙不能小于$d$ …,抽象理解下 你把这$m$个$d$全部推前面去，不久相当于直接在后面$n-m * d-(m-1)$选$m-1$个 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 998244353;const int maxn = (int) 1e7 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;//typedef __int128 LLL;template&lt;typename T&gt;void read(T &amp;w) &#123;//读入 char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125;template&lt;typename T&gt;void output(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125;LL L, d, m;P p[3005];LL qz[maxn], l[maxn];const int Comb_Maxn = 1e7 + 10;LL Fac_inv[Comb_Maxn];LL Fac[Comb_Maxn];inline void Comb_init() &#123; Fac_inv[0] = Fac[0] = 1; Fac_inv[1] = 1; for (int i = 1; i &lt; Comb_Maxn; i++) Fac[i] = Fac[i - 1] * (LL) i % mod; for (int i = 2; i &lt; Comb_Maxn; i++) Fac_inv[i] = (LL) (mod - mod / i) * Fac_inv[mod % i] % mod; for (int i = 1; i &lt; Comb_Maxn; i++) Fac_inv[i] = (LL) Fac_inv[i - 1] * Fac_inv[i] % mod;&#125;LL Comb(LL n, LL m) &#123; if (n &lt; 0 || m &lt; 0)return 0; if (n &lt; m)return 0; assert(n &lt; Comb_Maxn &amp;&amp; n &gt;= m); assert(m &lt; Comb_Maxn); return Fac[n] * Fac_inv[m] % mod * Fac_inv[n - m] % mod;&#125;LL dp[maxn];int main() &#123; f(); read(L); read(d); read(m); Comb_init(); for (int i = 0; i &lt; m; i++) &#123; read(p[i].first); read(p[i].second); &#125; sort(p, p + m); l[0] = 1; qz[0] = 1; for (int i = 1; i &lt;= L; i++) &#123; if (i &gt;= d) &#123; l[i] = qz[i - d]; &#125; qz[i] = (qz[i - 1] + l[i]) % mod; &#125; for (int i = 0; i &lt; m; i++) &#123; dp[i] = Comb(p[i].second - d * p[i].first + p[i].first - 1, p[i].first - 1); if (dp[i] != 0) &#123; for (int j = 0; j &lt; i; j++) &#123; dp[i] = (dp[i] - Comb(p[i].second - p[j].second - d * (p[i].first - p[j].first) + (p[i].first - p[j].first) - 1, (p[i].first - p[j].first) - 1) * dp[j] % mod + mod) % mod; &#125; &#125; &#125; LL ans = l[L]; for (int i = 0; i &lt; m; i++) &#123; ans = (ans - dp[i] * l[L - p[i].second] % mod + mod) % mod; &#125; printf("%lld\n", ans);#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>牛客暑期多校训练营</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第八场)Flower Dance(有坑)]]></title>
    <url>%2F2019%2F08%2F13%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5(%E7%AC%AC%E5%85%AB%E5%9C%BA)Flower%20Dance%2F</url>
    <content type="text"><![CDATA[2019牛客暑期多校训练营(第八场)Flower Dance 题意: 给$n$个点 $m$条边，每条边有一个权值区间，表示能通过这个区间的 值的范围，问从$1$到$n$可以通过的权值有多少个。 题解: 1.DFS线段树+离散化+并查集这个线段树，其实也不能算是个正常的线段树，他build 的之后就没啥用了，没有更新和查询.。。直接在线段树上dfs,首先把权值离散化，然后存入线段树中，线段树每个节点表示，区间[l,r]，中有哪些边，这样每次深搜下去，经过的边用并查集维护起来，表示哪些点是联通的，然后如果，1和n联通的话就更新权值。这题有回溯，就有拆边，所以并查集要保存路径，而且要加按秩合并的优化,不然会超时。 写离散化线段树尽量保存 (l,r] 左开右闭的区间值，保存[l,r] 的区间会出问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;//typedef __int128 LLL;template&lt;typename T&gt;void read(T &amp;w) &#123;//读入 char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125;template&lt;typename T&gt;void output(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125;struct edge &#123; int u, v, l, r;&#125; eg[maxn];vector&lt;int&gt; v;int get(int x) &#123; return lower_bound(v.begin(), v.end(), x) - v.begin() + 1;&#125;int n, m;vector&lt;int&gt; dat[maxn];void build(int l, int r, int k, int a, int b, int x) &#123; if (l == a &amp;&amp; b == r) &#123; dat[k].emplace_back(x); return; &#125; if (b &lt;= mid) &#123; build(lson, a, b, x); &#125; else if (a &gt;= mid) &#123; build(rson, a, b, x); &#125; else &#123; build(lson, a, mid, x); build(rson, mid, b, x); &#125;&#125;vector&lt;int&gt; d[maxn];int ans = 0;int par[maxn];int find(int x) &#123; return (par[x] == x) ? x : find(par[x]);&#125;int rk[maxn];void unit(int x, int y, int dep) &#123; x = find(x); y = find(y); if (x != y) &#123; if (rk[x] &lt; rk[y])swap(x, y); par[y] = x; d[dep].emplace_back(y); if (rk[x] == rk[y])rk[x]++; &#125;&#125;void dfs(int l, int r, int k, int dep) &#123; d[dep].clear(); for (auto au:dat[k]) &#123; unit(eg[au].u, eg[au].v, dep); &#125; if (find(1) == find(n)) &#123; ans += v[r - 1] - v[l - 1]; &#125; else if (r != l + 1) &#123; dfs(lson, dep + 1); dfs(rson, dep + 1); &#125; for (auto au:d[dep]) &#123; par[au] = au; &#125;&#125;int main() &#123; f(); read(n); read(m); for (int i = 0; i &lt;= n; i++)par[i] = i; for (int i = 0; i &lt; m; i++) &#123; read(eg[i].u); read(eg[i].v); read(eg[i].l); read(eg[i].r); v.emplace_back(eg[i].l); v.emplace_back(eg[i].r + 1); &#125; sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); int mx = v.size(); for (int i = 0; i &lt; m; i++) &#123; build(1, mx, 1, get(eg[i].l), get(eg[i].r + 1), i); &#125; dfs(1, mx, 1, 0); output(ans); puts("");#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; endl;#endif return 0;&#125; LCT+最小生成树 挖个坑，懒得学splay]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>离散化</tag>
        <tag>牛客暑期多校训练营</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第八场) Distance]]></title>
    <url>%2F2019%2F08%2F13%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5(%E7%AC%AC%E5%85%AB%E5%9C%BA)Distance%2F</url>
    <content type="text"><![CDATA[2019牛客暑期多校训练营(第八场) Distance题意: 给你一个 $n* m* h$ 的空间，每次插入一个点，或者询问空间中点到这一点的最小曼哈顿距离。题解: 1.HASH+三维BIT三维BIT，对于这种写法，太巨了，$n * m * h &lt; 1e5$ 特么直接用三维BIT 存一下就可以了，枚举八个方向，把绝对值去掉，然后最牛的还是hash处理，把三维压缩成一维，削常数，我特么卡常卡成这样也是少见。这种hash将维度，枚举八个方向去绝对值，数组数组模拟空间，还是挺6的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;//typedef __int128 LLL;template&lt;typename T&gt;void read(T &amp;w) &#123;//读入 char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125;template&lt;typename T&gt;void output(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125;typedef vector&lt;int&gt; VI;typedef vector&lt;VI&gt; VVI;typedef vector&lt;VVI&gt; VVVI;struct BIT &#123; int n, m, h; int a[maxn]; void init(int n, int m, int h) &#123; this-&gt;n = n; this-&gt;m = m; this-&gt;h = h; mem(a, -inf); &#125; int get(int x, int y, int z) &#123; return x * h * m + y * h + z; &#125; int lowbit(int &amp;x) &#123; return x &amp; (-x); &#125; void add(int x, int y, int z, int t) &#123; for (int i = x; i &lt;= n; i += lowbit(i)) for (int j = y; j &lt;= m; j += lowbit(j)) for (int k = z; k &lt;= h; k += lowbit(k)) a[get(i, j, k)] = max(a[get(i, j, k)], t); &#125; int sum(int x, int y, int z) &#123; int res = -inf; for (int i = x; i; i -= lowbit(i)) for (int j = y; j; j -= lowbit(j)) for (int k = z; k; k -= lowbit(k)) res = max(a[get(i, j, k)], res); return res; &#125;&#125; b[8];int get_pos(int x, int pos) &#123; return (x &gt;&gt; pos) &amp; 1;&#125;int main() &#123; f(); int n, m, h, q; int op; read(n); read(m); read(h); read(q); for (int i = 0; i &lt; 8; i++) &#123; b[i].init(n, m, h); &#125; int d[] = &#123;n + 1, m + 1, h + 1&#125;; int a[3], c[3]; while (q--) &#123; read(op); read(a[0]); read(a[1]); read(a[2]); if (op == 1) &#123; for (int i = 0; i &lt; 8; i++) &#123; c[0] = get_pos(i, 0) ? d[0] - a[0] : a[0]; c[1] = get_pos(i, 1) ? d[1] - a[1] : a[1]; c[2] = get_pos(i, 2) ? d[2] - a[2] : a[2]; b[i].add(c[0], c[1], c[2], c[1] + c[2] + c[0]); &#125; &#125; else &#123; int ans = inf; for (int i = 0; i &lt; 8; i++) &#123; c[0] = get_pos(i, 0) ? d[0] - a[0] : a[0]; c[1] = get_pos(i, 1) ? d[1] - a[1] : a[1]; c[2] = get_pos(i, 2) ? d[2] - a[2] : a[2]; ans = min(ans, c[0] + c[1] + c[2] - b[i].sum(c[0], c[1], c[2])); &#125; output(ans); puts(""); &#125; &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; " s" &lt;&lt; endl;#endif return 0;&#125; 2.分块+bfs第二种写法就更骚了Orz,对于 $1e5$ 组查询，分成$\sqrt{(1e5)}$ 块，每次插入一个点，先判断有没有$\sqrt{(1e5)}$个，少于这个数量，直接暴力找，假设就算每次都是满的都是 $\sqrt{(1e5)} * 1e5$ 的复杂度，然后如果满了，直接空间中bfs,比如说你插入了两个点,0,0,1 0,0,2,直接暴力bfs,枚举6个方向,找离这个点最近的距离是多少。暴力枚举空间复杂度是$O(n * m * h)$.总复杂度就是 $q*\sqrt{q}+\sqrt{n * m * h} * q$. 这种分块更新的操作，学不来，学不来，根本学不来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include "bits/stdc++.h" using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a)); const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8; #ifndef ONLINE_JUDGEclock_t prostart = clock();#endif void f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125; //typedef __int128 LLL; template&lt;typename T&gt;void read(T &amp;w) &#123;//读入 char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125; template&lt;typename T&gt;void output(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125; int a[maxn]; int dir[6][3] = &#123;&#123;1, 0, 0&#125;, &#123;-1, 0, 0&#125;, &#123;0, 1, 0&#125;, &#123;0, -1, 0&#125;, &#123;0, 0, 1&#125;, &#123;0, 0, -1&#125;&#125;;int X[maxn], Y[maxn], Z[maxn];int lx, ly, lz;int n, m, h, q; int get(int x, int y, int z) &#123; return x * h * m + y * h + z;&#125; struct node &#123; int k, x, y, z; node(int x, int y, int z) &#123; this-&gt;x = x; this-&gt;y = y; this-&gt;z = z; this-&gt;k = get(x, y, z); &#125;&#125;; void rebuild() &#123; queue&lt;node&gt; que; for (int i = 0; i &lt; lx; i++) &#123; que.push(node(X[i], Y[i], Z[i])); a[get(X[i], Y[i], Z[i])] = 0; &#125; while (que.size()) &#123; node t = que.front(); que.pop(); for (int i = 0; i &lt; 6; i++) &#123; int tox = t.x + dir[i][0], toy = t.y + dir[i][1], toz = t.z + dir[i][2]; if (tox &lt; 0 || tox &gt;= n || toy &lt; 0 || toy &gt;= m || toz &lt; 0 || toz &gt;= h) continue; int k = get(tox, toy, toz); if (a[k] &gt; a[t.k] + 1) &#123; a[k] = a[t.k] + 1; que.push(node(tox, toy, toz)); &#125; &#125; &#125; lx = 0; ly = 0; lz = 0;&#125; int op, x, y, z; int main() &#123; f(); mem(a, inf); read(n); read(m); read(h); read(q); while (q--) &#123; read(op); read(x); read(y); read(z); --x, --y, --z; if (op == 1) &#123; X[lx++] = x; Y[ly++] = y; Z[lz++] = z; &#125; else &#123; int k = get(x, y, z); int ans = a[k]; for (int i = 0; i &lt; lx; i++) &#123; ans = min(ans, abs(x - X[i]) + abs(z - Z[i]) + abs(y - Y[i])); &#125; output(ans); puts(""); &#125; if (lx == 300) &#123; rebuild(); &#125; &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; " s" &lt;&lt; endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>牛客暑期多校训练营</tag>
        <tag>树状数组</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第七场) E Find the median]]></title>
    <url>%2F2019%2F08%2F09%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5(%E7%AC%AC%E4%B8%83%E5%9C%BA)E.Find-the-median%2F</url>
    <content type="text"><![CDATA[2019牛客暑期多校训练营(第七场)Find the median 题意: 先把输入处理一下，没啥问题吧。处理完后应该相当于每次在一个集合里面加入l,r之间所有的数，问中位数是多少。题解： 这题很有意思，离散化+线段树 就能做，就相当于在线段树上求第sum/2个数在哪。比较朴素的就是先把所有的l,r保存下来，然后把他离散化，然后对离散化后的值做插入删除操作，我根据线段树动态开点的操作，写了个在线段树上直接离散化的操作，有点像把动态开点和离散化结合起来的感觉。总体来说：就是需要哪个区间我就把线段树的下一个节点开什么样的l,r，不一定是刚好分一半。这样写很容易被卡掉，因为可能退化到$n^2$的复杂度。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;const LL mod = (LL) 1e9 + 7;const int maxn = (int) 4e7 + 5;const int MX = 4e5 + 10;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;LL n;LL x1, x2, a1, b1, c1, m1, Y1, y2, a2, b2, c2, m2;LL ls[MX], rs[MX], xs[MX], ys[MX];struct node &#123; int l; int r; int num; LL sum; int ls, rs;&#125; dat[maxn];int cnt;int init(int l, int r, int k) &#123; dat[k].l = l; dat[k].r = r; dat[k].sum = 0; dat[k].num = 0; dat[k].ls = -1; dat[k].rs = -1; return k;&#125;void build(int l, int r, int k) &#123; cnt = 0; init(l, r, cnt++);&#125;void add(int k, int num) &#123; dat[k].num += num; dat[k].sum += 1LL * (dat[k].r - dat[k].l + 1) * num;&#125;void pushdown(int k) &#123; add(dat[k].ls, dat[k].num); add(dat[k].rs, dat[k].num); dat[k].num = 0; dat[k].sum = dat[dat[k].ls].sum + dat[dat[k].rs].sum;&#125;void update(int a, int b, int k) &#123; if (b &lt; dat[k].l || a &gt; dat[k].r)return; if (a &lt;= dat[k].l &amp;&amp; dat[k].r &lt;= b) &#123; dat[k].num++; dat[k].sum += dat[k].r - dat[k].l + 1; &#125; else &#123; if (dat[k].ls == -1) &#123; int mid; if (b &lt;= dat[k].r) &#123; mid = b; &#125; else mid = a; if (mid == dat[k].l) &#123; //需要什么点，开什么点 dat[k].ls = init(dat[k].l, mid, cnt++); dat[k].rs = init(mid + 1, dat[k].r, cnt++); &#125; else &#123; dat[k].ls = init(dat[k].l, mid - 1, cnt++); dat[k].rs = init(mid, dat[k].r, cnt++); &#125; &#125; pushdown(k); update(a, b, dat[k].ls); update(a, b, dat[k].rs); dat[k].sum = dat[dat[k].ls].sum + dat[dat[k].rs].sum; &#125;&#125;int querry(int k, LL x) &#123; if (dat[k].ls == -1) &#123; return dat[k].l + (x + dat[k].num - 1) / dat[k].num - 1; &#125; else &#123; pushdown(k); if (dat[dat[k].ls].sum &gt;= x) &#123; return querry(dat[k].ls, x); &#125; else return querry(dat[k].rs, x - dat[dat[k].ls].sum); &#125;&#125;int main() &#123; f(); scanf("%lld", &amp;n); scanf("%lld%lld%lld%lld%lld%lld", &amp;x1, &amp;x2, &amp;a1, &amp;b1, &amp;c1, &amp;m1); scanf("%lld%lld%lld%lld%lld%lld", &amp;Y1, &amp;y2, &amp;a2, &amp;b2, &amp;c2, &amp;m2); ls[1] = min(x1, Y1) + 1, rs[1] = max(x1, Y1) + 1; ls[2] = min(x2, y2) + 1, rs[2] = max(x2, y2) + 1; xs[1] = x1, ys[1] = Y1; xs[2] = x2, ys[2] = y2; for (int i = 3; i &lt;= n; ++i) &#123; xs[i] = (1LL * a1 * xs[i - 1] + 1LL * b1 * xs[i - 2] + c1) % m1; ys[i] = (1LL * a2 * ys[i - 1] + 1LL * b2 * ys[i - 2] + c2) % m2; ls[i] = min(xs[i], ys[i]) + 1; rs[i] = max(xs[i], ys[i]) + 1; &#125; LL mi = 1e9 + 1, mx = -1; for (int i = 1; i &lt;= n; ++i) &#123; mx = max(mx, rs[i]); mi = min(mi, ls[i]); &#125; LL S = 0; build(mi, mx, 0); for (LL i = 1; i &lt;= n; i++) &#123; S += rs[i] - ls[i] + 1; update(ls[i], rs[i], 0); printf("%d\n", querry(0, (S+1) / 2)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>离散化</tag>
        <tag>牛客暑期多校训练营</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 5 1002 three arrays]]></title>
    <url>%2F2019%2F08%2F09%2F2019-Multi-University-Training-Contest-5-1002-three-arrays%2F</url>
    <content type="text"><![CDATA[HDU 6625 three arrays题意： 给两个数组，求两个数组两两异或后最小字典序。题解： 求字典序最小，也就是求值最小，如果是求一个数和另一个数组里面的一个值异或最小，很显然就是字典树，就是在字典树上优先取同位相同，没有再取同位相反。求两个数组异或之后字典序最小，其实也可以按照同样的方法求解。对两个数组分别做成一颗字典树，求两颗线段树异或之后字典序最小，就是两颗树异或值尽可能小。一开始我想到这个写法的时候，队友说如果0 0，和1 1 异或都等于0 先选哪一个，仔细思考一下，其实没有什么影响，统计一下两颗树当前节点下方，0 1 的个数，优先把 0 0 1 1 匹配掉，然后再把0 1 1 0两种匹配掉。有点像在字典树上贪心.复杂度两颗树最多有n*31个节点，最差就是每个树都跑一次，所以复杂度是$O(nlog(n))$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;int n;inline int getpos(int x, int pos) &#123; return ((x &gt;&gt; pos) &amp; 1);&#125;struct tree &#123; int a[maxn * 10][3]; int num[maxn * 10][3]; int root = 0; int cnt = 1; void init() &#123; cnt = 1; &#125; void insert(int x) &#123; int p = root, dep = 30; while (dep &gt;= 0) &#123; int nx = getpos(x, dep); if (num[p][nx] == 0) &#123; a[p][nx] = cnt++; num[p][nx] = 1; &#125; else &#123; num[p][nx]++; &#125; p = a[p][nx]; dep--; &#125; &#125;&#125; t1, t2;vector&lt;int&gt; v;template&lt;class T&gt;inline T min(T t1, T t2, T t3) &#123; return min(t1, min(t2, t3));&#125;void dfs(int now1, int now2, int num, int val, int dep) &#123; if (dep == -1) &#123; for (int i = 0; i &lt; num; i++) v.emplace_back(val); return; &#125; if (t1.num[now1][0] &gt; 0 &amp;&amp; t2.num[now2][0] &gt; 0 &amp;&amp; num &gt; 0) &#123; int ct = min(t2.num[now2][0], t1.num[now1][0], num); dfs(t1.a[now1][0], t2.a[now2][0], ct, val, dep - 1); t1.num[now1][0] -= ct; t2.num[now2][0] -= ct; num -= ct; &#125; if (t1.num[now1][1] &gt; 0 &amp;&amp; t2.num[now2][1] &gt; 0 &amp;&amp; num &gt; 0) &#123; int ct = min(t1.num[now1][1], t2.num[now2][1], num); dfs(t1.a[now1][1], t2.a[now2][1], ct, val, dep - 1); t1.num[now1][1] -= ct; t2.num[now2][1] -= ct; num -= ct; &#125; if (t1.num[now1][0] &gt; 0 &amp;&amp; t2.num[now2][1] &gt; 0 &amp;&amp; num &gt; 0) &#123; int ct = min(t2.num[now2][1], t1.num[now1][0], num); dfs(t1.a[now1][0], t2.a[now2][1], ct, val | (1 &lt;&lt; dep), dep - 1); t1.num[now1][0] -= ct; t2.num[now2][1] -= ct; num -= ct; &#125; if (t1.num[now1][1] &gt; 0 &amp;&amp; t2.num[now2][0] &gt; 0 &amp;&amp; num &gt; 0) &#123; int ct = min(t1.num[now1][1], t2.num[now2][0], num); dfs(t1.a[now1][1], t2.a[now2][0], ct, val | (1 &lt;&lt; dep), dep - 1); t1.num[now1][1] -= ct; t2.num[now2][0] -= ct; num -= ct; &#125;&#125;int main() &#123; f(); int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); t1.init(); t2.init(); for (int i = 0; i &lt; n; i++) &#123; int a; scanf("%d", &amp;a); t1.insert(a); &#125; for (int j = 0; j &lt; n; j++) &#123; int a; scanf("%d", &amp;a); t2.insert(a); &#125; v.clear();// debug(t2.num[29][1]); dfs(0, 0, n, 0, 30); sort(v.begin(), v.end()); for (int i = 0; i &lt; n; i++) &#123; printf("%d%c", v[i], i == n - 1 ? '\n' : ' '); &#125; &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>杭电多校</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回文树]]></title>
    <url>%2F2019%2F08%2F07%2F%E5%9B%9E%E6%96%87%E6%A0%91%2F</url>
    <content type="text"><![CDATA[这个东西学会了AC自动机 理解这个应该不难，AC自动fail指针保存了一个最长匹配后缀，这个也差不多。这个保存了最长匹配后缀回文串。举个例子老子找了半天没找到原本看过的博客，只找到了这张图片。随便写几句混一混就过去了。回文树里面的next 和字典树差不多的意义，只不过字典树里面的一个节点是表示在一个节点后面加上一个字符，但next是前后各加一个字符,就是t变成tc 和t变成ctc的区别，前后各加一个字符肯定是回文串。那么问题来了奇数的回文串怎么办，所以出现啊了两个根节点，一个0,一个-1，连在-1的表示是个奇数个数的回文串，看代码里面的x-len[p]+1刚好也是自己，所以自己和自己一定是回文串没啥毛病。再给个图fail差不多就是上图的意思.解释下例子怎么构造的开始的时候建立两个根节点,两个根节点一个长度为0,一个-1，将fail[0]=1,0表示长度为0,1号节点长度为-1,一开始加入a肯定是没有任何后缀，直接连上-1根节点，fail肯定是连上0，此时当前节点的回文后缀有a，空串和-1，然后添加b,a节点前面很显然没有b，所以无法匹配，然后匹配空串，空串前面是a所以还是没法匹配，又匹配-1，很显然这个一定是可以的，因为和自己肯定是相同的.也就是构建了这一部分。然后下一个字符串还是b,此时后缀有b,空串和-1，匹配后缀b前一个是a很显然不匹配，匹配空串,前一个刚好是b所以此时，将bb连到0节点下面，fail指向父亲节点失陪的第一个能够匹配b的位置，这个有点难理解。在代码中是这一行。下一个字符是a，此时字符串最长回文后缀有bb,b,空串和-1,显然bb就直接匹配了，然后再更新fail,差不多就是这么个过程。多余的不解释看别人博客去吧。想深入了解，去看看 国家集训队2017年的论文 吧12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061namespace Palindromic_Tree &#123;const int MAXN = 1000010;const int N = 26;int next[MAXN][N];//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成int fail[MAXN];//fail指针，失配后跳转到fail指针指向的节点int cnt[MAXN];int num[MAXN];int len[MAXN];//len[i]表示节点i表示的回文串的长度int S[MAXN];//存放添加的字符int last;//指向上一个字符所在的节点，方便下一次addint n;//字符数组指针int p;//节点指针int newnode(int l) &#123;//新建节点 for (int i = 0; i &lt; N; ++i) next[p][i] = 0; cnt[p] = 0; num[p] = 0; len[p] = l; return p++;&#125;void init() &#123;//初始化 p = 0; newnode(0); newnode(-1); last = 0; n = 0; S[n] = -1;//开头放一个字符集中没有的字符，减少特判 fail[0] = 1;&#125;int get_fail(int x) &#123;//和KMP一样，失配后找一个尽量最长的 while (S[n - len[x] - 1] != S[n]) x = fail[x]; return x;&#125;int add(int c) &#123; c -= 'a'; S[++n] = c; int ct = 0; int cur = get_fail(last);//通过上一个回文串找这个回文串的匹配位置 if (!next[cur][c]) &#123;//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串 int now = newnode(len[cur] + 2);//新建节点 fail[now] = next[get_fail(fail[cur])][c];//和AC自动机一样建立fail指针，以便失配后跳转 next[cur][c] = now; num[now] = num[fail[now]] + 1; ct = num[now]; &#125; last = next[cur][c]; cnt[last]++; return num[last];&#125;void count() &#123; for (int i = p - 1; i &gt;= 0; --i) cnt[fail[i]] += cnt[i]; //父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！&#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>回文树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AC自动机]]></title>
    <url>%2F2019%2F08%2F07%2FAC%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[AC自动机用途给多个字符串t，再询问一个字符串s，问有多少个字符串t出现在询问的字符串s中。 前置技能学AC自动机之前，先学会什么是字典树，什么是kmp。kmp我写过一篇博客，就不讲了，就是next 数组保存一个最长匹配前缀。字典树就更简单了，每个节点从根节点开始，出现一个字符就在父亲节点上连上下一个节点，也不多说。有需要再写一篇博客。 AC自动机对于这个玩意，都说是字典树上跑KMP,到也没错。朴素KMP是在一个串上面跑next,而AC自动机只是变成了在字典树节点上跑fail指针，每个fail指针保存是最长匹配后缀。推荐一名大佬博客，讲的挺不错的。朴素的写法，每一个字符串t对s做一次kmp算法或者 对所有的t字符串建一颗字典树，然后每个位置匹配一下，很显然$O(n^2)$的复杂度，绝对超时。仔细思考一下，字典树里面，每次匹配都要从下一个位置开始跑一次匹配，类比一下没有kmp的朴素字符串匹配。是不是有点相似。普通单个字符串匹配，是不是枚举每一个位置，然后做一次暴力匹配？然后kmp 做了什么，通过next找到最大匹配前缀。那么我们是否可以在字典树用fail保存最大匹配后缀呢？显然是可以的，不然AC自动机干啥.举个栗子： 假设有三个t asa aaa aas, 匹配aasab字典树建成这个样子，丑了点，别在意，重在思想。然后一开始吧aas匹配掉了没啥意见吧，然后继续匹配aasa，很显然这个时候没有这个字符串，那么肯定就要转移，转移到哪去呢？最长匹配后缀啊。如图是不是这样。然后匹配asa,再继续匹配b,很显然失配了啊，然后找最长匹配后缀，只有根节点了，然后根节点背后又没有b。所以啥都没了，匹配最长后缀为空串。好了，现在差不多理解这个算法的思想，接下来就是一些细节，不知道我还有没有没有考虑到的，如果有请在评论区提问。1.上诉所讲的例子很明显，aas向as跳转，如果后继没有a这个节点怎么办?asa 改成asb,asa要匹配谁呢？这个在kmp算法里面也有这个问题，很显然，继续找下去就能解决问题，假设 再加一个tsb，aasb适配，aas调转到as没有后继b,再跳转到匹配后缀s，有后继b就匹配sb，类推，如果还没有找到就继续想上找。ps: 这个地方可以优化，fail指针找到了最长匹配后缀，然后字典树的下一个节点可以直接跳到对应位置如例子 aas后继a可以直接跳到为asa这个节点，不过不优化也没啥影响，因为字符串长度是固定的，最多不会跳超过n次，不优化只是多了个常数2.多个匹配怎么办？没到一个节点把他的fail找下去记录个数，如图字典树匹配sa,的时候会找他的fail,找到a然后把a这个节点记录，同理找sab,不仅仅把自己匹配了，还要把b匹配掉3.怎么记录个数，如果一个字符串多次出现怎么办，看代码，记录一下就行了。 这个AC自动机的思想还是要学好，后面回文自动机要用到这个玩意的思想。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263namespace Aho_Corasick_Automaton &#123;int trie[maxn][27]; //字典树int cntword[maxn]; //记录单词出现次数，可以开一个vector记录是第几个单词int fail[maxn]; // 失败回溯int cnt=0; // 树的节点个数void init(int x) &#123; for(int i=0; i&lt;26; i++) &#123; trie[x][i]=0; &#125;&#125;void insertWords(char *s) &#123; int ls=strlen(s); int root=0; for(int i=0; i&lt;ls; i++) &#123; int next=s[i]-'a'; if(!trie[root][next]) &#123; init(++cnt); trie[root][next]=cnt; &#125; root=trie[root][next]; &#125; cntword[root]++;&#125;void getFial() &#123; queue&lt;int&gt; q; for(int i=0; i&lt;26; i++) &#123; if(trie[0][i]) &#123; fail[trie[0][i]]=0; q.push(trie[0][i]); &#125; &#125; while(q.size()) &#123; int now=q.front(); q.pop(); for(int i=0; i&lt;26; i++) &#123; if(trie[now][i]) &#123; fail[trie[now][i]]=trie[fail[now]][i]; q.push(trie[now][i]); &#125; else trie[now][i]=trie[fail[now]][i]; &#125; &#125;&#125;int query(char *s) &#123; int ls=strlen(s); int now =0,ans=0; for(int i=0; i&lt;ls; i++) &#123; now=trie[now][s[i]-'a']; for(int j=now; j&amp;&amp;cntword[j]!=-1; j=fail[j]) &#123; // 如果这种状态已经计算过了就不用继续找下去了 ans+=cntword[j];//统计个数，可以在这进行各种操作 cntword[j]=-1; &#125; &#125; return ans;&#125;&#125; 再贴一个大哥板子123456789101112131415161718192021222324252627282930313233343536373839queue&lt;int&gt;q;struct Aho_Corasick_Automaton &#123; int c[N][26],val[N],fail[N],cnt; void ins(char *s) &#123; int len=strlen(s); int now=0; for(int i=0; i&lt;len; i++) &#123; int v=s[i]-'a'; if(!c[now][v]) c[now][v]=++cnt; now=c[now][v]; &#125; val[now]++; &#125; void build() &#123; for(int i=0; i&lt;26; i++) if(c[0][i]) fail[c[0][i]]=0,q.push(c[0][i]); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=0; i&lt;26; i++) if(c[u][i]) fail[c[u][i]]=c[fail[u]][i],q.push(c[u][i]); else c[u][i]=c[fail[u]][i]; &#125; &#125; int query(char *s) &#123; int len=strlen(s); int now=0,ans=0; for(int i=0; i&lt;len; i++) &#123; now=c[now][s[i]-'a']; for(int t=now; t&amp;&amp;~val[t]; t=fail[t]) ans+=val[t],val[t]=-1; &#125; return ans; &#125;&#125; AC;]]></content>
      <categories>
        <category>ACM</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 4-1003 Divide the Stones]]></title>
    <url>%2F2019%2F07%2F31%2F2019-Multi-University-Training-Contest-4-1003%2F</url>
    <content type="text"><![CDATA[HDU 6616 Divide the Stones题意： 给一个n和一个k，将重量为[1,n]的石子分成k堆，每堆重量一样。题解： 先将石子分成n/k份，比如15 3，分成1 2 34 5 67 8 910 11 1213 14 15不难看出如果刚好偶数分，每两份组成一个，分配一定是刚好分配合理的，比如上述例子没有13 14 15,肯定是前两组分成 1 6,2 5 3 4 后两组7 12 8 11 9 10,这样一定是平分的。如果是奇数，&gt;3的份数，依旧一样的处理，1 2 3前三份再分成3等份。这个分法有很多，我找了一个比较辣鸡的。 画个图给你看下图给你了，看不看得懂就是你的悟性了，告辞.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;LL n, k;vector&lt;int&gt; v[maxn];vector&lt;LL&gt; ans[maxn];int main() &#123; int T; f(); scanf("%d", &amp;T); while (T--) &#123; scanf("%lld%lld", &amp;n, &amp;k); LL sum = n * (n + 1) / 2 / k; if (n == 1 &amp;&amp; k == 1) &#123; puts("yes\n1"); continue; &#125; if (n == k || n * (n + 1) / 2 % k != 0) &#123; puts("no"); &#125; else if (k == 1) &#123; puts("yes"); for (int i = 1; i &lt;= n; i++) &#123; printf("%d%c", i, i == n ? '\n' : ' '); &#125; &#125; else &#123; n /= k; int pos = 1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; k; j++) &#123; v[i].push_back(pos++); &#125; &#125; puts("yes"); if (n &amp; 1) &#123; for (int j = 4; j &lt;= n; j += 2) &#123; for (int i = 0; i &lt; k; i++) &#123; ans[i].push_back(v[j][i]); ans[i].push_back(v[j + 1][k - i - 1]); &#125; &#125; int j = k / 2 - 1; for (int i = 0; i &lt; k; i++) &#123; ans[i].push_back(v[3][i]); ans[i].push_back(v[2][(++j) % k]); &#125; for (int i = 0; i &lt; k; i++) &#123; LL temp = 0; for (int j = 0; j &lt; n; j++) &#123; if (j + 1 != n)temp += ans[i][j]; else ans[i].push_back(sum - temp); printf("%lld", ans[i][j]); if (j + 1 == n)printf("\n"); else printf(" "); &#125; ans[i].clear(); &#125; &#125; else &#123; for (int j = 1; j &lt;= n; j += 2) &#123; for (int i = 0; i &lt; k; i++) &#123; ans[i].push_back(v[j][i]); ans[i].push_back(v[j + 1][k - i - 1]); &#125; &#125; for (int i = 0; i &lt; k; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; printf("%lld", ans[i][j]); if (j + 1 == n)printf("\n"); else printf(" "); &#125; ans[i].clear(); &#125; &#125; &#125; for (int i = 0; i &lt;= n; i++) &#123; v[i].clear(); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>构造</category>
      </categories>
      <tags>
        <tag>杭电多校</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组和高度数组(LCP)学习笔记(有坑)]]></title>
    <url>%2F2019%2F07%2F30%2F%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%92%8C%E9%AB%98%E5%BA%A6%E6%95%B0%E7%BB%84(LCP)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[后缀数组字符串后缀，指从字符串某个位置开始到字符串末尾的字串，原串和空串也是后缀。反之前缀。用sa保存字符串开始的下标。字符串总共有n+1个,字符串比较大小是$O(n)$的,所以直接用sort直接排序是$O(n^2log(n))$,很显然不合理。 优化一 hash优化把字符串hash处理,修改sort排序方式，比较两个字符串，先二分最长前缀，比较两个字符串hash处理是$O(1)$的，然后比较第一个位置不同的地方就行了。复杂度$(O(nlog^2(n)))$,但是hash可能会有冲突. 优化二 倍增优化假设一个字符串abaca12345acaacabacaabaca 后缀如上一开始比较可以得出,a&lt;b&lt;c得到一个rank可以表示为字符大小,然后根据这个排序后缀数组。123456789a=0b=1c=2//字符串就是aaabc 然后开始倍增，比较长度2，由于已经知道了a,b,c，长度为1的大小所以可以直接比较，第一个长度1，的大小，再比较第二个长度为1的大小最终可以得出a&lt;ab&lt;ac&lt;ba&lt;ca1234567891011a=0ab=1ac=2ba=3ca=4//字符串aabacbaca 详细推断见 白书P378依次类推就行了，详情见代码这个地方排序可以用基数排序，将复杂度优化到$O(nlog(n))$ 优化三 SA-IS挖下坑以后填，另外还有DC3算法$O(n)$的复杂度，但是DC3常数太大. 高度数组这个处理也非常巧妙，我觉得字符串处理都很有意思。假设一个字符串abracadabra一开始处理出sa 数组你可以发现一个很有意思的事一开始匹配和sa[0] 最大的那一个，也就是原串。abracadabra 后缀排序后比他小的排序后比他小的第一个sa[7]就是abra不难看出来，前缀就是4个。sa[1] bracadabra 匹配 sa[8] bra发现了没有，刚好就是 前面的减去一个刚好3个。然后继续匹配sa[2] racadabra sa[9] ra刚好2个,然后继续sa[3] acadabra sa[0] abracadabra刚好1个。所以sa[i] 匹配sa[k],虽然下一个sa[i+1] 不一定匹配sa[k+1] ,但是匹配个数一定至少是$h_i-1$个，然后我们可以直接从$h_i-1$开始匹配就好了。最多增加不会超过n次，所以复杂度是$O(n)$的。详情见 白书382 推荐习题POJ 2217 SecretaryPOJ 3581 Sequencespoj spoj 694 Distinct Substrings 整理板子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748namespace My &#123; int Rank[maxn + 1], tmp[maxn + 1]; int k, n; bool compare_sa(const int &amp;i, const int &amp;j) &#123; if (Rank[i] != Rank[j])return Rank[i] &lt; Rank[j]; //这个地方很巧妙，比较前k else &#123; int ri = i + k &lt;= n ? Rank[i + k] : -1; //如果加上后半部分超过n，就直接算最小。 int rj = j + k &lt;= n ? Rank[j + k] : -1; return ri &lt; rj; &#125; &#125; template&lt;class T&gt; void construct_sa(T *S, int _n, int *sa) &#123; n = _n; for (int i = 0; i &lt;= n; i++) &#123; sa[i] = i; Rank[i] = i &lt; n ? S[i] : -1; &#125; for (k = 1; k &lt;= n; k *= 2) &#123; sort(sa, sa + n + 1, compare_sa); tmp[sa[0]] = 0; for (int i = 1; i &lt;= n; i++) &#123; tmp[sa[i]] = tmp[sa[i - 1]] + compare_sa(sa[i - 1], sa[i]); //如果两个相等说明前k相等，就像在同一个桶里一样。 &#125; for (int i = 0; i &lt;= n; i++) &#123; Rank[i] = tmp[i]; &#125; &#125; &#125; template&lt;class T&gt; void construct_lcp(T *S, int _n, int *sa, int *lcp) &#123; n = _n; for (int i = 0; i &lt;= n; i++)Rank[sa[i]] = i; int h = 0; lcp[0] = 0; for (int i = 0; i &lt; n; i++) &#123; int j = sa[Rank[i] - 1]; if (h &gt; 0)h--; for (; j + h &lt; n &amp;&amp; i + h &lt; n; h++) &#123; if (S[j + h] != S[i + h])break; &#125; lcp[Rank[i] - 1] = h; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 3 1011 Squrirrel]]></title>
    <url>%2F2019%2F07%2F30%2F2019-Multi-University-Training-Contest-3-1011%2F</url>
    <content type="text"><![CDATA[HDU 6613 Squrirrel题意： 可以合并树上两个点，合并两个点让某一个点到离他最远的距离最小，如果有多个答案输出字典序最小的。题解： 首先从叶子节点往根节点跑，保存每个到这个点的最大距离，和儿子节点删掉一条边之后最大距离的最小值。（肯定是从最大路径上删一条边）我为了保险全判断了 。然后再从根节点往儿子节点跑，每次保存一个，最大，次大，第三大，具体为什么看代码注释。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 2e5 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;int ans1;vector&lt;int&gt; G[maxn];vector&lt;int&gt; cost[maxn];int dp[maxn];int mi[maxn];int in[maxn];int used[maxn];int ans2 = inf;void dfs(int r, int p, int mx, int cmi, int c) &#123; cmi = min(cmi + c, mx); mx = mx + c; int temp = min(max(mx, mi[r]), max(cmi, dp[r])); if (ans2 &gt; temp) &#123; ans2 = temp; ans1 = r; &#125; if (ans2 == temp) &#123; ans2 = temp; ans1 = min(ans1, r); &#125;// cout &lt;&lt; "r=" &lt;&lt; r &lt;&lt; "mx=" &lt;&lt; mx &lt;&lt; "mi=" &lt;&lt; cmi &lt;&lt; endl;// int temp = min(max(dp[r], cmi), max(mi[r], mx));// if (ans2 &gt; temp) &#123;// ans2 = min(max(dp[r], cmi), max(mi[r], mx));// ans1 = r;// &#125; else if (ans2 == temp)ans1 = min(r, ans1); int mx1 = mx, mx2 = 0, mx3 = 0, mi2 = -1, mi1 = p, mi3 = -1, vmi1 = cmi, vmi2 = 0, vmi3 = 0; //记录最大，次大，第三大 for (int i = 0; i &lt; G[r].size(); i++) &#123; int au = G[r][i]; int c = dp[au] + cost[r][i]; if (au == p) continue; temp = min(dp[au], mi[au] + cost[r][i]); if (mx1 &lt;= c) &#123; swap(mx1, c); swap(mi1, au); swap(vmi1, temp); &#125; if (mx2 &lt;= c) &#123; swap(mx2, c); swap(mi2, au); swap(vmi2, temp); &#125; if (mx3 &lt;= c) &#123; swap(mx3, c); swap(mi3, au); swap(vmi3, temp); &#125; &#125; for (int i = 0; i &lt; G[r].size(); i++) &#123; int au = G[r][i]; int c = cost[r][i]; if (au == p)continue; if (au == mi1) &#123; if (mi3 == -1)dfs(au, r, mx2, vmi2, c); else dfs(au, r, mx2, max(vmi2, mx3), c); //如果是往最大的路径走，就是在次大的路上删一条边再和第三大比较 &#125; else if (au == mi2) &#123; if (mi3 == -1)dfs(au, r, mx1, vmi1, c); else dfs(au, r, mx1, max(vmi1, mx3), c); //如果是往第二大的，就是在最大路上删一条边再和第三大比较 &#125; else dfs(au, r, mx1, max(vmi1, mx2), c); // 其他的肯定都是删最大的路径一条边 再和第二大比较 &#125;&#125;int main() &#123; f(); int n; int t; scanf("%d", &amp;t); while (t--) &#123; scanf("%d", &amp;n); for (int i = 1; i &lt; n; i++) &#123; int u, v, c; scanf("%d%d%d", &amp;u, &amp;v, &amp;c); G[u].emplace_back(v); cost[u].emplace_back(c); G[v].emplace_back(u); cost[v].emplace_back(c); in[u]++; in[v]++; &#125; queue&lt;int&gt; q; for (int i = 1; i &lt;= n; i++) &#123; dp[i] = 0; if (in[i] == 1) &#123; q.push(i); mi[i] = 0; &#125; else mi[i] = inf; &#125; int r = -1; ans1 = 0; ans2 = inf; while (q.size()) &#123; int v = q.front(); q.pop(); r = v; if (used[v] == 0)used[v] = 1; else continue; int mx1 = 0, mx2 = 0; for (int i = 0; i &lt; G[r].size(); i++) &#123; int au = G[r][i]; int c = dp[au] + cost[r][i]; if (!used[au])continue; if (mx1 &lt; c)swap(mx1, c); if (mx2 &lt; c)swap(mx2, c); &#125; for (int i = 0; i &lt; G[r].size(); i++) &#123; int au = G[r][i]; int c = cost[r][i]; if (!used[au])continue; if (dp[au] + c == mx1) &#123; mi[r] = min(mi[r], max(min(dp[au], mi[au] + c), mx2)); //这个肯定就是最小的 &#125; else mi[r] = min(mi[r], max(min(dp[au], mi[au] + c), mx1)); //这个可以不要 &#125; for (int i = 0; i &lt; G[v].size(); i++) &#123; int &amp;au = G[v][i], &amp;c = cost[v][i]; in[au]--; if (used[au] == 0) &#123; dp[au] = max(dp[r] + c, dp[au]); if (in[au] == 1)q.push(au); &#125; &#125; &#125;// for (int i = 1; i &lt;= n; i++) &#123;// printf("[%d]= %d %d\n", i, dp[i], mi[i]);// &#125; if (n == 1 || n == 2)printf("%d %d\n", 1, 0); else &#123; dfs(r, -1, 0, 0, 0); printf("%d %d\n", ans1, ans2); for (int i = 1; i &lt;= n; i++) &#123; used[i] = 0; in[i] = 0; G[i].clear(); cost[i].clear(); &#125; &#125; &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>杭电多校</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 1 1001 Blank]]></title>
    <url>%2F2019%2F07%2F27%2F2019-Multi-University-Training-Contest-1-1001%2F</url>
    <content type="text"><![CDATA[HDU 6578 Blank题意： 给定1,N 的位置，每个位置可以填1,2,3,4其中一个，给m个区间[l,r] x ，限制[l,r]区间内只有x种不同的数。题解： n非常小，只有100，可以直接用数组枚举上一个数出现的位置，每个位置暴力填就行了。直接$O(n^4)$会T，。，必须要削常数。可以发现出现是什么数本身不重要，只和位置有关。然后最大的那个位置，一定是你要填的这个pos-1,所以dp空间可以优化一维，dp[i][j][k],代表排序后位置分别是i&lt;j&lt;k&lt;pos-1，然后枚举的状态也是i&lt;j&lt;k&lt;pos-1 ，对于限制条件，判断一下状态合不合法就行了。对于某个pos到了[l,r] x,r的位置,判断一下就行了，这个不影响复杂度。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;unordered_map&gt;#include&lt;unordered_set&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;(x)&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a, b) memset(a,b,sizeof(a));const long long mod = 998244353;const int maxn = 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif // ONLIN_JUDGE&#125;LL dp[105][105][105][2];struct node &#123; int l, r, x; bool operator&lt;(node &amp;t) const &#123; if (r == t.r)return l &lt; t.l; return r &lt; t.r; &#125;&#125; dat[maxn];int n, m;void check(LL &amp;x) &#123; x %= mod;&#125;int main() &#123; f(); int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d", &amp;dat[i].l, &amp;dat[i].r, &amp;dat[i].x); dat[i].l += 3; dat[i].r += 3; &#125; dp[0][1][2][1] = 1; sort(dat + 1, dat + m + 1); int l = 1, p = 0; for (int pos = 4; pos &lt;= n + 3; pos++, p = !p) &#123; for (int i = 0; i &lt;= pos - 4; i++) &#123; for (int j = i + 1; j &lt;= pos - 3; j++) &#123; for (int k = j + 1; k &lt;= pos - 2; ++k) &#123; int flag = 0, temp = l; while (temp &lt;= m &amp;&amp; pos - 1 == dat[temp].r) &#123; if (dat[temp].x == 1 &amp;&amp; dat[temp].l &lt;= k) &#123; flag = 1; &#125; if (dat[temp].x == 2 &amp;&amp; (dat[temp].l &lt;= j || dat[temp].l &gt; k)) &#123; flag = 1; &#125; if (dat[temp].x == 3 &amp;&amp; (dat[temp].l &lt;= i || dat[temp].l &gt; j))flag = 1; if (dat[temp].x == 4 &amp;&amp; dat[temp].l &gt; i)flag = 1; temp++; &#125; if (flag) &#123; dp[i][j][k][!p] = 0; continue; &#125; dp[j][k][pos - 1][p] += dp[i][j][k][!p]; check(dp[j][k][pos - 1][p]); dp[i][k][pos - 1][p] += dp[i][j][k][!p]; check(dp[i][j][pos - 1][p]); dp[i][j][pos - 1][p] += dp[i][j][k][!p]; check(dp[i][j][pos - 1][p]); dp[i][j][k][p] += dp[i][j][k][!p]; check(dp[i][j][k][p]); dp[i][j][k][!p] = 0; &#125; &#125; &#125; while (l &lt;= m &amp;&amp; dat[l].r == pos - 1)l++; &#125; LL ans = 0; for (int i = 0; i &lt;= n + 3; i++) &#123; for (int j = i + 1; j &lt;= n + 3; j++) &#123; for (int k = j + 1; k &lt;= n + 3; ++k) &#123; int flag = 0, temp = l; while (temp &lt;= m) &#123; if (dat[temp].x == 1 &amp;&amp; dat[temp].l &lt;= k) &#123; flag = 1; &#125; if (dat[temp].x == 2 &amp;&amp; (dat[temp].l &lt;= j || dat[temp].l &gt; k)) &#123; flag = 1; &#125; if (dat[temp].x == 3 &amp;&amp; (dat[temp].l &lt;= i || dat[temp].l &gt; j))flag = 1; if (dat[temp].x == 4 &amp;&amp; dat[temp].l &gt; i)flag = 1; temp++; &#125; if (flag) &#123; dp[i][j][k][!p] = 0; continue; &#125; ans = (ans + dp[i][j][k][!p] % mod) % mod; dp[i][j][k][!p] = 0; &#125; &#125; &#125; printf("%lld\n", ans); &#125; return 0;&#125;/*61 0410 0104857611 0419430420 044459512330 068215596540 0382013690 */]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>杭电多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单调栈和单调队列]]></title>
    <url>%2F2019%2F07%2F26%2F%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[理解单调栈和单单调队列之前，要明白一种技巧，叫做尺取法。 尺取法尺取法，两个位置，一个是l，一个r,r一位位的左移，l根据条件左移。比如POJ 3061求最大连续字串和不超过sl r初始化为0,r左移，总和加上r位置的值，如果总和一旦大于s,l开始左移，直到满足[l,r]区间的总和小于s，这种通过l,r反复推进的方法，就叫尺取法。 细心的人可以发现，这种方法，求结果一定要满足，右边一个位置跨过r到l一定是不合法的的情况。 单调栈其实这个和尺取法关系不大。。。。单调栈,用于求最左边（右边）的第一个满足某种具有单调性质条件（比如大于，小于）的位置。距离，求第一个大于的位置。求大于，将不大于的数全部加入单调栈里面，保证栈单调递减，（下面距离栈中存的是小标,注意区分值和下标）假设有1 3 5 2 1 4 7 6一开始栈为空，将第一个数位置加进去，此时栈中有下标1到第二个数 3 ，栈顶 位置的值 小于3弹出，赋值位置右边第一个大于他的数下标是2，然后栈为空，将2号位置加入栈，依次类推.到5 弹出下标2 加入下标3,到 2 因为栈顶位置的值大于2不弹出，直到4 弹出值2,1，不弹出5。当前值比栈顶的数大，弹出栈顶的值，并赋值，否则加入栈。 单调队列单调队列和尺取法用点像，和单调栈也差距不大。总结来说，位置尺取，队列单调，就想尺取法和单调栈的结合体。例子 HDU 3530按题目来讲： 查寻区间最大最小值之差在[m,k]之间的最大长度。现按照尺取的方法来：不断移动，l，r,虽然从在r右边跨过r 到l 最大最小值之差绝对是大于等于[r,l]之间的,但是最大最小不可能一直是端点，可能[r,l]之间存在比r,l大或者小的值。那么该如何处理呢，单调栈可以保存一个单调的子序列，我们是否能和他一样保存[l,r],的单增子序列呢？很显然是可以的。因为我们的[l,r]有两端，所以用栈是肯定不行的，那么就只能用双端队列。我们建立两个双端队列，一个保存[l,r]递增的子序列，一个保存[l,r]递减的子序列，那么递减队列中第一个值保存的就是[l,r]区间的最大值，递增的就是最小值。那么假设[l,r] 区间的最大值和最小值不满足条件了，要尺取就要移动l,怎么移动？我们要改变最大最小值。改变哪里一个？肯定是离r最远的那一个，我们单调队列保存的下标，直接把l移动到两个队列队首，最小的下标+1,然后弹出队首，就相当于找到了新[l,r]最大（最小）值 (因为我们队列是单调的，弹出了最大（最小）值就相当于找到了次大（次小）值，在新区间就没有比他小的了 ) 然后，一直循环直到满足条件为止。单增队列就是队尾进，每次和单调栈一样保证队列中是单调的，队首永远都是最小的或者最大的 HDU 3530 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;struct deq &#123; static const int start = maxn * 2; int dat[start * 2]; int l = start; int r = start; void push_front(int x) &#123; dat[l--] = x; &#125; void pop_front() &#123; l++; &#125; int front() &#123; return dat[l + 1]; &#125; void push_back(int x) &#123; dat[++r] = x; &#125; void pop_back() &#123; r--; &#125; int back() &#123; return dat[r]; &#125; int size() &#123; return r - l; &#125; void clear() &#123; r = l = start; &#125; bool empty() &#123; return r == l; &#125;&#125;;deque&lt;int&gt; dq, dq2;int n, m, k;int a[maxn];int main() &#123; f(); while (~scanf("%d%d%d", &amp;n, &amp;m, &amp;k)) &#123; int ans = 0; dq.clear(); dq2.clear(); int pos = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); // 大的弹出所以最前面是最小的 while (dq.size() &gt; 0 &amp;&amp; a[dq.back()] &gt; a[i]) &#123; dq.pop_back(); &#125; dq.push_back(i); while (dq2.size() &gt; 0 &amp;&amp; a[dq2.back()] &lt; a[i]) &#123; dq2.pop_back(); &#125; dq2.push_back(i); while (a[dq2.front()] - a[dq.front()] &gt; k) &#123; if (dq2.front() &lt; dq.front()) &#123; pos = dq2.front(); dq2.pop_front(); &#125; else &#123; pos = dq.front(); dq.pop_front(); &#125; &#125; if (dq2.size() &amp;&amp; dq.size() &amp;&amp; a[dq2.front()] - a[dq.front()] &gt;= m) &#123; ans = max(ans, i - pos); &#125; &#125; printf("%d\n", ans); &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125;/*54 */ 友情提示：最好别用 std 里面的栈和队列，太慢了进阶题：2019牛客暑期多校训练营（第三场）F Planting Trees题解 ： 2019牛客暑期多校训练营（第三场）F Planting TreesF/)]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
        <tag>巧解</tag>
        <tag>笔记</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营（第三场）F Planting Trees]]></title>
    <url>%2F2019%2F07%2F26%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5(%E7%AC%AC%E4%B8%89%E5%9C%BA)F%2F</url>
    <content type="text"><![CDATA[2019牛客暑期多校训练营（第三场）F Planting Trees题意: 一个$N \ast N$ 的矩阵，问最大值和最小值大小差距不超过$M$的最大子矩阵多大。题解: 题目明示你要使用$O(N^3)$的杂度,暴力枚举子矩阵高度$x$，做一个预处理，把$a[i][j]$到$a[i+x][j]$的最大最小值处理出来，压缩成一行，然后做一次求区间最大值和最小值差值不超过$M$的区间最大长度。不懂单调队列的可以看看 单调栈和单调队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include "stdio.h"#include "ctype.h" #define max(a, b) a&gt;b?a:b#define min(a, b) a&lt;b?a:bconst int maxn = 5e2 + 5; struct deq &#123; static const int start = maxn * 2; int dat[start * 2]; int l = start; int r = start; void push_front(int x) &#123; dat[l--] = x; &#125; void pop_front() &#123; l++; &#125; int front() &#123; return dat[l + 1]; &#125; void push_back(int x) &#123; dat[++r] = x; &#125; void pop_back() &#123; r--; &#125; int back() &#123; return dat[r]; &#125; int size() &#123; return r - l; &#125; void clear() &#123; r = l = start; &#125; bool empty() &#123; return r == l; &#125;&#125;; deq dqmx, dqmi; template&lt;typename T&gt;void read(T &amp;w) &#123; //读入 char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar()))w = w * 10 + (c &amp; 15);&#125; int n, k;int a[maxn][maxn];int ans = 0;int mi[maxn][maxn];int mx[maxn][maxn]; int main() &#123; int T; read(T); while (T--) &#123; read(n); read(k); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; read(a[i][j]); &#125; &#125; ans = 0; for (int x = 1; x &lt;= n; x++) &#123; for (int i = n; i &gt;= x; i--) &#123; int pos = 0; dqmx.clear(); dqmi.clear(); for (int j = 1; j &lt;= n; j++) &#123; if (x == 1) &#123; mx[i][j] = a[i][j]; mi[i][j] = a[i][j]; &#125; else &#123; mx[i][j] = max(mx[i - 1][j], a[i][j]); mi[i][j] = min(mi[i - 1][j], a[i][j]); &#125; int tmi = mi[i][j], tmx = mx[i][j]; if (tmx - tmi &gt; k) &#123; dqmi.clear(); dqmx.clear(); pos = j; &#125; else &#123; while (dqmi.size() &amp;&amp; mi[i][dqmi.back()] &gt; tmi) &#123; dqmi.pop_back(); &#125; dqmi.push_back(j); while (dqmx.size() &amp;&amp; mx[i][dqmx.back()] &lt; tmx) &#123; dqmx.pop_back(); &#125; dqmx.push_back(j); while (mx[i][dqmx.front()] - mi[i][dqmi.front()] &gt; k) &#123; if (dqmx.front() &lt; dqmi.front()) &#123; pos = dqmx.front(); dqmx.pop_front(); &#125; else &#123; pos = dqmi.front(); dqmi.pop_front(); &#125; &#125; ans = max(ans, x * (j - pos)); &#125; &#125; &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>牛客暑期多校训练营</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 1 1012 Sequence]]></title>
    <url>%2F2019%2F07%2F25%2F2019-Multi-University-Training-Contest-1-1012%2F</url>
    <content type="text"><![CDATA[2019 Multi-University Training Contest 1HDU 6589 Sequence果然不看大佬博客不会写题。顺手把板子也扒了。题解: x 只有 1 2 3三种情况。直接观察前缀.可以发现当 x=1 的时候 $c_1$表示 1出现的个数 a[i]=\sum_{j=0}^{i}C_{c_1-1+j}^{j} * a[i-j]预理出 $C[j]=C_{c_1-1+j}^{j}$上式就变成了 a[i]=\sum_{j=0}^{i}C[j] * a[i-j]是不是绝对上述这个式子非常眼熟，就是卷积中的一项。。。发现了这个，就是一个组合数加个NTT当x=2的时候就把数组分奇数项和偶数项求一个上式当x=3的时候就求3个实际上，只要改一下$c[j]$把按照x=1的求一下x=2c[j]=j%2==0&gt;c[j/2]:0x=3``c[j]=j%3==0?c[j/3]:0123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 998244353;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;const double PI = acos(-1);#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;int t;int n, m;LL a[maxn];int c[maxn];LL b[maxn];const int Comb_Maxn = 1e6 + 10;LL Fac_inv[Comb_Maxn];LL Fac[Comb_Maxn];inline void Comb_init() &#123; Fac_inv[0] = Fac[0] = 1; Fac_inv[1] = 1; for (int i = 1; i &lt; Comb_Maxn; i++) Fac[i] = Fac[i - 1] * (LL) i % mod; for (int i = 2; i &lt; Comb_Maxn; i++) Fac_inv[i] = (LL) (mod - mod / i) * Fac_inv[mod % i] % mod; for (int i = 1; i &lt; Comb_Maxn; i++) Fac_inv[i] = Fac_inv[i - 1] * Fac_inv[i] % mod;&#125;LL Comb(int n, int m) &#123; if (m &gt; n || m &lt; 0 || n &lt; 0)return 0; return Fac[n] * Fac_inv[m] % mod * Fac_inv[n - m] % mod;&#125;typedef LL ll;const int N = maxn;struct NumberTheoreticTransform &#123; int pow2(int x) &#123; int res = 1; while (res &lt; x) res &lt;&lt;= 1; return res; &#125; inline LL pow_mod(ll x, int n) &#123; ll res; for (res = 1; n; n &gt;&gt;= 1, x = x * x % mod) if (n &amp; 1) res = res * x % mod; return res; &#125; inline int add_mod(int x, int y) &#123; x += y; return x &gt;= mod ? x - mod : x; &#125; inline int sub_mod(int x, int y) &#123; x -= y; return x &lt; 0 ? x + mod : x; &#125; void NTT(LL a[], int n, int op) &#123; for (int i = 1, j = n &gt;&gt; 1; i &lt; n - 1; ++i) &#123; if (i &lt; j) swap(a[i], a[j]); int k = n &gt;&gt; 1; while (k &lt;= j) &#123; j -= k; k &gt;&gt;= 1; &#125; j += k; &#125; for (int len = 2; len &lt;= n; len &lt;&lt;= 1) &#123; LL g = pow_mod(3, (mod - 1) / len); for (int i = 0; i &lt; n; i += len) &#123; LL w = 1; for (int j = i; j &lt; i + (len &gt;&gt; 1); ++j) &#123; LL u = a[j], t = 1ll * a[j + (len &gt;&gt; 1)] * w % mod; a[j] = (u + t) % mod, a[j + (len &gt;&gt; 1)] = (u - t + mod) % mod; w = 1ll * w * g % mod; &#125; &#125; &#125; if (op == -1) &#123; reverse(a + 1, a + n); LL inv = pow_mod(n, mod - 2); for (int i = 0; i &lt; n; ++i) a[i] = 1ll * a[i] * inv % mod; &#125; &#125; void mul(LL A[], LL B[], int Asize, int Bsize) &#123; int n = pow2(Asize + Bsize - 1); for (int i = Asize; i &lt; n; ++i) A[i] = 0; for (int i = Bsize; i &lt; n; ++i) B[i] = 0; NTT(A, n, 1); NTT(B, n, 1); for (int i = 0; i &lt; n; ++i) &#123; A[i] = 1ll * A[i] * B[i] % mod; B[i] = 0; &#125; NTT(A, n, -1); return; &#125;&#125; ntt;template&lt;typename T&gt;void read(T &amp;w) &#123; //读入 char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar()))w = w * 10 + (c &amp; 15);&#125;int main() &#123; f(); read(t); Comb_init(); while (t--) &#123; read(n); read(m); for (int i = 0; i &lt; n; i++) &#123; read(a[i]); &#125; c[0] = c[1] = c[2] = c[3] = 0; while (m--) &#123; int x; scanf("%d", &amp;x); c[x]++; &#125; if (c[1] &gt; 0) &#123; for (int i = 0; i &lt; n; i++) &#123; b[i] = Comb(c[1] + i - 1, i); &#125; ntt.mul(a, b, n, n); &#125; if (c[2] &gt; 0) &#123; for (int i = 0; i &lt; n; i += 2) &#123; b[i] += Comb(c[2] + i / 2 - 1, i / 2); b[i + 1] = 0; &#125; ntt.mul(a, b, n, n); &#125; if (c[3] &gt; 0) &#123; for (int i = 0; i &lt; n; i += 3) &#123; b[i] = Comb(c[3] + i / 3 - 1, i / 3); &#125; ntt.mul(a, b, n, n); &#125; LL ans = 0; for (int i = 0; i &lt; n; i++) &#123; ans ^= (i + 1LL) * a[i]; &#125; printf("%lld\n", ans); &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>杭电多校</tag>
        <tag>FFT/NTT/FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 2 1012 Longest Subarray]]></title>
    <url>%2F2019%2F07%2F24%2F2019-Multi-University-Training-Contest-2-1012%2F</url>
    <content type="text"><![CDATA[Longest Subarray HDU 6602题意: n个数，求区间内 数的个数要么为0个要么大于等于k个的长度最长是多少。题解：解法一： 不完美算法，每次枚举计算区间内所有数的个数有多少个，如果没有数的个数小于k的就更新答案,如果有就把这几个数标记，然后这些数会把原本的数组分成几段，然后在这几段中继续求。理论上这种写法会超时，实际上就是超时了，所以我们把分的次数限定一下，如果分了超过30次就直接跳出。这样理论上没有把所有可能性跑到，但是这种数据很难得，所以只要没有专门卡这种数据就能过。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;int n, c, k;int a[maxn];int b[maxn];int pos = 0;int v[maxn];int ans = 0;int de[maxn];int dfs(int l, int r, int dep) &#123; if (dep &gt; 30)return 0; if (r &lt; l)return 0; if (r - l + 1 &lt; k)return 0; for (int i = l; i &lt;= r; i++) &#123; b[a[i]] = 0; &#125; pos = 0; for (int i = l; i &lt;= r; i++) &#123; if (b[a[i]] == 0) &#123; v[pos++] = a[i]; &#125; b[a[i]]++; &#125; int flag = 0; for (int i = 0; i &lt; pos; i++) &#123; if (b[v[i]] &gt;= k) &#123; b[v[i]] = 1; &#125; else &#123; b[v[i]] = 0; flag = 1; &#125; &#125; for (int i = l; i &lt;= r; i++) &#123; if (b[a[i]] == 0)de[i] = 0; else de[i] = 1; &#125; if (flag == 0) &#123; ans = max(ans, r - l + 1); return 0; &#125; int L = -1, R = -1; for (int i = l; i &lt;= r; i++) &#123; if (de[i] &amp;&amp; L == -1) &#123; L = i; &#125; if (de[i] == 0 &amp;&amp; L != -1) &#123; R = i - 1; dfs(L, R, dep + 1); L = -1; &#125; &#125; if (L != -1 &amp;&amp; L &lt;= r) &#123; dfs(L, r, dep + 1); &#125;&#125;int main() &#123; f(); while (~scanf("%d%d%d", &amp;n, &amp;c, &amp;k)) &#123; ans = 0; for (int i = 1; i &lt;= n; i++)scanf("%d", &amp;a[i]); dfs(1, n, 0); printf("%d\n", ans); &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125; 题解二： 枚举区间r,线段树查找最小的l。能够选的位置一定是分成两段。然后把从 r到l 少于k个数字不合法 区间 -1，变成合法的时候+1，大于等于0的区间中最小下标就是答案。假设，k=3每个数字一定是这样，举个例子k=21 4 1 4 2 1 1首先到 r=1 a[r]=1 ,没有超过 k个, 把 最开始到 r 全部减 1 -1查询 [1,r] 没有大于等于0的位置，不更新答案r=2 a[r]=4 ,个数少于 k,[1,r] -1 -2 -1[1,r] 没有大于0 的位置 ,不更新r=3 a[r]=1 ,大于等于 k 个，把当前位置和前面a[r]位置之间 -1, 也就是 [2,3] -1 ,然后超过k个的位置 [1,1] +1-1 -2 -1还是没有0的位置 不更新r=4 a[r]=4，同上[3,4] -1 ，[1,2] +10 -1 -2 -1最小0位置为1 pos=1 更新答案 ans=max(ans,r-pos+1)后面依次类推123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;int n, c, k;int a[maxn];int ans = 0;int last[maxn];int b[maxn];int dat[maxn &lt;&lt; 2];int lazy[maxn &lt;&lt; 2];int lastk[maxn], pre[maxn], nxt[maxn];void build(int l, int r, int k) &#123; if (r == l) &#123; dat[k] = 0; lazy[k] = 0; &#125; else &#123; build(lson); build(rson); dat[k] = 0; lazy[k] = 0; &#125;&#125;void push_down(int l, int r, int k) &#123; if (r == l)dat[k] += lazy[k]; else &#123; lazy[chl] += lazy[k]; lazy[chr] += lazy[k]; &#125; lazy[k] = 0; if (r != l)dat[k] = max(dat[chl] + lazy[chl], dat[chr] + lazy[chr]);&#125;void update(int A, int B, int l, int r, int k, int x) &#123;// if (k == 0) &#123;// printf("[%d,%d] %d\n", A, B, x);// &#125; push_down(l, r, k); if (A &gt; r || B &lt; l)return; else if (A &lt;= l &amp;&amp; r &lt;= B) &#123; lazy[k] += x; &#125; else &#123; update(A, B, lson, x); update(A, B, rson, x); dat[k] = max(dat[chl] + lazy[chl], dat[chr] + lazy[chr]); &#125;&#125;int query(int A, int B, int l, int r, int k) &#123; push_down(l, r, k); if (A &gt; r || B &lt; l || dat[k] &lt; 0)return inf; else if (r == l &amp;&amp; A &lt;= l &amp;&amp; r &lt;= B) &#123; return l; &#125; else &#123; if (B &lt;= mid || dat[chl] + lazy[chl] &gt;= 0) &#123; return query(A, B, lson); &#125; else return query(A, B, rson); &#125;&#125;int queryval(int A, int B, int l, int r, int k) &#123; push_down(l, r, k); if (A &gt; r || B &lt; l)return -inf; else if (A &lt;= l &amp;&amp; r &lt;= B) &#123; return dat[k]; &#125; else &#123; return max(queryval(A, B, lson), queryval(A, B, rson)); &#125;&#125;int main() &#123; f(); while (~scanf("%d%d%d", &amp;n, &amp;c, &amp;k)) &#123; ans = 0; build(1, n, 0); for (int i = 0; i &lt;= c; i++)b[i] = last[i] = lastk[i] = pre[i] = nxt[i] = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); nxt[last[a[i]]] = i; pre[i] = last[a[i]]; if (b[a[i]] + 1 &gt;= k) &#123; update(pre[i] + 1, i, 1, n, 0, -1); update(pre[lastk[a[i]]] + 1, lastk[a[i]], 1, n, 0, 1); lastk[a[i]] = nxt[lastk[a[i]]]; &#125; else if (b[a[i]] == 0) &#123; update(1, i, 1, n, 0, -1); lastk[a[i]] = i; pre[i] = 0; &#125; else if (b[a[i]] + 1 &lt; k) &#123; update(last[a[i]] + 1, i, 1, n, 0, -1); &#125; last[a[i]] = i; ans = max(ans, i - query(1, i, 1, n, 0) + 1); b[a[i]]++; &#125; if (k == 1)ans = n; else if (k == 0)ans = 0; printf("%d\n", ans); &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>杭电多校</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营（第二场）J Subarray]]></title>
    <url>%2F2019%2F07%2F23%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5(%E7%AC%AC%E4%BA%8C%E5%9C%BA)J%2F</url>
    <content type="text"><![CDATA[2019牛客暑期多校训练营（第二场）J Subarray题意：长度为$1e9$的区间$A$下标为$[0,1e9-1]$,数输入$n$个区间，$[l_i,r_i]$区间类的值为1，其余为-1，问有多少区间和大于0.题解：看了来自大佬的博客，能够产生贡献的点最多只有$3e7$个,意思是先求一个前缀和，然后画成图应该是这样。最差就是这样了，能够有影响的就只有这$3e7$个点 (可能是分段的) ，那么问题来了，怎么求出这$3e7$个点。来自大佬的博客为什么呢？在大佬眼里很简单，我画了个图才理解。显然前面一个的$f[i]$加后面$g[i+1]$比两个区间之间的长度大就事连在一起的。(我果然太菜了)然后处理完之后，就相当于处理一个这样的前缀和，求所有位置有几个在他前面前缀比他小。如果范围小一点就用树状数组求一下就没了，$3e7log(3e7)$显然超时了。看到这个前缀和，前后项最大只差了$1$,上下界最大差值不超过$3e7$,这再做个前缀和 sum 。用一个数组表示一个数字出现的次数，然后$sum[m]=sum[m-1]+b[m]$,更新前缀和,答案就是$ans+=sum[m-1]$。中间有一些细节要处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;typedef long double ld;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;(x)&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define mem(a, b) memset(a,b,sizeof(a));const long long mod = 1e9 + 7;const int maxn = 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;void fin() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif // ONLINE_JUDGE&#125;#ifndef ONLINE_JUDGEclock_t start = clock();#endif // ONLINE_JUDGEint n;LL l[maxn], r[maxn];LL f[maxn], g[maxn];struct node &#123; LL l, r, x;&#125; dat[maxn * 5];LL sum[maxn * 30 + 20], b[maxn * 30 + 20];int main() &#123; fin(); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%lld%lld", &amp;l[i], &amp;r[i]); &#125; f[1] = r[1] - l[1] + 1; for (int i = 2; i &lt;= n; i++) &#123; f[i] = max(0LL, f[i - 1] - (l[i] - r[i - 1] - 1)) + r[i] - l[i] + 1; &#125; g[n] = r[n] - l[n] + 1; for (int i = n - 1; i &gt;= 1; --i) &#123; g[i] = max(0LL, g[i + 1] - (l[i + 1] - r[i] - 1)) + r[i] - l[i] + 1; &#125; int i = 1; LL ans = 0; while (i &lt;= n) &#123; int j = i + 1; LL mi = 0, mx = 0, pos = 0; //mi 下界,mx 上界 while (j &lt;= n &amp;&amp; g[j] + f[j - 1] &gt;= l[j] - r[j - 1] - 1) &#123; j++; &#125; j--; int t = i, num = 1; // [i,j] 区间是相互影响的 for (; t &lt;= j; t++) &#123; // 把每一段处理到 dat里面 if (num == 1)dat[num].l = 0; else if (l[t] - r[t - 1] == 1) dat[num].l = pos + 1; else dat[num].l = pos; pos += r[t] - l[t] + 1; dat[num].r = pos; dat[num++].x = 1; mx = max(mx, pos); if (t != j) &#123; dat[num].r = pos - 1; pos -= l[t + 1] - r[t] - 1; dat[num].l = pos + 1; dat[num++].x = 0; // 0 表示下降 ,1 表示上升 mi = min(pos, mi); &#125; else &#123; dat[num].r = pos - 1; dat[num].l = max(mi, pos - ((int) 1e9 - 1 - r[t])); dat[num++].x = 0; &#125; &#125; dat[0].r = min(mx, l[i]); dat[0].l = 1; dat[0].x = 0; for (int k = 0; k &lt;= mx - mi + 200; k++)b[k] = sum[k] = 0; assert(mx - mi &lt; maxn * 30); for (int k = 0; k &lt; num; ++k) &#123; dat[k].l += -mi; //全部向上移动一个下届，保证最小值等于0 dat[k].r += -mi; if (dat[k].x == 1) &#123; for (int m = dat[k].l; m &lt;= dat[k].r; ++m) &#123; b[m]++; sum[m] = sum[m - 1] + b[m]; if (m &gt;= 1)ans += sum[m - 1]; &#125; &#125; else &#123; LL tmp = 0; if (dat[k].l &gt; 0)tmp = sum[dat[k].l - 1]; for (int m = dat[k].l; m &lt;= dat[k].r; ++m) &#123; if (m &gt;= 1)ans += tmp; tmp = sum[m]; //如果是下降的 ，从小往上处理是不能把当前更新加进去因当前这个在他后面 b[m]++; sum[m] = sum[m - 1] + b[m]; &#125; &#125; &#125; i = j + 1; &#125; printf("%lld\n", ans);#ifndef ONLINE_JUDGE cout &lt;&lt; "RUNTIME:" &lt;&lt; (1.0 * clock() - start) / 1000 &lt;&lt; "ms" &lt;&lt; endl;#endif // ONLINE_JUDGE return 0;&#125; 给几组数据你去试试 1234567891011121314151625 912 1733 56 67 933 58 89 101999999998 999999999 123456720076494]]></content>
      <categories>
        <category>ACM</category>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>牛客暑期多校训练营</tag>
        <tag>巧解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NTT快速数论变换]]></title>
    <url>%2F2019%2F07%2F22%2FNTT%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[NTT理解了FFT的原理，NTT也差不多。FTT是用复数实现变换，而NTT是用取模意义实现。找出一个g,和开一个模数p,g是p的原根。 原根 $0&lt;i&lt;P,0&lt;j&lt;P,1&lt;g&lt;P\ g^i(mod\ p)\ne g^j(mod\ p)$ 这样在FTT里面的$w_n^1\equiv g^{\frac{p-1}{n}}$。显然:$(g^\frac{p-1}{n})^n=g^{p-1}=1(mod\ p)$$g^\frac{p-1}{n} * g^\frac{p-1}{n} = g^{2\frac{p-1}{n}}$同样的 FFT 里面用到的几个原根性质，他都有。你可以抽象为，把一个长度为 P 线段，每次走一格，走了N次回来了。 所以一开始要求的几个点值是$\{A(1),A(g^{\frac{p-1}{n}}),\cdots,A(g^{\frac {p-1}{n}{n-1}})\}$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//ntt#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int N=(1&lt;&lt;18)+5, INF=1e9;const double PI=acos(-1);inline int read()&#123; char c=getchar();int x=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125; ll P=1004535809;ll Pow(ll a, ll b,ll P) &#123; ll ans=1; for(; b; b&gt;&gt;=1, a=a*a%P) if(b&amp;1) ans=ans*a%P; return ans;&#125;struct NumberTheoreticTransform &#123; int pow2(int x) &#123; int res = 1; while (res &lt; x) res &lt;&lt;= 1; return res; &#125; inline LL pow_mod(ll x, int n) &#123; ll res; for (res = 1; n; n &gt;&gt;= 1, x = x * x % mod) if (n &amp; 1) res = res * x % mod; return res; &#125; inline int add_mod(int x, int y) &#123; x += y; return x &gt;= mod ? x - mod : x; &#125; inline int sub_mod(int x, int y) &#123; x -= y; return x &lt; 0 ? x + mod : x; &#125; void NTT(LL a[], int n, int op) &#123; for (int i = 1, j = n &gt;&gt; 1; i &lt; n - 1; ++i) &#123; if (i &lt; j) swap(a[i], a[j]); int k = n &gt;&gt; 1; while (k &lt;= j) &#123; j -= k; k &gt;&gt;= 1; &#125; j += k; &#125; for (int len = 2; len &lt;= n; len &lt;&lt;= 1) &#123; LL g = pow_mod(3, (mod - 1) / len); for (int i = 0; i &lt; n; i += len) &#123; LL w = 1; for (int j = i; j &lt; i + (len &gt;&gt; 1); ++j) &#123; LL u = a[j], t = 1ll * a[j + (len &gt;&gt; 1)] * w % mod; a[j] = (u + t) % mod, a[j + (len &gt;&gt; 1)] = (u - t + mod) % mod; w = 1ll * w * g % mod; &#125; &#125; &#125; if (op == -1) &#123; reverse(a + 1, a + n); LL inv = pow_mod(n, mod - 2); for (int i = 0; i &lt; n; ++i) a[i] = 1ll * a[i] * inv % mod; &#125; &#125; void mul(LL A[], LL B[], int Asize, int Bsize) &#123; int n = pow2(Asize + Bsize - 1); for (int i = Asize; i &lt; n; ++i) A[i] = 0; for (int i = Bsize; i &lt; n; ++i) B[i] = 0; NTT(A, n, 1); NTT(B, n, 1); for (int i = 0; i &lt; n; ++i) &#123; A[i] = 1ll * A[i] * B[i] % mod; B[i] = 0; &#125; NTT(A, n, -1); return; &#125;&#125; f; int n1, n2, m, c[N];ll a[N], b[N];char s1[N], s2[N];int main() &#123; //freopen("in","r",stdin); scanf("%s%s",s1,s2); n1=strlen(s1); n2=strlen(s2); for(int i=0; i&lt;n1; i++) a[i] = s1[n1-i-1]-'0'; for(int i=0; i&lt;n2; i++) b[i] = s2[n2-i-1]-'0'; m=n1+n2-1; f.mul(a, b, m); for(int i=0; i&lt;m; i++) c[i]=a[i]; for(int i=0; i&lt;m; i++) c[i+1]+=c[i]/10, c[i]%=10; if(c[m]) m++; for(int i=m-1; i&gt;=0; i--) printf("%d",c[i]);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>FFT/NTT/FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFT快速傅里叶变换简解]]></title>
    <url>%2F2019%2F07%2F20%2FFFT%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E7%AE%80%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[概述FTT： 快速傅里叶变换。看起来挺难的，实际上确实挺难的。 用途A=a_0+a_1x+a_2x\cdots +a_nx^nB=b_0+b_1x+b_2x\cdots +b_nx^n求 C_k=\sum_{i+j=k}A_i * B_j也就是上面两个多项式相乘等于下面这个 C=c_0+c_1x+c_2x\cdots +c_{2n}x^{2n}朴素算法一个个乘 $O(n^2)$ 复杂度，FFT能在 $O(nlog(n)$ 的复杂度内解决。 点值这个是多项式 系数表达 A=a_0+a_1x+a_2x\cdots +a_nx^n下面这个是 点值表示法 \{ (x_0,y_0) , (x_1,y_1) , \cdots (x_n,y_n) \}不难看出能用下面这个n+1个不同的点值推出 系数表达式 FFT步骤 加倍次数界求值 将转A B系数表达式，找出 2n+1 个点值,(只需要n+1个点值就能推出一个最高次项为n的表达式，但是，A B相乘后有2n，所以要找出2n+1个值) 逐点相乘 将两个点值相乘获得C 的点值C=\{(x_0 ,A(x_0) * B(x_0)),\cdots,(x_{2n},A(x_{2n}) * B(x_{2n})\} 插值 再用逆变换将C的点值转换成 系数表达式 第一步叫离散傅里叶变换 (DFT) 正式讲解不难看出,如果直接用朴素算法，去求多项式乘积，第一步复杂度 $O(n^2)$,第二步$O(n)$，第三步$O(n^2)$FFT 作用就是优化第一步和第三步，都变成$O(nlog(n))$的复杂度。 在这之前需要知道一个东西叫单位复根 单位复根不具体讲了,讲了你也理解不了。 (其实我没理解)想要具体了解见黑书算法导论P532，我只做简介n次单位复根，$w^n=1$，这个数有恰好n个，具体是啥不重要，我说个简单的理解。复数大家都知道吧。假设有两个复数$z1=a+bi$$z2=c+di$把他们两个乘一下 z2z1=(ac-bd)+(ad+bc)i求一下$z1 z2$他们的长度和角，先求长度 [z1]=\sqrt{a^2+b^2}[z2]=\sqrt{b^2+c^2}[z1z2]=\sqrt{(ac-bd)^2+(ad+bc)^2}=\sqrt{a^2c^2+b^2d^2+a^2d^2+b^2c^2}=\sqrt{(a^2+b^2)(b^2+d^2)}是不是就等于$[z1] * [z2]$然后你代一个数放z1 z2里面 z1=cos(\alpha)+sin(\alpha)iz2=cos(\beta)+sin(\beta) i\begin{aligned} z1z2&=(cos(\alpha) cos(\beta)-sin(\alpha)sin(\beta))+(cos(\alpha)sin(\beta)+sin(\alpha)cos(\beta))i\\ &=cos(\alpha+\beta)+sin(\alpha+\beta)i \end{aligned}看到这应该懂了，复数的乘法性质。 (a_0,\theta_0) * (a_1,\theta_1)=(a_1 * a_0,\theta_0\theta_1)可能你还不知道这意味着啥，但是马上你就懂了假设一个复数，长度为1，角度为\frac{2\pi}{n}，$w_n^1=cos(\frac{2\pi}{n})+sin(\frac{2\pi}n{})i$把他画成成圆就是那么w_n^2=w_n^1 * w_n^1 就相当于在圆上转了一下如下图看到这，后面理解性质就贼简单，你全部想象成在圆上面旋转。但是这些都不重要接下来给你退公式了,假设 A有最高次项为 n-1 \begin{aligned} A&=a_0+a_1x+a_2x^2+\cdots+a_{n-1}x^{n-1}\\ &=(a_0+a_2x^2+\cdots+a_{n-2}x^{n-2})+x(a_1+a_3x^2+\cdots+a_{n-1}x^{n-2}) \end{aligned}可以发现前面一堆和后面一堆很像然后设这$A0 A1$ A0=a_0+a_2x+a_4x^2+\cdots+a_{n-2}x^{n-1}\\ A1=a_1+a_3x+a_5x^2+\cdots+a_{n-1}x^{n-1}这个地方注意，A0,A1 里面的次项是开根号所以是 A=A0(x^2)+xA1(x^2)假设你代入的是一个普通的数，假设是 \{1,x_0,\cdots,x_{n-1}\}，$A(X)=A0(X^2)+xA1(X^2)$ 你还需要求\{A0(1),A0(x_0^2),\cdots,A0(x_{n-1}^2),A1(1),A1(x_0^2),\cdots,A1(x_{n-1}^2)\} ,一共是2n个，两边同时求还是$O(n)$.当你带入复数 \{1,w_n^1,\cdots,w_n^{n-1}\},你可以发现一个神奇的事，要求的数量变少了 \begin{aligned} A&=A0((w_n^k)^2)+w_n^kA1((w_n^k)^2)\\ &=A0(w_n^{2k})+w_n^kA1(w_n^{2k})\\ &=A0(w_{\frac{n}{2}}^k)+w_n^kA1(w_{\frac{n}{2}}^k) \end{aligned}上述公式化简用上了一个公式 w_n^k=w_{\frac{n}{2}}^{\frac{k}{2}} 这个事很显然的事，在单位圆里面，改变这个比例，角度不变 你需要求的数就变成了\{1,w_{\frac{n}{2}}^1,\cdots,w_\frac{n}{2}^{n-1}\}看上去没有减少，实际上你可以发现，其中有一半其实是重复的，这又要立用到一个公式 $w_n^k=w_n^{k+n}$ 很显然，圆转了一圈，我又回来啦 所以就变成了求\{1,w_{\frac{n}{2}}^1,\cdots,w_\frac{n}{2}^{\frac{n-2}{2}}\}举个栗子 解释一下假设 一个 A长度为4 最高次项就是 3 A=a_0+a_1x+a_2x^2+a_3^3x^3求 4 个 点值 \{\{1,A(1)\},\{w_4^1,A(w_4^1)\},\{w_4^2,A(w_4^2)\},\{w_4^3,A(w_4^3)\}\}一开始要求的有 4 个点值 \{A(1),A(w_4^1),A(w_4^2),A(w_4^3)\}通过前面那个转换, 看不懂为啥有个1的 ，注意 $w_n^0=1$ \begin{aligned} A(1)&=A0(1)+1A1(1)\\ A(w_4^1)&=A0(w_2^1)+w_4^1A1(w_2^1)\\ A(w_4^2)&=A0(w_2^2)+w_4^2A1(w_2^2)=A0(1)+w_4^2A1(1)\\ A(w_4^3)&=A0(w_2^3)+w_4^3A1(w_2^3)=A0(w_2^1)+w_4^3A1(w_2^1) \end{aligned}要求的点值就变成了$\{A0(1),A0(w_2^1),A1(1),A1(w_2^1)\}$ 同样是4个， 但是递归下去找每次分成两部分，就相当于折半了，(还是没有理解等会画个图给你看下) 另外还没完，上述还有一个特点: 前面一半和后面一半 很像，没错，还可以优化。这个地方又要用到一个性质. $w_n^{k+\frac{n}{2}}=-w_n^{k}$ 很显然,你在圆里面转了半圈，不就是个相反的了么。。。。 感觉我的证明都是显然证明法,不用在意这些细节由此可以再优化当$k&lt;\frac{n}{2}$ A(w_n^k)=A0(w_{\frac{n}{2}}^k)+w_n^kA1(w_{\frac{n}{2}}^k)当$k&gt;\frac{n}{2}$ A(w_n^k)=A0(w_{\frac{n}{2}}^k)-w_n^{k-\frac{n}{2}}A1(w_{\frac{n}{2}}^k)网上很多写的是A(w_n^{k+\frac{n}{2}})=A0(w_{\frac{n}{2}}^k)-w_n^{k}A1(w_{\frac{n}{2}}^k)，其实是一个意思，哪个好理解你看哪个吧。例子A(w_4^3)=A0(w_2^1)-w_4^1A1(w_2^1)对应上面举得那个具体的例子，你就可以再次优化了。 这个地方看不懂推荐一篇神级大佬的博客 从多项式乘法到快速傅里叶变换 最后再画个图助解一下: 至此算法核心原理全部解释完毕。逆运算从点值 转换成系数表达式 ，你把矩阵写出来，就相当于乘了一个逆矩阵。就相当于再求一次DFT ，只不过 $w_n^k$ 变成他的逆，w_n^k * w_n^{-k}=1，加个负号就行了。代码网上一大堆我这里贴个我的，测试题目51Nod 大数乘法2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;const double eps = 0.5;const double pi = acos(-1.0);struct complexx &#123; double x, y; complexx(double xx = 0, double yy = 0) &#123; x = xx, y = yy; &#125; void put() &#123; printf("[x=%f y=%f]\n", x, y); &#125;&#125; a[maxn], b[maxn];complexx operator+(complexx a, complexx b) &#123; return complexx(a.x + b.x, a.y + b.y); &#125;complexx operator-(complexx a, complexx b) &#123; return complexx(a.x - b.x, a.y - b.y); &#125;complexx operator*(complexx a, complexx b) &#123; return complexx(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y); &#125;void fft(int len, complexx *a, int o) &#123; if (len == 1) return; complexx a0[(len &gt;&gt; 1) + 3], a1[(len &gt;&gt; 1) + 3]; for (int i = 0; i &lt;= len; i += 2) a0[i &gt;&gt; 1] = a[i], a1[i &gt;&gt; 1] = a[i + 1]; fft(len &gt;&gt; 1, a0, o); fft(len &gt;&gt; 1, a1, o); complexx wn = complexx(cos(2 * pi / len), o * sin(2 * pi / len)), w0 = complexx(1, 0); for (int i = 0; i &lt; (len &gt;&gt; 1); i++, w0 = w0 * wn) &#123; a[i] = a0[i] + w0 * a1[i];// a[i + (len &gt;&gt; 1)] = a0[i] - w0 * a1[i]; //前面说的一个优化 &#125; //不加优化继续跑下去，直接枚举所有 for (int i = (len &gt;&gt; 1); i &lt; len; i++, w0 = w0 * wn) &#123; a[i] = a0[i - (len &gt;&gt; 1)] + w0 * a1[i - (len &gt;&gt; 1)]; &#125;&#125;char s[maxn];int ans[maxn];int main() &#123; f(); scanf("%s", s); int la = strlen(s); for (int i = la - 1; i &gt;= 0; i--)a[i].x = s[la - i - 1] - '0'; scanf("%s", s); int lb = strlen(s); for (int i = lb - 1; i &gt;= 0; i--)b[i].x = s[lb - i - 1] - '0'; int m = la + lb - 2; int len = 1; for (; len &lt;= m; len &lt;&lt;= 1); fft(len, a, 1);//DFT fft(len, b, 1);//DFT for (int i = 0; i &lt;= len; i++) a[i] = a[i] * b[i]; fft(len, a, -1);//IDFT for (int i = 0; i &lt;= m; i++) &#123; ans[i] = (int) (a[i].x / len + eps);//记得除len eps 用来消 浮点误差我用的 0.5 &#125; for (int i = 0; i &lt;= m; i++)ans[i + 1] += ans[i] / 10, ans[i] = ans[i] % 10; if (ans[m + 1])printf("%d", ans[m + 1]); for (int i = m; i &gt;= 0; i--) &#123; printf("%d", ans[i]); &#125; puts("");#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125; 你以为大结局了吗?没有 优化除了前面那个直接再表达式上的优化,，下面还有代码上的优化。递归太慢了，可以换成迭代。另外，这空间变成了nlog(n) ，那个辅助数组优化掉也可以不好.已经理解核心了，后面这个就不用我说了吧。。。。。。是我懒得写了，我18岁我好累 直接贴一个大哥的板子把，找的太多了都不知道是谁的了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//fft#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int N=(1&lt;&lt;18)+5, INF=1e9;const double PI=acos(-1);inline int read()&#123; char c=getchar();int x=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125; struct meow&#123; double x, y; meow(double a=0, double b=0):x(a), y(b)&#123;&#125;&#125;;meow operator +(meow a, meow b) &#123;return meow(a.x+b.x, a.y+b.y);&#125;meow operator -(meow a, meow b) &#123;return meow(a.x-b.x, a.y-b.y);&#125;meow operator *(meow a, meow b) &#123;return meow(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);&#125;meow conj(meow a) &#123;return meow(a.x, -a.y);&#125;typedef meow cd; struct FastFourierTransform &#123; int n, rev[N]; cd omega[N], omegaInv[N]; void ini(int lim) &#123; n=1; int k=0; while(n&lt;lim) n&lt;&lt;=1, k++; for(int i=0; i&lt;n; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1) | ((i&amp;1)&lt;&lt;(k-1)); for(int k=0; k&lt;n; k++) &#123; omega[k] = cd(cos(2*PI/n*k), sin(2*PI/n*k)); omegaInv[k] = conj(omega[k]); &#125; &#125; void fft(cd *a, cd *w) &#123; for(int i=0; i&lt;n; i++) if(i&lt;rev[i]) swap(a[i], a[rev[i]]); for(int l=2; l&lt;=n; l&lt;&lt;=1) &#123; int m=l&gt;&gt;1; for(cd *p=a; p!=a+n; p+=l) for(int k=0; k&lt;m; k++) &#123; cd t = w[n/l*k] * p[k+m]; p[k+m]=p[k]-t; p[k]=p[k]+t; &#125; &#125; &#125; void dft(cd *a, int flag) &#123; if(flag==1) fft(a, omega); else &#123; fft(a, omegaInv); for(int i=0; i&lt;n; i++) a[i].x/=n; &#125; &#125; void mul(cd *a, cd *b, int m) &#123; ini(m); dft(a, 1); dft(b, 1); for(int i=0; i&lt;n; i++) a[i]=a[i]*b[i]; dft(a, -1); &#125;&#125;f; int n1, n2, m, c[N];cd a[N], b[N];char s1[N], s2[N];int main() &#123; //freopen("in","r",stdin); scanf("%s%s",s1,s2); n1=strlen(s1); n2=strlen(s2); for(int i=0; i&lt;n1; i++) a[i].x = s1[n1-i-1]-'0'; for(int i=0; i&lt;n2; i++) b[i].x = s2[n2-i-1]-'0'; m=n1+n2-1; f.mul(a, b, m); for(int i=0; i&lt;m; i++) c[i]=floor(a[i].x+0.5); for(int i=0; i&lt;m; i++) c[i+1]+=c[i]/10, c[i]%=10; if(c[m]) m++; for(int i=m-1; i&gt;=0; i--) printf("%d",c[i]);&#125; 如有错误，望指出。]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>FFT/NTT/FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营（第二场）F MAZE]]></title>
    <url>%2F2019%2F07%2F20%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5(%E7%AC%AC%E4%BA%8C%E5%9C%BA)F%2F</url>
    <content type="text"><![CDATA[2019牛客暑期多校训练营（第二场）F MAZE世界上有种算法不叫做算法，那就是暴力。。。。 C_{2n}^n 是$4e7$，总状态是$4e7$种，然后转移,$O(n)$直接向相邻的状态转移。总复杂度$O(C_{2n}^{n} * n)$。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;(x)&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("dat.in", "r", stdin);#endif // ONLINE_JUDGE&#125;#ifndef ONLINE_JUDGEclock_t start=clock();#endif // ONLINE_JUDGEint n,m;int mp[30][30];LL sum,ans;int ar[15],br[15]; //a b 个表示一个集合int la,lb;void dfs(int num) &#123; //选n位 if(la&gt;n||lb&gt;n)return ; if(la==n&amp;&amp;lb==n) &#123; //如果各选了 n 位就更新答案 ans=max(sum,ans); return ; &#125; else &#123; if(la&lt;n) &#123; LL tmp=0; for(int i=0; i&lt;lb; i++) &#123; //选到 a 集合 tmp+=mp[num][br[i]]; &#125; sum+=tmp; ar[la++]=num; dfs(num+1); ar[--la]; sum-=tmp; &#125; if(lb&lt;n) &#123; LL tmp=0; for(int i=0; i&lt;la; i++) &#123; //选到 b 集合 tmp+=mp[num][ar[i]]; &#125; sum+=tmp; br[lb++]=num; dfs(num+1); br[lb--]; sum-=tmp; &#125; &#125;&#125;int main() &#123; f(); scanf("%d", &amp;n); m = 2 * n; for(int i = 0; i &lt; m; ++i) &#123; for(int j = 0; j &lt; m; ++j) &#123; scanf("%d", &amp;mp[i][j]); &#125; &#125; dfs(0); printf("%lld\n",ans);#ifndef ONLINE_JUDGE debug((1.0*(clock()-start)/1000));#endif // ONLINE_JUDGE return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>牛客暑期多校训练营</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第一场) C Euclidean Distance]]></title>
    <url>%2F2019%2F07%2F19%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%B8%80%E5%9C%BA%EF%BC%89C%2F</url>
    <content type="text"><![CDATA[2019牛客暑期多校训练营（第一场）C Euclidean Distance题解: 拉格朗日乘子法，首先引入拉格朗日乘子得出公式 f(x)=\sum_{i=1}^{n}(p_i-a_i)^2+2*\lambda(\sum_{i=0}^{n}p_i-1)这个应该看的懂，然后引入对偶变成成\max_\lambda f(\lambda)其中 f(\lambda)=\min_{p_i\geq0}\sum_{i=1}^{n}(p_i-a_i)^2+2*\lambda(\sum_{i=0}^{n}p_i-1)然后化成叉姐给的题解里面的公式就行了 f(\lambda)=\min_{p_i\geq0}\sum_{i=1}^{n}(p_i-(a_i-\lambda))^2+\lambda(\sum_{i=0}^{n}(a_i^2-(a_i-\lambda)^2)-2\lambda再然后，我就不会了qaq后来看了一下别的大佬的博客，突然感觉可以直接理解一下，假设所有的$p_i=0$,$f(x)$就等于$a_i^2$的和 题目要求的是 在 q_i\geq0,\quad \sum_{i=0}^{n}q_i=1条件下求 $f(x)=\sum_{i=1}^{n}(p_i-a_i)^2$ 。相当于分配$p_i$ 的值，去让 $(p_i-a_i)^2$ 变小。根据二次函数的性质，自变量 $x$ 越大因变量 $y$ 化越快。所以先分配给最大肯定更优啊，直接贪心下去啊。最后肯定是变成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("dat.in", "r", stdin);#endif // ONLIN_JUDGE&#125;LL a[maxn];int n;LL m;int main() &#123; while(~scanf("%d%lld",&amp;n,&amp;m)) &#123; for(int i=1; i&lt;=n; i++) &#123; scanf("%lld",&amp;a[i]); &#125; sort(a+1,a+n+1,greater&lt;int&gt;()); LL r=m; //p[i]的总分配价值是 1 也就是 m/m LL pos=1; // pos 标记能够分配p[i] 到第 pos 个 while(pos&lt;n) &#123; if(r&lt;(a[pos]-a[pos+1])*pos)break; r-=(a[pos]-a[pos+1])*pos; pos++; &#125; // 最终前pos个的值 都会是a[pos]-r/pos,将他扩大pos 倍, 然后再乘以 pos 个 LL ans=(a[pos]*pos-r)*(a[pos]*pos-r)*pos; //因为最后的值可能是 1/pos,所以把分子分母同时乘以pos个 LL b=m*m*pos*pos; // 因为求的是距离的平方 分母 就是 m*m*pos*pos for(int i=pos+1; i&lt;=n; i++) &#123; //分配不到的 a[i]，直接加上 ans+=a[i]*a[i]*pos*pos; &#125; LL g=__gcd(ans,b); if(ans%b==0)printf("%lld\n",ans/b); else printf("%lld/%lld\n",ans/g,b/g); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>牛客暑期多校训练营</tag>
        <tag>拉格朗日</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexoNext主题插入数学公式]]></title>
    <url>%2F2019%2F07%2F17%2FhexoNext%E4%B8%BB%E9%A2%98%E6%8F%92%E5%85%A5%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[开启mathjax先把这个打开，然后看到mathjax上面这一行了没有，要用hexo-rendering-pandoc 或者hexo-renderer-kramed这个渲染，第一个我试的时候发现和hexo-renderer-marked这个语法有点出入 (hexo默认使用 hexo-renderer-marked 渲染) ，如果换了前面写所有md文件的全都要改语法，所以我就用了第二个,先把hexo-renderer-marked的卸了，再装hexo-renderer-kramed。12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 用数学公式的时候记得打开 测试代码如下12345678$$P = \frac&#123;\sum_&#123;i=1&#125;^n (x_i- x)(y_i- y)&#125;&#123;\displaystyle \left[\sum_&#123;i=1&#125;^n (x_i-x)^2\sum_&#123;i=1&#125;^n (y_i-y)^2\right]^&#123;1/2&#125; &#125;$$ 效果如下: P = \frac {\sum_{i=1}^n (x_i- x)(y_i- y)} {\displaystyle \left[ \sum_{i=1}^n (x_i-x)^2 \sum_{i=1}^n (y_i-y)^2 \right]^{1/2} } HexoEditor 展示数学公式如果你用这个编辑器，想实时展示这个效果就打开TeX数学表达式。效果如下：]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HexoNext添加网易云音乐]]></title>
    <url>%2F2019%2F07%2F17%2FHexoNext%E6%B7%BB%E5%8A%A0%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%2F</url>
    <content type="text"><![CDATA[添加网易云音乐生成外链 修改模板文件就是这个themes\next\layout\_macro\sidebar.swig自己找个位置复制粘贴进去我是放在那个最下面]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HexoNext添加gitment评论]]></title>
    <url>%2F2019%2F07%2F17%2FHexoNext%E6%B7%BB%E5%8A%A0gitment%E8%AF%84%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[添加gitment评论区安装gitment1npm install gitment --save #安装gitment 创建应用再创建一个 OAuth application1234Application name:随便写Homepage URL:这个也可以随意写,就写你的博客地址就行Application description:描述,也可以随意写Authorization callback URL:这个必须写你的博客地址 申请好之后点注册,然后就可以看到两个东西ClientID和Client Secret,后面会用到. 创建完后这个等会要用上 配置123456789101112131415# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/gitment: enable: true mint: false # 如果要修改gitment.swig地址就改成false RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide &apos;Powered by ...&apos; on footer, and more language: # Force language, or auto switch by theme github_user: &#123;you github user id&#125; github_repo: 随便写一个你的公开的git仓库就行,到时候评论会作为那个项目的issue client_id: &#123;刚才申请的ClientID&#125; client_secret: &#123;刚才申请的Client Secret&#125; proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled 然后在 主题配置文件next config.yml中开启gitment因为某个服务器挂了，所以mint要为false才会执行你所修改的。 错误： object ProgressEventc 错误就是上面这个原因，把mint改成法false即可。 找到themes/next/layout/_third-party/comments/gitment.swig文件修改其中的css 和js ,注释掉的是一开始默认的，现在改成下方没有注释的。 (后面这个是汉化的)123456789101112&lt;!-- LOCAL: You can save these files to your site and update links --&gt;&#123;% if theme.gitment.mint %&#125; &#123;% set CommentsClass = 'Gitmint' %&#125; &lt;script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitmint.browser.js"&gt;&lt;/script&gt;&#123;% else %&#125; &#123;% set CommentsClass = 'Gitment' %&#125; &lt;!-- &lt;script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js"&gt;&lt;/script&gt; --&gt;&lt;script src="https://billts.site/js/gitment.js"&gt;&lt;/script&gt;&#123;% endif %&#125;&lt;!-- &lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css"/&gt; --&gt;&lt;link rel="stylesheet" href="https://billts.site/extra_css/gitment.css"&gt;&lt;!-- END LOCAL --&gt; 需要注意的是确保themes/next/_config.yml中theme.gitment.mint设置为false,才会走到我们改动的分支. 还有修改一下gitment模板，只需要修改id还是在上面那个文件, （我也不知道为啥要改，大佬门说要改，实际上我没改也没出现啥错误1234var gitment = new &#123;&#123;CommentsClass&#125;&#125;(&#123; id: &apos;&#123;&#123; page.date &#125;&#125;&apos;, owner: &apos;&#123;&#123; theme.gitment.github_user &#125;&#125;&apos;, repo: &apos;&#123;&#123; theme.gitment.github_repo &#125;&#125;&apos;,]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018CCPC吉林场重现赛]]></title>
    <url>%2F2019%2F07%2F16%2F2018CCPC%E5%90%89%E6%9E%97%E5%9C%BA%E9%87%8D%E7%8E%B0%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[2018CCPC吉林赛区（重现赛）传送门 A B这两题如果不会写，还是多去刷刷基础题，也没几个人为了这两题来吧。 C Justice题意： 给你N堆石子 ，每堆石子重量是1/(2^ki)的重量，然后问能不能把石子分成大于等于1/2重量的两堆石子。题解： 从大到小每次合并两堆一样的，如果只剩一个就直接丢掉，因为无论如何这个都没法合并成更大的一层的。一直这样合并下去如果能分成两堆一样的各大于1/2，那么最终合并的和一定能合成一个 0例子:1 3 3 4 4 5 2先按大小排序5 4 4 3 3 2 15没法合并，直接丢掉，合并两个4获得一个33 3 3 2 1合并两个3或得一个2 ，多出来的一个3没法合成2直接丢掉。2 2 1合并两个2再合并两个1最终获得0.能够获得0说明能分成两堆一样的1/2一开始没看到要记录状态，后来补救了一下，合并的时候加一个并查集就行了，不影响复杂度。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const long long mod = 1e9 + 7;const int maxn = 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;clock_t prostart;void f() &#123;#ifndef ONLINE_JUDGE prostart = clock(); freopen("../data.in", "r", stdin);#endif return;&#125;vector&lt;P&gt; v;int par[maxn];int find(int x) &#123; return x == par[x] ? x : par[x] = find(par[x]);&#125;priority_queue&lt;P, vector&lt;P&gt;, less&lt;P&gt; &gt; q;int main() &#123; f(); int T; int cas = 1; scanf("%d", &amp;T); while (T--) &#123; int n; scanf("%d", &amp;n); v.clear(); for (int i = 0; i &lt;= n; i++)par[i] = i; for (int i = 0; i &lt; n; i++) &#123; int a; scanf("%d", &amp;a); if (a &lt; n + 1) &#123; v.emplace_back(P(a, i + 1)); &#125; &#125; sort(v.begin(), v.end()); int flag = 0, ans = -1; for (int i = (int) v.size() - 1; i &gt;= 0; i--) &#123; while (q.size() &amp;&amp; v[i].first &lt; q.top().first)q.pop(); if (q.empty()) &#123; q.push(P(v[i].first, v[i].second)); if (v[i].first == 1)ans = v[i].second; &#125; else &#123; int l = v[i].first, y = v[i].second; while (q.size() &amp;&amp; q.top().first == l) &#123; if (l - 1 &gt;= 1) &#123; int x = find(q.top().second); par[x] = y; if (l - 1 == 1)ans = y; &#125; q.pop(); l = l - 1; &#125; if (l &lt;= 0)flag = y; q.push(P(l, y)); &#125; &#125; while (q.size()) &#123; int l = q.top().first, y = q.top().second; if (l == 1)ans = y; q.pop(); while (q.size() &amp;&amp; q.top().first == l) &#123; if (l - 1 &gt;= 1) &#123; int x = find(q.top().second); par[x] = y; if (l - 1 == 1)ans = y; &#125; q.pop(); l = l - 1;// if (l == 1)ans = y; &#125; if (l &lt;= 0)flag = 1; &#125; printf("Case %d: %s\n", cas++, flag ? "YES" : "NO"); if (flag) &#123;// debug(find(2)); for (int i = 1; i &lt;= n; i++) &#123; if (find(i) == ans)printf("1"); else printf("0"); &#125; puts(""); &#125; &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125; D The Moon题意： p的概率赢，初始获得包概率q为 2% 每次进行一次游戏，如果赢了q的概率获得包，如果没获得概率q变成min(100%，p),如果输了q变成min(100%，p),输入p问期望论数是多少.题解: p是一个整数，总共只有100个值，q最多只会出现0.5%，看到这些我有一个大胆的想法。期望等于 轮数*概率所以我暴力枚举1e6轮，用dp[i]表示q=i/2%的概率，然后直接把1e6轮的值加起来，因为到后面概率绝对越来越小1e6轮误差已经很小，然后暴力枚举p的1-100,把答案打印下来。。。。然后你懂的(注释掉的是暴力跑的代码)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const long long mod = 1e9 + 7;const int maxn = 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;clock_t prostart;void f() &#123;#ifndef ONLINE_JUDGE prostart = clock(); freopen("../data.in", "r", stdin);#endif return;&#125;bool cmp(double o1, double o2) &#123; return abs(o1 - o2) &lt; eps;&#125;struct point3 &#123; double x, y, z;&#125; s, t;double dp[maxn];double a[1000] = &#123;130.7530454000, 79.2053644503, 61.1640496589, 51.6033688156, 45.5020175987, 41.1756105103, 37.8950632978, 35.2908241865, 33.1540346125, 31.3568193706, 29.8159317728, 28.4744883082, 27.2920701057, 26.2390206161, 25.2929905666, 24.4367537696, 23.6567754479, 22.9422440770, 22.2843986720, 21.6760501176, 21.1112333591, 20.5849499398, 20.0929742362, 19.6317054554, 19.1980530697, 18.7893470611, 18.4032668302, 18.0377843270, 17.6911181415, 17.3616961332, 17.0481247749, 16.7491638265, 16.4637052733, 16.1907557033, 15.9294214771, 15.6788961816, 15.4384499618, 15.2074204071, 14.9852047313, 14.7712530335, 14.5650624685, 14.3661721843, 14.1741589106, 13.9886331012, 13.8092355497, 13.6356344123, 13.4675225797, 13.3046153516, 13.1466483734, 12.9933758002, 12.8445686601, 12.7000133904, 12.5595105271, 12.4228735274, 12.2899277111, 12.1605093052, 12.0344645825, 11.9116490803, 11.7919268935, 11.6751700320, 11.5612578361, 11.4500764445, 11.3415183077, 11.2354817448, 11.1318705365, 11.0305935527, 10.9315644109, 10.8347011617, 10.7399260000, 10.6471649983, 10.5563478614, 10.4674076992, 10.3802808172, 10.2949065219, 10.2112269412, 10.1291868575, 10.0487335524, 9.9698166630, 9.8923880479, 9.8164016621, 9.7418134409, 9.6685811914, 9.5966644912, 9.5260245936, 9.4566243391, 9.3884280725, 9.3214015652, 9.2555119427, 9.1907276158, 9.1270182166, 9.0643545388, 9.0027084802, 8.9420529899, 8.8823620181, 8.8236104686, 8.7657741544, 8.7088297556, 8.6527547795, 8.5975275235, 8.5431270393&#125;;int main() &#123;// f(); int T; int cas = 1;// T=100; scanf("%d", &amp;T); // int t=1; while (T--) &#123; int p;// p = t++; scanf("%d", &amp;p); printf("Case %d: %.10f\n", cas++, a[p - 1]);// p = p / 100;// double ans = 0;// memset(dp, 0, sizeof(dp + 300));// dp[4] = 1;// for (int i = 1; i &lt; maxn; i++) &#123;// for (int j = 200; j &gt;= 0; j--) &#123;//// debug(dp[j]);// if (dp[j] == 0)continue;// ans += i * dp[j] * j / 200.0 * p;// double t = dp[j];// dp[j] = 0;// dp[min(j + 4, 200)] += p * t * (1 - j / 200.0);// dp[min(200, j + 3)] += (1 - p) * t;// &#125;// &#125;// printf("%.10f\n", ans);// a[t - 1] = ans; &#125;// for (int i = 1; i &lt;= 100; i++)printf("%.10f\n", a[i]);#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125; E The Tower题意： 给一个圆锥的r,h 和一个点(x,y,z)，点的移动速度(vx,vy,vz)问这个点什么时候撞上去，保证直接从外面撞上去。题解： 线的方程:x=x0+vx*ty=y0+vy*tz=z0+vz*t圆锥方程: x^2 + y^2 = (h-z)^2 * r^2 / h^2解方程高中知识1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const long long mod = 1e9 + 7;const int maxn = 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif return;&#125;bool cmp(double o1, double o2) &#123; return abs(o1 - o2) &lt; eps;&#125;struct point3 &#123; double x, y, z;&#125; s, t;int main() &#123; f(); int T; double r, h; int cas = 0; scanf("%d", &amp;T); while (T--) &#123; scanf("%lf%lf%lf%lf%lf%lf%lf%lf", &amp;r, &amp;h, &amp;s.x, &amp;s.y, &amp;s.z, &amp;t.x, &amp;t.y, &amp;t.z); double tx, ty, tz; tx = t.x; ty = t.y; tz = t.z; double a, b, c; a = (tx * tx + ty * ty - tz * tz * r * r / h / h); b = 2 * (tx * s.x + ty * s.y + tz * (h - s.z) * r * r / h / h); c = s.x * s.x + s.y * s.y - (h - s.z) * (h - s.z) * r * r / h / h; double high = max((h - s.z) / tz, -s.z / tz), low = min((h - s.z) / tz, -s.z / tz); double a1 = (-b + sqrt(b * b - 4 * a * c)) / 2 / a, a2 = (-b - sqrt(b * b - 4 * a * c)) / 2 / a, ans; ans = inf; if (a1 &gt;= low &amp;&amp; a1 &lt;= high)ans = min(a1, ans); if (a2 &gt;= low &amp;&amp; a2 &lt;= high)ans = min(a2, ans); else ans = a2; cout &lt;&lt; "Case " &lt;&lt; ++cas &lt;&lt; ": " &lt;&lt; fixed &lt;&lt; setprecision(10) &lt;&lt; ans &lt;&lt; "\n"; &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125; F The Hermit题意: 太长了自己读吧.题解: 读题读懂了可以发现一个有趣的事，每个i对应的k都是连续的几个。为什么会这样呢？仔细分析每个站点的区域发现，后面的结束一定比前面的晚，前面的开始的一定比后面晚，所以导致了k是连续的，枚举i用set保存覆盖到i的j 用set的二分找到一个与i有k的起始位置，到set最后一个j的最后一个k的位置，这两个位置之间的站点都是i的k，然后异或就行了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;int n;set&lt;P&gt; s;int main() &#123; f(); int T, cas = 1; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int a; scanf("%d", &amp;a); int last = a + i - 1; if (s.size()) &#123; set&lt;P&gt;::iterator ite = s.lower_bound(P(i - (a - 1) / 2, 0)); if (ite != s.end()) &#123; int stat = max(i - a + 1, 2 * ite-&gt;first - ite-&gt;second); int end = 2 * (--s.end())-&gt;first - i; ans ^= end - stat + 1; &#125; &#125; s.insert(P(i, last)); while (s.size() &amp;&amp; s.begin()-&gt;second &lt;= i) &#123; s.erase(s.begin()); &#125; &#125; s.clear(); printf("Case %d: %d\n", cas++, ans); &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125; H Lovers题意： n 个字符串，m个操作，wrap操作在区间[l,r]的字符串前后各加一个数字,如3加入2112变成321123，一开始是个空字符串，值为0。query 查询[l,r]之间所有字符串的值的和模1e9+7。题解： 把字符串分成三段 前缀+原本的值+后缀，前缀和后缀就是一个相反的，我直接把他处理成数字，然后记录长度，原本的值也是一样，保存值和长度。然后线段树随便搞，lazy数组保存字符串加在前面的贡献，lazy2 后缀贡献,dat区间内添加一个数影响的总贡献，val区间和.每次更新值：val[k] =lazy[k]*dat[k] + val[k] * lenth(lazy[k]) + lazy2[k]dat[k] = dat[k] * lenth(lazy[k]) 具体见代码add() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;LL dat[maxn &lt;&lt; 2], lazy[maxn &lt;&lt; 2], val[maxn &lt;&lt; 2], lazy2[maxn &lt;&lt; 2];LL p10[maxn];int len[maxn &lt;&lt; 2];void up(int l, int r, int k) &#123; val[k] = (val[chl] + val[chr]) % mod; dat[k] = (dat[chl] + dat[chr]) % mod; len[k] = 0; lazy2[k] = lazy[k] = 0;&#125;void build(int l, int r, int k) &#123; if (r == l) &#123; dat[k] = 1; lazy2[k] = lazy[k] = 0; len[k] = 0; val[k] = 0; &#125; else &#123; build(lson); build(rson); up(l, r, k); &#125;&#125;LL re(LL x) &#123; LL res = 0; while (x &gt; 0) &#123; res = res * 10 + x % 10 % mod; x /= 10; &#125; return res;&#125;void add(int l, int r, int k, LL x, LL y, int lenx) &#123; if (r == l) &#123; lazy2[k] = lazy[k] = 0; val[k] = (1LL * y % mod + val[k] * p10[lenx] % mod + dat[k] * p10[lenx] % mod * x % mod) % mod; dat[k] = dat[k] * p10[2 * lenx] % mod; return; &#125; lazy[k] = (lazy[k] + x * p10[len[k]] % mod) % mod; lazy2[k] = (lazy2[k] * p10[lenx] % mod + y) % mod; len[k] += lenx; val[k] = (1LL * y * (r - l + 1) % mod + val[k] * p10[lenx] % mod + dat[k] * p10[lenx] % mod * x % mod) % mod; dat[k] = dat[k] * p10[2 * lenx] % mod;&#125;void pushdown(int l, int r, int k) &#123; if (len[k] == 0) &#123; return; &#125; else &#123; add(lson, lazy[k], lazy2[k], len[k]); add(rson, lazy[k], lazy2[k], len[k]); up(l, r, k); &#125;&#125;int t;int n, m;void update(int a, int b, int l, int r, int k, int x) &#123; pushdown(l, r, k); if (r &lt; a || l &gt; b)return; else if (a &lt;= l &amp;&amp; r &lt;= b) &#123; add(l, r, k, x, x, 1LL); &#125; else &#123; update(a, b, lson, x); update(a, b, rson, x); up(l, r, k); &#125;&#125;LL querry(int a, int b, int l, int r, int k) &#123; pushdown(l, r, k); if (r &lt; a || l &gt; b)return 0; else if (a &lt;= l &amp;&amp; r &lt;= b) &#123;// debug(val[k]); return val[k]; &#125; else &#123; return (querry(a, b, lson) + querry(a, b, rson)) % mod; &#125;&#125;int main() &#123; f(); p10[0] = 1; for (int i = 1; i &lt;= 400000; i++) &#123; p10[i] = p10[i - 1] * 10 % mod; &#125; int cas = 1; scanf("%d", &amp;t); while (t--) &#123; scanf("%d%d", &amp;n, &amp;m); build(1, n, 0); printf("Case %d:\n", cas++); while (m--) &#123; char s[10]; int l, r; scanf("%s%d%d", s, &amp;l, &amp;r); if (s[0] == 'q') &#123; LL ans = querry(l, r, 1, n, 0); printf("%lld\n", ans % mod); &#125; else &#123; int x; scanf("%d", &amp;x); update(l, r, 1, n, 0, x);// for (int i = 1; i &lt;= n; i++) &#123;// printf("%lld ", querry(i, i, 1, n, 0));// &#125;// puts(""); &#125; &#125; &#125; return 0;&#125; I Strength题意: 游戏王，我有n个怪 全都是战斗表示 ,对面有m个怪，0表示战斗表示，1防守表示,问我第一回合能造成多少点伤害。题解: 一个水题，其实和A B难度差距不大。枚举两种情况，一种是能把对面怪全部砍了，一种是不能。不能全砍死，直接用最大的砍对面攻击表示最小的，砍不过就算了不打了。能全砍死，本来这还有两种情况，就算我能全砍死对面的怪，但是我全砍死，和第一种情况一样，直接用最大的砍你最小的，另一种就是全砍死 (事实上数据就只有这一种情况，可能出题人有特殊癖好，要砍就全砍死) ，先把防御状态的用尽可能小的代价砍死，然后你想怎么砍就怎么砍，反正最后代价都是你怪攻击力总和减对面战斗力总和。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;struct node &#123; int x, op; bool operator&lt;(const node &amp;o) const &#123; if (op == o.op)return x &lt; o.x; return op &lt; o.op; &#125;&#125; k[maxn], d[maxn];bool cmp(node &amp;o1, node &amp;o2) &#123; return o1.x &gt; o2.x;&#125;int main() &#123; f(); int T, cas = 1; scanf("%d", &amp;T); while (T--) &#123; int n, m; multiset&lt;int&gt; s; priority_queue&lt;int&gt; q; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;k[i].x); s.insert(k[i].x); q.push(k[i].x); &#125; for (int i = 0; i &lt; m; i++) &#123; scanf("%d", &amp;d[i].x); &#125; for (int i = 0; i &lt; m; i++) &#123; scanf("%d", &amp;d[i].op); &#125; sort(k, k + n, cmp); sort(d, d + m, cmp); int flag = 0; if (n &lt; m)flag = 1; else &#123; for (int i = 0; i &lt; m; i++) &#123; if (k[i].x &lt; d[i].x) &#123; flag = 1; break; &#125; &#125; &#125; LL ans = 0; if (flag == 1) &#123; sort(d, d + m); for (int i = 0; i &lt; m; i++) &#123; if (d[i].op == 1)break; else &#123; if (q.top() &gt; d[i].x) &#123; ans += q.top() - d[i].x; q.pop(); &#125; &#125; &#125; &#125; else &#123; sort(d, d + m); for (int i = 0; i &lt; m; i++) &#123; if (d[i].op == 1)break; else &#123; if (k[i].x &gt; d[i].x) &#123; ans += k[i].x - d[i].x; &#125; else &#123; break; &#125; &#125; &#125; LL res = 0; for (int i = 0; i &lt; m; i++) &#123; if (d[i].op == 1) &#123; s.erase(s.lower_bound(d[i].x)); &#125; else &#123; res -= d[i].x; &#125; &#125; for (auto au:s) &#123; res += au; &#125; ans = max(res, ans); &#125; printf("Case %d: %lld\n", cas++, ans); &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "运行时间:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>CCPC</tag>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 573 Div 2]]></title>
    <url>%2F2019%2F07%2F13%2FCodeforces-Round-573-Div-2%2F</url>
    <content type="text"><![CDATA[A - Tokitsukaze and Enhancement简单题不与说明12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt; using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P; #define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a)); const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("dat.in", "r", stdin);#endif // ONLIN_JUDGE&#125; int main() &#123; f(); int x; cin&gt;&gt;x; x=x%4; if(x==0) &#123; printf("1 A\n"); &#125; else if(x==1) &#123; printf("0 A\n"); &#125; else if(x==2) &#123; printf("1 B\n"); &#125; else printf("2 A\n"); return 0;&#125; B - Tokitsukaze and Mahjong1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt; using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P; #define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a)); const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("dat.in", "r", stdin);#endif // ONLIN_JUDGE&#125;char s[20];vector&lt;int &gt;v[3],v2,v3; int f(int x) &#123; sort(v[x].begin(),v[x].end()); if(v[x].size()==0)return 3; if(v[x].size()==1)return 2; else if(v[x].size()==2) &#123; if(v[x][1]==v[x][0])return 1; if(v[x][1]==v[x][0]+1)return 1; if(v[x][1]==v[x][0]+2)return 1; return 2; &#125; else &#123; if(v[x][1]==v[x][0]&amp;&amp;v[x][1]==v[x][2])return 0; if(v[x][1]==v[x][0]+1&amp;&amp;v[x][1]==v[x][2]-1)return 0; if(v[x][1]==v[x][0]||v[x][1]==v[x][2])return 1; if(v[x][1]==v[x][0]+1||v[x][1]==v[x][0]+2||v[x][1]==v[x][2]-1||v[x][1]==v[x][2]-2)return 1; return 2; &#125;&#125;int main() &#123; int ans=2; for(int i=0; i&lt;3; i++) &#123; scanf("%s",s); if(s[1]=='s') &#123; v[0].push_back(s[0]); &#125; else if(s[1]=='p') &#123; v[1].push_back(s[0]); &#125; else v[2].push_back(s[0]); &#125; for(int i=0; i&lt;3; i++) &#123;// debug(i); ans=min(ans,f(i)); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; C - Tokitsukaze and Discard Items12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt; using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P; #define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a)); const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("dat.in", "r", stdin);#endif // ONLIN_JUDGE&#125; LL n,m,k;LL a[maxn];int main() &#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=0; i&lt;m; i++) &#123; scanf("%lld",&amp;a[i]); &#125; sort(a,a+m); LL sum=0,ans=0,num=0; LL page=1; for(int i=0; i&lt;m; i++) &#123; if(a[i]&lt;=page*k+sum) &#123; num++; &#125; else &#123; if(num==0) &#123; page=(a[i]-sum+k-1)/k; num++; &#125; else &#123; ans++; sum+=num; page=(a[i]-sum+k-1)/k; num=1; &#125; &#125; &#125; if(num!=0)ans++; printf("%lld\n",ans); return 0;&#125; D - Tokitsukaze, CSL and Stone Game首先这题是简单粗暴，因为选择到两个相同的就输了，说明每一个都不相同，最终状态肯定是 0 1 2 3 …. n-1这种状态肯定是必输，无法动弹。所以最终都会变成这个状态，判断一下到这个状态的奇偶就是答案。另外还有一开始就输了的状态，比如 3 4 4 两个一样的，只能选一样的，但是选了有一个和他相同，还有 0 0 一开始就有两个0 还有就是 5 5 5 三个一样的或者两对两个一样的，这四种状态绝对是直接输了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374By ET_BUBBLE, contest:Codeforces Round #573 (Div. 2), problem: (D) Tokitsukaze, CSL and Stone Game, Accepted, ##include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("dat.in", "r", stdin);#endif // ONLIN_JUDGE&#125;LL n;LL a[maxn];int flag=1,num;map&lt;LL,LL&gt; mp;LL sum=0;int main() &#123; cin&gt;&gt;n; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;a[i]; &#125; sort(a,a+n); for(int i=0; i&lt;n; i++) &#123; if(mp.find(a[i])!=mp.end()) &#123; num++; if(mp.find(a[i]-1)!=mp.end())flag=0; &#125; mp[a[i]]++; &#125; if(num&gt;1||mp[0]&gt;=2||flag==0) &#123; puts("cslnb"); return 0; &#125; if(n==1) &#123; puts((a[0]&amp;1)?"sjfnb":"cslnb"); &#125; else &#123; int flag=1; sum=0; for(int i=0; i&lt;n; i++) &#123; if(a[i]&lt;i) &#123; flag=0; &#125; else &#123; sum+=a[i]-i; &#125; &#125; if(flag==0) &#123; puts("cslnb"); return 0; &#125; puts(sum%2==1?"sjfnb":"cslnb"); &#125; return 0;&#125; F - Tokitsukaze and Strange Rectangle题意：自己读去题解：先按照,y从大到小排序在按照x从小到大排序，然后每次判断一层y。先判断第一层 1 2 6 7 10 （假设）y=10然后判断第二层 4 8 (假设) y = 9第一层能够出现的不同的选法是 5*(5-1)/2;第二层会受到第一层的影响 1 2 在 4 前面，所以要选 4 的矩形情况 是红色l到右边蓝色r的所有矩形，会选上4,同理选上8又不和前面的重复就只能是这样了。然后又可以发现，如果有第3层 ，前面两层对第3层的影响只与x的出现有关，每次判断一层只需要考虑上面出现的 x的影响。先离散化一下，然后用树状数组求一下这个点前面有多个点，后面有多少个点，然后乘一下就可以了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("dat.in", "r", stdin);#endif // ONLIN_JUDGE&#125;int bit[maxn+1],pos;int sum(int i) &#123; int s=0; while(i&gt;0) &#123; s +=bit[i]; i-=i&amp;-i; &#125; return s;&#125;void add(int i,int x) &#123; while(i&lt;=pos) &#123; bit[i]+=x; i+=i&amp;-i; &#125;&#125;int n;struct node &#123; int x,y;&#125; p[maxn];bool cmp(node &amp;o1,node &amp;o2) &#123; if(o1.y==o2.y)return o1.x&lt;o2.x; return o1.y&gt;o2.y;&#125;LL ans=0;unordered_map&lt;int,int&gt;mp;int a[maxn];int main() &#123; f(); scanf("%d",&amp;n); for(int i=0; i&lt;n; i++) &#123; scanf("%d%d",&amp;p[i].x,&amp;p[i].y); a[i]=(p[i].x); &#125; pos=1; sort(a,a+n); for(int i=0; i&lt;n; i++) &#123; if(i==0) &#123; mp[a[0]]=pos++; &#125; else if(a[i]!=a[i-1]) &#123; mp[a[i]]=pos++; &#125; &#125; for(int i=0; i&lt;n; i++) &#123; p[i].x=mp[p[i].x]; &#125; sort(p,p+n,cmp); int len=0; a[len++]=p[0].x; add(p[0].x,1); int mx=pos; for(int i=1; i&lt;n; i++) &#123; if(p[i].y==p[i-1].y) &#123; a[len++]=p[i].x; if(sum(p[i].x)-sum(p[i].x-1)==0)add(p[i].x,1); &#125; else &#123; int la=0; // sort(a,a+len); for(int j=0; j&lt;len; j++) &#123; int i=a[j]; ans+=1LL*(sum(i)-sum(la))*(sum(mx)-sum(i-1)); la=i; &#125; len=0; a[len++]=(p[i].x); if(sum(p[i].x)-sum(p[i].x-1)==0)add(p[i].x,1); &#125; &#125; int la=0; // sort(a,a+len); for(int j=0; j&lt;len; j++) &#123; int i=a[j]; ans+=1LL*(sum(i)-sum(la))*(sum(mx)-sum(i-1)); la=i; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拉格朗日插值和求多项式系数]]></title>
    <url>%2F2019%2F07%2F12%2F%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E5%92%8C%E6%B1%82%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%B3%BB%E6%95%B0%2F</url>
    <content type="text"><![CDATA[拉格朗日介绍先说说拉格朗日是啥吧首先 拉格朗日插值是给你 n+1 个点 $(x,y)$ 然后根据这n个点可以$O(n^2)$的求出多项式的系数。也就是解出这个多项式的答案。 假设给你一个多项式$y=a_0+a_1x+a_2x^2$然后给你3个解$(x1,y1)(x2,y2)(x3,y3)$你第一个想法是怎么解？解方程啊是不是代进去是不是这样 \begin{cases} y_1=a_0+a_1x_1+a_2x_1^2\\ y_2=a_0+a_1x_2+a_2x_2^2\\ y_3=a_0+a_1x_3+a_2x_3^2 \end{cases}然年后解这个方程？解这个方程复杂度多少,高斯消元O(n^3)很显然复杂度高了。拉格朗日就比较厉害了他能O(n^2)解决首先 假设一个多项式$f_1(x)= b_0 + b_1x+b_2x^2$当他$x=x_1$解是1,$x_2$ $x_3$ 解是 0同理再假设 $f_2(x)$ $f_3(x)$然后$L(x)=y_1f_1(x)+y_2f_2(x)+y_3f_3(x)$,这个就是最开始那个方程，不信?你分别把$x_1,x_2,x_3$ 带进去解绝对是 $y_1,y_2,y_3$。那么问题来了后面$f_1(x)$这个多项式怎么求出来？？？？这就是拉格朗日基本公式 再来一遍，这就是拉格朗日基本公式 f_j(x)=l_j(x)=\prod_{j=0,j\neq i}^{n-1}\frac{x-x_j}{x_j-x_i}把这个多项式展开会发现非常神奇的事，当$x=x_j$的时候刚好等于1否则等于0,刚好满足了原来所需要的方程式。就是下面这样： f_j(x)=l_j(x)=\prod_{j=0,j\neq i}^{k}\frac{x-x_j}{x_i-x_j}=\frac{x-x_0}{x_0-x_j}\cdots\frac{x-x_0}{x_j-x_{j-1}}\frac{x-x_{j+1}}{x_j-x_{j+1}}\cdots\frac{x-x_k}{x_j-x_k}最终表达式L(x)=\sum_{i=0}^{n-1}y_i\prod_{j=0,j\neq i}^{n-1}\frac{x-x_j}{x_j-x_i}怕你还是看不懂，举个例子给你看 $f(4)=10\ f(5)=5.25\ f(6)=1$ 求 $f(18)$ 首先写出拉格朗日基本多项式 l_0=\frac{(x-5)(x-6)}{(4-5)(5-6)}l_1=\frac{(x-4)(x-6)}{(5-4)(5-6)}l_2=\frac{(x-4)(x-5)}{(6-4)(6-5)}\begin{cases} p(x)&=f(4)l_0(x)+f(5)l_1(x)+f(6)l_2(x)\\ &=10\frac{(x-5)(x-6)}{(4-5)(5-6)}+5.25\frac{(x-4)(x-6)}{(5-4)(5-6)}+1*\frac{(x-4)(x-5)}{(6-4)(6-5)}\\ &=\frac{1}{4}(x^2-28x+136) \end{cases}此时代入18:$f(18)=p(18)=-11$还有一个问题你们肯定很想问。。。知道公式之后怎么解。。。对于这个问题分母 是不是每次算一下就行了，答案是固定的分子是不是一个大的多项式里面少了一个，就预处理出总的多项式然后，模拟除一下$(x+c)$的多项式 理论知识全部搞定，下面就给你贴模板了 板子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//这个是杜教的板子 我打了点注释/// 注意mod，使用前须调用一次 polysum::init(int M);/// 注意mod，使用前须调用一次 polysum::init(int M);namespace polysum &#123;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)typedef long long ll;const ll mod = 1e9 + 7; /// 取模值ll powmod(ll a, ll b) &#123; ll res = 1; a %= mod; assert(b &gt;= 0); for (; b; b &gt;&gt;= 1) &#123; if (b &amp; 1)res = res*a%mod; a = a*a%mod; &#125; return res;&#125;const int D = 1010000; /// 最高次限制ll a[D], f[D], g[D], p[D], p1[D], p2[D], b[D], h[D][2], C[D];ll calcn(int d, ll *a, ll n) &#123; //根据前 d 项 求 第n项 if (n &lt;= d) return a[n]; p1[0] = p2[0] = 1; rep(i, 0, d + 1) &#123; ll t = (n - i + mod) % mod; p1[i + 1] = p1[i] * t%mod; &#125; rep(i, 0, d + 1) &#123; ll t = (n - d + i + mod) % mod; p2[i + 1] = p2[i] * t%mod; &#125; ll ans = 0; rep(i, 0, d + 1) &#123; ll t = g[i] * g[d - i] % mod*p1[i] % mod*p2[d - i] % mod*a[i] % mod; if ((d - i) &amp; 1) ans = (ans - t + mod) % mod; else ans = (ans + t) % mod; &#125; return ans;&#125;void init(int M) &#123; /// M：最高次 f[0] = f[1] = g[0] = g[1] = 1; rep(i, 2, M + 5) f[i] = f[i - 1] * i%mod; g[M + 4] = powmod(f[M + 4], mod - 2); per(i, 1, M + 4) g[i] = g[i + 1] * (i + 1) % mod; //逆元&#125;ll polysum(ll n, ll *arr, ll m) &#123; /// a[0].. a[m] \sum_&#123;i=0&#125;^&#123;n-1&#125; a[i] for (int i = 0; i &lt;= m; i++) a[i] = arr[i]; a[m + 1] = calcn(m, a, m + 1); rep(i, 1, m + 2) a[i] = (a[i - 1] + a[i]) % mod; return calcn(m + 1, a, n - 1);&#125;ll qpolysum(ll R, ll n, ll *a, ll m) &#123; /// a[0].. a[m] \sum_&#123;i=0&#125;^&#123;n-1&#125; a[i]*R^i if (R == 1) return polysum(n, a, m); a[m + 1] = calcn(m, a, m + 1); ll r = powmod(R, mod - 2), p3 = 0, p4 = 0, c, ans; h[0][0] = 0; h[0][1] = 1; rep(i, 1, m + 2) &#123; h[i][0] = (h[i - 1][0] + a[i - 1])*r%mod; h[i][1] = h[i - 1][1] * r%mod; &#125; rep(i, 0, m + 2) &#123; ll t = g[i] * g[m + 1 - i] % mod; if (i &amp; 1) p3 = ((p3 - h[i][0] * t) % mod + mod) % mod, p4 = ((p4 - h[i][1] * t) % mod + mod) % mod; else p3 = (p3 + h[i][0] * t) % mod, p4 = (p4 + h[i][1] * t) % mod; &#125; c = powmod(p4, mod - 2)*(mod - p3) % mod; rep(i, 0, m + 2) h[i][0] = (h[i][0] + h[i][1] * c) % mod; rep(i, 0, m + 2) C[i] = h[i][0]; ans = (calcn(m, C, n)*powmod(R, n) - c) % mod; if (ans&lt;0) ans += mod; return ans;&#125;&#125; 然后下面这个是求多项式的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758LL temp[maxn];void mul(LL *f, int len, LL t) &#123; //len为多项式的次数+1，函数让多项式f变成f*(x+t) for (int i = len; i &gt; 0; --i) &#123; temp[i] = f[i]; f[i] = f[i - 1]; &#125; temp[0] = f[0], f[0] = 0; for (int i = 0; i &lt;= len; ++i) &#123; f[i] = (f[i] + t * temp[i]) % mod; &#125;&#125;void dev(LL *f, LL *r, LL t, int len) &#123; //f是被除多项式的系数，r保存f除以x+t的结果 len是最高次项 for (int i = 0; i &lt;= len; ++i) &#123; temp[i] = f[i]; &#125; for (int i = len; i &gt; 0; --i) &#123; r[i - 1] = temp[i]; temp[i - 1] = (temp[i - 1] - t * temp[i]) % mod; &#125; return;&#125;LL a[maxn], b[maxn], c[maxn];LL x[maxn], y[maxn]; //x,y输入从 1开始到nint n;void lglr() &#123; memset(a, 0, sizeof a); b[1] = 1, b[0] = -x[1]; for (int i = 2; i &lt;= n; ++i) &#123; mul(b, i, -x[i]); &#125;//预处理(x-x1)*(x-x2)...*(x-xn) for (int i = 1; i &lt;= n; ++i) &#123; LL fz = 1; for (int j = 1; j &lt;= n; ++j) &#123; if (j == i) continue; fz = fz * (x[i] - x[j]) % mod; &#125; fz = qm(fz, mod - 2); fz = fz * y[i] % mod;//得到多项式系数 dev(b, c, -x[i], n);//得到多项式，保存在b数组 for (int j = 0; j &lt; n; ++j) a[j] = (a[j] + fz * c[j]) % mod; &#125;&#125;LL cal(LL k) &#123; //计算第x=k值 LL ans = 0; LL res = 1; for (int i = 0; i &lt; n; ++i) &#123; ans = (ans + res * a[i]) % mod; res = res * k % mod; &#125; ans = (ans + mod) % mod; return ans;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数素数判断及质因子分解]]></title>
    <url>%2F2019%2F07%2F11%2F%E5%A4%A7%E6%95%B0%E7%B4%A0%E6%95%B0%E5%88%A4%E6%96%AD%E5%8F%8A%E8%B4%A8%E5%9B%A0%E5%AD%90%E5%88%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[判断是否是素数几个常用的sqrt(n)复杂度的就不说了。对于一个 longlong 范围或者更大的数，怎么快速判断一个数是不是素数，就要用到Miller_Rabin算法.立用a^(n-1)=1(mod n) 怎么来的就不解释了，有兴趣的同学可以看看算法导论P566有详细推导。在这个的基础上用 随机数进行测试（直接用的话会有一些伪素数）。里面 a用随机数随机， (n-1) 写成 2^r*s 为啥这么写我也不知道，反正大家都是这么写的 qaq然后就根据上面那个判断就行了这个算法有时候会出错，出错的概率差不多是 2^-循环次数12345678910111213141516171819202122232425262728293031323334353637inline LL ksc(LL x,LL n,LL mod) &#123; LL res=0; while(n&gt;0) &#123; if(n&amp;1)res=(res+x)%mod; x=(x+x)%mod; n&gt;&gt;=1; &#125; return res%mod;&#125;inline LL ksm(LL x,LL n,LL mod) &#123; LL res=1; while(n&gt;0) &#123; if(n&amp;1)res=ksc(res,x,mod); x=ksc(x,x,mod); n&gt;&gt;=1; &#125; return res%mod;&#125;bool check(LL x) &#123; //Miller_Rabin算法，判断n是否为素数 for(int i=0; i&lt;50; i++) &#123; int a=rand()%(x-1)+1,k=0; LL t=x-1; if(ksm(a,x-1,x)!=1)return 0; while(t&amp;1==0) &#123; ++k; t&gt;&gt;=1; &#125; LL u=ksm(a,t,x),l=u; for(int i=1; i&lt;=k; i++) &#123; u=ksc(u,u,x); if(u==1&amp;&amp;l!=1&amp;&amp;l!=x-1)return 0; l=u; &#125; &#125; return 1;&#125; 质因子分解pollard_rho算法,这个算法十分玄学，找到一个数x0 ，然后用一个玄学递推得到 x1=x0*x0 + 一个随机数 然后用两个的差值去和 n做 gcd 然后得出来如果是1就继续找，如果不是1 不就是个因子吗？ （个人理解有点像直接随机一个数和他做GCD有没有公约数。。。。） 补充说明一下 x=(x*x +c)%n 是一个滚循环 像ρ所以称为pollard_rho算法，所以要判断循环结 用 floyd 判断。1234567891011121314151617181920212223242526272829303132333435363738LL pollard_rho(LL n, LL c) &#123; LL i = 1, k = 2; LL x = rand() % (n - 1) + 1; LL y = x; while (1) &#123; i++; x = (ksc(x, x, n) + c) % n; //玄学递推 LL d = __gcd((y - x + n) % n, n); if (1LL &lt; d &amp;&amp; d &lt; n) &#123; //如果有因子就直接返回 return d; &#125; if (y == x) &#123; //如果找到了循环节就跳出 return n; &#125; if (i == k) &#123; //空间 o1 判断循环节用的 ，看不懂你没救了 y = x; k &lt;&lt;= 1; &#125; &#125;&#125;LL fac[100],ct;void find(LL n, int c) &#123; if (n == 1) &#123; return; &#125; if (check(n)) &#123; fac[ct++] = n; //是个质因子 return; &#125; LL p = n; LL k = c; while (p &gt;= n) &#123; p = pollard_rho(p, c--); //如果是合数总会找到一个因子 &#125; find(p, k); //继续找 find(n / p, k);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何将本地项目传入github]]></title>
    <url>%2F2019%2F06%2F24%2F%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%BC%A0%E5%85%A5github%2F</url>
    <content type="text"><![CDATA[初始化文件夹在本地执行git init命令1git init 添加需要上传到github的代码到本地仓库git status查看哪些文件是没有加入到本地仓库的，红色的没有，绿色是已经添加了的。 1git add 可以把需要的文件加入本地仓库 将add的文件commit到仓库1git commit -m &quot;第一次提交&quot; 去github上创建自己的Repository这个不用教了吧 将本地的仓库关联到github上1git remote add origin +链接 上传代码到github远程仓库12git push #传上去git pull #拉回来 123git pull --rebase origin mastergit push -u origin master]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA连接myqsl数据库]]></title>
    <url>%2F2019%2F05%2F24%2FIDEA%E8%BF%9E%E6%8E%A5myqsl%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[第一步然后右边就会出现一个database 这个地方可能要更新一下驱动，idea 有自带更新，点一下下面那个 MySQL 就行添加连接数据库的Java包选择找到的包添加好后应该会在下面多一个这样的包连接数据库就成功了测试一下，具体测试根据你自己数据库来，后面我打有注释1234567891011121314151617181920212223242526272829303132package longpf;import java.sql.*;public class My &#123; public static void main(String[] args) &#123; Connection conn = null; //建立一个数据库连接 try &#123; Class.forName( "com.mysql.jdbc.Driver"); //加载驱动 System.out.println("数据库驱动加载成功"); long start=System.currentTimeMillis(); //记录开始时间 conn=DriverManager.getConnection("jdbc:mysql://localhost:3306/mygamedb","root","root"); //连接数据库，参数数据库位置，用户名 密码 long end=System.currentTimeMillis(); // 记录结束时间 System.out.println(conn); // 打印连接 System.out.println("建立用时："+(end-start)+"ms"); // 创建Statement对象 Statement stmt = conn.createStatement(); // 执行SQL语句 ResultSet rs = stmt.executeQuery("select * from users"); System.out.println("id\tusername\tpwd\t\tregTime"); while (rs.next()) &#123; System.out.println(rs.getInt(1) + "\t" + rs.getString(2) + "\t\t" + rs.getString(3)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return; &#125;&#125;]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EC-FINAL I Misunderstood Missing]]></title>
    <url>%2F2019%2F04%2F25%2FEC-FINAL-I%2F</url>
    <content type="text"><![CDATA[写此篇记录EC-FINAL 铁牌。I Misunderstood … Missing此题，是EC打铁的主要原因。在牛客的那个网站上此题出的比F题还要多，然而我在比赛中却没有写出来，如果这题写出来了，可能还有救。对于这题DP没写出来，感觉是真的傻逼。以后打比赛切记不可以慌张，慌张并不能解决问题，这题如果静下心来思考应该不难想出来。题意：t 组数据 n 个回合初始战力 A 为 0 后面有n 个回合，每个回合可以进行一个操作1可以造成A+a点伤害2每个回合战力加b3直接提升 c 点战斗力问最多能造成多少点伤害题解：DP求解 dp[i][j]为j 个回合进行了第一种操作，操作的下标和为j。如果把1 2 3 三种操作的伤害区分开来，1 操作就是直接造成 a 点伤害。 2 操作会对后面的A造成影响，仔细思考一下加入 2 操作是 第 i 个 后面进行了 j 次攻击 ,能够发现 2 操作 最终造成的伤害和是 （下标和 - i * j ） b 点伤害。举个例子：如果 你在 2 3 进行了攻击,你在第1个回合进行了2操作 那么贡献就 是 (2+3 - 1 * 2)*b。理解了这个 3 操作就更简单了，直接就是j*c的伤害。看到这里也差不多明白，这个DP是从后往前DP的。后面的状态永远都不会影响到前面。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &quot;bits/stdc++.h&quot;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout &lt;&lt; &quot;[&quot; &lt;&lt; x &lt;&lt; &quot;]&quot; &lt;&lt; endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const long long mod = 1e9 + 7;const int maxn = 6e3 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen(&quot;../data.in&quot;, &quot;r&quot;, stdin);#endif return;&#125;LL dp[maxn][105];LL a[105], b[105], c[105];int main() &#123; f(); int t, n; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%lld%lld%lld&quot;, &amp;a[i], &amp;b[i], &amp;c[i]); &#125; memset(dp, -1, sizeof(dp)); dp[n][1]=a[n]; for (int i = n - 1; i &gt;= 1; i--) &#123; for (int j = maxn-1; j&gt;=0; j--) &#123; for (int l = 0; l &lt;= n; l++) &#123; if(dp[j][l]==-1)continue; if(j+i&lt;maxn)dp[j+i][l+1]=max(dp[j+i][l+1],dp[j][l]+a[i]); dp[j][l]=max(dp[j][l]+c[i]*l,max(dp[j][l],dp[j][l]+b[i]*(j-l*i))); &#125; &#125; &#125; LL ans=0; for(int i=0; i&lt;=n; i++) &#123; for(int j=0; j&lt;maxn; j++) &#123; ans=max(dp[j][i],ans); &#125; &#125; printf(&quot;%lld\n&quot;,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ sock编程学习笔记]]></title>
    <url>%2F2019%2F04%2F19%2FC%2B%2B-sock%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[主机字节序和网络字节序CPU累加器一次能装载至少4个字节，即一个整数。字节序分为大端字节序和小端字节序。大端字节序高位字节（23-31bit）储存在内存的低处，低位字节储存在高地址初。小端字节序恰恰相反。大部分PC电脑电脑使用小端字节序，所以又被称为主机字节序。大端字节序被称为网络字节序。JAVA虚拟机使用的是大端字节序4个函数函数用来完成字节序转换。123456// #include&lt;netinet/in.h&gt; //linux 下头文件#include&lt;winsock2.h&gt; //window 下头文件unsigned long htonl(unsigned long); //host to net 转换IPunsigned long ntohl(unsigned long); //net to host 转换IPunsigned short htons(unsigned short); //host to net 转换端口unsigned short ntohs(unsigned short); //net to host 转换端口]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>笔记</tag>
        <tag>sock 编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选拔赛Tulip Festival及其进阶]]></title>
    <url>%2F2019%2F04%2F16%2F%E9%80%89%E6%8B%94%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[线段树动态开点，对于这题顺便挂个自己学校OJ Tulip Festival以及后面跟着的几个版本，用线段树动态开点都能过。题意：给 n 个数字,m个操作操作两种:1 把p修改成x2 查询 [l,r]区件类与 [l,r]区间异或和不相等的数字个数。 题解：把每个数字的下标放到一个数组，区间异或和直接用树状数组求出来(对于不会用树状数组求区间异或和的多去做做树状数组基础题)然后每次查询区间里面的有个数字和异或值相等即可。有一个版本只有200个相同值，这个直接用vector存，然后暴力查找就行了。但是后面出现了大量相同的数字，就不能暴力了。查询区间类有多少个值，可以用树状数组最简洁，但是明显1e6个数，每个数开一个树状数组，长度为1e6明显炸了。用线段树，如果直接开空间每个都要开nlogn个点，明显也会炸。但是自信一想，其中有很多点都是无用的，所有数加起来个数最多不到1e6个点，所以用线段树动态开点，最多不会超过nlogn个点。线段树动态开点其实和普通的线段树其实差距不大。动态开点，就是把没有用的节点就不给他分配内存，字节当作空，这样每个数字最多最多开logn个点。动态开点建议用结构体写，这样可以方便一点。结构体设置3个值一个是当前节点保存的值，左右儿子下标举个例子，加入线段树总长度是 1 - 8,你在 1 1 插入一个值。那么你就需要 1-8 1-4 1-2 1-1这几个点开空间，其他点直接不用管，查询的时候直接返回0123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define bug printf("*********\n");#define debug(x) cout &lt;&lt; "[" &lt;&lt; x &lt;&lt; "]" &lt;&lt; endl;#define mid (l + r) / 2#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const long long mod = 1e9 + 7;const int maxn = 1e6 + 5 + 1e5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("../1.in", "r", stdin); freopen("../data.out", "w", stdout);#endif return;&#125;int tot, n, m;int a[maxn], bit[maxn];unordered_map&lt;int, int&gt; mp;int sum(int i) &#123; int ans = 0; while (i &gt; 0) &#123; ans ^= bit[i]; // debug(i); i -= i &amp; -i; &#125; return ans;&#125;void add(int i, int x) &#123; while (i &lt;= n) &#123; bit[i] ^= x; // debug(i); i += i &amp; -i; &#125;&#125;struct node &#123; int x; int chl, chr;&#125; tree[maxn * 50];int tt;void update(int a, int b, int l, int r, int k, int bol) &#123; if (b &lt; l || a &gt; r)return; else if (a &lt;= l &amp;&amp; r &lt;= b) &#123; if (bol)tree[k].x = 1; else tree[k].x = 0; &#125; else &#123; if (b &lt;= mid) &#123; if (tree[k].chl == 0) &#123; tree[k].chl = tt++; &#125; update(a, b, l, mid, tree[k].chl, bol); &#125; else &#123; if (tree[k].chr == 0) &#123; tree[k].chr = tt++; &#125; update(a, b, mid + 1, r, tree[k].chr, bol); &#125; int sum = 0; if (tree[k].chl != 0) &#123; sum += tree[tree[k].chl].x; &#125; if (tree[k].chr != 0) &#123; sum += tree[tree[k].chr].x; &#125; tree[k].x = sum; return; &#125;&#125;int querry(int a, int b, int l, int r, int k) &#123; if (b &lt; l || a &gt; r) &#123; return 0; &#125; else if (a &lt;= l &amp;&amp; r &lt;= b) &#123; return tree[k].x; &#125; else &#123; int sum = 0; if (tree[k].chl != 0) &#123; sum += querry(a, b, l, mid, tree[k].chl); &#125; if (tree[k].chr != 0) &#123; sum += querry(a, b, mid + 1, r, tree[k].chr); &#125; return sum; &#125;&#125;int main() &#123; f(); scanf("%d%d", &amp;n, &amp;m); tt = n + m + 1; for (int i = 0; i &lt; n; i++) &#123; int t; scanf("%d", &amp;t); add(i + 1, t); if (mp[t] == 0) &#123; mp[t] = ++tot; update(i + 1, i + 1, 1, n, tot, 1); &#125; else &#123; update(i + 1, i + 1, 1, n, mp[t], 1); &#125; &#125; // debug(sum(1)); while (m--) &#123; int op; scanf("%d", &amp;op); if (op == 1) &#123; int p, x; scanf("%d%d", &amp;p, &amp;x); int t = sum(p) ^sum(p - 1); update(p, p, 1, n, mp[t], 0); add(p, t ^ x); if (mp[x] == 0)mp[x] = ++tot; update(p, p, 1, n, mp[x], 1); assert(tt &lt; 5e7); &#125; else &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); int t = sum(r) ^sum(l - 1); //debug(t); if (mp[t] == 0)printf("%d\n", r - l + 1); else printf("%d\n", r - l + 1 - querry(l, r, 1, n, mp[t])); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D触发器和碰撞器]]></title>
    <url>%2F2019%2F03%2F26%2FUnity3D%E8%A7%A6%E7%A2%B0%E5%99%A8%E5%92%8C%E7%A2%B0%E6%92%9E%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Unity3d碰撞检测中碰撞器与触发器的区别要产生碰撞必须为游戏对象添加刚体（Rigidbody）和碰撞器，刚体可以让物体在物理影响下运动。碰撞体是物理组件的一类，它要与刚体一起添加到游戏对象上才能触发碰撞。如果两个刚体相互撞在一起，除非两个对象有碰撞体时物理引擎才会计算碰撞，在物理模拟中，没有碰撞体的刚体会彼此相互穿过。 物体发生碰撞的必要条件 两个物体都必须带有碰撞器(Collider)，其中一个物体还必须带有Rigidbody刚体。 在unity3d中，能检测碰撞发生的方式有两种，一种是利用碰撞器，另一种则是利用触发器。 碰撞器：一群组件，它包含了很多种类，比如：Box Collider（盒碰撞体），Mesh Collider（网格碰撞体）等，这些碰撞器应用的场合不同，但都必须加到GameObjecet身上。 触发器，只需要在检视面板中的碰撞器组件中勾选IsTrigger属性选择框。勾选Is Trigger 后不会有碰撞物理现象触发信息检测： 1.MonoBehaviour.OnTriggerEnter(Collider collider)当进入触发器 2.MonoBehaviour.OnTriggerExit(Collider collider)当退出触发器 3.MonoBehaviour.OnTriggerStay(Collider collider)当逗留触发器 碰撞信息检测： 1.MonoBehaviour.OnCollisionEnter(Collision collision) 当进入碰撞器 2.MonoBehaviour.OnCollisionExit(Collision collision) 当退出碰撞器 3.MonoBehaviour.OnCollisionStay(Collision collision) 当逗留碰撞器 12345678void OnTriggerEnter(Collider collider)&#123; //进入触发器执行的代码&#125;void OnCollisionEnter(Collision collision) &#123; //进入碰撞器执行的代码&#125;]]></content>
      <categories>
        <category>游戏</category>
        <category>U3D</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中南多校第一场]]></title>
    <url>%2F2019%2F03%2F18%2F%E4%B8%AD%E5%8D%97%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%80%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[源题目 2018-2019 ACM-ICPC Nordic Collegiate Programming Contest (NCPC 2018)&lt;/br&gt; 写一篇博客表示自己把题补了. &lt;/br&gt; A.Altruistic Amphibians简单DP，每个青蛙的重量总和不会超过 1e8，每一次影响的状态最多只有 1e8复杂度最高只有1e8dp[j]表示能支撑重量j最大高度是多少。dp[j-w[i]]=max(dp[j-w[i]],dp[j]);1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;x&lt;&lt;"]" &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e8+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;int a[maxn/10];struct node &#123; int l,w,h; bool operator&lt;(const node &amp; t) &#123; return w&gt;t.w; &#125;&#125; dat[maxn/10];int dp[maxn*2];int main() &#123; int n,d; scanf("%d%d",&amp;n,&amp;d); int mx=0; for(int i=0; i&lt;n; i++) &#123; scanf("%d%d%d",&amp;dat[i].l,&amp;dat[i].w,&amp;dat[i].h); mx=max(mx,dat[i].w); &#125; sort(dat,dat+n); int ans=0; for(int i=0; i&lt;n; i++) &#123; if(dp[dat[i].w]+dat[i].l&gt;d)ans++; for(int j=dat[i].w+1; j&lt;min(2*dat[i].w,maxn); j++) &#123; dp[j-dat[i].w]=max(dp[j-dat[i].w],dp[j]+dat[i].h); &#125; &#125; printf("%d\n",ans); return 0;&#125; B. Baby Bites水题都不解释12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#define fi first#define se second#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1#define pb push_back#define MP make_pair#define LL long long#define FIN freopen("in.txt","r",stdin)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt;pii;int n;string s;int main()&#123;#ifndef ONLINE_JUDGE FIN;#endif // ONLINE_JUDGE while(cin&gt;&gt;n) &#123; int falg= 1; for(int i = 1; i&lt;=n; i++) &#123; cin&gt;&gt;s; if(s=="mumble") continue; else &#123; int tmp = stoi(s); if(tmp!=i) &#123; falg = 0; &#125; &#125; &#125; if(falg)&#123; cout&lt;&lt;"makes sense"&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;"something is fishy"&lt;&lt;endl; &#125; &#125; return 0;&#125; C. Code Cleanups12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#define fi first#define se second#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1#define pb push_back#define MP make_pair#define LL long long#define FIN freopen("in.txt","r",stdin)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt;pii;const int mod = 1e9+7;const int MX = 3e3+5;int n;int vis[MX];int main()&#123;#ifndef ONLINE_JUDGE FIN;#endif // ONLINE_JUDGE while(~scanf("%d",&amp;n))&#123; memset(vis,0,sizeof(vis)); for(int i = 1,x;i &lt;= n;i++) &#123; scanf("%d",&amp;x); vis[x] = 1; &#125; int ans = 0; int sum = 0,cnt = 0; for(int i = 1;i &lt;= 365;i++) &#123; sum += cnt; if(sum &gt;= 20) &#123; ans++; sum = 0; cnt = 0; i--; continue; &#125; if(vis[i]) cnt++; &#125; if(cnt) ans++; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; D. Delivery Delays这题也挺简单的，不过出了不少bug记录一下。首先预处理出所有点直接的最近距离，然后再预处理出送完第j个回到1点然后一直等到 i 第i个订单的需要的时间，和用户最大等待时间。然后dp[i]保存送完第 i 个订单回到 1 的最小时间，然后再二分最大等待时间。最后写二分出了点问题，二分的范围 ，l 初值应该是-1而不是0;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;LL, int&gt; P;#define bug printf("*********\n");#define debug(x) cout &lt;&lt; "[" &lt;&lt; x &lt;&lt; "]" &lt;&lt; endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const long long mod = 1e9 + 7;const int maxn = 1e3 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f3f3f3f3f;const double eps = 1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif return;&#125;int n, m;struct edge &#123; int to, next; LL w;&#125; eg[maxn * 10];int head[maxn], tot;LL cost[maxn];void init() &#123; memset(head, -1, sizeof(head)); tot = 0;&#125;void add(int u, int v, LL w) &#123; eg[tot].to = v; eg[tot].w = w; eg[tot].next = head[u]; head[u] = tot++;&#125;LL dis[maxn][maxn];void dij(int u) &#123; memset(cost, inf, sizeof(cost)); priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; q; cost[u] = 0; q.push(P(cost[u], u)); while (q.size()) &#123; int v = q.top().second; LL w = q.top().first; q.pop(); if (cost[v] &lt; w)continue; else &#123; for (int i = head[v]; i != -1; i = eg[i].next) &#123; edge &amp;e = eg[i]; if (cost[e.to] &gt; w + e.w) &#123; cost[e.to] = w + e.w; q.push(P(cost[e.to], e.to)); &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; dis[u][i] = cost[i]; &#125;&#125;int q;LL s[maxn], to[maxn], t[maxn];LL dp[maxn];LL k[maxn][maxn];LL mx[maxn][maxn];int solve(LL m) &#123; memset(dp, inf, sizeof(dp)); dp[0] = 0; for (int i = 1; i &lt;= q; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; LL ti = dp[j], flag = 1; ti = max(ti, t[i]); if(mx[j][i]+ti&gt;m)flag=0; ti+=k[j][i]; if (flag == 0)continue; else &#123; dp[i] = min(dp[i], ti + dis[to[i]][1]); &#125; &#125; &#125; for(int i=1;i&lt;=q;i++)&#123; if(dp[i]==dp[maxn-1])return 0; &#125; return 1;&#125;int main() &#123; f(); scanf("%d%d", &amp;n, &amp;m); init(); for (int i = 0; i &lt; m; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, w); &#125; for (int i = 1; i &lt;= n; i++) &#123; dij(i); &#125; scanf("%d", &amp;q); to[0] = 1; for (int i = 1; i &lt;= q; i++) &#123; scanf("%lld%lld%lld", &amp;s[i], &amp;to[i], &amp;t[i]); &#125; for (int i = 1; i &lt;= q; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; LL ti,m=-inf; ti=0; int pos = j + 1, lat = 1; while (pos &lt;= i) &#123; ti += dis[lat][to[pos]]; if (ti - s[pos] &gt; m ) &#123; m=ti - s[pos]; &#125; lat = to[pos]; pos++; &#125; k[j][i]=ti; mx[j][i]=m; &#125; &#125; LL l = -1, r =inf; while (r &gt; l + 1) &#123; if (solve(mid))r = mid; else l = mid; &#125; printf("%lld\n", r); return 0;&#125; E. Explosion Exploit这题竟然没想到用 类似状压DP了，还一直想怎么十维数组了，唉。直接用一个long long 整数，前5位保存自己小兵的值，后5位保存对面小兵的值。后来发现这样写复杂度过不去。就算是记忆化搜索还是错的。应该用6位来保存还剩多少点血的小兵的个数。因为 前面一种搜索，31300和 13300不是同一种状态，除非排一下序。而后面这一种保存方式，全部都是102。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;x&lt;&lt;"]" &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;map&lt;LL,double&gt;mp;int n,m,k;double dfs(LL a,int u) &#123; if(mp.count(a)) &#123; return mp[a]; &#125; LL b=a; LL ans=0,a1=0,a2=0; for(int i=0; i&lt;12; i++) &#123; if(i&gt;=6) &#123; if(b%10!=0)a2+=b%10; b/=10; continue; &#125; ans+=(b%10)*(6-i); if(b%10!=0)a1+=b%10; b/=10; &#125;// debug(ans&lt;&lt;"a="&lt;&lt;a2); if(ans==0) &#123; mp[a]=1; return 1; &#125; if(ans&gt;u) &#123; mp[a]=0; return 0; &#125; double tp=0; if(a2==0) &#123; mp[a]=1; return 1; &#125; else &#123; LL tk=1; b=a; for(int i=0; i&lt;12; i++) &#123; if(b%10!=0) &#123; if(i==11||i==5)&#123; tp+=dfs(a-tk,u-1)*(b%10)*1.0/(a1+a2); &#125; else if(i&lt;6)&#123; tp+=dfs(a-tk+tk*10,u-1)*(b%10)*1.0/(a1+a2); &#125; else tp+=dfs(a-tk+tk*10,u-1)*(b%10)*1.0/(a1+a2); &#125; b/=10; tk*=10; &#125; &#125; mp[a]=tp; return tp;&#125;LL a;int b[2][10];int main() &#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=0 ; i&lt;n; i++) &#123; int p; scanf("%d",&amp;p); b[0][p]++; &#125; for(int i=0; i&lt;m; i++) &#123; int p; scanf("%d",&amp;p); b[1][p]++; &#125; for(int i=1; i&lt;=6; i++) &#123; a=a*10+b[0][i]; &#125; for(int i=1; i&lt;=6; i++) &#123; a=a*10+b[1][i]; &#125; printf("%.10f\n",dfs(a,k)); return 0;&#125;/*2 2 31 11 2*/ F * G 这两题有点难，没写出来。。。空着。。 H. House Lawn队友写的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;typedef long long LL;typedef long double lb;typedef pair&lt;int, int&gt; P;#define debug(x) cout&lt;&lt;"["&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define bug cout&lt;&lt;"*******************"&lt;&lt;endl;#define mem(a,b) memset(a,b,sizeof(a));#define fi first#define se second#define pb(x) push_back(x)const LL mod = 1e9+7;const int inf=0x3f3f3f3f;const int INF=0x7fffffff;const double eps = 1e-7;const double pi = acos(-1);const int maxn=1e6+5;int n, sum;string s, name[106];int stak[106], top = 0;int minp;struct node &#123; int id; LL p, c, t, r;&#125; lawn[107];LL solve(LL tm, LL tp, LL c, LL t, LL r) &#123; return (c*t*(tp/(t+r)))/sum;&#125;int main() &#123; //scanf("%d%d", &amp;sum, &amp;n); cin &gt;&gt; sum &gt;&gt; n; int ans = inf; int p, c, t, r; minp = INF; getchar(); for(int i = 1, len; i &lt;= n; ++i) &#123; getline(cin, s); len = s.length(); int tmp = 0; for(; s[tmp] != ',';++tmp) ; name[i] = s.substr(0, tmp); //cout &lt;&lt; name[i] &lt;&lt; endl; p = c = t = r = 0; for(++tmp; s[tmp] != ',';++tmp) p = p*10+s[tmp]-'0'; for(++tmp; s[tmp] != ',';++tmp) c = c*10+s[tmp]-'0'; for(++tmp; s[tmp] != ',';++tmp) t = t*10+s[tmp]-'0'; for(++tmp; tmp &lt; len;++tmp) r = r*10+s[tmp]-'0'; //cout &lt;&lt; p &lt;&lt;" "&lt;&lt; c &lt;&lt;" "&lt;&lt; t &lt;&lt;" "&lt;&lt; r &lt;&lt; endl; //cin &gt;&gt; p &gt;&gt; c &gt;&gt; t &gt;&gt; r; //scanf("%d%d%d%d", &amp;p, &amp;c, &amp;t, &amp;r); lawn[i].id = i; lawn[i].p = p; lawn[i].c = c; lawn[i].t = t; lawn[i].r = r; &#125; for(int i = 1; i &lt;= n; ++i) &#123; LL tp = 10080LL * (lawn[i].t+lawn[i].r) / __gcd(10080LL , 1LL*(lawn[i].t+lawn[i].r)); LL T = tp / 10080; LL tot = sum * T; LL tt = solve(tot, tp, lawn[i].c, lawn[i].t, lawn[i].r); //printf("i: %d, T: %lld, tp: %lld, tt: %lld\n", i, T, tp, tt); if(tt &gt;= T) &#123; //printf("OK\n"); if(minp &gt; lawn[i].p) &#123; minp = lawn[i].p; top = 1; stak[top] = lawn[i].id; &#125; else if(minp == lawn[i].p) &#123; top ++; stak[top] = lawn[i].id; &#125; &#125; &#125; for(int i = 1; i &lt;= top; ++i) &#123; cout &lt;&lt; name[stak[i]] &lt;&lt; "\n"; &#125; if(top == 0) cout &lt;&lt; "no such mower\n"; //printf("%d\n", ans); return 0;&#125;/*7000 49999 10 120 120999 1 120 2405499 2 25 355499 3 25 3510000 3aaa,1,1,1,1bbb,1,10000,10080,1ccc,1,10000,10079,1*/ I. Intergalactic Bidding大数，排序,没了。。因为保证 一个值等于另一个值的2倍以上。所以有且只有一种情况。能选就一定要选上123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;typedef long long LL;typedef long double lb;typedef pair&lt;int, int&gt; P;#define debug(x) cout&lt;&lt;"["&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define bug cout&lt;&lt;"*******************"&lt;&lt;endl;#define mem(a,b) memset(a,b,sizeof(a));#define fi first#define se second#define pb(x) push_back(x)const LL mod = 1e9+7;const int inf=0x3f3f3f3f;const int INF=0x7fffffff;const double eps = 1e-7;const double pi = acos(-1);const int maxn=1e6+5;const int MAXL = 6e3+5;const int MAXN = 9999;const int DLEN = 4 ;class big &#123;public: int a[MAXN],len; big (const char *s) &#123; int t,k,index=0,L=strlen(s); memset(a,0,sizeof(a)); len=L/DLEN; if(L%DLEN) len++; for(int i = L-1; i&gt;=0; i-=DLEN) &#123; t=0; k=i-DLEN + 1; if(k&lt;0) k=0; for(int j = k; j &lt;=i ; j++) t=t*10+s[j]-'0'; a[index++]=t; &#125; &#125; bool operator&lt;(const big &amp;t) const &#123; int ln; if(len&gt;t.len) return false; else if(len==t.len) &#123; ln=len-1; while(a[ln]==t.a[ln]&amp;&amp;ln&gt;=0) ln--; if(ln&gt;=0&amp;&amp;a[ln]&gt;t.a[ln]) return false; else return true; &#125; else return true; &#125; big operator-(const big &amp;T)const &#123; bool flag; big t1=*this,t2=T; flag=0; int b=t1.len; for(int i=0,j; i&lt;b; i++) &#123; if(t1.a[i]&lt;t2.a[i]) &#123; if(j=i+1); while(t1.a[j]==0) j++; t1.a[j--]--; while(j&gt;i) t1.a[j--]+=MAXN; t1.a[i]+=MAXN+1-t2.a[i]; &#125; else t1.a[i]-=t2.a[i]; &#125; t1.len=b; while(t1.a[t1.len-1]==0&amp;&amp;t1.len&gt;1) t1.len--,b--; return t1; &#125; void print() &#123; printf("%d",a[len-1]); for(int i=len-2; i&gt;=0; i--) &#123; printf("%04d",a[i]); &#125; &#125;&#125;;typedef pair&lt;big,string&gt; PS;vector&lt;PS&gt; v;int main() &#123; int n; char s[1005]; scanf("%d%s",&amp;n,s); big mx(s);// debug((mx&lt;big("0")&amp;&amp;big("0")&lt;mx));// mx.print(); char nam[100]; for(int i=0; i&lt;n; i++) &#123; scanf("%s%s",nam,s); v.push_back(PS(s,nam)); &#125; sort(v.begin(),v.end()); int l=v.size(); vector&lt;string&gt; ans; while(l--&gt;0) &#123; big b=v[l].first; if(b&lt;mx) &#123; ans.pb(v[l].se); mx=mx-b; &#125; &#125; big temp("0"); if(!(temp&lt;mx&amp;&amp;mx&lt;temp)) &#123; printf("0\n"); return 0; &#125; printf("%d\n",ans.size()); for(auto i:ans) &#123; cout&lt;&lt;i&lt;&lt;"\n"; &#125; return 0;&#125; J. Jumbled String首先更具a,d算出有多少个0 和 1 特判一下只有一个1的情况。更具这个可以判断出 01 10 这两种字符串就是 0 在1前面和1在0前面又多少个，还可以发现0在1前面和1在0前面的总和是一样的，更具这个可以判断有没有这样的字符串。然后在随便构造一个字符串就行了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;typedef long long LL;typedef long double lb;typedef pair&lt;int, int&gt; P;#define debug(x) cout&lt;&lt;"["&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define bug cout&lt;&lt;"*******************"&lt;&lt;endl;#define mem(a,b) memset(a,b,sizeof(a));#define fi first#define se second#define pb(x) push_back(x)const LL mod = 1e9+7;const int inf=0x3f3f3f3f;const int INF=0x7fffffff;const double eps = 1e-7;const double pi = acos(-1);const int maxn=1e6+5;LL a,b,c,d;LL zn=-1,on=-1;int main() &#123; while(~scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;d)) &#123; for(LL i=0; i&lt;1e5; i++) &#123; if(i*(i-1)&gt;2*a) &#123; break; &#125; else if(i*(i-1)==2*a) &#123; zn=i; &#125; &#125; for(LL i=0; i&lt;1e5; i++) &#123; if(i*(i-1)&gt;2*d) &#123; break; &#125; else if(i*(i-1)==2*d) &#123; on=i; &#125; &#125; if(a==0) &#123; if(b!=0||c!=0) &#123; zn=1; &#125; else zn=0; &#125; if(d==0) &#123; if(b!=0||c!=0) &#123; on=1; &#125; else on=0; &#125;// debug(zn);// debug(on); if(((b+c)!=on*zn)||zn==-1||on==-1) &#123; puts("impossible"); &#125; else &#123; LL k=(on==0)?0:((on*zn)-b)/on,num=(on==0)?0:((on*zn)-b)%on;// debug(k);// debug(num); for(int i=0; i&lt;zn+on; i++) &#123; if(i&lt;zn-k-1) &#123; printf("0"); &#125; else if(i&gt;zn+on-k-1) &#123; printf("0"); &#125; else if(i==zn-k+num-1) &#123; printf("0"); &#125; else printf("1"); &#125; puts(""); &#125; &#125; return 0;&#125; K. King’s Colors队友写的。。。不过这题就是一个容斥，是一颗树，所以能够保证一个节点的染色只合一个节点有关。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;typedef long long LL;typedef long double lb;typedef pair&lt;int, int&gt; P;#define debug(x) cout&lt;&lt;"["&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define bug cout&lt;&lt;"*******************"&lt;&lt;endl;#define mem(a,b) memset(a,b,sizeof(a));#define fi first#define se second#define pb(x) push_back(x)const LL mod = 1e9+7;const int inf=0x3f3f3f3f;const int INF=0x7fffffff;const double eps = 1e-7;const double pi = acos(-1);const int maxn=1e6+5;char s[10];int rint(char* t) &#123; int l=strlen(t); if(t[0]&lt;'0'||t[0]&gt;'9') &#123; return -1; &#125; else &#123; int i=0,ans=0; while(i&lt;l)&#123; ans=ans*10+t[i]-'0'; i++; &#125; return ans; &#125;&#125;//int a[maxn];LL ksm(LL a, int b) &#123; LL res = 1; for(;b;b&gt;&gt;=1,a=a*a%mod) &#123; if(b&amp;1) res = res*a%mod; &#125; return res;&#125;LL C[3005][3005];int main() &#123; C[1][1] = 1; for(int i = 2; i &lt; 3000; ++i) &#123; for(int j = 1; j &lt;= i; ++j) &#123; C[i][j] = (C[i-1][j]+C[i-1][j-1])%mod; &#125; &#125; LL n, k; scanf("%lld%lld",&amp;n, &amp;k); for(int i = 1, x; i &lt; n; ++i) &#123; scanf("%d", &amp;x); &#125; LL ans = 0, tmp; for(LL i = k, j = 0; i &gt;= 2; --i, j = !j) &#123; tmp = C[k+1][i+1] * i % mod * ksm(i-1, n-1) % mod; if(j == 0) ans = (ans+tmp)%mod; else ans = (ans - tmp)%mod; &#125; printf("%lld\n", (ans+mod)%mod); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HexoNext一些操作]]></title>
    <url>%2F2019%2F03%2F16%2FHexoNext%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[更改头像1.在主题配置文件中搜索 avatar2.3.找到这个路径修改就行了。4. 添加个人cssthemes\next\source\css\_custom修改这个文件 12345678910111213141516171819202122232425262728293031323334353637// Custom styles.@media screen and (min-width:1200px) &#123; body &#123; background:url(https://i.loli.net/2019/03/01/5c7942720fc39.png); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%; background-size: cover; &#125; #footer a &#123; color:#eee; &#125; .main-inner &#123; margin-top: 10px; opacity: 0.8; &#125; .header-inner &#123; margin-top: 10px; position: absolute; top: auto; overflow: hidden; padding: 0; width: 240px; background: #fff; box-shadow: initial; border-radius: initial; opacity: 1; &#125; .post &#123; margin-bottom: 30px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125;&#125;]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>配置</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用VScode 调试的时候提示Unable to start debugging]]></title>
    <url>%2F2019%2F03%2F02%2F%E4%BD%BF%E7%94%A8VScode%20%E8%B0%83%E8%AF%95%E7%9A%84%E6%97%B6%E5%80%99%E6%8F%90%E7%A4%BAUnable%20to%20start%20debugging%2F</url>
    <content type="text"><![CDATA[使用VScode 调试的时候提示Unable to start debugging. Launch options string provided by the project system is invalid. Unable to determine path to debugger. Please specify the “MIDebuggerPath” option. 提示这个错误。 翻译过来就是 miDebuggerPath他出错了。 如果你是在linux 下按照官网的陪应该就是 这个地方陪错了，要先下载gdb 在终端输入 apt-get install gdb 然后把gdb的路径丢进去就行了。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Deepin VSCODE安装C++环境]]></title>
    <url>%2F2019%2F03%2F02%2FDeepin-VSCODE%E5%AE%89%E8%A3%85C%2B%2B%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[首先]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>配置</tag>
        <tag>VScode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime快捷键集合]]></title>
    <url>%2F2019%2F03%2F02%2Fsublime%E5%BF%AB%E6%8D%B7%E9%94%AE%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Sublime Text 3 快捷键列表：精华版 Ctrl+Shift+P：打开命令面板 Ctrl+P：搜索项目中的文件 Ctrl+G：跳转到第几行 Ctrl+W：关闭当前打开文件 Ctrl+Shift+W：关闭所有打开文件 Ctrl+Shift+V：粘贴并格式化 Ctrl+D：选择单词，重复可增加选择下一个相同的单词 Ctrl+L：选择行，重复可依次增加选择下一行 Ctrl+Shift+L：选择多行 Ctrl+Shift+Enter：在当前行前插入新行 Ctrl+X：删除当前行 Ctrl+M：跳转到对应括号 Ctrl+U：软撤销，撤销光标位置 Ctrl+J：选择标签内容 Ctrl+F：查找内容 Ctrl+Shift+F：查找并替换 Ctrl+H：替换 Ctrl+R：前往 method Ctrl+N：新建窗口 Ctrl+K+B：开关侧栏 Ctrl+Shift+M：选中当前括号内容，重复可选着括号本身 Ctrl+F2：设置/删除标记 Ctrl+/：注释当前行 Ctrl+Shift+/：当前位置插入注释 Ctrl+Alt+/：块注释，并Focus到首行，写注释说明用的 Ctrl+Shift+A：选择当前标签前后，修改标签用的 F11：全屏 Shift+F11：全屏免打扰模式，只编辑当前文件 Alt+F3：选择所有相同的词 Alt+.：闭合标签 Alt+Shift+数字：分屏显示 Alt+数字：切换打开第N个文件 Shift+右键拖动：光标多不，用来更改或插入列内容 鼠标的前进后退键可切换Tab文件 按Ctrl，依次点击或选取，可需要编辑的多个位置 按Ctrl+Shift+上下键，可替换行 选择类 Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。 Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。 Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。 Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。 Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。 Ctrl+M 光标移动至括号内结束或开始的位置。 Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。 Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。 Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。 Ctrl+Shift+] 选中代码，按下快捷键，展开代码。 Ctrl+K+0 展开所有折叠代码。 Ctrl+← 向左单位性地移动光标，快速移动光标。 Ctrl+→ 向右单位性地移动光标，快速移动光标。 shift+↑ 向上选中多行。 shift+↓ 向下选中多行。 Shift+← 向左选中文本。 Shift+→ 向右选中文本。 Ctrl+Shift+← 向左单位性地选中文本。 Ctrl+Shift+→ 向右单位性地选中文本。 Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。 Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。 Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。 Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。 编辑类 Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。 Ctrl+Shift+D 复制光标所在整行，插入到下一行。 Tab 向右缩进。 Shift+Tab 向左缩进。 Ctrl+K+K 从光标处开始删除代码至行尾。 Ctrl+Shift+K 删除整行。 Ctrl+/ 注释单行。 Ctrl+Shift+/ 注释多行。 Ctrl+K+U 转换大写。 Ctrl+K+L 转换小写。 Ctrl+Z 撤销。 Ctrl+Y 恢复撤销。 Ctrl+U 软撤销，感觉和 Gtrl+Z 一样。 Ctrl+F2 设置书签 Ctrl+T 左右字母互换。 F6 单词检测拼写 搜索类 Ctrl+F 打开底部搜索框，查找关键字。 Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。 Ctrl+P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。 Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。 Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。 Ctrl+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。 Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。 Esc 退出光标多行选择，退出搜索框，命令框等。 显示类 Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。 Ctrl+PageDown 向左切换当前窗口的标签页。 Ctrl+PageUp 向右切换当前窗口的标签页。 Alt+Shift+1 窗口分屏，恢复默认1屏（非小键盘的数字） Alt+Shift+2 左右分屏-2列 Alt+Shift+3 左右分屏-3列 Alt+Shift+4 左右分屏-4列 Alt+Shift+5 等分4屏 Alt+Shift+8 垂直分屏-2屏 Alt+Shift+9 垂直分屏-3屏 Ctrl+K+B 开启/关闭侧边栏。 F11 全屏模式 Shift+F11 免打扰模式]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2019%2F02%2F27%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[此片文章主要用于记录一些简单的Markdown语法&lt;/br&gt;&lt;/br&gt;&lt;/br&gt; 标题123# 标题1级## 标题2级### 标题3级 标题1级标题2级标题3级文本12345正常文本**加粗文本***斜体文本 ****斜体加粗文本***~~中间加线文本~~ 正常文本加粗文本斜体文本 斜体加粗文本中间加线文本 引用123456&gt;引用&gt;&gt;二级引用&gt;&gt;&gt;以此内推&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的 引用 二级引用 以此内推这是引用的内容这是引用的内容 这是引用的 分割线1234---分割线----- 分割线 1![图片](https://i.loli.net/2019/02/27/5c767c74660a3.png) 图插入1![图片名](images/Markdown语法/20190301060640743.png) 超链接1[超链接](http://baidu.com) 超链接 列表无序列表12345- 无序列表- 1- 1* 1* 2 无序列表 1 1 1 2有序列表 1231.列表12.列表23.有序列表 1.列表12.列表23.有序列表 列表嵌套123456- 列表1 1.列表嵌套 3.列表2 4.列表3- 列表2 1.列表 下一级前3个空格 列表1 1.列表嵌套 3.列表2 4.列表3 列表2 1.列表 表格1234表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容 第二行分割表头和内容。-有一个就行，为了对齐，多加了几个 文字默认居左-两边加：表示文字居中-右边加：表示文字居右 表头 表头 表头 内容 内容 内容 内容 内容 内容 代码块12345var num = 0;for (var i = 0; i &lt; 5; i++) &#123; num+=i;&#125;console.log(num); ``` (此处写代码语言)中间可写入代码 ``` ` 一个点小型分块]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA环境配置]]></title>
    <url>%2F2019%2F02%2F27%2FJAVA%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本篇文章用于记录JAVA配置。 JAVA安装，百度搜索JAVA官网，下载对应系统版本，下载安装好后应该有 JDK 和JDR 两个文件夹 配置系统环境(1)新建-&gt;变量名”JAVA_HOME”，变量值 C:\Java\jdk1.8.0_05(你的JDK路径)(2)新建-&gt;变量名“CLASSPATH”,变量值 .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;第三个变量，如果已经有了Path变量应该直接编辑，然后再在背后添加变量(3)编辑-&gt;变量名”Path”，在原变量值的最后面加上 ;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin这个变量没配置好会出现没有javac这个指令 变量值是以 ； 区分几个变量值。在win10情况下，点击编辑Path路径能够看见一个图表 里面存有各个变量值，点击编辑文本可以看见变量值文本形式，两者对照看应该就能明白怎么给Path添加一个新的变量。 window 在控制台输入三个指令 java，javac，java -version 如果显示没有这个指令说明配置错误。]]></content>
      <categories>
        <category>计算机语言</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>配置</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next 6.0 以上版本背景动画Canvas_nest设置无效]]></title>
    <url>%2F2019%2F02%2F25%2FNext%206.0%20%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC%E8%83%8C%E6%99%AF%E5%8A%A8%E7%94%BBCanvas_nest%E8%AE%BE%E7%BD%AE%E6%97%A0%E6%95%88%2F</url>
    <content type="text"><![CDATA[把这个下载一下 见官方文档 https://github.com/theme-next/theme-next-canvas-nest 在你的博客目录下 1git clone https://github.com/theme-next/theme-next-canvas-nest themes/next/source/lib/canvas-nest 就可以了]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity安装好SDK JDK 还是无法打包app 2019版本问题]]></title>
    <url>%2F2019%2F02%2F22%2FUnity%E5%AE%89%E8%A3%85%E5%A5%BDSDK%20JDK%20%E8%BF%98%E6%98%AF%E6%97%A0%E6%B3%95%E6%89%93%E5%8C%85app%20%20%202019%E7%89%88%E6%9C%AC%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[安装好SDK，JDK，打爆安卓软件还是出错。出现版本小了 弹出错误 CommandInvokationFailure: Failed to create a raw.ap_ package 1234567891011121314151617181920212223242526272829303132333435363738 CommandInvokationFailure: Failed to create a raw.ap_ packageH:\Program Files\Unity\Editor\Data\PlaybackEngines\AndroidPlayer/Tools\OpenJDK\Windows\bin\java.exe -Xmx4096M -Dcom.android.sdkmanager.toolsdir=&quot;H:/Program Files/android-sdk-windows\tools&quot; -Dfile.encoding=UTF8 -jar &quot;H:\Program Files\Unity\Editor\Data\PlaybackEngines\AndroidPlayer/Tools\sdktools.jar&quot; -stderr[Exception in thread &quot;main&quot; java.lang.reflect.InvocationTargetException at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at SDKMain.main(SDKMain.java:136)Caused by: java.lang.NoSuchMethodError: com.google.common.util.concurrent.MoreExecutors.directExecutor()Ljava/util/concurrent/Executor; at com.android.apkzlib.zip.ZFile.createSources(ZFile.java:1586) at com.android.apkzlib.zip.ZFile.makeStoredEntry(ZFile.java:1546) at com.android.apkzlib.zip.ZFile.add(ZFile.java:1625) at com.android.apkzlib.zip.ZFile.add(ZFile.java:1499) at com.android.apkzlib.sign.ManifestGenerationExtension.updateManifest(ManifestGenerationExtension.java:241) at com.android.apkzlib.sign.ManifestGenerationExtension.access$000(ManifestGenerationExtension.java:52) at com.android.apkzlib.sign.ManifestGenerationExtension$1.lambda$beforeUpdate$0(ManifestGenerationExtension.java:168) at com.android.apkzlib.zip.ZFile.notify(ZFile.java:2099) at com.android.apkzlib.zip.ZFile.update(ZFile.java:871) at com.android.apkzlib.zip.ZFile.close(ZFile.java:1161) at com.android.apkzlib.zfile.ApkZFileCreator.close(ApkZFileCreator.java:189) at UnityPackageBuilder.CreatePackage(UnityPackageBuilder.java:136) at UnityPackageBuilder.&lt;init&gt;(UnityPackageBuilder.java:70) at UnityPackageBuilder.main(UnityPackageBuilder.java:27) ... 5 more]stdout[]exit code: 1UnityEditor.Android.AndroidSDKTools.RunCommand (System.String javaExe, System.String sdkToolsDir, System.String[] sdkToolCommand, System.String workingdir, System.String errorMsg, System.Int32 memoryMB) (at &lt;7cbc688ae1af4105929402a46c6a4414&gt;:0)UnityEditor.Android.AndroidSDKTools.RunSDKToolWithReadLock (System.String[] command, System.String workingdir, System.String errorMsg) (at &lt;7cbc688ae1af4105929402a46c6a4414&gt;:0)UnityEditor.Android.PostProcessor.Tasks.AAPTPackage.CreatePackage (UnityEditor.Android.PostProcessor.PostProcessorContext context, System.String package, System.String directory, System.Boolean compress) (at &lt;7cbc688ae1af4105929402a46c6a4414&gt;:0)UnityEditor.Android.PostProcessor.Tasks.AAPTPackage.Pack (UnityEditor.Android.PostProcessor.PostProcessorContext context, System.String package, System.String directory, System.Boolean compress, System.Boolean useAAPT) (at &lt;7cbc688ae1af4105929402a46c6a4414&gt;:0)UnityEditor.Android.PostProcessor.Tasks.AAPTPackage.Execute (UnityEditor.Android.PostProcessor.PostProcessorContext context) (at &lt;7cbc688ae1af4105929402a46c6a4414&gt;:0)UnityEditor.Android.PostProcessor.PostProcessRunner.RunAllTasks (UnityEditor.Android.PostProcessor.PostProcessorContext context) (at &lt;7cbc688ae1af4105929402a46c6a4414&gt;:0)UnityEngine.GUIUtility:ProcessEvent(Int32, IntPtr) 这个是版本跟不上结果，要么更新SDK ，要么就是unity有一个use legecy SDK tool 选上就可以了]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装JAVA环境 java能用javac不能用]]></title>
    <url>%2F2019%2F02%2F22%2F%E5%AE%89%E8%A3%85JAVA%E7%8E%AF%E5%A2%83%20java%E8%83%BD%E7%94%A8javac%E4%B8%8D%E8%83%BD%E7%94%A8%2F</url>
    <content type="text"><![CDATA[安装java环境就不说了，百度一下一大片。重点是安装那个安装好后javac不能用。 这个大部分都是因为没有主义一下环境设置细节。 我把这几个打成代码免得不知道引号和空格是不是要输入的。。。 新建环境变量 变量名 1CLASSPATH 变量值 1.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; 新建环境变量 变量名 1JAVA_HOME 变量值 //是你安装JDK的路径别直接复制粘贴 1H:\Program Files\Java\jdk 前面两个是新建路径，一般不会有啥问题。后面这个一般是编辑，因为系统自带一部分路径。编辑就比较容易出错。 编辑环境变量 变量名 1Path 变量值 1C:\ProgramData\Oracle\Java\javapath;%java_home%\bin;%java_home%\jre\bin; 编辑之后应该是这个样子，一开始有一部分。 一般就是出错在这，大部分人看不懂那个路径就直接复制粘贴上去。就会出现这种情况 解决办法，点击右下角的编辑文本,把下面两个引号删除就可以了 然后你重新点击编辑变量值，应该是下面这个样子。 出现这种情况是因，你直接复制粘贴的这一段里面有分号，分号是环境变量的分割符，你输入的文本里面有分号，结果系统自动给你加了引号。 把分号去掉一段一段的输入也是可以的。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity 点击UI与点击屏幕冲突]]></title>
    <url>%2F2019%2F02%2F20%2FUnity%20%E7%82%B9%E5%87%BBUI%E4%B8%8E%E7%82%B9%E5%87%BB%E5%B1%8F%E5%B9%95%E5%86%B2%E7%AA%81%2F</url>
    <content type="text"><![CDATA[Unity 有点击屏幕进行移动操作，通过Input.GetMouseButtonDown(0)。如果点击到了一些UI上面会触发点击屏幕事件。 引入UnityEngine.EventSystems，用函数判断一下即可 12345678910111213141516 using System.Collections;using System.Collections.Generic;using UnityEngine;using DG.Tweening;using UnityEngine.EventSystems;public class PlayerController : MonoBehaviour&#123; private void Update() &#123; if (EventSystem.current.IsPointerOverGameObject()) return; if (Input.GetMouseButtonDown(0)) &#123; Debug.Log(&quot;点击屏幕&quot;); &#125; &#125;&#125; 这个方法会将点击Text的时候也会当作点击UI 将raycast target 取消勾选可以避免。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用虚拟机CentOS7 做服务器 搭建个人博客 详细教程 2019.02]]></title>
    <url>%2F2019%2F02%2F11%2F%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BACentOS7%20%E5%81%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%20%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%202019.02%2F</url>
    <content type="text"><![CDATA[服务器用的是CentOS7 , 我建在虚拟机上，像腾讯云什么的其实也是一样的。 虚拟机的安装就不说了，不懂的自己去百度下，一百度一大堆。 准备工作 没有给出下载连接，都是些常见的东西，如果实在找不到或者有疑问留下评论。 安装 有CentOS 虚拟机的 VMware (安装CentOS7 的时候记得打开网卡，不然后面要用命令行打开挺麻烦的，这个自己去百度怎么打开。) Xshell 6 同类型的连接服务器软件也可以，腾讯云或自己的连接也行。 start （先登录。。。。） 查看自己虚拟机 IP 指令：ip add 1ip add 如上图 就是IP4 的地址，然后通过Xshell6 连接 (为了模拟服务器连接，所以虚拟机直接后台运行，实际上直接在虚拟机处理也是一样，这里说一下连接服务器的方法) 新建一个连接 然后连接就可以了 关闭防火墙，也可以开一个端口。 为了方便我直接关闭防火墙。 12 systemctl stop firewalld.service #停止firewallsystemctl disable firewalld.service #禁止firewall开机启动 然后直接安装，httpd即可也就是Apache 指令：yum install httpd 1yum install httpd 然后启动服务 指令:systemctl start httpd.service 1systemctl start httpd.service 输入IP应该就能看见这个玩意了。 说明已经安装好了 然后就是安装mysql 因为没有mysql 源 所以先装一个。 指令：sudo rpm -Uvh http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm yum install mysql mysql-server mysql-libs mysql-server 12 sudo rpm -Uvh http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpmyum install mysql mysql-server mysql-libs mysql-server 然后启动一下这个mysql服务 systemctl restart mysql.service 123 systemctl restart mysql.service #重启mysql服务systemctl start mysql.service #启动mysql服务systemctl stop mysql.service #停止mysql服务 为mysql设置登陆密码，然后登陆，在创建一个wordpress 的数据库。 1234 /usr/bin/mysqladmin -u root password &apos;123456&apos; #后面这两个引号里面的是密码mysql -uroot --password=&apos;123456&apos; #输入登陆密码CREATE DATABASE wordpress; #创建wordpress数据库exit #退出mysql 然后再安装PHP 指令：yum install php-fpm php-mysql -y 123 yum install php-fpm php-mysql -yyum install phpyum install php-gd php-imap php-ldap php-odbc php-pear php-xml php-xmlrpc 启动PHP服务 再把它设置为开机启动。 12 service php-fpm startchkconfig php-fpm on 然后再把，Apache 和 mysql 设置成开机自动启动再重启一下服务 1234 systemctl enable httpd.servicesystemctl enable mysqld.servicesystemctl restart httpd.servicesystemctl restart mysqld.service 然后创建一个 php文件试试是不是成功装好了PHP 指令：vi /var/www/html/info.php (如果直接修改不了就进入这个文件夹里面先创建再修改) 1vi /var/www/html/info.php 然后按 i 进入输入模式，再输入 123 &lt;?phpphpinfo();?&gt; 然后按ESC 按 : 输入 wq 确定 ，保存退出。 然后再去浏览器输入 网址 你原本的ip/info.php 应该就是这个样子，然后，就去自己电脑上找wordpress 的文件 然后获得这个安装包 wget 刚才那个连接 如果显示 没有wget 先 输入 yum install wegt 先安装 1wget https://wordpress.org/latest.zip 然后在 解压 unzip latest.zip 如果显示没有unzip 一样的先输入 yum insatll unzip 1unzip latest.zip #是什么文件名就是解压什么文件 然后再复制到html 文件里面去 1cp -rf wordpress/* /var/www/html/ 再修改一下文件权限。 1chmod -R 777 html/ 然后输入IP应该就可以进入安装界面了。 然后一路点下去就行了，输入数据库名，还有数据库登陆账户和密码，就是登陆mysql的。用户名一般就是root。 如果出现这个，把里面内容复制一遍，创建一个wp-config.php文件然后复制粘贴进去就行了。 然后按提示一路下去就行了，如果后面装插件出了点问题，要FTP协议的话就去装一下 yum install vsftpd useradd admin passwd 123456systemctl enable vsftpd.service systemctl restart vsftpd.service 123456789 yum install vsftpduseradd adminpasswd 123456systemctl enable vsftpd.service systemctl restart vsftpd.service]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wordpress Error establishing a database connection Mysql80建立数据库连接时出错]]></title>
    <url>%2F2019%2F02%2F07%2FWordpress%20Error%20establishing%20a%20database%20connection%20Mysql80%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%97%B6%E5%87%BA%E9%94%99%2F</url>
    <content type="text"><![CDATA[建立数据库连接时出错 这或者意味着文件中的用户名和密码信息 wp-config.php 不正确，或者我们无法联系数据库服务器 localhost 。这可能意味着主机的数据库服务器已关闭。 您确定拥有正确的用户名和密码吗？ 您确定已键入正确的主机名吗？ 您确定数据库服务器正在运行吗？ 如果您不确定这些术语的含义，您应该联系您的主人。如果您仍需要帮助，可以随时访问WordPress支持论坛。 出现这个问题有几种可能，最常见几种就是用户名密码或者数据库名打错了。 还有一种可能就是你的mysql加密方式不一样。 先输入 use mysql ; 再输入 select host,user,plugin from user; 12 use mysql;select host,user,plugin from user; 查看加密方式，就是 plugin 这个下面显示。 caching_sha2_password 是一种新的加密方式，wp和discuz 有些版本 是不支持的。 所以这个时候要修改一下 输入指令 update user set plugin=’mysql_native_password’ where user=’root’; 1update user set plugin=&apos;mysql_native_password&apos; where user=&apos;root&apos;; 输入指令之后就是下面这个样子。输入这个指令之后 你原本的密码加密方式变了，所以你的密码也变了，如果你技术好，可以研究一下你的密码变成了多少，如果算不出来就老老实实改密码。注意：改密码必须指明加密方式，不然又会变回去。 输入指令：ALTER USER ‘root’@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘你的密码’; 1ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;; 然后在输入前面那个指令看一下 select host,user,plugin from user; 最后输入最后一个更新权限指令： flush privileges; 1flush privileges; 然后退出重启就行了。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github搭建个人博客 2019.2 详细教程]]></title>
    <url>%2F2019%2F02%2F04%2Fhexo%2Bgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%202019.2%20%20%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[大过年的，就去试试搭一个自己的博客，看了别人的博客，照着搭了一个，中间因为各种bug，试了半天哎。不过也是个很好理解github,hexo的法子，毕竟不出错，怎么会理解。中间还有些东西还没搞明白，希望大佬前来解答一下。 下面就开始搭建了。 准备工作 node.js https://nodejs.org/en/ 链接：https://pan.baidu.com/s/1-I1ROA_2rq4MDG1BFe0BqA 提取码：cnsz GIT https://git-scm.com/downloads 百度云链接：https://pan.baidu.com/s/1-I1ROA_2rq4MDG1BFe0BqA 提取码：cnsz (不要问为啥给你们放个百度云链接 ，我特么官网下不了，还找了半天) 安装好后确认一下： 装好后，在cmd 或者 power shell 里面打出这几个指令，就可以显示版本，也就是有这几个软件。 first 注册个github,这个小孩子玩意我就不和你们BB，自己去注册。 注册好后应该是个这样的瞎J B样子，然后创建一个仓库 仓库名: _yourname_._github.oi_ 进入setting 这个是你的仓库名，然后向下滑动。 上面那个网址，就是你可以外网访问的，你的服务器就是这个了。我们现在就是要把博客放上去。 在这个地方遇到了几个错误 1cd ~/.ssh 这个指令进入ssh,如果显示没有这个文件夹，那就直接创建文件夹BLOG 后面就是用来放博客文件的 进入文件夹，右击，git bash，(通过cmd,power shell 命令行进入也是一样的) 在命令行中输入指令 hexo init 初始化。 1hexo init 输入npm install，安装所需要的组件 1npm install 然后输入 hexo -g 静态部署 1hexo g 差不多就是这个样子，这个时候 博客已经可以访问了。 要看一下的话输入 hexo s 服务器启动 1hexo s 然后你输入一下 http://localhost:4000/ 就可以看一下 localhost 是本机的地址 ，端口是 4000 如果 4000 端口被用了的话可以换一个端口。 hexo server -p 端口号 指令是这个，发生什么我就不截图了。 应该是这个样子。 看完之后ctrl +c 停止运行服务器。 。 下一步就是把这个网页传到github 上去。 为了方便我们建一个 ssh git使用https协议，每次pull,push都要输入密码，使用git协议，使用ssh秘钥，可以省去每次输密码 一、本地生成密钥对； 二、设置github上的公钥； cd ~/.ssh ssh-keygen -t rsa -C “你创建那个github的邮箱” 12 cd ~/.sshssh-keygen -t rsa -C &quot;3035536707@qq.com&quot; 连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh ）找不到就用搜索。 如果显示没有这个文件夹，就先创建，再进入，就是把两个指令换一下输入。 用记事本打开这个 然后把里面的东西复制一下，应该是一大堆看不懂的东西。 然后就放到github上。 测试： 在终端 ssh -T git@github.com 添加好后 重新回到你创建的文件夹。 文本编辑一下这个文件 1234deploy: type: git repository: git@github.com:ETBUBBLE/ETBUBBLE.github.io.git branch: master 你的仓库地址就是是这个 这个是你前面看过的那个玩意，如果没有设置会出啥问题自己去试试。 然后重新回到命令行，进入 BLOG 文件夹 在生成以及部署文章之前，需要安装一个扩展 然后输入 hexo clean hexo d -g 12 hexo cleanhexo d -g 传到仓库去就可以了。 然后就再也没有然后了。 hexo new post “你的博客内容” 就可以发送出去了。 一个博客就搭好了，是不是特别简单。 补充绑定域名 去域名解析上面添加解析。 然后再在自己的github仓库里面新建一个CNAME文件，没有后缀 里面写上你的域名。 1www.etbubble.xyz 再去source创建一个CNAME文件和上面一样]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeCraft-19 and Codeforces Round 537 (Div. 2)]]></title>
    <url>%2F2019%2F02%2F04%2FCodeCraft-19%20and%20Codeforces%20Round%20537%20(Div.%202)%2F</url>
    <content type="text"><![CDATA[对于这一场我是内心崩溃的0.0 A. Superhero Transformation 我特么醉了，没任何难度，但是我数组开小了，少打了一个0.。。。。。。。。。。。。。。被fst. 123456789101112131415161718192021222324252627 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;const int maxn=1e7+5;int k[1000];int main() &#123; k[&apos;a&apos;]=1; k[&apos;e&apos;]=1; k[&apos;i&apos;]=1; k[&apos;o&apos;]=1; k[&apos;u&apos;]=1; char s[2000],t[2000]; cin&gt;&gt;s&gt;&gt;t; int l=strlen(s),l2=strlen(t),flag=1; if(l==l2) &#123; for(int i=0; i&lt;l; i++) &#123; if(k[s[i]]!=k[t[i]])flag=0; &#125; &#125; else flag=0; puts(flag?&quot;YES&quot;:&quot;NO&quot;); return 0;&#125; B. Average Superhero Gang Power 直接算就行了，然而我还是错了。直接枚举删除最小的 m个。 12345678910111213141516171819202122232425 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;const int maxn=1e5+5;int kk[maxn];int main() &#123; LL n,k,m; LL ans=0; cin&gt;&gt;n&gt;&gt;k&gt;&gt;m; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d&quot;,&amp;kk[i]); ans+=kk[i]; &#125; sort(kk,kk+n); double res=0; for(int i=0; i&lt;=min(m,n-1); i++) &#123; res=max(res,(double)(min((n-i)*k,m-i)+ans)/(n-i)); ans-=kk[i]; &#125; printf(&quot;%.10f\n&quot;,res); return 0;&#125; C. Creative Snap 这题好了，终于没有fst了，然而这题才是最崩溃的，一开始就想到了dfs,想了一下复杂度不行，不行你妹啊，然后发现可以，然后计算在区间 [l,r]之间有多少个数，我第一个想到了暴力，我特么想把自己给拍死，二分不行吗，二分不行吗？？？？？我得回到今天凌晨去把自己拍死。 1234567891011121314151617181920212223242526272829303132 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; p;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;const int maxn=1e5+5;int n,k,a,b;LL d[maxn];LL dfs(LL l, LL r,LL i,LL j,LL cnt) &#123; if(cnt&lt;=0) &#123; return a; &#125; else &#123; LL mid=(l+r)/2; LL a1=cnt*(r-l+1)*b; LL pos=upper_bound(d+i,d+j+1,mid)-d; if(r-l==0)return a1; return min(a1,dfs(l,mid,i,pos-1,pos-i)+dfs(mid+1,r,pos,j,j-pos+1)); &#125;&#125;int main() &#123; scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;k,&amp;a,&amp;b); for(int i=0; i&lt;k; i++) &#123; scanf(&quot;%d&quot;,&amp;d[i]); &#125; sort(d,d+k); LL ans=0; ans=dfs(1LL,1&lt;&lt;n,0LL,k-1,k); printf(&quot;%lld\n&quot;,ans); return 0;&#125; 最终掉分。。。。。。。。。原谅我的菜。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCPC-Wannafly Winter Camp Day2 E]]></title>
    <url>%2F2019%2F02%2F01%2FCCPC-Wannafly%20Winter%20Camp%20Day2%20E%2F</url>
    <content type="text"><![CDATA[Power of Function 这个题重点是读题。看懂函数，函数最终表示的是 n 写成K进制，K进制的值的和加上长度 -2 就是m。 给你一个 ，k,l,r,求K进制下，[l,r]区间内m的最大值。然后输出当m最大时[l,r]区间最大值和最小值。 题解：把l,r转换成K进制， r&gt;l，如果r,l,高位相同，那么求得到最大值M高位肯定也是和这个值一样。然后从第一个位不同开始，想让M值最大，只有两种可能，一种是取r这个值二进制下位减一，然后后面位的全部取 k-1,或者这个位取最大值再继续讨论下一个位。写个DFS就可以，和数位DP有点像。 举个例子 ：k=10 ,l=1001,r=1179. 10进制下 l = 1 0 0 1 r = 1 1 7 9 最前面 1 和 1 是相同的所以要 m最大 肯定 最高位也是 1 b=1 0 0 0 然后从第3位开始dfs(3) 要么这个位取 1， 要么 取 0 后慢慢全取 9， 如果这个位 取 1 就会影响下一个位，所以再DFS（2） 然后发现 要么取7 ，（要么 取 6 后面全为9） 以此类推，最后发现 后面3为 179 099 取得 后面比较大，那么m取最大就是 1099； 还有一些细节要注意，比如 179 ，99是一样打的，因为99只有两位数。还有 0 是没有 比他小1这个数，如果要小1就要向高位借，所以这情况要排除。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;int t;LL k,l,r;vector&lt;LL&gt; v1,v2,mi,mx;LL p[2000];LL dfs(LL pos,bool limit) &#123; if(pos==-1)return 0; if(limit) &#123; LL m1,m2; m1=dfs(pos-1,1); m2=dfs(pos-1,0); m1+=v2[pos]; m2+=v2[pos]-1; if(v2[pos]==0)m2=-1; //排除 为 r pos位 为0情况 if(pos==v2.size()-1&amp;&amp;v2[pos]==1)m2--; // 最高位为 0 m2要减一 if(m1&gt;m2) &#123; mx[pos]=mi[pos]=v2[pos]; return m1; &#125; else if(m1==m2) &#123; mx[pos]=v2[pos]; mi[pos]=v2[pos]-1; for(int i=0; i&lt;pos; i++) &#123; mi[i]=k-1; &#125; return m2; &#125; else &#123; mx[pos]=mi[pos]=v2[pos]-1; for(int i=0; i&lt;pos; i++) &#123; mi[i]=mx[i]=k-1; &#125; return m2; &#125; &#125; else &#123; return (k-1)*(pos+1); &#125;&#125;int cas=1;int main() &#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%lld%lld%lld&quot;,&amp;k,&amp;l,&amp;r); v1.clear(); v2.clear(); LL x=r; while(x&gt;0) &#123; v2.push_back(x%k); x/=k; &#125; x=l; while(x&gt;0) &#123; v1.push_back(x%k); x/=k; &#125; while(v1.size()&lt;v2.size()) &#123; v1.push_back(0); &#125; p[0]=1; for(int i=1; i&lt;v2.size(); i++) &#123; p[i]=p[i-1]*k; &#125; int pos=v2.size()-1; mi.resize(v2.size()); mx.resize(v2.size()); while(pos&gt;=0) &#123; if(v1[pos]==v2[pos]) &#123; mi[pos]=mx[pos]=v2[pos]; &#125; else break; pos--; &#125; if(pos!=-1)dfs(pos,1); LL a=0,b=0,m=0,flag=1; for(int i=mx.size()-1; i&gt;=0; i--) &#123; m+=mx[i]; if(mx[i]!=0)flag=0; if(flag)m--; b+=mx[i]*p[i]; a+=mi[i]*p[i]; &#125; m=m+mx.size()-2; printf(&quot;Case #%d: %lld %lld %lld\n&quot;,cas++,m,a,b); &#125; return 0; //看不懂留言0.0，或者加Q3035536707&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 CCPC-Wannafly Winter Camp Day2（Div2）]]></title>
    <url>%2F2019%2F01%2F28%2F2019%20CCPC-Wannafly%20Winter%20Camp%20Day2%EF%BC%88Div2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Camp 的题是真的难，还好没去，不然要被血虐。 做了Day2的几道题。 A题，Erase Numbers II 这个挺简单的，就是范围炸了long long ,暴力枚举两个数就行了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;//typedef long long LL;typedef unsigned long long LL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=6e3+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;int t,n;LL a[maxn],m1=0,ans1,ans2;LL k(LL x,LL y)&#123; LL k=x; while(k&gt;0)&#123; k/=10; y*=10; &#125; return y+x;&#125;int main() &#123; scanf(&quot;%d&quot;,&amp;t); int cas=1; while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); m1=0; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;a[i]; &#125; ans1=ans2=0; for(int i=0;i&lt;n;i++)&#123; for(int j=i+1;j&lt;n;j++)ans1=max(ans1,k(a[j],a[i])); &#125; printf(&quot;Case #%d: &quot;,cas++); cout&lt;&lt;ans1&lt;&lt;endl; &#125; return 0;&#125; B题：Erase Numbers I 题意：删除两个数，最后连起来的数字结果最大。 这题暴力过了，实际上暴力是过不了，本来要预处理一下，删除一个长度为 L的数字串，第一个不同的数字的位置， 比如：12 55 58 删除第二个 字符串的时候， 会变成 1258，和原字符串 125558 字符是 5 和8 不同（这个地方只是举例说明删一个字符串） 但是出题人好像没有特意卡，就直接暴力过了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;//#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot;&lt;&lt;endl;const int maxn=6e3+5;int a[maxn],b[maxn],t,n,mi,a1,a2;char s[maxn*10];char c[maxn][15];bool pd(int pos) &#123; int pos2=pos+1,i=0,j=0; // 就是这个地方要本来是要预处理的，但是暴力每次比较也可以过 while(1) &#123; if(c[pos][i]&lt;c[pos2][j]) &#123; return 1; &#125; else if(c[pos][i]&gt;c[pos2][j]) &#123; return 0; &#125; i++; j++; if(i==b[pos]) &#123; pos++; i=0; &#125; if(j==b[pos2]) &#123; pos2++; j=0; &#125; if(pos2==n)return 1; &#125;&#125;bool pd2(int pos) &#123; int pos2=pos+1,i=0,j=0; while(1) &#123; if(pos==a1)pos++; if(pos2==a1)pos2++; if(c[pos][i]&lt;c[pos2][j]) &#123; return 1; &#125; else if(c[pos][i]&gt;c[pos2][j]) &#123; return 0; &#125; i++; j++; if(i==b[pos]) &#123; pos++; i=0; &#125; if(j==b[pos2]) &#123; pos2++; j=0; &#125; if(pos2==n)return 1; &#125;&#125;int main() &#123; scanf(&quot;%d&quot;,&amp;t); int cas=1; while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); mi=100; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%s&quot;,c[i]); b[i]=strlen(c[i]); a[i]=0; for(int j=0; j&lt;b[i]; j++) &#123; a[i]=a[i]*10+c[i][j]-&apos;0&apos;; &#125; mi=min(mi,b[i]); &#125; a1=-1; for(int i=0; i&lt;n; i++) &#123; if(b[i]==mi) &#123; if(pd(i)) &#123; a1=i; break; &#125; &#125; &#125; if(a1==-1) &#123; for(int i=n-1; i&gt;=0; i--) &#123; if(b[i]==mi) &#123; a1=i; break; &#125; &#125; &#125; mi=100; a2=-1; for(int i=0; i&lt;n; i++) &#123; if(i==a1)continue; mi=min(b[i],mi); &#125; for(int i=0; i&lt;n; i++) &#123; if(i==a1)continue;; if(b[i]==mi) &#123; if(pd2(i)) &#123; a2=i; break; &#125; &#125; &#125; if(a2==-1) &#123; for(int i=n-1; i&gt;=0; i--) &#123; if(i==a1)continue; if(b[i]==mi) &#123; a2=i; break; &#125; &#125; &#125; printf(&quot;Case #%d: &quot;,cas++); for(int i=0; i&lt;n; i++) &#123; if(i==a1||a2==i)continue; printf(&quot;%d&quot;,a[i]); &#125; puts(&quot;&quot;); &#125; return 0;&#125; H题：Cosmic Cleaner 题意：问删除的球和原来给的这些球相交的体积有多少。 贴个求球相交的体积板子就行了0.0. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889 #include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#define CLR(a,b) memset(a,b,sizeof(a));using namespace std;const double PI = acos(-1);const int maxn= 105;typedef struct point &#123; double x,y,z; point() &#123; &#125; point(double a, double b,double c) &#123; x = a; y = b; z = c; &#125; point operator -(const point &amp;b)const &#123; //返回减去后的新点 return point(x - b.x, y - b.y,z-b.z); &#125; point operator +(const point &amp;b)const &#123; //返回加上后的新点 return point(x + b.x, y + b.y,z+b.z); &#125; //数乘计算 point operator *(const double &amp;k)const &#123; //返回相乘后的新点 return point(x * k, y * k,z*k); &#125; point operator /(const double &amp;k)const &#123; //返回相除后的新点 return point(x / k, y / k,z/k); &#125; double operator *(const point &amp;b)const &#123; //点乘 return x*b.x + y*b.y+z*b.z; &#125;&#125; point;double dist(point p1, point p2) &#123; //返回平面上两点距离 return sqrt((p1 - p2)*(p1 - p2));&#125;typedef struct sphere &#123;//球 double r; point centre;&#125; sphere;sphere s,a[maxn];void SphereInterVS(sphere a, sphere b,double &amp;v,double &amp;s) &#123; double d = dist(a.centre, b.centre);//球心距 double t = (d*d + a.r*a.r - b.r*b.r) / (2.0 * d);// double h = sqrt((a.r*a.r) - (t*t)) * 2;//h1=h2，球冠的高 double angle_a = 2 * acos((a.r*a.r + d*d - b.r*b.r) / (2.0 * a.r*d)); //余弦公式计算r1对应圆心角，弧度 double angle_b = 2 * acos((b.r*b.r + d*d - a.r*a.r) / (2.0 * b.r*d)); //余弦公式计算r2对应圆心角，弧度 double l1 = ((a.r*a.r - b.r*b.r) / d + d) / 2; double l2 = d - l1; double x1 = a.r - l1, x2 = b.r - l2;//分别为两个球缺的高度 double v1 = PI*x1*x1*(a.r - x1 / 3);//相交部分r1圆所对应的球缺部分体积 double v2 = PI*x2*x2*(b.r - x2 / 3);//相交部分r2圆所对应的球缺部分体积 v = v1 + v2;//相交部分体积 double s1 = PI*a.r*x1; //r1对应球冠表面积 double s2 = PI*a.r*x2; //r2对应球冠表面积 s = 4 * PI*(a.r*a.r + b.r*b.r) - s1 - s2;//剩余部分表面积&#125;int t, n;double x, y, z, r;int cas = 1;int main() &#123; cin &gt;&gt; t; while(t--) &#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%lf%lf%lf%lf&quot;,&amp;x,&amp;y,&amp;z,&amp;a[i].r); //其他球 a[i].centre = &#123;x,y,z&#125;; &#125; scanf(&quot;%lf%lf%lf%lf&quot;,&amp;x,&amp;y,&amp;z,&amp;r); s.r = r; s.centre = &#123;x,y,z&#125;; //中心球 double ans = 0, v = 0; for(int i = 1; i &lt;= n; i++) &#123; double ss, dis = dist(s.centre, a[i].centre); if(dis &gt;= s.r + a[i].r)continue; //在外部 if(dis + min(s.r, a[i].r) &lt;= max(s.r, a[i].r)) &#123; //在内部 ans += 4.0 / 3.0 * PI * min(s.r,a[i].r) * min(s.r,a[i].r) * min(s.r,a[i].r); continue; &#125; SphereInterVS(s, a[i], v, ss); //相交部分 ans += v; &#125; printf(&quot;Case #%d: %.14f\n&quot;,cas++,ans); &#125;&#125;//搜索板子，搜到的一名大佬的，我改都没改就直接过了0.0 K题：Sticks 预处理出所有分组情况，一共是 C(3,12)C(3,9)C(3,6) /24种。 15400种 让后暴力求解 15400*6000竟然判断过了0.0 题目没说要怎么输出答案，然后我用SET 错了，用vector 过了。。。。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot;&lt;&lt;endl;const int maxn=369605;int a[20];struct th &#123; short x[4][3]; bool operator&lt;(const th&amp; t) const &#123; &#125;&#125; dat,pa[maxn];int u[20],k=0;void dfs(int p) &#123; if(p==4) &#123; pa[k]=dat; k++; return ; &#125; for(int i=0; i&lt;12; i++) &#123; if(u[i])continue; if(dat.x[p-1][0]&gt;i)continue; //这个是去重的，会有重复的情况 for(int i2=i+1; i2&lt;12; i2++) &#123; if(u[i2])continue; for(int i3=i2+1; i3&lt;12; i3++) &#123; if(u[i3])continue; dat.x[p][0]=i; dat.x[p][1]=i2; dat.x[p][2]=i3; u[i]=u[i2]=u[i3]=1; dfs(p+1); u[i]=u[i2]=u[i3]=0; &#125; &#125; &#125;&#125;int t,cas=1;int main() &#123; dfs(0); debug(k); scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; for(int i=0; i&lt;12; i++) scanf(&quot;%d&quot;,&amp;a[i]); int num=0,ans; for(int i=0;i&lt;k;i++) &#123; int tnum=0; for(int j=0; j&lt;4; j++) &#123; int m1=a[pa[i].x[j][0]],m2=a[pa[i].x[j][1]],m3=a[pa[i].x[j][2]]; if(m1+m2&gt;m3&amp;&amp;m2+m3&gt;m1&amp;&amp;m3+m1&gt;m2)tnum++; &#125; if(tnum&gt;num) &#123; num=tnum; ans=i; &#125; if(num==4)break; &#125; printf(&quot;Case #%d: %d\n&quot;,cas++,num); if(num==0)continue; for(int j=0; j&lt;4; j++) &#123; int m1=a[pa[ans].x[j][0]],m2=a[pa[ans].x[j][1]],m3=a[pa[ans].x[j][2]]; if(m1+m2&gt;m3&amp;&amp;m2+m3&gt;m1&amp;&amp;m3+m1&gt;m2)&#123; printf(&quot;%d %d %d\n&quot;,m1,m2,m3); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-2019 ACM-ICPC, Asia Nanjing Regional Contest M]]></title>
    <url>%2F2019%2F01%2F23%2F2018-2019%20ACM-ICPC%2C%20Asia%20Nanjing%20Regional%20Contest%20M%2F</url>
    <content type="text"><![CDATA[2018-2019 ACM-ICPC, Asia Nanjing Regional Contest M 扩展KMP+马拉车回文串 s:ababa t:aba 题意：将第一个字符串的一个字串，与第二个字符串从 (0-k)的字符连在一起可以成为回文字符串，且第一个字符串字串的长度比第二个字符串的长度要大。 要构成的的回文字符串 两部分构成 s’ 第一个字符串的字串，和第二个字符串的前缀t’，构成一个回文字符串。 那么如果把第一个字符串倒过来， 那就相当于，s’ 的一部分是和 t’是相同的，s’还有一部分是回文字符串。 那么s’与t’相同的长度 * 从当前位置能够产生的回文串数量，就相当能够构成的回文串个数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot;&lt;&lt;endl;const int maxn=1e6+5;int nxt[maxn*2],ex[maxn*2];void getnext(char * str) &#123; int i=0,j,po,len=strlen(str); nxt[0]=len; while(i+1&lt;len&amp;&amp;str[i]==str[i+1])i++; nxt[1]=i; po=1,j=0; for(i=2; i&lt;len; i++) &#123; int p=nxt[po]+po; if(nxt[i-po]+i&lt;p) &#123; nxt[i]=nxt[i-po]; &#125; else &#123; j=p-i; if(j&lt;0)j=0; while(i+j&lt;len&amp;&amp;str[j]==str[j+i]) j++; nxt[i]=j; po=i; &#125; &#125;&#125;void exkmp(char *s1,char *s2) &#123; int i=0,j,po,len=strlen(s1),l2=strlen(s2); getnext(s2); while(s1[i]==s2[i]&amp;&amp;i&lt;l2&amp;&amp;i&lt;len)i++; ex[0]=i; po=0; for(i=1; i&lt;len; i++) &#123; int p=ex[po]+po; if(nxt[i-po]+i&lt;p) &#123; ex[i]=nxt[i-po]; &#125; else &#123; j=max(0,p-i); while(i+j&lt;len&amp;&amp;j&lt;l2&amp;&amp;s1[i+j]==s2[j]) &#123; j++; &#125; ex[i]=j; po=i; &#125; &#125;&#125;char Ma[maxn*2];int Mp[maxn*2],pos[maxn*2];int dp[maxn*2],cnt[maxn];void Manacher(char s[],int len) &#123; //一名大佬的写法0.0 memset(pos,-1,sizeof(pos)); int l=0; Ma[l++]=&apos;$&apos;; Ma[l++]=&apos;#&apos;; for(int i=0; i&lt;len; i++) &#123; pos[l]=i; Ma[l++]=s[i]; Ma[l++]=&apos;#&apos;; &#125; Ma[l]=0; int mx=0,id=0; for(int i=0; i&lt;l; i++) &#123; Mp[i]=mx&gt;i?std::min(Mp[2*id-i],mx-i):1; while(i-Mp[i]&gt;=0&amp;&amp;Ma[i+Mp[i]]==Ma[i-Mp[i]]) Mp[i]++; if(i+Mp[i]&gt;mx) &#123; mx=i+Mp[i]; id=i; &#125; &#125; for(int i=0; i&lt;l; i++) &#123; dp[i+Mp[i]-1]++; if(i&gt;0) dp[i-1]--; &#125; for(int i=l-1; i&gt;=0; i--) &#123; dp[i]+=dp[i+1]; &#125; for(int i=0; i&lt;l; i++) &#123; if(pos[i]==-1) continue; cnt[pos[i]]=dp[i]; &#125;&#125;char s[maxn],c[maxn];int main() &#123; scanf(&quot;%s%s&quot;,s,c); int len=strlen(s); reverse(s,s+len); Manacher(s,len); exkmp(s,c); LL ans=0; for(int i=1; i&lt;len; i++) &#123; ans+=1LL*cnt[i-1]*ex[i]; &#125; printf(&quot;%lld\n&quot;,ans); return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF201812 JAVA]]></title>
    <url>%2F2019%2F01%2F16%2FCCF201812%20JAVA%2F</url>
    <content type="text"><![CDATA[发现JAVA比C++慢了不止一星半点 C++能直接过，这个JAVA卡极限过了 第一二题，随便写一下没啥难度，直接写第4题的代码 CCF201812-4123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner input=new Scanner(System.in); int n,m,r; n=input.nextInt(); m=input.nextInt(); r=input.nextInt(); Point arr[]=new Point[m]; for(int i=0;i&lt;m;i++) arr[i]=new Point(); for(int i=0;i&lt;m;i++)&#123; arr[i].x=input.nextInt(); arr[i].y=input.nextInt(); arr[i].c=input.nextInt(); &#125; Arrays.sort(arr, new MyComprator()); int ans=0; int k=0; int []par=new int[m+1]; for(int i=1;i&lt;=m;i++)par[i]=i; for(int i=0;i&lt;m;i++)&#123; int x=find(arr[i].x,par),y=find(arr[i].y,par); if(x!=y) &#123; par[x] = y; ans = arr[i].c; k++; &#125; if(k==n-1)break; &#125; System.out.println(ans); &#125; static int find(int x,int[] par)&#123; return x==par[x] ? x : (par[x]=find(par[x],par)); &#125;&#125;class Point&#123; int x,y,c;&#125;class MyComprator implements Comparator &#123; public int compare(Object arg0, Object arg1) &#123; Point t1=(Point)arg0; Point t2=(Point)arg1; return t1.c&gt;t2.c? 1:-1; &#125;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 528 (Div. 2, based on Technocup 2019 Elimination Round 4)]]></title>
    <url>%2F2018%2F12%2F24%2FCodeforces%20Round%20528%20(Div.%202%2C%20based%20on%20Technocup%202019%20Elimination%20Round%204)%2F</url>
    <content type="text"><![CDATA[随手写一篇博客吧0.0 A. Right-Left Cipher 直接模拟，偶数在左边，奇数在右边。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;char s[maxn],t[maxn];int main() &#123; cin&gt;&gt;t; int l=strlen(t); int k=l-1; if(l&amp;1)k++; for(int i=0; i&lt;(l+1)/2; i++) &#123; s[k]=t[i]; k-=2; &#125; k=2; for(int i=(l+1)/2; i&lt;l; i++) &#123; s[k]=t[i]; k+=2; &#125; for(int i=1; i&lt;=l; i++)printf(&quot;%c&quot;,s[i]); return 0;&#125; B. Div Times Mod 直接暴力枚举啊，不就是 a*k+b=x b=n/a,直接暴力枚举n的因子。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;LL n,k;int main() &#123; cin&gt;&gt;n&gt;&gt;k; LL ans=inf*inf; for(LL i=1; i&lt;=n; i++) &#123; if(n%i==0&amp;&amp;n/i&lt;k) &#123; ans=min(ans,k*i+n/i); &#125; &#125; cout&lt;&lt;ans&lt;&lt;&quot;\n&quot;; return 0;&#125; C. Connect Three 直接想象怎么走最近，随便瞎几把写，数据有点水，我数组开小了都过了，结果被fst了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e3+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;int a[3],b[3];pair&lt;int,int&gt;p[3];int x[maxn*100],y[maxn*1000];int mp[maxn][maxn];int main() &#123; for(int i=0; i&lt;3; i++) &#123; scanf(&quot;%d%d&quot;,&amp;a[i],&amp;b[i]); p[i].first=a[i]; p[i].second=b[i]; &#125; sort(a,a+3); sort(b,b+3); sort(p,p+3); printf(&quot;%d\n&quot;,a[2]-a[0]+b[2]-b[0]+1); int x1=p[0].first,y1=p[0].second,x2=p[1].first,x3=a[2];// debug(x1);// debug(x2);// debug(x3); int k=0; for(int i=0;i&lt;=x2-x1;k++,i++)&#123; x[k]=x1+i; y[k]=y1; mp[x[k]][y[k]]=1; &#125; for(int i=0;i&lt;=b[2]-b[0];i++)&#123; if(mp[x2][b[0]+i])continue; x[k]=x2; y[k]=b[0]+i; mp[x[k]][y[k]]=1; k++; &#125; for(int i=1;i&lt;=x3-x2;i++)&#123; if(mp[x2+i][p[2].second])continue;// debug(y[0]); x[k]=x2+i; y[k]=p[2].second; k++;// debug(k); &#125; k=a[2]-a[0]+b[2]-b[0]+1; for(int i=0;i&lt;k;i++) printf(&quot;%d %d\n&quot;,x[i],y[i]); return 0;&#125; D. Minimum Diameter Tree 直径是通过权值分配来搞定的，要直径最大值最小。直径最大值肯定是从每一个叶子走到另一个叶子，所以直接算有多少个叶子，答案就是s*2.0/(叶子数量)。任意两个叶子之间的距离相同，就是最小。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;vector&lt;int&gt; G[maxn];int pre[maxn],in[maxn];int k[maxn],u[maxn];int main() &#123; int n; double s; scanf(&quot;%d%lf&quot;,&amp;n,&amp;s); for(int i=0; i&lt;n-1; i++) &#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); in[a]++; in[b]++; G[a].push_back(b); G[b].push_back(a); &#125; double ans=0; for(int i=1; i&lt;=n; i++) &#123; if(in[i]==1) &#123; ans+=1; &#125; &#125; printf(&quot;%.10f&quot;,s*2.0/ans); return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 526 (Div. 2)]]></title>
    <url>%2F2018%2F12%2F13%2FCodeforces%20Round%20526%20(Div.%202)%2F</url>
    <content type="text"><![CDATA[很久没写代码了。随便刷了一下CF C. The Fair Nut and String 先统计一下被’b’分隔的‘a’有多少个，放到一个数组里面，比如说，ababaaba a[0]=1,a[1]=1,a[2]=2,a[3]=1; 然后算一下总方案数，这个有点难解释，就是取这个之前所有的方案数*这个里面的个数，再加上只取这个里面的个数。 差不多就是这么算的:sum[i]=sum[i-1]*a[i]+a[i]; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;char s[maxn];LL ans[maxn];long long n,k,num,sum,ct;int main() &#123; scanf(&quot;%s&quot;,s); int l = strlen(s); k=0; ct=1; for(int i = 0 ; i &lt; l ; i ++) &#123; if(s[i]==&apos;a&apos;)&#123; n++; ct=0; &#125; if(s[i]==&apos;b&apos;)&#123; if(ct==0)ans[k++]=n; ct=1; n=0; &#125; &#125; if(!ct)ans[k++]=n; for(int i = 0 ; i &lt; k ; i++)&#123; sum+=sum*ans[i]; sum%=mod; sum+=ans[i]; sum%=mod; &#125; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125; D. The Fair Nut and the Best Path 这题是个树形DP，每次选最边上的节点，如果一个节点周围的节点只有一个没走过了就把这个节点加到队列里面取判断。 如果你选的节点是最大的油量中的一个，那么，一定等于周围两个最大且大于零的节点想加，且加上自己的油量。具体看代码吧，然后dp每次保存到这个节点最大油量。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,in[maxn];LL w[maxn],ans,dp[maxn];int used[maxn];struct two &#123; LL to,c;&#125;;int k;vector&lt;two&gt; G[maxn];int main() &#123; scanf(&quot;%d&quot;,&amp;n); for(int i = 1 ; i &lt;= n ; i ++) &#123; scanf(&quot;%lld&quot;,&amp;w[i]); &#125; two t; for(int i = 0 ; i &lt; n-1; i++) &#123; int u,v,c; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;c); t.c=c; t.to=v; G[u].push_back(t); t.to=u; G[v].push_back(t); in[u]++; in[v]++; &#125; queue&lt;int&gt;q; for(int i = 1 ; i &lt;= n ; i++) &#123; if(in[i]&lt;=1) &#123; q.push(i); &#125; &#125; LL max1=0,max2=0; LL ans=0; while(q.size()) &#123; int node=q.front(); q.pop(); max1=max2=0; for(auto i:G[node]) &#123; if(used[i.to]==1) &#123; LL temp=dp[i.to]-i.c; if(temp&gt;max1) &#123; swap(max1,temp); &#125; if(temp&gt;max2) &#123; swap(max2,temp); &#125; &#125; else &#123; in[i.to]--; if(in[i.to]&lt;=1)&#123; q.push(i.to); &#125; &#125; &#125; used[node]=1; LL temp=max1+max2+w[node]; ans=max(ans,temp); dp[node]=temp-max2; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[camera.ScreenToWorldPoint使用出现引用错误]]></title>
    <url>%2F2018%2F12%2F06%2Fcamera.ScreenToWorldPoint%E4%BD%BF%E7%94%A8%E5%87%BA%E7%8E%B0%E5%BC%95%E7%94%A8%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[使用camera.ScreenToWorldPoint出现如下错误 NullReferenceException: Object reference not set to an instance of an object PlayerController.FixedUpdate () (at Assets/Scenes/PlayerController.cs:37) 没有设置主相机]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity 3D 粒子播放]]></title>
    <url>%2F2018%2F12%2F03%2FUnity%203D%20%E7%B2%92%E5%AD%90%E6%92%AD%E6%94%BE%2F</url>
    <content type="text"><![CDATA[gameObject.GetCompoment().Play();播放 gameObject.GetCompoment().Pause();暂停 gameObject.GetCompoment().Stop();停止]]></content>
      <categories>
        <category>游戏</category>
        <category>U3D</category>
      </categories>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity3d开发中，用VS打开脚本文件不自动补全]]></title>
    <url>%2F2018%2F12%2F03%2Funity3d%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8C%E7%94%A8VS%E6%89%93%E5%BC%80%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6%E4%B8%8D%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%2F</url>
    <content type="text"><![CDATA[设置一下默认代码软件，这个是因为文件不是默认用VS打开的。 进入Edit-&gt;Preferences External Tools 把VS设成编辑器就可以了。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言实验十进制2进制16进制转换输出]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E8%BF%9B%E5%88%B62%E8%BF%9B%E5%88%B616%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[从键盘输入一个0–255之间的整数，在屏幕上显示出该整数对应的二进制和十六进制数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178 DATA SEGMENTMEG DB &apos;Please input a number(0~255):&apos;,0DH,0AH,&apos;$&apos;ME2 DB 0DH,0AH,&apos;Input a invalid number,exit!&apos;,0DH,0AH,&apos;$&apos;X DB ?Y DB 0AHBUF DB 10 DB ? DB 10 DUP(?)BU2 DB &apos;0&apos;,&apos;$&apos; DB 8 DUP(?) DATA ENDSCODE SEGMENT ASSUME DS:DATA,CS:CODESTART: MOV AX,DATA MOV DS,AX MOV AH,09H MOV DX,OFFSET MEG INT 21H MOV AH,0AH MOV DX,OFFSET BUF INT 21H MOV DL,BUF[1] CMP DL,3 JA ER MOV DL,BUF[2] CMP DL,0DH JZ PD CMP DL,&apos;0&apos; JB ER CMP DL,&apos;9&apos; JA ER SUB DL,&apos;0&apos; MOV X,DL MOV DL,BUF[3] CMP DL,0DH JZ PD CMP DL,&apos;0&apos; JB ER CMP DL,&apos;9&apos; JA ER MOV AL,X MUL Y SUB DL,&apos;0&apos; ADD AL,DL MOV X,AL MOV DL,BUF[4] CMP DL,0DH JZ PD CMP DL,&apos;0&apos; JB ER CMP DL,&apos;9&apos; JA ER SUB DL,&apos;0&apos; MOV AL,X CMP AL,19H JA ER MUL Y MOV BL,0FFH SUB BL,DL CMP AL,BL JA ER ADD AL,DL MOV X,ALPD: CMP X,0 JB ER CMP X,255 JA ER MOV AL,X MOV Y,AL CMP AL,0 JE XS MOV BL,BUF[1] MOV DI,BX MOV BU2[DI],&apos;$&apos; MOV BL,0AH AND AX,00FFH DIV BL DEC DI ADD AH,&apos;0&apos; MOV BU2[DI],AH MOV BL,AL CMP BL,0 JE XS MOV AL,BL MOV BL,0AH AND AX,00FFH DIV BL ADD AH,&apos;0&apos; DEC DI MOV BU2[DI],AH MOV BL,AL CMP BL,0 JE XS DEC DI MOV AL,BL MOV BL,0AH AND AX,00FFH DIV BL ADD AH,&apos;0&apos; MOV BU2[DI],AHXS: MOV AH,09H MOV DX,OFFSET BU2 INT 21H MOV AH,02H MOV DL,&apos;=&apos; INT 21H MOV CX,8 MOV AL,X SEC: MOV AL,Y MOV DI,CX MOV CL,1 ROL AL,CL MOV Y,AL AND AL,01H MOV DL,AL MOV AH,02H ADD DL,&apos;0&apos; INT 21H MOV CX,DI LOOP SEC MOV AH,02H MOV DL,&apos;B&apos; INT 21H MOV AH,02H MOV DL,&apos;=&apos; INT 21H MOV DL,X MOV CL,4 SHR DL,CL OR DL,30H CMP DL,39H JBE AD1 ADD DL,7AD1: MOV AH,2 INT 21H MOV DL,X AND DL,0FH OR DL,30H CMP DL,39H JBE AD2 ADD DL,7AD2: MOV AH,2 INT 21H MOV AH,02H MOV DL,&apos;H&apos; INT 21H MOV AH,4CH INT 21HER: MOV AH,09H MOV DX,OFFSET ME2 INT 21H MOV AH,4CH INT 21HCODE ENDS END START]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言实现显示16进制数]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E6%98%BE%E7%A4%BA16%E8%BF%9B%E5%88%B6%E6%95%B0%2F</url>
    <content type="text"><![CDATA[将内存单元存储的8个两位16进制数：01H, 25H, 38H, 62H, 8DH, 9AH, BAH, CEH依次显示在屏幕上。 直接转换。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 DATA SEGMENTBUF DB 01H,25H,38H,62H,8DH,9AH,0BAH,0CEHN DW $-BUFX DW 0DATA ENDSCODE SEGMENT ASSUME CS:CODE,DS:DATASTART: MOV AX,DATA MOV DS,AX MOV CX,NBE: MOV N,CX MOV BX,X MOV DL,BUF[BX] INC BX MOV X,BX CALL DELY MOV CX,N CMP CX,1 JE FINISH MOV DL,&apos;,&apos; MOV AH,2 INT 21H LOOP BEFINISH:MOV AX,4C00H INT 21HDELY PROC NEAR MOV BL,DL MOV CL,4 SHR DL,CL OR DL,30H CMP DL,39H JBE AD1 ADD DL,7AD1: MOV AH,2 INT 21H MOV DL,BL AND DL,0FH OR DL,30H CMP DL,39H JBE AD2 ADD DL,7AD2: MOV AH,2 INT 21H MOV DL,&apos;H&apos; MOV AH,2 INT 21H RETDELY ENDPCODE ENDS END START 打表法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 DATA SEGMENTBUF DB 01H,25H,38H,62H,8DH,9AH,0BAH,0CEHN DW $-BUFASCII DB 30H,31H,32H,33H,34H,35H,36H,37H,38H,39H DB 41H,42H,43H,44H,45H,46HX DW 0Y DB 0DATA ENDSCODE SEGMENT ASSUME CS:CODE,DS:DATASTART: MOV AX,DATA MOV DS,AX MOV CX,NBE: MOV N,CX MOV BX,X MOV DL,BUF[BX] INC BX MOV X,BX MOV CX,N CMP CX,1 JE FINISH MOV DL,&apos;,&apos; MOV AH,2 INT 21H LOOP BEFINISH:MOV AX,4C00H INT 21HDELY PROC NEAR MOV Y,DL MOV CL,4 SHR DL,CL MOV BX,OFFSET ASCII MOV AL,DL AND AL,0FH XLAT MOV DL,AL MOV AH,2 INT 21H MOV AL,Y AND AL,0FH XLAT MOV DL,AL MOV AH,2 INT 21H MOV DL,&apos;H&apos; MOV AH,2 INT 21H RETDELY ENDPCODE ENDS END START]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言实现冒泡法排序]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%86%92%E6%B3%A1%E6%B3%95%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[利用冒泡法排序算法，将内存单元存储的数35H，78H，25H，13H，8H，D2H由大到小进行排序。 1234567891011121314151617181920212223242526272829303132333435363738394041 DATA SEGMENTDAT DB 35H,78H,25H,13H,8H,0D2HDATA ENDSCODE SEGMENT ASSUME CS:CODE,DS:DATASTART: MOV AX,DATA MOV DS,AX MOV CX,5A1: MOV DI,CX MOV BX,0A2: MOV AL,DAT[BX] CMP AL,DAT[BX+1] JGE A3 XCHG AL,DAT[BX+1] MOV DAT[BX],ALA3: ADD BX,1 LOOP A2 MOV CX,DI LOOP A1 MOV DL,DAT[0] MOV CL,4 SHR DL,CL OR DL,30H CMP DL,39H JBE AD1 ADD DL,7AD1: MOV AH,2 INT 21H MOV DL,DAT[0] AND DL,0FH OR DL,30H CMP DL,39H JBE AD2 ADD DL,7AD2: MOV AH,2 INT 21H MOV AH,4CH INT 21HCODE ENDS END START]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言实现文本浏览器]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E6%B5%8F%E8%A7%88%E5%99%A8%2F</url>
    <content type="text"><![CDATA[运行程序后，屏幕显示“input number (1-3)：” 键入“1”后，显示“chapter1: introduction” 键入“2”后，显示“chapter2: designing method” 键入“3”后，显示“chapter3: experiment” 键入其他数字后，返回屏幕提示状态 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 data segmentstr db &apos;please input number(1-3):&apos;,&apos;$&apos;str1 db &apos;chapter1: introduction&apos;,&apos;$&apos;str2 db &apos;chapter2: designing method&apos;,&apos;$&apos;str3 db &apos;chapter3:experimenr&apos;,&apos;$&apos;table dw A1,A2,A3 data endscode segment assume cs:code,ds:datastart: mov ax,data mov ds,ax begin:mov dx,offset str mov ah,9 int 21h mov ah,01h int 21h cmp al,&apos;1&apos; jb finish cmp al,&apos;3&apos; ja finish and ax,000FH dec ax shl ax,1 mov bx,ax jmp table[bx] A1: mov dx,offset str1 mov ah,9 int 21h jmp enter A2: mov dx,offset str2 mov ah,9 int 21h jmp enter A3: mov dx,offset str3 mov ah,9 int 21h jmp enter finish: mov dl,0dh mov ah,2 int 21h mov dl,0ah int 21h jmp begin enter: mov ax,4c00h int 21hcode ends end start]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言实验将内存单元存储的字节数据的16进制数的低位输出到显示器并显示。]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%B0%86%E5%86%85%E5%AD%98%E5%8D%95%E5%85%83%E5%AD%98%E5%82%A8%E7%9A%84%E5%AD%97%E8%8A%82%E6%95%B0%E6%8D%AE%E7%9A%8416%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E4%BD%8E%E4%BD%8D%E8%BE%93%E5%87%BA%E5%88%B0%E6%98%BE%E7%A4%BA%E5%99%A8%E5%B9%B6%E6%98%BE%E7%A4%BA%E3%80%82%2F</url>
    <content type="text"><![CDATA[打表法： 1234567891011121314151617181920 DATA SEGMENTASCII DB 30H,31H,32H,33H,34H,35H,36H,37H,38H,39H DB 41H,42H,43H,44H,45H,46HHEX DB 0BHDATA ENDSCODE SEGMENT ASSUME CS:CODE,DS:DATASTART: MOV AX,DATA MOV DS,AX MOV BX,OFFSET ASCII MOV AL,HEX AND AL,0FH XLAT MOV DL,AL MOV AH,2 INT 21H MOV AX,4C00H INT 21HCODE ENDS END START 直接转换： 12345678910111213141516171819 DATA SEGMENTHEX DB 0BHDATA ENDSCODE SEGMENT ASSUME CS:CODE,DS:DATASTART: MOV AX,DATA MOV DS,AX MOV DL,HEX AND DL,0FH OR DL,30H CMP DL,39H JBE AD1 ADD DL,7AD1: MOV AH,2 INT 21H MOV AX,4C00H INT 21HCODE ENDS END START]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编实现大小字母转换]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B1%87%E7%BC%96%E5%AE%9E%E7%8E%B0%E5%A4%A7%E5%B0%8F%E5%AD%97%E6%AF%8D%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[从键盘键入一个大写英文字母，存放到内存单元BUF1中，再转化为对应的小写字母，存放到内存单元BUF2中。 1234567891011121314151617181920 data segmentbuf1 db ?buf2 db ?data endscode segmentassume ds:data,cs:codebegin:mov ax,datamov ds,axmov ah,01int 21hmov buf1,aladd al,20hmov buf2,almov dl,almov ah,02int 21hmov ah,4chint 21hcode endsend begin]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编实现一个简单加法程序。]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B1%87%E7%BC%96%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E5%8A%A0%E6%B3%95%E7%A8%8B%E5%BA%8F%E3%80%82%2F</url>
    <content type="text"><![CDATA[汇编语言，写一个简单加法程序“3+5=8”，加数和结果分别存在内存单元NUM1、NUM2、NUM3中。 12345678910111213141516 data segment num1 db 3 num2 db 5 num3 db ?data endscode segmentassume cs:code,ds:data start:mov ax,data mov ds,ax mov al,num1 add al,num2 mov num3,al mov ax,4c00h int 21hcode endsend start]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-CCSP杭州]]></title>
    <url>%2F2018%2F10%2F30%2F2018-CCSP%E6%9D%AD%E5%B7%9E%2F</url>
    <content type="text"><![CDATA[作为一个只学了一年的菜鸡，没想到竟然在CCSP上拿了一块金。只能说运气不错。 https://git.thusaac.org/publish/CCSP2018]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF 2018-09 题解]]></title>
    <url>%2F2018%2F09%2F17%2FCCF%202018-09%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[CCF 201809 1.就是求平均值，第一个和最后一个特判一下。 2.这题两种思路：第一种，直接n*n的判断有没有交叉的区间，有就直接加上去。第二种直接模拟时间轴，时间轴最大只有1e6，那个区间如果有覆盖就直接+1，然后两个人的区间覆盖，如果两个人都有这个区间就是2，数组为2的个数加起来就行了。由于区间长度是S-T，其实这个相当于[s,t),有一个是开区间。 3.请见 政大佬 4.记忆化DFS，开一个vis[400][400][400]的数组，vis[pos][i][j],pos表示位置，i，表示当前位置的值，j,表示前一个位置的值。然后就暴力枚举所有的值，如果那个值和前面一个的值已经访问过了就直接返回0。从小往大搜索，这样就可以保证字典序最小。 这题可以用第一题对拍一下哈哈 主要考点: 1.平均值，知道a[pos],b[pos-1],b[pos]可以推出b[pos+1]只有3种取值(满足(b[pos-1]+b[pos]+b[pos+1])/3==a[pos])； 2 记忆化搜索，因为每种状态后面都有3种取值所以暴力是，3^100复杂度，明显超时。所以要剪枝，就是前面说的vis数组。这样所有状态最多跑一次，总复杂度300^3,（实际上没有这么大）可以过。 5.你能开这一题，可以直接跳过我博客了。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[长沙理工集训队-9.11日组队赛]]></title>
    <url>%2F2018%2F09%2F15%2F%E9%95%BF%E6%B2%99%E7%90%86%E5%B7%A5%E9%9B%86%E8%AE%AD%E9%98%9F-9.11%E6%97%A5%E7%BB%84%E9%98%9F%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[好久没写博客了，写篇博客放松一下。 外网OJ：http://csustacm.com:4803/ 1题我就不写了这题写了也没啥意义。 2.黄金矿工 Description 游戏中有n个宝石，每个宝石有一个价值vi，每次挖出这个宝石需要时间ti。因为有些宝石被另外一个宝石挡住了（两个宝石在同一直线上），一个宝石最多挡住一个宝石，一个宝石最多被一个宝石挡住。要先捡起挡路的宝石，才能捡起该宝石。每个宝石的挡路宝石为fi，如果没有挡路宝石fi = 0，即它自己(题目保证没有环，且不存在)。 游戏的时间限制是t秒，在t秒内你获得最大价值和是多少？ Input 第一行一个整数T，表示接下来有T组数据。（T &lt;= 50） 每组数据格式如下： 第一行两个整数n（1&lt;=n&lt;=200），t（1&lt;=t&lt;=100,000,000） 接下来n行，每行三个整数vi（1&lt;=vi&lt;=50），ti（1&lt;=ti&lt;=1000,000），（0&lt;=fi&lt;=n） Output 输出获得的最大价值和 Sample Input 1 11 5 10 2 1 0 5 3 1 3 2 0 1 4 3 4 6 4 Sample Output 1 111 题意：挖宝石，挖某个宝石前可能有一个宝石，一个宝石也只能阻难一个宝石，挖某个宝石要消耗时间ti获得价值vi，问T=t秒最多可以挖宝石的最大价值。 题解：看了下数据范围，肯定是以价值DP，求价值的最小时间，如果时间小于所给定的时间就可以挖到相应价值。 首先处理下，每个宝石前后最多只有一个，肯定是一条链，把每条链处理一下（假如一条链是1-&gt;2-&gt;3,那么这条链上就有3个节点分别保存2个值，挖到1，(v1,t1）挖到2，（v1+v2,t1+t2）挖到3,(v1+v2+v3,t1+t2+t3))。最多只有200条链，所以不用担心超时。 每条链保存 两个值，价值和所需要的时间。然后在DP就行了。因为每条链上只能选一个值所以DP肯定要开二维。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 #include&lt;bits/stdc++.h&gt;#define fi first#define se secondusing namespace std;#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot;&lt;&lt;endl;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;const int maxn=1e3+7;const int inf=0x3f3f3f3f;int n, m, tot;int son[maxn];int in[maxn], v[maxn], t[maxn], vis[maxn];vector&lt;P&gt; ar[maxn];int dp[205][10005];void dfs(int u,int val,int tim) &#123; //用DFS，一条链 vis[u] = 1; ar[tot].push_back(make_pair(val+v[u],tim+t[u])); if(son[u] == 0)return; dfs(son[u],val+v[u],tim+t[u]);&#125;int main() &#123; int tim; scanf(&quot;%d&quot;, &amp;tim); while(tim--) &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int sum = 0; for(int i = 0; i &lt;= n; ++i) &#123; son[i]=vis[i]=0; ar[i].clear(); &#125; for(int i = 1, u; i &lt;= n; ++i) &#123; scanf(&quot;%d%d%d&quot;, &amp;v[i], &amp;t[i], &amp;u); sum += v[i]; //if(u == 0)continue; son[u] = i; &#125; tot = 0; for(int i = 1; i &lt;= n; ++i) &#123; if(vis[i] == 0) &#123;//如果这个节点没有父亲，就说明这有一条链。 dfs(i, 0, 0); tot++; &#125; &#125; memset(dp, 0x3f, sizeof(dp)); for(int i = 0; i &lt; tot; ++i) &#123; 。 ar[i].push_back(make_pair(0, 0));//每个链肯定可以一个都不挖，所以0 ，0要加进去。 sort(ar[i].begin(),ar[i].end()); &#125; int sz = ar[0].size(); for(int i = 0; i &lt; sz; ++i) &#123;//dp初始化 dp[0][ar[0][i].fi] = ar[0][i].se; &#125; for(int i = 1; i &lt; tot; ++i) &#123; sz = ar[i].size(); for(int j = 0; j &lt; sz; ++j) &#123; for(int k = sum; k &gt;= ar[i][j].fi; --k) &#123; dp[i][k] = min(dp[i-1][k-ar[i][j].fi]+ar[i][j].se,dp[i][k]); &#125; &#125; &#125; int ans = 0; for(int i = sum; i &gt;= 0; --i) &#123; if(dp[tot-1][i]&lt;=m) &#123; //找第一个小于等于给定时间的价值 ans = i; break; &#125; &#125; printf(&quot;%d\n&quot;, ans); &#125; return 0;&#125; 3.精灵王国 Description 小J离开了神秘群岛之后，来到了繁华的精灵王国。 精灵王国中有n个城市，现在已知第 i 个城市和第 i + 1个城市之间有一条长度为d[i]的双向道路。（特别的，第n个城市和第1个城市之间有一条长度为d[n]的双向道路）。 随着经济的发展，精灵王国的城市之间建立了m条地铁，第i条地铁可以从城市u[i]前往v[i]，也可以从v[i]前往u[i]，同时地铁的长度为w[i]。 现在小J在各个城市之间旅游，小J想知道从城市x前往城市y旅游需要花费多长的时间？ Input 第一行为2个整数n、m。 第二行为n个正整数d[i]。 接下来m行每行三个正整数u[i]、v[i]、w[i]。 第m+3行为一个正整数Q，表示询问次数。 接下来Q行每行两个正整数x、y，表示一次从城市x到城市y的旅行。 数据范围：1&lt;=n,q&lt;=1e5,1&lt;=m&lt;=30,1&lt;=u[i],v[i],x,y&lt;=n,1&lt;=d[i],w[i]&lt;=1e9; Output 输出Q行每行一个正整数表示该次旅行的最短时间。 Sample Input 1 14 1 1 2 3 6 1 3 2 5 1 2 1 4 1 3 2 3 4 3 Sample Output 1 11 5 2 2 3 看起来挺难的，其实是到原题。。，把数据范围改了一下，见牛客第二场挑战赛。 看起来很难，实际上简单的一匹，只有30条铁路，直接把有铁路的60个点直接全部跑一次最短路，然后问两个点之间的最短距离，要么坐了地铁，那么就是到60个点中的一个最短路加上从这个有铁路的点到另一个点的最短路，要么就是不做地铁，不做地铁一个前缀和就行了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e5+5;const int inf=0x3f3f3f3f;int n,m;int d[maxn];LL dp[maxn];vector&lt;int&gt; v;bool u[maxn];struct edge &#123; int to,next; LL w;&#125; eg[maxn*3];int tot,head[maxn];void add(int u,int v,int w) &#123; eg[tot].to=v; eg[tot].w=w; eg[tot].next=head[u]; head[u]=tot++;&#125;LL dis[65][maxn];int main() &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); mem(head,-1); for(int i = 1; i &lt;= n ; i ++) &#123; scanf(&quot;%d&quot;,&amp;d[i]); dp[i]=dp[i-1]+d[i]; if(i==n) &#123; add(1,n,d[i]); add(n,1,d[i]); &#125; else &#123; add(i,i+1,d[i]); add(i+1,i,d[i]); &#125; &#125; while(m--) &#123; int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); if(u[a]==0) &#123; v.push_back(a); u[a]=1; &#125; if(u[b]==0) &#123; v.push_back(b); u[b]=1; &#125; add(a,b,c); add(b,a,c); &#125; mem(dis,inf); priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; q; for(int i = 0 ; i &lt; v.size(); i ++) &#123; dis[i][v[i]]=0; q.push(P(0,v[i])); while(q.size()) &#123; int u = q.top().second; q.pop(); for(int j = head[u]; j!=-1; j=eg[j].next) &#123; edge &amp;e=eg[j]; if(dis[i][e.to]&gt;dis[i][u]+e.w) &#123; dis[i][e.to]=dis[i][u]+e.w; q.push(P(dis[i][e.to],e.to)); &#125; &#125; &#125; &#125; int Q; scanf(&quot;%d&quot;,&amp;Q); while(Q--) &#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); if(a&gt;b)swap(a,b); LL ans=min(dp[b-1]-dp[a-1],dp[n]-(dp[b-1]-dp[a-1])); for(int i =0 ; i &lt;v.size(); i++) &#123;// debug(dis[i][a]+dis[i][b]); ans=min(ans,dis[i][a]+dis[i][b]); &#125; printf(&quot;%lld\n&quot;,ans); &#125; return 0;&#125; 5.zzq的数学教室2 Description zzq想保研，他的成绩单上有一排非递减顺序的成绩，面试时老师想知道他数学成绩的位置，zzq知道他的数学成绩是x分，他要找到第一个出现x的位置。 他想运用二分查找算法， 代码如下： 显然L就是最终的位置。 可是现在他的成绩全被lcy学姐打乱了（随机把数字乱放）。 他想知道最后找到的位置仍然是原来的位置的概率， 请你帮帮他。 概率是在模1e9 + 7意义下的， 即 p / q = p * inv(q) 。inv(q)是q在模1e9 + 7 意义下的逆元。 Input 输入第一行一个正整数N。 第二行N个正整数a[i]，代表的是原来的成绩单，呈非递减顺序。 第三行一个数字x，代表他的数学成绩。 1 &lt;= N &lt;= 1e5 1 &lt;= a[i] &lt;= 1e9 x保证是某一个a[i]。 Output 输出一个整数代表概率。 Sample Input 1 18 1 1 1 3 7 9 9 10 1 Sample Output 1 11 Sample Input 2 13 1 2 2 2 Sample Output 2 1333333336 Hint 对于第二个样例，lcy学姐可能打乱成这3种等概率的情况： 1 2 2 2 1 2 2 2 1 其中只有第一种会结果正确。 概率是1 / 3。 题解：水题，直接把小于x的个数，a，和大于x的个数算出来b，然后照这个二分写法一路把答案算下去就行了；具体看代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e5+5;const int inf=0x3f3f3f3f;int l,r;LL pow(LL x,LL n) &#123; LL ans=1; while(n) &#123; if(n&amp;1)ans=ans*x%mod; x=x*x%mod; n&gt;&gt;=1; &#125; return ans;&#125;int n,x;int a[maxn];int main() &#123; scanf(&quot;%d&quot;,&amp;n); for(int i = 1 ; i &lt;= n ; i ++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; scanf(&quot;%d&quot;,&amp;x); LL mx=0,mi=0; for(int i = 1; i&lt;=n; i++) &#123; if(a[i]&gt;=x) &#123; mx++;//大于等于x的个数 &#125; else &#123; mi++;//小于等于x的个数 &#125; &#125; int l=1,r=n; LL ans=1; while(l&lt;=r) &#123; int mid=(l+r)/2; if(a[mid]&gt;=x) &#123; ans=ans*mx%mod*pow(mi+mx,mod-2)%mod;//需要一个选一个大于等于x的数，选到的概率是(mx/(mi+mx)); mx--; r=mid-1; &#125; else &#123; ans=ans*mi%mod*pow(mi+mx,mod-2)%mod;//同上。 mi--; l=mid+1; &#125; &#125; printf(&quot;%lld\n&quot;,ans); return 0;&#125; 6.zzq的数学教室 Description 众所周知，摸鱼是qwb的一大爱好。即使是在zzq的数学课上，qwb也是在疯狂摸鱼。这被眼尖的zzq发现了，所以zzq决定考考摸鱼的qwb，如果qwb答不出来，他的平时分自然就归零了。 现在zzq把数字1~n从左至右排成一排（第i个数的值为i），接下来进行m轮操作，每次操作描述如下：将奇数位置的数字取出形成序列A，将偶数位置的数字取出形成序列B，将A序列拼接在B序列之后，构成新的序列。 现在问题来了：进行m次操作后，第k个位置的数字是多少呢？ Input 第一行，输入2个正整数n,q 接下来q行，每行2个整数m和k，表示zzq想知道在m次操作之后第k个位置上的数是多少。 数据范围： n&lt;=5000 q&lt;=1e6 m&lt;=1e6 k&lt;=n; Output 输出q行，每行输出第k个位置的数字。 Sample Input 1 15 2 1 2 2 3 Sample Output 1 14 2 水题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 #include&lt;bits/stdc++.h&gt;using namespace std;#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot;&lt;&lt;endl;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;const int maxn=5e3+7;const int inf=0x3f3f3f3f;int n,q;int ar[maxn], br[maxn];int ans[maxn][maxn];int main()&#123; while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;q))&#123; for(int i = 1; i &lt;= n; ++i)&#123; ar[i] = ans[0][i] = i; &#125; int tot, tim = 1; do&#123; tot = 1; for(int i = 2; i &lt;= n; i += 2)&#123; ans[tim][tot] = ans[tim-1][i]; //printf(&quot;%d &quot;, ans[tim][tot]); tot++; &#125; for(int i = 1; i &lt;= n; i += 2)&#123; ans[tim][tot] = ans[tim-1][i]; //printf(&quot;%d &quot;, ans[tim][tot]); tot++; &#125; int flag = 0; for(int i = 1; i &lt;= n; ++i)&#123; if(ans[tim][i] != ar[i])flag = 1; &#125; if(flag == 0)break; tim ++; &#125;while(1); //printf(&quot;*%d\n&quot;,tim); int m, k; while(q--)&#123; scanf(&quot;%d%d&quot;, &amp;m, &amp;k); m %= tim; if(m == 0)m = tim; printf(&quot;%d\n&quot;, ans[m][k]); &#125; &#125; return 0;&#125; 7.玩游戏 Description dr喜欢玩游戏，现在有n个游戏，每个游戏时间为[Li,Ri)，现在问题是，找出最长的一段游戏时间，使得该时间段被至少k个游戏完全覆盖(这k个区间要每一个都要完全覆盖你选出来的这个区间）。 Input 多组输入 第一行n,k(1&lt;=n,k&lt;1e6) 接下来n行，每行两个数l,r(1&lt;=l&lt;r&lt;=1e9) Output 输出这个区间的长度 Sample Input 1 13 2 1 5 1 4 1 3 Sample Output 1 13 贪心就好，每次从最先结束的一个线段开始选，然后找最小的k小于当前线段结束点的起点，然后满足条件的区间就是当前区间的终点减去k个起始点中最大值。找完这个线段的终点后把这个区间删掉，然后依次类推下去知道找完所有的线段。本来每次找k个小于当前线段的结束点起始点需要一个操作，但是因为数据有点水，被我水过去了。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 #include&lt;bits/stdc++.h&gt;using namespace std;#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot;&lt;&lt;endl;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;const int maxn=1e6+7;const int inf=0x3f3f3f3f;struct th &#123; int st,en,id; bool operator &lt;(const th a)const &#123; if(en==a.en) &#123; return st&lt;a.st; &#125; else return en&lt;a.en; &#125;&#125; a[maxn];bool u[maxn];priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt;q;int main() &#123; int n,m; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)) &#123; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d%d&quot;,&amp;a[i].st,&amp;a[i].en); a[i].id=i; q.push(P(a[i].st,i)); &#125; sort(a,a+n); int cnt=0,ans=0,L=0; memset(u,0,sizeof(u)); for(int i =0; i&lt;n; i++) &#123; if(!u[a[i].id])cnt++; u[a[i].id]=1; L=a[i].st; //本来这是要找最大值的，但是数据有点水，直接就过去了。。。 while(cnt&lt;m&amp;&amp;q.size()) &#123; if(u[q.top().second]==1) &#123; q.pop(); continue; &#125; else if(q.top().first&gt;=a[i].en) &#123; break; &#125; else &#123; cnt++; u[q.top().second]=1; L=max(L,q.top().first); q.pop(); &#125; &#125; if(cnt==m) &#123; ans=max(ans,a[i].en-L); &#125; cnt--; &#125; while(q.size())q.pop(); printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125; 9.签到题 Description “素数就是因子只包含1和它本身的数”zzq如是说道。 现在zzq的数学课下课了，他发现qwb在他的课摸鱼，于是要出一个题考qwb：N！的素因子有多少个？ 如果qwb做不出来就要被py交易！但是qwb完全不知道zzq上课讲了什么，于是向从来不摸鱼的你求助了（划重点：这是简单题）。 Input 第一行输入一个整数T（T \leq 10T≤10），表示有T组数据。 每组数据输入站一行，输入一个整数N（N \leq 10^5N≤105） Output 对于每组数据，输出N!有多少个素因子 Sample Input 1 12 1 4 Sample Output 1 10 4 如题目。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;const int maxn=1e5+7;const int inf=0x3f3f3f3f;int prim[maxn], p[maxn], pcnt;int sum[maxn];int main() &#123; int t; prim[0]=1; prim[1]=1; pcnt = 0; for(int i =2; i &lt; maxn; i++) &#123; if(!prim[i]) p[pcnt++] = i; for(int j = 0; j &lt; pcnt&amp;&amp;i*p[j]&lt;maxn; ++j) &#123; prim[i*p[j]] = 1; if(i%p[j] == 0)break; &#125; &#125; sum[0] = 0; sum[1] = 0; sum[2] = 1; for(int i = 3; i &lt; maxn; ++i) &#123; int tmp = i,cnt = 0; if(prim[i] == 0) &#123; sum[i]=sum[i-1]+1; continue; &#125; for(int j = 0; j &lt; pcnt; ++j) &#123; while(tmp % p[j] == 0) &#123; tmp /= p[j]; cnt++; &#125; if(tmp == 1)break; &#125; if(tmp!=1)cnt++; sum[i] = sum[i-1] + cnt; &#125; int n; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;, &amp;n); printf(&quot;%d\n&quot;, sum[n]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF傻逼题，201709-5-除法---暴力可以过？？？？？]]></title>
    <url>%2F2018%2F09%2F06%2FCCF%E5%82%BB%E9%80%BC%E9%A2%98%EF%BC%8C201709-5-%E9%99%A4%E6%B3%95---%E6%9A%B4%E5%8A%9B%E5%8F%AF%E4%BB%A5%E8%BF%87%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[这题特么无语，史上最无语没有之一，C++纯暴力过 90？？？？，JAVA纯暴力过了？？？？？？？？？？？？，tell me ，发生了什么，这题为什么能暴力。 CCF如果JAVA熟练，建议大家用JAVA。 http://118.190.20.162/view.page?gpid=T59 JAVA纯暴力AC代码。。。。。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 //import java.lang.reflect.Array;import java.math.*;import java.util.Arrays;import java.util.Scanner;//import om.sun.swing.internal.plaf.basic.resources.basic;public class Main &#123; static int[] a= new int[100005]; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int n = input.nextInt(),m = input.nextInt(); for(int i= 1 ; i &lt;= n ; i ++) &#123; a[i] = input.nextInt(); &#125; int op,l,r,v; for(int j=0;j&lt;m;j++) &#123;// op = input.nextInt(); l = input.nextInt(); r = input.nextInt(); if(op==1) &#123; v = input.nextInt(); if(v == 1)continue; for(int i = l ; i &lt;= r; i ++) &#123; if(a[i] &gt;= v &amp;&amp; a[i] % v == 0) &#123; a[i] /= v; &#125; &#125; &#125; else &#123;// l=input.nextInt();// r=input.nextInt(); long ans=0; for(int i=l;i&lt;=r;i++) &#123; ans += a[i]; &#125; System.out.println(ans); &#125; &#125;// System.out.println(ans); &#125;&#125; C++纯暴力，过 90%，这个可以理解。。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;const long long mod=1e9+7;const int maxn=1e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int A[maxn];int n,m;int main() &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;A[i]); &#125; while(m--) &#123; int op,l,r,v; scanf(&quot;%d%d%d&quot;,&amp;op,&amp;l,&amp;r); if(op==1) &#123; scanf(&quot;%d&quot;,&amp;v); if(v==1)continue; while(l&lt;=r) &#123; if(A[l]&gt;=v&amp;&amp;A[l]%v==0) &#123; A[l]/=v; &#125; l++; &#125; &#125; else &#123; long long ans=0; while(l&lt;=r) &#123; ans+=A[l++]; &#125; printf(&quot;%lld\n&quot;,ans); &#125; &#125; return 0;&#125; C++，AC代码。也是半个暴力。因为每个数去除最多只能除 32次，（因为数的最大值只有1e6,每次就算只除2，也不能除多少次，所以这个更新可以暴力，并不会超时。复杂度最高也只有 32 N logN,重点在于处理前缀和），不会再多，所以只需要用一个树状数组维护前缀和即可，每次更新值，直接暴力能不能除，然后再更新值即可。 考察两点：1.暴力更新值（注意特判除1），2.树状数组求前缀和。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;const long long mod=1e9+7;const int maxn=1e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int A[maxn];long long bit[maxn];int n,m;long long sum(int i) &#123; long long ans=0; while(i&gt;0) &#123; ans+=bit[i]; i-=i&amp;-i; &#125; return ans;&#125;void add( int i, int x) &#123; while(i&lt;=n) &#123; bit[i]+=x; i += i&amp;-i; &#125;&#125;int main() &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;A[i]); add(i,A[i]); &#125; while(m--) &#123; int op,l,r,v; scanf(&quot;%d%d%d&quot;,&amp;op,&amp;l,&amp;r); if(op==1) &#123; scanf(&quot;%d&quot;,&amp;v); if(v==1)continue; while(l&lt;=r) &#123; if(A[l]&gt;=v&amp;&amp;A[l]%v==0) &#123; add(l,0-A[l]+A[l]/v); A[l]/=v; &#125; l++; &#125; &#125; else &#123; printf(&quot;%lld\n&quot;,sum(r)-sum(l-1)); &#125; &#125; return 0;&#125; 细心的孩子，肯定一定发现了。。。。。。。。。，JAVA暴力，6s 。C++树状数组7s，我竟无言以对。暴力比树状数组快，这数据出的挺好的。。。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2013-2014 Summer Petrozavodsk Camp, Andrew Stankevich Contest 44 (ASC 44)]]></title>
    <url>%2F2018%2F08%2F31%2F2013-2014%20Summer%20Petrozavodsk%20Camp%2C%20Andrew%20Stankevich%20Contest%2044%20(ASC%2044)%2F</url>
    <content type="text"><![CDATA[暑训最后一场组队训练赛，特么故意的，把别人的WF练习题给我们写，写了半天才签到两题。靠！ B - Braess’s Paradox Gym - 100518B 题意：有几个点，每个点到下一个点之间有两条路。上面一条路的通过时间是 AK1+B,下面一条通过时间是CK2+D，要两条路通过的时间数尽量相同，K1+K2=1(K1,K2是经过的人流量占总人数的比例)。然后中间的点可以建驿站，如果中间的点不建驿站，就相当于直接从起点到终点，只有两条路，如果建了驿站，就相当于从起点到驿站，再从驿站到终点。 题解：前两个直接算出来就行，一个驿站都不建，就相当于两条路，把所有点上面那条路，ai.bi,加起来就是上面那一条路的A,B，同理，下面一条路就是所有的,ci,di加起来。每个都建就是相当于一个个点走过去，暴力啊，一个点到另一个点的时间，然后全加起来就行了。后面两个就是求最小通过时间的和最大通过时间，看似很难，其实就是一个很简单的DP，N^2的复杂度不会超时。首先预处理从起点到当前点的A,B,C,D。然后每个点的时间就是从前面某一个点建驿站的最小值，最大值转移过来。直接过来上面路的A，B就用两个前缀相减。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;ll,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e3+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;int a[maxn],b[maxn],c[maxn],d[maxn];double qza[maxn],qzb[maxn],qzc[maxn],qzd[maxn];double dp1[maxn],dp2[maxn];double ans1,ans2,ans3,ans4;int main() &#123; freopen(&quot;braess.in&quot;,&quot;r&quot;,stdin); freopen(&quot;braess.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d%d%d%d&quot;,&amp;a[i],&amp;b[i],&amp;c[i],&amp;d[i]); &#125; double A=0,B=0,C=0,D=0; for(int i=1; i&lt;=n; i++) &#123; //第一种结果都不建，A相当于所有点之间的a[i]相加 A+=a[i]; B+=b[i]; C+=c[i]; D+=d[i]; &#125; double k; if(A+C!=0) &#123; k=min(1.0,(D+C-B)/(A+C));//k1最大值不能超过1 ans1=k*A+B; if(k&lt;=0) &#123; //k1最小值不能小于0，如果小于等于0说明所有人都走下面一条路 ans1=C+D; &#125; &#125; else &#123; ans1=min(B,D); //如果AC都等于零，那就直接判断B，D大小 &#125; ans2=0; for(int i=1; i&lt;=n; i++) &#123; A=a[i]; //所有的点一个个算 B=b[i]; C=c[i]; D=d[i]; double temp; if(A+C!=0) &#123; k=min(1.0,(D+C-B)/(A+C)); temp=k*A+B; if(k&lt;=0) &#123; temp=C+D; &#125; &#125; else &#123; temp=min(B,D); &#125; ans2+=temp; &#125; for(int i=1; i&lt;=n; i++) &#123; //求前缀 qza[i]=qza[i-1]+a[i]; qzb[i]=qzb[i-1]+b[i]; qzc[i]=qzc[i-1]+c[i]; qzd[i]=qzd[i-1]+d[i]; dp1[i]=inf; &#125; dp1[0]=0; for(int i=1; i&lt;=n; i++) &#123; for(int j=0; j&lt;i; j++) &#123; A=qza[i]-qza[j]; B=qzb[i]-qzb[j]; //ABCD等于上一个状态和当前状态的差值， C=qzc[i]-qzc[j]; D=qzd[i]-qzd[j]; double temp; if(A+C!=0) &#123; k=min(1.0,(D+C-B)/(A+C)); temp=k*A+B; if(k&lt;=0) &#123; temp=C+D; &#125; &#125; else &#123; temp=min(B,D); &#125; dp1[i]=min(dp1[i],dp1[j]+temp); //dp1保留最小值，从j驿站转移到i驿站的最小值 dp2[i]=max(dp2[i],dp2[j]+temp); //最大值 &#125; &#125; ans3=dp1[n]; ans4=dp2[n]; printf(&quot;%.10f\n%.10f\n%.10f\n%.10f\n&quot;,ans1,ans2,ans3,ans4); return 0;&#125; I - Intelligent Tourist Gym - 100518I 题意：有N场考试，第i考试需要复习pi天，考试时间是di，考试的时间没法复习，如果没有复习多天那场考试就不会去，就会去复习其他考试，中间有些天有活动，活动时间是s-t活动时间不会去复习，问最多能通过机场考试。 题解：贪心，这题贼他妈傻逼，漏看了一个条件，DEBUG一个小时。。。，从后面往前面扫，每次选需要复习时间最少的一场考试，因为这个时间只能给后面的所以不用担心选的考试时间已经过了，至于考试时间不能复习，你直接把考试也当作复习的时间，不去考试就相当于少复习这种科目一天，去了就相当于多复习一天。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;ll,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,m;struct one &#123; ll d,p; int id; bool operator&lt;(const one a)const &#123; return d&lt;a.d; &#125;&#125; X;struct two &#123; ll st,en; bool operator&lt;(const two a)const &#123; return st&lt;a.st; &#125;&#125; H;priority_queue&lt;one&gt; q1;priority_queue&lt;two&gt; q2;priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt;q;int main() &#123; freopen(&quot;intelligent.in&quot;,&quot;r&quot;,stdin); freopen(&quot;intelligent.out&quot;,&quot;w&quot;,stdout); while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n) &#123; vector&lt;int&gt; v; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%I64d%I64d&quot;,&amp;X.d,&amp;X.p); X.p++; X.id=i+1; q1.push(X); &#125; scanf(&quot;%d&quot;,&amp;m); for(int i=0; i&lt;m; i++) &#123; scanf(&quot;%I64d%I64d&quot;,&amp;H.st,&amp;H.en); q2.push(H); &#125; while(q2.size()) &#123; if(q2.top().st&gt;q1.top().d) &#123; q2.pop(); &#125; else break; &#125; while(q1.size()) &#123; X=q1.top(); q1.pop(); ll temp; if(q1.size()==0)temp=0; else temp=q1.top().d; ll tim=0; tim=X.d-temp; while(q2.size()) &#123; H=q2.top(); if(H.st&gt;temp) &#123; q2.pop(); tim-=H.en-H.st+1; &#125; else break; &#125; if(X.p==0) &#123; v.push_back(X.id); &#125; else q.push(P(X.p,X.id)); while(tim&gt;0&amp;&amp;q.size()) &#123; P temp2=q.top(); q.pop(); if(tim&gt;=temp2.first) &#123; tim-=temp2.first; v.push_back(temp2.second); &#125; else &#123; temp2.first-=tim; tim=0; q.push(temp2); &#125; &#125; &#125; while(q1.size())q1.pop(); while(q2.size())q2.pop(); while(q.size())q.pop(); sort(v.begin(),v.end()); int ans=v.size(); printf(&quot;%d\n&quot;,ans); for(int i=0; i&lt;ans; i++) &#123; printf(&quot;%d&quot;,v[i]); if(ans==i+1)printf(&quot;\n&quot;); else printf(&quot; &quot;); &#125; if(ans==0)puts(&quot;&quot;); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[傻瓜级git命令理解]]></title>
    <url>%2F2018%2F08%2F27%2F%E5%82%BB%E7%93%9C%E7%BA%A7git%E5%91%BD%E4%BB%A4%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[git clone wangzhi.com —克隆对应网址仓库 git pull –更新仓库 git add -A 添加到缓冲区， git commit -m“your name” 更新本地仓 git push 提交上网络仓库 上面3个连着用就行了。 git config —global user.name “输入你的用户名” git config —global user.email “输入你的邮箱” 初始化下身份照着打就行了]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The 17th Zhejiang University Programming Contest Sponsored by TuSimple(浙江省赛)]]></title>
    <url>%2F2018%2F08%2F27%2FThe%2017th%20Zhejiang%20University%20Programming%20Contest%20Sponsored%20by%20TuSimple(%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9B)%2F</url>
    <content type="text"><![CDATA[A - Marjar Cola ZOJ - 3948 签到题，x,y,a,b,都很小直接暴力。判断INF，只要判断次数有没有过多就行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int main() &#123; int x,y,a,b; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; int ans=0; scanf(&quot;%d%d%d%d&quot;,&amp;x,&amp;y,&amp;a,&amp;b); if(x==1||y==1)puts(&quot;INF&quot;); else &#123; while(a&gt;=x||y&lt;=b) &#123; if(a&gt;=x) &#123; a-=x; a++; b++; ans++; &#125; else &#123; b-=y; b++; a++; ans++; &#125;// debug(a);// debug(b); if(ans&gt;3e5)&#123; break; &#125; &#125; if(ans&gt;3e5)&#123; puts(&quot;INF&quot;); &#125; else printf(&quot;%d\n&quot;,ans); &#125; &#125; return 0;&#125; C - How Many Nines ZOJ - 3950 打个表，比较考虑细节，真的难处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e4+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int Year[maxn], Mon[35], pre1[maxn], pre2[35];int hh[13], mon[13];bool leap(int y)&#123; if(y%400==0)return 1; if(y%100==0)return 0; if(y%4==0)return 1; return 0;&#125;int nine(int y)&#123; int cnt = 0; while(y)&#123; if(y%10==9)cnt++; y/=10; &#125; return cnt;&#125;void init()&#123; Mon[1]=Mon[3]=Mon[5]=Mon[7]=Mon[8]=Mon[10]=Mon[12]=3;///31 Mon[2]=2; Mon[4]=Mon[6]=Mon[9]=Mon[11] = 3;///30 Mon[9] += 30; hh[1]=hh[3]=hh[5]=hh[7]=hh[8]=hh[10]=hh[12]=31; hh[2] = 28; hh[4]=hh[6]=hh[9]=hh[11]=30; mon[0] = 0; for(int i = 1; i &lt;= 12; ++i)&#123; mon[i] = hh[i]+mon[i-1]; &#125; int sum = 0;pre1[1999]=pre2[0] = 0; for(int i = 1; i &lt;= 12; ++i)&#123; sum += Mon[i]; pre2[i] = pre2[i-1]+Mon[i]; &#125; for(int i = 2000; i &lt;= 9999; ++i)&#123; int tmp = nine(i); if(tmp)&#123; Year[i] = sum + tmp*365; if(leap(i))Year[i] += tmp + 1; &#125;else&#123; Year[i] = sum; if(leap(i))++Year[i]; &#125; pre1[i] = pre1[i-1]+Year[i]; &#125;&#125;int get(int d)&#123; if(d&lt;=9)return 3; if(d&lt;=19)return 2; if(d&lt;=29)return 1; return 0;&#125;int main()&#123;#ifndef ONLINE_JUDGE //freopen(&quot;E://ADpan//in.in&quot;, &quot;r&quot;, stdin); //freopen(&quot;E://ADpan//out.out&quot;, &quot;w&quot;, stdout); #endif init(); int tim;scanf(&quot;%d&quot;,&amp;tim); while(tim--)&#123; int y1,m1,d1,y2,m2,d2; scanf(&quot;%d%d%d%d%d%d&quot;,&amp;y1,&amp;m1,&amp;d1,&amp;y2,&amp;m2,&amp;d2); if(y1==y2)&#123; if(m1==m2)&#123; int ans = get(d1)-get(d2+1); if(m1==9)ans += d2-d1+1; int tmp = nine(y1); ans += tmp*(d2-d1+1); printf(&quot;%d\n&quot;, ans); continue; &#125; int ans = pre2[m2-1]-pre2[m1]; if(leap(y1)&amp;&amp;2&gt;m1&amp;&amp;2&lt;m2)ans++; ans += get(d1) + 3 - get(d2+1); if(m1==2&amp;&amp;leap(y1)==false)ans--; if(m1==9)&#123; ans+=30-d1+1; &#125; if(m2==9)&#123; ans += d2; &#125; int tmp = nine(y1); if(tmp)&#123; int day = mon[m2-1]-mon[m1] + (hh[m1] - d1 + 1) + d2; if(leap(y1)&amp;&amp;2&gt;m1&amp;&amp;2&lt;m2)day++; if(leap(y1)&amp;&amp;m1==2)day++; ans += day*tmp; &#125; printf(&quot;%d\n&quot;, ans); &#125;else&#123; int ans = pre1[y2-1]-pre1[y1]; int a = 0, b = 0, tmp = nine(y1),day; a = pre2[12]-pre2[m1]; a += get(d1); if(leap(y1)==0&amp;&amp;m1==2)a--; if(leap(y1)&amp;&amp;m1==1)a++; if(m1==9)a += 30-d1+1; b = pre2[m2-1]; b += 3-get(d2+1); if(leap(y2)&amp;&amp;m2&gt;2)b++; if(m2==9)b+=d2; if(tmp)&#123; day = mon[12]-mon[m1] + (hh[m1] - d1 + 1); if(leap(y1)&amp;&amp;m1&lt;=2)day++; a += tmp * day; &#125; tmp = nine(y2); if(tmp)&#123; day = mon[m2-1] + d2; if(leap(y2)&amp;&amp;m2&gt;2)day++; b += tmp * day; &#125; ans += a+b; printf(&quot;%d\n&quot;, ans); &#125; &#125; return 0;&#125; F - Knuth-Morris-Pratt Algorithm ZOJ - 3957 签到题，KMP，判断一下次数就行。暴力判断也没事 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;char ch1[]=&quot;dog&quot;,ch2[]=&quot;cat&quot;;int nex[2000];void get_next(char *t,int lent)&#123; nex[0] = -1; for(int i = 0,k = -1;i &lt; lent;)&#123; if(k==-1||t[i] == t[k])&#123; ++k;++i; nex[i]=k; &#125;else k = nex[k]; &#125;&#125;int kmp(char *s,int lens,char *t,int lent)&#123; if(lens&lt;lent)return 0; get_next(t,lent); int i = 0, j = 0; int cnt = 0; while(i &lt; lens&amp;&amp;j&lt;lent) &#123; if(j==-1||s[i] == t[j])&#123; i++;j++; if(j==lent)&#123; cnt++; j = nex[j]; &#125; &#125;else j=nex[j]; &#125; return cnt;&#125;int main() &#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; char s[2000]; scanf(&quot;%s&quot;,s); int l=strlen(s); int ans=0; ans+=kmp(s,l,ch1,3); ans+=kmp(s,l,ch2,3); printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125; G - Intervals ZOJ - 3953 贪心，真的贪的内心崩溃。贪心策略，按L排序，每次判断3个区间，如果出现3个重合，丢去 R最大的，因为影响最大。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;struct seg &#123; int st,en,id; bool operator &lt; (const seg a )const &#123; return en&lt;a.en; &#125;&#125; sg[maxn];bool cmp(seg a,seg b) &#123; if(a.st==b.st) &#123; return a.en&lt;b.en; &#125; return a.st&lt;b.st;&#125;int res[maxn];int main() &#123; int n,t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d%d&quot;,&amp;sg[i].st,&amp;sg[i].en); sg[i].id=i+1; &#125; sort(sg,sg+n,cmp); priority_queue&lt;seg&gt;q; int ans=0; for(int i=0; i&lt;n; i++) &#123; if(q.size()&lt;2) &#123; q.push(sg[i]); &#125; else &#123; q.push(sg[i]); seg s[3]; for(int i=0; i&lt;3; i++) &#123; s[i]=q.top(); q.pop(); &#125; if(s[0].st&lt;=s[2].en&amp;&amp;s[1].st&lt;=s[2].en) &#123; res[ans++]=s[0].id; q.push(s[1]); q.push(s[2]); &#125; else &#123; q.push(s[0]); q.push(s[1]); &#125; &#125; &#125; sort(res,res+ans); printf(&quot;%d\n&quot;,ans); for(int i=0; i&lt;ans; i++) &#123; printf(&quot;%d&quot;,res[i]); if(i+1==ans)printf(&quot;\n&quot;); else printf(&quot; &quot;); &#125; if(ans==0)puts(&quot;&quot;); &#125; return 0;&#125; H - Seven-Segment Display ZOJ - 3954 题意 ：1-9九个数，分别可以用后面7个0 1表示，下面给你n个数，每个数后面跟有7个01串，你可以交换n个数任意两列。如果可以通过交换表示出来输出YES 否则NO。 例子 : 17 0101011 1 1101011 把第2列和第5列交换，变成 11 1001111 7 0001111 与1 7 的表示匹配，所以输出YES 题解：这题只有9个数，暴力啊匹配，n^2都不会超时。。。；我是把每一列的状态用一个10进制数保存，每次能够从原来的数里面找与之匹配的状态，如果找不到，就输出NO； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int mp[10];int n;int k[10],v[10];int p[10];map&lt;int,int&gt; m;int main() &#123; mp[1]=1001111; mp[2]=10010; mp[3]=110; mp[4]=1001100; mp[5]=100100; mp[6]=100000; mp[7]=1111; mp[8]=0; mp[9]=100; int t; p[0]=1; for(int i=1; i&lt;10; i++) &#123; p[i]=p[i-1]*10; &#125; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d%d&quot;,&amp;k[i],&amp;v[i]); &#125; m.clear(); for(int i=0; i&lt;7; i++) &#123; int sum=0; for(int j=0; j&lt;n; j++) &#123; sum+=mp[k[j]]/p[i]%10*p[j]; &#125; m[sum]++; &#125; int flag=1; for(int i=0; i&lt;7; i++) &#123; int sum=0; for(int j=0; j&lt;n; j++) &#123; sum+=v[j]/p[i]%10*p[j]; &#125; m[sum]--; if(m[sum]&lt;0) &#123; flag=0; break; &#125; &#125; puts(flag?&quot;YES&quot;:&quot;NO&quot;); &#125; return 0;&#125; J - Course Selection System ZOJ - 3956 傻逼题,一开始还在想怎么推公式，结果发现，CI的和只有5e4，枚举所用能够到的状态H 的和最大不久行了，直接转换成了 0 1 背包。。。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e4+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;int a[maxn];int x[maxn],y[maxn];int main() &#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]); &#125; mem(a,-1); a[0]=0; for(int i=0; i&lt;n; i++) &#123; for(int j=5e4-y[i]; j&gt;=0; j--) &#123; if(a[j]!=-1) &#123; a[j+y[i]]=max(a[j+y[i]],a[j]+x[i]); &#125; &#125; &#125; ll ans=0; for(ll i=1;i&lt;=5e4;i++)&#123; if(a[i]!=-1) ans=max(ans,1LL*a[i]*a[i]-i*a[i]-i*i); &#125; printf(&quot;%lld\n&quot;,ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCPC2018中国大学生程序设计竞赛 - 网络选拔赛]]></title>
    <url>%2F2018%2F08%2F27%2FCCPC2018%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%20-%20%E7%BD%91%E7%BB%9C%E9%80%89%E6%8B%94%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[HDU 6438 1001 Buy and Resell Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 2282 Accepted Submission(s): 359 Problem Description The Power Cube is used as a stash of Exotic Power. There are n cities numbered 1,2,…,n where allowed to trade it. The trading price of the Power Cube in the i-th city is ai dollars per cube. Noswal is a foxy businessman and wants to quietly make a fortune by buying and reselling Power Cubes. To avoid being discovered by the police, Noswal will go to the i-th city and choose exactly one of the following three options on the i-th day: spend ai dollars to buy a Power Cube resell a Power Cube and get ai dollars if he has at least one Power Cube do nothing Obviously, Noswal can own more than one Power Cubes at the same time. After going to the n cities, he will go back home and stay away from the cops. He wants to know the maximum profit he can earn. In the meanwhile, to lower the risks, he wants to minimize the times of trading (include buy and sell) to get the maximum profit. Noswal is a foxy and successful businessman so you can assume that he has infinity money at the beginning. Input There are multiple test cases. The first line of input contains a positive integer T (T≤250), indicating the number of test cases. For each test case: The first line has an integer n. (1≤n≤105) The second line has n integers a1,a2,…,an where ai means the trading price (buy or sell) of the Power Cube in the i-th city. (1≤ai≤109) It is guaranteed that the sum of all n is no more than 5×105. Output For each case, print one line with two integers —— the maximum profit and the minimum times of trading to get the maximum profit. Sample Input 1 3 4 1 2 10 9 5 9 5 9 10 5 2 2 1 Sample Output 1 16 4 5 2 0 0 _Hint_ In the first case, he will buy in 1, 2 and resell in 3, 4. _profit = - 1 - 2 + 10 + 9 = 16_ In the second case, he will buy in 2 and resell in 4. _profit = - 5 + 10 = 5_ In the third case, he will do nothing and earn nothing. _profit = 0_ 贪心，每次保留买，和卖两种状态，如果一种买了，说明后面有一定有可以卖的，从前往后扫每次取前面最小的，如果遇见能从卖了的里面取，总次数不用+2，如果是从买了的里面取，总交易次数+2； 用，0，1分别代表买和卖。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int a[maxn];int n;priority_queue&lt;P&gt;q;ll sum=0,ans=0;int main() &#123; int t; cin&gt;&gt;t; while(t--) &#123; sum=0; ans=0; scanf(&quot;%d&quot;,&amp;n); while(q.size())q.pop(); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); q.push(P(-a[i],0)); q.push(P(-a[i],1)); int temp=a[i]+q.top().first; if(q.top().second==0) &#123; ans+=2; &#125; q.pop(); sum+=temp; &#125; printf(&quot;%lld %lld\n&quot;,sum,ans); &#125; return 0;&#125; HDU 6441 1004 Find Integer 更具费马大定理，n&gt;2 和等于 0误解，n=1，直接输出 1 a+1; n=2 的时候，就是一个勾股定理，a^2=cc-bb = (c-b)(c+b) 如果A为偶数 c-b=2 c+b=aa/2 ,如果a为奇数 c-b=1 c+b=a*a 解个方程就行了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int main() &#123; int t; cin&gt;&gt;t; while(t--) &#123; ll n,k; scanf(&quot;%lld%lld&quot;,&amp;k,&amp;n); if(k==0||k&gt;2)puts(&quot;-1 -1&quot;); else if(k==1) &#123; if(n==1e9)puts(&quot;-1 -1&quot;); else printf(&quot;%lld %lld\n&quot;,1,n+1); &#125; else &#123; ll temp=n; if(n==1||n==2)puts(&quot;-1 -1&quot;); else if(n&amp;1) &#123; ll c=(temp*temp+1)/2; ll b=c-1; if(c&gt;1e9)puts(&quot;-1 -1&quot;); else &#123; printf(&quot;%lld %lld\n&quot;,b,c); &#125; &#125; else &#123; ll c=n*n/4+1,b=c-2; if(c&gt;1e9)puts(&quot;-1 -1&quot;); else printf(&quot;%lld %lld\n&quot;,b,c); &#125; &#125; &#125; return 0;&#125; HDU 6446 1009 Tree and Permutation 直接算一条边左右两边点的个数，全排列种，每条边经过的次数等于 ，2C,(n-m)(m)*(n-1)！次，一个DFS求出他根节点的数量为m，前一条边 权值为C,求一下所有数的和，预处理阶乘。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;struct edge &#123; int to,cost,next;&#125; eg[maxn];int head[maxn],tot;void init() &#123; mem(head,-1); tot=0;&#125;void add(int u,int v,int c) &#123; eg[tot].to=v; eg[tot].cost=c; eg[tot].next=head[u]; head[u]=tot++;&#125;ll k[maxn];ll c[maxn],num[maxn];int dfs(int r,int p,int v) &#123; c[r]=v%mod; int ans=1; for(int i=head[r]; i!=-1; i=eg[i].next) &#123; if(eg[i].to!=p) &#123; ans+=dfs(eg[i].to,r,eg[i].cost); &#125; &#125; num[r]=ans%mod; return ans;&#125;int main() &#123; k[1]=1; for(int i=2; i&lt;=1e5; i++) &#123; k[i]=k[i-1]*i%mod; &#125; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; init(); for(int i=1; i&lt;n; i++) &#123; int u,v,c; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;c); add(u,v,c); add(v,u,c); &#125; dfs(1,-1,0); ll sum=0; for(int i=2; i&lt;=n; i++) &#123; sum+=2*c[i]*num[i]%mod*(n-num[i])%mod*k[n-1]%mod; sum%=mod; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第九届福建省大学生程序设计竞赛-重现赛（感谢承办泉州师范学院）]]></title>
    <url>%2F2018%2F08%2F26%2F%E7%AC%AC%E4%B9%9D%E5%B1%8A%E7%A6%8F%E5%BB%BA%E7%9C%81%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-%E9%87%8D%E7%8E%B0%E8%B5%9B%EF%BC%88%E6%84%9F%E8%B0%A2%E6%89%BF%E5%8A%9E%E6%B3%89%E5%B7%9E%E5%B8%88%E8%8C%83%E5%AD%A6%E9%99%A2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[A - Uint47 calculator FZU - 2294 水题，用unsigned long long,自带自动溢出，然后就可以随便写了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));ull mod=1;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;string s;map&lt;string,ull&gt; mp;int main() &#123; char op[100]; string tx,ty; ull x,y; for(int i=1;i&lt;48;i++)&#123; mod*=2; &#125; while(~scanf(&quot;%s&quot;,op)) &#123; if(op[0]==&apos;d&apos;&amp;&amp;op[1]==&apos;e&apos;) &#123; //def cin&gt;&gt;s&gt;&gt;x; mp[s]=x; cout&lt;&lt;s&lt;&lt;&quot; = &quot;&lt;&lt;x&lt;&lt;&apos;\n&apos;; &#125; else if(op[0]==&apos;s&apos;) &#123; //sub cin&gt;&gt;tx&gt;&gt;ty; x=mp[tx]; y=mp[ty]; mp[tx]=x=(x-y+mod)%mod; cout&lt;&lt;tx&lt;&lt;&quot; = &quot;&lt;&lt;x&lt;&lt;&apos;\n&apos;; &#125; else if(op[0]==&apos;a&apos;) &#123; cin&gt;&gt;tx&gt;&gt;ty; x=mp[tx]; y=mp[ty]; mp[tx]=x=(x+y)%mod; cout&lt;&lt;tx&lt;&lt;&quot; = &quot;&lt;&lt;x&lt;&lt;&apos;\n&apos;; &#125; else if(op[0]==&apos;m&apos;&amp;&amp;op[1]==&apos;u&apos;) &#123; cin&gt;&gt;tx&gt;&gt;ty; x=mp[tx]; y=mp[ty]; mp[tx]=x=(x*y)%mod; cout&lt;&lt;tx&lt;&lt;&quot; = &quot;&lt;&lt;x&lt;&lt;&apos;\n&apos;; &#125; else if(op[0]==&apos;d&apos;) &#123; cin&gt;&gt;tx&gt;&gt;ty; x=mp[tx]; y=mp[ty]; mp[tx]=x=(x/y)%mod; cout&lt;&lt;tx&lt;&lt;&quot; = &quot;&lt;&lt;x&lt;&lt;&apos;\n&apos;; &#125; else &#123; cin&gt;&gt;tx&gt;&gt;ty; x=mp[tx]; y=mp[ty]; mp[tx]=x=x%y; cout&lt;&lt;tx&lt;&lt;&quot; = &quot;&lt;&lt;x&lt;&lt;&apos;\n&apos;; &#125; &#125; return 0;&#125; B - Human life FZU - 2295 最大权闭合子图，k只有5暴力枚举所有状态。然后就是一个裸题了。 答案 是最大正权值-去最大流。如果有人想了解为啥，自行百度吧。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e3+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int v[maxn];int pre[maxn][maxn];int u[maxn];int n,m,K;int a[2][5];int ku[maxn];vector&lt;int&gt; tv[maxn];struct edge &#123; int to,cap,rev;&#125;;vector &lt;edge&gt; G[maxn];int level[maxn];int iter[maxn];void init(int _n) &#123; for(int i=0; i&lt;=_n; i++) &#123; G[i].clear(); tv[i].clear(); &#125; mem(pre,0); mem(u,0);&#125;void init()&#123; for(int i=0;i&lt;=n+m+1;i++)G[i].clear();&#125;void bfs(int s) &#123; memset(level,-1,sizeof(level)); queue&lt;int&gt; que; level[s]=0; que.push(s); while(!que.empty()) &#123; int v= que.front(); que.pop(); for(int i=0; i&lt;G[v].size(); i++) &#123; edge &amp; e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0) &#123; level[e.to]=level[v] + 1; que.push(e.to); &#125; &#125; &#125;&#125;void add(int from,int to,int cap) &#123; edge eg; eg.to=to; eg.cap=cap; eg.rev=G[to].size(); G[from].push_back(eg); eg.to=from; eg.cap=0; eg.rev=G[from].size()-1; G[to].push_back(eg);&#125;int dfs(int v,int t,int f) &#123; if(v == t)return f; for(int &amp;i = iter[v]; i &lt; G[v].size(); i++) &#123; edge &amp;e=G[v][i]; if(e.cap&gt;0 &amp;&amp; level[v]&lt;level[e.to]) &#123; int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0) &#123; e.cap-=d; G[e.to][e.rev].cap+=d; return d; &#125; &#125; &#125; return 0;&#125;int maxflow(int s,int t) &#123; int flow=0; for(;;) &#123; bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while((f = dfs(s,t,INF))&gt;0) &#123; flow +=f; &#125; &#125;&#125;void dfs(int r) &#123; u[r]=1; for(int i=1; i&lt;=n; i++) &#123; if(pre[r][i]) &#123; if(u[i]==0) &#123; dfs(i); &#125; for(int j=1; j&lt;=n; j++) &#123; pre[r][j]|=pre[i][j]; &#125; &#125; &#125;&#125;int main() &#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;K); init(n+m+1); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;v[i]); int k; scanf(&quot;%d&quot;,&amp;k); if(k==0)u[i]=1; for(int j=0; j&lt;k; j++) &#123; int x; scanf(&quot;%d&quot;,&amp;x); pre[i][x]=1; &#125; &#125; for(int i=1; i&lt;=n; i++) &#123; if(u[i]==0) &#123; dfs(i); &#125; &#125; for(int i=n+1; i&lt;=n+m; i++) &#123; scanf(&quot;%d&quot;,&amp;v[i]); int k; bool tu[maxn]= &#123;0&#125;; scanf(&quot;%d&quot;,&amp;k); for(int j=0; j&lt;k; j++) &#123; int x; scanf(&quot;%d&quot;,&amp;x); if(tu[x])continue; tu[x]=1; for(int l=1; l&lt;=n; l++) &#123; tu[l]|=pre[x][l]; &#125; &#125; for(int j=1; j&lt;=n; j++) &#123; if(tu[j]) &#123; tv[i].push_back(j); &#125; &#125; &#125; for(int i=0; i&lt;K; i++) &#123; scanf(&quot;%d%d&quot;,&amp;a[0][i],&amp;a[1][i]); &#125; int mx=0; for(int i=0; i&lt;1&lt;&lt;K; i++) &#123; mem(ku,0); init(); for(int j=0; j&lt;K; j++) &#123; ku[a[(i&gt;&gt;j)&amp;1][j]+n]=1;// debug(a[(i&gt;&gt;j)&amp;1][j]+n); &#125; int sum=0; for(int i=n+1; i&lt;=n+m; i++) &#123; if(ku[i]==1)continue;// debug(i); add(0,i,v[i]); for(int j=0; j&lt;tv[i].size(); j++) &#123; add(i,tv[i][j],inf); &#125; sum+=v[i]; &#125; for(int i=1; i&lt;=n; i++)add(i,n+m+1,v[i]); mx=max(sum-maxflow(0,n+m+1),mx); &#125; printf(&quot;%d\n&quot;,mx); &#125; return 0;&#125; D - Number theory FZU - 2297 一开始还以为是大数，java 了一发，大数了一发，全都TLE，正解就是一个线段树。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e3+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int c[maxn][maxn];int q[maxn][maxn];int b2[maxn];long long pow(long long x,long long n,long long mod=1e9+7) &#123; long long res=1; while(n&gt;0) &#123; if(n&amp;1)res=res*x%mod; x=x*x%mod; n&gt;&gt;=1; &#125; return res%mod;&#125;int main() &#123; c[1][1]=1; c[1][0]=1; for(int i=1; i&lt;1e3+1; i++) &#123; c[i+1][0]=1;// printf(&quot;%d &quot;,c[i+1][0]); for(int j=1; j&lt;=i+1; j++) &#123; c[i+1][j]=(c[i][j-1]+c[i][j])%mod;// printf(&quot;%d &quot;,c[i+1][j]); &#125; &#125; for(int i=1; i&lt;1e3+1; i++) &#123; for(int j=0; j&lt;=i; j++) &#123; q[i][j+1]=(q[i][j]+c[i][j])%mod; &#125; &#125; b2[0]=1; for(int i=1; i&lt;1e3+1; i++) &#123; b2[i]=(b2[i-1]*2)%mod; &#125; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); if(m&gt;n) &#123; puts(&quot;0&quot;); &#125; else &#123; cout&lt;&lt;(q[n][n+1]-q[n][m]+mod)%mod*pow(b2[n],mod-2,mod)%mod&lt;&lt;endl; &#125; &#125; return 0;&#125; E - Traffic jamFZU - 2298 最短路，处理下到某个点的情况，如果是红灯，时间变为到绿灯开始。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int a[maxn];int cost[maxn];int n,m;struct edge &#123; int to,c,next;&#125; eg[maxn*2];int head[maxn],tot,vis[maxn];void init() &#123; mem(head,-1); tot=0;&#125;void add(int u,int v,int c) &#123; eg[tot].to=v; eg[tot].c=c; eg[tot].next=head[u]; head[u]=tot++;&#125;int main() &#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; init(); for(int i=0; i&lt;m; i++) &#123; int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); add(a,b,c); add(b,a,c); &#125; int st,en; scanf(&quot;%d%d&quot;,&amp;st,&amp;en); queue&lt;int&gt; q; q.push(st); mem(cost,inf); mem(vis,0); cost[st]=0; while(q.size()) &#123; int v=q.front(); q.pop(); vis[v]=0; for(int i=head[v]; i!=-1; i=eg[i].next) &#123; int d=cost[v]+eg[i].c,to=eg[i].to; if(to!=en&amp;&amp;(d/a[to])&amp;1)d=(d/a[to]+1)*a[to]; if(d&lt;cost[to]) &#123; cost[to]=d; if(vis[to]==0) &#123; vis[to]=1; q.push(to); &#125; &#125; &#125; &#125; printf(&quot;%d\n&quot;,cost[en]); &#125; return 0;&#125; G - IoU FZU - 2300 签到题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));ull mod=1;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;string s;map&lt;string,ull&gt; mp;int T;struct node &#123; ll x,y,w,h;&#125;a[3];int main() &#123; scanf(&quot;%d&quot;, &amp;T); while (T --) &#123; scanf(&quot;%lld %lld %lld %lld&quot;, &amp;a[0].x,&amp;a[0].y,&amp;a[0].w,&amp;a[0].h); scanf(&quot;%lld %lld %lld %lld&quot;, &amp;a[1].x,&amp;a[1].y,&amp;a[1].w,&amp;a[1].h); ll wi = (min(a[0].x+a[0].w, a[1].x+a[1].w)-max(a[0].x, a[1].x)); ll hi = (min(a[0].y+a[0].h, a[1].y+a[1].h)-max(a[0].y, a[1].y)); ll un; if(wi &gt; 0 &amp;&amp; hi &gt; 0) un = wi*hi; else un = 0; //debug(un); ll sum = a[0].w*a[0].h+a[1].w*a[1].h-un; //debug(sum); printf(&quot;%.2f\n&quot;, 1.0*un/sum); &#125; return 0;&#125;/*61 1 1 11 1 2 21 1 2 11 1 1 21 1 2 22 0 1 10 3 3 32 2 2 10 3 3 32 4 5 51 1 1 1-100 -100 1 1*/ H - Chosen by god FZU - 2301 题意：n点伤害随机分配，求分配到敌人身上大于等于m，的期望，就是求C(M,N)+…+C(M,N); 题解：打个组合数的表，然后前缀处理一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e3+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int c[maxn][maxn];int q[maxn][maxn];int b2[maxn];long long pow(long long x,long long n,long long mod=1e9+7) &#123; long long res=1; while(n&gt;0) &#123; if(n&amp;1)res=res*x%mod; x=x*x%mod; n&gt;&gt;=1; &#125; return res%mod;&#125;int main() &#123; c[1][1]=1; c[1][0]=1; for(int i=1; i&lt;1e3+1; i++) &#123; c[i+1][0]=1;// printf(&quot;%d &quot;,c[i+1][0]); for(int j=1; j&lt;=i+1; j++) &#123; c[i+1][j]=(c[i][j-1]+c[i][j])%mod;// printf(&quot;%d &quot;,c[i+1][j]); &#125; &#125; for(int i=1; i&lt;1e3+1; i++) &#123; for(int j=0; j&lt;=i; j++) &#123; q[i][j+1]=(q[i][j]+c[i][j])%mod; &#125; &#125; b2[0]=1; for(int i=1; i&lt;1e3+1; i++) &#123; b2[i]=(b2[i-1]*2)%mod; &#125; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); if(m&gt;n) &#123; puts(&quot;0&quot;); &#125; else &#123; cout&lt;&lt;(q[n][n+1]-q[n][m]+mod)%mod*pow(b2[n],mod-2,mod)%mod&lt;&lt;endl; &#125; &#125; return 0;&#125; J - Mind control FZU - 2303 题意：n个人，m个蛋糕，你把蛋糕给一个人，他后面的人也会被选上，例如选1 ，2 3 4 5 ….等都会被选上，选 3 4 5 …都会被选上，求选上人数的期望。 题解：给蛋糕的总肯能是C（M,N），选的人最高为1 的选择种数是，C（M-1,N-1），选一个蛋糕给1，然后其他蛋糕给他后面的人，以此类推，最高为2 选择种数是 ,C(M-1,N-2)，最高为3 可能是 C（m-1,N-3）; 然后权值乘以概率就是期望 ，NC(M-1,N-1)+(N-1)C(M-1,N-2)+….+M*C(M-1,M-1)/C(M,N)； 看到权值是 N,N-1肯定要化进组合数 ，大答案m/m, 就可以化成MC(M,N)+M(M,N-1)+…..+MC(M,M)/C(M,N)； 在化简 MC(M+1,N+1)/C(M,N)最后化为M(N+1)/(M+1)； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;long long pow(long long x,long long n,long long mod=1e9+7) &#123; long long res=1; while(n&gt;0) &#123; if(n&amp;1)res=res*x%mod; x=x*x%mod; n&gt;&gt;=1; &#125; return res%mod;&#125;void read(ll &amp;sum) &#123; sum=0; int flag=0; char ch=getchar(); while(!(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)) &#123; if (ch == &apos;-&apos;) &#123; flag = 1; &#125; ch=getchar(); &#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)sum=sum*10+ch-48,ch=getchar(); if(flag)sum*=-1;&#125;int main() &#123; ll t; read(t); while(t--) &#123; ll n,m; read(n); read(m); cout&lt;&lt;m*(n+1)%mod*pow(m+1,mod-2,mod)%mod&lt;&lt;&quot;\n&quot;; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016CCPC东北地区大学生程序设计竞赛 - 重现赛]]></title>
    <url>%2F2018%2F08%2F23%2F2016CCPC%E4%B8%9C%E5%8C%97%E5%9C%B0%E5%8C%BA%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%20-%20%E9%87%8D%E7%8E%B0%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[A 题目连接：HDU 5922 Minimum’s Revenge 水题，每次连接上1就行，就是一个等差数列。 123456789101112131415161718192021222324252627282930313233343536373839404142434445 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int main() &#123; int n,t,cas=1; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d&quot;,&amp;n); ll res=n; printf(&quot;Case #%d: %lld\n&quot;,cas++,(res+2)*(res-1)/2); &#125; return 0;&#125; B 题目链接：HDU 5923 Prediction 题意：一棵树，每个点代表一条边，每次选择几个点，需要把他的祖先也选上，然后把图里面相应的边连接上，问连接后的图有多少个联通块。 题解：可持续化并查集，每个顶点开一个并查集，维护从根节点到当前节点已经连接的图，再把自己这条边连上。 查询，把所有点的并查集合并一下就可以，然后输出合并后并查集块的个数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 #include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=5e2+2;const int maxm=1e4+5;bool u[maxm];int par[maxm][maxn];struct node &#123; int x,y; int fa;&#125; tree[maxm];int n,m;int find(int y,int x) &#123; return par[y][x]==x?x:par[y][x]=find(y,par[y][x]);&#125;void dfs(int x) &#123; int fa=tree[x].fa; u[x]=1; if(u[fa]==0) &#123; dfs(fa); &#125; else &#123; if(x==1) &#123;// cout&lt;&lt;&quot;1asd&quot;&lt;&lt;endl; for(int i=0; i&lt;=n; i++)par[1][i]=i; par[1][tree[x].x]=tree[x].y; &#125; else &#123; for(int i=0; i&lt;=n; i++)par[x][i]=par[fa][i]; int X=find(x,tree[x].x),Y=find(x,tree[x].y); if(X!=Y) &#123; par[x][X]=par[x][Y]; &#125; &#125; &#125;&#125;int main() &#123; int t,cas=1; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=m; i++) &#123; if(i==1)tree[i].fa=1; else &#123; int x; scanf(&quot;%d&quot;,&amp;x); tree[i].fa=x; &#125; &#125; for(int i=1; i&lt;=m; i++) &#123; u[i]=0; scanf(&quot;%d%d&quot;,&amp;tree[i].x,&amp;tree[i].y); &#125; for(int i=1; i&lt;=m; i++) &#123; if(!u[i]) &#123; dfs(i); &#125; &#125; int q; scanf(&quot;%d&quot;,&amp;q); printf(&quot;Case #%d:\n&quot;,cas++); while(q--) &#123; int k,s; scanf(&quot;%d&quot;,&amp;k); int res=0; for(int i=0; i&lt;=n; i++)par[0][i]=i; while(k--) &#123; scanf(&quot;%d&quot;,&amp;s);// for(int i=1; i&lt;=n; i++)printf(&quot;%d &quot;,par[s][i]); for(int i=1; i&lt;=n; i++) &#123; int t1=find(0,i),t2=find(s,i); if(t1!=t2) &#123; int t3=find(0,t2); if(t3!=t1) &#123; res++; par[0][t1]=par[0][t3]; &#125; &#125; &#125; &#125; printf(&quot;%d\n&quot;,n-res); &#125; &#125; return 0;&#125; C 题目连接：HUD 5924 Mr. Frog’s Problem A/B+ B/A 只有在两个数最接近的时候最小，所以如果A&lt;=C&lt;D&lt;=B,C /D+D/C必定小于于等 A/B+B/A所以只有和A B相同的时候才会满足条件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;ll a,b,t,n;int main() &#123; int cas=1; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;a&gt;&gt;b; printf(&quot;Case #%d:\n&quot;,cas++); if(a==b) &#123; puts(&quot;1&quot;); cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl; &#125; else &#123; puts(&quot;2&quot;); cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl; cout&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;a&lt;&lt;endl; &#125; &#125; return 0;&#125; D 题目连接:HDU 5925 Coconuts 题意：给你一个R*C的矩阵中间有几个n个点，问分成了几个联通块，联通块的大小是多少。 题解：R，C范围是1e9肯定是要离散，离散之后变成了一个不到 2000*2000的矩阵，求联通块数量直接DFS一遍就可以了。 问题来了了，离散之后怎么求每个块的大小呢。 首先你是根据行和列分别离散，计算主要是把离散掉的重新算回来。 如下图加入黄色是你被覆盖的格子，你会把横着离散黑色的格子为一个格子，红色的竖着离散成一个格子。因此，你只要把这些离散的格子从新加回来就行了，另外还要加上中间那一块被离散掉的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=205;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;map&lt;int,int&gt; mpx,mpy;int x[maxn],y[maxn];int lx[maxn],ly[maxn];ll vx[maxn*10],vy[maxn*10];int mp[maxn*10][maxn*10],mx,my;int dx[]= &#123;-1,0,1,0&#125;,dy[]= &#123;0,-1,0,1&#125;;ll ans[maxn*10];void dfs(int tx,int ty,int pos) &#123; if(mp[tx][ty]!=0)return ; mp[tx][ty]=pos; ++ans[pos]; for(int i=0; i&lt;4; i++) &#123; int ttx=tx+dx[i],tty=ty+dy[i]; if(ttx&gt;0&amp;&amp;ttx&lt;=mx&amp;&amp;tty&gt;0&amp;&amp;tty&lt;=my) &#123; dfs(ttx,tty,pos); &#125; &#125;&#125;int main() &#123; int cas=1,t;// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); scanf(&quot;%d&quot;, &amp;t); while(t--) &#123; mpx.clear(); mpy.clear(); mem(ans,0); int r,c; scanf(&quot;%d%d&quot;,&amp;r,&amp;c); scanf(&quot;%d&quot;,&amp;n); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]); lx[i]=x[i]; ly[i]=y[i]; &#125; lx[n]=r; sort(lx,lx+n+1); int d=0; vx[d]=0; for(int i=0; i&lt;=n; i++) &#123; if(lx[i]==vx[d])continue; else if(lx[i]==vx[d]+1) &#123; vx[d+1]=vx[d]+1; mpx[lx[i]]=d+1; d+=1; &#125; else if(lx[i]-d==2) &#123; vx[d+1]=vx[d]+1; vx[d+2]=vx[d]+2; mpx[lx[i]]=d+2; d+=2; &#125; else &#123; vx[d+1]=vx[d]+1; vx[d+2]=lx[i]; mpx[lx[i]]=d+2; d+=2; &#125; &#125; ly[n]=c; sort(ly,ly+n+1); mx=d; d=0; vy[d]=0; for(int i=0; i&lt;=n; i++) &#123; if(ly[i]==vy[d])continue; else if(ly[i]==vy[d]+1) &#123; vy[d+1]=vy[d]+1; mpy[ly[i]]=d+1; d+=1; &#125; else if(ly[i]-d&gt;=2) &#123; vy[d+1]=vy[d]+1; vy[d+2]=ly[i]; mpy[ly[i]]=d+2; d+=2; &#125; &#125; my=d; mem(mp,0); for(int i=0; i&lt;n; i++) &#123; mp[mpx[x[i]]][mpy[y[i]]]=-1; &#125; int num=1; for(int i=1; i&lt;=mx; i++) &#123; for(int j=1; j&lt;=my; j++) &#123; if(mp[i][j]==0) &#123; dfs(i,j,num++); &#125; &#125; &#125; for(int j=1; j&lt;=my; j++) &#123; //把离散竖着的加起来 for(int i=1; i&lt;=mx; i++) &#123; if(mp[i][j]!=-1) &#123; ans[mp[i][j]]+=vx[i]-vx[i-1]-1; &#125; else if(mp[i-1][j]!=-1) &#123; ans[mp[i-1][j]]+=vx[i]-vx[i-1]-1; &#125; &#125; &#125; for(int i=1; i&lt;=mx; i++) &#123; //把横着离散掉的加起来 for(int j=1; j&lt;=my; j++) &#123; if(mp[i][j]!=-1) &#123; ans[mp[i][j]]+=vy[j]-vy[j-1]-1; &#125; else if(mp[i][j-1]!=-1) &#123; ans[mp[i][j-1]]+=vy[j]-vy[j-1]-1; &#125; &#125; &#125; for(int i=1; i&lt;=mx; i++) &#123; //把中间那块离散掉的加起来 for(int j=1; j&lt;=my; j++) &#123; if(mp[i][j]!=-1) &#123; ans[mp[i][j]]+=(vy[j]-vy[j-1]-1)*(vx[i]-vx[i-1]-1); &#125; else if(mp[i-1][j-1]!=-1) &#123; ans[mp[i-1][j-1]]+=(vy[j]-vy[j-1]-1)*(vx[i]-vx[i-1]-1); &#125; &#125; &#125; printf(&quot;Case #%d:\n%d\n&quot;,cas++,num-1); sort(ans+1,ans+num); for(int i=1; i&lt;num; i++) &#123; printf(&quot;%lld&quot;,ans[i]); if(i+1==num)printf(&quot;\n&quot;); else printf(&quot; &quot;); &#125; &#125; return 0;&#125;下面是2组数据，正确答案能手算出来/*2100 100201 501 511 551 602 502 542 562 603 503 513 553 604 514 524 534 544 564 574 584 59100 10081 22 1100 9999 10099 1100 21 992 100*/ E:题目链接 HDU 5926 Mr. Frog’s Game 水题不解释了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int ar[35][35];int n,m;int dir[4][2]=&#123;1,0,0,1,-1,0,0,-1&#125;;int main() &#123; int cas=1,t; scanf(&quot;%d&quot;, &amp;t); while(t--) &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=0;i&lt;n;++i)&#123; for(int j = 0; j &lt; m; ++j)&#123; scanf(&quot;%d&quot;, &amp;ar[i][j]); &#125; &#125; int flag = 0; for(int i=0;i&lt;n;++i)&#123; for(int j=0;j&lt;m;++j)&#123; for(int k=0;k&lt;4;++k)&#123; int px = i + dir[k][0],py = j + dir[k][1]; if(px&lt;0||py&lt;0||px&gt;=n||py&gt;=m)continue; if(ar[px][py]==ar[i][j])&#123; flag=1;break; &#125; &#125; if(flag)break; &#125; if(flag)break; &#125; for(int i=0;i&lt;n;++i)&#123; for(int j=i+1;j&lt;n;++j)&#123; if(ar[i][0]==ar[j][0]||ar[i][m-1]==ar[j][m-1])&#123; flag=1;break; &#125; &#125; if(flag)break; &#125; for(int i=0;i&lt;m;++i)&#123; for(int j=i+1;j&lt;m;++j)&#123; if(ar[0][i]==ar[0][j]||ar[n-1][i]==ar[n-1][j])&#123; flag=1;break; &#125; &#125; if(flag)break; &#125; printf(&quot;Case #%d: &quot;,cas++); if(flag)printf(&quot;Yes\n&quot;); else printf(&quot;No\n&quot;); &#125; return 0;&#125; F 题目链接：HDU 5927 Auxiliary Set 题意：随便选几个点作为不重要的点，其他的全是重要的点，然后把不重要的点中如果是两个不同节点的最近公共祖先就把他变为重要的点，问，选了几个不重要的点，最后重要的点总共有多少个。 题解：数据看的挺吓人的 1e3 组 1e5的数据那命去写啊，实际上没多少。。。。。直接按不重要的点深度排个序，如果是另外两个重要的点的LCA就变成重要的点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,m;struct edge &#123; int to,next;&#125; eg[maxn*2];int head[maxn],tot;void init() &#123; mem(head,-1); tot=0;&#125;void add(int u,int v) &#123; eg[tot].to=v; eg[tot].next=head[u]; head[u]=tot++;&#125;int dep[maxn],pre[maxn];int u[maxn];int res[maxn];int num[maxn];int dfs(int r,int p,int d) &#123; dep[r]=d; pre[r]=p; int ans=0; for(int i=head[r]; i!=-1; i=eg[i].next) &#123; if(eg[i].to!=p) &#123; ans+=dfs(eg[i].to,r,d+1); &#125; &#125; num[r]=ans; return ans;&#125;void read(int &amp;sum) &#123; scanf(&quot;%d&quot;,&amp;sum); return ; sum=0; int flag=0; char ch=getchar(); while(!(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)) &#123; if (ch == &apos;-&apos;) &#123; flag = 1; &#125; ch=getchar(); &#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)sum=sum*10+ch-48,ch=getchar(); if(flag)sum*=-1;&#125;bool cmp(int &amp;a,int &amp;b) &#123; return dep[a]&gt;dep[b];&#125;int main() &#123; int t,cas=1; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; read(n); read(m); init(); for(int i=0; i&lt;n-1; i++) &#123; int a,b; read(a); read(b); add(a,b); add(b,a); &#125; dfs(1,-1,1); printf(&quot;Case #%d:\n&quot;,cas++); while(m--) &#123; int k,d,ans=0; read(k); ans=n-k; for(int i=0; i&lt;k; i++) &#123; read(res[i]); u[res[i]]=-1; &#125; sort(res,res+k,cmp); for(int i=0; i&lt;k; i++) &#123; d=0; for(int j=head[res[i]]; j!=-1; j=eg[j].next) &#123; int to=eg[j].to; if(to==pre[res[i]]) &#123; continue; &#125; else &#123; if(u[to]&lt;0) &#123; continue; &#125; if(u[res[i]]==-1) &#123; u[res[i]]=1; &#125; else u[res[i]]++; if(u[res[i]]==2) &#123; ans++; break; &#125; &#125; &#125; &#125; for(int i=0; i&lt;k; i++)u[res[i]]=0; printf(&quot;%d\n&quot;,ans); &#125; &#125; return 0;&#125; H 题目连接：HDU 5929 Basic Data Structure 简单模拟一下就可以了，记录下一最后一个零的位置，因为到零除了是第一个位置之外全都必定是1. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int a[maxn];int l,r;int t,cas=1;int Q;char s[100];deque&lt;int&gt; q;int main() &#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;,&amp;Q); int x; bool b=1; l=r=2e5+5; printf(&quot;Case #%d:\n&quot;,cas++); q.clear(); while(Q--) &#123; scanf(&quot;%s&quot;,s); if(b) &#123; if(s[0]==&apos;P&apos;&amp;&amp;s[1]==&apos;U&apos;) &#123; scanf(&quot;%d&quot;,&amp;x); a[++r]=x; if(x==0)q.push_back(r); &#125; else if(s[0]==&apos;Q&apos;) &#123; if(r==l)printf(&quot;Invalid.\n&quot;); else if(r-l==1)printf(&quot;%d\n&quot;,a[r]); else &#123; if(q.size()==0) &#123; printf(&quot;%d\n&quot;,(r-l)&amp;1); &#125; else &#123; int k=q.front(); if(r==k)printf(&quot;%d\n&quot;,(k-l+1)&amp;1); else printf(&quot;%d\n&quot;,(k-l)&amp;1); &#125; &#125; &#125; else if(s[0]==&apos;R&apos;) &#123; b=0; &#125; else &#123; if(a[r]==0)q.pop_back(); --r; &#125; &#125; else &#123; if(s[0]==&apos;P&apos;&amp;&amp;s[1]==&apos;U&apos;) &#123; scanf(&quot;%d&quot;,&amp;x); a[l--]=x; if(x==0)q.push_front(l+1); &#125; else if(s[0]==&apos;Q&apos;) &#123; if(r==l)printf(&quot;Invalid.\n&quot;); else if(r-l==1)printf(&quot;%d\n&quot;,a[r]); else &#123; if(q.size()==0)printf(&quot;%d\n&quot;,(r-l)&amp;1); else &#123; int k=q.back(); if(k==l+1)printf(&quot;%d\n&quot;,(r-k)&amp;1); else printf(&quot;%d\n&quot;,(r-k+1)&amp;1); &#125; &#125; &#125; else if(s[0]==&apos;R&apos;) &#123; b=1; &#125; else &#123; if(a[l+1]==0)q.pop_front(); ++l; &#125; &#125; &#125; &#125; return 0;&#125; I -题目链接：HDU - 5930 GCD 这题是真的难理解.这题要是不用线段树大家都会写吧，首先暴力从前面的每个位置到当前位置的GCD ，然后记录每个GCD的个数，更新一个点就是删除一个点，然后再加一个点，就是暴力从前面所有位置到后面所有位置的GCD，减去这个值。把值更新再一次算从前面所有位置到后面所有位置的GCD，然后加上去。 竟然会这个这个，这题就是用线段树维护一下GCD的值，，，就像二分一样，因为会有很长一段的GCD值是一样的，每次不用一个个去找，直接找到前面GCD改变的位置，然后减去上一次GCD改变的位置。也是一种暴力。。。修改其实也是一样的就是把前面GCD和后面GCD求一个GCD，然后前后GCD 的数量相乘 比如 1 1 1 2 4 4 4 前面3个数的GCD是3 个 1 和后面3个数 是 2 那么GCD为 gcd(1,2) 数量就是 3 * 3; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int g[maxn&lt;&lt;4],c[maxn];int f[maxn&lt;&lt;4],a[maxn],aa[maxn],b[maxn],bb[maxn];int A,B,n,m;long long gcd(long long a,long long b) &#123; return b==0?a:gcd(b,a%b);&#125;void build(int l,int r,int k) &#123; if(r-l==1) &#123; g[k]=c[r]; &#125; else &#123; build(lson); build(rson); g[k]=gcd(g[chl],g[chr]); &#125;&#125;int findleft(int l,int r,int k,int u,int v) &#123; if(r&lt;=u) &#123; if(gcd(g[k],v)==v)return 0; if(l+1==r)return r; int x=findleft(rson,u,v); if(x)return x; else return findleft(lson,u,v); &#125; if(u&gt;mid) &#123; int x=findleft(rson,u,v); if(x)return x; &#125; return findleft(lson,u,v);&#125;void getleft(int x) &#123; A=0; for(int i=c[x],j=x,k; j!=0; j=k) &#123; k=findleft(0,n,0,j,i); a[A]=j-k; aa[A++]=i; if(k==0)return ; i=gcd(c[k],i); &#125; return ;&#125;int findright(int l,int r,int k,int u,int v) &#123; //这个是用线段树往左找GCD if(l+1&gt;=u) &#123; if(gcd(g[k],v)==v)return n+1; if(l+1==r)return r; int x = findright(lson,u,v); if(x&lt;=n)return x; else return findright(rson,u,v); &#125; if(u&lt;=mid) &#123; int x=findright(lson,u,v); if(x&lt;=n)return x; &#125; return findright(rson,u,v);&#125;void getright(int x) &#123; B=0; for(int i= c[x],j=x,k; j&lt;=n; j=k) &#123; //这个是暴力X所有左边的GCD k=findright(0,n,0,j,i); b[B]=k-j; bb[B++]=i; i=gcd(c[k],i); &#125; return ;&#125;void change(int l,int r,int k,int u,int v) &#123; if (l+1==r) &#123; g[k] = v; return; &#125; if (u&lt;=mid) change(lson,u,v); else change(rson,u,v); g[k]=gcd(g[chl],g[chr]);&#125;int main() &#123; int t,cas=1; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; printf(&quot;Case #%d:\n&quot;,cas++); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; ++i)scanf(&quot;%d&quot;,&amp;c[i]); build(0,n,0); //初始化线段树 memset(f,0,sizeof(f)); int ans=0; for(int i=1; i&lt;=n; i++) &#123; getleft(i); //初始化只要找所有i左边的GCD或者右边也可以，但是只能找一边不然会重复。 for(int j=0; j&lt;A; j++) &#123; if(!f[aa[j]])ans++; f[aa[j]]+=a[j]; &#125; &#125; while(m--) &#123; int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); getleft(x); //找到所有左边的GCD getright(x); //找到所有右边的GCD for(int j=0; j&lt;A; j++) &#123;//暴力所有左右两边GCD所有可能 for(int k=0; k&lt;B; k++) &#123; int t=gcd(aa[j],bb[k]); //左右两边的GCD的GCD f[t]-=1LL *a[j]*b[k]; // 暴力删除 if(!f[t])ans--; &#125; &#125; c[x]=y; change(0,n,0,x,y); getleft(x); getright(x); for(int j=0; j&lt;A; j++) &#123; for(int k=0; k&lt;B; k++) &#123; int t=gcd(aa[j],bb[k]);//暴力添加 if(!f[t])ans++; f[t]+=1LL*a[j]*b[k]; &#125; &#125; printf(&quot;%d\n&quot;,ans); // 得出结论 &#125; &#125; return 0;&#125; J 题目链接：HDU5931 - Mission Possible 暴力所有速度，推一下公式，发现要么是用初始血量去掉不加血，要么是加血等于掉血数量的时候是最优解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;ll D,A,GA,GB,GC;int main() &#123; int t,cas=1; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%lld%lld%lld%lld%lld&quot;,&amp;D,&amp;A,&amp;GA,&amp;GB,&amp;GC); ll v,r,h; ll ans=1e18,temp; for(v=1; v&lt;=D; v++) &#123; double t=1.0*D/v; temp=v*GB+A*GC+A*GA; ans=min(ans,temp); double tem2=t*A; temp=v*GB+floor(t*A-eps+1)*GA;// debug(temp-v*GB); ans=min(ans,temp); &#125; printf(&quot;Case #%d: %lld\n&quot;,cas++,ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第八届福建省大学生程序设计竞赛-FZU 2280 HASH处理+暴力搜索]]></title>
    <url>%2F2018%2F08%2F21%2F%E7%AC%AC%E5%85%AB%E5%B1%8A%E7%A6%8F%E5%BB%BA%E7%9C%81%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-FZU%202280%20HASH%E5%A4%84%E7%90%86%2B%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[题目：Problem 2280 Magic Problem Description Kim is a magician, he can use n kinds of magic, number from 1 to n. We use string Si to describe magic i. Magic Si will make Wi points of damage. Note that Wi may change over time. Kim obey the following rules to use magic: Each turn, he picks out one magic, suppose that is magic Sk, then Kim will use all the magic i satisfying the following condition: Wi&lt;=Wk Sk is a suffix of Si. Now Kim wondering how many magic will he use each turn. Note that all the strings are considered as a suffix of itself. Input First line the number of test case T. (T&lt;=6) For each case, first line an integer n (1&lt;=n&lt;=1000) stand for the number of magic. Next n lines, each line a string Si (Length of Si&lt;=1000) and an integer Wi (1&lt;=Wi&lt;=1000), stand for magic i and it’s damage Wi. Next line an integer Q (1&lt;=Q&lt;=80000), stand for there are Q operations. There are two kinds of operation. “1 x y” means Wx is changed to y. “2 x” means Kim has picked out magic x, and you should tell him how many magic he will use in this turn. Note that different Si can be the same. Output For each query, output the answer. Sample Input 1 5 abracadabra 2 adbra 1 bra 3 abr 3 br 2 5 2 3 2 5 1 2 5 2 3 2 2 Sample Output 3 1 2 1 Source 第八届福建省大学生程序设计竞赛-重现赛（感谢承办方厦门理工学院） 题目：给你n个字符串以及权值，两种操作 一种 更新字符串对应的权值 ，查询 输出所有以当前字符串为后缀且对应权值小于当前字符串权值的个数。 题解：首先hash 预处理所有能供以当前字符串为后缀的字符串，直接n^2暴力就行。。。 然后查询直接暴力搜索小于当前字符串权值的。 数据只有1000 的范围随便暴力啊。。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e3+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;const int seed=131;ull Hash[maxn][maxn];ull po[maxn];char ch[maxn][maxn];int t,n;int len[maxn];bool mp[maxn][maxn];int val[maxn];void init() &#123; mem(mp,0); po[0]=1; for(int i=1; i&lt;1002; i++) &#123; po[i]=po[i-1]*seed; &#125; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=len[i]; j++) &#123; Hash[i][j]=Hash[i][j-1]*seed+ch[i][j]; &#125; &#125; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=n; j++) &#123; if(len[j]&lt;len[i])continue; else &#123; int l=len[j]-len[i]; if(Hash[j][len[j]]-Hash[j][l]*po[len[i]]==Hash[i][len[i]]) &#123; mp[i][j]=1; &#125; &#125; &#125; &#125;&#125;void read(int &amp;sum) &#123; sum=0; int flag=0; char ch=getchar(); while(!(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)) &#123; if (ch == &apos;-&apos;) &#123; flag = 1; &#125; ch=getchar(); &#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)sum=sum*10+ch-48,ch=getchar(); if(flag)sum*=-1;&#125;int main() &#123; read(t); while(t--) &#123; read(n); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%s%d&quot;,ch[i]+1,&amp;val[i]); len[i]=strlen(ch[i]+1); &#125; init(); int q; read(q); while(q--) &#123; int op; read(op); int x,y; if(op==1) &#123; read(x); read(y); val[x]=y; &#125; else &#123; read(x); int ans=0; for(int i=1;i&lt;=n;i++)if(mp[x][i]&amp;&amp;val[x]&gt;=val[i])ans++; printf(&quot;%d\n&quot;,ans); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性排序算法 --- 计数排序，基数排序，桶排序]]></title>
    <url>%2F2018%2F08%2F21%2F%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%20---%20%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%8C%E6%A1%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[计数排序应用: J - Jeronimo’s List Gym - 101466J http://codeforces.com/gym/101466/problem/J 线性排序算法计数排序应该挺好理解的，每次把数字出现的次数记录下来，然后做成前缀，前缀就是小于等于当前数的个数。 比如 2,3,0,3,6,2,3,5，首先记录出现次数 0 1 2 3 4 5 6 1 0 2 3 0 1 1 然后对这个数组做一个前缀 c[0] c[1] c[2] c[3] c[4] c[5] c[6] 1 1 3 6 6 7 8 就是这样 ，然后排序的时候就 输出数字对应的地方 如 a[i]= 5 那么 b[c[a[i]]]=a[i]; 把b 数组里面 7的位置赋值为5.然后小于等于5的数量-1； 1234567891011121314151617181920212223242526272829303132 #include&lt;bits/stdc++.h&gt;using namespace std;int a[8]= &#123;2,3,0,3,6,2,3,5&#125;;int b[8];int c[7];int main() &#123; for(int i=0; i&lt;8; i++) &#123; c[a[i]]++; &#125; for(int i=1; i&lt;7; i++) &#123; //把这个for倒过来就是从大到小 c[i]=c[i-1]+c[i]; &#125; printf(&quot;C数组:\n&quot;); for(int i=0; i&lt;7; i++) &#123; printf(&quot;c[%d]\t&quot;,i); &#125; printf(&quot;\n&quot;); for(int i=0; i&lt;7; i++) &#123; printf(&quot; %d\t&quot;,c[i]); &#125; printf(&quot;\n&quot;); printf(&quot;排序过程\n&quot;); for(int i=7; i&gt;=0; i--) &#123; b[--c[a[i]]]=a[i]; for(int i=0; i&lt;7; i++) &#123; printf(&quot;%d &quot;,b[i]); &#125; printf(&quot;\n&quot;); &#125; return 0;&#125; 基数排序： 实际上和计数排序没啥太大的区别 ，计数排序如果数太大，你 C数组的就要浪费非常大的内存，或者根本开不了这么大的内存。 基数排序，就是把每个 位拆分出来，实际上和计数排序差距不大。 12,13,120,33,46,52,3,25 120 12 52 13 33 3 25 46 以最后一位递增 3 12 13 120 25 33 46 52 在最后一位为递增基础上倒数第2位递增 3 12 13 25 33 46 52 120 最后以 第一位 递增，就是排序好的 12345678910111213141516171819202122232425262728293031323334353637383940414243 #include&lt;bits/stdc++.h&gt;using namespace std;int a[8]= &#123;12,13,120,33,46,52,3,25&#125;;int b[8];int c[10];int main() &#123; int mx=0,pos=0,cot=1; for(int i=0; i&lt;8; i++) &#123; mx=max(mx,a[i]); &#125; while(mx/cot&gt;0) &#123; memset(c,0,sizeof(c)); for(int i=0; i&lt;8; i++) &#123; c[a[i]/cot%10]++; &#125; for(int i=1; i&lt;10; i++) &#123; //把这个for倒过来就是从大到小 c[i]=c[i-1]+c[i]; &#125; printf(&quot;计数数组:\n&quot;); for(int i=0; i&lt;10; i++) &#123; printf(&quot;c[%d]\t&quot;,i); &#125; printf(&quot;\n&quot;); for(int i=0; i&lt;10; i++) &#123; printf(&quot; %d\t&quot;,c[i]); &#125; printf(&quot;\n&quot;); printf(&quot;排序第%d位结果:\n&quot;,pos); for(int i=7; i&gt;=0; i--) &#123; b[--c[a[i]/cot%10]]=a[i]; &#125; for(int i=0; i&lt;8; i++) &#123; a[i]=b[i]; &#125; for(int i=0;i&lt;8;i++)&#123; printf(&quot;%d &quot;,a[i]); &#125; puts(&quot;&quot;); cot*=10; pos++; &#125; return 0;&#125; 桶排序，实际上和计数排序也差不多，但是到目前位置我还没用过。 计数排序就相当于 桶的大小为 1 的排序 。（基数排序实际上有点类似于以10 的桶里面套着一个10 的桶）个人理解 开一个桶的大小 b 然后把他一个数x丢到 x/b 那个桶里面去，然后把每个桶里面排序。把桶分成1不就是计数排序。。个人理解 理论上来说：在分布桶均匀的情况下，是O(n+n*(2-1/n)); 有些情况下可能退化成 普通排序一样的复杂度。 代码就不敲了，还没用过。。。。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第八届福建省大学生程序设计竞赛-FZU 2277 DFS +线段树+读入挂]]></title>
    <url>%2F2018%2F08%2F20%2F%E7%AC%AC%E5%85%AB%E5%B1%8A%E7%A6%8F%E5%BB%BA%E7%9C%81%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-FZU%202277%20%20DFS%20%2B%E7%BA%BF%E6%AE%B5%E6%A0%91%2B%E8%AF%BB%E5%85%A5%E6%8C%82%2F</url>
    <content type="text"><![CDATA[FZU 2277 Problem 2277 Change Accept: 245 Submit: 1186 Time Limit: 2000 mSec Memory Limit : 262144 KB Problem Description There is a rooted tree with n nodes, number from 1-n. Root’s number is 1.Each node has a value ai. Initially all the node’s value is 0. We have q operations. There are two kinds of operations. 1 v x k : a[v]+=x , a[v’]+=x-k (v’ is child of v) , a[v’’]+=x-2*k (v’’ is child of v’) and so on. 2 v : Output a[v] mod 1000000007(10^9 + 7). Input First line contains an integer T (1 ≤ T ≤ 3), represents there are T test cases. In each test case: The first line contains a number n. The second line contains n-1 number, p2,p3,…,pn . pi is the father of i. The third line contains a number q. Next q lines, each line contains an operation. (“1 v x k” or “2 v”) 1 ≤ n ≤ 3*10^5 1 ≤ pi &lt; i 1 ≤ q ≤ 3*10^5 1 ≤ v ≤ n; 0 ≤ x &lt; 10^9 + 7; 0 ≤ k &lt; 10^9 + 7 Output For each operation 2, outputs the answer. Sample Input 1 3 1 1 3 1 1 2 1 2 1 2 2 Sample Output 2 1 Source 题意：给你一棵树 有两种操作：查询节点的值，和将所有树节点及以下下所有的节点 + x - (子节点深度-当前深度)*k 的值 题解：首先肯定是DFS建序，然后根据dfs 序建一颗线段树，这题更新操作是更新一个区间，查询是单点。 这题只要用一个dep数组保存每个节点所包含区间里面的最小深度，然后向下更新的时候每次把，x，和k，更新下去； 更新的时候直接把，(子节点深度-当前深度)*k的值更新到 ，x,里面。 查询直接返回单点的x. 这题主要是卡取模和读入。。。读入特么就快超时了，最让我无语的还是超时给我返回一个WA加个读入挂就过了。。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef ll LL;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=3e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int e[maxn],s[maxn],tdep[maxn];int cnt=0;struct node &#123; ll x,k;&#125; lazy[maxn&lt;&lt;4];int dep[maxn&lt;&lt;4];struct edge &#123; int to,next;&#125; eg[maxn];int head[maxn],tot;void add(int u,int v) &#123; eg[tot].to=v; eg[tot].next=head[u]; head[u]=tot++;&#125;void init() &#123; tot=0; cnt=0; mem(head,-1);&#125;int dfs(int r,int dp) &#123; cnt++; s[r]=cnt; tdep[cnt]=dp; for(int i=head[r]; i!=-1; i=eg[i].next) &#123; int to=eg[i].to; dfs(to,dp+1); &#125; e[r]=cnt;&#125;void build(int l,int r,int k) &#123; if(r-l==1) &#123; dep[k]=tdep[r]; lazy[k].k=0; lazy[k].x=0; &#125; else &#123; build(lson); build(rson); dep[k]=min(dep[chl],dep[chr]); lazy[k].k=0; lazy[k].x=0; &#125;&#125;void pushdown(int l,int r,int k) &#123; if(lazy[k].k==0&amp;&amp;lazy[k].x==0) return ; lazy[chl].k+=lazy[k].k; lazy[chl].k%=mod; lazy[chr].k+=lazy[k].k; lazy[chr].k%=mod; lazy[chl].x+=(lazy[k].x-lazy[k].k%mod*(dep[chl]-dep[k])+mod)%mod; lazy[chl].x=(lazy[chl].x+mod)%mod; lazy[chr].x+=(lazy[k].x-lazy[k].k%mod*(dep[chr]-dep[k])+mod)%mod; lazy[chr].x=(lazy[chr].x+mod)%mod; lazy[k].x=0; lazy[k].k=0;&#125;void update(int a,int b,int l,int r,int k,ll x,ll y,ll dp) &#123; if(b&lt;=l||a&gt;=r) &#123; return ; &#125; else if(a&lt;=l&amp;&amp;r&lt;=b) &#123; lazy[k].x+=(x-y*(dep[k]-dp)%mod+mod)%mod; lazy[k].x%=mod; lazy[k].k+=y; lazy[k].k%=mod; return ; &#125; else &#123; pushdown(l,r,k); update(a,b,lson,x,y,dp); update(a,b,rson,x,y,dp); &#125;&#125;ll res=0;void query(int a,int b,int l,int r,int k) &#123; if(b&lt;=l||a&gt;=r) &#123; return ; &#125; else if(a&lt;=l&amp;&amp;r&lt;=b) &#123; res=lazy[k].x%mod; return ; &#125; else &#123; pushdown(l,r,k); query(a,b,lson); query(a,b,rson); &#125;&#125;void read(LL &amp;sum) &#123; sum=0; char ch=getchar(); while(!(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;))ch=getchar(); while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)sum=sum*10+ch-48,ch=getchar();&#125;void read(int &amp;sum) &#123; sum=0; char ch=getchar(); while(!(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;))ch=getchar(); while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)sum=sum*10+ch-48,ch=getchar();&#125;int main() &#123; int n,t; read(t); while(t--) &#123; init(); scanf(&quot;%d&quot;,&amp;n); for(int i=2; i&lt;=n; i++) &#123; int x; read(x); add(x,i); &#125; dfs(1,1); build(0,n,0); int q; read(q); while(q--) &#123; int op; read(op); ll a,b,c; if(op==1) &#123; read(a); read(b); read(c); update(s[a]-1,e[a],0,n,0,b,c,tdep[s[a]]); &#125; else &#123; scan_d&lt;LL&gt;(a); query(s[a]-1,s[a],0,n,0); printf(&quot;%lld\n&quot;,(res+mod)%mod); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A - Gaby And Addition Gym - 101466A --字典树 ，暴力+贪心]]></title>
    <url>%2F2018%2F08%2F19%2FA%20-%20Gaby%20And%20Addition%20Gym%20-%20101466A%20--%E5%AD%97%E5%85%B8%E6%A0%91%20%EF%BC%8C%E6%9A%B4%E5%8A%9B%2B%E8%B4%AA%E5%BF%83%2F</url>
    <content type="text"><![CDATA[题目链接 ：http://codeforces.com/gym/101466/problem/A A. Gaby And Addition time limit per test 6.0 s memory limit per test 1024 MB input standard input output standard output Gaby is a little baby who loves playing with numbers. Recently she has learned how to add 2 numbers using the standard addition algorithm which we summarize in 3 steps: Line up the numbers vertically matching digits places. Add together the numbers that share the same place value from right to left. Carry if necessary. it means when adding two numbers we will get something like this: Unfortunately as Gaby is too young she doesn’t know what the third step means so she just omitted this step using her own standard algorithm (Gaby’s addition algorithm). When adding two numbers without carrying when necessary she gets something like the following: Gaby loves playing with numbers so she wants to practice the algorithm she has just learned (in the way she learned it) with a list of numbers adding every possible pair looking for the pair which generates the largest value and the smallest one. She needs to check if she is doing it correctly so she asks for your help to find the largest and the smallest value generated from the list of numbers using Gaby’s addition algorithm. Input The input starts with an integer _n_ (2 ≤ _n_ ≤ 106) indicating the number of integers Gaby will be playing with. The next line contains _n_numbers _ni_ (0 ≤ _ni_ ≤ 1018) separated by a single space. Output Output the smallest and the largest number you can get from adding two numbers from the list using Gaby’s addition algorithm. Examples input Copy 12 617 5 11 0 42 99 output Copy 10 99 input Copy 12 7506823119072235413 991096248449924896 204242310783332529 778958050378192979 384042493592684633 942496553147499866 410043616343857825 output Copy 152990443860776502 972190360051424498 Note In the first sample input this is how you get the minimum and the maximum value 题意：给 n个数求不进位加法，两个数和的最大值，最小值。 题解：分别对每个数字拆分成 18个位，每个位是 0-9 的数字，然后用每个位建一个字典树。 就形成了一棵以0结点为根节点，然后每层分配0-9 儿子节点的字典树，然后每次查询和当前值相加最大值和最小值，分别每次从取模10最大的和最小的节点匹配。 例如 当前位是 5 最大值直接从当前位儿子节点 4开始找 如果存在直接求两个数的和，否则继续3 2 1.。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;int cnt=1;struct Trie &#123; int son[10]; void init() &#123; for(int i=0; i&lt;10; i++) &#123; son[i]=-1; &#125; &#125;&#125; tree[maxn*20];ll p[20];void insert(int r,int pos,ll val) &#123; if(pos==-1)return ; ll v=val/p[pos]%10; if(tree[r].son[v]==-1) &#123;// printf(&quot;%d&quot;,v); tree[cnt].init(); tree[r].son[v]=cnt++; &#125; insert(tree[r].son[v],pos-1,val);&#125;ll findmx(int r,int pos,ll val) &#123; if(pos==-1)return 0; ll v=val/p[pos]%10; for(int i=9-v; i&gt;=0; i--) &#123; if(tree[r].son[i]!=-1) &#123; return (p[pos]*((v+i)%10))+findmx(tree[r].son[i],pos-1,val); &#125; &#125; for(int i=9; i&gt;9-v; i--) if(tree[r].son[i]!=-1) return (p[pos]*((v+i)%10))+findmx(tree[r].son[i],pos-1,val);&#125;ll findmi(int r,int pos,ll val) &#123; if(pos==-1)return 0; int v=val/p[pos]%10; for(int i=10-v; i&lt;=9; i++) if(tree[r].son[i]!=-1) &#123; return (p[pos]*((v+i)%10))+findmi(tree[r].son[i],pos-1,val); &#125; for(int i=0; i&lt;10-v; i++) if(tree[r].son[i]!=-1) return (p[pos]*((v+i)%10))+findmi(tree[r].son[i],pos-1,val);&#125;int main() &#123; scanf(&quot;%d&quot;,&amp;n); p[0]=1; for(int i=1; i&lt;=18; i++) &#123; p[i]=p[i-1]*10; &#125; tree[0].init(); ll mx=-1e18,mi=1e18; for(int i=0; i&lt;n; i++) &#123; ll x; scanf(&quot;%lld&quot;,&amp;x); if(i!=0) &#123; mi=min(mi,findmi(0,18,x)); mx=max(mx,findmx(0,18,x)); &#125; insert(0,18,x);// puts(&quot;&quot;); &#125; printf(&quot;%lld %lld\n&quot;,mi,mx); return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K - Random Numbers Gym - 101466K ------线段树+DFS序]]></title>
    <url>%2F2018%2F08%2F19%2FK%20-%20Random%20Numbers%20Gym%20-%20101466K%20%20------%E7%BA%BF%E6%AE%B5%E6%A0%91%2BDFS%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[K. Random Numbers time limit per test 2.0 s memory limit per test 256 MB input standard input output standard output Tamref love random numbers, but he hates recurrent relations, Tamref thinks that mainstream random generators like the linear congruent generator suck. That’s why he decided to invent his own random generator. As any reasonable competitive programmer, he loves trees. His generator starts with a tree with numbers on each node. To compute a new random number, he picks a rooted subtree and multiply the values of each node on the subtree. He also needs to compute the number of divisors of the generated number (because of cryptographical applications). In order to modify the tree (and hence create different numbers on the future), Tamref decided to perform another query: pick a node, and multiply its value by a given number. Given a initial tree _T_, where _T__u_ corresponds to the value on the node _u_, the operations can be summarized as follows: RAND: Given a node _u_ compute and count its divisors, where _T_(_u_) is the set of nodes that belong to the subtree rooted at _u_. SEED: Given a node _u_ and a number _x_, multiply _T__u_ by _x_. Tamref is quite busy trying to prove that his method indeed gives integers uniformly distributed, in the meantime, he wants to test his method with a set of queries, and check which numbers are generated. He wants you to write a program that given the tree, and some queries, prints the generated numbers and count its divisors. Tamref has told you that the largest prime factor of both _T__u_ and _x_ is at most the Tamref’s favourite prime: 13. He also told you that the root of _T_ is always node 0. The figure shows the sample test case. The numbers inside the squares are the values on each node of the tree. The subtree rooted at node 1 is colored. The RAND query for the subtree rooted at node 1 would generate 14400, which has 63 divisors. Input The first line is an integer _n_ (1 ≤ _n_ ≤ 105), the number of nodes in the tree _T_. Then there are _n_ - 1 lines, each line contains two integers _u_and _v_ (0 ≤ _u_, _v_ &lt; _n_) separated by a single space, it represents that _u_ is a parent of _v_ in _T_. The next line contains _n_ integers, where the _i_ - _th_ integer corresponds to _Ti_ (1 ≤ _Ti_ ≤ 109). The next line contains a number _Q_ (1 ≤ _Q_ ≤ 105), the number of queries. The final _Q_ lines contain a query per line, in the form “_RAND_ _u_” or “SEED _u_ _x_” (0 ≤ _u_ &lt; _n_, 1 ≤ _x_ ≤ 109). Output For each _RAND_ query, print one line with the generated number and its number of divisors separated by a space. As this number can be very long, the generated number and its divisors must be printed modulo 109 + 7. Example input Copy 12345678910111213 80 10 21 32 42 53 63 77 3 10 8 12 14 40 153RAND 1SEED 1 13RAND 1 output Copy 12 14400 63187200 126 题意：建一颗树，查询 所有以当前节点和所有儿子节点因子个数，更新，单点更新倍数。 题解：首先dfs把所有位置出现的序 排好。题目样例 dfs,进入的先后顺序 是 s[0]=1,s[1]=2,s[3]=2,s[6]=4,s[7]=5,s[2]=6,s[4]=7,s[5]=8; 然后保留每个节点最后一个所覆盖的最大范围如： e[0]=8, 因为 0节点覆盖了所有节点也就是 1-8 ，e[1]=5,1节点 覆盖了所有序从 s[1]-e[1]（2 - 5）的节点。 然后以序建一颗线段树： 查询： x 每次查询 [s[x],e[x]]; 更新： x 每次更新 [ s[x] ,s[x] ]; 我的线段树每次保存的是 (l,r] ,所以 l 每次要-1。 这题数据处理，每个节点保留所有素数因子个数，然后求的值就是所有素数的乘积，因子个数就是相应素数个数+1的乘积， 假如 素因子2有6个，素因子3有 2个 ，素因子5有2个，输出就是 2^63^25^2, 733 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=2e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;vector&lt;int&gt; G[maxn];int e[maxn],s[maxn];int val[maxn],val2[maxn];int cnt=0;int dfs(int r,int p) &#123; cnt++;// debug(r); val[cnt]=val2[r]; s[r]=cnt; for(int i=0; i&lt;G[r].size(); i++) &#123; int to=G[r][i]; if(to!=p) &#123; dfs(to,r); &#125; &#125; e[r]=cnt;&#125;int dat[maxn&lt;&lt;4][6];int prim[]= &#123;2,3,5,7,11,13&#125;;void init(int l,int r,int k) &#123; if(r-l==1) &#123; for(int i=0; i&lt;6; i++) &#123; while(val[r]%prim[i]==0) &#123; val[r]/=prim[i]; dat[k][i]++; &#125; &#125; &#125; else &#123; init(lson); init(rson); for(int i=0; i&lt;6; i++) &#123; dat[k][i]=dat[chl][i]+dat[chr][i]; &#125; &#125;&#125;void update(int a,int b,int l,int r,int k,ll x) &#123; if(b&lt;=l||a&gt;=r) &#123; return ; &#125; else if(a&lt;=l&amp;&amp;r&lt;=b) &#123; for(int i=0; i&lt;6; i++) &#123; while(x%prim[i]==0) &#123; x/=prim[i]; dat[k][i]++; &#125; &#125; return ; &#125; else &#123; update(a,b,lson,x); update(a,b,rson,x); for(int i=0; i&lt;6; i++) &#123; dat[k][i]=dat[chl][i]+dat[chr][i]; &#125; &#125;&#125;int res[6];void query(int a,int b,int l,int r,int k) &#123; if(b&lt;=l||a&gt;=r) &#123; return ; &#125; else if(a&lt;=l&amp;&amp;r&lt;=b) &#123; for(int i=0; i&lt;6; i++) &#123; res[i]+=dat[k][i]; &#125; &#125; else &#123; query(a,b,lson); query(a,b,rson); &#125;&#125;long long pow(long long x,long long n,long long mod=1e9+7) &#123; long long res=1; while(n&gt;0) &#123; if(n&amp;1)res=res*x%mod; x=x*x%mod; n&gt;&gt;=1; &#125; return res%mod;&#125;int main() &#123; int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;n; i++) &#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); G[a].push_back(b); G[b].push_back(a); &#125; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d&quot;,&amp;val2[i]); &#125; dfs(0,-1); init(0,n,0); int q; scanf(&quot;%d&quot;,&amp;q); while(q--) &#123; char ch[100]; scanf(&quot;%s&quot;,ch); if(ch[0]==&apos;R&apos;) &#123; int a; scanf(&quot;%d&quot;,&amp;a); mem(res,0); query(s[a]-1,e[a],0,n,0); ll ans=1,num=1; for(int i=0; i&lt;6; i++) &#123; ans*=pow(prim[i],res[i],mod); ans%=mod; num*=res[i]+1; num%=mod; &#125; printf(&quot;%lld %lld\n&quot;,ans%mod,num%mod); &#125; else &#123; int a; ll b; scanf(&quot;%d%lld&quot;,&amp;a,&amp;b); update(s[a]-1,s[a],0,n,0,b); &#125; &#125; return 0;&#125; 0]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[省赛选拔-单调队列]]></title>
    <url>%2F2018%2F08%2F12%2F%E7%9C%81%E8%B5%9B%E9%80%89%E6%8B%94-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[单调队列写法。 Py&amp;hyh想脱单 Description 总所周知,，py和hyh有十分浓烈的脱单意愿，但是非常不幸，在一个风和日丽的下午，他们穿越到一个没有妹子的世界，他必须回答一个问题才能回到本来的世界，这个问题是给出一个nm的矩阵，然后有q次操作，每一个操作，给出xi,yi,ti,表示在ti时刻摧毁(xi,yi)这个格子，然后他们要求出一个最早时刻，出现至少一个kk的矩阵被毁坏，注意：一个kk矩阵被毁坏的意思是某一个kk的矩阵中的每一个格子都被摧毁过一次或一次以上。聪明的acmer能帮他们回答这个问题吗（如果没人能ac这个题，就代表他们两个没有脱单的可能了哦） Input Input：采用多组输入第一行输入n,m,k,q,(1 ≤ n, m ≤ 500, 1 ≤ k ≤ min(n, m), 1 ≤ q ≤ n·m)分别代表nm的矩阵，kk的矩阵，和q次操作接下来q行每一行输入xi,yi,ti(1 ≤ xi ≤ n, 1 ≤ yi ≤ m, 0 ≤ t ≤ 1e6)，代表，在ti这个时刻，xi，yi这个位置会被摧毁 Output Out：输出一行，代表最早时刻出现至少一个k*k的矩阵被毁坏如果永远不存在这一个时刻，输出-1 Sample Input 1 2 3 2 5 2 1 8 2 2 8 1 2 1 1 3 4 2 3 2 Sample Output 1 8 Sample Input 2 3 3 2 5 1 2 2 2 2 1 2 3 5 3 2 10 2 1 100 Sample Output 2 -1 题意：自己看。 解法：标程是二分+二维前缀和，我个人觉得双向队列写法更优。 首先每行 记录 mp[i][ j-k , j ]区间的最大值，再在得到每行每个区间最大值的条件下再次记录 每列的最大值 mp[i-k,i][j]; 这中写法只要会用双向队列来维护单调队列，就很好些。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_backconst long long mod=998244353;const int maxn=5e3+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,m,k,q;deque&lt;int&gt; dq;int mp[maxn][maxn];int mp2[maxn][maxn]; //开个mp2记录下每行一个区间的最大值int main() &#123; while(~scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;k,&amp;q)) &#123; memset(mp,inf,sizeof(mp)); while(q--) &#123; int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); mp[a][b]=min(mp[a][b],c); &#125; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=m; j++) &#123; if(j&gt;k&amp;&amp;dq.back()==mp[i][j-k]) &#123; dq.pop_back(); &#125; while(dq.size()&gt;0&amp;&amp;dq.front()&lt;mp[i][j]) &#123; dq.pop_front(); &#125; if(dq.size()==0||dq.front()&gt;=mp[i][j]) &#123; dq.push_front(mp[i][j]); &#125; mp2[i][j]=dq.back(); &#125; dq.clear(); &#125; for(int i=k; i&lt;=m; i++) &#123; for(int j=1; j&lt;=n; j++) &#123; if(j&gt;k&amp;&amp;dq.back()==mp2[j-k][i]) &#123; dq.pop_back(); &#125; while(dq.size()&gt;0&amp;&amp;dq.front()&lt;mp2[j][i]) &#123; dq.pop_front(); &#125; if(dq.size()==0||dq.front()&gt;=mp2[j][i]) &#123; dq.push_front(mp2[j][i]); &#125; mp[j][i]=dq.back(); &#125; dq.clear(); &#125; int res=inf; for(int i=k; i&lt;=n; i++) &#123; for(int j=k; j&lt;=m; j++) &#123; res=min(res,mp[i][j]); &#125; &#125; if(res&gt;1e6+1)res=-1; printf(&quot;%d\n&quot;,res); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 2532 Internship(网络流求割边)]]></title>
    <url>%2F2018%2F08%2F02%2FZOJ%202532%20Internship(%E7%BD%91%E7%BB%9C%E6%B5%81%E6%B1%82%E5%89%B2%E8%BE%B9)%2F</url>
    <content type="text"><![CDATA[ZOJ2532 Internship Time Limit: 5 Seconds Memory Limit: 32768 KB CIA headquarter collects data from across the country through its classified network. They have been using optical fibres long before it’s been deployed on any civilian projects. However they are still under a lot pressure recently because the data are growing rapidly. As a result they are considering upgrading the network with new technologies that provide a few times wider bandwidth. In the experiemental stage, they would like to upgrade one segment of their original network in order to see how it performs. And as a CIA intern it’s your responsibility to investigate which segment could actually help increase the total bandwidth the headquarter receives, suppose that all the cities have infinite data to send and the routing algorithm is optimized. As they have prepared the data for you in a few minutes, you are told that they need the result immediately. Well, practically immediately. Input Input contains multiple test cases. First line of each test case contains three integers n, m and l, they represent the number of cities, the number of relay stations and the number of segments. Cities will be referred to as integers from 1 to n, while relay stations use integers from n+1 to n+m. You can saves assume that n + m &lt;= 100, l &lt;= 1000 (all of them are positive). The headquarter is identified by the integer 0. The next l lines hold a segment on each line in the form of a b c, where a is the source node and b is the target node, while c is its bandwidth. They are all integers where a and b are valid identifiers (from 0 to n+m). c is positive. For some reason the data links are all directional. The input is terminated by a test case with n = 0. You can safely assume that your calculation can be housed within 32-bit integers. Output For each test print the segment id’s that meets the criteria. The result is printed in a single line and sorted in ascending order, with a single space as the separator. If none of the segment meets the criteria, just print an empty line. The segment id is 1 based not 0 based. Sample Input 12 1 3 1 3 2 3 0 1 2 0 1 2 1 3 1 3 1 2 3 1 3 0 2 0 0 0 Sample Output 12 3 &lt;hey here is an invisible empty line&gt; 题意：就是给你几个点 然后全部要汇到 终点 0 问哪几条边流量上升可以直接增大流量。 题解： 首先用网络流跑一边，然后一个是起点的残余网络，一个是终点的残余网络，如果有一条变能从起点残余网络跑到终点的残余网络肯定 就是因为他限制了流量，所以这题就是找能连接两个残余网络的的边。 起点残余网络，就顺着你连的边流一次就行了。 终点残余网络是逆着流一遍，是用反向边跑，这一点需要注意下，因为这个残余网络是从别的点汇聚到终点，不是从重点流出去。把所有能连接两边点的且边的流量是0的边加入答案就行，最后排个序。 怕理解不了插个图 AC代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#define mem(a,b) memset(a,b,sizeof(a))using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;const long long mod=1e9+7;const int maxn=400+25;const int maxm=1e5+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,m,l,tot;struct edge &#123; int num,to,cap,rev;&#125;;vector &lt;edge&gt; G[maxn];int level[maxn];int iter[maxn];void init(int _n) &#123; for(int i=0; i&lt;=_n; i++) &#123; G[i].clear(); &#125;&#125;void bfs(int s) &#123; memset(level,-1,sizeof(level)); queue&lt;int&gt; que; level[s]=0; que.push(s); while(!que.empty()) &#123; int v= que.front(); que.pop(); for(int i=0; i&lt;G[v].size(); i++) &#123; edge &amp; e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0) &#123; level[e.to]=level[v] + 1; que.push(e.to); &#125; &#125; &#125;&#125;void add(int from,int to,int cap) &#123; edge eg; eg.to=to; eg.num=tot; eg.cap=cap; eg.rev=G[to].size(); G[from].push_back(eg); eg.num=2*n+m+1+l+tot++; eg.to=from; eg.cap=0; eg.rev=G[from].size()-1; G[to].push_back(eg);&#125;int dfs(int v,int t,int f) &#123; if(v == t)return f; for(int &amp;i = iter[v]; i &lt; G[v].size(); i++) &#123; edge &amp;e=G[v][i]; if(e.cap&gt;0 &amp;&amp; level[v]&lt;level[e.to]) &#123; int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0) &#123; e.cap-=d; G[e.to][e.rev].cap+=d; return d; &#125; &#125; &#125; return 0;&#125;int maxflow(int s,int t) &#123; int flow=0; for(;;) &#123; bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while((f = dfs(s,t,inf))&gt;0) &#123; flow +=f; &#125; &#125;&#125;int dis[maxn],dis2[maxn];void dfs1(int x) &#123; dis[x]=1; for(int i=0; i&lt;G[x].size(); i++) &#123; if(dis[G[x][i].to]==-1&amp;&amp;G[x][i].cap!=0) &#123; dfs1(G[x][i].to); &#125; &#125;&#125;void dfs2(int x) &#123; dis2[x]=1; for(int i=0; i&lt;G[x].size(); i++) &#123; if(dis2[G[x][i].to]==-1&amp;&amp;G[G[x][i].to][G[x][i].rev].cap!=0) &#123; dfs2(G[x][i].to); &#125; &#125;&#125;int main() &#123; while(~scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;l)&amp;&amp;(m+n+l)) &#123; init(n+m+1); tot=1; for(int i=0; i&lt;l; i++) &#123; int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); add(a,b,c); &#125; for(int i=1; i&lt;=n; i++) &#123; add(n+m+1,i,inf); &#125; maxflow(n+m+1,0); mem(dis,-1); mem(dis2,-1); dfs1(n+m+1); dfs2(0); vector&lt;int&gt; v; v.clear(); for(int i=1; i&lt;=n+m; i++) &#123; if(dis[i]==1) &#123; for(int j=0; j&lt;G[i].size(); j++) &#123; if(G[i][j].num&lt;=l&amp;&amp;dis2[G[i][j].to]==1&amp;&amp;G[i][j].cap==0) &#123; v.push_back(G[i][j].num); &#125; &#125; &#125; &#125; if(v.size()==0) &#123; puts(&quot;&quot;); &#125; else &#123; sort(v.begin(),v.end()); for(int i=0; i&lt;v.size(); i++) &#123; printf(&quot;%d%c&quot;,v[i],i+1==v.size()?&apos;\n&apos;:&apos; &apos;); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Multi-University Training Contest 2]]></title>
    <url>%2F2018%2F07%2F29%2F2018%20Multi-University%20Training%20Contest%202%201007%20Naive%20Operations%2F</url>
    <content type="text"><![CDATA[HDU 6135 Naive Operations Time Limit: 6000/3000 MS (Java/Others) Memory Limit: 502768/502768 K (Java/Others) Total Submission(s): 2438 Accepted Submission(s): 1074 Problem Description In a galaxy far, far away, there are two integer sequence a and b of length n. b is a static permutation of 1 to n. Initially a is filled with zeroes. There are two kind of operations: add l r: add one for al,al+1…ar query l r: query ∑ri=l⌊ai/bi⌋ Input There are multiple test cases, please read till the end of input file. For each test case, in the first line, two integers n,q, representing the length of a,b and the number of queries. In the second line, n integers separated by spaces, representing permutation b. In the following q lines, each line is either in the form ‘add l r’ or ‘query l r’, representing an operation.1≤n,q≤100000, 1≤l≤r≤n, there’re no more than 5 test cases. Output Output the answer for each ‘query’, each one line. Sample Input 5 12 1 5 2 4 3 add 1 4 query 1 4 add 2 5 query 2 5 add 3 5 query 1 5 add 2 4 query 1 4 add 2 5 query 2 5 add 2 2 query 1 5 Sample Output 1 1 2 4 4 6 Source 2018 Multi-University Training Contest 2 比赛的时候写了半天没写出来，结果发现是线段树板子敲错了-_-||| 给一段区间，区间的值全部加+1 查询 区间 a[i]/b[i]向下取整的和。 因为查询a[i]/b[i]向下取整，直接求有点难。 所以我们换个操作，我们每次区间加一，变成把每个值减一，每次减到0的时候ai/bi的值就会+1，我们记录这个+1，再把值重新更新为bi，查询的时候查询+1 的总和。 用线段树保留最小值，当出现最小值为0的时候把cnt++，值更新为b[r]，因为每次只会加+1所以总数不会太大 如： 1 2 3 4 5 add 1 4 区间值 0 1 2 3 5 ,出现最小值 0 所以区间 cnt++ 把零变为 b[i] 1 1 2 3 5 然后一直下去，查询直接查询cnt 总和就行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxn=1e5+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int b[4*maxn]; int n,q;int dat[4*maxn],lazy[4*maxn];//lazy保存区间所加的值 dat 为最小值。int res;int cnt[maxn*4]; // 保存每个区间里面的总个数void init(int l,int r,int k) &#123; //初始化 int chl=2*k+1,chr=2*k+2,mid=(l+r)&gt;&gt;1; if(r-l==1) &#123; lazy[k]=cnt[k]=0; dat[k]=b[r]; return ; &#125; else &#123; lazy[k]=cnt[k]=0; init(l,mid,chl); init(mid,r,chr); dat[k]=min(dat[chl],dat[chr]); &#125;&#125;int sum(int a,int c,int l,int r,int k) &#123;//查询总个数 int chl=2*k+1,chr=2*k+2,m=(l+r)/2; if(c&lt;=l||a&gt;=r) &#123; //不在区间内 return 0; &#125; else if(a&lt;=l&amp;&amp;r&lt;=c) &#123; //覆盖这个区间 return cnt[k]; &#125; else &#123; lazy[chl]+=lazy[k]; //把lazy 更新下去 lazy[chr]+=lazy[k]; lazy[k]=0; dat[k]=min(dat[chl]+lazy[chl],dat[chr]+lazy[chr]); return sum(a,c,l,(l+r)/2,k*2+1)+sum(a,c,(l+r)/2,r,k*2+2); &#125;&#125;void update(int a,int c,int l,int r,int k) &#123; int chl=2*k+1,chr=2*k+2,mid=(l+r)/2; if(c&lt;=l||a&gt;=r) &#123; return ; &#125; else if(a&lt;=l&amp;&amp;r&lt;=c) &#123; if(lazy[k]+dat[k]-1&lt;=0) &#123; //如果所覆盖的区间减一出现值小于等于0 就去找那个值 if(r-l==1) &#123; cnt[k]++; //找到后 cnt ++ dat[k]=b[r]; lazy[k]=0; //把当前结点的值重新更新为b[r] return ; &#125; lazy[chl]+=lazy[k]; //向下更新lazy lazy[chr]+=lazy[k]; lazy[k]=0; update(a,c,l,mid,chl); //向左右儿子结点找 update(a,c,mid,r,chr); if(r-l!=1) &#123; cnt[k]=cnt[chl]+cnt[chr]; dat[k]=min(dat[chl]+lazy[chl],dat[chr]+lazy[chr]); //更新值 &#125; return; &#125; lazy[k]--; //如果没有就直接把lazy减一 &#125; else &#123; // 大区间有一部分在小区间内 lazy[chl]+=lazy[k]; lazy[chr]+=lazy[k]; update(a,c,l,mid,chl); update(a,c,mid,r,chr); lazy[k]=0; dat[k]=min(dat[chl]+lazy[chl],dat[chr]+lazy[chr]); //更新 if(r-l!=1)cnt[k]=cnt[chl]+cnt[chr]; &#125;&#125;char ch[10];int l,r;int main() &#123; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;q)!=EOF) &#123; for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;b[i]); &#125; init(0,n,0); while(q--) &#123; scanf(&quot;%s%d%d&quot;,ch,&amp;l,&amp;r); if(ch[0]==&apos;a&apos;) &#123; update(l-1,r,0,n,0); //我写的线段是是(l,r] 所以要记得-1 &#125; else &#123; printf(&quot;%d\n&quot;,sum(l-1,r,0,n,0)); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-4389 X mod f(x) 数位DP]]></title>
    <url>%2F2018%2F07%2F29%2FHDU-4389%20X%20mod%20f(x)%20%20%E6%95%B0%E4%BD%8DDP%2F</url>
    <content type="text"><![CDATA[题目链接 ：HDU - 4389 X mod f(x) Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 3619 Accepted Submission(s): 1409 Problem Description Here is a function f(x): int f ( int x ) { if ( x == 0 ) return 0; return f ( x / 10 ) + x % 10; } Now, you want to know, in a given interval [A, B] (1 &lt;= A &lt;= B &lt;= 109), how many integer x that mod f(x) equal to 0. Input The first line has an integer T (1 &lt;= T &lt;= 50), indicate the number of test cases. Each test case has two integers A, B. Output For each test case, output only one line containing the case number and an integer indicated the number of x. Sample Input 2 1 10 11 20 Sample Output Case 1: 10 Case 2: 3 Author WHU Source 2012 Multi-University Training Contest 9 Recommend zhuyuanchen520 数位DP 所有数的和最大不超过82 dp[pos][sum][mod][res] ，pos 第几位，sum 到第几位每个位数加起来的和，mod， 取模多少 。余数是res ,状态下有多少个数。 然后直接用for暴力取模的数的所有情况。 套个数位DP的板子就行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 #include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;typedef int ll;int dp[10][82][82][82];// 所有数的和最大不超过82 dp[pos][sum][mod][res] ，pos 第几位，sum 到第几位每个位数加起来的和，mod， 取模多少 。余数是res ,状态下有多少个数。int a[25];ll dfs(int pos,ll sum,ll mod,ll res,bool limit) &#123; //状态 pos sum,mod,res, 上线情况limit if(sum&gt;mod)return 0; if(pos==-1) &#123; //当枚举完最后一位返回 if(sum==mod&amp;&amp;res==0)return 1; //满足条件返回1 else return 0; //不满足返回0 &#125; if(limit==0&amp;&amp;dp[pos][sum][mod][res]!=-1)return dp[pos][sum][mod][res];//如果当前状态是已经有过记录且当前没有限制就直接返回已经记录的值 ll up=limit?a[pos]:9,cnt=0;//最大可以枚举到up,如果当前没有上限就可以 0-9,否则只能到当前位的最大值，cnt 记录总共多少 for(int i=0; i&lt;=up; i++) &#123; //跳转状态，前一位，总和加上值，取模数不变，更新余数，如果当前有上限，切加入的值已经到达当前上限 下一种情况才有上线 cnt+=dfs(pos-1,sum+i,mod,(res*10+i)%mod,limit&amp;&amp;i==a[pos]); &#125; if(limit==0)dp[pos][sum][mod][res]=cnt; //当前状态是没有上限的情况下求的和，就可以记录当前状态 return cnt; &#125;ll n,m;ll solve(ll x) &#123; int pos=0; while(x&gt;0) &#123; a[pos++]=x%10; x/=10; &#125; ll ans=0; for(int i=1; i&lt;82; i++) &#123; ans+=dfs(pos-1,0,i,0,true); //直接用for暴力取模的数的所有情况。 &#125; return ans;&#125;int main() &#123; ios_base::sync_with_stdio(0); int t; memset(dp,-1,sizeof(dp)); cin&gt;&gt;t; int l=0; while(t--) &#123; l++; cin&gt;&gt;n&gt;&gt;m; cout&lt;&lt;&quot;Case &quot;&lt;&lt;l&lt;&lt;&quot;: &quot;; cout&lt;&lt;solve(m)-solve(n-1)&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习23]]></title>
    <url>%2F2018%2F07%2F28%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A023%2F</url>
    <content type="text"><![CDATA[牛客练习赛23 这次牛客练习赛，都考了一点小技巧。 A 随便模拟一下 链接：https://www.nowcoder.com/acm/contest/156/A 来源：牛客网 时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format: %lld 题目描述 紧张刺激的世界杯正在进行中(在托米的世界线里)，欧洲人托米沉迷于赌球无法自拔。 托米的口袋里有 100 元，50元，20元，10元，5元，2元，1元的纸币，50分，20分，10分，5分，2分，1分的硬币各无限个。 托米计划买下几注 a 元 b 分的彩票，他希望能支出的纸票数量和硬币数量之和最小，他希望你帮助他完成这个任务。同时由于彩票亭不支持找零，托米希望他的支出恰好等于 a 元 b 分 输入描述:1第一行输入一个正整数 T下面 T 行每行两个整数 a,b 输出描述:1每行输出 13 个正整数 n1 ...n13, 对应题面顺序给出最小化支出纸票数量和硬币数量之和的情况下，每种货币的使用次数，如果有多种方案，输出字典序最大的一种，注意这里字典序是依次比较n1到n13，而不是简单的把 13 个正整数拼接在一起 示例1 输入 复制 123 21 52 4 输出 复制 12 0 0 0 0 0 0 1 0 0 0 1 0 00 0 0 0 0 1 0 0 0 0 0 2 0 备注:1T=100,0≤ a≤ 109, 0≤ b&lt;100 12345678910111213141516171819202122232425262728 #include&lt;bits/stdc++.h&gt;using namespace std;int a[7]= &#123;100,50,20,10,5,2,1&#125;;int b[6]= &#123;50,20,10,5,2,1&#125;;int a1[7],b1[6];int main() &#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; int x,y; cin&gt;&gt;x&gt;&gt;y; for(int i=0; i&lt;7; i++) &#123; a1[i]=x/a[i]; x=x%a[i]; &#125; for(int i=0; i&lt;6; i++) &#123; b1[i]=y/b[i]; y%=b[i]; &#125; for(int i=0; i&lt;7; i++) &#123; printf(&quot;%d%c&quot;,a1[i],&apos; &apos;); &#125; for(int i=0; i&lt;6; i++) &#123; printf(&quot;%d%c&quot;,b1[i],i==5?&apos;\n&apos;:&apos; &apos;); &#125; &#125; return 0;&#125; B 链接：https://www.nowcoder.com/acm/contest/156/B 来源：牛客网 时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format: %lld 题目描述 欧洲人托米非常喜欢数字，他经常在空闲时玩下面的游戏 对于一个数字 n, 托米会随性选中一个数 p, (1 ＜ p &lt;= n), 将 n 拆分成 ,v=n-u,并对 u,v 重复这个过程，直到他有了 n 个 1 1317 为了挑战托米，在每次托米进行划分时，会给托米奖励 u * v 的分数，托米希望你能帮他最大化他的得分。 输入描述:1第一行一个正整数 T下面 T 行每行一个正整数 n 输出描述:1对于每组数据，输出托米的最大得分 示例1 输入 复制 11 5 输出 复制 110 备注:1T≤ 104, n≤ 109 推公式 2 = 1*1 3 =12 +11; 4=13 +12+1*1; 规律就是 Sn = (n*(n-1))/2; 12345678910111213 #include&lt;bits/stdc++.h&gt;using namespace std;long long n;int main() &#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%lld&quot;,&amp;n); printf(&quot;%lld\n&quot;,(n*(n-1))/2); &#125; return 0;&#125; C 链接：https://www.nowcoder.com/acm/contest/156/C 来源：牛客网 时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format: %lld 题目描述 托米完成了1317的上一个任务，十分高兴，可是考验还没有结束 说话间1317给了托米 n 个自然数 a1… an, 托米可以选出一些带回家，但是他选出的数需要满足一些条件 设托米选出来了k 个数 b1,b2… bk, 设这个数列 b 的给值为 b 中所有数按位与的结果，如果你能找到一个整除 b 的最大的 2v,(v≥ 0)， 则设定 v 为这个数列的给价，如果不存在这样的 v，则给价值为 -1, 1317 希望托米在最大化给价的情况下，最大化 k 输入描述:1第一行输入一个整数 n, 第二行输入 a1...an 输出描述:1第一行输出最大的整数 k, 第二行输出 k 个整数 b1... bk, 按原数列的相对顺序输出 (如果行末有额外空格可能会格式错误) 示例1 输入 复制 12 51 2 3 4 5 输出 复制 12 24 5 备注:1n≤ 105, a1... an &lt; 231 题目毒瘤读了半天 给你一个 n 个数 a1 …an,选几个数 b1…bk 然后全部&amp;后 b=b1&amp;b2…&amp;bk, b&amp;2^v==0, v最大就是当前选的这个b序列的值； 求 V最大的情况下K最大。 题解 ：从最高位为1 &amp;到最低位是1 一路下来就行。v 的值是按位于之后最后一位为 1的位置。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 #include&lt;bits/stdc++.h&gt;using namespace std;long long n;typedef long long ll;const int maxn=1e5+5;ll a[maxn],x[maxn];int main() &#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%lld&quot;,&amp;a[i]); &#125; for(int i=0; i&lt;=31; i++) &#123; //预处理下最高位位置的值 x[i]=1&lt;&lt;i; &#125; int k=0,flag=0,bi=0; ll v=0,m=-1; for(int i=31; i&gt;=0; i--) &#123;//从最高为处理到最低位 int t=0; flag=0; for(int j=0; j&lt;n; j++) &#123; if((a[j]&amp;x[i])==x[i]) &#123; //把高于最高位的值全部选上 if(t==0) &#123; flag=a[j]; &#125; else &#123; flag&amp;=a[j]; &#125; t++; &#125; &#125; int pos=0; while(flag&gt;0&amp;&amp;(flag&amp;1)==0) &#123; //判断v 的位置 pos++; flag&gt;&gt;=1; &#125; if(pos&gt;m||(pos==m&amp;&amp;t&gt;k)) &#123; //更新值 m=pos; v=flag&lt;&lt;pos; k=t; &#125; &#125; printf(&quot;%d\n&quot;,k); for(int i=0; i&lt;n; i++) &#123; if((a[i]&amp;v)==v) &#123; //把所有能按位于成 v 的全部输出。 k--; printf(&quot;%lld%c&quot;,a[i],k==0?&apos;\n&apos;:&apos; &apos;); &#125; &#125; return 0;&#125; 有点难懂，看不懂留言。 D 链接：https://www.nowcoder.com/acm/contest/156/D 来源：牛客网 时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format: %lld 题目描述 托米没有完成上一个任务，准备施展黑魔法推倒 1317 黑魔法咒语被描述为一个 长为 n 的，仅包含小写英文字母 ‘a’…’i’ 的字符串，在托米所在的星球，魔法造成的每次有效伤害都是来自他的一个子序列，对于每一个 ‘a’… ‘i’ 的排列(共 9! 种)，若作为咒语的子序列出现, 就会造成 1 的伤害 而咒语的总伤害为所有 ‘a’… ‘i’ 的排列造成的伤害值之和，托米能打出多少点的伤害，是否能击败 1317 呢？ 输入描述:1一行输入一个字符串 s 输出描述:1一行输出一个数，表示伤害值 示例1 输入 复制 1aabcdefghi 输出 复制 11 备注:1|s| ≤ 3000 优雅的暴力。 全排列所有情况，二分查找这种情况在字符串里面可不可行，然后一个个加上。 1234567891011121314151617181920212223242526272829303132333435363738394041 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=4e5+5;char ch[maxn];int n[maxn];vector&lt;int&gt; v[10];int dp[maxn][9];int main() &#123; int ans[9]= &#123;0,1,2,3,4,5,6,7,8&#125;; int k=0; do &#123; for(int i=0; i&lt;9; i++) &#123; dp[k][i]=ans[i]; &#125; k++; &#125; while(next_permutation(ans,ans+9)); cin&gt;&gt;ch; int l=strlen(ch); for(int i=0; i&lt;l; i++) &#123; n[i]=ch[i]-&apos;a&apos;; v[n[i]].push_back(i); &#125; int res=0; for(int i=0; i&lt;k; i++) &#123; int p=-1; for(int j=0; j&lt;9; j++) &#123; int num=dp[i][j]; if(upper_bound(v[num].begin(),v[num].end(),p)==v[num].end()) &#123; break; &#125; int t=upper_bound(v[num].begin(),v[num].end(),p)-v[num].begin(); p=v[num][t]; if(j==8) &#123; res++; &#125; &#125; &#125; cout&lt;&lt;res&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些函数要记的函数笔记]]></title>
    <url>%2F2018%2F07%2F25%2F%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%E8%A6%81%E8%AE%B0%E7%9A%84%E5%87%BD%E6%95%B0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[__builtin_popcount() 求二进制 1的个数。 double add(double a,double b) { if(abs(a+b)&lt;eps *(abs(a)+abs(b))) return 0; return a+b; } 一个 向量操作结构体。 const double eps =1e-8; struct P { double x,y; P() {} P(double x,double y):x(x),y(y) {} P operator + (P p) { return P(add(x,p.x),add(y,p.y)); } P operator - (P p) { return P(add(x,-p.x),add(y,-p.y)); } P operator (double d) { return P(xd,yd); } double dot (P p) { //向量积 return add(xp.x,yp.y); } double det(P p) { //数量积 return add(xp.y,-y*p.x); } }; double Distance(P a,P b) { return sqrt((a.x-b.x)(a.x-b.x)+(a.y-b.y)(a.y-b.y)); } double InterArea(P a,double R,P b,double r) { if(R=R+r) //两圆相离，相交面积为0 return 0; if(dis&lt;=R-r) //两圆内含，相交面积为小圆的面积 return PIrr; //两圆相交时 double angle1=acos((RR+disdis-rr)/(2.0Rdis)); //大圆的那个角 double angle2=acos((rr+disdis-RR)/(2.0rdis)); //小圆的那个角 double s=Rangle1R+rangle2r; s-=Rdissin(angle1); return s; } 全排列 一定要排序 #includeusing namespace std;typedef long long ll;const int maxn=4e5+5;int n[maxn];int dp[maxn][9];int main() {int ans[9]= {0,1,2,3,4,5,6,7,8};int k=0;do {for(int i=0; i&lt;9; i++) {dp[k][i]=ans[i];}k++;} while(next_permutation(ans,ans+9));return 0;} hypot() 求三角斜边]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018杭电多校第一场-2018 Multi-University Training Contest 1]]></title>
    <url>%2F2018%2F07%2F23%2F2018%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%80%E5%9C%BA-2018%20Multi-University%20Training%20Contest%201%2F</url>
    <content type="text"><![CDATA[因为去了躺上海，导致两场牛客多校没有打。这场杭电多校在努力也只能写5题，有了大佬讲题解我就过一下。 Maximum Multiple Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 0 Accepted Submission(s): 0 Problem Description Given an integer n, Chiaki would like to find three positive integers x, y and z such that: n=x+y+z, x∣n, y∣n, z∣n and xyz is maximum. Input There are multiple test cases. The first line of input contains an integer T (1≤T≤106), indicating the number of test cases. For each test case: The first line contains an integer n (1≤n≤106). Output For each test case, output an integer denoting the maximum xyz. If there no such integers, output −1 instead. Sample Input 1 3 1 2 3 Sample Output 1 -1 -1 1 n/s+n/t+n/k=n; 求得 s=3 t=3 k=3 /s=2 t=1 k=1;这两种情况最小，然后暴力就行了 我的写法是打了个表，数据范围不大。 100112345678910111213141516171819202122232425262728293031323334353637383940 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxn=1e6+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int t,n;long long a[maxn];int main() &#123; memset(a,-1,sizeof(a)); for(long long i=1;i*4&lt;=maxn;i++)&#123; a[i*4]=i*i*i*2; &#125; for(long long i=1;i*3&lt;=maxn;i++)&#123; a[i*3]=i*i*i; &#125; cin&gt;&gt;t; while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); printf(&quot;%lld\n&quot;,a[n]); &#125; return 0;&#125; 1002Balanced Sequence Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 0 Accepted Submission(s): 0 Problem Description Chiaki has n strings s1,s2,…,sn consisting of ‘(‘ and ‘)’. A string of this type is said to be balanced: if it is the empty string if A and B are balanced, AB is balanced, if A is balanced, (A) is balanced. Chiaki can reorder the strings and then concatenate them get a new string t. Let f(t) be the length of the longest balanced subsequence (not necessary continuous) of t. Chiaki would like to know the maximum value of f(t) for all possible t. Input There are multiple test cases. The first line of input contains an integer T, indicating the number of test cases. For each test case: The first line contains an integer n (1≤n≤105) — the number of strings. Each of the next n lines contains a string si (1≤|si|≤105) consisting of (&#39; and)’. It is guaranteed that the sum of all |si| does not exceeds 5×106. Output For each test case, output an integer denoting the answer. Sample Input 1 2 1 )()(()( 2 ) )( Sample Output 1 4 2 先处理字符串 把他简化最后所有字符串都会变成 )))((( 像这样的形式。 然后贪心一下每次选左边最长或者右边最长，都没有影响，反正是往两边添加，只要保证选的这个是一种的最大的就行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const int maxn=1e5+25;int t,n;stack&lt;char&gt; s;char ch[maxn];int dp1[maxn],dp2[maxn],ans;struct three &#123; int d1,d2,n;&#125; d[maxn];bool cmp(three &amp;a,three &amp;b)&#123; if(a.d1==b.d1)&#123; return a.d2&gt;b.d2; &#125; return a.d1&gt;b.d1;&#125;int main() &#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; ans=0; scanf(&quot;%d&quot;,&amp;n); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%s&quot;,ch); int pos=0; while(ch[pos]!=&apos;\0&apos;) &#123; if(ch[pos]==&apos;)&apos;) &#123; if(s.size()==0||s.top()==&apos;)&apos;) &#123; s.push(&apos;)&apos;); &#125; else &#123; ans+=2; s.pop(); &#125; &#125; else if(ch[pos]==&apos;(&apos;) &#123; s.push(&apos;(&apos;); &#125; pos++; &#125; int a1=0,a2=0; if(s.size()==0) &#123; i--; n--; &#125; else &#123; while(s.size()&gt;0) &#123; if(s.top()==&apos;)&apos;)a2++; else a1++; s.pop(); &#125; d[i].d1=a1; d[i].d2=a2; d[i].n=i; &#125; &#125; sort(d,d+n,cmp); int k1=d[0].d1,k2=d[0].d2; for(int i=1; i&lt;n; i++) &#123; int k=max(min(k1,d[i].d2),min(k2,d[i].d1)); ans+=2*k; k1=k1-k+d[i].d1; k2=k2-k+d[i].d2; &#125; printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125; 1003Triangle Partition Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 132768/132768 K (Java/Others) Total Submission(s): 0 Accepted Submission(s): 0Special Judge Problem Description Chiaki has 3n points p1,p2,…,p3n. It is guaranteed that no three points are collinear. Chiaki would like to construct n disjoint triangles where each vertex comes from the 3n points. Input There are multiple test cases. The first line of input contains an integer T, indicating the number of test cases. For each test case: The first line contains an integer n (1≤n≤1000) — the number of triangle to construct. Each of the next 3n lines contains two integers xi and yi (−109≤xi,yi≤109). It is guaranteed that the sum of all n does not exceed 10000. Output For each test case, output n lines contain three integers ai,bi,ci (1≤ai,bi,ci≤3n) each denoting the indices of points the i-th triangle use. If there are multiple solutions, you can output any of them. Sample Input 1 1 1 1 2 2 3 3 5 Sample Output 11 2 3 没啥好讲的，排个序从左到右反正不会交叉。 1234567891011121314151617181920212223242526272829303132333435363738394041424344 #include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;typedef pair&lt;char, int &gt; PCI;typedef pair&lt;int, int&gt; PII;typedef pair&lt;LL, LL&gt; PLL;const int MAX = 1e4+7;const int INF = 0x3f3f3f3f;const int mod=1e9+7;int N, M, K, T;struct node &#123; int x, y, id; bool operator&lt;(const node&amp; b) const &#123; return x &lt; b.x; &#125;&#125;;node a[MAX];vector&lt;int&gt; v[MAX];int main() &#123; scanf(&quot;%d&quot;,&amp;T); while(T--) &#123; scanf(&quot;%d&quot;,&amp;N); for(int i = 1; i &lt;= 3*N; i++) &#123; scanf(&quot;%d %d&quot;, &amp;a[i].x, &amp;a[i].y); a[i].id = i; &#125; sort(a+1, a+N*3+1); for(int i = 1; i &lt;= 3*N; i+=3) &#123; printf(&quot;%d %d %d\n&quot;,a[i].id, a[i+1].id, a[i+2].id); &#125; &#125; return 0;&#125; 1004 hiaki has an array of n positive integers. You are told some facts about the array: for every two elements ai and aj in the subarray al..r (l≤i&lt;j≤r), ai≠ajholds. Chiaki would like to find a lexicographically minimal array which meets the facts. Input There are multiple test cases. The first line of input contains an integer T, indicating the number of test cases. For each test case: The first line contains two integers n and m (1≤n,m≤105) — the length of the array and the number of facts. Each of the next m lines contains two integers li and ri (1≤li≤ri≤n). It is guaranteed that neither the sum of all n nor the sum of all m exceeds 106. Output For each test case, output n integers denoting the lexicographically minimal array. Integers should be separated by a single space, and no extra spaces are allowed at the end of lines. Sample Input 1 3 2 1 1 2 4 2 1 2 3 4 5 2 1 3 2 4 Sample Output 1 1 2 1 2 1 2 1 2 3 1 1 队友写的，看了一下，贪心，每次放最小的就行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 #include &lt;bits/stdc++.h&gt;#define fi first#define se second#define lson l,m,rt&lt;&lt;1#define rson m+1,r,rt&lt;&lt;1|1#define lowbit(x) x&amp;-x#define MP make_pair#define debug(x) cout&lt;&lt;x&lt;&lt;&quot;= &quot;&lt;&lt;x&lt;&lt;endl;#define FIN freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt;pii;typedef pair&lt;ll,ll&gt;pll;const int mod=1e9+7;const int inf=0x3f3f3f3f;const ll infll=0x3f3f3f3f3f3f3f3f;const int MX=1e5+7;int n,m;struct node &#123; int l,r; bool operator&lt;(const node&amp;A)const &#123; if(l==A.l) return r&lt;A.r; return l&lt;A.l; &#125;&#125; a[MX];int ans[MX];bool vis[MX];int main() &#123; int T; cin&gt;&gt;T; while(T--) &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=m; i++) &#123; scanf(&quot;%d%d&quot;,&amp;a[i].l,&amp;a[i].r); &#125; sort(a+1,a+m+1); priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q; for(int i=1; i&lt;=n; i++)&#123; ans[i]=1;vis[i]=0; q.push(i); &#125; int l=a[1].l,r=a[1].l; for(int i=1;i&lt;=m;i++)&#123; for(;l&lt;a[i].l;l++)&#123; if(vis[l]) q.push(ans[l]); &#125; for(;r&lt;=a[i].r;r++)&#123; if(r&gt;=a[i].l)&#123; ans[r]=q.top();q.pop(); vis[r]=1; &#125; &#125; &#125; for(int i=1; i&lt;=n; i++) &#123; printf(&quot;%d&quot;,ans[i]); if(i==n) printf(&quot;\n&quot;); else printf(&quot; &quot;); &#125; &#125; return 0;&#125; 1007Chiaki Sequence Revisited Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 428 Accepted Submission(s): 69 Problem Description Chiaki is interested in an infinite sequence a1,a2,a3,…, which is defined as follows: an={1an−an−1+an−1−an−2n=1,2n≥3 Chiaki would like to know the sum of the first n terms of the sequence, i.e. ∑i=1nai. As this number may be very large, Chiaki is only interested in its remainder modulo (109+7). Input There are multiple test cases. The first line of input contains an integer T (1≤T≤105), indicating the number of test cases. For each test case: The first line contains an integer n (1≤n≤1018). Output For each test case, output an integer denoting the answer. Sample Input 1 10 1 2 3 4 5 6 7 8 9 10 Sample Output 1 1 2 4 6 9 13 17 21 26 32 打个表找规律， 1 2 3 4 5 6 7 8 9 10 2 2 1 3 1 2 1 4 1 2 各个数出现的次数就是这样，然后就是lowbit（i）次，然后二分找 到哪个数出现的数次数总和为n 然后再看一下 每次找的的数，x,你会发现，x总是在n/2附近。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include &lt;complex&gt;#include &lt;functional&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxn=1e7+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;long long m,n;long long sum(ll x) &#123; ll ans=1,k=1; while(x&gt;0) &#123;// cout&lt;&lt;x&lt;&lt;endl; if(x%2==1)ans+=x/2*k+1*k; else &#123; ans+=x/2*k; &#125; k++; x/=2; &#125; return ans;&#125;long long js(ll x) &#123; ll res=0,k=1,ans,p=1; while(x&gt;0) &#123; if(x%2==1) &#123; ans=x/2+1; &#125; else &#123; ans=x/2; &#125; ans%=mod; res+=ans*ans%mod*p%mod*k%mod; res%=mod; k++; p=p*2%mod; x/=2; &#125; return res%mod;&#125;int main() &#123; int t; cin&gt;&gt;t; while(t--) &#123; scanf(&quot;%lld&quot;,&amp;n); ll l=0,r=n; if(n&gt;200)&#123; l=n/2-100; r=n/2+100; &#125; while(l&lt;r-1) &#123; ll mid=(l+r)/2; if(sum(mid)&gt;n) &#123; r=mid; &#125; else l=mid; &#125;// cout&lt;&lt;l&lt;&lt;endl; printf(&quot;%lld\n&quot;,(js(l)+(n-sum(l))*(l+1)%mod+1)%mod); &#125; return 0;&#125; 1011Time Zone Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 1646 Accepted Submission(s): 289 Problem Description Chiaki often participates in international competitive programming contests. The time zone becomes a big problem. Given a time in Beijing time (UTC +8), Chiaki would like to know the time in another time zone s. Input There are multiple test cases. The first line of input contains an integer T (1≤T≤106), indicating the number of test cases. For each test case: The first line contains two integers a, b (0≤a≤23,0≤b≤59) and a string s in the format of “UTC+X’’, “UTC-X’’, “UTC+X.Y’’, or “UTC-X.Y’’ (0≤X,X.Y≤14,0≤Y≤9). Output For each test, output the time in the format of hh:mm (24-hour clock). Sample Input 1 3 11 11 UTC+8 11 12 UTC+9 11 23 UTC+0 Sample Output 1 11:11 12:12 03:23 注意精度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxn=1e7+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int t;int main() &#123; cin&gt;&gt;t; int h,m; double ut; while(t--) &#123; scanf(&quot;%d%d UTC%lf&quot;,&amp;h,&amp;m,&amp;ut); int u=ut*100; int k=abs(u); if(k%10&gt;5)k=k/10+1; else k=k/10; if(u&gt;0)u=k; else u=-k;// cout&lt;&lt;u&lt;&lt;endl; m+=u%10*6; if(m&lt;0) &#123; m+=60; h--; &#125; h+=m/60; m=m%60;// cout&lt;&lt;h&lt;&lt;endl; m=m%60; u=u/10-8; h+=u; if(h&lt;0)h+=24; h=h%24; printf(&quot;%02d:%02d\n&quot;,h,m); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 496 (Div. 3) E2 - Median on Segments (General Case Edition)（思维+用bit 位求前缀合）]]></title>
    <url>%2F2018%2F07%2F16%2FCodeforces%20Round%20496%20(Div.%203)%20E2%20-%20Median%20on%20Segments%20(General%20Case%20Edition)%EF%BC%88%E6%80%9D%E7%BB%B4%2B%E7%94%A8bit%20%E4%BD%8D%E6%B1%82%E5%89%8D%E7%BC%80%E5%90%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这题看了别人的博客，看的我一脸懵逼。 思路：很巧秒的转换，我们把&lt;= m 数记为-1, &gt;m的数 记为1， 求其前缀和, 我们将问题转变成求以&gt; m 的数作为中位数的区间个数， 答案就变为ans(m-1) - ans(m )，我们可以用上面求得的前缀用bit就能求出答案。 我特么还不知道是这样写的么，我是不知道怎么用前缀。然后纠结了半天，是咱的基础不好。 所以重点是怎么用bit位来处理前缀和呢？ 只可意会不可言传 12 5 41 4 5 60 4 首先传个 当 k =4 时 就是 -1 -2 -1 0 -1 首先 知道 前缀和为负数的中卫肯定是&lt;=4为正数的一定是&gt;4 结点图如下，至于8以上的结点就不画了，画了也没用前缀合最大值不会超过8； 首先 0 +n+1=5 （初始值都为-1） 和这个以后的结点值 ++； 也就是 6 8结点 都加1； 下一个值 -1 把所有 -1+n=4 一下的结点 的值都加起来。 然后 把 小于 -1+n 的结点和都加一，也就是 4 8都加1； 后面的都是同样的道理 1234567891011121314151617181920212223242526272829303132333435363738394041424344 #include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+5;const int N=2*maxn;int n,m,a[maxn];int v[N];void jl(int x) &#123; for(int i=x; i&lt;N; i+=i&amp;-i) &#123; //这个是来保留的前缀和，假如 当前位置的前缀合 是 -1 ，因为可能出现负数的情况所以加上 n // 然后比 -1 + n 向上跳转的结点 都加上1 v[i]++; &#125;&#125;long long s(int x) &#123; long long sum=0; for(int i=x; i&gt;0; i-=i&amp;-i) &#123; sum+=v[i]; // 计算前缀和，从上往下加，这样会把小于当前结点的值都加起来。 &#125; return sum;&#125;long long cal(int k)&#123; memset(v,0,sizeof(v)); jl(n+1); int dp=0; long long sum=0; for(int i=0;i&lt;n;i++)&#123; if(a[i]&lt;=k)dp-=1; else dp+=1; sum+=s(dp+n); jl(dp+n+1); &#125; return sum;&#125;int main() &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0; i&lt;n; i++)scanf(&quot;%d&quot;,&amp;a[i]); cout&lt;&lt;cal(m-1)-cal(m)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 45 (Rated for Div. 2)]]></title>
    <url>%2F2018%2F06%2F10%2FEducational%20Codeforces%20Round%2045%20(Rated%20for%20Div.%202)%2F</url>
    <content type="text"><![CDATA[A ,B 两题就直接给代码了，没啥讲的 A: 123456789101112131415161718 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;using LL = long long;ll n,m,a,b;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;a&gt;&gt;b; ll k=n/m; if(n%m==0) &#123; cout&lt;&lt;0&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;min((n-k*m)*b,((k+1)*m-n)*a)&lt;&lt;endl; &#125; return 0;&#125; B: 1234567891011121314151617181920212223 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;using LL = long long;const int maxn=2e5+25;int n,a[maxn],k;int main() &#123; cin&gt;&gt;n&gt;&gt;k; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; sort(a, a+n); int mx=1e7+25,ans=0;; for(int i=n-2;i&gt;=0;i--) &#123; int *temp=upper_bound(a,a+n,a[i]); if(temp==a+n)ans++; else if(a[i]+k&lt;*temp||a[i]==*temp)ans++; &#125; cout&lt;&lt;ans+1&lt;&lt;endl;; return 0;&#125; http://codeforces.com/contest/990/problem/C 括号匹配。每个字符串保留前缀和 例如 ((() 前缀和 2 ())) 前缀和 -2； 每次只要把两个数前缀和加起来等于0的数量想成就是可以匹配的数量。 保留负数前缀和的时候一定要是这个前缀和的时候一定是最小的那个，不然本身就是错的。 例如 )))(( ())( 123456789101112131415161718192021222324252627282930 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;using LL = long long;const int maxn=3e5+25;ll n,mx=0;char ch[maxn];map&lt;ll,ll&gt; mp;int main() &#123; cin&gt;&gt;n; for(ll j=0; j&lt;n; j++) &#123; scanf(&quot;%s&quot;,ch); ll flag=0,k=0,l=strlen(ch); for(ll i=0; i&lt;l; i++) &#123; if(ch[i]==&apos;(&apos;)k++; else k--; if(k&lt;0)flag=min(k,flag); &#125; if(flag&lt;0&amp;&amp;k&gt;flag)continue; else &#123; mp[k]++; mx=max(k,mx); &#125; &#125; ll sum=0; for(int i=0; i&lt;=mx; i++) sum+=mp[i]*mp[-i]; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125; D:http://codeforces.com/contest/990/problem/D 题目意思是，给你N个顶点，然后怎么连让他可以有，a,个联通快，然后连的的矩阵的反矩阵 刚好有b个联通快。 例如 3 1 2 矩阵 是 001 001 110 他就是 这个样子 反矩阵就是 010 100 000 图就是 这个样子所以满足条件。 看起来挺难的，实际上就是个傻逼题，就是没连的边一定可以连上，所以无论你一种连成啥样另一种必然是全部联通 所以，a,b必须有一个是 1 ，如果没有就不可行，然后特判一下 2 3 两个 都是 1的情况，为什么要特判呢，自己画个图试试就知道了。 然后就简单了，矩阵其实只要吧 不是 1 的的那个联通快数量分成 1 1 1 1 n-a 这样的几个联通块就行了。 所以只要连 n-a条边。 1234567891011121314151617181920212223242526272829303132333435363738 #include &lt;bits/stdc++.h&gt;using namespace std;const int Maxn = 1005;int n, a, b;char B[Maxn][Maxn];int main() &#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;a, &amp;b); if(a!=1&amp;&amp;b!=1)printf(&quot;NO\n&quot;); else if((n==2||n==3)&amp;&amp;a==1&amp;&amp;b==1)printf(&quot;NO\n&quot;); else &#123; char ca=&apos;1&apos;,cb=&apos;0&apos;; if(a&lt;b) &#123; swap(a,b); swap(ca,cb); &#125; int k=n-a; for(int i=0; i&lt;n; i++) &#123; for(int j=0; j&lt;n; j++) &#123; if(i==j)B[i][j]=&apos;0&apos;; else B[i][j]=cb; &#125; &#125; for(int i=0; i&lt;k; i++) &#123; B[i][i+1]=B[i+1][i]=ca; &#125; printf(&quot;YES\n&quot;); for(int i=0; i&lt;n; i++) &#123; for(int j=0; j&lt;n; j++) printf(&quot;%c&quot;,B[i][j]); printf(&quot;\n&quot;); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中南多校赛八]]></title>
    <url>%2F2018%2F06%2F06%2F%E4%B8%AD%E5%8D%97%E5%A4%9A%E6%A0%A1%E8%B5%9B%E5%85%AB%2F</url>
    <content type="text"><![CDATA[CSU2128 2130 2135 2136 A题 CSU2128 2128: Wells’s Travel PlanSubmit Page Summary Time Limit: 3 Sec Memory Limit: 128 Mb Submitted: 39 Solved: 3 DescriptionWells来到了一个未知的梦幻国度，这个国度有 2N 个城市，分布为一个 2*N 的矩阵。有些城市是无法到达的。一个城市可以到达与之曼哈顿距离为 1 的城市。 大家都知道打acm没有太多的自由时间出去玩，但Wells仍然想知道，如果在从第 l 个城市出发到第 r 个城市的最少需要经过多少城市。 城市的分布如下图: 1, 2, 3, ….N N+1,N+2,N+3….N*2 Input第一行两个正整数 n，m，m 为询问数 接下来两行，每行是一个长度为 N 的字符串，表示城市能否经过。 若为 X，表示不能经过，若为 P，表示可以经过。 接下来 m 行，每行两个整数 l,r，描述一个询问。 Output对于每个询问输出一行，l 到 r 的需要经过的最少城市个数(不包括起点，但包括终点)，若无法到达输出-1。 Sample Input13 4 XPX PPP 1 4 4 2 6 5 6 4 Sample Output1-1 2 1 2 Hint对于所有数据,_n_, _m_ &lt; =2 * 105. A题 本来应该是用倍增，但是暴力还是能卡极限过。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define pi acos(-1.0)#define e 2.718#define lowbit(x) (x&amp;(-x))using namespace std;typedef unsigned long long ull;typedef long long ll;const int N=4e5+9;const long long mod=1e9+7;const int maxn=2e5+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,m;int mp[3][maxn];char ch[maxn];set&lt;int&gt; s[3];int main() &#123; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)&amp;&amp;n&amp;&amp;m) &#123; scanf(&quot;%s&quot;,ch); s[0].clear(); s[1].clear(); for(int i=0; i&lt;n; i++) &#123; if(ch[i]==&apos;X&apos;) &#123; s[0].insert(i); mp[0][i]=-1; &#125; else mp[0][i]=0; &#125; scanf(&quot;%s&quot;,ch); for(int i=0; i&lt;n; i++) &#123; if(ch[i]==&apos;X&apos;) &#123; s[1].insert(i); mp[1][i]=-1; &#125; else mp[1][i]=0; &#125; for(int i=0; i&lt;m; i++) &#123; int a,b; int p=0,sum=0; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); a--; b--; if(a%n&gt;b%n)swap(a,b); int ka=a/n,va=a%n,kb=b/n,vb=b%n; if(mp[ka][va]==-1||mp[kb][vb]==-1)sum=-1; else &#123; set&lt;int&gt;::iterator ite; ite=s[ka].upper_bound(va); if(ite!=s[ka].end())p=*ite; else p=INF; while(p&lt;=vb) &#123; sum+=p-va; ka=!ka; va=p-1; if(mp[ka][va]==-1) &#123; sum=-1; break; &#125; ite=s[ka].lower_bound(p); if(ite!=s[ka].end())p=*ite; else p=INF; if(p-1==va) &#123; sum=-1; break; &#125; &#125; if(sum!=-1) &#123; sum+=vb-va; if(kb!=ka)sum+=1; &#125; &#125; printf(&quot;%d\n&quot;,sum); &#125; &#125; return 0;&#125; C 题 CSU 2130 C(2130):Permutations Submit Page Summary Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 57 Solved: 20 Description 给定两个1~n的排列A, B。每次可以把A的最后一个数取出，插入到A的任何一个位置（最前面或者任何两个数中间）。问最少几次可以把A转化为B。 Input 第一行为一个整数n。第二行为1~n的一个排列，表示A。第三行为1~n的一个排列，表示B。 Output 一个整数即最少操作次数。 Sample Input 5 1 5 2 3 4 1 2 3 4 5 Sample Output 3 Hint 30%：n &lt;=100 50%：n &lt;=1000 100%: n &lt;= 200000 最前面顺序正确的就是不用变换的，所以直接减去就行了。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define pi acos(-1.0)#define e 2.718#define lowbit(x) (x&amp;(-x))using namespace std;typedef unsigned long long ull;typedef long long ll;const int N=4e5+9;const long long mod=1e9+7;const int maxn=1e7+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;int a[maxn],b[maxn];map&lt;int,int &gt; m;int main() &#123; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; for(int i=0; i&lt;n; i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d&quot;,&amp;b[i]); m[b[i]]=i; &#125; int k=m[a[0]],ans=1; for(int i=1; i&lt;n; i++) &#123; if(m[a[i]]&gt;k) &#123; ans++; k=m[a[i]]; &#125; else break; &#125; cout&lt;&lt;n-ans&lt;&lt;endl; &#125; return 0;&#125; H 题 H(2135):Appositive BodySubmitPage Summary Time Limit: 10 Sec Memory Limit: 512 Mb Submitted: 29 Solved: 7 DescriptionYuki Nagato is an aliencreated by the Data Overmind, and possesses supernatural powers as a result.Two of her abilities are to observe the universe and to transcend time and space. As we know, it is unstable ofthe universe if there are more than one active bodies which are actually thesame individual at the same time. Nagato defines them as _appositivebodies_. Of course, Nagato can tell whether there are any appositivebodies of one as soon as she observes. Now, you become able totravel through time and space by some special chance. But before taking action,you have to make sure you won’t destabilize the universe, so you can ask Nagatofor some help, including whether there is an appositive body of you at yourdestination. However, it is inconvenient to make a request every time, so youdecide to study this method. At this time, you are able todescribe the universe abstractly, with several points in a 4-dimension vector,which are the space rectangular coordinates _x_, _y_ and _z_,and the time _t_. After filtered, these points seem to bein alignment. What you need to do now is to check whether these points arecentrosymmetric in four dimensional space. If they are, it means there is yourappositive body at your destination. InputInput consists of severaltest cases, for each test case: First line: a integer _n_ (1 ≤ _n_ ≤ 107), the count ofpoints. Next _n_ lines:each line has four integers _x_, _y_, _z_, _t_ (−108 ≤ _x_, _y_, _z_, _t_ ≤ 108), the coordinate of apoint. OutputFor each test case, output aline: if these points are centrosymmetric in four dimensional space, output”exist”. Otherwise, output “not exist”. Sample Input14 10 0 0 0 1-1 0 3 4 14 8 2 2 15 8 -1 -2 13 10 0 0 0 11 1 1 1 11 1 1 1 14 10 0 0 0 11 1 1 1 11 1 1 1 10 0 0 0 Sample Output1exist 1not exist 1exist 排个序，然后 判断 第 I 个 加上 N-I-1个的xyzt,是不是全部等于2背平均数就行 暴力。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define pi acos(-1.0)#define e 2.718#define lowbit(x) (x&amp;(-x))using namespace std;typedef unsigned long long ull;typedef long long ll;const int N=4e5+9;const long long mod=1e9+7;const int maxn=1e7+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;struct four &#123; double x,y,z,t;&#125; f[maxn];bool cmp(const four &amp;a,const four &amp;b) &#123; if(a.t==b.t) &#123; if(a.x==b.x) &#123; if(a.y==b.y) &#123; return a.z&lt;b.z; &#125; else return a.y&lt;b.y; &#125; else return a.x&lt;b.x; &#125; else return a.t&lt;b.t;&#125;long double cl(long double t)&#123; return t*2/n;&#125;int main() &#123; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; long double x,y,z,t; x=y=z=t=0; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%lf%lf%lf%lf&quot;,&amp;f[i].x,&amp;f[i].y,&amp;f[i].z,&amp;f[i].t); x+=f[i].x; y+=f[i].y; z+=f[i].z; t+=f[i].t; &#125; x=cl(x); y=cl(y); z=cl(z); t=cl(t);// cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;t&lt;&lt;endl; int flag=1; sort(f,f+n,cmp); for(int i=0; i&lt;=(n-1)/2; i++) &#123; if(abs(f[i].x+f[n-i-1].x-x)&gt;eps|| abs(f[i].y+f[n-i-1].y-y)&gt;eps|| abs(f[i].z+f[n-i-1].z-z)&gt;eps|| abs(f[i].t+f[n-i-1].t-t)&gt;eps)&#123; flag=0; &#125; &#125; puts(flag?&quot;exist&quot;:&quot;not exist&quot;); &#125; return 0;&#125; I题 I(2136):统帅三军! Submit Page Summary Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 7 Solved: 1 Description Wells最近迷上了一款攻城的策略游戏，点就去就能当大元帅统帅三军！ 游戏界面主要是一个平面(坐标可以为浮点数)，然而Wells发现这游戏是个骗局，其实只给了一个军队。 Wells初始有一个军队，仅包含n个士兵，每个士兵有一个初始位置（x,y）和一个劳累指数Wi，每个队员可以移动，显然对于每个队员的移动是需要消耗一些体力的，若第i个队员从位置（x1,y1）移动到（x2,y2）的体力消耗为Wi*(|x2-x1|+|y2-y1|)。 Wells希望先将队伍集合起来，且希望整个队伍一次集合的体力消耗越少越好。显然能量消耗的多少直接取决与Wells对于会和点（x,y）的选择，然而Wells太懒了，希望你帮他找出某个时刻的最佳会和点。 Input 对于每组数据： 第一行：一个整数N，表示士兵数目。 第二行：一共N个整数，其中的第i个数Wi表示第i个队员的劳累指数。(N&lt;=106)(N&lt;=106) 接下来N行：每一行两个整数X和Y，表示第i个士兵的当前的横坐标和纵坐标。(−109&lt;=X,Y&lt;=109)(−109&lt;=X,Y&lt;=109) Output 一个实数。表示所有队员集合到最佳攻击位置的体力消耗总和，答案保留两位小数。 Sample Input 1 1 0 0 Sample Output 0.00 I 这题比较毒瘤，写了半天三分发现精度有问题，后来仔细想了下，根本不可能是小数， 他求的是曼哈顿距离，可以把X，Y分开算。 从左往右走到某个点 左边的W &gt; 右边W的和就可以了，那个时候绝对就是临界值 因为再往左走一定是增的比减的少 Y轴也是同理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define pi acos(-1.0)#define e 2.718#define lowbit(x) (x&amp;(-x))using namespace std;typedef unsigned long long ull;typedef long long ll;const int N=4e5+9;const long long mod=1e9+7;const int maxn=1e7+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;struct P&#123; int x,w,y;&#125;p[maxn];bool cmp(const P &amp; a,const P &amp; b)&#123; return a.x&lt;b.x;&#125;bool cmp2(const P &amp;a,const P &amp; b)&#123; return a.y&lt;b.y;&#125;long long jsx(int l)&#123; long long s1=0,s2=0; for(int i=0;i&lt;n;i++) &#123; s1+=abs(p[i].w*(p[i].x-p[l].x)); &#125; for(int i=0;i&lt;n;i++) &#123; s2+=abs(p[i].w*(p[i].x-p[l-1].x)); &#125; return min(s1,s2);&#125;long long jsy(int l)&#123; long long s1=0,s2=0; for(int i=0;i&lt;n;i++) &#123; s1+=abs(p[i].w*(p[i].y-p[l].y)); &#125; for(int i=0;i&lt;n;i++) &#123; s2+=abs(p[i].w*(p[i].y-p[l-1].y)); &#125; return min(s1,s2);&#125;int main() &#123; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;p[i].w); long long aw=0; for(int i=0;i&lt;n;i++) &#123; scanf(&quot;%d%d&quot;,&amp;p[i].x,&amp;p[i].y); aw+=p[i].w; &#125; sort(p,p+n,cmp); long long l=0,r=aw-p[0].w,sum=0; for(int i=1;i&lt;n;i++) &#123; l+=p[i-1].w; r-=p[i].w; if(r&lt;=l) &#123; sum+=jsx(i); break; &#125; &#125; sort(p,p+n,cmp2); l=0;r=aw-p[0].w; for(int i=1;i&lt;n;i++) &#123; l+=p[i-1].w; r-=p[i].w; if(r&lt;=l) &#123; sum+=jsy(i); break; &#125; &#125; printf(&quot;%lld.00\n&quot;,sum); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小生成树Prim&&Kruskal 算法 详细笔记]]></title>
    <url>%2F2018%2F06%2F06%2F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91Prim%26%26Kruskal%20%E7%AE%97%E6%B3%95%20%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[POJ 1258 Agri-Net http://poj.org/problem?id=1258； 两种算法 Prim Kruskal. 先说Prim 初始化 权值，随便一个顶点做起点，为0 其它的为最大值。 找到权值最小的顶点，且没有加入集合。 把顶点权值加到结果，把定点加入集合。 暴力枚举 顶点连接的所有的边，更新所有能够连接上顶点的权值。 重复前3步，直到所有点全部加入集合。 以上图就是 首先找到的是 0节点 一开始权值是0，所以res +=0；然后暴力所有能够连接的点就是 1，和2， 然后更新 mincost[2]=min(INF,2)，结果等于2；同理 mincost[1]=10; 其它点的权值不变。 然后又开始找找到 2 顶点，然后暴力所有点，这次更新的就是3 4 5顶点。然后不断重复就行了 最后连接起来的树是这个样子的。 下面是代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxv=1e3+25; //最大顶点数const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int cost[maxv][maxv]; // cost[u][v] 表示 u 到 v 的权值如果没有边权值为无穷大（INF）;int mincost[maxv]; //每个点的最小权值，起点自己为0，其它为自己连接到集合最小权值；bool used[maxv]; //表示顶点 是否已经连接上；int V; //顶点数目；int prim() &#123; for(int i=0; i&lt;V; i++) &#123; mincost[i]=INF; //开始的时候全部初始化为无穷大。 used[i]=false; //初始化 ，全部没有连接。 &#125; mincost[0]=0; //以 0 节点为起点开始连接。 int res = 0; //权值和 while(1) &#123; int v=-1; //选择的节点，开始为-1，然后开始找已经确定是最小的距离 for(int u=0; u&lt;V; u++) &#123; if(!used[u]&amp;&amp; (v == -1 || mincost[u]&lt;mincost[v]))v=u; //如果 v==-1或者不是最小距离的时候更新v。 &#125; if(v==-1)break; //只有在所有的点都已经加入集合 v==-1。跳出循环。 used[v]=true; //把顶点加入集合。 res+=mincost[v]; //把边的长度加到结果里 for(int u=0; u&lt;V; u++) &#123; mincost[u]=min(mincost[u],cost[v][u]); //从当前点到其它点的距离如果比其他路短就更新。 &#125; &#125; return res;&#125;int main() &#123; int m; scanf(&quot;%d%d&quot;,&amp;V,&amp;m); //输入顶点数和边数。 注意定点是从 0 到V-1。 for(int i=0; i&lt;m; i++) &#123; int u,v,w; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); cost[u][v]=cost[v][u]=w; &#125; printf(&quot;%d\n&quot;,prim());//下面是POJ 1258 主程序代码。 /* while(cin&gt;&gt;V) &#123; for(int i=0; i&lt;V; i++) &#123; for(int j=0; j&lt;V; j++) &#123; cin&gt;&gt;cost[i][j]; &#125; &#125; printf(&quot;%d\n&quot;,prim()); &#125; */ return 0;&#125; 接下来是Kruskal 代码 这个算法其实和Prim 算法差距不大，这个是直接把边排序 找到最小的边 判断边的两个节点是不是连接到同一颗树上，是跳过，不是连接两个顶点的根节点，结果加上边。 重复上面两步，直到连接N-1条边，因为N个顶点要N-1条边就能连接起来。 对于这个图，首先就找到（2，3 ）这条边连起来，然后就是（4 5），然后（0 2），这时候有2棵树 （0 2 3 ）和（4 5）然后接着连 （2 5）（5 6 ）（1 4）就全部连接上了 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxv=1e3+25; //最大顶点数const int maxm=1e6+25; //最大边数const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int V,m; //顶点数目；struct edge &#123; int u,v,cost; //节点用来 保存每个边的情况&#125;;bool cmp(const edge &amp; a,const edge &amp; b) &#123; return a.cost&lt;b.cost; //用于排序，相当于重载小于号。&#125;edge es[maxm];int par[maxv]; // par[i]==j. i 的 根节点为 j;int find(int x) &#123; //寻找根节点 if(x==par[x])return x; //如果根节点就是自己直接返回自己 else return par[x]=find(par[x]); //如果根节点不是自己，继续寻找自己上一个节点的根节点。&#125;void unit(int x,int y) &#123; x=find(x); //找到 x 的根节点 y=find(y); par[x]=y; //把 x 的根节点 连接上 y.&#125;void init(int n) &#123; for(int i=0; i&lt;=n; i++)par[i]=i; //初始化的时候根节点都是自己；&#125;int Kruskal() &#123; sort(es,es+m,cmp); //按 边的权值排序； init(V); int res=0,se=0; //se 保存边数。 for(int i= 0; i&lt;m; i++) &#123; edge e =es[i]; if(find(e.u)!=find(e.v)) &#123; //如果根节点不相同就连接 unit(e.u,e.v); res+=e.cost; if(++se==V-1)return res; //如果连了V-1条边就跳出； &#125; &#125; return res;&#125;int main() &#123; scanf(&quot;%d%d&quot;,&amp;V,&amp;m); //输入顶点数和边数。 注意定点是从 0 到V-1。 for(int i=0; i&lt;m; i++) &#123; int u,v,w; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); es[i].u=u; es[i].v=v; es[i].cost=w; &#125; printf(&quot;%d\n&quot;,Kruskal()); // POJ 1285 AC 主程序代码 /* while(cin&gt;&gt;V) &#123; int k=0; for(int i=0; i&lt;V; i++) &#123; for(int j=0; j&lt;V; j++) &#123; cin&gt;&gt;es[k].cost; es[k].u=i; es[k].v=j; k++; &#125; &#125; m=k; printf(&quot;%d\n&quot;,Kruskal()); &#125;*/ return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛19]]></title>
    <url>%2F2018%2F06%2F04%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B19%2F</url>
    <content type="text"><![CDATA[链接：https://www.nowcoder.com/acm/contest/111/A来源：牛客网 时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 524288K，其他语言1048576K64bit IO Format: %lld 题目描述 作为故事主角的托米是一名老师。 一天，他正在为解析算术表达式的课程准备课件。 在课程的第一部分，他只想专注于解析括号。 他为他的学生发明了一个有趣的正确括号序列的几何表示，如下图所示: 几何表示的定义： 1. 对于一个括号序列A，我们定义g(A)是A的几何表示形式,则 “()”的表示是一个1*1的方块，高度为1; 2.对于一个括号序列A，”(A)”的表示是由一个比g(A)宽2个单位高1个单位的矩形包围g(A)，它的高度为A+1;3.对于两个括号序列A和B，A+B的几何表示形式为把g(B)放置在g(A)右边的一个单位，且高度为A和B的高度的较大值。其中+指的是字符串的连接符。 在完成课件后，托米老师开始玩他做好的图片。 他将图像的有限区域交替地涂成黑色和白色，使最外面的区域全部涂成黑色。 对于上面的例子，这个着色如下所示： 现在给你一个合法的括号序列。 请计算颜色为黑色的区域的面积。 输入描述: 输入的第一行包含一个整数T，表示指定测试用例的数量。每个测试用例前面都有一个空白行。每个测试用例由一个合法括号序列组成。 每行只包含字符’(‘和’)’。 输出描述: 对于每个测试用例，输出一行包含一个整数,表示相应几何表示的黑色部分的面积。 示例1 输入 复制 2 ((())) (())(()(())) 输出 复制 10 20 说明 第二个测试案例是上图中显示的案例。 备注: 1≤T≤10 一个合法括号序列长度≤4 x 105 这题主要是处理三个问题 一个是长方体的高度，一个长度，白色还是黑色。 首先预处理，颜色，和高度 颜色，判断是第几个奇偶就行了，第一个肯定是黑色，第二个就是白色。 注意处理的时候每匹配一个’)’ 数量就要减1； 长方体的高，用一棵树就行了，然后每个‘（’的度就是每个长方形的高度。 长度容易处理 直接找到匹配的括号直接距离 -1 就是长方体长度 我用栈来保存 ‘（’的位置。 遇见’(’压入栈 ，遇见‘)’弹出 ，计算距离。如果是白色就是减去这个长方形的面积，黑色就加上。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxn=1e7+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int a[maxn];int p[maxn],b[maxn];char ch[maxn];int n;stack&lt;int&gt; s;int main() &#123; scanf(&quot;%d&quot;,&amp;n); while(n--) &#123; scanf(&quot;%s&quot;,ch); int l=strlen(ch); a[0]=1; int x=1,y=0; p[0]=-1; b[0]=1; int k=0; for(int i=1; i&lt;l; i++) &#123; if(ch[i]==&apos;(&apos;) &#123; a[i]=a[i-1]+1; p[i]=k; k=i; b[k]=1; &#125; else &#123; b[p[k]]=max(b[p[k]],b[k]+1); k=p[k]; a[i]=a[i-1]-1; &#125; &#125;// for(int i=0;i&lt;l;i++)// printf(&quot;%d%c&quot;,b[i],i+1==l?&apos;\n&apos;:&apos; &apos;); long long flag=1,sum=0; for(int i=0; i&lt;l; i++) &#123; if(ch[i]==&apos;(&apos;) &#123; s.push(i); &#125; else &#123; int k=s.top(); s.pop(); if(a[k]%2==1)sum=sum+(i-k)*(b[k]); else sum-=(i-k)*(b[k]); &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125; D： 链接：https://www.nowcoder.com/acm/contest/111/D来源：牛客网 时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 524288K，其他语言1048576K 64bit IO Format: %lld 题目描述 此时的托米老师已经出任CEO，迎娶白富美，走向了人生巅峰！于是这个暑假，托米老师打算在北京一个偏僻的小农村里度过他的假期。 由于这里什么都没有，于是他去超市选了很多生活用品，更多的是吃的，然后推着堆满零食的购物车到柜台等待结账。 当然，我们都知道他的钱包里有很多钱。但是，作为一名为生活精打细算的男孩子，他更愿意使用其他支付方式如：饭券，礼券，不同类型的优惠券等。但是饭券只能用于购买食物，而礼券通常只限于某种类型的礼物。 现在给你托米购物车中物品的数量N和每件物品的价格。也会给出他钱包中的代金券数量M以及允许使用的信息 。 在为他的购物付款时，托米可能使用代金券的金额超过他所购物品的成本。也可以在多张代金券之间拆分商品的成本，并使用代金券支付多件商品。 请你计算托米需要为购物支付的额外现金的最小金额。 输入描述:1输入的第一行包含一个整数T，用于指定测试用例的数量。 每个测试用例前面都有一个空白行。 每个测试用例从包含两个正整数N(物品数量)和M(券数量)的行开始。 接下来一行包含N个数字，第i个数字表示托米购物车里第i件物品的价格。 接下来一行包含M个数字，第i个数字表示第i张券的金额。 接下来有M行，当中的第 i 行描述第 i 张卷可以买哪些商品。每行的第一个数字是 K,代表第 i 张卷可以为 K 件商品付款，接下来还有 K 个数，是这 K 件商品的编号 输出描述:1对于每个测试用例输出数字，表示托米需要支付多少现金。 最大流模板题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxn=2e2+25;const int maxm=4e3+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,m,T;int a[maxn],b[maxm];struct edge &#123; int to,cap,rev;&#125;;vector &lt;edge&gt; G[maxn+maxm];bool used[maxn+maxm];int level[maxn+maxm];int iter[maxn+maxm];void bfs(int s) &#123; memset(level,-1,sizeof(level)); queue&lt;int&gt; que; level[s]=0; que.push(s); while(!que.empty()) &#123; int v= que.front(); que.pop(); for(int i=0; i&lt;G[v].size(); i++) &#123; edge &amp; e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0) &#123; level[e.to]=level[v] + 1; que.push(e.to); &#125; &#125; &#125;&#125;void add(int from,int to,int cap) &#123; edge eg; eg.to=to; eg.cap=cap; eg.rev=G[to].size(); G[from].push_back(eg); eg.to=from; eg.cap=0; eg.rev=G[from].size()-1; G[to].push_back(eg);&#125;//int dfs(int v,int t,int f) &#123;// if(v == t)return f;// used[v]=true;// for(int i = 0; i &lt; G[v].size(); i++) &#123;// edge &amp;e=G[v][i];// if(!used[e.to]&amp;&amp;e.cap&gt;0) &#123;// int d=dfs(e.to,t,min(f,e.cap));// if(d&gt;0) &#123;// e.cap-=d;// G[e.to][e.rev].cap+=d;// return d;// &#125;// &#125;// &#125;// return 0;//&#125;int dfs(int v,int t,int f) &#123; if(v == t)return f; for(int &amp;i = iter[v]; i &lt; G[v].size(); i++) &#123; edge &amp;e=G[v][i]; if(e.cap&gt;0 &amp;&amp; level[v]&lt;level[e.to]) &#123; int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0) &#123; e.cap-=d; G[e.to][e.rev].cap+=d; return d; &#125; &#125; &#125; return 0;&#125;/*int maxflow(int s,int t) &#123; int flow=0; for(;;) &#123; memset(used,0,sizeof(used)); int f=dfs(s,t,INF); if(f==0)return flow; flow += f; &#125;&#125;*/int maxflow(int s,int t) &#123; int flow=0; for(;;) &#123; bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while((f = dfs(s,t,INF))&gt;0) &#123; flow +=f; &#125; &#125;&#125;int main() &#123; scanf(&quot;%d&quot;,&amp;T); while(T--) &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int sum=0; for(int i=0;i&lt;=m+n+1;i++)G[i].clear(); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); sum+=a[i]; add(i,n+m+1,a[i]); &#125; for(int j=1; j&lt;=m; j++) &#123; scanf(&quot;%d&quot;,&amp;b[j]); add(0,n+j,b[j]); &#125; for(int i=1; i&lt;=m; i++) &#123; int k; scanf(&quot;%d&quot;,&amp;k); for(int j=0; j&lt;k; j++) &#123; int x; scanf(&quot;%d&quot;,&amp;x); add(n+i,x,a[x]); &#125; &#125; cout&lt;&lt;sum-maxflow(0,n+m+1)&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP]]></title>
    <url>%2F2018%2F05%2F23%2FKMP%2F</url>
    <content type="text"><![CDATA[KMP算法，刚接触到这个算法本来一看是看一眼就会了，但是过了一段时间反而不会了，搞得我又重新回来学了一次。 其实KMP算法挺简单的，这个算法的核心我感觉就是在处理next 数组上。 我先讲一下一种处理方式吧， next [0]=-1,这个不用多说，第一个肯定是没有匹配好的。 k=-1; ,i=0两个初始化 ，k,表示的是匹配到的位置 ，i，表示的是你正在为那个位置标记next。 123456789101112131415161718192021222324252627282930313233343536 #include&lt;bits/stdc++.h&gt;using namespace std; void getnext(const char * str,int * next) &#123; next[0]=-1; int i=0,k=-1; while(str[i]!=&apos;\0&apos;) &#123; while(k!=-1&amp;&amp;str[i]!=str[k])k=next[k];// 在你匹配这个 i 之前首先寻找到前面一个最大匹配位置， //如果 不匹配就一直往前面回溯，直到能够匹配。 i++; k++; if(str[i]==str[k])next[i]=next[k]; //当前位置是相等的 这个不匹配 同样 K的位置也没法匹配，所以 next [i]可以直接等于next[k]. else next[i]=k; &#125;&#125;int kmp(const char *s,const char * c)&#123; int lc=strlen(c),ls=strlen(s); int *next=new int[lc+1]; getnext(c,next); int j=0,i=0; while(i&lt;ls) &#123; while(j!=-1&amp;&amp;s[i]!=c[j])j=next[j]; i++,j++; if(j==lc)return 1; &#125; return 0;&#125; int main() &#123; int next[1000]; char ch[]=&quot;abaabc&quot;,s[]=&quot;ababaababcb&quot;; cout&lt;&lt;kmp(s,ch)&lt;&lt;endl;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DP学习笔记，题目 Traveling by Stagecoach POJ 2686 题解]]></title>
    <url>%2F2018%2F05%2F19%2FDP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8C%E9%A2%98%E7%9B%AE%20Traveling%20by%20Stagecoach%20POJ%20%202686%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Traveling by Stagecoach POJ 2686，题解。 作为一名菜鸟，说状压DP，还是有点勉强，顶多做个学习笔记。 首先，什么是DP，状态转移，其实就是从已经确定的状态，到一个状态。 状压DP，我理解的就是 用 一个数的二进制表达状态。 1，表示 有 ，0 表示无 比如 4而进制表示 100 ， 说明 3号 位置表示 有 ，其它的都表示没有。 题目 Traveling by Stagecoach POJ 2686 开一个DP【S】[M]. S 是票的使用状况 ， M，是在哪一个城市。值就是最小花费。 把一个票都没有用的，起点 标记为0,也就是 DP[1&lt;&lt;n-1][a]==0. 暴力枚举 所有 可以用的票 ，(S&gt;&gt;i)&amp;1 表示第 I 张票可不可以用。 再暴力枚举 当前这个S下所有的 可以到的城市，dp[S][v]!=INF，当前S下v这个城市可不可以到达。 然后再暴力所有 v， 这个城市所有的路，然后使用第 i张票。d[v][u]&gt;=0。V 和u中间的路。 然如果用这张票，走这条路 到目的地的值小就覆盖前面的值S&amp;~(1&lt;&lt;i)使用第i张票后的状态，d[v][u],从 v城市到u城市的路。 dp[S&amp;~(1&lt;&lt;i)][u]=min(dp[S&amp;~(1&lt;&lt;i)][u],dp[S][v]+(double)d[v][u]*1.0/t[i])。 AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;stdio.h&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxn=9;const int maxm=31;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,m,a,b,p,u,v,c;int t[maxn];int d[maxm][maxm];double dp[1&lt;&lt;maxn][maxm];int main() &#123; ios_base::sync_with_stdio(false); cin.tie(0);// freopen(&quot;123.txt&quot;,&quot;r&quot;,stdin); while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;p&gt;&gt;a&gt;&gt;b) &#123; int k=(1&lt;&lt;n)-1; if(n==0&amp;&amp;m==0&amp;&amp;p==0&amp;&amp;a==0&amp;&amp;b==0)return 0; for(int i=0; i&lt;n; i++)cin&gt;&gt;t[i]; memset(d,-1,sizeof(d)); while(p--) &#123; cin&gt;&gt;u&gt;&gt;v&gt;&gt;c; d[u][v]=c; d[v][u]=c; &#125; for(int i=0; i&lt;=k; i++)fill(dp[i],dp[i]+m+1,INF); dp[k][a]=0; double res=INF; for(int S=k; S&gt;=0; S--) &#123; res=min(res,dp[S][b]); for(int i=0; i&lt;n; i++) &#123; if((S&gt;&gt;i)&amp;1) &#123; for(v =1; v&lt;=m; v++) &#123; if(dp[S][v]!=INF) &#123; for(u=1; u&lt;=m; u++) &#123; if(d[v][u]&gt;=0) &#123; dp[S&amp;~(1&lt;&lt;i)][u]=min(dp[S&amp;~(1&lt;&lt;i)][u],dp[S][v]+(double)d[v][u]*1.0/t[i]); &#125; &#125; &#125; &#125; &#125; &#125; &#125; if(res==INF) &#123; printf(&quot;Impossible\n&quot;); &#125; else &#123; printf(&quot;%.3f\n&quot;,res); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 湘潭邀请赛 部分题解]]></title>
    <url>%2F2018%2F05%2F14%2F2018%20%E6%B9%98%E6%BD%AD%E9%82%80%E8%AF%B7%E8%B5%9B%20%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[2018 湘潭邀请赛 题解 A C F G K .其它题解，后续添加 A 题 没啥好讲的，签到题 从后面往前面数，大于个数的时候直接输出就行了。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;const long long mod=1e9+7;const int maxn=2e5+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int main() &#123; int n,a[maxn]; long long sum=0; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) &#123; sum=0; for(int i=0; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; for(int i=n; i&gt;=0; i--) &#123; sum+=a[i]; if(sum&gt;=i) &#123; printf(&quot;%d\n&quot;,i); break; &#125; &#125; &#125; return 0;&#125; C题 题目的意思就是找一个区间比 一个数大的数的个数要不小于这个数。求这个数最大是多少。 这一题就是一个区域树（大佬们告诉我也叫主席树，然而我这个菜鸡不知道啥是主席树），一般线段树维护的是一个值。这题每个节点维护的是一个数组，这个题没有修改只有查询。 每次查询在包含这个区间就二分查找大于这个数的个数， 如果 不包含返回零。 如果有一部分在这个区间就继续往下找，然后返回两个儿子的个数和。 复杂度是（nlogn+m log^3 n）; AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;const long long mod=1e9+7;const int maxn=1e7+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;const int sz=(1&lt;&lt;18)-1;int n,m;int a[maxn];vector&lt;int&gt; dat[sz];void init(int k,int l,int r) &#123; dat[k].clear(); if(r-l==1)dat[k].push_back(a[l]); else &#123; int lch=k*2+1,rch=k*2+2,md=(l+r)/2; init(lch,l,md); init(rch,md,r); dat[k].resize(r-l); merge(dat[lch].begin(),dat[lch].end(),dat[rch].begin(),dat[rch].end(),dat[k].begin()); &#125;&#125;int query(int i,int j,int x,int k,int l,int r) &#123; if(j&lt;=l||r&lt;=i)return 0; else if(i&lt;=l&amp;&amp;r&lt;=j) &#123; return dat[k].end()-lower_bound(dat[k].begin(),dat[k].end(),x); &#125; else &#123; int lch=2*k+1,rch=2*k+2,md=(l+r)/2; return query(i,j,x,lch,l,md)+query(i,j,x,rch,md,r); &#125;&#125;int main() &#123; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)) &#123; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; init(0,0,n); int l,r,R,L,x; for(int i=0; i&lt;m; i++) &#123; scanf(&quot;%d%d&quot;,&amp;l,&amp;r); l--; L=1; R=n; while(R-L&gt;1) &#123; x=(R+L)/2; int c=query(l,r,x,0,0,n); if(c&gt;=x)L=x; else R=x; &#125; printf(&quot;%d\n&quot;,L); &#125; &#125; return 0;&#125; F题 一个sort 就过了没啥难的，就是注意值爆了double 要用long double。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;const long long mod=1e9+7;const int maxn=1e3+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;struct two &#123; long double val; int id;&#125; k[maxn];bool cmp(two &amp; a,two &amp;b) &#123; if(a.val==b.val)return a.id&lt;b.id; return a.val&lt;b.val;&#125;int main() &#123; int n; long long a,b,c,d; while(~scanf(&quot;%lld&quot;,&amp;n)) &#123; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c); long double t=0; t=a*1.0; t+=b*1.0; t=t/(t+c*1.0); k[i].id=i; k[i].val=t; &#125; sort(k,k+n,cmp); for(int i=0; i&lt;n; i++) &#123; printf(&quot;%d%c&quot;,k[i].id+1,i+1==n?&apos;\n&apos;:&apos; &apos;); &#125; &#125; return 0;&#125; G题 找规律，这个变化可以保证 两个a,b一定可以消去，a,b,的位置可以交换，所以题目就变成了找两个字符串对应的，c ,左右两边的a,b奇偶是不是一样的。 如果c个数不相等直接输出no； 相等 判断 ，以c为分隔符的区间 a,b,的奇偶相不相等。 AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;const long long mod=1e9+7;const int maxn=1e4+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;struct two &#123; int x,y;&#125; k[maxn],k2[maxn];int main() &#123; char a[maxn],b[maxn]; int flag,c; while(~scanf(&quot;%s%s&quot;,&amp;a,&amp;b)) &#123; int la=strlen(a),lb=strlen(b); memset(k,0,sizeof(k)); memset(k2,0,sizeof(k2)); c=0; flag=1; int pa,pb; pa=pb=0; for(int i=0; i&lt;la; i++) &#123; if(a[i]==&apos;a&apos;) &#123; k[pa].x=(k[pa].x+1)%2; &#125; if(a[i]==&apos;b&apos;) &#123; k[pa].y=(k[pa].y+1)%2; &#125; if(a[i]==&apos;c&apos;) &#123; pa++; c++; &#125; &#125; for(int i=0; i&lt;lb; i++) &#123; if(b[i]==&apos;a&apos;) &#123; k2[pb].x=(k2[pb].x+1)%2; &#125; if(b[i]==&apos;b&apos;) &#123; k2[pb].y=(k2[pb].y+1)%2; &#125; if(b[i]==&apos;c&apos;) &#123; pb++; c--; &#125; &#125; int l=max(pa,pb); if(c!=0)flag=0; for(int i=0; i&lt;=l; i++) &#123; if(k[i].x!=k2[i].x||k[i].y!=k2[i].y) &#123; flag=0; &#125; if(!flag)break; &#125; if(flag)printf(&quot;Yes\n&quot;); else printf(&quot;No\n&quot;); &#125; return 0;&#125; K题 就是一个找因子的题 2018 因子 1 ，2018 ，2 ，1009； 所以 所有的 奇数可以和所有的 2018的倍数匹配。 2018 可以和所有的数匹配， 偶数 可以和所有 1009 的倍数匹配 1009 可以和所有 偶数匹配； 注意一下，其中重复算的就行。 AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;const long long mod=1e9+7;const int maxn=2e5+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int main() &#123; long long sum=0,a,b,c,d; while(scanf(&quot;%lld%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c,&amp;d)!=EOF) &#123; sum=0; long long x1,x2,x1009,x2018,y1,y2,y1009,y2018; x2=x1=(b-a+1)/2; if((b-a)%2==0) &#123; if(a&amp;1)x1++; else x2++; &#125; x1009=(a%1009==0)+b/1009-a/1009; x2018=(a%2018==0)+b/2018-a/2018; y2=y1=(d-c+1)/2; if((d-c)%2==0) &#123; if(c&amp;1)y1++; else y2++; &#125; y1009=(c%1009==0)+d/1009-c/1009; y2018=(c%2018==0)+d/2018-c/2018; sum+=(x1-x1009+x2018)*y2018; sum+=x2018*(y1+y2); sum+=(x2-x2018)*(y1009); sum+=(x1009-x2018)*y2; printf(&quot;%lld\n&quot;,sum); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bit 位，树状数组学习笔记。]]></title>
    <url>%2F2018%2F04%2F25%2Fbit%20%E4%BD%8D%EF%BC%8C%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%82%2F</url>
    <content type="text"><![CDATA[给一个初始值全为0的数列a1,a2,…,an. 给定 i，求a1+a2+..+ai. 给定i,x 执行ai+x; 图不好看见谅： 如图所示，1节点维护的是a1本身的和 2节点维护的是 a1到a2 的和 3节点维护的是a3的和 4节点维护的是a1到a4 的和 为啥会有些节点维护的值的个数不同呢？ 很简单 ，就是看最后一个1的位置，2：二进制0010 最后一个1是第2个位置所以维护2的2-1次方个值。4：0100维护2的3-1次方个值。 加法，把有维护自己的值都加上X就行了 加法：例子在a3上+X就是在3节点上+X，4节点+X，8节点+X。看一眼上图，就知道，就是按箭头一个个向上节点转移。 怎么实现这种转移呢？ 3的二进制是0011.4是 0100，8是1000. 就是把加上最后一个1所在位置的值，0011 +0001（最后一个位置是最后一个）=0100； 0100+0100（最后一个1位置是第3个）=1000； 以此类推，在a5也是一样,0101+0001=0110(6); 0110+0010=1000(8); 怎么实现，就是i+=i&amp;-i; i&amp;-i可以把自己最后一个1的位置算出来，怎么来的就自己去百度吧。 求和：比如 前5个的和，就是（1到4）+5 也就是4节点加5节点的和。 前7个的和就是7+（5到6）+（1到4）的和，也就是4节点加6节点加7节点的和。 至于怎么实现呢如果细心的话不难发现，其实就是从最后一个1慢慢一个个变成0的节点全加上 如 7的二进制是0111 前7个的和就是 0111+ 0110+0100 前 5（0101）个的和 0101 +0100 按位运算就是 i-=i&amp;-i. 代码非常简单。 复杂度 O（log N）; includeusing namespace std;const int maxn=1&lt;0) { s +=bit[i]; i-=i&amp;-i; } return s;}void add(int i,int x){ while(i&lt;=n) { bit[i]+=x; i+=i&amp;-i; }}]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIT基本操作，和别人一起做项目]]></title>
    <url>%2F2018%2F04%2F16%2FGIT%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%92%8C%E5%88%AB%E4%BA%BA%E4%B8%80%E8%B5%B7%E5%81%9A%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[Git基本操作 GIT教程：https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 GIT下载： 在自己的电脑上，安装Git下载页面：https://git-scm.com/downloads下载安装，一路下一步即可。 GitHub Desktop下载地址：https://desktop.github.com GIT 简单的使用： 1、 注册码云： 码云注册页面：https://gitee.com/signup 应该不需要我多说 2、你需要访问仓库（是个网址）： 如果你需要创建自己有一个专门的分支还需要fork； 点击fork 后会让你选择自己，然后 点击确定 ，左上角变成你自己的名字就对了。 左上角变成你自己的名字就对了 左上角变成你自己的名字就对了 左上角变成你自己的名字就对了 一定要记住 ，那个红圈里面是自己的码云昵称。不然你就等着一直认证失败吧。 点击的【克隆/下载】，点击【复制】按钮复制下面的连接，我们把这个连接称为【连接①】 3、开始clone ： 第一种： 要打开的是Git Bash Here 不是 Git GUI here 上图指错了 然后开始克隆就行了，输入 命令 git clone 做完这些你就会发现你当前文件夹下面多了你clone出来的文件夹，也就是你的本地仓了。 第二种： 打开cmd窗口 按Win键+R，输入cmd，按【确定】 1在cmd窗口中切换文件夹 随便找一个文件夹 比如d盘中123文件夹，那么输入D: 敲回车，cd 123 敲回车即可切换 1这个是转换到你要转换到你要clone的目录下 然后输入 12 1git config --global user.name &quot;注册码云时用的昵称&quot; 12 1git config --global user.email &quot;注册码云时用的邮箱&quot; 这个是登录 特别提醒：转到的目录是仓库下，不是你原本clone的目录下，是到clone出来的那个文件夹目录下。别和前面clone的目录一样。 特别提醒：转到的目录是仓库下，不是你原本clone的目录下，是到clone出来的那个文件夹目录下。别和前面clone的目录一样。 特别提醒：转到的目录是仓库下，不是你原本clone的目录下，是到clone出来的那个文件夹目录下。别和前面clone的目录一样。 和第一种的区别是用的是自己电脑带的命令行。不是git给的。 4.上传 上去 一样的有两种操作我就之说一种，另一种自己照着上面两种进行操作。 先进行修改 修改后 进入命令行 操作 转到仓库位置也就是你clone出来的文件夹。这个是clone出来的文件夹位置（本地仓的位置），不是clone到的位置。git add -A .git commit -m “姓名”git push 第一次push 需要登陆 ，输入密码的时候 输入什么都看不见不用管，也有可能弹出一个窗口让你登陆。 告诉大家一种用GitHub Desktop 这个东西进行简单操作； 下载地址https://desktop.github.com 然后安装好就行。 安装好后 直接登陆，添加仓库 然后选中 你原本clone 的文件夹就可以了， 如果 你提交的是自己的，请注意 那个分支要提交对了 // 注意第一次提交 要登陆 ，登陆的用户名是那个个人主页 名称下面的那几个英文。 提交Pull Request 到仓库 然后就OK了，这样就可以愉快的和别人一起做项目了]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018湖南多校第三场]]></title>
    <url>%2F2018%2F04%2F16%2F2018%E6%B9%96%E5%8D%97%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%89%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[2018 中南多校 第三场 A(2063): Good Versus Evil SubmitPage Summary TimeLimit: 5 Sec MemoryLimit: 512 Mb Submitted: 85 Solved: 15 Description Middle Earth is about to go to war. The forces of goodwill have many battles with the forces of evil. Different races will certainlybe involved. Each race has a certain ‘worth’ when battling against others. Onthe side of good we have the following races, with their associated worth: Hobbits - 1 Men - 2 Elves - 3 Dwarves - 3 Eagles - 4 Wizards - 10 On the side of evil we have: Orcs - 1 Men - 2 Wargs - 2 Goblins - 2 Uruk Hai - 3 Trolls - 5 Wizards - 11 Although weather, location, supplies and valor play apart in any battle, if you add up the worth of the side of good and compare itwith the worth of the side of evil, the side with the larger worth will tend towin. Thus, given the count of each of the races on the side of good, followedby the count of each of the races on the side of evil, determine which sidewins. Input The first line of input will contain an integer greaterthan 0 signifying the number of battles to process. Information for each battlewill consist of two lines of data as follows. First, there will be a linecontaining the count of each race on the side of good. Each entry will beseparated by a single space. The values will be ordered as follows: Hobbits,Men, Elves, Dwarves, Eagles, Wizards. The next line will contain the count ofeach race on the side of evil in the following order: Orcs, Men, Wargs, Goblins,Uruk Hai, Trolls, Wizards. All values are non-negative integers. The resultingsum of the worth for each side will not exceed the limit of a 32-bit integer. Output For each battle, print “Battle” followed by a singlespace, followed by the battle number starting at 1, followed by a “:”, followedby a single space. Then print “Good triumphs over Evil” if good wins. Print“Evil eradicates all trace of Good” if evil wins. If there is a tie, then print“No victor on this battle field”. Sample Input 3 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 10 0 1 1 1 1 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 Sample Output Battle 1: Evileradicates all trace of Good Battle 2: Goodtriumphs over Evil Battle 3: Novictor on this battle field 这种简单题只要看懂题就能写出来，除了题面上是7个数的那个 权值 11 实际上是 10。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; int a[]= &#123;1,2,3,3,4,10&#125;,b[]= &#123;1,2,2,2,3,5,10&#125;; long long n,x; long sum1,sum2; cin&gt;&gt;n; for(int j=1; j&lt;=n; j++) &#123; sum1=sum2=0; for(int i=0; i&lt;6; i++) &#123; cin&gt;&gt;x; sum1+=x*a[i]; &#125; for(int i=0; i&lt;7; i++) &#123; cin&gt;&gt;x; sum2+=x*b[i]; &#125; printf(&quot;Battle %d: &quot;,j); if(sum1&gt;sum2) &#123; cout&lt;&lt;&quot;Good triumphs over Evil\n&quot;; &#125; else if(sum1&lt;sum2) &#123; cout&lt;&lt;&quot;Evil eradicates all trace of Good\n&quot;; &#125; else &#123; cout&lt;&lt;&quot;No victor on this battle field\n&quot;; &#125; &#125; return 0;&#125; B(2064): Magic Multiple SubmitPage Summary TimeLimit: 5 Sec MemoryLimit: 512 Mb Submitted: 28 Solved: 18 Description The Elvish races of Middle Earth believed that certainnumbers were more significant than others. When using a particular quantity nof metal to forge a particular sword, they believed that sword would be mostpowerful if the thickness k were chosen according to the following rule: Givena nonnegative integer n, what is the smallest k such that the decimalrepresentations of the integers in the sequence: n, 2n, 3n, 4n, 5n, …, kncontain all ten digits (0 through 9) at least once? Lord Elrond of Rivendell hascommissioned you with the task to develop an algorithm to find the optimalthickness (k) for any given quantity of metal (n). Input Input will consist of a single integer n per line. Theend of input will be signaled by end of file. The input integer will be between1 and 200,000,000, inclusive. Output The output will consist of a single integer per line,indicating the value of k needed such that every digit from 0 through 9 is seenat least once. Sample Input 1 10 123456789 3141592 Sample Output 10 9 3 5 一个数的1 到 K倍中 0-9全部出现过，暴力K倍就行了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int a[10];int l;void check(long long x)&#123; while(x&gt;0) &#123; if(a[x%10]==0) &#123; l++; a[x%10]=1; &#125; x/=10; &#125;&#125; int main()&#123; long long n; long sum1,sum2; while (cin&gt;&gt;n) &#123; l=0; memset(a,0,sizeof(a)); int i=1; for (; l!=10; i++) &#123; check(i*n); &#125; cout&lt;&lt;i-1&lt;&lt;endl; &#125; return 0;&#125; DescriptionSaruman’s army of orcs andother dark minions continuously mine and harvest lumber out of the landsurrounding his mighty tower for N continuous days. On day number i, Sarumaneither chooses to spend resources on mining coal and harvesting more lumber, oron raising the level (i.e., height) of his tower. He levels up his tower by oneunit only on days where the binary representation of i contains a total numberof 1’s that is an exact multiple of 3. Assume that the initial level of histower on day 0 is zero. For example, Saruman will level up his tower on day 7(binary 111), next on day 11 (binary 1011) and then day 13, day 14, day 19, andso on. Saruman would like to forecast the level of his tower after N days. Canyou write a program to help? InputThe input file will containmultiple input test cases, each on a single line. Each test case consists of apositive integer N &lt; 1016, as described above. The input ends on end offile. OutputFor each test case, outputone line: “Day N: Level = L”, where N is the input N, and L is the number oflevels after N days. Sample Input12 119 164 Sample Output1Day 2: Level = 0 1Day 19: Level = 5 1Day 64: Level = 21 这一题就是从2进制 第一个找，一个个往下找，找其中 1 的个数是3的倍数就行了。 还有一种本身就是 3的倍数要额外加一前面只是处理所有比N小的数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int l;long long gcd(long long a,long long b)&#123; return (b==0)?a:gcd(b,a%b);&#125;long long C(long long n,long long m)&#123; long long x=1,y=1; if(n-m&lt;m)m=n-m; for(int i=0; i&lt;m; i++) &#123; x*=(n-i); y*=1+i; int t=gcd(x,y); x/=t; y/=t; &#125; return x/y;&#125; int main()&#123; int a[1000]; long long n,k,sum; while (cin&gt;&gt;n) &#123; sum=0; k=n; long long l=1,t=0; while(n&gt;0) &#123; a[l++]=(n&amp;1); n&gt;&gt;=1; &#125; for(int i=l-1; i&gt;0; i--) &#123; if(a[i]) //如果当前位为1 &#123; for(int j=3; j-t&lt;=i-1;j+=3) //当前位数减1,还能找出是3的倍数个 1 if(j-t&gt;=0)sum+=C(i-1,j-t); t++; &#125; &#125; if(t&gt;0&amp;&amp;t%3==0)sum+=1; //处理本身就是3的倍数情况。 printf(&quot;Day %lld: Level = %lld\n&quot;,k,sum); &#125; return 0;&#125; H(2070): Seating Chart SubmitPage Summary TimeLimit: 10 Sec MemoryLimit: 512 Mb Submitted: 41 Solved: 15 Description Bilbo’s birthday is coming up, and Frodo and Sam are incharge of all the party planning! They have invited all the hobbits of MiddleEarth to the party, and everyone will be sitting in a single row at anextremely long dining table. However, due to poor communication, Frodo and Samhave each independently put together a seating chart for all the hobbits at thedining table. Help Frodo and Sam find out how similar their seating charts areby counting the total number of distinct pairs of hobbits who appear indifferent orders in the two charts. Input The input filewill contain multiple test cases. Each test case begins with a single linecontaining an integer N(1≤N≤100,000)N(1≤N≤100,000)indicating thenumber of hobbits. The next two lines represent Frodo’s and Sam’s seatingcharts, respectively. Each seating chart is specified as a single line of Nunique alphabetical strings; the set of strings in each line are guaranteed tobe identical. The end-of-input is denoted by a line containing the number 0. Output For each input test case, output a single integerdenoting, out of the N choose 2 distinct pairs of hobbits, how many pairsappear in different orders in Frodo’s and Sam’s seating arrangements. Sample Input 3 Frodo Sam Bilbo Sam Frodo Bilbo 5 A B C D E B A D E C 0 Sample Output 1 3 这一题就是一道求逆序数，逆序数怎么求就自己找模板吧，另外这个题超了int 要用longlong。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;map&gt;using namespace std;const int maxn=1e6+5;int a[maxn];map&lt;string,int&gt;m;long long n=0;//全局变量，用于统计逆序对数void merge(int a[],int first,int mid,intlast)&#123; int *temp = new int[last-first+1];//临时数组，用于临时存放比较后的数字 int i=first,j=mid+1,k=0; while(i&lt;=mid&amp;&amp;j&lt;=last)//遍历比较左右两个部分 &#123; if(a[i]&lt;=a[j]) temp[k++] = a[i++]; //左半部分元素小于右半部分的元素，将左边该元素存入临时数组 else &#123; temp[k++] = a[j++]; n=n+(mid-i+1);//统计左半边能和右半边该元素构成的逆序对数 &#125; &#125; while(i&lt;=mid) temp[k++]=a[i++]; while(j&lt;=last) temp[k++]=a[j++]; for(i=0; i &lt; k; i++) a[first + i] = temp[i];//从临时数组取出放回原数组&#125;void mergesort(int a[],int first,int last)&#123; if(first &lt; last) &#123; int mid = (first+last)/2; mergesort(a,first,mid);//递归排序左半部分 mergesort(a,mid+1,last);//递归排序右半部分 merge(a,first,mid,last);//将处理后的两个部分合并 &#125;&#125;int main()&#123; int N; string k; while (cin&gt;&gt;N&amp;&amp;N) &#123; m.clear(); for(int i=0;i&lt;N;i++) &#123; cin&gt;&gt;k; m[k]=i; &#125; for(int i=0;i&lt;N;i++) &#123; cin&gt;&gt;k; a[i]=m[k]; &#125; mergesort(a,0,N-1); cout&lt;&lt;n&lt;&lt;endl; n=0; &#125; return 0;&#125; J(2072): Temple Build SubmitPage Summary TimeLimit: 10 Sec MemoryLimit: 512 Mb Submitted: 8 Solved: 1 Description The Dwarves of Middle Earth are renowned for theirdelving and smithy ability, but they are also master builders. During the timeof the dragons, the dwarves found that above ground the buildings that weremost resistant to attack were truncated square pyramids (a square pyramid thatdoes not go all the way up to a point, but instead has a flat square on top).The dwarves knew what the ideal building shape should be based on the heightthey wanted and the size of the square base at the top and bottom. Theytypically had three different sizes of cubic bricks with which to work. Theirgoal was to maximize the volume of such a building based on the followingrules: The building is constructed of layers; each layer is asingle square of bricks of a single size. No part of any brick may extend outfrom the ideal shape, either to the sides or at the top. The resultingstructure will have jagged sides and may be shorter than the ideal shape, butit must fit completely within the ideal design. The picture at the right is avertical cross section of one such tower. There is no limit on how many bricksof each type can be used. Input Each line of input will contain six entries, eachseparated by a single space. The entries represent the ideal temple height, thesize of the square base at the bottom, the size of the square base at the top(all three as non-negative integers less than or equal to one million), thenthree sizes of cubic bricks (all three as non-negative integers less than orequal to ten thousand). Input is terminated upon reaching end of file. Output For each line of input, output the maximum possiblevolume based on the given rules, one output per line. Sample Input 500000 800000300000 6931 11315 5000 Sample Output 160293750000000000 这一题就是一个，dp，dp[0]=0.dp[i]=max(dp[i-a[j]]+V[a[j]])(0&lt;=j&lt;3); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt; using namespace std;const int maxn=1e7+5;long long dp[maxn];int main()&#123; long long h,d,t,a[3],ans; while(cin&gt;&gt;h&gt;&gt;d&gt;&gt;t&gt;&gt;a[0]&gt;&gt;a[1]&gt;&gt;a[2]) &#123; ans=0; memset(dp,-1,sizeof(dp)); dp[0]=0; for(int i=0;i&lt;=h;i++) &#123; if(dp[i]!=-1) &#123; for(int j=0;j&lt;3;j++) &#123; if(i+a[j]&lt;=h) &#123; doubleb=1.0*d-1.0*(i+a[j])/h*(d-t); int cnt=floor(b/a[j]); long longv=cnt*cnt*pow(a[j],3); if(dp[i+a[j]]==-1)dp[i+a[j]]=dp[i]+v; elsedp[i+a[j]]=max(dp[i+a[j]],dp[i]+v); // 我是从一个状态跳所有它可以跳到的状态。 ans=max(ans,dp[i+a[j]]); &#125; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; L(2074): Tongues SubmitPage Summary TimeLimit: 5 Sec MemoryLimit: 512 Mb Submitted: 44 Solved: 18 Description Gandalf’s writings have long been available for study,but no one has yet figured out what language they are written in. Recently, dueto programming work by a hacker known only by the code name ROT13, it has beendiscovered that Gandalf used nothing but a simple letter substitution scheme,and further, that it is its own inverse—the same operation scrambles themessage as unscrambles it. This operation is performed by replacing vowels inthe sequence (a i y e o u) with the vowel three advanced, cyclicly, whilepreserving case (i.e., lower or upper). Similarly, consonants are replaced fromthe sequence (b k x z n h d c w g p v j q t s r l m f) by advancing tenletters. So for instance the phrase One ring to rule them all. translates toIta dotf ni dyca nsaw ecc. The fascinating thing about this transformation isthat the resulting language yields pronounceable words. For this problem, youwill write code to translate Gandalf’s manuscripts into plain text. Input The input file will contain multiple test cases. Eachtest case consists of a single line containing up to 100 characters,representing some text written by Gandalf. All characters will be plain ASCII,in the range space (32) to tilde (126), plus a newline terminating each line.The end of the input is denoted by the end-of-file. Output For each input test case, print its translation intoplaintext. The output should contain exactly the same number of lines andcharacters as the input. Sample Input Ita dotf ni dycansaw ecc. Sample Output One ring to rulethem all. 字符串替换，XJB暴力就行,就是耗神。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt; using namespace std;const int maxn=1e2+5;char s[maxn];int main()&#123;//b k x z n h d c w g //p v j q t s r l m f char c1[]=&#123;&quot;bkxznhdcwg&quot;&#125;; char c2[]=&#123;&quot;pvjqtsrlmf&quot;&#125;; char a[500]=&#123;0&#125;; for(int i=0;i&lt;strlen(c1);i++) &#123; a[c1[i]]=c2[i]; a[c1[i]-(&apos;a&apos;-&apos;A&apos;)]=c2[i]-(&apos;a&apos;-&apos;A&apos;); &#125; for(int i=0;i&lt;strlen(c1);i++) &#123; a[c2[i]]=c1[i]; a[c2[i]-(&apos;a&apos;-&apos;A&apos;)]=c1[i]-(&apos;a&apos;-&apos;A&apos;); &#125; strcpy(c1,&quot;aiy&quot;); strcpy(c2,&quot;eou&quot;); for(int i=0;i&lt;strlen(c1);i++) &#123; a[c1[i]]=c2[i]; a[c1[i]-(&apos;a&apos;-&apos;A&apos;)]=c2[i]-(&apos;a&apos;-&apos;A&apos;); &#125; for(int i=0;i&lt;strlen(c1);i++) &#123; a[c2[i]]=c1[i]; a[c2[i]-(&apos;a&apos;-&apos;A&apos;)]=c1[i]-(&apos;a&apos;-&apos;A&apos;); &#125; while(~scanf(&quot;%c&quot;,&amp;s[0])) &#123; int i=0; while(s[i++]!=&apos;\n&apos;) &#123; scanf(&quot;%c&quot;,&amp;s[i]); &#125; i=0; do &#123; if(a[s[i]]==0) &#123; printf(&quot;%c&quot;,s[i]); &#125; else printf(&quot;%c&quot;,a[s[i]]); &#125;while(s[i++]!=&apos;\n&apos;); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心]]></title>
    <url>%2F2018%2F03%2F17%2F%E8%B4%AA%E5%BF%83%2F</url>
    <content type="text"><![CDATA[Problem B: 洗衣 Time Limit: 2 Sec Memory Limit: 128 MBSubmit: 148 Solved: 26 [Submit][Status][Web Board] Description durong有N件衣服要洗， 但是他的第i件衣服必须在[st, en) 时间洗， 同一洗衣机不能同时洗多件衣服，他想，要洗完N件衣服，至少需要多少个洗衣机呢？ Input 多组输入 第一行一个整数n（n &lt;= 100000）, 代表衣服的个数 接下来n行, 每行两个整数st, en（1 &lt;= st &lt; en &lt;= 1000000000），代表第i件衣服在st开始洗，en洗完 Output 输出一个整数和换行符，代表至少需要的洗衣机个数 Sample Input1234 31 23 42 8 Sample Output12 贪心，先排序，然后到一个时间点能加就加，如果过了一个减去一个就行了，每次跳跃一件衣服的时间长度就行了，复杂度只有排序的复杂度NlogN #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;queue&gt; using namespace std; const int maxn=1e5+10; int n; int main() { ` int`st[maxn],en[maxn],sz,ez,ans,cou; ` while`( scanf ( &quot;%d&quot; ,&amp;n)!=EOF) ` {` ` for`( int i=0;i&lt;n;i++){ ` scanf`( &quot;%d%d&quot; ,&amp;st[i],&amp;en[i]); ` }` ` sort(st,st+n);` ` sort(en,en+n);` ` ans=cou=ez=0;` ` for`( int i=0;i&lt;n;i++) ` {` ` cou++;` ` while`(en[ez]&lt;=st[i]) ` {` ` ez++;` ` cou—;` ` }` ` if`(cou&gt;ans)ans=cou; ` }` ` printf`( &quot;%d\n&quot; ,ans); ` }` ` return`0; }]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大生成树]]></title>
    <url>%2F2018%2F03%2F17%2F%E6%9C%80%E5%A4%A7%E7%94%9F%E6%88%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Problem A: 灾区重建Time Limit: 3 Sec Memory Limit: 128 MBSubmit: 123 Solved: 32[Submit][Status][Web Board] Description在一场地震之后，原本美丽的C国变成了一片废墟，但是这并没有击垮人们的意志，在各方的支持下救援队马上开始了灾区重建。已知C国一共由N个城市（编号从1~N）组成，在这N个城市之间有M条道路连通着各个城市，现在要将物资运往各个城市，但是每条道路都有其最大承重量W，也就是说如果一辆车所运载的货物重量大于W的话是无法通过这条路的。为了防止道路崩塌同时提高效率，我们都会去走承重量尽可能大的道路，现在救援队的队长想知道如果要将货物从任意一个城市运往其他N-1个城市，一次所能运输的最大重量是多少，你能告诉他吗？ Input输入第一行为一个整数T(T&lt;=10），表示有T组样例； 第二行为两个整数N(N&lt;=10^5)和M(M&lt;=10^6)，分别表示城市的数量和道路的数量； 接下来M行每行有三个整数,u,v,w，（u,v&lt;=N，w&lt;=10^9） 表示u和v之间有一条承重量为w的道路（道路是双向的，即可以从u走到v，也可以从v走到u，同时数据保证任意两个城市之间至多只会有一条道路）。 Output每组样例输出一行 Case #X: Y，X表示第几组样例，Y便是所要求的答案。 Sample Input11 4 6 1 2 2 1 3 1 1 4 9 2 4 8 2 3 10 3 4 4 Sample Output1Case #1: 8 HINT样例解释： 如果要将物资从1运输到2，那么走1-4-2这条路径所即能运输的最大重量为8； 如果要将物资从1运输到3，那么走1-4-2-3这条路径即所能运输的最大重量为8； 如果要将物资从1运输到4，那么走1-4这条路径即所能运输的最大重量为9； 如果要将物资从2运输到3，那么走2-3这条路径即所能运输的最大重量为10； 如果要将物资从2运输到4，那么走2-4这条路径即所能运输的最大重量为8； 如果要将物资从3运输到4，那么走3-2-4这条路径即所能运输的最大重量为8； 故答案为8。 很裸的一道最大生成树，求最大生成树的最大权边，注意跳出就不会超时。 #include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;int t,n,m,i,j;using namespace std; struct s{` int`a,b,c;}k[1000005]; const int maxn=1000005; bool bmp(s a, s b){` return`a.c&gt;b.c;} int par[maxn];void init(){` for`( int i=0;i&lt;=n;i++){` par[i]=i;` }}int find( int x){` if`(par[x]==x) return x;` else`{` return`par[x]=find(par[x]);` }`}void unite( int x, int y){` x=find(x);` y=find(y);` if`(x==y) return ;` else`{` par[y]=x;` }} int main(){` scanf`( &quot;%d&quot; ,&amp;t);` for`(i=0;i&lt;t;i++)` {` scanf ( &quot;%d%d&quot; ,&amp;n,&amp;m);` init();` for (j=0;j&lt;m;j++)` scanf`( &quot;%d%d%d&quot; ,&amp;k[j].a,&amp;k[j].b,&amp;k[j].c);` sort(k,k+m,bmp);` int res=0,l=0;` for`(j=0;j&lt;m;j++)` {` if (find(k[j].a)!=find(k[j].b))` {` unite(k[j].a,k[j].b);` res=k[j].c;` if (++l==n-1) break ;` }` if (l==n-1) break ;` }` printf ( &quot;Case #%d: %d\n&quot; ,i+1,res);` }` return 0;}]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
</search>

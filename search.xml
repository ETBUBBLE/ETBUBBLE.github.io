<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ÁÆÄÂçïËÆ∞ÂΩï‰∏Ä‰∏ãÊò•ÊãõÊóÖÁ®ã-ËÖæËÆØ&Â≠óËäÇ]]></title>
    <url>%2F2020%2F04%2F07%2F%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E6%98%A5%E6%8B%9B%E6%97%85%E7%A8%8B-%E8%85%BE%E8%AE%AF%26%E5%AD%97%E8%8A%82%2F</url>
    <content type="text"><![CDATA[Âéª‰∫ÜÂ≠óËäÇÔºåËÖæËÆØoffer ÁªôÁöÑÂ§™ÊÖ¢‰∫ÜÔºåÁ≠â‰∫Ü‰∏§‰∏™ÊòüÊúü„ÄÇÊú¨Êù•‰ª•‰∏∫Ê≤°Êó∂Èó¥Èù¢Â≠óËäÇ‰∫ÜÔºåÁªìÊûúÂ≠óËäÇ‰∏§Â§©ÂÖ®ÈÉ®ÊêûÂÆö‰∫Ü„ÄÇ„ÄÇ„ÄÇÔºåÁªô‰∫ÜÂè£Â§¥offer„ÄÇÊäïËÖæËÆØÊúâÁÇπÊØíÁò§ÔºåÁÇπ‰∫Ü‰∏Ä‰∏ãÂÜÖÊé®ÈìæÊé•ÔºåÁõ¥Êé•ÊääÊàëÁÆÄÂéÜÊäïÈÄí‰∫Ü„ÄÇÁÑ∂ÂêéÈ°∫‰æøÂ∞±Ëøá‰∫Ü„ÄÇ ËÖæËÆØ‰∏§Èù¢‰∏ÄÈù¢linux ËøõÁ®ã ÂíåÂÜÖÂ≠òÂÖ±‰∫´ÂÜÖÂ≠ò‰∫ÜËß£ÂêóÊúâÂì™‰∫õÈîÅÊú∫Âà∂ÁºñËØëÂô® ÈÄâÈ°πÁî®ËøáÂì™‰∫õLinuxÂëΩ‰ª§ (ËØ¥‰∫Ü‰∏Ä‰∫õÂ∏∏Áî®ÁöÑ)shell ËÑöÊú¨‰∫ÜËß£Âêó (Ëøô‰∏™Ê≤°Áî®ËøáÂ∞±Ê≤°ÈóÆ‰∫Ü)C++Êúâ‰ªÄ‰πàÁâπÁÇπÊµÆÁÇπÊï∞ÊòØÊÄé‰πàÂÇ®Â≠òÁöÑËÆ≤‰∏Ä‰∏ãÁ±ªÁöÑÂ∏ÉÂ±Ä deine ÂíåÂáΩÊï∞Ê®°ÊùøÁöÑÂå∫Âà´new Âíåmallocstatic_castÂíådynamic_castslecetÂíåepoll ÁöÑÂå∫Âà´TCPÂíåUDPÁöÑÂå∫Âà´‰ªñ‰ª¨ÁöÑÈ¶ñÈÉ®ÊòØ‰ªÄ‰πàÊ†∑ÁöÑÊ∏∏ÊàèÈÄÇÂêàÁî®Âì™‰∏™Êúâ‰∫∫ËØ¥Áî®È´òÂ±ÇÂçèËÆÆÂÆûÁé∞ÁöÑÂèØÈù†UDP‰∏∫‰ªÄ‰πà‰∏çÁõ¥Êé•Áî®TCPÂë¢ÂÜô‰∏™ÂèëÁâåÁÆóÊ≥ïÔºåÈ´òÂ∫¶Ëá™Áî±ÔºåÈöè‰æø‰Ω†ÂÜôÔºå‰∏ªË¶ÅÁúãÁºñÁ†ÅÈ£éÊ†º‰Ω†ÂØπ‰Ω†Ëá™Â∑±ËøòÊúâ‰ªÄ‰πàË¶ÅË°•ÂÖÖÁöÑ„ÄÇ‰Ω†ËøòÊúâ‰ªÄ‰πàÊÉ≥ÈóÆÁöÑÂêó?(Èù¢ËØïÂÆòÁ™ÅÁÑ∂ÈóÆ‰∫Ü‰∏Ä‰∏ã)Ë¥üËΩΩÂùáË°°ÁÆóÊ≥ï ‰∫åÈù¢È°πÁõÆÁõ∏ÂÖ≥sendËøîÂõûÂÄºrecvÂë¢Á≤òÂåÖCÁ±ªÊûÑÈÄ†ÂáΩÊï∞ÁöÑÂÖ®ËøáÁ®ãÁ±ªÈáåÈù¢ÁöÑÊôÆÈÄöÊàêÂëòÂ¶ÇÊûúÊ≤°ÊúâÂàùÂßãÂåñ‰ºöÊÄé‰πàÊ†∑„ÄÇÊûÑÈÄ†ÂáΩÊï∞Ë∞ÉÁî®ËôöÂáΩÊï∞‰ºöÊÄé‰πàÊ†∑Ë∞ÉÁî®Á∫ØËôöÂáΩÊï∞Âë¢‰∏Ä‰∏™Âü∫Á±ªÊåáÈíàÊÄé‰πàÂà§Êñ≠‰ªñÊåáÂêë‰∫ÜÊ¥æÁîüÁ±ªËøòÊòØÂü∫Á±ª„ÄÇËôöÁªßÊâøÂë¢Âçï‰æãÊ®°ÂºèÊÄé‰πàËÆæËÆ°„ÄÇÂÆèÂÆö‰πâÂíåÂÜÖËÅîÂáΩÊï∞ÁöÑÂå∫Âà´Ê®°ÊùøÂáΩÊï∞Âë¢ÂÆèÂèÇÊï∞ÁöÑÂâØ‰ΩúÁî®ÂÜÖËÅîÂáΩÊï∞ÁºñËØëÂô®ÔºåÊ≤°ÊúâÂÜÖËÅîÊòØÂõ†‰∏∫‰ªÄ‰πà„ÄÇlinux ÊÄé‰πàÂàõÂª∫ËøõÁ®ã ÈÉΩÊØîËæÉÂü∫Á°ÄÔºåÂü∫Êú¨‰∏äÈÉΩÁ≠î‰∏äÊù•‰∫Ü„ÄÇÈù¢ËØïÊÑüËßâËøòÊòØÊå∫Â•ΩÁöÑÔºåÈù¢ËØïÂÆò‰πüÊå∫ÂíåËîºÁöÑ„ÄÇ Â≠óËäÇË∑≥Âä®Â≠óËäÇË∑≥Âä®Â∞±ÊØîËæÉÂ§∏Âº†Ôºå‰∏ÄÂ§©Èù¢ÂÆåÊâÄÊúâÊäÄÊúØÈù¢ÔºåÁ¨¨‰∫åÂ§©HRÁªô‰∫ÜÂè£Â§¥OFFERüòìÔºåËøôÈÄüÂ∫¶ÁúüÁöÑÂø´„ÄÇ Èù¢ËØïÂÜÖÂÆπ‰∏çÂ§ö„ÄÇ ‰∏ÄÈù¢‰∏ÄÈù¢ÊØîËæÉÁÆÄÂçïÔºå‰∏§‰∏™ÁÆóÊ≥ïÈ¢òÔºåÁõ¥Êé•Áßí‰∫Ü„ÄÇ ËæìÂá∫‰∏Ä‰∏™Êï∞ ÔºåËøô‰∏™Êï∞Â∑¶ËæπÊâÄÊúâÊï∞ÊØî‰ªñÂ∞èÁöÑÔºåÂè≥ËæπÊâÄÊúâÊï∞ÊØî‰ªñÂ§ß„ÄÇÊúâÂ§ö‰∏™Èöè‰æøËæìÂá∫‰∏Ä‰∏™1 3 2 7 8‰∏äÈù¢ 1 7 8 ÈÉΩÂèØ‰ª• ‰∏Ä‰∏™ÂõæÔºå‰Ω†ÂèØ‰ª•ÂæÄÂè≥ËæπËµ∞Ôºå‰∏ãÈù¢Ëµ∞ÔºåÈóÆ‰ªéÂ∑¶‰∏äËßíËµ∞Âà∞Âè≥‰∏ãËßíÔºåÊúÄÂ§öÂèØ‰ª•ËΩ¨K‰∏™ÂºØÔºåxÊòØ‰∏çËÉΩËµ∞ÁöÑ„ÄÇs 0 x 00 0 0 00 0 0 t ‰∫åÈù¢ ÂÜô‰∏™Á∫øÁ®ãÂÆâÂÖ®ÁöÑhashmapÔºåÂèØ‰ª•Êõø‰ª£unordered_map Áü≠ÁΩëÂùÄ Á≥ªÁªüÔºå‰Ω†ÊÄé‰πàËÆæËÆ°Ôºü ÔºàÊáµÈÄº ‰Ω†ËØ¥Âï•? ‰∏âÈù¢ËØ¥‰∏Ä‰∏ãSTL,Áî®ËøáÂì™‰∫õÔºå‰ªãÁªç‰∏ãÂéüÁêÜ„ÄÇÂÜô‰∏™Á∫øÁ®ãÂÆâÂÖ®ÁöÑÈòüÂàó„ÄÇ ÂÜô‰∫Ü‰πãÂêéÈóÆ‰∫Ü‰∏ãnotify_allÂíånotify_one ÁöÑÂå∫Âà´ÔºåÁî®Âì™‰∏™Â•Ω„ÄÇ„ÄÇËÆ®ËÆ∫‰∏Ä‰∏ã Ê∂àË¥πËÄÖË∂äÂ§öË∂äÂ•ΩÔºåËøòÊòØ‰ªÄ‰πà„ÄÇËøòÊúâ‰∏Ä‰∫õÂæàÁ•ûÂ•áÁöÑ‰∏úË•øÔºåÊàëÂíåÈù¢ËØïÂÆòÊÄùËÄÉÁöÑÁÇπ‰∏ÄÁõ¥ÂØπ‰∏ç‰∏äÔºåÊàë‰∏ÄÂ∫¶ÊÄÄÁñëÊàëÊòØ‰∏çÊòØÊ≤°Â≠¶ËøáÂ§öÁ∫øÁ®ã„ÄÇÔºàÊúÄÂêé‰ªñËØ¥ÂÆûÈôÖ‰∏ä‰Ω†ÂéüÊú¨ËØ¥ÁöÑÊ≤°ÈîôÔºåÂè™‰∏çËøáÂú®ËøôÁßçÊÉÖÂÜµ‰∏ãÔºå‰∏çÁ¨¶Âêà„ÄÇ„ÄÇ„ÄÇ ËøòÈóÆ‰∫Ü‰∏Ä‰∏ã tcpÂíåudp ÔºåÂ∞±ÈóÆ‰∫Ü‰∏Ä‰∏ã tcp Êè°ÊâãÁöÑÂøÖË¶ÅÊÄßÔºåÈóÆ‰∫Ü‰∏Ä‰∏ãÂèëÈÄÅÊï∞ÊçÆÁöÑÁöÑÊµÅÁ®ã„ÄÇ Êó†ÈîÅÈòüÂàóÂíå‰∫íÊñ•ÈáèÁöÑÂå∫Âà´Ôºå‰∏∫Âï•Êó†ÈîÅÈòüÂàóÂùóÔºå‰∏∫Âï•‰∫íÊñ•ÈáèÂø´„ÄÇÁÑ∂ÂêéÂèàÂá∫Áé∞‰∫ÜÂõûÁ≠îÁöÑÈóÆÈ¢ò‰∏çÂà∞ÁÇπ‰∏ä„ÄÇ Âà∞Ê≠§ÁªìÊùüÔºåÂëäËæû„ÄÇÂü∫Á°Ä‰ªÄ‰πàÁöÑÔºåC++ËØ≠Ë®ÄÂü∫Á°ÄÂï•ÈÉΩÊ≤°ÈóÆ„ÄÇÂ•ΩÂú®Ëøá‰∫Ü„ÄÇÂìàÂìàÂìàÂìà„ÄÇ]]></content>
      <categories>
        <category>Èù¢Áªè</category>
      </categories>
      <tags>
        <tag>Èù¢Áªè</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÁÆÄÂçïÂÅö‰∏™ÂÆûÈ™åÂàÜÊûê‰∏Ä‰∏ã new/new[] Âíå delete/delete[]]]></title>
    <url>%2F2020%2F03%2F14%2F%E7%AE%80%E5%8D%95%E5%81%9A%E4%B8%AA%E5%AE%9E%E9%AA%8C%E5%88%86%E6%9E%90%E4%B8%80%E4%B8%8B-new-new%5B%5D-%E5%92%8C-delete-delete%5B%5D%2F</url>
    <content type="text"><![CDATA[ÂÖàÊù•‰ªãÁªç‰∏ãÊµÅÁ®ã„ÄÇ new/new[],‰ªñÁöÑÊµÅÁ®ãÊòØÂÖàÂºÄËæü‰∫Ü‰∏Ä‰∏™Á©∫Èó¥ÔºåÁÑ∂ÂêéË∞ÉÁî®‰∫ÜÊûÑÈÄ†ÂáΩÊï∞„ÄÇ delete/delete[]ÂÖàË∞ÉÁî®ÊûêÊûÑÂáΩÊï∞ÔºåÁÑ∂ÂêéÈáäÊîæÂÜÖÂ≠ò„ÄÇ ÈÇ£‰πàÂ¶ÇÊûúnew/deleteÂíånew[]/deletep[]Ê≤°ÊúâÈÖçÂØπ‰ºöÂá∫Áé∞‰ªÄ‰πàÈóÆÈ¢ò„ÄÇÂØπ‰∫éËøô‰∏™ÈóÆÈ¢òÊàëÂÅö‰∫ÜÁÆÄÂçïÁöÑÂÆûÈ™å„ÄÇ ÈùûÂü∫Á°ÄÁ±ªÂûã‰πüÂ∞±ÊòØËá™Â∑±ÂÜôÁöÑÁ±ª„ÄÇÂÖàËØ¥‰∏ãÁªìËÆ∫ deleteÈáäÊîænew[]Âè™‰ºöË∞ÉÁî®Á¨¨‰∏Ä‰∏™ÁöÑÊûêÊûÑÂáΩÊï∞ÔºåÂØºËá¥ÂÜÖÂ≠òÊ≥ÑÊºè„ÄÇ delete[]ÈáäÊîænew‰ºöÂá∫bug„ÄÇ ÊµãËØïÂ¶Ç‰∏ã123456789101112131415161718192021222324252627class A&#123; int a;public: A():a(0xffff)&#123; cout&lt;&lt;"A()\n"; &#125; ~A()&#123; cout&lt;&lt;"~A()\n"; &#125; virtual void func()&#123; cout&lt;&lt;"func\n"; &#125;&#125;;int main() &#123; A *b=new A[4]; delete [] b; b =new A(); delete b; b=new A[4]; delete b; A *a=new A(); delete[] a; return 0;&#125; ËæìÂá∫ÁªìÊûúÊòØ123456789101112131415161718A()A()A()A()~A()~A()~A()~A()//4‰∏™ÊûêÊûÑA()~A()//‰∏Ä‰∏™ÊûêÊûÑA()A()A()A()~A()//‰∏Ä‰∏™ÊûêÊûÑA()Process finished with exit code -1073741819 (0xC0000005)//Áõ¥Êé•RE‰∫Ü ÈóÆÈ¢òÂ∑≤ÁªèÁúãÂá∫Êù•ÔºåÈÇ£‰πàÊòØ‰∏∫‰ªÄÂë¢„ÄÇÊàë‰ª¨ÂéªÁúãÁúãÂÜÖÂ≠ò„ÄÇÁúãÂà∞‰∫ÜÂêóÔºåÂçÅÂàÜÊòéÊòæÁöÑ‰∏Ä‰∏™Êï∞Â≠óÔºåË°®Á§∫ÂàÜÈÖç‰∫ÜÂ§öÂ∞ë‰∏™ÔºåÂêéÈù¢ÂæàÊòéÊòæÂêß„ÄÇ‰∏Ä‰∏™ËôöÂáΩÊï∞ÊåáÈíàÔºåÂíå‰∏Ä‰∏™ÂÄº„ÄÇÁÑ∂ÂêéÊâßË°å‰∏ã‰∏ÄË°åÈáäÊîæÂÜÖÂ≠ò„ÄÇÁúãÂá∫ÂÜÖÂ≠òÁöÑÂèòÂåñ‰∫ÜÂêóÔºåÂÖ®ÈÉ®ÈÉΩÈáäÊîæÊéâ‰∫ÜÔºåÂâçÈù¢ÈÇ£‰∏™4 ‰πüÊ≤°‰∫Ü„ÄÇÊâßË°åÂà∞ËøôÔºåÁî®newÂàõÂª∫ÁöÑÊòéÊòæÊ≤°Êúâ‰∏Ä‰∏™Ë°®Á§∫Â§öÂ∞ë‰∏™ÁöÑ„ÄÇÊâßË°å‰∏ã‰∏ÄË°åÁÑ∂ÂêéÊ≤°‰∫ÜË¢´ÈáäÊîæ‰∫Ü„ÄÇ ÊâßË°åÂêéÈù¢ÈîôËØØÁöÑ„ÄÇÁúãÁúãÁî®deleleÂà†Èô§new[]„ÄÇ ÊâßË°åÂÆåÂêéÔºå‰ªñ‰ª¨ÂÖ®ÈÉ®ÈÉΩÂú®ÔºåÊàëÈÉΩÊÄÄÁñëÂÜÖÂ≠òÂà∞Â∫ïÊúâÊ≤°ÊúâÈáäÊîæ„ÄÇÂæàÊòæÁÑ∂ÂÖ®ÈÉ®ÈÉΩËøòÊ≤°ÊúâÈáäÊîæÊéâ„ÄÇ ÁÑ∂ÂêéÂêéÈù¢ÈÇ£‰∏™‰∏∫Âï•‰ºöRE‰∏çÁî®ÊàëËØ¥‰∫ÜÂêß„ÄÇÂâçÈù¢ÈÇ£‰∏™Ë°®Ëø∞‰∏™Êï∞ÁöÑÊï∞Â≠óËøô‰πàÂ§ß„ÄÇ„ÄÇ‰Ω†ÊÉ≥ÊÄé‰πàÊêû„ÄÇ„ÄÇ„ÄÇ Â∞èÈóÆÈ¢ò1‰∏çË¶ÅÊÖåÂØπ‰∫éËøô‰∏™ÂÆûÈ™åÔºåÂ¶ÇÊûúÊääËôöÂáΩÊï∞Âà†ÊéâÔºåÂ∞±‰∏ç‰ºöÊòØÂÜÖÂ≠òÈîôËØØËÄåÊòØ‰∏Ä‰∏™ÈùûÂ∏∏Â§ßÁöÑÂæ™ÁéØ„ÄÇËá≥‰∫é‰∏∫‰ªÄ‰πàËá™Â∑±ÊÄùËÄÉ„ÄÇ ÁªìËÆ∫ÔºöÁî®newÂèÇÊï∞ÁöÑÈùûÂü∫Á°ÄÁ±ªÂûãÔºåÂè™‰ºöÂºÄËæü‰∏Ä‰∏™ÂØπË±°ÂÜÖÂ≠òÁ©∫Èó¥Ôºånew[]Ëøò‰ºö‰øùÂ≠ò‰∏Ä‰∏™Êï∞ÁªÑÂ§ßÂ∞è„ÄÇdelete[]Âà†Èô§ÁöÑÊó∂ÂÄô‰ºöÊ†πÊçÆ Âà†Èô§Âú∞ÂùÄÂâçÈù¢ÁöÑ4‰∏™Â≠óËäÇË°®Á§∫ÁöÑÊï∞Â≠óÂ§ßÂ∞èÊù•Âà†Èô§ÂêéÈù¢ÁöÑÂØπË±°„ÄÇ ‰∏∫‰∫Ü‰øùËØÅÊ≠£Á°ÆÊÄßÔºåÊàëÊù•ÂÅö‰∏™ÊúâÊÑèÊÄùÁöÑ‰∫ãÔºåÊàë‰ª¨Êù•ÊâãÂÜô‰∏Ä‰∏™new[]„ÄÇ12345678910111213141516171819202122232425class A&#123; int a;public: A():a(0xffff)&#123; cout&lt;&lt;"A()\n"; &#125; ~A()&#123; cout&lt;&lt;"~A()\n"; &#125; virtual void func()&#123; cout&lt;&lt;"func\n"; &#125;&#125;;int main() &#123; void *p=::operator new(sizeof(A)*4+sizeof(int));//Ëøô‰∏™ÂèØ‰ª•Áî®mallocÊù•ÊòØ‰∏ÄÊ†∑ÁöÑÁªìÊûú„ÄÇ int *size=(int *)p; *size=4;//Ëøô‰∏™ËÆæÁΩÆ‰∏Ä‰∏ãÂ§ßÂ∞è A *a=(A *)(size+1);//Ëøô‰∏™Â∞±ÊòØnew[] ÁöÑÂÆûÁé∞ new(a)A(); new(a+1)A(); new(a+2)A(); new(a+3)A(); delete[] a;//ÊòæÁÑ∂Ëøô‰∏™ÊòØÈáäÊîæ return 0;&#125; ÁêÜËÆ∫‰∏ädelete []‰πüËÉΩÊâãÂÜôÂÆûÁé∞ÔºåÂÖ∑‰ΩìÊÄé‰πàÂÆûÁé∞ËØªËÄÖËá™Â∑±Âä®ÊâãÊìç‰ΩúÔºåÂàáÂøåÊãøÊù•‰∏ª‰πâ„ÄÇ Âü∫Êú¨Á±ªÂûãÂØπ‰∫éÂü∫Êú¨Á±ªÂûãÂíåÈùûÂü∫Êú¨Á±ªÂûãÊúâ‰ªÄ‰πàÂå∫Âà´Âë¢ÔºüÔºüÔºüÔºåemmmmÂ•ΩÂÉèÊ≤°Âï•Âå∫Âà´„ÄÇ‰ΩÜÊòØ‰ªñÁ°ÆÂÆû‰∏ç‰∏ÄÊ†∑„ÄÇ1234567891011121314int main() &#123; int *b=new int[4]&#123;0xfff,0xffff,0xfff,0xfff&#125;; delete [] b; b =new int(); delete b; b=new int[4]&#123;0xfff,0xffff,0xfff,0xfff&#125;; delete b; int *a=new int(); delete[] a; return 0;&#125; ËøêË°åËøô‰∏™‰Ω†‰ºöÂèëÁé∞ÔºåÊ≤°Êúâ‰ªª‰ΩïÈóÆÈ¢òÔºÅÔºÅÔºÅÔºÅÔºåÁ°ÆÂÆûÂ∞±ÊòØÔºåÊ≤°Êúâ‰ªª‰ΩïÈóÆÈ¢ò„ÄÇ‰∏∫‰ªÄ‰πà‰ºöËøôÊ†∑???„ÄÇÊàë‰ª¨ÁÖßÁùÄÂâçÈù¢ÈÇ£‰∏™ÁöÑÊù•„ÄÇÁúãÂà∞‰∫ÜÂêóÔºåÊ≤°ÊúâÈÇ£‰∏™Ë°®Á§∫Êï∞ÁªÑÈïøÂ∫¶ÁöÑ‰∏úË•ø‰∫Ü„ÄÇdelete‰πãÂêéÂÜÖÂ≠òÂèò‰∫Ü„ÄÇ ÂêéÈù¢ÁöÑËá™Â∑±ÁúãÔºå‰Ω†‰ºöÂèëÁé∞ÔºåÁî®deletÂà†Èô§new[]ÂÆåÂÖ®Ê≤°ÈóÆÈ¢ò„ÄÇ„ÄÇ„ÄÇdelet[]Âà†Èô§new,Â•ΩÂÉè‰πüÊ≤°Âï•ÈóÆÈ¢ò„ÄÇ ÈÇ£‰πàÈóÆÈ¢òÊù•‰∫ÜÔºå‰ªñ‰ª¨ÊòØÊÄé‰πàÁü•ÈÅìË¶ÅÈáäÊîæÂ§öÂ∞ëÂÜÖÂ≠òÁöÑ„ÄÇËøô‰∏™Â∞±ÊØîËæÉÂ§çÊùÇ‰∫Ü„ÄÇ‰ªñÂíåfreeÊòØ‰∏Ä‰∏™ÊÄßË¥®ÔºåÂÜÖÂ≠òÂàÜÈÖçÊòØ‰∫§ÁªôÊìç‰ΩúÁ≥ªÁªüÂÆåÊàêÁöÑÔºåÂÖ∑‰ΩìÊÄé‰πàÊìç‰ΩúÁöÑËøòÊòØÂíåÂÜÖÊ†∏ÊúâÂÖ≥„ÄÇÂ∫îËØ•‰πüËÉΩÂæàÊ∏ÖÊ•öÁöÑÁúãËßÅÔºåÊØèÊ¨°ÈáäÊîæÂÜÖÂ≠òÔºåÊîπÂèòÁöÑ‰∏ç‰ªÖ‰ªÖÊòØ‰Ω†ÈúÄË¶ÅÁöÑÁöÑÂÜÖÂ≠òÂ§ßÂ∞èÔºåËÄåÊòØ‰∏ÄÊï¥ÂùóÂÜÖÂ≠ò„ÄÇÊâÄ‰ª•Áî®delete/delete[]ÈáäÊîæÂÜÖÂ≠òÁöÑÊó∂ÂÄôÔºåÂÆûÈôÖ‰∏äÊòØÁõ¥Êé•ÊääÈÇ£‰∏ÄÂùóÂÜÖÂ≠òÈáäÊîæ‰∫Ü„ÄÇ ÁªìËÆ∫:ÂØπ‰∫éÂü∫Á°ÄÁ±ªÂûãÔºåÁî®delete/delete[]Âà†Èô§ÂÆûÈôÖ‰∏äÊòØ‰∏ÄÊ†∑ÁöÑ,‰∏ªË¶ÅÂéüÂõ†Â∫îËØ•ËøòÊòØÂõ†‰∏∫Ôºå‰ªñÊ≤°ÊúâË∞ÉÁî®ÊûÑÈÄ†ÂíåÊûêÊûÑÁöÑÂøÖË¶Å„ÄÇÂ¶ÇÊûú‰∏Ä‰∏™Á±ªÈáåÈù¢Â∞ÅË£Ö‰∫Ü‰∏Ä‰∏™ÊåáÈíàÔºåÁÑ∂Âêénew‰∫Ü‰∏Ä‰∏™ÂØπË±°ÔºåÂ¶ÇÊûú‰∏çË∞ÉÁî®ÊûêÊûÑÂáΩÊï∞ÔºåÂ∞±‰ºöÂá∫Áé∞ÂÜÖÂ≠òÊ≥ÑÊºè„ÄÇ]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÁÆÄÂçïÁ†îÁ©∂C++ ÂØπË±°ÂÜÖÂ≠òÂ∏ÉÂ±Ä]]></title>
    <url>%2F2020%2F02%2F18%2F%E7%AE%80%E5%8D%95%E7%A0%94%E7%A9%B6C%2B%2B%20%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[ÂÖ≥‰∫éC++ÂØπË±°Â∏ÉÂ±Ä Áúã‰∫ÜÂ§ß‰Ω¨ÁöÑÂçöÂÆ¢,Â§ß‰Ω¨ÁöÑÂçöÂÆ¢Ëøá‰∫é‰πÖËøúÊ†ºÂºèÊØîËæÉÊ∏ÖÂ•áÔºåÊàëÊï¥ÁêÜ‰∫ÜÔºåÈ°∫‰æøÊîπ‰∫ÜÁ®ãÂ∫èËÉΩÂ§üÂú® 64‰ΩçÊú∫ËøêË°å„ÄÇ Âçï‰∏ÄÁöÑ‰∏ÄËà¨ÁªßÊâøÈÄö‰øóÁöÑËÆ≤Ôºå‰∏ÄÂ±ÇÂ±Ç‰∏ãÂéª„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;using namespace std;class Parent&#123;public: long iparent;//Âõ†‰∏∫ÊòØ64‰ΩçÊú∫ÔºåÊâÄ‰ª•ÊîπÊàê‰∫Ü long Parent() : iparent(10) &#123;&#125; virtual void f() &#123; cout &lt;&lt; " Parent::f()" &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; " Parent::g()" &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; " Parent::h()" &lt;&lt; endl; &#125;&#125;;class Child : public Parent&#123;public: long ichild; Child() : ichild(100) &#123;&#125; virtual void f() &#123; cout &lt;&lt; "Child::f()" &lt;&lt; endl; &#125; virtual void g_child() &#123; cout &lt;&lt; "Child::g_child()" &lt;&lt; endl; &#125; virtual void h_child() &#123; cout &lt;&lt; "Child::h_child()" &lt;&lt; endl; &#125;&#125;;class GrandChild : public Child&#123;public: long igrandchild; GrandChild() : igrandchild(1000) &#123;&#125; virtual void f() &#123; cout &lt;&lt; "GrandChild::f()" &lt;&lt; endl; &#125; virtual void g_child() &#123; cout &lt;&lt; "GrandChild::g_child()" &lt;&lt; endl; &#125; virtual void h_grandchild() &#123; cout &lt;&lt; "GrandChild::h_grandchild()" &lt;&lt; endl; &#125;&#125;;typedef void (*Fun)(void);int main()&#123; GrandChild gc; long **pVtab = (long **)&amp;gc; Fun pFun; cout &lt;&lt; "[0] GrandChild::_vptr-&gt;" &lt;&lt; endl; for (int i = 0; (Fun)pVtab[0][i] != NULL; i += 2) &#123; pFun = (Fun)pVtab[0][i]; cout &lt;&lt; " [" &lt;&lt; i &lt;&lt; "] "; pFun(); &#125; printf("start offet:%llx\n", pVtab); cout &lt;&lt; "[1] Parent.iparent = " &lt;&lt; (long)((pVtab[1])) &lt;&lt; endl; cout &lt;&lt; "[2] Child.ichild = " &lt;&lt; (long)(pVtab[2]) &lt;&lt; endl; cout &lt;&lt; "[3] GrandChild.igrandchild = " &lt;&lt; (long)(pVtab[3]) &lt;&lt; endl;&#125; ËæìÂá∫ÁªìÊûú12345678[0] GrandChild::_vptr-&gt; [0] GrandChild::f() [2] Parent::h() [4] Child::h_child()start offet:7ffee4956f80[1] Parent.iparent = 10[2] Child.ichild = 100[3] GrandChild.igrandchild = 1000 È°∫‰æøÊàë‰ª¨Áî®gdb Áúã‰∏Ä‰∏ã„ÄÇ12345678910111213141516171819202122GNU gdb (Debian 7.12-6) 7.12.0.20161007-gitlist40 &#123;41 pFun = (Fun)pVtab[0][i];42 cout &lt;&lt; " [" &lt;&lt; i &lt;&lt; "] ";43 pFun();44 &#125;45 printf("start offet:%llx\n", pVtab);46 cout &lt;&lt; "[1] Parent.iparent = " &lt;&lt; (long)((pVtab[1])) &lt;&lt; endl;47 cout &lt;&lt; "[2] Child.ichild = " &lt;&lt; (long)(pVtab[2]) &lt;&lt; endl;48 cout &lt;&lt; "[3] GrandChild.igrandchild = " &lt;&lt; (long)(pVtab[3]) &lt;&lt; endl;49 &#125;p pVtab$1 = (long **) 0x7fffffffcb90x /10xg 0x7fffffffcb900x7fffffffcb90: 0x0000555555755ce0(‰Ω†ÂèØ‰ª•ÁªßÁª≠Êâæ‰∏ãÂéªÂèØ‰ª•ÊâæÂà∞ÂÖ∑‰ΩìÂáΩÊï∞Âú∞ÂùÄ) 0x000000000000000a(10)0x7fffffffcba0: 0x0000000000000064(100) 0x00000000000003e8(1000)0x7fffffffcbb0: 0x000000000000008e 0x000055555555509a0x7fffffffcbc0: 0x00007fffffffcb90 0x0000000655554bf00x7fffffffcbd0: 0x00007fffffffccc0 0x0000000000000000 Â§öÈáçÁªßÊâø12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;iostream&gt;using namespace std;class Base1&#123;public: long ibase1; Base1() : ibase1(0x10) &#123;&#125; virtual void f() &#123; cout &lt;&lt; "Base1::f()" &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; "Base1::g()" &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; "Base1::h()" &lt;&lt; endl; &#125;&#125;;class Base2&#123;public: long ibase2; Base2() : ibase2(0x20) &#123;&#125; virtual void f() &#123; cout &lt;&lt; "Base2::f()" &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; "Base2::g()" &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; "Base2::h()" &lt;&lt; endl; &#125;&#125;;class Base3&#123;public: long ibase3; Base3() : ibase3(0x30) &#123;&#125; virtual void f() &#123; cout &lt;&lt; "Base3::f()" &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; "Base3::g()" &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; "Base3::h()" &lt;&lt; endl; &#125;&#125;;class Derive : public Base1, public Base2, public Base3&#123;public: long iderive; Derive() : iderive(0x100) &#123;&#125; virtual void f() &#123; cout &lt;&lt; "Derive::f()" &lt;&lt; endl; &#125; virtual void g1() &#123; cout &lt;&lt; "Derive::g1()" &lt;&lt; endl; &#125;&#125;;typedef void (*Fun)(void);int main()&#123; Derive d; long **pVtab = (long **)&amp;d; Fun pFun; cout&lt;&lt;hex; cout &lt;&lt; "[0] Base1::_vptr-&gt;" &lt;&lt; endl; pFun = (Fun)pVtab[0][0]; cout &lt;&lt; " [0] "; pFun(); pFun = (Fun)pVtab[0][1]; cout &lt;&lt; " [1] "; pFun(); pFun = (Fun)pVtab[0][2]; cout &lt;&lt; " [2] "; pFun(); pFun = (Fun)pVtab[0][3]; cout &lt;&lt; " [3] "; pFun(); pFun = (Fun)pVtab[0][4]; cout &lt;&lt; " [4] "; cout &lt;&lt; pFun &lt;&lt; endl; cout &lt;&lt; "[1] Base1.ibase1 = " &lt;&lt; (long)(pVtab[1]) &lt;&lt; endl; long s = sizeof(Base1) / 8; cout &lt;&lt; "[" &lt;&lt; s &lt;&lt; "] Base2::_vptr-&gt;" &lt;&lt; endl; pFun = (Fun)pVtab[s][0]; cout &lt;&lt; " [0] "; pFun(); cout &lt;&lt; " [1] "; pFun=(Fun)pVtab[s][1]; pFun(); pFun = (Fun)pVtab[s][2]; cout &lt;&lt; " [2] "; pFun(); pFun = (Fun)pVtab[s][3]; cout &lt;&lt; " [3] "; cout &lt;&lt; pFun &lt;&lt; endl; cout &lt;&lt; "[" &lt;&lt; s + 1 &lt;&lt; "] Base2.ibase2 = " &lt;&lt; (long)(pVtab[s + 1]) &lt;&lt; endl; s = s + sizeof(Base2) / 8; cout &lt;&lt; "[" &lt;&lt; s &lt;&lt; "] Base3::_vptr-&gt;" &lt;&lt; endl; pFun = (Fun)pVtab[s][0]; cout &lt;&lt; " [0] "; pFun(); pFun = (Fun)pVtab[s][1]; cout &lt;&lt; " [1] "; pFun(); pFun = (Fun)pVtab[s][2]; cout &lt;&lt; " [2] "; pFun(); pFun = (Fun)pVtab[s][3]; cout &lt;&lt; " [3] "; cout &lt;&lt; pFun &lt;&lt; endl; s++; cout &lt;&lt; "[" &lt;&lt; s &lt;&lt; "] Base3.ibase3 = " &lt;&lt; (long)pVtab[s] &lt;&lt; endl; s++; cout &lt;&lt; "[" &lt;&lt; s &lt;&lt; "] Derive.iderive = " &lt;&lt; (long)pVtab[s] &lt;&lt; endl;&#125; ËøêË°åÁªìÊûú1234567891011121314151617181920[0] Base1::_vptr-&gt; [0] Derive::f() [1] Base1::g() [2] Base1::h() [3] Derive::g1() [4] 1//Ëøô‰∏™Ë°®Á§∫ÊúÄÂêé‰∏Ä‰∏™[1] Base1.ibase1 = 10[2] Base2::_vptr-&gt; [0] Derive::f() [1] Base2::g() [2] Base2::h() [3] 1[3] Base2.ibase2 = 20[4] Base3::_vptr-&gt; [0] Derive::f() [1] Base3::g() [2] Base3::h() [3] 0[5] Base3.ibase3 = 30[6] Derive.iderive = 100 Áî®GDBÁúãÁúã1234567891011121314151617181920212223-exec p pVtab$1 = (long **) 0x7fffffffcb80-exec x /10xg 0x7fffffffcb800x7fffffffcb80: 0x0000555555756c50 0x00000000000000100x7fffffffcb90: 0x0000555555756c80 0x00000000000000200x7fffffffcba0: 0x0000555555756ca8 0x00000000000000300x7fffffffcbb0: 0x0000000000000100 0x00000000000000000x7fffffffcbc0: 0x000055555555583e 0x00007fffffffcb80-exec x /10xg 0x0000555555756c500x555555756c50 &lt;_ZTV6Derive+16&gt;: 0x000055555555583e 0x00005555555555be0x555555756c60 &lt;_ZTV6Derive+32&gt;: 0x00005555555555f6 0x00005555555558820x555555756c70 &lt;_ZTV6Derive+48&gt;: 0xfffffffffffffff0 0x0000555555756d380x555555756c80 &lt;_ZTV6Derive+64&gt;: 0x000055555555587b 0x000055555555568c0x555555756c90 &lt;_ZTV6Derive+80&gt;: 0x00005555555556c4 0xffffffffffffffe0-exec x /10xg 0x000055555555583e (‰∏çÁü•ÈÅì‰∏∫Âï•ÂÖ∂‰ªñÊü•ÁúãÂÖ∂‰ªñÂá†‰∏™ËôöË°®ÔºåÂíåËøô‰∏™ÂÄº‰∏ç‰∏ÄÊ†∑Ôºå‰ΩÜÊòØ‰πüÊåáÂêëËøô‰∏™ÂáΩÊï∞)0x55555555583e &lt;Derive::f()&gt;: 0x10ec8348e5894855 0x57358d48f87d89480x55555555584e &lt;Derive::f()+16&gt;: 0x18083d8d48000001 0x48fffff453e800200x55555555585e &lt;Derive::f()+32&gt;: 0x201791058b48c289 0xe8d78948c68948000x55555555586e &lt;Derive::f()+48&gt;: 0x48c3c990fffff45e 0xef8348c3eb20ef830x55555555587e &lt;_ZThn16_N6Derive1fEv+3&gt;: 0xe589485590bdeb10 0xf87d894810ec8348 ÈáçÂ§çÁªßÊâø123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;iostream&gt;using namespace std;class B&#123;public: long ib; char cb;public: B() : ib(0), cb('B') &#123; &#125; virtual void f() &#123; cout &lt;&lt; "B::f()" &lt;&lt; endl; &#125; virtual void Bf() &#123; cout &lt;&lt; "B::Bf()" &lt;&lt; endl; &#125;&#125;;class B1 : public B&#123;public: long ib1; char cb1;public: B1() : ib1(11), cb1('1') &#123; &#125; virtual void f() &#123; cout &lt;&lt; "B1::f()" &lt;&lt; endl; &#125; virtual void f1() &#123; cout &lt;&lt; "B1::f1()" &lt;&lt; endl; &#125; virtual void Bf1() &#123; cout &lt;&lt; "B1::Bf1()" &lt;&lt; endl; &#125;&#125;;class B2 : public B&#123;public: long ib2; char cb2;public: B2() : ib2(12), cb2('2') &#123; &#125; virtual void f() &#123; cout &lt;&lt; "B2::f()" &lt;&lt; endl; &#125; virtual void f2() &#123; cout &lt;&lt; "B2::f2()" &lt;&lt; endl; &#125; virtual void Bf2() &#123; cout &lt;&lt; "B2::Bf2()" &lt;&lt; endl; &#125;&#125;;class D : public B1, public B2&#123;public: long id; char cd;public: D() : id(100), cd('D') &#123; &#125; virtual void f() &#123; cout &lt;&lt; "D::f()" &lt;&lt; endl; &#125; virtual void f1() &#123; cout &lt;&lt; "D::f1()" &lt;&lt; endl; &#125; virtual void f2() &#123; cout &lt;&lt; "D::f2()" &lt;&lt; endl; &#125; virtual void Df() &#123; cout &lt;&lt; "D::Df()" &lt;&lt; endl; &#125;&#125;;typedef void (*Fun)(void);int main()&#123; long **pVtab = NULL; Fun pFun = NULL; D d; pVtab = (long **)&amp;d; cout &lt;&lt; "[0] D::B1::_vptr-&gt;" &lt;&lt; endl; pFun = (Fun)pVtab[0][0]; cout &lt;&lt; " [0] "; pFun(); pFun = (Fun)pVtab[0][1]; cout &lt;&lt; " [1] "; pFun(); pFun = (Fun)pVtab[0][2]; cout &lt;&lt; " [2] "; pFun(); pFun = (Fun)pVtab[0][3]; cout &lt;&lt; " [3] "; pFun(); pFun = (Fun)pVtab[0][4]; cout &lt;&lt; " [4] "; pFun(); pFun = (Fun)pVtab[0][5]; cout &lt;&lt; " [5] 0x" &lt;&lt; pFun &lt;&lt; endl; cout &lt;&lt; "[1] B::ib = " &lt;&lt; (long)pVtab[1] &lt;&lt; endl; cout &lt;&lt; "[2] B::cb = " &lt;&lt; static_cast&lt;char&gt;((long)(pVtab[2])) &lt;&lt; endl; cout &lt;&lt; "[3] B1::ib1 = " &lt;&lt; (long)pVtab[3] &lt;&lt; endl; cout &lt;&lt; "[4] B1::cb1 = " &lt;&lt; (static_cast&lt;char&gt;((long)(pVtab[4]))) &lt;&lt; endl; cout &lt;&lt; "[5] D::B2::_vptr-&gt;" &lt;&lt; endl; pFun = (Fun)pVtab[5][0]; cout &lt;&lt; " [0] "; pFun(); pFun = (Fun)pVtab[5][1]; cout &lt;&lt; " [1] "; pFun(); pFun = (Fun)pVtab[5][2]; cout &lt;&lt; " [2] "; pFun(); pFun = (Fun)pVtab[5][3]; cout &lt;&lt; " [3] "; pFun(); pFun = (Fun)pVtab[5][4]; cout &lt;&lt; " [4] 0x" &lt;&lt; pFun &lt;&lt; endl; cout &lt;&lt; "[6] B::ib = " &lt;&lt; (long)pVtab[6] &lt;&lt; endl; cout &lt;&lt; "[7] B::cb = " &lt;&lt; (static_cast&lt;char&gt;((long)pVtab[7])) &lt;&lt; endl; cout &lt;&lt; "[8] B2::ib2 = " &lt;&lt; (long)pVtab[8] &lt;&lt; endl; cout &lt;&lt; "[9] B2::cb2 = " &lt;&lt; (static_cast&lt;char&gt;((long)pVtab[9])) &lt;&lt; endl; cout &lt;&lt; "[10] D::id = " &lt;&lt; (long)pVtab[10] &lt;&lt; endl; cout &lt;&lt; "[11] D::cd = " &lt;&lt; (static_cast&lt;char&gt;((long)pVtab[11])) &lt;&lt; endl;&#125; ËæìÂá∫ÁªìÊûú1234567891011121314151617181920212223[0] D::B1::_vptr-&gt; [0] D::f() [1] B::Bf() [2] D::f1() [3] B1::Bf1() [4] D::f2() [5] 0x1[1] B::ib = 0[2] B::cb = B[3] B1::ib1 = 11[4] B1::cb1 = 1[5] D::B2::_vptr-&gt; [0] D::f() [1] B::Bf() [2] D::f2() [3] B2::Bf2() [4] 0x0[6] B::ib = 0[7] B::cb = B[8] B2::ib2 = 12[9] B2::cb2 = 2[10] D::id = 100[11] D::cd = D GDBË∞ÉËØï 1234567x /12x 0x7fffffffcb600x7fffffffcb60: 0x0000555555756c58 0x00000000000001230x7fffffffcb70: 0x0000555555756c55 0x00000000000001110x7fffffffcb80: 0x0000000000000011 0x0000555555756c980x7fffffffcb90: 0x0000000000000123 0x00005555555555550x7fffffffcba0: 0x0000000000000212 0x0000555555555a220x7fffffffcbb0: 0x0000000000000100 0x0000000000000033 ËôöÊãüÁªßÊâøÂ§ß‰Ω¨ÂÅ∑Êáí‰∫ÜÔºåÈÇ£Êàë‰ª¨ÂÆå‰∫ÜÂïä„ÄÇ ÂØπ‰∫éËøô‰∏™ËôöÊãüÁªßÊâøÔºåÂíå64‰ΩçÊú∫Â•ΩÂÉèÊúâÁÇπ‰∏ç‰∏ÄÊ†∑ÔºåÊàë‰πü‰∏çÁü•ÈÅì‰∏∫Âï•„ÄÇÂ¶ÇÊûúÊúâ‰∫∫ÁúãÊáÇ‰∫ÜÂõûÊù•ÁßÅ‰ø°ÊàëÔºàÁïô‰∏™Ë®Ä‰πüË°åÔºâ„ÄÇÂëäËØâÊàë‰∏∫Âï•„ÄÇ ÊàëË¥¥‰∏Ä‰∏™Ëá™Â∑±ÁöÑÂÆûÈ™å„ÄÇ‰∏ç‰øùËØÅÊ≠£Á°ÆÊÄß„ÄÇ]]></content>
      <categories>
        <category>ËÆ°ÁÆóÊú∫ËØ≠Ë®Ä</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ ËôöÊãüÁªßÊâøÂØπË±°Â∏ÉÂ±Ä]]></title>
    <url>%2F2020%2F02%2F18%2FC%2B%2B-%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[Ëá™Â∑±ÂÅöÂÆûÈ™åÁöÑÊó∂ÂÄôÂèëÁé∞Âíå‰∏Ä‰∫õÊñáÁ´†‰∏äÈù¢ÁöÑÊúâÁÇπ‰∏ç‰∏ÄÊ†∑„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;using namespace std;class B&#123;public: long ib; long cb;//ÂÖ®ÈÉΩÂÆö‰πâÊàê long Ëøô‰∏™Êñπ‰æøÁúãÂÜÖÂ≠òÔºå‰∏çÁÑ∂‰∏çÊòØÂØπÈΩêÁöÑpublic: B() :ib(0x1010), cb(0x1010) &#123;&#125; virtual void f() &#123; cout &lt;&lt; "B::f()" &lt;&lt; endl; &#125; virtual void Bf() &#123; cout &lt;&lt; "B::Bf()" &lt;&lt; endl; &#125;&#125;;class B1 : virtual public B&#123;public: long ib1; long cb1;public: B1() :ib1(0x1111111), cb1(0x1111) &#123;&#125; //virtual void f() &#123; cout &lt;&lt; "B1::f()" &lt;&lt; endl; &#125; //‰∏∫‰ªÄ‰πàË¶ÅÊ≥®ÈáäÊéâÂë¢ÔºåÂêéÈù¢ËØ¥Ôºå‰∏çÊ≥®ÈáäÊéâÊòØÂ§±Ë¥•ÁöÑ ÊòØËøêË°å‰∏ç‰∫ÜÁöÑ virtual void f1() &#123; cout &lt;&lt; "B1::f1()" &lt;&lt; endl; &#125; virtual void Bf1() &#123; cout &lt;&lt; "B1::Bf1()" &lt;&lt; endl; &#125;&#125;;int main()&#123; typedef void(*Fun)(void); long long** pVtab = NULL; Fun pFun = NULL; B1 bb1; cout&lt;&lt;hex; pVtab = (long long**)&amp;bb1; cout&lt;&lt;"offset:"&lt;&lt;(long)pVtab-(long)(B*)&amp;bb1&lt;&lt;endl;//Âõ†‰∏∫Â≠òÂú®ÂÅèÁßª (B*)&amp;bb1 ÊòØ‰∏çÁ≠â‰∫é &amp;bb1 Ëøô‰∏™Âú∞ÂùÄÁöÑ„ÄÇ cout &lt;&lt; "[0] B1::_vptr-&gt;" &lt;&lt; endl; for(int i=0;(Fun) pVtab[0][i]!=NULL;i++)&#123; cout&lt;&lt;"\t["&lt;&lt;i&lt;&lt;"]\t"; pFun=(Fun)pVtab[0][i]; pFun(); &#125; cout &lt;&lt; "[2] B1::ib1 = "; cout &lt;&lt; (long)pVtab[1]&lt;&lt; endl; //B1::ib1 cout &lt;&lt; "[3] B1::cb1 = "; cout &lt;&lt; (long)pVtab[2] &lt;&lt; endl; //B1::cb1 cout &lt;&lt; "[3] B::_vptr-&gt;" &lt;&lt; endl; for(int i=0;i&lt;2;i++)&#123; //Â∞±ÊòØËøô‰∏™Âú∞ÊñπÔºåÂ¶ÇÊûúÂâçÈù¢‰∏çÊ≥®ÈáäÊéâÂ∞±‰ºöÊä•Èîô //ËøòÊúâ‰Ω†Ê≤°ÊúâÊ≤°ÊúâÊ≥®ÊÑèÂà∞ÁªÜËäÇ ÔºåÊàëËøô‰∏™Âú∞ÊñπÂÜôÁöÑÊòØ &lt;2 Âπ∂‰∏çÊòØ ÂáΩÊï∞‰∏∫ Á©∫Ôºü cout&lt;&lt;"\t["&lt;&lt;i&lt;&lt;"]\t"; pFun=(Fun)(pVtab[3][i]); pFun(); &#125; cout &lt;&lt; "[4] B::ib1 = "; cout &lt;&lt; (long)pVtab[4]&lt;&lt; endl; //B1::ib1 cout &lt;&lt; "[5] B::cb1 = "; cout &lt;&lt; (long)*(pVtab+5) &lt;&lt; endl; //B1::cb1 return 0;&#125; ËæìÂá∫ÁªìÊûú1234567891011offset:ffffffffffffffe8[0] B1::_vptr-&gt; [0] B1::f1() [1] B1::Bf1()[2] B1::ib1 = 1111111[3] B1::cb1 = 1111[3] B::_vptr-&gt; [0] B::f() [1] B::Bf()[4] B::ib1 = 1010[5] B::cb1 = 1010 GDB Ë∞ÉËØï Êü•ÁúãÂÜÖÂ≠òÔºåÊúâÊÑèÊÄùÁöÑÊù•‰∫Ü„ÄÇ12345678(gdb) p pVtab$1 = (long long **) 0x7ffdf9b52fc0 //‰∏Ä‰∏™B1ÂØπË±°ÁöÑÂÖ∑‰ΩìÂÜÖÂ≠ò(gdb) x /10xg 0x7ffdf9b52fc00x7ffdf9b52fc0: 0x0000562080dd6d08(Ëøô‰∏™ÊòØÁ¨¨‰∏Ä‰∏™ËôöË°®ÊåáÈíà) 0x00000000011111110x7ffdf9b52fd0: 0x0000000000001111 0x0000562080dd6d38(Á¨¨‰∫å‰∏™ËôöË°®ÊåáÈíàÔºâ0x7ffdf9b52fe0: 0x0000000000001010 0x00000000000010100x7ffdf9b52ff0: 0x0000562080bd61c0 0x0000562080bd617e0x7ffdf9b53000: 0x00007ffdf9b52fc0 0x0000000200000000 ÊúâÁöÑÊñáÁ´†ÈáåÈù¢ËØ¥ÔºåËôöÊãüÁªßÊâøÊØè‰∏™Âü∫Á±ª‰ºöÂàõÂª∫‰∏Ä‰∏™ËôöË°®ÔºåÂÆûÈôÖ‰∏äÂπ∂Ê≤°ÊúâÔºåÂè™ÊòØÂ§ö‰∫Ü‰∏Ä‰∏™ËôöË°®ÊåáÈíàÂπ∂Ê≤°ÊúâÈÇ£‰πàÂ§öÁ•ûÂ•áÁöÑÁé©ÊÑè„ÄÇ‰Ω†ÂèØ‰ª•ÂèëÁé∞‰∏§‰∏™Âú∞ÂùÄÊå®ÁùÄÈùûÂ∏∏Ëøë„ÄÇÊàë‰ª¨Êü•Áúã 0x0000562080dd6d08Ëøô‰∏™ÁöÑÂÜÖÂ≠ò„ÄÇ123456gdb) x /10xg 0x0000562080dd6d080x562080dd6d08 &lt;vtable for B1+24&gt;: 0x0000562080bd6146 0x0000562080bd617e0x562080dd6d18 &lt;vtable for B1+40&gt;: 0x0000000000000000 0x00000000000000000x562080dd6d28 &lt;vtable for B1+56&gt;: 0xffffffffffffffe8 0x0000562080dd6d780x562080dd6d38 &lt;vtable for B1+72&gt;: 0x0000562080bd607eÔºàÁ¨¨‰∫å‰∏™ËôöË°®ÊåáÈíàÂú®Ëøô???Ôºâ 0x0000562080bd60b60x562080dd6d48 &lt;VTT for B1&gt;: 0x0000562080dd6d08(ÊúâÊ≤°ÊúâÂèëÁé∞Ëøô‰∏™Âú∞ÂùÄÂ∞±ÊòØÁ¨¨‰∏Ä‰∏™ËôöË°®ÊåáÈíàÔºåÂπ∂Ê≤°ÊúâNULLÔºåÊâÄ‰ª•ÊàëÈÇ£‰∏™Âú∞ÊñπÂÜôÁöÑÊòØi&lt;2) 0x0000562080dd6d38 ÁúãÂà∞‰∫ÜÂêóÔºåÂÆûÈôÖ‰∏äÂÖ®ÈÉΩÂú®B1ÁöÑËôöË°®ÈáåÈù¢ÔºåÂè™ÊòØÊåáÈíàÊåáÂêëÁöÑ‰ΩçÁΩÆ‰∏ç‰∏ÄÊ†∑„ÄÇËøòÊúâ‰∏™Êõ¥ÊúâÊÑèÊÄùÁöÑ„ÄÇÊúâÊ≤°ÊúâÂèëÁé∞Êúâ‰∏§‰∏™0x0000000000000000ÁõÆÂâç‰∏çÁü•ÈÅìÊòØÂï•„ÄÇ0xffffffffffffffe8Ëøô‰∏™ÂàöÂ•ΩÂ∞±ÊòØÂÅèÁßªÈáèÔºåÂπ∂Ê≤°Êúâ‰ªÄ‰πàÊåáÈíàÁõ¥Êé•ÊåáÂêë‰ªñ„ÄÇÊâÄ‰ª•Êàë‰∏çÁü•ÈÅìËôöÂü∫Ë°®ÊåáÈíàÊòØÂï•Ôºå‰πüÊ≤°ÁúãÂà∞‰∏Ä‰∏™ÊåáÈíàÁÆóËøõÂØπË±°ÁöÑÁ©∫Èó¥„ÄÇ ÁÑ∂ÂêéÂÜçÁªßÁª≠ÁúãËøô‰∏§‰∏™ËôöË°®ÊåáÈíàÁöÑÂÜÖÂÆπ„ÄÇ12345678910111213(gdb) x /10xg 0x0000562080bd6146 //‰∏çÂá∫ÊÑèÂ§ñÊòØ‰∏™ÂáΩÊï∞0x562080bd6146 &lt;B1::f1()&gt;: 0x10ec8348e5894855 0xfb358d48f87d89480x562080bd6156 &lt;B1::f1()+16&gt;: 0x0f003d8d48000000 0x48fffff97be800200x562080bd6166 &lt;B1::f1()+32&gt;: 0x200e89058b48c289 0xe8d78948c68948000x562080bd6176 &lt;B1::f1()+48&gt;: 0x90c3c990fffff976 0x10ec8348e58948550x562080bd6186 &lt;B1::Bf1()+8&gt;: 0xcc358d48f87d8948 0x0ec83d8d48000000(gdb) x /10xg 0x0000562080bd607e //Á¨¨‰∫å‰∏™ÊåáÈíà‰πüÊòØ0x562080bd607e &lt;B::f()&gt;: 0x10ec8348e5894855 0xb4358d48f87d89480x562080bd608e &lt;B::f()+16&gt;: 0x0fc83d8d48000001 0x48fffffa43e800200x562080bd609e &lt;B::f()+32&gt;: 0x200f51058b48c289 0xe8d78948c68948000x562080bd60ae &lt;B::f()+48&gt;: 0x90c3c990fffffa3e 0x10ec8348e58948550x562080bd60be &lt;B::Bf()+8&gt;: 0x83358d48f87d8948 0x0f903d8d48000001 ÁÑ∂ÂêéÂ∞±ÊòØÊõ¥ÊúâÊÑèÊÄùÁöÑ„ÄÇËÆ∞ÂæóÊàë‰ª¨ÂéüÊú¨Ê≥®ÈáäÁöÑÂêóÔºåÊàë‰ª¨Êää‰ªñÂèñÊ∂àÊ≥®ÈáäÂÜçÊù•GDBË∞ÉËØï„ÄÇ123(gdb) x /10xg 0x000055aec160519d //Âõ†‰∏∫ÈáçÊñ∞ËøêË°å‰∫ÜÂú∞ÂùÄ‰∏ç‰∏ÄÊ†∑ÔºåÊàë‰ª¨ÂÉèÈÇ£Ê†∑ÁúãÁ¨¨‰∫å‰∏™ËôöÊåáÈíàÁ¨¨‰∏ÄÈ°πÁöÑÂÄº0x55aec160519d &lt;virtual thunk to B1::f()&gt;: 0xebe87a0349178b4c 0xec8348e5894855c0//ÁúãÂà∞‰∫Ü virtual thunk ÔºåËøô‰∏™ÂëäËØâÊàë‰ª¨Ëøô‰∏™Â∑≤ÁªèË¢´ÈáçÂÜô‰∫ÜÔºåÁÑ∂ÂêéÂèà‰ºöË∞ÉÁî®B1::f() ÊòØ‰∏çÊòØÂèëÁé∞Ëøô‰∏™Â∏ÉÂ±ÄÂæàÂÉèËøôÁßçÂÜôÊ≥ï„ÄÇ123class B&#123; A a;&#125; ÂΩìÁÑ∂Âè™ÊòØÊúâÁÇπÂÉèÔºåÂà∞‰∫ÜËè±ÂΩ¢ÁªßÊâøÂ∞±Â∑ÆË∑ùÂæàÂ§ß‰∫Ü„ÄÇÊàë‰ª¨ÁªßÁª≠Êé¢Á¥¢„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;using namespace std;#include &lt;iostream&gt;using namespace std;class B&#123;public: long ib;public: B() : ib(0xbbbbb) &#123;&#125; virtual void f() &#123; cout &lt;&lt; "B::f()" &lt;&lt; endl; &#125; virtual void Bf() &#123; cout &lt;&lt; "B::Bf()" &lt;&lt; endl; &#125;&#125;;class B1 : virtual public B&#123;public: long ib1;public: B1() : ib1(0x1111) &#123; &#125; virtual void f()&#123;cout &lt;&lt; "B1::f()" &lt;&lt; endl;&#125; virtual void f1() &#123; cout &lt;&lt; "B1::f1()" &lt;&lt; endl; &#125; virtual void Bf1() &#123; cout &lt;&lt; "B1::Bf1()" &lt;&lt; endl; &#125;&#125;;class B2 : virtual public B&#123;public: long ib2;public: B2() : ib2(0x2222) &#123; &#125;// virtual void f()&#123;cout &lt;&lt; "B2::f()" &lt;&lt; endl;&#125; virtual void f2() &#123; cout &lt;&lt; "B2::f2()" &lt;&lt; endl; &#125; virtual void Bf2() &#123; cout &lt;&lt; "B2::Bf2()" &lt;&lt; endl; &#125;&#125;;class D : public B1, public B2&#123;public: long id;public: D() : id(0xdddd) &#123; &#125; virtual void f() &#123; cout &lt;&lt; "D::f()" &lt;&lt; endl; &#125; virtual void f1() &#123; cout &lt;&lt; "D::f1()" &lt;&lt; endl; &#125; virtual void f2() &#123; cout &lt;&lt; "D::f2()" &lt;&lt; endl; &#125; virtual void Df() &#123; cout &lt;&lt; "D::Df()" &lt;&lt; endl; &#125;&#125;;int main()&#123; typedef void(*Fun)(void); long long** pVtab = NULL; Fun pFun = NULL; D d; cout&lt;&lt;"D size:"&lt;&lt;sizeof(d)&lt;&lt;endl; cout&lt;&lt;"B1 size:"&lt;&lt;sizeof(B1)&lt;&lt;endl; cout&lt;&lt;"D address:"&lt;&lt;&amp;d&lt;&lt;endl; cout&lt;&lt;"B1 address:"&lt;&lt;(B1*)&amp;d&lt;&lt;endl; cout&lt;&lt;"B1-B2 offset:"&lt;&lt;(long)(B1*)&amp;d-(long)(B2*)&amp;d&lt;&lt;endl; cout&lt;&lt;"B2-B offset:"&lt;&lt;(long)(B2*)&amp;d-(long)(B*)&amp;d&lt;&lt;endl; cout&lt;&lt;"B address:"&lt;&lt;(B*)&amp;d&lt;&lt;endl; pVtab = (long long**)&amp;d; cout&lt;&lt;hex; cout &lt;&lt; "[0] B1::_vptr-&gt;" &lt;&lt; endl; for(int i=0;i&lt;5;i++)&#123; cout&lt;&lt;"\t["&lt;&lt;i&lt;&lt;"]\t"; pFun=(Fun)pVtab[0][i]; pFun(); &#125; cout &lt;&lt; "[1] B1::ib1 = "; cout &lt;&lt; (long)pVtab[1]&lt;&lt; endl; cout &lt;&lt; "[2] B2::_vptr-&gt;" &lt;&lt; endl; for(int i=0;i&lt;2;i++)&#123; cout&lt;&lt;"\t["&lt;&lt;i&lt;&lt;"]\t"; pFun=(Fun)pVtab[2][i]; pFun(); &#125; cout &lt;&lt; "[3] B2::ib2 = "; cout &lt;&lt; (long)pVtab[3]&lt;&lt; endl; cout &lt;&lt; "[4] B::ib = "; cout &lt;&lt; (long)pVtab[4]&lt;&lt; endl; cout &lt;&lt; "[5] B::_vptr-&gt;" &lt;&lt; endl; for(int i=1;i&lt;2;i++)&#123; cout&lt;&lt;"\t["&lt;&lt;i&lt;&lt;"]\t"; pFun=(Fun)pVtab[5][i]; pFun(); &#125; cout &lt;&lt; "[6] B::ib = "; cout &lt;&lt; (long)pVtab[6]&lt;&lt; endl; return 0;&#125; ËøêË°åÁªìÊûú12345678910111213141516171819202122D size:56B1 size:32D address:0x7fff13a26610B1 address:0x7fff13a26610B1-B2 offset:-16B2-B offset:-24B address:0x7fff13a26638[0] B1::_vptr-&gt; [0] D::f() [1] D::f1() [2] B1::Bf1() [3] D::f2() [4] D::Df()[1] B1::ib1 = 1111[2] B2::_vptr-&gt; [0] D::f2() [1] B2::Bf2()[3] B2::ib2 = 2222[4] B::ib = dddd[5] B::_vptr-&gt; [1] B::Bf()[6] B::ib = bbbbb GDBÊü•ÁúãÂÜÖÂ≠ò„ÄÇ123456(gdb) x /10xg pVtab0x7ffc64cadc10: 0x000055c32e665b88(B1ÁöÑËôöÊåáÈíà) 0x00000000000011110x7ffc64cadc20: 0x000055c32e665bc8ÔºàB2ÁöÑËôöÊåáÈíàÔºâ 0x00000000000022220x7ffc64cadc30: 0x000000000000ddddÔºàDÁöÑÊï∞ÊçÆÔºâ 0x000055c32e665bf8(BÁöÑËôöÊåáÈíà)0x7ffc64cadc40: 0x00000000000bbbbb 0x00000000000000000x7ffc64cadc50: 0x0000000000000000 0x00007ffc64cadc10 ÁúãÂà∞ËøôÂ∫îËØ•ÈÉΩÊ∏ÖÊ•ö‰∫Ü„ÄÇÊòæÁÑ∂BÂ∏ÉÂ±ÄÂà∞‰∫ÜÊúÄÂêéÈù¢„ÄÇÂ§ßÊ¶ÇÂ∞±ÊòØÂõ†‰∏∫Ëøô‰∏™ÊâÄ‰ª•ÊâçËÉΩÂÆûÁé∞Âè™Êúâ‰∏Ä‰ªΩÊã∑Ë¥ùÂêß„ÄÇÂÖ∑‰ΩìËØ¶ÁªÜÂàÜÊûêÔºåËá™Â∑±ËøõÂéªÁúãÂêßÔºåÂ∞±ÊòØÊää‰∏úË•øÁªìÂêàËµ∑Êù•„ÄÇ‰∏∫‰∫ÜÊñπ‰æøÊü•ÁúãÂÅèÁßªÈáè ÊàëGDB Ë∞ÉËØï 10ËøõÂà∂1234567891011121314151617181920212223242526(gdb) x /10g pVtab0x7ffd2687ea70: 94162329979784 43690x7ffd2687ea80: 94162329979848 87380x7ffd2687ea90: 56797 941623299798960x7ffd2687eaa0: 768955 00x7ffd2687eab0: 0 140725249895024(gdb) x /10dg 941623299797840x55a3e03acb88 &lt;vtable for D+24&gt;: 94162327877818 941623278778820x55a3e03acb98 &lt;vtable for D+40&gt;: 94162327877436 941623278779380x55a3e03acba8 &lt;vtable for D+56&gt;: 94162327878000 24Ôºà‰∏çÁü•ÈÅìÂÖ∑‰ΩìÊÄé‰πàÊéíÂàóÁöÑÔºå‰ΩÜÊòØÁü•ÈÅìÊúâÂ∞±Ë°å‰∫ÜÔºâ0x55a3e03acbb8 &lt;vtable for D+72&gt;: -16 941623299801840x55a3e03acbc8 &lt;vtable for D+88&gt;: 94162327877993 94162327877624(gdb) x /10dg 941623299798480x55a3e03acbc8 &lt;vtable for D+88&gt;: 94162327877993 941623278776240x55a3e03acbd8 &lt;vtable for D+104&gt;: 0 -400x55a3e03acbe8 &lt;vtable for D+120&gt;: -40 941623299801840x55a3e03acbf8 &lt;vtable for D+136&gt;: 94162327877873 941623278771840x55a3e03acc08 &lt;VTT for D&gt;: 94162329979784 94162329979992(gdb) x /10dg 941623299798960x55a3e03acbf8 &lt;vtable for D+136&gt;: 94162327877873 941623278771840x55a3e03acc08 &lt;VTT for D&gt;: 94162329979784 941623299799920x55a3e03acc18 &lt;VTT for D+16&gt;: 94162329980048 941623299800880x55a3e03acc28 &lt;VTT for D+32&gt;: 94162329980136 941623299798960x55a3e03acc38 &lt;VTT for D+48&gt;: 94162329979848 40 Áúã‰∫ÜÂ•ΩÂ§öÂçöÂÆ¢ÔºåÈÉΩÊêû‰∏çÊáÇÔºåËá™Â∑±ÂÅöÂá∫Êù•ÁöÑÂíå‰ªñ‰ª¨ÊúâÁÇπ‰∏ç‰∏ÄÊ†∑„ÄÇÁªìËÆ∫‰Ω†‰ª¨Ëá™Â∑±ÂæóÂêßÔºåÂëäËæû„ÄÇ]]></content>
      <categories>
        <category>ËÆ°ÁÆóÊú∫ËØ≠Ë®Ä</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT6.828(ÂÖ≠)Lab6:Network Driver(default final project)]]></title>
    <url>%2F2020%2F02%2F18%2FMIT-6.828-(%E5%85%AD)-Lab-6-Network-Driver-(default-final-project)%2F</url>
    <content type="text"><![CDATA[ËøôÊòØÊúÄÂêé‰∏Ä‰∏™ÂÆûÈ™åÔºåÂÅöÂÆåËøô‰∏™‰∏Ä‰∏™Âü∫Êú¨ÁöÑÂÜÖÊ†∏Â∞±ÂÅöÂÆå‰∫Ü„ÄÇËøôÁ´†ÈúÄË¶ÅËá™Â∑±ÂéªÁúãÁöÑ‰∏úË•øÁâπ‰πàÁöÑÂ§öÔºåÊâÄ‰ª•Â§ßÈÉ®ÂàÜÔºåÊàë‰ª¨Â∞±ÁúãÁúãÂÆûÁé∞‰∫Ü‰ªÄ‰πàÔºå‰∏ç‰ºö‰∏ìÈó®‰∏Ä‰∏™‰∏™ÁªÜËäÇÁöÑÁúã‰∫Ü„ÄÇ Lab 6: Network Driver (default final project)IntroductionLab6 ÊòØÊúÄÂêé‰∏Ä‰∏™ÂÆûÈ™å‰∫ÜÔºåÂÅöÂÆåËøô‰∏™Ôºå‰∏Ä‰∏™ÁÆÄÂçïÁöÑÂÜÖÊ†∏Â∞±Â∑≤ÁªèÂÆûÁé∞‰∫ÜÔºåÁé∞Âú®‰Ω†ÂèØ‰ª•Ëá™Â∑±ÂÅöËá™Â∑±ÁöÑÂÜÖÊ†∏„ÄÇÁé∞Âú®Ôºå‰Ω†Êúâ‰∏Ä‰∏™Êñá‰ª∂Á≥ªÁªüÔºåÊìç‰ΩúÁ≥ªÁªüÊ≤°ÊúâÁΩëÁªúÂ†ÜÊ†à„ÄÇÂú®Ëøô‰∏™ÂÆûÈ™åÂÆ§Èáå‰Ω†Ë¶ÅÁºñÂÜô‰∏Ä‰∏™ÁΩëÁªúÊé•Âè£Âç°ÁöÑÈ©±Âä®Á®ãÂ∫è„ÄÇËØ•Âç°Â∞ÜÂü∫‰∫éIntel 82540EMËäØÁâáÔºå‰πüË¢´Áß∞‰∏∫E1000‰∏ä„ÄÇ Getting StartedÂÖàÂàáÊç¢‰∏™ÂàÜÊîØ„ÄÇ Èô§‰∫ÜÁºñÂÜôÈ©±Âä®Á®ãÂ∫è‰πãÂ§ñÔºåÊÇ®ËøòÈúÄË¶ÅÂàõÂª∫‰∏Ä‰∏™Á≥ªÁªüË∞ÉÁî®Êé•Âè£Êù•Êéà‰∫àÂØπÈ©±Âä®Á®ãÂ∫èÁöÑËÆøÈóÆÊùÉÈôê„ÄÇÊÇ®Â∞ÜÂÆûÁé∞Áº∫Â∞ëÁöÑÁΩëÁªúÊúçÂä°Âô®‰ª£Á†ÅÔºå‰ª•Âú®ÁΩëÁªúÂ†ÜÊ†àÂíåÈ©±Âä®Á®ãÂ∫è‰πãÈó¥‰º†ËæìÊï∞ÊçÆÂåÖ„ÄÇÊÇ®ËøòÂ∞ÜÈÄöËøáÂÆåÊàêWebÊúçÂä°Âô®Â∞ÜÊâÄÊúâÂÜÖÂÆπÊçÜÁªëÂú®‰∏ÄËµ∑„ÄÇ‰ΩøÁî®Êñ∞ÁöÑWebÊúçÂä°Âô®ÔºåÊÇ®Â∞ÜËÉΩÂ§ü‰ªéÊñá‰ª∂Á≥ªÁªüÊèê‰æõÊñá‰ª∂„ÄÇ ÊÇ®ÂøÖÈ°ª‰ªéÂ§¥ÂºÄÂßãÁºñÂÜôËÆ∏Â§öÂÜÖÊ†∏ËÆæÂ§áÈ©±Âä®Á®ãÂ∫è‰ª£Á†Å„ÄÇ‰∏é‰ª•ÂâçÁöÑÂÆûÈ™åÁõ∏ÊØîÔºåÊú¨ÂÆûÈ™åÊèê‰æõÁöÑÊåáÂØºË¶ÅÂ∞ëÂæóÂ§öÔºöÊ≤°ÊúâÊ°ÜÊû∂Êñá‰ª∂ÔºåÊ≤°Êúâ‰ªª‰ΩïÂõ∫ÂÆöÁöÑÁ≥ªÁªüË∞ÉÁî®Êé•Âè£ÔºåËÆ∏Â§öËÆæËÆ°ÂÜ≥Á≠ñÈÉΩÁî±ÊÇ®Ëá™Â∑±ÂÜ≥ÂÆö„ÄÇÂõ†Ê≠§ÔºåÊàë‰ª¨Âª∫ËÆÆÊÇ®Âú®ÂºÄÂßã‰ªª‰ΩïÁªÉ‰π†‰πãÂâçÔºåÂÖàÈòÖËØªÊï¥‰∏™‰Ωú‰∏öËÆ∞ÂΩï„ÄÇËÆ∏Â§öÂ≠¶ÁîüÂèëÁé∞Êú¨ÂÆûÈ™åÊØî‰ª•ÂâçÁöÑÂÆûÈ™åÂõ∞ÈöæÂæóÂ§öÔºåÂõ†Ê≠§ËØ∑Áõ∏Â∫îÂú∞ËÆ°ÂàíÊÇ®ÁöÑÊó∂Èó¥„ÄÇÊúÄÁªà‰Ω†‰ºöÂèëÁé∞Ëøô‰∏™‰∏ªË¶ÅÈöæÁÇπÂ∞±ÊòØÁúãÊñáÊ°£ÂÜôÈ©±Âä®„ÄÇÊ†πÊçÆ‰ªñÁöÑÊé®ËçêËÆ©Êàë‰ª¨ÂÖàÁúãÁúãÊï¥‰∏™‰ªªÂä°ÔºåÁõ¥Êé•Áî®Ë∞∑Ê≠åÊµÅÊµ™Âô®ÔºåÁøªËØëÊï¥‰∏™È°µÈù¢ÔºåÁÑ∂ÂêéÂ§ßËá¥ÁúãÁúã„ÄÇ ÁúãÂÆå‰πãÂêéÂèëÁé∞Âπ∂Ê≤°Êúâ‰ªÄ‰πàÂçµÁî®ÔºåËøòÊòØ‰∏çÊáÇÔºåËøòÊòØÊÖ¢ÊÖ¢Êù•„ÄÇ QEMU‚Äôs virtual networkÊàë‰ª¨Â∞Ü‰ΩøÁî®QEMUÁöÑÁî®Êà∑Ê®°ÂºèÁΩëÁªúÂ†ÜÊ†àÔºåÂõ†‰∏∫ÂÆÉ‰∏çÈúÄË¶ÅËøêË°å‰ªª‰ΩïÁÆ°ÁêÜÊùÉÈôê„ÄÇQEMUÁöÑÊñáÊ°£Âú®ËøôÈáåÊúâÊõ¥Â§öÂÖ≥‰∫éuser-netÁöÑ‰ø°ÊÅØ„ÄÇÊàë‰ª¨Â∑≤ÁªèÊõ¥Êñ∞‰∫ÜmakefileÔºå‰ª•ÂêØÁî®QEMUÁöÑÁî®Êà∑Ê®°ÂºèÁΩëÁªúÂ†ÜÊ†àÂíåËôöÊãüE1000ÁΩëÂç°„ÄÇ ÈªòËÆ§ÊÉÖÂÜµ‰∏ãÔºåQEMUÊèê‰æõËøêË°åÂú®IP 10.0.2.2‰∏äÁöÑËôöÊãüË∑ØÁî±Âô®ÔºåÂπ∂Â∞Ü‰∏∫JOSÂàÜÈÖçIPÂú∞ÂùÄ10.0.2.15„ÄÇ‰∏∫‰∫ÜÁÆÄÂçïËµ∑ËßÅÔºåÊàë‰ª¨Â∞ÜËøô‰∫õÈªòËÆ§ÂÄºÁ°¨ÁºñÁ†ÅÂà∞net/ns.h‰∏≠ÁöÑÁΩëÁªúÊúçÂä°Âô®‰∏≠„ÄÇÊàë‰ª¨ÁÆÄÂçïÁúã‰∏Ä‰∏ãËøô‰∏™Êñá‰ª∂12345678910111213141516171819202122#include &lt;inc/ns.h&gt;#include &lt;inc/lib.h&gt;#define IP "10.0.2.15" //IP#define MASK "255.255.255.0" //ZIYANMA#define DEFAULT "10.0.2.2" //ËøôÊòØ‰∏™ËôöÊãüË∑ØÁî±#define TIMER_INTERVAL 250 //Â∫îËØ•ÊòØÊó∂Èó¥‰∏≠Êñ≠Êó∂Èó¥// Virtual address at which to receive page mappings containing client requests.//Âú®Ëøô‰∏™ËôöÊãüÂú∞ÂùÄÊé•Êî∂ ÂåÖÂê´ÂÆ¢Êà∑Á´ØËØ∑Ê±ÇÁöÑ È°µÈù¢Êò†Â∞Ñ„ÄÇ#define QUEUE_SIZE 20#define REQVA (0x0ffff000 - QUEUE_SIZE * PGSIZE)/* timer.c */ void timer(envid_t ns_envid, uint32_t initial_to);/* input.c */ /*Ëøô‰∏§‰∏™ÂáΩÊï∞ÊòØÊàë‰ª¨ÁöÑÁõÆÊ†áÔºåÂ∞±ÊòØ‰∏∫‰∫ÜÂÆûÁé∞Ëøô‰∏§‰∏™ÂáΩÊï∞*/void input(envid_t ns_envid);/* output.c */void output(envid_t ns_envid); Â∞ΩÁÆ°QEMUÁöÑËôöÊãüÁΩëÁªúÂÖÅËÆ∏JOSËøõË°åÂà∞InternetÁöÑ‰ªªÊÑèËøûÊé•Ôºå‰ΩÜJOSÁöÑ10.0.2.15Âú∞ÂùÄÂú®QEMUÂÜÖÈÉ®ËøêË°åÁöÑËôöÊãüÁΩëÁªúÂ§ñÈÉ®Ê≤°Êúâ‰ªª‰ΩïÊÑè‰πâÔºàÂç≥QEMUÂÖÖÂΩìNATÔºâÔºåÂõ†Ê≠§Êàë‰ª¨Êó†Ê≥ïÁõ¥Êé•ËøûÊé•Âà∞ÊúçÂä°Âô®Âç≥‰ΩøÂú®ËøêË°åQEMUÁöÑ‰∏ªÊú∫‰∏≠Ôºå‰πüÂèØ‰ª•Âú®JOSÂÜÖÈÉ®ËøêË°å„ÄÇ‰∏∫‰∫ÜËß£ÂÜ≥Ëøô‰∏™ÈóÆÈ¢òÔºåÊàë‰ª¨Â∞ÜQEMUÈÖçÁΩÆ‰∏∫Âú®‰∏ªÊú∫‰∏äÊüê‰∏™Á´ØÂè£‰∏äËøêË°åÊúçÂä°Âô®ÔºåËØ•ÊúçÂä°Âô®‰ªÖËøûÊé•Âà∞JOS‰∏≠ÁöÑÊüê‰∏™Á´ØÂè£ÔºåÂπ∂Âú®ÁúüÂÆû‰∏ªÊú∫ÂíåËôöÊãüÁΩëÁªú‰πãÈó¥Êù•ÂõûÁ©øÊ¢≠Êï∞ÊçÆ„ÄÇ ÊÇ®Â∞ÜÂú®Á´ØÂè£7ÔºàÂõûÊòæÔºâÂíå80ÔºàhttpÔºâ‰∏äËøêË°åJOSÊúçÂä°Âô®„ÄÇ‰∏∫ÈÅøÂÖçÂú®ÂÖ±‰∫´ÁöÑAthenaÊú∫Âô®‰∏äÂèëÁîüÂÜ≤Á™ÅÔºåmakefile‰ºöÊ†πÊçÆÊÇ®ÁöÑÁî®Êà∑ID‰∏∫Ëøô‰∫õÊú∫Âô®ÁîüÊàêËΩ¨ÂèëÁ´ØÂè£„ÄÇË¶ÅÊü•ÊâæQEMUÂ∞ÜË¶ÅËΩ¨ÂèëÂà∞ÊÇ®ÁöÑÂºÄÂèë‰∏ªÊú∫‰∏äÁöÑÁ´ØÂè£ÔºåËØ∑ËøêË°åmake which-ports„ÄÇ‰∏∫‰∫ÜÊñπ‰æøËµ∑ËßÅÔºåmakefileËøòÊèê‰æõmake nc-7Âíåmake nc-80Ôºå‰ΩøÊÇ®ÂèØ‰ª•Áõ¥Êé•‰∏éÂú®ÁªàÁ´Ø‰∏≠Ëøô‰∫õÁ´ØÂè£‰∏äËøêË°åÁöÑÊúçÂä°Âô®ËøõË°å‰∫§‰∫í„ÄÇÔºàËøô‰∫õÁõÆÊ†á‰ªÖËøûÊé•Âà∞Ê≠£Âú®ËøêË°åÁöÑQEMUÂÆû‰æãÔºõÊÇ®ÂøÖÈ°ªÂçïÁã¨ÂêØÂä®QEMUÊú¨Ë∫´„ÄÇÔºâÈÄö‰øóÁÇπÊù•ËÆ≤ÔºåÂ∞±ÊòØ Ëøô‰∏™JOSÊúçÂä°Âô®Áî®ÁöÑÊòØ 7 Âíå80Á´ØÂè£Ôºå‰ΩÜÊòØ‰Ω†ÁöÑËôöÊãüÊú∫‰∏äÈù¢ÂèØËÉΩÂ∑≤ÁªèÁî®‰∫ÜÔºåÊâÄ‰ª•Â∏Æ‰Ω†ËΩ¨ÂèëÂà∞Âè¶‰∏Ä‰∏™Á´ØÂè£‰∫Ü„ÄÇ Packet InspectionÁîüÊàêÊñá‰ª∂ËøòÈÖçÁΩÆQEMUÁöÑÁΩëÁªúÂ†ÜÊ†àÔºå‰ª•Â∞ÜÊâÄÊúâ‰º†ÂÖ•Âíå‰º†Âá∫Êï∞ÊçÆÂåÖËÆ∞ÂΩïÂà∞ÊÇ®ÁöÑÂÆûÈ™åÂÆ§ÁõÆÂΩï‰∏≠ÁöÑqemu.pcap„ÄÇ Ë¶ÅËé∑ÂèñÊçïËé∑ÁöÑÊï∞ÊçÆÂåÖÁöÑhex/ASCIIÔºåËØ∑‰ΩøÁî®tcpdumpÔºåÂ¶Ç‰∏ãÊâÄÁ§∫Ôºötcpdump -XXnr qemu.pcapÊàñËÄÖÔºåÊÇ®ÂèØ‰ª•‰ΩøÁî®Wireshark‰ª•ÂõæÂΩ¢ÊñπÂºèÊ£ÄÊü•pcapÊñá‰ª∂„ÄÇWiresharkËøòÁü•ÈÅìÂ¶Ç‰ΩïËß£Á†ÅÂíåÊ£ÄÊü•Êï∞ÁôæÁßçÁΩëÁªúÂçèËÆÆ„ÄÇÂ¶ÇÊûúÊÇ®‰ΩøÁî®ÁöÑÊòØAthenaÔºåÂàôÂøÖÈ°ª‰ΩøÁî®WiresharkÁöÑÂâçË∫´etherealÔºåÂÆÉ‰Ωç‰∫ésipbnet locker„ÄÇ Debugging the E1000Êàë‰ª¨ÂæàÂπ∏ËøêËÉΩÂ§ü‰ΩøÁî®‰ªøÁúüÁ°¨‰ª∂„ÄÇÁî±‰∫éE1000Âú®ËΩØ‰ª∂‰∏≠ËøêË°åÔºåÂõ†Ê≠§‰ªøÁúüÁöÑE1000ÂèØ‰ª•‰ª•Áî®Êà∑ÂèØËØªÁöÑÊ†ºÂºèÂêëÊàë‰ª¨Êä•ÂëäÂÖ∂ÂÜÖÈÉ®Áä∂ÊÄÅ‰ª•ÂèäÈÅáÂà∞ÁöÑ‰ªª‰ΩïÈóÆÈ¢ò„ÄÇÈÄöÂ∏∏Ôºå‰ΩøÁî®Ë£∏Êú∫ÁºñÂÜôÈ©±Âä®Á®ãÂ∫èÁöÑÂºÄÂèë‰∫∫ÂëòÂ∞ÜÊó†Ê≥ïËé∑ÂæóËøôÁßçÂ•¢‰æà„ÄÇ E1000ÂèØ‰ª•‰∫ßÁîüÂæàÂ§öË∞ÉËØïËæìÂá∫ÔºåÂõ†Ê≠§ÊÇ®ÂøÖÈ°ªÂêØÁî®ÁâπÂÆöÁöÑÊó•ÂøóËÆ∞ÂΩïÈÄöÈÅì„ÄÇÊÇ®ÂèØËÉΩ‰ºöÂèëÁé∞ÊúâÁî®ÁöÑ‰∏Ä‰∫õÊ∏†ÈÅìÊòØÔºö FlagMeaning tx Êó•ÂøóÂåÖÂèëÈÄÅÊìç‰Ωú txerrËÆ∞ÂΩï‰º†ËæìÁéØÈîôËØØ rxÂ∞ÜÊõ¥ÊîπËÆ∞ÂΩïÂà∞RCTL rxfilter‰º†ÂÖ•Êï∞ÊçÆÂåÖÁöÑÊó•ÂøóËøáÊª§ rxerrÊó•ÂøóÊé•Êî∂ÊåØÈìÉÈîôËØØ unknownÊó•ÂøóËØªÂèñÂíåÂÜôÂÖ•Êú™Áü•ÂØÑÂ≠òÂô® eeprom‰ªéEEPROMËØªÂèñÊó•Âøó interruptËÆ∞ÂΩï‰∏≠Êñ≠ÂíåÊõ¥ÊîπÂà∞‰∏≠Êñ≠ÂØÑÂ≠òÂô®„ÄÇ ‰æãÂ¶ÇÔºåË¶ÅÂêØÁî®txÂíåtxerrÊó•ÂøóËÆ∞ÂΩïÔºåËØ∑‰ΩøÁî®make E1000_DEBUG=tx,txerr ...„ÄÇ Ê≥®ÊÑèÔºö E1000_DEBUGÊ†áÂøó‰ªÖÂú®6.828ÁâàÊú¨ÁöÑQEMU‰∏≠Ëµ∑‰ΩúÁî®„ÄÇ ÊÇ®ÂèØ‰ª•Ëøõ‰∏ÄÊ≠•‰ΩøÁî®ËΩØ‰ª∂‰ªøÁúüÁöÑÁ°¨‰ª∂ËøõË°åË∞ÉËØï„ÄÇÂ¶ÇÊûúÊÇ®Èô∑ÂÖ•Âõ∞Â¢ÉÂπ∂‰∏î‰∏ç‰∫ÜËß£E1000‰∏∫‰ªÄ‰πàÊ≤°ÊúâÊåâÈ¢ÑÊúüÊñπÂºèÂÅöÂá∫ÂìçÂ∫îÔºåÂàôÂèØ‰ª•Âú®hw/net/e1000.c‰∏≠Êü•ÁúãQEMUÁöÑE1000ÂÆûÁé∞„ÄÇ The Network Server‰ªéÂ§¥ÂºÄÂßãÁºñÂÜôÁΩëÁªúÂ†ÜÊ†àÊòØ‰∏ÄÈ°πËâ∞Â∑®ÁöÑÂ∑•‰Ωú„ÄÇÁõ∏ÂèçÔºåÊàë‰ª¨Â∞Ü‰ΩøÁî®lwIPÔºåËøôÊòØ‰∏Ä‰∏™ÂºÄÊ∫êÁöÑËΩªÈáèÁ∫ßTCP/IPÂçèËÆÆÂ•ó‰ª∂ÔºåÂÖ∂‰∏≠ÂåÖÊã¨‰∏Ä‰∏™ÁΩëÁªúÂ†ÜÊ†à„ÄÇÊÇ®ÂèØ‰ª•Âú®Ê≠§Â§ÑÊâæÂà∞ÊúâÂÖ≥lwIPÁöÑÊõ¥Â§ö‰ø°ÊÅØ „ÄÇÂ∞±Ê≠§ËÄåË®ÄÔºåÂ∞±Êàë‰ª¨ËÄåË®ÄÔºålwIPÊòØ‰∏Ä‰∏™ÈªëÁÆ±ÔºåÂÆÉÂÆûÁé∞‰∫ÜBSDÂ•óÊé•Â≠óÊé•Âè£ÔºåÂπ∂ÂÖ∑Êúâ‰∏Ä‰∏™Êï∞ÊçÆÂåÖËæìÂÖ•Á´ØÂè£Âíå‰∏Ä‰∏™Êï∞ÊçÆÂåÖËæìÂá∫Á´ØÂè£„ÄÇ ÁΩëÁªúÊúçÂä°Âô®ÂÆûÈôÖ‰∏äÊòØÂõõ‰∏™ÁéØÂ¢ÉÁöÑÁªÑÂêàÔºö Ê†∏ÂøÉÁΩëÁªúÊúçÂä°Âô®ÁéØÂ¢ÉÔºàÂåÖÊã¨Â•óÊé•Â≠óË∞ÉÁî®ÂàÜÊ¥æÂô®ÂíålwIPÔºâ ËæìÂÖ•ÁéØÂ¢É ËæìÂá∫ÁéØÂ¢É ËÆ°Êó∂Âô®ÁéØÂ¢É ‰∏ãÂõæÊòæÁ§∫‰∫Ü‰∏çÂêåÁöÑÁéØÂ¢ÉÂèäÂÖ∂ÂÖ≥Á≥ª„ÄÇËØ•ÂõæÊòæÁ§∫‰∫ÜÂåÖÊã¨ËÆæÂ§áÈ©±Âä®Á®ãÂ∫èÂú®ÂÜÖÁöÑÊï¥‰∏™Á≥ªÁªüÔºåÁ®çÂêéÂ∞ÜËøõË°å‰ªãÁªç„ÄÇÂú®Êú¨ÂÆûÈ™å‰∏≠ÔºåÊÇ®Â∞ÜÂÆûÁé∞‰ª•ÁªøËâ≤Á™ÅÂá∫ÊòæÁ§∫ÁöÑÈÉ®ÂàÜ„ÄÇËøô‰∏™Âú∞ÊñπÂ∑≤ÁªèÂëäËØâ‰Ω†Êàë‰ª¨Ë¶ÅÂÆûÁé∞‰ªÄ‰πà‰∫Ü ÂÆûÁé∞E1000È©±Âä®ÈáåÈù¢ÁöÑTX Áî®‰∫é‰º†ËæìÊï∞ÊçÆ,RXÁî®‰∫éÂèëÈÄÅÊï∞ÊçÆ„ÄÇ ÂÆûÁé∞ÂèëÈÄÅÁéØÂ¢ÉÂíåËæìÂá∫ÁéØÂ¢ÉÔºåÊó∂ÈíüÁéØÂ¢ÉÂ∑≤ÁªèÂ∏ÆÊàë‰ª¨ÂÆûÁé∞Â•Ω‰∫ÜÔºåÊàë‰ª¨ÂêéÈù¢‰ºöÂéªÁúãÁúã http ÊúçÂä°Âô®ÔºåËøô‰∫õ‰∫ãÂÖ∑‰ΩìÂ∫îÁî®ÊúçÂä°Âô®‰∫Ü„ÄÇThe Core Network Server EnvironmentÊ†∏ÂøÉÁΩëÁªúÊúçÂä°Âô®ÁéØÂ¢ÉÁî±Â•óÊé•Â≠óË∞ÉÁî®ÂàÜÊ¥æÂô®ÂíålwIPÊú¨Ë∫´ÁªÑÊàê„ÄÇÂ•óÊé•Â≠óË∞ÉÁî®Ë∞ÉÂ∫¶Á®ãÂ∫èÁöÑÂ∑•‰ΩúÊñπÂºè‰∏éÊñá‰ª∂ÊúçÂä°Âô®ÂÆåÂÖ®Áõ∏Âêå„ÄÇÁî®Êà∑ÁéØÂ¢É‰ΩøÁî®Â≠òÊ†πÔºàÂèØÂú®lib/nsipc.c‰∏≠ÊâæÂà∞ÔºâÂ∞ÜIPCÊ∂àÊÅØÂèëÈÄÅÂà∞Ê†∏ÂøÉÁΩëÁªúÁéØÂ¢É„ÄÇÂ¶ÇÊûúÊü•Áúã lib/nsipc.cÔºåÊÇ®‰ºöÂèëÁé∞Êàë‰ª¨ÊâæÂà∞Ê†∏ÂøÉÁΩëÁªúÊúçÂä°Âô®ÁöÑÊñπÂºè‰∏éÊâæÂà∞Êñá‰ª∂ÊúçÂä°Âô®ÁöÑÊñπÂºèÁõ∏ÂêåÔºöi386_init‰ΩøÁî®NS_TYPE_NSÂàõÂª∫NSÁéØÂ¢ÉÔºåÂõ†Ê≠§Êàë‰ª¨Êâ´ÊèèenvsÔºåÂØªÊâæËøôÁßçÁâπÊÆäÁöÑÁéØÂ¢ÉÁ±ªÂûã„ÄÇÂØπ‰∫éÊØè‰∏™Áî®Êà∑ÁéØÂ¢ÉIPCÔºåÁΩëÁªúÊúçÂä°Âô®‰∏≠ÁöÑË∞ÉÂ∫¶Á®ãÂ∫è‰ª£Ë°®Áî®Êà∑Ë∞ÉÁî®lwIPÊèê‰æõÁöÑÁõ∏Â∫îBSDÂ•óÊé•Â≠óÊé•Âè£ÂäüËÉΩ„ÄÇÊàë‰ª¨Êù•ÁÆÄÂçïÁúãÁúãËøô‰∫õ‰∏úË•ø„ÄÇÂ§ßÈÉ®ÂàÜÈÉΩÊòØ‰∏ÄÊ†∑ÁöÑÔºåÊàë‰ª¨Â∞±ÁúãÁúãÂ∞±Ë°å„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839404142434445// Virtual address at which to receive page mappings containing client requests.#define REQVA 0x0ffff000union Nsipc nsipcbuf __attribute__((aligned(PGSIZE)));// Send an IP request to the network server, and wait for a reply.// The request body should be in nsipcbuf, and parts of the response// may be written back to nsipcbuf.// type: request code, passed as the simple integer IPC value.// Returns 0 if successful, &lt; 0 on failure.static intnsipc(unsigned type) //Âíå Êñá‰ª∂ÂèëÈÄÅ‰∏ÄÊ®°‰∏ÄÊ†∑ÔºåËá™Â∑±ÁúãÁúã&#123; static envid_t nsenv; if (nsenv == 0) nsenv = ipc_find_env(ENV_TYPE_NS); static_assert(sizeof(nsipcbuf) == PGSIZE); if (debug) cprintf("[%08x] nsipc %d\n", thisenv-&gt;env_id, type); ipc_send(nsenv, type, &amp;nsipcbuf, PTE_P|PTE_W|PTE_U); return ipc_recv(NULL, NULL, NULL);&#125;/*struct sockaddr &#123; u8_t sa_len; u8_t sa_family; char sa_data[14];&#125;;*/intnsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen) //Êé•ÂèóÂáΩÊï∞&#123; int r; nsipcbuf.accept.req_s = s; nsipcbuf.accept.req_addrlen = *addrlen; if ((r = nsipc(NSREQ_ACCEPT)) &gt;= 0) &#123; struct Nsret_accept *ret = &amp;nsipcbuf.acceptRet; memmove(addr, &amp;ret-&gt;ret_addr, ret-&gt;ret_addrlen); *addrlen = ret-&gt;ret_addrlen; &#125; return r;&#125; ÂÜçÁúãÁúãinit.cÔºåÂ§ö‰∫ÜËøô‰πàÂá†Ë°åÔºåÁúãÊû∂ÂäøÊòØÂàõÂª∫‰∫Ü‰∏Ä‰∏™ÁΩëÁªúÊúçÂä°Âô®„ÄÇ1234#if !defined(TEST_NO_NS) // Start ns. ENV_CREATE(net_ns, ENV_TYPE_NS);#endif ‰∏çÂá∫ÊÑèÂ§ñÊàë‰ª¨Âú®net/serv.cÊàêÂäüÊâæÂà∞‰∫Üumian12345678910111213141516171819202122232425262728293031323334353637383940414243voidumain(int argc, char **argv)&#123; envid_t ns_envid = sys_getenvid(); binaryname = "ns"; // fork off the timer thread which will send us periodic messages timer_envid = fork();//ÂàõÂª∫ÂÆöÊó∂Âô® if (timer_envid &lt; 0) panic("error forking"); else if (timer_envid == 0) &#123; timer(ns_envid, TIMER_INTERVAL); return; &#125; // fork off the input thread which will poll the NIC driver for input // packets input_envid = fork();//ËæìÂÖ•ÁéØÂ¢É if (input_envid &lt; 0) panic("error forking"); else if (input_envid == 0) &#123; input(ns_envid); return; &#125; // fork off the output thread that will send the packets to the NIC // driver output_envid = fork();//ËæìÂá∫ÁéØÂ¢É if (output_envid &lt; 0) panic("error forking"); else if (output_envid == 0) &#123; output(ns_envid); return; &#125; // lwIP requires a user threading library; start the library and jump // into a thread to continue initialization. thread_init();//Á∫øÁ®ãÂàùÂßãÂåñ //ÂÅöÂÆûÁé∞ÂºÄÂßã‰πãÂâçÂõûÊù•Â•ΩÂ•ΩÂàÜÊûê‰∏Ä‰∏ã thread_create(0, "main", tmain, 0);//Á∫øÁ®ãÂàõÂª∫ thread_yield();//Á∫øÁ®ãË∞ÉÂ∫¶ÔºüÔºüÔºü // never coming here!&#125; Â∏∏ËßÑÁî®Êà∑ÁéØÂ¢É‰∏ç‰ºönsipc_*Áõ¥Êé•‰ΩøÁî®ÂëºÂè´„ÄÇÁõ∏ÂèçÔºåÂÆÉ‰ª¨‰ΩøÁî®lib/ sockets.c‰∏≠ÁöÑÂáΩÊï∞ÔºåËØ•ÂáΩÊï∞Êèê‰æõ‰∫ÜÂü∫‰∫éÊñá‰ª∂ÊèèËø∞Á¨¶ÁöÑÂ•óÊé•Â≠óAPI„ÄÇÂõ†Ê≠§ÔºåÁî®Êà∑ÁéØÂ¢ÉÈÄöËøáÊñá‰ª∂ÊèèËø∞Á¨¶ÂºïÁî®Â•óÊé•Â≠óÔºåÂ∞±ÂÉèÂÆÉ‰ª¨ÂºïÁî®Á£ÅÁõòÊñá‰ª∂‰∏ÄÊ†∑„ÄÇÂ§ö‰∏™Êìç‰ΩúÔºàconnectÔºåacceptÁ≠âÔºâÁâπÂÆö‰∫éÊèíÂ∫ßÔºå‰ΩÜÊòØreadÔºåwriteÂíå closeÁªèËøáÂú®Ê≠£Â∏∏Êñá‰ª∂ÊèèËø∞Á¨¶ËÆæÂ§áÂàÜÊ¥æ‰ª£Á†Ålib/fd.c„ÄÇÂ∞±ÂÉèÊñá‰ª∂ÊúçÂä°Âô®‰∏∫ÊâÄÊúâÊâìÂºÄÁöÑÊñá‰ª∂Áª¥Êä§ÂÜÖÈÉ®ÂîØ‰∏ÄIDÁöÑÊñπÂºè‰∏ÄÊ†∑ÔºålwIPËøò‰ºö‰∏∫ÊâÄÊúâÊâìÂºÄÁöÑÂ•óÊé•Â≠óÁîüÊàêÂîØ‰∏ÄÁöÑID„ÄÇÂú®Êñá‰ª∂ÊúçÂä°Âô®ÂíåÁΩëÁªúÊúçÂä°Âô®‰∏≠ÔºåÊàë‰ª¨ÈÉΩ‰ΩøÁî®Â≠òÂÇ®Âú®ÂÖ∂‰∏≠ÁöÑ‰ø°ÊÅØÂ∞Üstruct FdÊØè‰∏™ÁéØÂ¢ÉÁöÑÊñá‰ª∂ÊèèËø∞Á¨¶Êò†Â∞ÑÂà∞Ëøô‰∫õÂîØ‰∏ÄÁöÑIDÁ©∫Èó¥„ÄÇ Êàë‰ª¨ÂéªÁúãÁúãlib/sockets.cÂíåÂâçÈù¢ÁöÑÊñá‰ª∂ÊúçÂä°Ë∞ÉÁî®ÁöÑÊé•Âè£‰πüÊòØ‰∏ÄÊ†∑ÁöÑ„ÄÇ Âç≥‰ΩøÊñá‰ª∂ÊúçÂä°Âô®ÂíåÁΩëÁªúÊúçÂä°Âô®ÁöÑIPCË∞ÉÂ∫¶Á®ãÂ∫èÁúãËµ∑Êù•‰ºº‰πéÁõ∏ÂêåÔºå‰πüÂ≠òÂú®ÂÖ≥ÈîÆÂå∫Âà´„ÄÇBSDÂ•óÊé•Â≠óË∞ÉÁî®like acceptÂíårecvÂèØ‰ª•Êó†ÈôêÊúüÈòªÂ°û„ÄÇÂ¶ÇÊûúË∞ÉÂ∫¶Á®ãÂ∫èË¶ÅËÆ©lwIPÊâßË°åËøô‰∫õÈòªÂ°ûË∞ÉÁî®‰πã‰∏ÄÔºåÂàôË∞ÉÂ∫¶Á®ãÂ∫è‰πüÂ∞ÜÈòªÂ°ûÔºåÂπ∂‰∏îÊï¥‰∏™Á≥ªÁªü‰∏ÄÊ¨°Âè™ËÉΩÊúâ‰∏Ä‰∏™Êú™ÂÆåÊàêÁöÑÁΩëÁªúË∞ÉÁî®„ÄÇÁî±‰∫éËøôÊòØ‰∏çÂèØÊé•ÂèóÁöÑÔºåÂõ†Ê≠§ÁΩëÁªúÊúçÂä°Âô®‰ΩøÁî®Áî®Êà∑Á∫ßÁ∫øÁ®ãÊù•ÈÅøÂÖçÈòªÂ°ûÊï¥‰∏™ÊúçÂä°Âô®ÁéØÂ¢É„ÄÇÂØπ‰∫éÊØè‰∏™‰º†ÂÖ•ÁöÑIPCÊ∂àÊÅØÔºåË∞ÉÂ∫¶Á®ãÂ∫èÈÉΩ‰ºöÂàõÂª∫‰∏Ä‰∏™Á∫øÁ®ãÂπ∂Âú®Êñ∞ÂàõÂª∫ÁöÑÁ∫øÁ®ã‰∏≠Â§ÑÁêÜËØ∑Ê±Ç„ÄÇÂ¶ÇÊûúÁ∫øÁ®ãÈòªÂ°ûÔºåÂàôÂè™ÊúâËØ•Á∫øÁ®ãËøõÂÖ•Áù°Áú†Áä∂ÊÄÅÔºåËÄåÂÖ∂‰ªñÁ∫øÁ®ãÁªßÁª≠ËøêË°å„ÄÇ Èô§‰∫ÜÊ†∏ÂøÉÁΩëÁªúÁéØÂ¢ÉÂ§ñÔºåËøòÊúâ‰∏â‰∏™Â∏ÆÂä©Á®ãÂ∫èÁéØÂ¢É„ÄÇÈô§‰∫ÜÊé•ÂèóÊù•Ëá™Áî®Êà∑Â∫îÁî®Á®ãÂ∫èÁöÑÊ∂àÊÅØÂ§ñÔºåÊ†∏ÂøÉÁΩëÁªúÁéØÂ¢ÉÁöÑË∞ÉÂ∫¶Á®ãÂ∫èËøòÊé•ÂèóÊù•Ëá™ËæìÂÖ•ÂíåËÆ°Êó∂Âô®ÁéØÂ¢ÉÁöÑÊ∂àÊÅØ„ÄÇÊ†∏ÂøÉÊúçÂä°Âô®ÁéØÂ¢ÉÔºåÊú¨Ë¥®‰∏äÂ∞±ÊòØ‰∏Ä‰∏™Êñá‰ª∂ÊúçÂä°Âô®Ôºå‰ªñË¥üË¥£ÂíåÈ´òÂ±ÇÁöÑÊï∞ÊçÆ‰∫§Êç¢ÔºåÊØîÂ¶ÇËØ¥ÔºåhttpË¶ÅÁî®socket.c,Â∞±Ë∞ÉÁî®socket.cÈáåÈù¢ÁöÑ‰∏Ä‰∏™Êìç‰ΩúÔºåÁÑ∂ÂêéËøõË°åËΩ¨Âèë‰º†Âà∞ËæìÂÖ•/ËæìÂá∫ÁéØÂ¢É,‰ªñÂú®Âú®E1000Êù•ËøõË°åÁ°¨‰ª∂Êìç‰Ωú„ÄÇ The Output Environment‰∏∫Áî®Êà∑ÁéØÂ¢ÉÂ•óÊé•Â≠óË∞ÉÁî®Êèê‰æõÊúçÂä°Êó∂ÔºålwIPÂ∞ÜÁîüÊàêÊï∞ÊçÆÂåÖ‰æõÁΩëÂç°‰º†Ëæì„ÄÇLwIPÂ∞Ü‰ΩøÁî®NSREQ_OUTPUTIPCÊ∂àÊÅØÂ∞ÜÊØè‰∏™Ë¶ÅÂèëÈÄÅÁöÑÊï∞ÊçÆÂåÖÂèëÈÄÅÂà∞ËæìÂá∫Â∏ÆÂä©Á®ãÂ∫èÁéØÂ¢ÉÔºåÂπ∂Â∞ÜËØ•Êï∞ÊçÆÂåÖÈôÑÂä†Âú®IPCÊ∂àÊÅØÁöÑpageÂèÇÊï∞‰∏≠„ÄÇËæìÂá∫ÁéØÂ¢ÉË¥üË¥£Êé•ÂèóËøô‰∫õÊ∂àÊÅØÔºåÂπ∂ÈÄöËøáÂç≥Â∞ÜÂàõÂª∫ÁöÑÁ≥ªÁªüË∞ÉÁî®Êé•Âè£Â∞ÜÊï∞ÊçÆÂåÖËΩ¨ÂèëÂà∞ËÆæÂ§áÈ©±Âä®Á®ãÂ∫è„ÄÇ The Input EnvironmentÁΩëÂç°Êî∂Âà∞ÁöÑÊï∞ÊçÆÂåÖÈúÄË¶ÅÊ≥®ÂÖ•lwIP„ÄÇÂØπ‰∫éËÆæÂ§áÈ©±Âä®Á®ãÂ∫èÊî∂Âà∞ÁöÑÊØè‰∏™Êï∞ÊçÆÂåÖÔºåËæìÂÖ•ÁéØÂ¢ÉÔºà‰ΩøÁî®ÊÇ®Â∞ÜÂÆûÁé∞ÁöÑÂÜÖÊ†∏Á≥ªÁªüË∞ÉÁî®ÔºâÂ∞ÜÊï∞ÊçÆÂåÖÊãâÂá∫ÂÜÖÊ†∏Á©∫Èó¥ÔºåÁÑ∂Âêé‰ΩøÁî®NSREQ_INPUTIPCÊ∂àÊÅØÂ∞ÜÊï∞ÊçÆÂåÖÂèëÈÄÅÂà∞Ê†∏ÂøÉÊúçÂä°Âô®ÁéØÂ¢É„ÄÇ Êï∞ÊçÆÂåÖËæìÂÖ•ÂäüËÉΩ‰∏éÊ†∏ÂøÉÁΩëÁªúÁéØÂ¢ÉÂàÜÂºÄÔºåÂõ†‰∏∫JOS‰ΩøÂÖ∂Èöæ‰ª•ÂêåÊó∂Êé•ÂèóIPCÊ∂àÊÅØ‰ª•ÂèäËΩÆËØ¢ÊàñÁ≠âÂæÖÊù•Ëá™ËÆæÂ§áÈ©±Âä®Á®ãÂ∫èÁöÑÊï∞ÊçÆÂåÖ„ÄÇÊàë‰ª¨select Âú®JOS‰∏≠Ê≤°ÊúâÁ≥ªÁªüË∞ÉÁî®ÔºåËØ•Ë∞ÉÁî®ÂÖÅËÆ∏ÁéØÂ¢ÉÁõëËßÜÂ§ö‰∏™ËæìÂÖ•Ê∫ê‰ª•Ê†áËØÜÂáÜÂ§áÂ•ΩÂ§ÑÁêÜÂì™‰∫õËæìÂÖ•„ÄÇ Â¶ÇÊûú‰Ω†ÁúãÁúãnet/input.cÂíånet/output.c‰Ω†‰ºöÁúãÂà∞ÔºåÈÉΩÈúÄË¶ÅÊâßË°å„ÄÇËøô‰∏ªË¶ÅÊòØÂõ†‰∏∫ÂÆûÁé∞ÂèñÂÜ≥‰∫éÊÇ®ÁöÑÁ≥ªÁªüË∞ÉÁî®Êé•Âè£„ÄÇÂú®ÂÆûÁé∞È©±Âä®Á®ãÂ∫èÂíåÁ≥ªÁªüË∞ÉÁî®Êé•Âè£‰πãÂêéÔºåÂ∞Ü‰∏∫‰∏§‰∏™Â∏ÆÂä©Á®ãÂ∫èÁéØÂ¢ÉÁºñÂÜô‰ª£Á†Å„ÄÇ The Timer EnvironmentËÆ°Êó∂Âô®ÁéØÂ¢É‰ºöÂÆöÊúüÂêëNSREQ_TIMERÊ†∏ÂøÉÁΩëÁªúÊúçÂä°Âô®ÂèëÈÄÅÊ∂àÊÅØÁ±ªÂûãÔºåÈÄöÁü•ÂÖ∂ËÆ°Êó∂Âô®Â∑≤ËøáÊúü„ÄÇlwIP‰ΩøÁî®Ê≠§Á∫øÁ®ãÁöÑËÆ°Êó∂Âô®Ê∂àÊÅØÊù•ÂÆûÁé∞ÂêÑÁßçÁΩëÁªúË∂ÖÊó∂„ÄÇ ÈÄöËøáËøô‰∫õÊàë‰ª¨Â§ßËá¥Áü•ÈÅìËøô‰∏™ÁΩëÁªúÁöÑÊµÅÁ®ã‰∫ÜÔºåÂÆûÈôÖ‰∏äÊ†∏ÂøÉÊúçÂä°Âô®ÂíåÊñá‰ª∂ÊúçÂä°Âô®ÊòØ‰∏ÄÊ®°‰∏ÄÊ†∑ÁöÑÔºåËÆ©Êàë‰ª¨ÂÜçÂÅö‰∏ÄÊ¨°ÂÆûÈôÖ‰∏ä‰πüÂ∞±ÊòØÊää‰∏äÊ¨°ÁöÑ‰ª£Á†ÅÂú®Áúã‰∏ÄÈÅç„ÄÇËá≥‰∫éËæìÂá∫ÁéØÂ¢ÉÔºåËæìÂÖ•ÁéØÂ¢ÉÂíåÊó∂ÈíüÁéØÂ¢ÉÔºåÂ∞±ÊòØËÆ©Êàë‰ª¨ÂÆûÁé∞ÁöÑ‰∏úË•ø„ÄÇ ÂâçÁΩÆ‰ª£Á†ÅÂàÜÊûêÂà∞Ëøô‰∏™Âú∞ÊñπÔºåÊàë‰ª¨Â∑≤ÁªèÁü•ÈÅì‰∫ÜÂü∫Êú¨ÁöÑÁªìÊûÑÔºå‰ΩÜÊòØÊàë‰ª¨ËøòÊòØÂØπ‰ª£Á†ÅÊ≤°Âï•‰∫ÜËß£„ÄÇÊâÄ‰ª•Êàë‰ª¨Êù•ÁúãÁúãÂ§öÁöÑ‰ª£Á†ÅÂÅö‰∫Ü‰ªÄ‰πà„ÄÇ‰∏ÄÂ¶ÇÊó¢ÂæÄÔºå‰∏ÄÂàáÁöÑËµ∑ÁÇπÔºåËÇØÂÆöinit,ÂâçÈù¢Êàë‰ª¨Â∑≤ÁªèÁúãËøá‰∏ÄÁÇπ‰∫Ü„ÄÇ12345678// Lab 6 hardware initialization functions//Â§ö‰∫ÜËøô‰∫õ‰∏úË•øÔºåÁúãÊ≥®Èáä‰∫ãÁ°¨‰ª∂ÂàùÂßãÂåñtime_init(); //Ëøô‰∏™ÂêéÈù¢Á¨¨‰∏Ä‰∏™ÂÆûÈ™åÂ∞±‰ºöËÆ≤ÊòØ‰ªÄ‰πàÔºåÊòØÁªôÂÜÖÊ†∏Ê∑ªÂä†Êó∂ÈíüÁöÑÊ¶ÇÂøµÁî®ÁöÑpci_init(); //Ëøô‰∏™ÊòØ PCIÂàùÂßãÂåñÔºå‰πüÂ∞±ÊòØÊêúÁ¥¢ÊâÄÊúâ Áî®PCIËøûÊé•ÁöÑÁ°¨‰ª∂#if !defined(TEST_NO_NS) // Start ns. ENV_CREATE(net_ns, ENV_TYPE_NS);//Ëøô‰∏™ËØ¥Ëøá‰∫ÜÂ∞±ÊòØÊ†∏ÂøÉÁéØÂ¢ÉÂêØÂä®ÔºåËÄå‰∏îÈÄöËøáËøô‰∏™fork Èô§‰∫Ü ËæìÂÖ•/ËæìÂá∫/Êó∂ÈíüÁéØÂ¢É#endif Êàë‰ª¨Áü•ÈÅìËøô‰∫õ‰πãÂêéÔºåÊàë‰ª¨ÂÜçÂéªÁúãÁúãnetÈáåÈù¢ÁöÑ‰∏úË•ø.ÊàëÈù†‰∏ÄËøõÂéªÁúãÈáåÈù¢ÁöÑlwipÁõÆÂΩïÔºåÊàëÈù†ÈÇ£‰πàÂ§ö‰∏úË•øÔºåÁúã‰∏™È¨ºÔºåÂëäËæû„ÄÇÊàë‰ª¨ËøòÊòØÁªßÁª≠ÁúãÁúãserv.c,Ëøô‰∏™input.cÂíåoutput.c,ÊòØËæìÂÖ•ËæìÂá∫ÔºåÂêéÈù¢‰∏ªË¶ÅË¶ÅÂÅöÁöÑ„ÄÇ‰∏ÄÂºÄÂßãÊàë‰ª¨Â∑≤ÁªèÁúã‰∫Ü‰∏ÄÈÉ®ÂàÜÔºåÊàë‰ª¨Áõ¥Êé•ÁúãÁúãËøô‰∏™Á∫øÁ®ã„ÄÇ123thread_init();thread_create(0, "main", tmain, 0);thread_yield(); 1234567891011121314151617181920212223242526272829303132333435//lwpic/jos/thread.cvoidthread_init(void) &#123; threadq_init(&amp;thread_queue);//ËøõÂéªÁúãËøô‰∏™ÂáΩÊï∞ max_tid = 0;&#125;//lwpic/jos/threadq.hstatic inline void threadq_init(struct thread_queue *tq)&#123; tq-&gt;tq_first = 0; tq-&gt;tq_last = 0;&#125;struct thread_context;//‰∏Ä‰∏™Ëøô‰∏™Ë°®Á§∫‰∏Ä‰∏™ËøõÁ®ãstruct thread_queue //‰∏Ä‰∏™Á∫øÁ®ãÊ±†ÔºåÊàñËÆ∏Â∫îËØ•Âè´Á∫øÁ®ãÈòüÂàó&#123; struct thread_context *tq_first; struct thread_context *tq_last;&#125;;struct thread_context &#123; //Á∫øÁ®ãÁªìÊûÑÈ¢ò ‰πüÂ∞±ÊòØTCB thread_id_t tc_tid; //Á∫øÁ®ãID void *tc_stack_bottom;//Á∫øÁ®ãÊ†à char tc_name[name_size];//Á∫øÁ®ãÂêç void (*tc_entry)(uint32_t);//Á∫øÁ®ãÊåá‰ª§Âú∞ÂùÄ ÔºåÂÆûÁé∞ËøáÁ∫øÁ®ãËøô‰∏™ÂæàÂ•ΩÁêÜËß£ uint32_t tc_arg;//ÂèÇÊï∞ struct jos_jmp_buf tc_jb;//Ëøô‰∏™ÂèØ‰ª•ÁÆÄÂçïÁêÜËß£‰∏∫ ‰øùÂ≠òCPUÁöÑÂÜÖÂÆπ volatile uint32_t *tc_wait_addr; volatile char tc_wakeup; void (*tc_onhalt[THREAD_NUM_ONHALT])(thread_id_t); int tc_nonhalt; struct thread_context *tc_queue_link;&#125;; ÁÑ∂ÂêéÊàë‰ª¨ËøêË°å‰∫ÜÁ∫øÁ®ãÂàõÂª∫1234567891011121314151617181920212223242526272829303132333435intthread_create(thread_id_t *tid, const char *name, void (*entry)(uint32_t), uint32_t arg) &#123; struct thread_context *tc = malloc(sizeof(struct thread_context));//ÂàÜÈÖç‰∏Ä‰∏™Á©∫Èó¥ if (!tc) return -E_NO_MEM; memset(tc, 0, sizeof(struct thread_context)); thread_set_name(tc, name);//Ëøô‰∏™‰∏çÁî®Â§öËØ¥‰∫Ü tc-&gt;tc_tid = alloc_tid();//Ëá™Â∑±Áúã tc-&gt;tc_stack_bottom = malloc(stack_size);//ÊØè‰∏™Á∫øÁ®ãÂ∫îËØ•ÊúâÁã¨Á´ãÁöÑÊ†àÔºå‰ΩÜÊòØ‰∏Ä‰∏™ËøõÁ®ãÁöÑÁ∫øÁ®ãÂÜÖÂ≠òÊòØÂÖ±‰∫´ÁöÑÔºåÂõ†‰∏∫ÂÖ±Áî®‰∏Ä‰∏™È°µË°®„ÄÇ ÂæàÊòéÊòæÁöÑËÉΩÂ§üÁúãÂá∫Êù•ÔºåTCBÊ≤°ÊúâÈ°µË°®ÔºåÊâÄ‰ª•ÂÜÖÂ≠òÈÉΩÊòØÂÖ±‰∫´ÁöÑÔºåÊâÄ‰ª•ÁêÜËÆ∫‰∏äÊù•ËØ¥ÔºåÊòØÂèØ‰ª•Ë∑®Á∫øÁ®ãËÆøÈóÆÊ†àÁöÑ„ÄÇ if (!tc-&gt;tc_stack_bottom) &#123; free(tc); return -E_NO_MEM; &#125; void *stacktop = tc-&gt;tc_stack_bottom + stack_size; // Terminate stack unwinding stacktop = stacktop - 4; memset(stacktop, 0, 4); memset(&amp;tc-&gt;tc_jb, 0, sizeof(tc-&gt;tc_jb)); tc-&gt;tc_jb.jb_esp = (uint32_t)stacktop;//ÂàùÂßãÂåñÊ†àÈ°∂ tc-&gt;tc_jb.jb_eip = (uint32_t)&amp;thread_entry;//ÂàùÂßãÂåñÂÖ•Âè£ÔºåÂáΩÊï∞ÊåáÈíà tc-&gt;tc_entry = entry; tc-&gt;tc_arg = arg;//ÂèÇÊï∞ threadq_push(&amp;thread_queue, tc);//Âä†ÂÖ•Á∫øÁ®ãÈòüÂàó if (tid) *tid = tc-&gt;tc_tid; return 0;&#125; ÁÑ∂ÂêéË∞ÉÁî®‰∫ÜÁ∫øÁ®ãË∞ÉÂ∫¶1234567891011121314151617voidthread_yield(void) &#123; struct thread_context *next_tc = threadq_pop(&amp;thread_queue);//ÂºπÂá∫‰∫Ü‰∏Ä‰∏™Á∫øÁ®ã if (!next_tc) return; if (cur_tc) &#123; if (jos_setjmp(&amp;cur_tc-&gt;tc_jb) != 0) return; threadq_push(&amp;thread_queue, cur_tc);//‰øùÂ≠òÂΩìÂâçÁ∫øÁ®ã &#125; cur_tc = next_tc; jos_longjmp(&amp;cur_tc-&gt;tc_jb, 1);//Â∞Ü‰∏ã‰∏Ä‰∏™Á∫øÁ®ãÂØπÂ∫îÁöÑthread_contextÁªìÊûÑÁöÑtc_jbÂ≠óÊÆµÊÅ¢Â§çÂà∞CPUÁªßÁª≠ÊâßË°å&#125;//ÊâÄ‰ª•‰ªéËøô‰∏™Âú∞ÊñπÂ∞±Ë∑ëÂéª‰∫ÜËøêË°åÁ∫øÁ®ãmainÂáΩÊï∞‰∫Ü„ÄÇ 1234567static voidtmain(uint32_t arg) &#123; serve_init(inet_addr(IP), inet_addr(MASK), inet_addr(DEFAULT));//ÂàùÂßãÂåñ‰∫Ü‰∏ÄÁÇπ‰∏úË•ø serve();//ÁÑ∂ÂêéÂ∞±ÊòØËøô‰∏™ÊúçÂä°‰∫Ü&#125; serve()ÈáåÈù¢‰∏ªË¶ÅÊòØÂíåÂè¶Â§ñ‰∏§‰∏™ÁéØÂ¢ÉÈÄö‰ø°„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748voidserve(void) &#123; int32_t reqno; uint32_t whom; int i, perm; void *va; while (1) &#123; // ipc_recv will block the entire process, so we flush // all pending work from other threads. We limit the // number of yields in case there's a rogue thread. for (i = 0; thread_wakeups_pending() &amp;&amp; i &lt; 32; ++i) thread_yield(); perm = 0; va = get_buffer(); reqno = ipc_recv((int32_t *) &amp;whom, (void *) va, &amp;perm);//Âú®Ëøô‰∏™Âú∞ÊñπËøõË°åÈÄö‰ø° if (debug) &#123; cprintf("ns req %d from %08x\n", reqno, whom); &#125; // first take care of requests that do not contain an argument page if (reqno == NSREQ_TIMER) &#123;//Ëøô‰∏™Â∞±ÊòØÂ¶ÇÊûúÈÄö‰ø°Êù•Ëá™Êó∂Èíü process_timer(whom); put_buffer(va); continue; &#125; // All remaining requests must contain an argument page if (!(perm &amp; PTE_P)) &#123; cprintf("Invalid request from %08x: no argument page\n", whom); continue; // just leave it hanging... &#125; // Since some lwIP socket calls will block, create a thread and // process the rest of the request in the thread. struct st_args *args = malloc(sizeof(struct st_args)); if (!args) panic("could not allocate thread args structure"); args-&gt;reqno = reqno; args-&gt;whom = whom; args-&gt;req = va; thread_create(0, "serve_thread", serve_thread, (uint32_t)args);//Áªô‰ªñÂàõÂª∫‰∏Ä‰∏™Á∫øÁ®ãÂéªÂ§ÑÁêÜ„ÄÇ thread_yield(); // let the thread created run &#125;&#125; Âú®serve()ÁªèÂéÜ‰∫Ü‰∏ÄÂ§ßÂ†ÜÔºåÊúÄÁªàÂ§ÑÁêÜ‰∫ã‰ª∂ÁöÑÂáΩÊï∞ÊòØserve_thread‰∫Ü,ÂèØ‰ª•Âú®ÈáåÈù¢ÊòéÁ°ÆÁöÑÁúãÂá∫ÊòØÂï•„ÄÇ12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970static voidserve_thread(uint32_t a) &#123; struct st_args *args = (struct st_args *)a; union Nsipc *req = args-&gt;req; int r; switch (args-&gt;reqno) &#123; case NSREQ_ACCEPT: &#123; struct Nsret_accept ret; ret.ret_addrlen = req-&gt;accept.req_addrlen; r = lwip_accept(req-&gt;accept.req_s, &amp;ret.ret_addr, &amp;ret.ret_addrlen); memmove(req, &amp;ret, sizeof ret); break; &#125; case NSREQ_BIND: r = lwip_bind(req-&gt;bind.req_s, &amp;req-&gt;bind.req_name, req-&gt;bind.req_namelen); break; case NSREQ_SHUTDOWN: r = lwip_shutdown(req-&gt;shutdown.req_s, req-&gt;shutdown.req_how); break; case NSREQ_CLOSE: r = lwip_close(req-&gt;close.req_s); break; case NSREQ_CONNECT: r = lwip_connect(req-&gt;connect.req_s, &amp;req-&gt;connect.req_name, req-&gt;connect.req_namelen); break; case NSREQ_LISTEN: r = lwip_listen(req-&gt;listen.req_s, req-&gt;listen.req_backlog); break; case NSREQ_RECV: // Note that we read the request fields before we // overwrite it with the response data. r = lwip_recv(req-&gt;recv.req_s, req-&gt;recvRet.ret_buf, req-&gt;recv.req_len, req-&gt;recv.req_flags); break; case NSREQ_SEND: r = lwip_send(req-&gt;send.req_s, &amp;req-&gt;send.req_buf, req-&gt;send.req_size, req-&gt;send.req_flags); break; case NSREQ_SOCKET: r = lwip_socket(req-&gt;socket.req_domain, req-&gt;socket.req_type, req-&gt;socket.req_protocol); break; case NSREQ_INPUT: jif_input(&amp;nif, (void *)&amp;req-&gt;pkt); r = 0; break; default: cprintf("Invalid request code %d from %08x\n", args-&gt;whom, args-&gt;req); r = -E_INVAL; break; &#125; if (r == -1) &#123; char buf[100]; snprintf(buf, sizeof buf, "ns req type %d", args-&gt;reqno); perror(buf); &#125; if (args-&gt;reqno != NSREQ_INPUT) ipc_send(args-&gt;whom, r, 0, 0); put_buffer(args-&gt;req); sys_page_unmap(0, (void*) args-&gt;req); free(args);&#125; ÁÑ∂ÂêéÂ∞±‰ªéÂÖ∂‰∏≠Ë∞ÉÁî®‰∫ÜlwipÁöÑ‰∏Ä‰∫õÂáΩÊï∞,Ëøô‰∏™ÈáåÈù¢Êúâ‰∏Ä‰∏™socket.cÂíålib/socket.cÊúâÁÇπ‰∏ç‰∏ÄÊ†∑Ôºå‰πü‰∏çÁü•ÈÅìÊúâÂï•Âå∫Âà´Ôºå‰∏™‰∫∫ËßâÂæóÊòØlib/socket.cÊòØÁ≥ªÁªüÈáåÈù¢ÁöÑË∞ÉÁî®ÁªôÁî®Êà∑Áî®ÁöÑËøô‰∏™Êñá‰ª∂ÈáåÈù¢ÁöÑÂ∫îËØ•ÊòØËøõË°åÂ∫ïÂ±ÇË∞ÉÁî®ÁöÑ„ÄÇÂÖ∑‰ΩìÂ∞±‰∏çÂàÜÊûê‰∫ÜÔºåÊúâÂÖ¥Ë∂£ÁöÑËá™Â∑±ÂéªÁúãÁúã„ÄÇ ÂÖ∂‰ªñ‰∏â‰∏™ÁéØÂ¢ÉÂêéÈù¢ÂÜçÁúã„ÄÇ Part A: Initialization and transmitting packetsÊÇ®ÁöÑÂÜÖÊ†∏Ê≤°ÊúâÊó∂Èó¥Ê¶ÇÂøµÔºåÂõ†Ê≠§Êàë‰ª¨ÈúÄË¶ÅÊ∑ªÂä†ÂÆÉ„ÄÇÂΩìÂâçÔºåÁ°¨‰ª∂ÊØè10ÊØ´Áßí‰∫ßÁîü‰∏ÄÊ¨°Êó∂Èíü‰∏≠Êñ≠„ÄÇÂú®ÊØè‰∏™Êó∂Èíü‰∏≠Êñ≠Â§ÑÔºåÊàë‰ª¨ÈÉΩÂèØ‰ª•Â¢ûÂä†‰∏Ä‰∏™ÂèòÈáè‰ª•ÊåáÁ§∫Êó∂Èó¥ÊèêÂâç‰∫Ü10ms„ÄÇËøôÊòØÂú®kern/ time.c‰∏≠ÂÆûÁé∞ÁöÑÔºå‰ΩÜÂ∞öÊú™ÂÆåÂÖ®ÈõÜÊàêÂà∞ÊÇ®ÁöÑÂÜÖÊ†∏‰∏≠„ÄÇ‰∏çÁùÄÊÄ•ÂÅöÂÆûÈ™åÔºåÊàë‰ª¨ÂÖàÂéªÁúãÁúãkern/ time.c1234567891011121314151617181920212223242526#include &lt;kern/time.h&gt;#include &lt;inc/assert.h&gt;static unsigned int ticks;voidtime_init(void)//ÂàùÂßãÂåñÊó∂Èíü&#123; ticks = 0;&#125;// This should be called once per timer interrupt. A timer interrupt// fires every 10 ms.voidtime_tick(void)//Êó∂Èó¥Â¢ûÂä†&#123; ticks++; if (ticks * 10 &lt; ticks) panic("time_tick: time overflowed");&#125;unsigned inttime_msec(void)&#123; return ticks * 10;//ËøîÂõûÊó∂Èó¥&#125; Áúã‰∫ÜËøô‰∏™ÁªÉ‰π†1Â∞±ÁÆÄÂçï‰∫Ü„ÄÇÁªÉ‰π†1Â∞±ÊòØËÆ©Êàë‰ª¨Êää‰ªñÂä†ÂÖ•ÂÜÖÊ†∏„ÄÇÊàë‰ª¨Â∑≤ÁªèÂú®ÂÜÖÊ†∏ÈáåÈù¢ÂàùÂßãÂåñ‰∫ÜÔºåÁé∞Âú®Êàë‰ª¨ÈúÄË¶ÅÊó∂ÈíüË∑≥Âä®„ÄÇÈÇ£‰πà‰ªÄ‰πàÊó∂ÂÄôÊó∂ÈíüÂ¢ûÂä†Âë¢„ÄÇÊàë‰ª¨Â∑≤ÁªèÂÆûÁé∞‰∫ÜÊó∂Èíü‰∏≠Êñ≠ÔºåÊâÄ‰ª•Êàë‰ª¨Âú®Ëøô‰∏™Êó∂ÂÄôË∞ÉÁî®Â∞±Ë°å‰∫Ü„ÄÇÂè¶Â§ñ‰∏Ä‰∏™Ê∑ªÂä†‰∏Ä‰∏™Á≥ªÁªüË∞ÉÁî®Ëé∑ÂèñÊó∂ÈíüÂ∞±Ë°å‰∫Ü„ÄÇ1234567891011121314151617181920 case IRQ_OFFSET + IRQ_TIMER:&#123; lapic_eoi(); time_tick();//Êó∂Èíü‰∏≠Êñ≠ Êó∂ÈíüÂ¢ûÂä† sched_yield(); break; &#125; // Return the current time.static intsys_time_msec(void)//Ëé∑ÂèñÊó∂Èíü&#123; // LAB 6: Your code here. //panic("sys_time_msec not implemented"); return time_msec();&#125;//Ëøô‰∏™ÁªùÂØπ‰∏çË¶ÅÂÆå‰∫ÜÂÜçsyscall()ÈáåÈù¢Ê∑ªÂä† case SYS_time_msec: return sys_time_msec(); Êàë‰ª¨Áé∞Âú®ÂèØ‰ª•ÂÆûÁé∞ÊòØÊó∂ÈíüÁéØÂ¢ÉÔºåÊàë‰ª¨ÂéªÁúãÁúãnet/time.c12345678910111213141516171819202122232425262728293031#include "ns.h"voidtimer(envid_t ns_envid, uint32_t initial_to) &#123; int r; uint32_t stop = sys_time_msec() + initial_to; binaryname = "ns_timer"; while (1) &#123; while((r = sys_time_msec()) &lt; stop &amp;&amp; r &gt;= 0) &#123;//Ê≤°Âà∞Âà∞Êó∂Èó¥ sys_yield(); &#125; if (r &lt; 0) panic("sys_time_msec: %e", r); ipc_send(ns_envid, NSREQ_TIMER, 0, 0);//Âà∞‰∫ÜÊó∂ÈíüÂ∞±ÁªôÊ†∏ÂøÉÊúçÂä°Á®ãÂ∫èÂèë‰∫Ü‰∏Ä‰∏™‰ø°ÊÅØ while (1) &#123; uint32_t to, whom; to = ipc_recv((int32_t *) &amp;whom, 0, 0); if (whom != ns_envid) &#123; cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom); continue; &#125; stop = sys_time_msec() + to;//Êó∂ÈíüÊîπÂèò break; &#125; &#125;&#125; The Network Interface CardÁºñÂÜôÈ©±Âä®Á®ãÂ∫èÈúÄË¶ÅÊ∑±ÂÖ•‰∫ÜËß£Á°¨‰ª∂ÂíåÊèê‰æõÁªôËΩØ‰ª∂ÁöÑÊé•Âè£„ÄÇËØ•ÂÆûÈ™åÊñáÊú¨Â∞ÜÊèê‰æõÊúâÂÖ≥Â¶Ç‰Ωï‰∏éE1000ËøõË°å‰∫§‰∫íÁöÑÈ´òÁ∫ßÊ¶ÇËø∞Ôºå‰ΩÜÊòØÊÇ®Âú®ÁºñÂÜôÈ©±Âä®Á®ãÂ∫èÊó∂ÈúÄË¶ÅÂÖÖÂàÜÂà©Áî®IntelÁöÑÊâãÂÜå„ÄÇÁªÉ‰π†2ËÆ©ÊàëÈó®ÁúãÁúãÊâãÂÜå„ÄÇÂõ†‰∏∫ÊòØÂÖ®Ëã±ÊñáÁöÑÂèà‰∏çËÉΩÁøªËØëÊâÄ‰ª•Ê≤°Áúã„ÄÇÂêéÈù¢ÂëäËØâÊàë‰ª¨ÈúÄË¶Å‰ªÄ‰πàÊàë‰ª¨ÂéªÁúã‰ªÄ‰πà„ÄÇ ÂêéÈù¢ÊâçÊòØÁúüÁöÑÈ≠îÈ¨º„ÄÇ PCI InterfaceE1000ÊòØPCIËÆæÂ§áÔºåËøôÊÑèÂë≥ÁùÄÂÆÉÂ∑≤ÊèíÂÖ•‰∏ªÊùø‰∏äÁöÑPCIÊÄªÁ∫ø„ÄÇPCIÊÄªÁ∫øÂÖ∑ÊúâÂú∞ÂùÄÔºåÊï∞ÊçÆÂíå‰∏≠Êñ≠Á∫øÔºåÂπ∂ÂÖÅËÆ∏CPU‰∏éPCIËÆæÂ§áËøõË°åÈÄö‰ø°ÔºåÂπ∂‰∏îPCIËÆæÂ§áÂèØ‰ª•ËØªÂÜôÂ≠òÂÇ®Âô®„ÄÇÂú®‰ΩøÁî®PCIËÆæÂ§á‰πãÂâçÔºåÈúÄË¶ÅÂÖàÂØπÂÖ∂ËøõË°åÂèëÁé∞ÂíåÂàùÂßãÂåñ„ÄÇÂèëÁé∞ÊòØÈÅçÂéÜPCIÊÄªÁ∫ø‰ª•Êü•ÊâæËøûÊé•ÁöÑËÆæÂ§áÁöÑËøáÁ®ã„ÄÇÂàùÂßãÂåñÊòØÂàÜÈÖçI/OÂíåÂÜÖÂ≠òÁ©∫Èó¥‰ª•ÂèäÂçèÂïÜËÆæÂ§áË¶Å‰ΩøÁî®ÁöÑIRQÁ∫øÁöÑËøáÁ®ã„ÄÇ Êàë‰ª¨Âú®kern/pci.c‰∏≠‰∏∫ÊÇ®Êèê‰æõ‰∫ÜPCI‰ª£Á†Å„ÄÇË¶ÅÂú®ÂºïÂØºËøáÁ®ã‰∏≠ÊâßË°åPCIÂàùÂßãÂåñÔºåPCI‰ª£Á†ÅÂ∞ÜÈÅçÂéÜPCIÊÄªÁ∫ø‰ª•Êü•ÊâæËÆæÂ§á„ÄÇÊâæÂà∞ËÆæÂ§áÂêéÔºåÂÆÉÂ∞ÜËØªÂèñÂÖ∂‰æõÂ∫îÂïÜIDÂíåËÆæÂ§áIDÔºåÂπ∂Â∞ÜËøô‰∏§‰∏™ÂÄºÁî®‰ΩúÊêúÁ¥¢pci_attach_vendorÈòµÂàóÁöÑÈîÆ„ÄÇËØ•Êï∞ÁªÑÁî±‰ª•‰∏ãstruct pci_driverÊù°ÁõÆÁªÑÊàê Ôºö1234struct pci_driver &#123; uint32_t key1, key2; int (*attachfn) (struct pci_func *pcif);&#125;; Â¶ÇÊûúÂèëÁé∞ÁöÑËÆæÂ§áÁöÑ‰æõÂ∫îÂïÜIDÂíåËÆæÂ§áID‰∏éÈòµÂàó‰∏≠ÁöÑÊù°ÁõÆÂåπÈÖçÔºåÂàôPCI‰ª£Á†ÅÂ∞ÜË∞ÉÁî®ËØ•Êù°ÁõÆÁöÑattachfnÊù•ÊâßË°åËÆæÂ§áÂàùÂßãÂåñ„ÄÇÔºàËÆæÂ§á‰πüÂèØ‰ª•ÈÄöËøáÁ±ªÊù•Ê†áËØÜÔºåËøôÊòØkern/pci.c‰∏≠ÂÖ∂‰ªñÈ©±Âä®Á®ãÂ∫èË°®ÁöÑ‰ΩúÁî®„ÄÇÔºâ AttachÂáΩÊï∞ÈÄöËøáPCIÂáΩÊï∞ËøõË°åÂàùÂßãÂåñ„ÄÇÂ∞ΩÁÆ°E1000‰ªÖÊèê‰æõ‰∏ÄÁßçÂäüËÉΩÔºå‰ΩÜPCIÂç°ÂèØ‰ª•Êèê‰æõÂ§öÁßçÂäüËÉΩ„ÄÇËøôÊòØÊàë‰ª¨Âú®JOS‰∏≠Ë°®Á§∫PCIÂäüËÉΩÁöÑÊñπÂºèÔºö12345678910111213struct pci_func &#123; struct pci_bus *bus; uint32_t dev; uint32_t func; uint32_t dev_id; uint32_t dev_class; uint32_t reg_base[6]; uint32_t reg_size[6]; uint8_t irq_line;&#125;; ‰ª•‰∏äÁªìÊûÑÂèçÊò†‰∫ÜÂºÄÂèë‰∫∫ÂëòÊâãÂÜåÁ¨¨4.1ËäÇË°®4-1‰∏≠ÁöÑÊüê‰∫õÊù°ÁõÆ„ÄÇ(Â§ßÂÆ∂ÂèØ‰ª•ÂéªÁúãÁúã)Âêé‰∏â‰∏™Êù°ÁõÆ struct pci_funcÂØπÊàë‰ª¨ÁâπÂà´ÊúâÊÑè‰πâÔºåÂõ†‰∏∫ÂÆÉ‰ª¨ËÆ∞ÂΩï‰∫ÜËÆæÂ§áÁöÑÂçèÂïÜÂÜÖÂ≠òÔºåI/OÂíå‰∏≠Êñ≠ËµÑÊ∫ê„ÄÇÂú®reg_base‰∏éreg_sizeÈòµÂàóÂåÖÂê´Â§öËææÂÖ≠‰∏™Âü∫Âú∞ÂùÄÂØÑÂ≠òÂô®ÊàñÊù°‰ø°ÊÅØ„ÄÇreg_baseÂ≠òÂÇ®Áî®‰∫éÂÜÖÂ≠òÊò†Â∞ÑÁöÑI/OÂå∫ÂüüÔºàÊàñÁî®‰∫éI/OÁ´ØÂè£ËµÑÊ∫êÁöÑÂü∫Êú¨I/OÁ´ØÂè£ÔºâÁöÑÂü∫Êú¨ÂÜÖÂ≠òÂú∞ÂùÄÔºå reg_sizeÂåÖÂê´Êù•Ëá™ÁöÑÁõ∏Â∫îÂü∫Êú¨ÂÄºÁöÑÂ≠óËäÇÂ§ßÂ∞èÊàñI/OÁ´ØÂè£Êï∞reg_baseÔºåÂπ∂irq_lineÂåÖÂê´ÂàÜÈÖçÁªôËÆæÂ§áÁöÑIRQÁ∫øË∑ØÁî®‰∫é‰∏≠Êñ≠„ÄÇE1000 BARÁöÑÂÖ∑‰ΩìÂê´‰πâÂú®Ë°®4-2ÁöÑÂêéÂçäÈÉ®ÂàÜÁªôÂá∫„ÄÇ Ë∞ÉÁî®ËÆæÂ§áÁöÑÈôÑÂä†ÂäüËÉΩÊó∂ÔºåÂ∑≤ÊâæÂà∞ËØ•ËÆæÂ§á‰ΩÜÂ∞öÊú™ÂêØÁî®„ÄÇËøôÊÑèÂë≥ÁùÄPCI‰ª£Á†ÅÂ∞öÊú™Á°ÆÂÆöÂàÜÈÖçÁªôËÆæÂ§áÁöÑËµÑÊ∫êÔºå‰æãÂ¶ÇÂú∞ÂùÄÁ©∫Èó¥ÂíåIRQÁ∫øÔºåÂõ†Ê≠§ËØ•struct pci_funcÁªìÊûÑÁöÑÊúÄÂêé‰∏â‰∏™ÂÖÉÁ¥†Â∞öÊú™Â°´ÂÜô„ÄÇattachÂáΩÊï∞Â∫îË∞ÉÁî® pci_func_enableÔºåÂ∞ÜÂêØÁî®ËÆæÂ§áÔºåÂçèÂïÜËøô‰∫õËµÑÊ∫êÂπ∂Â°´ÂÜôstruct pci_func„ÄÇ ÁúãÂà∞Ëøô‰∏™Êó∂ÂÄôÂ∫îËØ•ÂíåÊàë‰∏ÄÊ†∑‰∫ëÈáåÈõæÈáåÁöÑÔºåËøô‰ªñÂ¶àÈÉΩÂú®ËÆ≤‰∫õÂï•Âïä„ÄÇÊàë‰ª¨ÁÆÄÂçïÊù•ËØ¥ÔºåÊàë‰ª¨Áé∞Âú®ÈúÄË¶ÅÊääËÆæÂ§áÂêØÂä®ÔºåÁÑ∂ÂêéÊää‰æõÂ∫îÂïÜIDÂíåËÆæÂ§áIDÂØπ‰∏äÂè∑ÔºåÁÑ∂ÂêéÈúÄË¶Å‰∏Ä‰∏™ÂáΩÊï∞ÂêØÂä®Ëøô‰∏™ËÆæÂ§á„ÄÇÊÄé‰πàÂàùÂßãÂåñÔºåÊÄé‰πàÂêØÂä®ÔºåÂÖà‰∏çÂéªÁÆ°‰ªñ„ÄÇÊàë‰ª¨Êù•ÂàÜÊûêpci_initÊÄé‰πàÊâßË°åÁöÑ„ÄÇ1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192intpci_init(void)&#123; static struct pci_bus root_bus;//ËøôÊòØ‰∏™ÊÄªÁ∫øÁªìÊûÑ‰ΩìÂ∞±ÊòØ‰ªñÊèê‰æõÁöÑ„ÄÇ /* struct pci_bus &#123; struct pci_func *parent_bridge; uint32_t busno;//ÊÄªÁ∫øÂè∑ÔºåÂõ†‰∏∫ÂèØËÉΩÂ≠òÂú®Â§öÊÄªÁ∫ø &#125;; struct pci_func &#123; struct pci_bus *bus; // Primary bus for bridges ‰∏ªË¶ÅÁöÑÊÄªÁ∫ø uint32_t dev;//Ëøô‰∫õ‰ªãÁªçÂÖ®Âú®ÊñáÊ°£ÈáåÈù¢ uint32_t func;// uint32_t dev_id;// uint32_t dev_class; uint32_t reg_base[6]; uint32_t reg_size[6]; uint8_t irq_line; &#125;; */ memset(&amp;root_bus, 0, sizeof(root_bus)); return pci_scan_bus(&amp;root_bus);//ÁÑ∂ÂêéÂºÄÂßãÊâ´Êèè&#125;static intpci_scan_bus(struct pci_bus *bus)&#123; int totaldev = 0; struct pci_func df; memset(&amp;df, 0, sizeof(df)); df.bus = bus; for (df.dev = 0; df.dev &lt; 32; df.dev++) &#123; uint32_t bhlc = pci_conf_read(&amp;df, PCI_BHLC_REG);//Âú®dfÈáåÈù¢ÊâæPCI_BHLC_REG ÔºåÂÖ∑‰ΩìÂ∞±‰∏çÁî®ÂéªÂÖ≥ÂøÉ‰∫Ü if (PCI_HDRTYPE_TYPE(bhlc) &gt; 1) // Unsupported or no device‰∏çÊîØÊåÅËÆæÂ§áÊàñËÄÖÊ≤°ÊúâËøô‰∏™ËÆæÂ§á continue; totaldev++;//ËÆæÂ§áÊï∞+1 struct pci_func f = df; for (f.func = 0; f.func &lt; (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1); f.func++) &#123; struct pci_func af = f; af.dev_id = pci_conf_read(&amp;f, PCI_ID_REG);//ËØªÂèñID if (PCI_VENDOR(af.dev_id) == 0xffff) continue; uint32_t intr = pci_conf_read(&amp;af, PCI_INTERRUPT_REG);//ËØªÂèñ‰∏≠Êñ≠ af.irq_line = PCI_INTERRUPT_LINE(intr); af.dev_class = pci_conf_read(&amp;af, PCI_CLASS_REG);//ËØªÂèñclass if (pci_show_devs)//ÊâìÂç∞Ëé∑ÂèñÂà∞ÁöÑËÆæÂ§á‰ø°ÊÅØ pci_print_func(&amp;af); pci_attach(&amp;af);//Ëøô‰∏™ÂáΩÊï∞Êàë‰ª¨ËøõÂéªÁúãÁúã &#125; &#125; return totaldev;&#125;static intpci_attach(struct pci_func *f)&#123; return pci_attach_match(PCI_CLASS(f-&gt;dev_class), PCI_SUBCLASS(f-&gt;dev_class), &amp;pci_attach_class[0], f) || pci_attach_match(PCI_VENDOR(f-&gt;dev_id), PCI_PRODUCT(f-&gt;dev_id), &amp;pci_attach_vendor[0], f);&#125;pci_attach_match(uint32_t key1, uint32_t key2, struct pci_driver *list, struct pci_func *pcif)&#123; uint32_t i; for (i = 0; list[i].attachfn; i++) &#123; if (list[i].key1 == key1 &amp;&amp; list[i].key2 == key2) &#123;//Â¶ÇÊûúÂåπÈÖç‰∏ä‰∫Ü int r = list[i].attachfn(pcif);//ËøôÊ†∑ÂéªËøêË°å‰∫Ü if (r &gt; 0) return r; if (r &lt; 0) cprintf("pci_attach_match: attaching " "%x.%x (%p): e\n", key1, key2, list[i].attachfn, r); &#125; &#125; return 0;&#125; ÁÆÄÂçïÊÄùËÄÉ‰∫Ü‰∏ãÔºåpci_init Â∫îËØ•Â∞±ÊòØÊâ´Êèè‰∫Ü‰∏Ä‰∏ãÊÄªÁ∫øÊääÊÄªÁ∫øÈáåÈù¢ÁöÑÊâÄÊúâËÆæÂ§áÔºåÁÑ∂ÂêéÂàùÂßãÂåñ‰∫Ü‰ªñ‰ª¨ÔºåÁÑ∂ÂêéËøîÂõû‰∫ÜÊÄªÂÖ±ÁöÑËÆæÂ§áÊï∞Èáè„ÄÇÂú® pci_attach Êàë‰ª¨Ë∞ÉÁî®‰∫Üpci_attach_vendorÔºåÊàë‰ª¨ÁúãÂà∞Ëøô‰∏™‰∏úË•øÔºåÁé∞Âú®ÈáåÈù¢Âï•ÈÉΩÊ≤°Êúâ„ÄÇÊâÄ‰ª•Êàë‰ª¨Áé∞Âú®Ë¶ÅÂÅöÁöÑÂ∞±ÊòØÊääÊàë‰ª¨ÁöÑÁΩëÂç°È©±Âä®Ê∑ªËøõÂéªÂàùÂßãÂåñ„ÄÇÁªÉ‰π†3ÁÑ∂Êàë‰ª¨Ê∑ªÂä†‰ªñÔºåÂπ∂Ê∑ªÂä†ÂàùÂßãÂåñÂáΩÊï∞„ÄÇÊàë‰ª¨ËøêË°åÂÜÖÊ†∏ÂæàÂÆπÊòìÁúãÂá∫Êù•ÁΩëÂç°ÁöÑ‰ø°ÊÅØ„ÄÇÂêåÊ†∑Êàë‰ª¨Âú®ÊñáÊ°£5.1ËäÇÁöÑË°®ÈáåÊâæÂà∞‰∫ÜËøô‰∏™‰∏úË•øÈÇ£‰πàËøòÊúâ‰∏™ÈóÆÈ¢òÔºåÂéÇÂïÜÂè∑„ÄÅËÆæÂ§áÂè∑Êúâ‰∫ÜÔºåÊÄé‰πàÂàùÂßãÂåñÔºüÔºüÔºüÔºüÂÆûÈ™åÁöÑË¶ÅÊ±ÇÊòØËÆ©ÊàëÂÜôÂú®e1000.hÂíåe1000.cÂÖà‰∏çÁÆ°Ëøô‰∫õÔºåÊàë‰ª¨ÂÖàÊääÂáΩÊï∞ÂÆö‰πâÂ•Ω„ÄÇÂÖàÂú®e1000.hÈáåÈù¢ÂÆö‰πâ123456789101112#include &lt;kern/pci.h&gt;int e1000_init(struct pci_func *pcif);//ËÆ∞ÂæóÂÖàÊääÂú® pic.cÈáåÈù¢Ê∑ªÂä†Â§¥Êñá‰ª∂ #include &lt;kern/e1000.h&gt; //ÁÑ∂Âêé‰øÆÊîπpci_driver// pci_attach_vendor matches the vendor ID and device ID of a PCI device. key1// and key2 should be the vendor ID and device ID respectively#define PCI_E1000_VENDOR_ID 0x8086#define PCI_E1000_DEVICE_ID 0x100Estruct pci_driver pci_attach_vendor[] = &#123; &#123; PCI_E1000_VENDOR_ID, PCI_E1000_DEVICE_ID, &amp;e1000_init&#125;, &#123; 0, 0, 0 &#125;,&#125;; Âú®Êàë‰∏áËà¨Êó†Â•àÁöÑÊó∂ÂÄôÁúãÂà∞‰∫Ü‰∏ÄÂè•ÁªÉ‰π†ÈáåÈù¢ÁöÑÊèêÁ§∫For now, just enable the E1000 device via pci_func_enable. We&#39;ll add more initialization throughout the lab.‰Ω†‰ªñÂ¶àÂú®ÈÄóÊàë,ÂëäËæûÔºå‰∏§Ë°åËß£ÂÜ≥„ÄÇ1234567uint32_t *pci_e1000;inte1000_init(struct pci_func *pcif)&#123; pci_func_enable(pcif); return 1;&#125; Âõ†‰∏∫‰ºöÁî®Âà∞ÂÖ∂‰ªñÂ§¥Êñá‰ª∂ÁöÑÁöÑÂáΩÊï∞ÔºåÊâÄ‰ª•ÂÖàÊääÂ§¥Êñá‰ª∂Âä†ÂÖ•Â•ΩÔºåÊúÄÁªà‰ºöÁî®Âà∞123#include &lt;kern/e1000.h&gt;#include &lt;kern/pmap.h&gt;#include &lt;inc/string.h&gt; Âá∫Áé∞Â§¥Êñá‰ª∂ÈóÆÈ¢òËá™Â∑±ÂéªÁúãÁúãÂ∞ë‰∫ÜÂï•„ÄÇ ËΩØ‰ª∂ÈÄöËøáÂÜÖÂ≠òÊò†Â∞ÑÁöÑI/OÔºàMMIOÔºâ‰∏éE1000ÈÄö‰ø°„ÄÇÊÇ®Âú®JOS‰∏≠Â∑≤ÁªèÁúãËøá‰∏§Ê¨°‰∫ÜÔºöCGAÊéßÂà∂Âè∞ÂíåLAPICÈÉΩÊòØÈÄöËøáÂÜôÂÖ•ÂíåËØªÂèñ‚ÄúÂÜÖÂ≠ò‚ÄùÊù•ÊéßÂà∂ÂíåÊü•ËØ¢ÁöÑËÆæÂ§á„ÄÇ‰ΩÜÊòØËøô‰∫õËØªÂíåÂÜôÊìç‰Ωú‰∏ç‰ºöÂ≠òÂÇ®Âà∞DRAM‰∏≠„ÄÇ‰ªñ‰ª¨Áõ¥Êé•ÂéªËøô‰∫õËÆæÂ§á„ÄÇ pci_func_enable‰∏éE1000ÂçèÂïÜMMIOÂå∫ÂüüÔºåÂπ∂Â∞ÜÂÖ∂Âü∫Êï∞ÂíåÂ§ßÂ∞èÂ≠òÂÇ®Âú®BAR 0ÔºàÂç≥ reg_base[0]Âíåreg_size[0]Ôºâ‰∏≠„ÄÇËøôÊòØÂàÜÈÖçÁªôËÆæÂ§áÁöÑ‰∏ÄÁ≥ªÂàóÁâ©ÁêÜÂÜÖÂ≠òÂú∞ÂùÄÔºåËøôÊÑèÂë≥ÁùÄÊÇ®ÂøÖÈ°ªÂÅö‰∏Ä‰∫õ‰∫ãÊÉÖÊâçËÉΩÈÄöËøáËôöÊãüÂú∞ÂùÄËÆøÈóÆÂÆÉ„ÄÇÁî±‰∫éMMIOÂå∫ÂüüÂàÜÈÖç‰∫ÜÂæàÈ´òÁöÑÁâ©ÁêÜÂú∞ÂùÄÔºàÈÄöÂ∏∏Â§ß‰∫é3GBÔºâÔºåKADDRÂõ†Ê≠§Áî±‰∫éJOSÁöÑ256MBÈôêÂà∂ÔºåÊÇ®‰∏çËÉΩ‰ΩøÁî®ÂÆÉÊù•ËÆøÈóÆÂÆÉ„ÄÇÂõ†Ê≠§ÔºåÊÇ®ÂøÖÈ°ªÂàõÂª∫‰∏Ä‰∏™Êñ∞ÁöÑÂÜÖÂ≠òÊò†Â∞Ñ„ÄÇÊàë‰ª¨Â∞Ü‰ΩøÁî®MMIOBASE‰∏äÊñπÁöÑÂå∫ÂüüÔºàÊÇ® mmio_map_regionÂú®ÂÆûÈ™å4‰∏≠Â∞ÜÁ°Æ‰øùÊàë‰ª¨‰∏ç‰ºöË¶ÜÁõñLAPIC‰ΩøÁî®ÁöÑÊò†Â∞ÑÔºâ„ÄÇÁî±‰∫éPCIËÆæÂ§áÂàùÂßãÂåñÂèëÁîüÂú®JOSÂàõÂª∫Áî®Êà∑ÁéØÂ¢É‰πãÂâçÔºåÂõ†Ê≠§ÊÇ®ÂèØ‰ª•Âú®ÂÖ∂‰∏≠ÂàõÂª∫Êò†Â∞ÑÔºåkern_pgdirÂπ∂‰∏îËØ•Êò†Â∞ÑÂ∞ÜÂßãÁªàÂèØÁî®„ÄÇ ÁªÉ‰π†4 ÂÆûÁé∞mmio_map_region‰∏∫E1000ÁöÑBAR 0ÂàõÂª∫ËôöÊãüÂÜÖÂ≠òÊò†Â∞Ñ,lapic = mmio_map_region(lapicaddr, 4096);‰ªøÁùÄËøô‰∏™ÂÜô‰∏Ä‰∏™„ÄÇÁÑ∂ÂêéËÆ©Êàë‰ª¨ÊâìÂç∞Áä∂ÊÄÅÔºå‰ΩÜÊòØÁä∂ÊÄÅÂú®Âì™„ÄÇÂêéÈù¢Áªô‰∫ÜÊèêÁ§∫ÊèêÁ§∫ÔºöÊÇ®Â∞ÜÈúÄË¶ÅÂæàÂ§öÂ∏∏ÈáèÔºå‰æãÂ¶ÇÂØÑÂ≠òÂô®ÁöÑ‰ΩçÁΩÆÂíå‰ΩçÊé©Á†ÅÁöÑÂÄº„ÄÇÂ∞ùËØïÂ∞ÜËøô‰∫õÂÜÖÂÆπ‰ªéÂºÄÂèë‰∫∫ÂëòÊâãÂÜå‰∏≠Â§çÂà∂Âá∫Êù•ÂæàÂÆπÊòìÂá∫ÈîôÔºåËÄåÈîôËØØÂèØËÉΩÂØºËá¥ÁóõËã¶ÁöÑË∞ÉËØï‰ºöËØù„ÄÇÊàë‰ª¨Âª∫ËÆÆÊîπÁî®QEMUÁöÑe1000_hw.hÊ†áÂ§¥‰Ωú‰∏∫ÊåáÂØº„ÄÇÊàë‰ª¨‰∏çÂª∫ËÆÆÈÄêÂ≠óÂ§çÂà∂ÂÆÉÔºåÂõ†‰∏∫ÂÆÉÂÆö‰πâÁöÑÂÜÖÂÆπËøúËøúË∂ÖÂá∫ÊÇ®ÁöÑÂÆûÈôÖÈúÄË¶ÅÔºåÂπ∂‰∏îÂèØËÉΩÊó†Ê≥ïÊåâÁÖßÊÇ®ÈúÄË¶ÅÁöÑÊñπÂºèËøõË°åÂÆö‰πâÔºå‰ΩÜËøôÊòØ‰∏Ä‰∏™ÂæàÂ•ΩÁöÑËµ∑ÁÇπ„ÄÇÊàë‰ª¨‰∏ãËΩΩÈÇ£‰∏™Êñá‰ª∂ÔºåÁÑ∂Âêéctrl+fÊü•ÊâæstatuÊâæÂà∞‰∫ÜËøô‰∏™#define E1000_STATUS 0x00008 /* Device Status - RO */ÔºåÊâÄ‰ª•Ê∑ªËøõÂéªÂ∞±Ë°å‰∫Ü„ÄÇ ÊâÄ‰ª•Èöè‰æøÊ∑ªÂä†‰∏ÄÁÇπÂ∞±Ë°å‰∫Ü„ÄÇ1234567891011uint32_t *pci_e1000;#define E1000_STATUS 0x00008 /* Device Status - RO Âª∫ËÆÆÂÜôÂà∞Â§¥Êñá‰ª∂ÈáåÈù¢*/inte1000_init(struct pci_func *pcif)&#123; pci_func_enable(pcif); pci_e1000 = mmio_map_region(pcif-&gt;reg_base[0], pcif-&gt;reg_size[0]); cprintf("the E1000 status register: [%08x]\n", *(pci_e1000+(E1000_STATUS&gt;&gt;2))); return 1;&#125; DMAÊÇ®ÂèØ‰ª•ÊÉ≥Ë±°ÈÄöËøáÂÜôÂÖ•ÂíåËØªÂèñE1000ÁöÑÂØÑÂ≠òÂô®Êù•ÂèëÈÄÅÂíåÊé•Êî∂Êï∞ÊçÆÂåÖÔºå‰ΩÜËøô‰ºöÂæàÊÖ¢ÔºåÂπ∂‰∏îÈúÄË¶ÅE1000Âú®ÂÜÖÈÉ®ÁºìÂÜ≤Êï∞ÊçÆÂåÖÊï∞ÊçÆ„ÄÇÁõ∏ÂèçÔºåE1000‰ΩøÁî®Áõ¥Êé•ÂÜÖÂ≠òËÆøÈóÆÊàñDMAÁõ¥Êé•‰ªéÂÜÖÂ≠òËØªÂèñÂíåÂÜôÂÖ•Êï∞ÊçÆÂåÖÊï∞ÊçÆÔºåËÄåÊó†ÈúÄ‰ΩøÁî®CPU„ÄÇÈ©±Âä®Á®ãÂ∫èË¥üË¥£‰∏∫ÂèëÈÄÅÂíåÊé•Êî∂ÈòüÂàóÂàÜÈÖçÂÜÖÂ≠òÔºåËÆæÁΩÆDMAÊèèËø∞Á¨¶ÔºåÂπ∂‰ΩøÁî®Ëøô‰∫õÈòüÂàóÁöÑ‰ΩçÁΩÆÈÖçÁΩÆE1000Ôºå‰ΩÜ‰πãÂêéÁöÑÊâÄÊúâÊìç‰ΩúÈÉΩÊòØÂºÇÊ≠•ÁöÑ„ÄÇ‰∏∫‰∫ÜÂèëÈÄÅÊï∞ÊçÆÂåÖÔºåÈ©±Âä®Á®ãÂ∫èÂ∞ÜÂÖ∂Â§çÂà∂Âà∞ÂèëÈÄÅÈòüÂàó‰∏≠ÁöÑ‰∏ã‰∏Ä‰∏™DMAÊèèËø∞Á¨¶‰∏≠ÔºåÂπ∂ÈÄöÁü•E1000Âè¶‰∏Ä‰∏™Êï∞ÊçÆÂåÖÂèØÁî®„ÄÇÂΩìÊúâÊó∂Èó¥ÂèëÈÄÅÊï∞ÊçÆÂåÖÊó∂ÔºåE1000‰ºöÂ∞ÜÊï∞ÊçÆ‰ªéÊèèËø∞Á¨¶‰∏≠Â§çÂà∂Âá∫Êù•„ÄÇÂêåÊ†∑ÔºåÂΩìE1000Êé•Êî∂Âà∞‰∏Ä‰∏™Êï∞ÊçÆÂåÖÊó∂ÔºåÂÆÉ‰ºöÂ∞ÜÂÖ∂Â§çÂà∂Âà∞Êé•Êî∂ÈòüÂàó‰∏≠ÁöÑ‰∏ã‰∏Ä‰∏™DMAÊèèËø∞Á¨¶‰∏≠ÔºåÈ©±Âä®Á®ãÂ∫èÂèØ‰ª•Âú®‰∏ã‰∏ÄÊ¨°Êú∫‰ºöËØªÂèñËØ•ÊèèËø∞Á¨¶„ÄÇ Âú®È´òÂ±ÇÔºåÊé•Êî∂ÂíåÂèëÈÄÅÈòüÂàóÈùûÂ∏∏Áõ∏‰ºº„ÄÇ‰∏§ËÄÖÈÉΩÁî±‰∏ÄÁ≥ªÂàóÊèèËø∞Á¨¶ÁªÑÊàê„ÄÇÂ∞ΩÁÆ°Ëøô‰∫õÊèèËø∞Á¨¶ÁöÑÁ°ÆÂàáÁªìÊûÑÊúâÊâÄ‰∏çÂêåÔºå‰ΩÜÊòØÊØè‰∏™ÊèèËø∞Á¨¶ÈÉΩÂåÖÂê´‰∏Ä‰∫õÊ†áÂøóÂíåÂåÖÂê´Êï∞ÊçÆÂåÖÊï∞ÊçÆÁöÑÁºìÂÜ≤Âå∫ÁöÑÁâ©ÁêÜÂú∞ÂùÄÔºàÊàñËÄÖÊòØË¶ÅÂèëÈÄÅÁªôÂç°ÁöÑÊï∞ÊçÆÂåÖÊï∞ÊçÆÔºåÊàñËÄÖÊòØOS‰∏∫Âç°ÂàÜÈÖçÁöÑÁºìÂÜ≤Âå∫ÔºåÁî®‰∫éÂ∞ÜÊé•Êî∂Âà∞ÁöÑÊï∞ÊçÆÂåÖÂÜôÂÖ•Âç°Ôºâ„ÄÇ ÈòüÂàóË¢´ÂÆûÁé∞‰∏∫ÂúÜÂΩ¢ÈòµÂàóÔºåËøôÊÑèÂë≥ÁùÄÂΩìÂç°ÊàñÈ©±Âä®Á®ãÂ∫èÂà∞ËææÈòµÂàóÁöÑÊú´Â∞æÊó∂ÔºåÂÆÉ‰ºöÂõûÁªïÂà∞ÂºÄÂ§¥„ÄÇ‰∏§ËÄÖÈÉΩÊúâ‰∏Ä‰∏™Â§¥ÊåáÈíàÂíå‰∏Ä‰∏™Â∞æÊåáÈíàÈòüÂàóÁöÑÂÜÖÂÆπÊòØËøô‰∏§‰∏™ÊåáÈíà‰πãÈó¥ÁöÑÊèèËø∞Á¨¶„ÄÇÁ°¨‰ª∂ÂßãÁªà‰ªéÂ§¥Ê∂àËÄóÊèèËø∞Á¨¶Âπ∂ÁßªÂä®Â§¥ÊåáÈíàÔºåËÄåÈ©±Âä®Á®ãÂ∫èÊÄªÊòØÂêëÊèèËø∞Á¨¶Ê∑ªÂä†ÊèèËø∞Á¨¶Âπ∂ÁßªÂä®Â∞æÊåáÈíà„ÄÇ‰º†ËæìÈòüÂàó‰∏≠ÁöÑÊèèËø∞Á¨¶Ë°®Á§∫Á≠âÂæÖÂèëÈÄÅÁöÑÊï∞ÊçÆÂåÖÔºàÂõ†Ê≠§ÔºåÂú®Á®≥ÂÆöÁä∂ÊÄÅ‰∏ãÔºå‰º†ËæìÈòüÂàó‰∏∫Á©∫Ôºâ„ÄÇÂØπ‰∫éÊé•Êî∂ÈòüÂàóÔºåÈòüÂàó‰∏≠ÁöÑÊèèËø∞Á¨¶ÊòØÂç°ÂèØ‰ª•Êé•Êî∂Êï∞ÊçÆÂåÖÁöÑÁ©∫Èó≤ÊèèËø∞Á¨¶ÔºàÂõ†Ê≠§ÔºåÂú®Á®≥ÂÆöÁä∂ÊÄÅ‰∏ãÔºåÊé•Êî∂ÈòüÂàóÁî±ÊâÄÊúâÂèØÁî®ÁöÑÊé•Êî∂ÊèèËø∞Á¨¶ÁªÑÊàêÔºâ„ÄÇÂú®‰∏çÊ∑∑Ê∑ÜE1000ÁöÑÊÉÖÂÜµ‰∏ãÊ≠£Á°ÆÊõ¥Êñ∞Â∞æÈÉ®ÂØÑÂ≠òÂô®ÈùûÂ∏∏Ê£òÊâãÔºõÂ∞èÂøÉÔºÅËøô‰∏™ÈòüÂàóÊòØ‰∏™ÂúàÔºå‰πüÂ∞±ÊòØÂèñ‰∏™Ê®°ÊåáÂêëËøô‰∫õÊï∞ÁªÑÁöÑÊåáÈíà‰ª•ÂèäÊèèËø∞Á¨¶‰∏≠ÁöÑÊï∞ÊçÆÂåÖÁºìÂÜ≤Âå∫ÁöÑÂú∞ÂùÄÈÉΩÂøÖÈ°ªÊòØÁâ©ÁêÜÂú∞ÂùÄÔºå Âõ†‰∏∫Á°¨‰ª∂Êó†ÈúÄÈÄöËøáMMUÂç≥ÂèØÁõ¥Êé•Âú®Áâ©ÁêÜRAM‰πãÈó¥ËøõË°åDMAÊìç‰Ωú„ÄÇÁÆÄÂçïÊù•ËØ¥Â∞±ÊòØÁªô‰∏ÄÂùóÂÜÖÂ≠òÁî®‰ΩúÁºìÂÜ≤Âå∫ÔºåËÆ©Á°¨‰ª∂ËÉΩÂ§üÁõ¥Êé•ËÆøÈóÆDMA Transmitting PacketsE1000ÁöÑÂèëÈÄÅÂíåÊé•Êî∂ÂäüËÉΩÂü∫Êú¨‰∏äÂΩºÊ≠§Áã¨Á´ãÔºåÂõ†Ê≠§Êàë‰ª¨ÂèØ‰ª•‰∏ÄÊ¨°ÂÆåÊàê‰∏Ä‰∏™Â∑•‰Ωú„ÄÇÊàë‰ª¨Â∞ÜÈ¶ñÂÖàÊîªÂáªÂèëÈÄÅÊï∞ÊçÆÂåÖÁöÑÂéüÂõ†‰ªÖ‰ªÖÊòØÂõ†‰∏∫Êàë‰ª¨Êó†Ê≥ïÂú®‰∏çÂèëÈÄÅ‚ÄúÊàëÂú®ËøôÈáåÔºÅ‚ÄùÁöÑÊÉÖÂÜµ‰∏ãÊµãËØïÊé•Êî∂„ÄÇÊï∞ÊçÆÂåÖ‰ºòÂÖà„ÄÇ È¶ñÂÖàÔºåÊÇ®ÂøÖÈ°ªÊåâÁÖß14.5ËäÇ‰∏≠ÊâÄËø∞ÁöÑÊ≠•È™§ÂàùÂßãÂåñË¶Å‰º†ËæìÁöÑÂç°Ôºà‰∏çÂøÖÊãÖÂøÉËøô‰∫õÂ∞èËäÇÔºâ„ÄÇ‰º†ËæìÂàùÂßãÂåñÁöÑÁ¨¨‰∏ÄÊ≠•ÊòØËÆæÁΩÆ‰º†ËæìÈòüÂàó„ÄÇÈòüÂàóÁöÑÁ≤æÁ°ÆÁªìÊûÑÂú®3.4ËäÇ‰∏≠ÊèèËø∞ÔºåÊèèËø∞Á¨¶ÁöÑÁªìÊûÑÂú®3.3.3ËäÇ‰∏≠ÊèèËø∞„ÄÇÊàë‰ª¨Â∞Ü‰∏ç‰ºö‰ΩøÁî®E1000ÁöÑTCPÂç∏ËΩΩÂäüËÉΩÔºåÂõ†Ê≠§ÊÇ®ÂèØ‰ª•‰∏ìÊ≥®‰∫é‚ÄúÊóßÁâà‰º†ËæìÊèèËø∞Á¨¶Ê†ºÂºè‚Äù„ÄÇÊÇ®Áé∞Âú®Â∫îËØ•ÈòÖËØªËøô‰∫õÈÉ®ÂàÜÔºåÂπ∂ÁÜüÊÇâËøô‰∫õÁªìÊûÑ„ÄÇ C StructuresÊÇ®‰ºöÂèëÁé∞‰ΩøÁî®C structÊù•ÊèèËø∞E1000ÁöÑÁªìÊûÑÂæàÊñπ‰æø„ÄÇÂ¶ÇÊÇ®ÊâÄËßÅstruct TrapframeÔºå‰ΩøÁî®C struct Á≠âÁªìÊûÑÂèØ‰ª• ‰ΩøÊÇ®Á≤æÁ°ÆÂú∞Âú®ÂÜÖÂ≠ò‰∏≠Â∏ÉÁΩÆÊï∞ÊçÆ„ÄÇCÂèØ‰ª•Âú®Â≠óÊÆµ‰πãÈó¥ÊèíÂÖ•Â°´ÂÖÖÔºå‰ΩÜÊòØE1000ÁöÑÁªìÊûÑÂ∏ÉÂ±Ä‰ΩøÂæóËøô‰∏çÊàêÈóÆÈ¢ò„ÄÇÂ¶ÇÊûúÁ°ÆÂÆûÈÅáÂà∞Â≠óÊÆµÂØπÈΩêÈóÆÈ¢òÔºåËØ∑Êü•ÁúãGCCÁöÑ‚ÄúÊâìÂåÖ‚ÄùÂ±ûÊÄß„ÄÇ ‰æãÂ¶ÇÔºåËØ∑ËÄÉËôëÊâãÂÜåË°®3-8‰∏≠ÁªôÂá∫Âπ∂Âú®Ê≠§Â§ÑÂ§çÂà∂ÁöÑÊóßÁâà‰º†ËæìÊèèËø∞Á¨¶Ôºö 63 48 47 40 39 32 31 24 23 16 15 0 +---------------------------------------------------------------+ | Buffer address | +---------------+-------+-------+-------+-------+---------------+ | Special | CSS | Status| Cmd | CSO | Length | +---------------+-------+-------+-------+-------+---------------+ ÁªìÊûÑÁöÑÁ¨¨‰∏Ä‰∏™Â≠óËäÇ‰ªéÂè≥‰∏äËßíÂºÄÂßãÔºåÂõ†Ê≠§Ë¶ÅÂ∞ÜÂÖ∂ËΩ¨Êç¢‰∏∫C structÔºå‰ªéÂè≥Âà∞Â∑¶Ôºå‰ªé‰∏äÂà∞‰∏ãËØªÂèñ„ÄÇÂ¶ÇÊûúÂ∏ÉÂ±ÄÊ≠£Á°ÆÔºåÊÇ®‰ºöÂèëÁé∞ÊâÄÊúâÂ≠óÊÆµÁîöËá≥ÈÉΩÈùûÂ∏∏ÈÄÇÂêàÊ†áÂáÜÂ§ßÂ∞èÁöÑÁ±ªÂûãÔºö12345678910struct tx_desc&#123; uint64_t addr; uint16_t length; uint8_t cso; uint8_t cmd; uint8_t status; uint8_t css; uint16_t special;&#125;; ÊÇ®ÁöÑÈ©±Âä®Á®ãÂ∫èÂ∞ÜÂøÖÈ°ª‰∏∫‰º†ËæìÊèèËø∞Á¨¶Êï∞ÁªÑÂíå‰º†ËæìÊèèËø∞Á¨¶ÊåáÂêëÁöÑÊï∞ÊçÆÂåÖÁºìÂÜ≤Âå∫‰øùÁïôÂÜÖÂ≠ò„ÄÇÊúâÂ§öÁßçÊñπÊ≥ïÂèØ‰ª•ÊâßË°åÊ≠§Êìç‰ΩúÔºå‰ªéÂä®ÊÄÅÂàÜÈÖçÈ°µÈù¢Âà∞ÁÆÄÂçïÂú∞Âú®ÂÖ®Â±ÄÂèòÈáè‰∏≠Â£∞ÊòéÈ°µÈù¢ÈÉΩÂèØ‰ª•„ÄÇÊó†ËÆ∫ÊÇ®ÈÄâÊã©‰ªÄ‰πàÔºåËØ∑ËÆ∞‰ΩèE1000Áõ¥Êé•ËÆøÈóÆÁâ©ÁêÜÂÜÖÂ≠òÔºåËøôÊÑèÂë≥ÁùÄÂÆÉËÆøÈóÆÁöÑ‰ªª‰ΩïÁºìÂÜ≤Âå∫ÂøÖÈ°ªÂú®Áâ©ÁêÜÂÜÖÂ≠ò‰∏≠ÊòØËøûÁª≠ÁöÑ„ÄÇ ËøòÊúâÂ§öÁßçÂ§ÑÁêÜÊï∞ÊçÆÂåÖÁºìÂÜ≤Âå∫ÁöÑÊñπÊ≥ï„ÄÇÊàë‰ª¨Âª∫ËÆÆÊúÄÁÆÄÂçïÁöÑÊñπÊ≥ïÊòØÔºåÂú®È©±Âä®Á®ãÂ∫èÂàùÂßãÂåñÊúüÈó¥‰∏∫ÊØè‰∏™ÊèèËø∞Á¨¶‰∏∫Êï∞ÊçÆÂåÖÁºìÂÜ≤Âå∫‰øùÁïôÁ©∫Èó¥ÔºåÂπ∂ÁÆÄÂçïÂú∞Â∞ÜÊï∞ÊçÆÂåÖÊï∞ÊçÆÂ§çÂà∂Âà∞Ëøô‰∫õÈ¢ÑÂàÜÈÖçÁöÑÁºìÂÜ≤Âå∫‰∏≠Êàñ‰ªéÂÖ∂‰∏≠Â§çÂà∂Âá∫Êù•„ÄÇ‰ª•Â§™ÁΩëÊï∞ÊçÆÂåÖÁöÑÊúÄÂ§ßÂ§ßÂ∞è‰∏∫1518Â≠óËäÇÔºåËøôÈôêÂà∂‰∫ÜËøô‰∫õÁºìÂÜ≤Âå∫ÁöÑÂ§ßÂ∞è„ÄÇÊõ¥Â§çÊùÇÁöÑÈ©±Âä®Á®ãÂ∫èÂèØ‰ª•Âä®ÊÄÅÂàÜÈÖçÊï∞ÊçÆÂåÖÁºìÂÜ≤Âå∫Ôºà‰æãÂ¶ÇÔºå‰ª•Âú®ÁΩëÁªú‰ΩøÁî®ÁéáËæÉ‰ΩéÊó∂ÂáèÂ∞ëÂÜÖÂ≠òÂºÄÈîÄÔºâÔºåÁîöËá≥ÂèØ‰ª•‰º†ÈÄíÁî®Êà∑Á©∫Èó¥Áõ¥Êé•Êèê‰æõÁöÑÁºìÂÜ≤Âå∫Ôºà‰∏ÄÁßçÁß∞‰∏∫‚ÄúÈõ∂Â§çÂà∂‚ÄùÁöÑÊäÄÊúØÔºâÔºå‰ΩÜÊòØÊúÄÂ•ΩËøòÊòØ‰ªéÁÆÄÂçïÂºÄÂßã„ÄÇ ÁªÉ‰π†5ÊâßË°åÁ¨¨14.5ËäÇÔºà‰ΩÜ‰∏çÂåÖÊã¨ÂÖ∂Â∞èËäÇÔºâ‰∏≠ÊèèËø∞ÁöÑÂàùÂßãÂåñÊ≠•È™§„ÄÇ‰ΩøÁî®Á¨¨13ËäÇ‰Ωú‰∏∫ÂàùÂßãÂåñËøáÁ®ãÊâÄÂºïÁî®ÁöÑÂØÑÂ≠òÂô®ÁöÑÂèÇËÄÉÔºåÂπ∂‰ΩøÁî®3.3.3Âíå3.4ËäÇ‰Ωú‰∏∫ÂèëÈÄÅÊèèËø∞Á¨¶ÂíåÂèëÈÄÅÊèèËø∞Á¨¶Êï∞ÁªÑÁöÑÂèÇËÄÉ„ÄÇËØ∑Ê≥®ÊÑèÂØπÂèëÈÄÅÊèèËø∞Á¨¶Êï∞ÁªÑÁöÑÂØπÈΩêË¶ÅÊ±Ç‰ª•ÂèäÂØπËØ•Êï∞ÁªÑÈïøÂ∫¶ÁöÑÈôêÂà∂„ÄÇÁî±‰∫éTDLENÂøÖÈ°ªÂØπÈΩê128Â≠óËäÇÔºåÊØè‰∏™‰º†ËæìÊèèËø∞Á¨¶‰∏∫16Â≠óËäÇÔºåÂõ†Ê≠§ÊÇ®ÁöÑ‰º†ËæìÊèèËø∞Á¨¶Êï∞ÁªÑÂ∞ÜÈúÄË¶Å8‰∏™‰º†ËæìÊèèËø∞Á¨¶ÁöÑÊüê‰∏™ÂÄçÊï∞„ÄÇ‰ΩÜÊòØÔºåËØ∑Âãø‰ΩøÁî®Ë∂ÖËøá64‰∏™ÁöÑÊèèËø∞Á¨¶ÔºåÂê¶ÂàôÊàë‰ª¨ÁöÑÊµãËØïÂ∞ÜÊó†Ê≥ïÊµãËØï‰º†ËæìÁéØÊ∫¢Âá∫„ÄÇÂØπ‰∫éTCTL.COLDÔºåÊÇ®ÂèØ‰ª•ÂÅáÂÆö‰∏∫ÂÖ®ÂèåÂ∑•Êìç‰Ωú„ÄÇÂØπ‰∫éTIPGÔºåËØ∑ÂèÇÈòÖÁ¨¨13.4.34ËäÇÁöÑË°®13-77‰∏≠ÊèèËø∞ÁöÑIEEE 802.3Ê†áÂáÜIPGÁöÑÈªòËÆ§ÂÄºÔºà‰∏çË¶Å‰ΩøÁî®Á¨¨14.5ËäÇÁöÑË°®‰∏≠ÁöÑÂÄºÔºâ„ÄÇ „ÄÇ„ÄÇ„ÄÇÂØπ‰∫éËøô‰∏™ÔºåÊàëÁúüÁúã‰∏çÊáÇÊòØÂï•„ÄÇÊåâÁÖß14.5ËäÇÁöÑÊèèËø∞ÂàùÂßãÂåñ„ÄÇÊ≠•È™§Â¶Ç‰∏ãÔºö ÂàÜÈÖç‰∏ÄÂùóÂÜÖÂ≠òÁî®‰ΩúÂèëÈÄÅÊèèËø∞Á¨¶ÈòüÂàóÔºåËµ∑ÂßãÂú∞ÂùÄË¶Å16Â≠óËäÇÂØπÈΩê„ÄÇÁî®Âü∫Âú∞ÂùÄÂ°´ÂÖÖ(TDBAL/TDBAH) ÂØÑÂ≠òÂô®„ÄÇ ËÆæÁΩÆ(TDLEN)ÂØÑÂ≠òÂô®ÔºåËØ•ÂØÑÂ≠òÂô®‰øùÂ≠òÂèëÈÄÅÊèèËø∞Á¨¶ÈòüÂàóÈïøÂ∫¶ÔºåÂøÖÈ°ª128Â≠óËäÇÂØπÈΩê„ÄÇ ËÆæÁΩÆ(TDH/TDT)ÂØÑÂ≠òÂô®ÔºåËøô‰∏§‰∏™ÂØÑÂ≠òÂô®ÈÉΩÊòØÂèëÈÄÅÊèèËø∞Á¨¶ÈòüÂàóÁöÑ‰∏ãÊ†á„ÄÇÂàÜÂà´ÊåáÂêëÂ§¥ÈÉ®ÂíåÂ∞æÈÉ®„ÄÇÂ∫îËØ•ÂàùÂßãÂåñ‰∏∫0„ÄÇ ÂàùÂßãÂåñTCTLÂØÑÂ≠òÂô®„ÄÇËÆæÁΩÆTCTL.EN‰Ωç‰∏∫1ÔºåËÆæÁΩÆTCTL.PSP‰Ωç‰∏∫1„ÄÇËÆæÁΩÆTCTL.CT‰∏∫10h„ÄÇËÆæÁΩÆTCTL.COLD‰∏∫40h„ÄÇ ËÆæÁΩÆTIPGÂØÑÂ≠òÂô®„ÄÇÊàë‰ª¨ÂÖàÊääËøô‰∫õ‰∏úË•øÂä†e1000.h‰∏≠,Âú®ÊääÁªìÊûÑÂÆö‰πâÂá∫Êù•„ÄÇ123456789101112131415161718192021222324252627282930313233#define E1000_TCTL 0x00400 /* TX Control - RW */#define E1000_TDBAL 0x03800 /* TX Descriptor Base Address Low - RW */#define E1000_TDBAH 0x03804 /* TX Descriptor Base Address High - RW */#define E1000_TDLEN 0x03808 /* TX Descriptor Length - RW */#define E1000_TDH 0x03810 /* TX Descriptor Head - RW */#define E1000_TDT 0x03818 /* TX Descripotr Tail - RW */#define E1000_TIPG 0x00410 /* TX Inter-packet gap -RW */#define E1000_TCTL_EN 0x00000002 /* enable tx */#define E1000_TCTL_BCE 0x00000004 /* busy check enable */#define E1000_TCTL_PSP 0x00000008 /* pad short packets */#define E1000_TCTL_CT 0x00000ff0 /* collision threshold */#define E1000_TCTL_COLD 0x003ff000 /* collision distance */#define E1000_TXD_CMD_RS 0x08000000 /* Report Status */#define E1000_TXD_STAT_DD 0x00000001 /* Descriptor Done */#define E1000_TXD_CMD_EOP 0x01000000 /* End of Packet */#define TX_MAX 64 //ÂèëÈÄÅÂåÖÁöÑÊúÄÂ§ßÊï∞Èáè#define BUFSIZE 2048struct tx_desc&#123; uint64_t addr; uint16_t length; uint8_t cso; uint8_t cmd; uint8_t status; uint8_t css; uint16_t special;&#125;__attribute__((packed));struct tx_desc tx_list[TX_MAX];//ÊèèËø∞Á¨¶struct packets&#123; char buffer[BUFSIZE];//16ÂØπÈΩê&#125;__attribute__((packed));struct packets tx_buf[TX_MAX];//ÁºìÂÜ≤Âå∫ ÂÖ∑‰ΩìÂÆûÁé∞ÔºåÊàëÂè™ÊòØÁúãÂà´‰∫∫ÁöÑÁúãÊáÇ‰∫Ü„ÄÇ„ÄÇ„ÄÇ„ÄÇ12345678910111213141516171819202122232425//Ëøô‰∏™ÂàùÂßãÂåñÂáΩÊï∞ÊòØË¶ÅÂú®ÂâçÈù¢ÈÇ£‰∏™ÂàùÂßãÂåñe1000_initÈáåÈù¢Ë∞ÉÁî®Ôºå‰∏çÁÑ∂‰∏ç‰ºöËøêË°åvoide1000_transmit_init()&#123; //ÂàùÂßãÂåñ memset(tx_list, 0, sizeof(struct tx_desc)*TX_MAX); memset(tx_buf, 0, sizeof(struct packets)*TX_MAX); for(int i=0; i&lt;TX_MAX; i++)&#123; tx_list[i].addr = PADDR(tx_buf[i].buffer); tx_list[i].cmd = (E1000_TXD_CMD_EOP&gt;&gt;24) | (E1000_TXD_CMD_RS&gt;&gt;24); tx_list[i].status = E1000_TXD_STAT_DD; &#125; //Â°´ÂÖÖE1000_TDBAL/E1000_TDBAH pci_e1000[E1000_TDBAL&gt;&gt;2] = PADDR(tx_list); pci_e1000[E1000_TDBAH&gt;&gt;2] = 0; //ËÆæÁΩÆÈïøÂ∫¶ pci_e1000[E1000_TDLEN&gt;&gt;2] = TX_MAX*sizeof(struct tx_desc); //ÂàùÂßãÂåñÂ§¥Â∞æ pci_e1000[E1000_TDH&gt;&gt;2] = 0; pci_e1000[E1000_TDT&gt;&gt;2] = 0; //ËÆæÁΩÆÂØÑÂ≠òÂô®ÁöÑÂÄº pci_e1000[E1000_TCTL&gt;&gt;2] |= (E1000_TCTL_EN | E1000_TCTL_PSP | (E1000_TCTL_CT &amp; (0x10&lt;&lt;4)) | (E1000_TCTL_COLD &amp; (0x40&lt;&lt;12))); pci_e1000[E1000_TIPG&gt;&gt;2] |= (10) | (4&lt;&lt;10) | (6&lt;&lt;20);&#125; Áé∞Âú®Ôºå‰º†ËæìÂ∑≤ÂàùÂßãÂåñÔºåÊÇ®Â∞ÜÂøÖÈ°ªÁºñÂÜô‰ª£Á†Å‰ª•‰º†ËæìÊï∞ÊçÆÂåÖÔºåÂπ∂‰ΩøÂÖ∂ÈÄöËøáÁ≥ªÁªüË∞ÉÁî®ÂèØÂú®Áî®Êà∑Á©∫Èó¥ËÆøÈóÆ„ÄÇË¶Å‰º†ËæìÊï∞ÊçÆÂåÖÔºåÊÇ®ÂøÖÈ°ªÂ∞ÜÂÖ∂Ê∑ªÂä†Âà∞‰º†ËæìÈòüÂàóÁöÑÊú´Â∞æÔºåËøôÊÑèÂë≥ÁùÄÂ∞ÜÊï∞ÊçÆÂåÖÊï∞ÊçÆÂ§çÂà∂Âà∞‰∏ã‰∏Ä‰∏™Êï∞ÊçÆÂåÖÁºìÂÜ≤Âå∫ÔºåÁÑ∂ÂêéÊõ¥Êñ∞TDTÔºà‰º†ËæìÊèèËø∞Á¨¶Êú´Â∞æÔºâÂØÑÂ≠òÂô®‰ª•ÈÄöÁü•Âç°‰∏≠Â≠òÂú®Âè¶‰∏Ä‰∏™Êï∞ÊçÆÂåÖ„ÄÇ‰º†ËæìÈòüÂàó„ÄÇÔºàËØ∑Ê≥®ÊÑèÔºåTDTÊòØ‰º†ËæìÊèèËø∞Á¨¶Êï∞ÁªÑÁöÑÁ¥¢ÂºïÔºåËÄå‰∏çÊòØÂ≠óËäÇÂÅèÁßªÈáèÔºõÊñáÊ°£ÂØπÊ≠§Âπ∂‰∏çÂçÅÂàÜÊ∏ÖÊ•ö„ÄÇÔºâ ‰ΩÜÊòØÔºåÂèëÈÄÅÈòüÂàóÂè™ÊúâËøô‰πàÂ§ß„ÄÇÂ¶ÇÊûúÂç°ËêΩÂêé‰∫é‰º†ËæìÊï∞ÊçÆÂåÖÂπ∂‰∏î‰º†ËæìÈòüÂàóÂ∑≤Êª°ÊÄé‰πàÂäûÔºü‰∏∫‰∫ÜÊ£ÄÊµãÂà∞ËøôÁßçÊÉÖÂÜµÔºåÊÇ®ÈúÄË¶ÅE1000ÁöÑ‰∏Ä‰∫õÂèçÈ¶à„ÄÇ‰∏çÂπ∏ÁöÑÊòØÔºåÊÇ®‰∏çËÉΩÂè™‰ΩøÁî®TDHÔºàÂèëÈÄÅÊèèËø∞Á¨¶Â§¥ÔºâÂØÑÂ≠òÂô®„ÄÇËØ•ÊñáÊ°£ÊòéÁ°ÆÊåáÂá∫Ôºå‰ªéËΩØ‰ª∂ËØªÂèñËØ•ÂØÑÂ≠òÂô®ÊòØ‰∏çÂèØÈù†ÁöÑ„ÄÇ‰ΩÜÊòØÔºåÂ¶ÇÊûúÊÇ®Âú®ÂèëÈÄÅÊèèËø∞Á¨¶ÁöÑÂëΩ‰ª§Â≠óÊÆµ‰∏≠ËÆæÁΩÆ‰∫ÜRS‰ΩçÔºåÂàôÂΩìÂç°Â∑≤Âú®ËØ•ÊèèËø∞Á¨¶‰∏≠ÂèëÈÄÅ‰∫ÜÊï∞ÊçÆÂåÖÊó∂ÔºåÂç°Â∞ÜÂú®ÊèèËø∞Á¨¶ÁöÑÁä∂ÊÄÅÂ≠óÊÆµ‰∏≠Â∞ÜDD‰ΩçÁΩÆ‰∏∫1„ÄÇÂ¶ÇÊûúÂ∑≤Â∞ÜÊèèËø∞Á¨¶ÁöÑDD‰ΩçÁΩÆ1ÔºåÂàôÂèØ‰ª•ÂÆâÂÖ®Âú∞ÂõûÊî∂ËØ•ÊèèËø∞Á¨¶Âπ∂‰ΩøÁî®ÂÆÉ‰º†ËæìÂè¶‰∏Ä‰∏™Êï∞ÊçÆÂåÖ„ÄÇ Â¶ÇÊûúÁî®Êà∑ÂëºÂè´ÊÇ®ÁöÑ‰º†ËæìÁ≥ªÁªüË∞ÉÁî®Ôºå‰ΩÜÊú™ËÆæÁΩÆ‰∏ã‰∏Ä‰∏™ÊèèËø∞Á¨¶ÁöÑDD‰ΩçÔºåË°®Êòé‰º†ËæìÈòüÂàóÂ∑≤Êª°ÊÄé‰πàÂäûÔºüÊÇ®ÂøÖÈ°ªÂÜ≥ÂÆöÂú®ËøôÁßçÊÉÖÂÜµ‰∏ãËØ•ÊÄé‰πàÂÅö„ÄÇÊÇ®ÂèØ‰ª•ÁÆÄÂçïÂú∞‰∏¢ÂºÉÊï∞ÊçÆÂåÖ„ÄÇÁΩëÁªúÂçèËÆÆÂØπÊ≠§ÂÖ∑Êúâ‰∏ÄÂÆöÁöÑÂºπÊÄßÔºå‰ΩÜÊòØÂ¶ÇÊûú‰∏¢ÂºÉÂ§ßÈáèÁöÑÊï∞ÊçÆÂåÖÔºåÂàôËØ•ÂçèËÆÆÂèØËÉΩÊó†Ê≥ïÊÅ¢Â§ç„ÄÇÊÇ®ÂèØ‰ª•Êîπ‰∏∫ÂëäËØâÁî®Êà∑ÁéØÂ¢ÉÂøÖÈ°ªÈáçËØïÔºåÂ∞±ÂÉèÊÇ®ÂØπÊâÄÂÅöÁöÑ‰∏ÄÊ†∑sys_ipc_try_send„ÄÇËøôÊ†∑ÂÅöÁöÑÂ•ΩÂ§ÑÊòØÂèØ‰ª•Êé®ËøüÁîüÊàêÊï∞ÊçÆÁöÑÁéØÂ¢É„ÄÇ ÂâçÈù¢Â∑≤ÁªèÂàùÂßãÂåñ‰∫ÜÂèëÈÄÅÔºåÁé∞Âú®Â∞±ÊòØË¶Å‰Ω†ÂÆûÁé∞ÂèëÈÄÅÂäüËÉΩ„ÄÇÁªÉ‰π†6ÈÄöËøáÊ£ÄÊü•‰∏ã‰∏Ä‰∏™ÊèèËø∞Á¨¶ÊòØÂê¶Á©∫Èó≤ÔºåÂ∞ÜÂåÖÊï∞ÊçÆÂ§çÂà∂Âà∞‰∏ã‰∏Ä‰∏™ÊèèËø∞Á¨¶Âπ∂Êõ¥Êñ∞TDTÔºåÁºñÂÜô‰∏Ä‰∏™ÂáΩÊï∞Êù•ÂèëÈÄÅÊï∞ÊçÆÂåÖ„ÄÇÁ°Æ‰øùÂ§ÑÁêÜ‰º†ËæìÈòüÂàóÂ∑≤Êª°„ÄÇ123456789101112131415intfit_txd_for_E1000_transmit(void *addr, int length)&#123; int tail = pci_e1000[E1000_TDT&gt;&gt;2];//ÂèñÈòüÂ∞æ struct tx_desc *tx_next = &amp;tx_list[tail];//Ëé∑ÂèñÁªìÊûÑ‰Ωì if(length &gt; sizeof(struct packets))//ÈïøÂ∫¶‰∏çËÉΩË∂ÖËøáÊúÄÂ§ßÂÄº length = sizeof(struct packets); if((tx_next-&gt;status &amp; E1000_TXD_STAT_DD) == E1000_TXD_STAT_DD)&#123;//ÈÄöËøáËøô‰∏™Ê†áÂøó‰ΩçÂÆûÁé∞Âà§Êñ≠ memmove(KADDR(tx_next-&gt;addr), addr, length); tx_next-&gt;status &amp;= !E1000_TXD_STAT_DD; tx_next-&gt;length = (uint16_t)length; pci_e1000[E1000_TDT&gt;&gt;2] = (tail + 1)%TX_MAX; return 0; &#125; return -1;&#125; ÁªÉ‰π†7 Â∞Ü‰ªñÂú®Á≥ªÁªüË∞ÉÁî®ÈáåÈù¢Ë∞ÉÁî®„ÄÇËøô‰∏™Â∞±ÁÆÄÂçï‰∫Ü„ÄÇÊ∑ªÂä†‰∏Ä‰∏™Êñ∞ÁöÑÁ≥ªÁªüË∞ÉÁî®ÔºåËá™Â∑±ÂëΩÂêçÂ∞±Ë°å„ÄÇ12345678static intsys_packet_try_send(void *addr, uint32_t len)&#123; user_mem_assert(curenv, addr, len, PTE_U); return fit_txd_for_E1000_transmit(addr, len);&#125;//Ê∑ªÂä†case Ê≥®ÊÑèËøô‰∏™SYS_packet_try_send ÊòØÊ≤°ÊúâÁöÑ Ë¶ÅÂú®syscall.h ÁöÑÂ§¥Êñá‰ª∂ÈáåÈù¢ÁöÑenum Ê∑ªÂä†‰∫Ü„ÄÇ case (SYS_packet_try_send): return sys_packet_try_send((void *)a1,a2); Âú®Ëøô‰∏™Âú∞ÊñπÊ∑ªÂä†‰πãÂêéË¶ÅÂÜôÂà∞lib/syscall.cÈáåÈù¢12345int sys_packet_try_send(void *data_va, int len)&#123; return (int) syscall(SYS_packet_try_send, 0 , (uint32_t)data_va, len, 0, 0, 0);&#125;//ËøòË¶ÅÂú® inc/lib.hÈáåÈù¢Â£∞Êòé int sys_packet_try_send(void *data_va, int len); Âà∞ËøôÈáåÂ∞±ÊúâÁ≥ªÁªüË∞ÉÁî®ÂèëÈÄÅ‰∏úË•ø‰∫Ü„ÄÇ Transmitting Packets: Network ServerÁé∞Âú®ÔºåÊÇ®Â∑≤ÁªèÂú®ËÆæÂ§áÈ©±Âä®Á®ãÂ∫èÁöÑÂèëÈÄÅÁ´ØÊúâ‰∫Ü‰∏Ä‰∏™Á≥ªÁªüË∞ÉÁî®Êé•Âè£ÔºåÊòØÊó∂ÂÄôÂèëÈÄÅÊï∞ÊçÆÂåÖ‰∫Ü„ÄÇËæìÂá∫Â∏ÆÂä©Á®ãÂ∫èÁéØÂ¢ÉÁöÑÁõÆÊ†áÊòØÂæ™ÁéØÊâßË°å‰ª•‰∏ãÊìç‰ΩúÔºöÊé•ÂèóNSREQ_OUTPUTÊù•Ëá™Ê†∏ÂøÉÁΩëÁªúÊúçÂä°Âô®ÁöÑIPCÊ∂àÊÅØÔºåÂπ∂‰ΩøÁî®‰∏äÈù¢Ê∑ªÂä†ÁöÑÁ≥ªÁªüË∞ÉÁî®Â∞Ü‰º¥ÈöèËøô‰∫õIPCÊ∂àÊÅØÁöÑÊï∞ÊçÆÂåÖÂèëÈÄÅÂà∞ÁΩëÁªúËÆæÂ§áÈ©±Âä®Á®ãÂ∫è„ÄÇËØ•NSREQ_OUTPUT IPCÁöÑÁî±ÂèëÈÄÅlow_level_outputÂäüËÉΩÂú® net/lwip/jos/jif/jif.cÔºåËØ•ËÉ∂ÂêàÁöÑLWIPÁöÑÂ†Ü‰π¶ÁöÑÁΩëÁªúÁ≥ªÁªü„ÄÇÊØè‰∏™IPCÈÉΩÂ∞ÜÂåÖÂê´‰∏Ä‰∏™È°µÈù¢ÔºåËØ•È°µÈù¢Áî±union NsipcÂÖ∂struct jif_pkt pktÂ≠óÊÆµ‰∏≠ÂåÖÂê´Êï∞ÊçÆÂåÖ ÔºàËØ∑ÂèÇËßÅinc / ns.hÔºâ„ÄÇ struct jif_pkt1234struct jif_pkt &#123; int jp_len; char jp_data [0]; &#125;; jp_lenË°®Á§∫Êï∞ÊçÆÂåÖÁöÑÈïøÂ∫¶„ÄÇIPCÈ°µÈù¢‰∏äÁöÑÊâÄÊúâÂêéÁª≠Â≠óËäÇ‰∏ìÁî®‰∫éÊï∞ÊçÆÂåÖÂÜÖÂÆπ„ÄÇjp_dataÂú®ÁªìÊûÑÁöÑÊú´Â∞æ‰ΩøÁî®Èõ∂ÈïøÂ∫¶Êï∞ÁªÑÊòØ‰∏ÄÁßçÂ∏∏ËßÅÁöÑCÊäÄÂ∑ßÔºåÁî®‰∫éË°®Á§∫Ê≤°ÊúâÈ¢ÑÂÆöÈïøÂ∫¶ÁöÑÁºìÂÜ≤Âå∫„ÄÇÁî±‰∫éC‰∏ç‰ºöËøõË°åÊï∞ÁªÑËæπÁïåÊ£ÄÊü•ÔºåÂõ†Ê≠§Âè™Ë¶ÅÊÇ®Á°Æ‰øùËØ•ÁªìÊûÑÂêéÈù¢ÊúâË∂≥Â§üÁöÑÊú™‰ΩøÁî®ÂÜÖÂ≠òÔºåÂ∞±ÂèØ‰ª•Â∞ÜÂÖ∂jp_dataÁî®‰Ωú‰ªª‰ΩïÂ§ßÂ∞èÁöÑÊï∞ÁªÑ„ÄÇ ÂΩìËÆæÂ§áÈ©±Âä®Á®ãÂ∫èÁöÑ‰º†ËæìÈòüÂàó‰∏≠Ê≤°ÊúâÊõ¥Â§öÁ©∫Èó¥Êó∂ÔºåËØ∑Ê≥®ÊÑèËÆæÂ§áÈ©±Âä®Á®ãÂ∫èÔºåËæìÂá∫ÁéØÂ¢ÉÂíåÊ†∏ÂøÉÁΩëÁªúÊúçÂä°Âô®‰πãÈó¥ÁöÑ‰∫§‰∫í„ÄÇÊ†∏ÂøÉÁΩëÁªúÊúçÂä°Âô®‰ΩøÁî®IPCÂ∞ÜÊï∞ÊçÆÂåÖÂèëÈÄÅÂà∞ËæìÂá∫ÁéØÂ¢É„ÄÇÂ¶ÇÊûúÁî±‰∫éÂèëÈÄÅÊï∞ÊçÆÂåÖÁ≥ªÁªüË∞ÉÁî®ËÄåÂØºËá¥ËæìÂá∫ÁéØÂ¢ÉÊöÇÂÅúÔºåÂõ†‰∏∫È©±Âä®Á®ãÂ∫èÊ≤°ÊúâÊõ¥Â§öÁöÑÁºìÂÜ≤Âå∫ÂèØÂÆπÁ∫≥Êñ∞Êï∞ÊçÆÂåÖÔºåÂàôÊ†∏ÂøÉÁΩëÁªúÊúçÂä°Âô®Â∞ÜÈòªÊ≠¢Á≠âÂæÖËæìÂá∫ÊúçÂä°Âô®Êé•ÂèóIPCË∞ÉÁî®„ÄÇÁõó‰∏™Âõæ ËøôÂ∞±ÊòØÊï¥‰∏™ÁöÑÊµÅÁ®ã‰∫Ü„ÄÇÊúÄÁªàÂÆûÁé∞‰πüÁÆÄÂçï„ÄÇÁªÉ‰π†8ÂÆûÁé∞output.c123456789101112131415161718192021#include "ns.h"extern union Nsipc nsipcbuf;voidoutput(envid_t ns_envid)&#123; binaryname = "ns_output"; // LAB 6: Your code here: // - read a packet from the network server // - send the packet to the device driver envid_t from_env; int perm; while(1)&#123; if( ipc_recv(&amp;from_env, &amp;nsipcbuf, &amp;perm) != NSREQ_OUTPUT) continue; while(sys_packet_try_send(nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len)&lt;0) sys_yield(); &#125;&#125; Part B: Receiving packets and the web serverÊàëÈÉΩ‰∏çÊÉ≥ËØ¥ËØù‰∫ÜÔºåÊï¥‰∏™ÂíåÂâçÈù¢ÈÇ£‰∏™Âü∫Êú¨‰∏ä‰∏ÄÊ®°‰∏ÄÊ†∑„ÄÇÊàëÁõ¥Êé•Áªô‰ª£Á†Å‰∫Üe100..h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#ifndef JOS_KERN_E1000_H#define JOS_KERN_E1000_H#include &lt;kern/pci.h&gt;#define E1000_STATUS 0x00008 /* Device Status - RO */int e1000_init(struct pci_func *pcif); #define E1000_TCTL 0x00400 /* TX Control - RW */#define E1000_TDBAL 0x03800 /* TX Descriptor Base Address Low - RW */#define E1000_TDBAH 0x03804 /* TX Descriptor Base Address High - RW */#define E1000_TDLEN 0x03808 /* TX Descriptor Length - RW */#define E1000_TDH 0x03810 /* TX Descriptor Head - RW */#define E1000_TDT 0x03818 /* TX Descripotr Tail - RW */#define E1000_TIPG 0x00410 /* TX Inter-packet gap -RW */#define E1000_TCTL_EN 0x00000002 /* enable tx */#define E1000_TCTL_BCE 0x00000004 /* busy check enable */#define E1000_TCTL_PSP 0x00000008 /* pad short packets */#define E1000_TCTL_CT 0x00000ff0 /* collision threshold */#define E1000_TCTL_COLD 0x003ff000 /* collision distance */#define E1000_TXD_CMD_RS 0x08000000 /* Report Status */#define E1000_TXD_STAT_DD 0x00000001 /* Descriptor Done */#define E1000_TXD_CMD_EOP 0x01000000 /* End of Packet */#define TX_MAX 64#define BUFSIZE 2048struct tx_desc&#123; uint64_t addr; uint16_t length; uint8_t cso; uint8_t cmd; uint8_t status; uint8_t css; uint16_t special;&#125;__attribute__((packed));struct tx_desc tx_list[TX_MAX];struct packets&#123; char buffer[BUFSIZE];&#125;__attribute__((packed));struct packets tx_buf[TX_MAX];void e1000_transmit_init();intfit_txd_for_E1000_transmit(void *addr, int length);#define RX_MAX 128#define E1000_RCTL_EN 0x00000002 /* enable */#define E1000_RCTL_SBP 0x00000004 /* store bad packet */#define E1000_RCTL_UPE 0x00000008 /* unicast promiscuous enable */#define E1000_RCTL_MPE 0x00000010 /* multicast promiscuous enab */#define E1000_RCTL_LPE 0x00000020 /* long packet enable */#define E1000_RCTL_LBM_NO 0x00000000 /* no loopback mode */#define E1000_RCTL_BAM 0x00008000 /* broadcast enable */#define E1000_RCTL_SZ_2048 0x00000000 /* rx buffer size 2048 */#define E1000_RCTL_SECRC 0x04000000 /* Strip Ethernet CRC */#define E1000_RXD_STAT_DD 0x01 /* Descriptor Done */#define E1000_RXD_STAT_EOP 0x02 /* End of Packet */#define E1000_RCTL 0x00100 /* RX Control - RW */#define E1000_RDBAL 0x02800 /* RX Descriptor Base Address Low - RW */#define E1000_RDBAH 0x02804 /* RX Descriptor Base Address High - RW */#define E1000_RDLEN 0x02808 /* RX Descriptor Length - RW */#define E1000_RDH 0x02810 /* RX Descriptor Head - RW */#define E1000_RDT 0x02818 /* RX Descriptor Tail - RW */#define E1000_MTA 0x05200 /* Multicast Table Array - RW Array */#define E1000_RA 0x05400 /* Receive Address - RW Array */#define E1000_RAH_AV 0x80000000 /* Receive descriptor valid */struct rx_desc&#123; uint64_t addr; uint16_t length; uint16_t pcs; uint8_t status; uint8_t errors; uint16_t special;&#125;__attribute__((packed));struct rx_desc rx_list[RX_MAX];int read_rxd_after_E1000_receive(void *addr);struct packets rx_buf[RX_MAX];void e1000_receive_init();int read_rxd_after_E1000_receive(void *addr);#endif // SOL &gt;= 6 ÊúÄÁªàÁöÑe1000.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;kern/e1000.h&gt;#include &lt;kern/pmap.h&gt;#include &lt;inc/string.h&gt;// LAB 6: Your driver code hereuint32_t *pci_e1000;inte1000_init(struct pci_func *pcif)&#123; pci_func_enable(pcif); pci_e1000 = mmio_map_region(pcif-&gt;reg_base[0], pcif-&gt;reg_size[0]); cprintf("the E1000 status register: [%08x]\n", *(pci_e1000+(E1000_STATUS&gt;&gt;2))); e1000_transmit_init(); e1000_receive_init(); return 1;&#125;voide1000_transmit_init()&#123; memset(tx_list, 0, sizeof(struct tx_desc)*TX_MAX); memset(tx_buf, 0, sizeof(struct packets)*TX_MAX); for(int i=0; i&lt;TX_MAX; i++)&#123; tx_list[i].addr = PADDR(tx_buf[i].buffer); tx_list[i].cmd = (E1000_TXD_CMD_EOP&gt;&gt;24) | (E1000_TXD_CMD_RS&gt;&gt;24); tx_list[i].status = E1000_TXD_STAT_DD; &#125; pci_e1000[E1000_TDBAL&gt;&gt;2] = PADDR(tx_list); pci_e1000[E1000_TDBAH&gt;&gt;2] = 0; pci_e1000[E1000_TDLEN&gt;&gt;2] = TX_MAX*sizeof(struct tx_desc); pci_e1000[E1000_TDH&gt;&gt;2] = 0; pci_e1000[E1000_TDT&gt;&gt;2] = 0; pci_e1000[E1000_TCTL&gt;&gt;2] |= (E1000_TCTL_EN | E1000_TCTL_PSP | (E1000_TCTL_CT &amp; (0x10&lt;&lt;4)) | (E1000_TCTL_COLD &amp; (0x40&lt;&lt;12))); pci_e1000[E1000_TIPG&gt;&gt;2] |= (10) | (4&lt;&lt;10) | (6&lt;&lt;20);&#125;intfit_txd_for_E1000_transmit(void *addr, int length)&#123; int tail = pci_e1000[E1000_TDT&gt;&gt;2]; struct tx_desc *tx_next = &amp;tx_list[tail]; if(length &gt; sizeof(struct packets)) length = sizeof(struct packets); if((tx_next-&gt;status &amp; E1000_TXD_STAT_DD) == E1000_TXD_STAT_DD)&#123; memmove(KADDR(tx_next-&gt;addr), addr, length); tx_next-&gt;status &amp;= !E1000_TXD_STAT_DD; tx_next-&gt;length = (uint16_t)length; pci_e1000[E1000_TDT&gt;&gt;2] = (tail + 1)%TX_MAX; return 0; &#125; return -1;&#125;voide1000_receive_init()&#123; for(int i=0; i&lt;RX_MAX; i++)&#123; memset(&amp;rx_list[i], 0, sizeof(struct rx_desc)); memset(&amp;rx_buf[i], 0, sizeof(struct packets)); rx_list[i].addr = PADDR(rx_buf[i].buffer); &#125; pci_e1000[E1000_MTA&gt;&gt;2] = 0; pci_e1000[E1000_RDBAL&gt;&gt;2] = PADDR(rx_list); pci_e1000[E1000_RDBAH&gt;&gt;2] = 0; pci_e1000[E1000_RDLEN&gt;&gt;2] = RX_MAX*sizeof(struct rx_desc); pci_e1000[E1000_RDH&gt;&gt;2] = 0; pci_e1000[E1000_RDT&gt;&gt;2] = RX_MAX - 1; pci_e1000[E1000_RCTL&gt;&gt;2] = (E1000_RCTL_EN | E1000_RCTL_BAM | E1000_RCTL_SZ_2048 | E1000_RCTL_SECRC); pci_e1000[E1000_RA&gt;&gt;2] = 0x52 | (0x54&lt;&lt;8) | (0x00&lt;&lt;16) | (0x12&lt;&lt;24); pci_e1000[(E1000_RA&gt;&gt;2) + 1] = (0x34) | (0x56&lt;&lt;8) | E1000_RAH_AV;&#125;intread_rxd_after_E1000_receive(void *addr)&#123; int head = pci_e1000[E1000_RDH&gt;&gt;2]; int tail = pci_e1000[E1000_RDT&gt;&gt;2]; tail = (tail + 1) % RX_MAX; struct rx_desc *rx_hold = &amp;rx_list[tail]; if((rx_hold-&gt;status &amp; E1000_TXD_STAT_DD) == E1000_TXD_STAT_DD)&#123; int len = rx_hold-&gt;length; memcpy(addr, rx_buf[tail].buffer, len); pci_e1000[E1000_RDT&gt;&gt;2] = tail; return len; &#125; return -1;&#125; Ê∑ªÂä† Á≥ªÁªüË∞ÉÁî®ÁöÑÂ∞±‰∏çË¥¥‰∫ÜÈÉΩ‰∏ÄÊ†∑„ÄÇinput.c1234567891011121314151617181920212223242526272829303132333435363738#include "ns.h"extern union Nsipc nsipcbuf;voidsleep(int msec)//ÁÆÄÂçïÁöÑÂª∂ËøüÂáΩÊï∞&#123; unsigned now = sys_time_msec(); unsigned end = now + msec; if ((int)now &lt; 0 &amp;&amp; (int)now &gt; -MAXERROR) panic("sys_time_msec: %e", (int)now); while (sys_time_msec() &lt; end) sys_yield();&#125;voidinput(envid_t ns_envid)&#123; binaryname = "ns_input"; // LAB 6: Your code here: // - read a packet from the device driver // - send it to the network server // Hint: When you IPC a page to the network server, it will be // reading from it for a while, so don't immediately receive // another packet in to the same physical page. char my_buf[2048]; int length; while(1)&#123; while((length = sys_packet_try_recv(my_buf))&lt;0) sys_yield(); nsipcbuf.pkt.jp_len=length; memcpy(nsipcbuf.pkt.jp_data, my_buf, length); ipc_send(ns_envid, NSREQ_INPUT, &amp;nsipcbuf, PTE_U | PTE_P); sleep(50); &#125;&#125; Âà∞Ëøô‰∏™Âú∞ÊñπÂü∫Êú¨‰∏äÂ∑≤ÁªèÂÖ®ÈÉ®ÁªìÊùü‰∫Ü„ÄÇÊúÄÂêéËÆ©‰Ω†ÂÆûÁé∞httpÁöÑÈÉ®ÂàÜ‰ª£Á†Å„ÄÇÊàë‰πüÁõ¥Êé•Áªô‰∫ÜÔºåÂõ†‰∏∫Â¶ÇÊûúË¶ÅÁêÜËß£Ë¶ÅÁúãÂÖ®ÈÉ®ÁöÑhttpÊ∫êÁ†Å„ÄÇ1234567891011121314static intsend_data(struct http_request *req, int fd)&#123; // LAB 6: Your code here. int n; char buf[BUFFSIZE]; while((n=read(fd,buf,(long)sizeof(buf)))&gt;0)&#123; if(write(req-&gt;sock,buf,n)!=n)&#123; die("Failed to send file to client"); &#125; &#125; return n; //panic("send_data not implemented");&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243static intsend_file(struct http_request *req)&#123; int r; off_t file_size = -1; int fd; // open the requested url for reading // if the file does not exist, send a 404 error using send_error // if the file is a directory, send a 404 error using send_error // set file_size to the size of the file // LAB 6: Your code here. if ((fd = open(req-&gt;url, O_RDONLY)) &lt; 0) &#123; send_error(req, 404); goto end; &#125; struct Stat stat; fstat(fd, &amp;stat); if (stat.st_isdir) &#123; send_error(req, 404); goto end; &#125; //panic("send_file not implemented"); if ((r = send_header(req, 200)) &lt; 0) goto end; if ((r = send_size(req, file_size)) &lt; 0) goto end; if ((r = send_content_type(req)) &lt; 0) goto end; if ((r = send_header_fin(req)) &lt; 0) goto end; r = send_data(req, fd);end: close(fd); return r;&#125; Ëá≥Ê≠§all is over „ÄÇ]]></content>
      <categories>
        <category>Êìç‰ΩúÁ≥ªÁªü</category>
        <category>MIT6.828</category>
      </categories>
      <tags>
        <tag>MIT6.282</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT6.828 (‰∫î)Lab5:File system, Spawn and Shell]]></title>
    <url>%2F2020%2F02%2F18%2FMIT-6.828-(%E4%BA%94)-Lab-5-File-system%2C-Spawn-and-Shell%2F</url>
    <content type="text"><![CDATA[ÈáçË¶ÅÁöÑÂâçÈù¢Âü∫Êú¨‰∏äÂ∑≤ÁªèÂÅö‰∫ÜÔºåÁé∞Âú®Â∞±Ââ©‰∏ãlab5‰∫Ü„ÄÇÂØπ‰∫éËøô‰∏™ÂÆûÈ™åÊú¨Ë∫´Ë¶Å‰Ω†ÂÜôÁöÑ‰ª£Á†Å‰∏çÂ§öÔºå‰ΩÜÊòØË¶ÅËá™Â∑±ÂéªÁúãÁöÑË¥º‰ªñÂ¶àÁöÑÂ§ö„ÄÇÂéüË∞ÖÊàëÂ§çÂà∂Á≤òË¥¥Âà´‰∫∫ÁöÑ„ÄÇ Lab 5: File system, Spawn and ShellÂú®Êú¨ÂÆûÈ™å‰∏≠ÔºåÊàë‰ª¨Â∞ÜÂÆûÁé∞spawnÂ∫ìË∞ÉÁî®Áî®‰ª•Âä†ËΩΩÂíåËøêË°åÁ£ÅÁõò‰∏äÁöÑÂèØÊâßË°åÊñá‰ª∂„ÄÇÁÑ∂ÂêéÔºåJOSÂÜÖÊ†∏ÂíåÂ∫ìÊûÑÊàêÁöÑÊìç‰ΩúÁ≥ªÁªüÂ∞ÜË∂≥‰ª•Âú®ÊéßÂà∂Âè∞‰∏äËøêË°åshell‰∫Ü„ÄÇËøô‰∫õÂäüËÉΩÈúÄË¶Å‰∏Ä‰∏™Êñá‰ª∂Á≥ªÁªüÔºåÊú¨ÂÆûÈ™åÂ∞Ü‰ªãÁªç‰∫Ü‰∏Ä‰∏™ÁÆÄÂçïÁöÑËØª/ÂÜôÊñá‰ª∂Á≥ªÁªü„ÄÇ ÂàáÊç¢‰∏Ä‰∏ãÂàÜÊîØÔºå‰ºöÂ§öÂá∫Êù•Âá†‰∏™Êñá‰ª∂ÔºåÊñá‰ª∂Âπ≤Âï•ÁöÑÂ•ΩÂ•ΩÁúãÁúã„ÄÇ fs/fs.c Êìç‰ΩúÊñá‰ª∂Á≥ªÁªüÂú®Á£ÅÁõò‰∏äÁöÑÁªìÊûÑÔºåÁêÜËß£ÊàêÊñá‰ª∂ÂÇ®Â≠òÁªìÊûÑ fs/bc.c Âü∫‰∫éÁî®Êà∑Á∫ßÈ°µÈîôËØØÂ§ÑÁêÜÊú∫Âà∂ÁöÑÂùóÁºìÂ≠ò„ÄÇ fs/ide.c ÊúÄÂ∞èÂåñÁöÑÂü∫‰∫éPIOÔºàÈùû‰∏≠Êñ≠È©±Âä®ÁöÑÔºâÁöÑIDEÁ£ÅÁõòÈ©±Âä®„ÄÇÁ£ÅÁõòÈ©±Âä®Áü•ÈÅìÊÄé‰πàË∞ÉÁî®Â∞±Ë°å fs/serv.c Êñá‰ª∂Á≥ªÁªüÊúçÂä°Á´Ø‰ª£Á†ÅÔºåÂÆ¢Êà∑Á´ØÁî®Êà∑ÁéØÂ¢ÉÈÄöËøáIPC‰∏é‰πã‰∫§‰∫íÔºå‰Ω†Â∞±ÂΩìÂÅöÂÜÖÊ†∏ËøõË°åÁ≥ªÁªüË∞ÉÁî®Âêß lib/fd.c ÂÆûÁé∞ÈÄöÂ∏∏ÁöÑUNIXÈ£éÊ†ºÁöÑÊñá‰ª∂ÊèèËø∞Á¨¶Êé•Âè£„ÄÇ lib/file.c Á£ÅÁõòÊñá‰ª∂Á±ªÂûãÁöÑÈ©±Âä®ÔºåÂÆûÁé∞‰∏∫Êñá‰ª∂Á≥ªÁªüIPCÂÆ¢Êà∑Á´Ø„ÄÇ lib/console.c ÊéßÂà∂Âè∞I/OÊñá‰ª∂Á±ªÂûãÁöÑÈ©±Âä® lib/spawn.c spawnÂ∫ìË∞ÉÁî®ÂÆûÁé∞ Ëøô‰∫õÊñá‰ª∂ÂêéÈù¢ÈÉΩ‰ºöË¶ÅÁúã‰∏ÄÁúãÁöÑ‰∏çÁî®ÊÖå„ÄÇ ÂºÄÂú∫ËÆ©ÊàëÂÖàËØïËØïÊ∞¥ÔºåËøòËÉΩ‰∏çËÉΩËøêË°ålab4ÁöÑpingpong,primes,forktreeÔºåË¶ÅÂÖàÊääkern/init.c‰∏≠ÁöÑENV_CREATE(fs_fs)Âíålib/exit.cÁöÑclose_all()Ê≥®ÈáäÊéâ„ÄÇÊàë‰ª¨ÂéªÁúãÁúã‰ªñÂÅö‰∫ÜÂï•„ÄÇÊàë‰ª¨ÂÖàÁúãÁúãinit.cÈáåÈù¢ÁöÑÂàùÂßãÂåñÂáΩÊï∞„ÄÇ1234567891011121314151617181920212223242526272829303132333435363738394041424344454647voidi386_init(void)&#123; // Initialize the console. // Can't call cprintf until after we do this! cons_init(); cprintf("6828 decimal is %o octal!\n", 6828); // Lab 2 memory management initialization functions mem_init(); // Lab 3 user environment initialization functions env_init(); trap_init(); // Lab 4 multiprocessor initialization functions mp_init(); lapic_init(); // Lab 4 multitasking initialization functions pic_init(); // Acquire the big kernel lock before waking up APs // Your code here: lock_kernel(); // Starting non-boot CPUs boot_aps(); //‰∏ä‰∏™ÂÆûÈ™åÈÉΩÊòØ‰∏ÄÊ†∑ÁöÑÔºåÂêéÈù¢ÊâçÂºÄÂßã‰∏çÂêå // Start fs. ENV_CREATE(fs_fs, ENV_TYPE_FS);//ËøôËÇØÂÆöÊòØËøêË°å‰∫Ü‰∏Ä‰∏™ Á®ãÂ∫èÊòØÂï•Âë¢ÔºüÁúã‰∏çÂá∫Êù•Ôºå‰ΩÜÊòØÊ†πÊçÆËæìÂá∫ //ÊúÄÂêéÊé®Êñ≠Âá∫Êù•ÊòØ fs/serv.c ÈáåÈù¢ÁöÑumain#if defined(TEST) // Don't touch -- used by grading script! ENV_CREATE(TEST, ENV_TYPE_USER);#else // Touch all you want. ENV_CREATE(user_icode, ENV_TYPE_USER);//Ëøô‰∏™ÂêéÈù¢ÂÜçËØ¥#endif // TEST* // Should not be necessary - drains keyboard because interrupt has given up. kbd_intr();//‰∏çÁî®ÁÆ°„ÄÇ // Schedule and run the first user environment! sched_yield();&#125; ÁúãÂÆå‰πãÂêéÔºåÂèëÁé∞Â∞±ÊòØÂ§ö‰∫Ü‰∏Ä‰∏™ËøõÁ®ãËÄåÂ∑≤ÔºåÂÖ∂‰ªñÈÉΩÊ≤°ÊÄé‰πàÂèò„ÄÇÈÇ£‰∏™ËøõÁ®ãÂ∫îËØ•ÊòØËøêË°å‰∫Üserv.cÔºåÊàë‰ª¨ÁÆÄÂçïÁúã‰∏Ä‰∏ãmainÂáΩÊï∞ÔºåÂÖ∑‰ΩìÂÅö‰∫ÜÂï•ÔºåÂêéÈù¢ÂÜçËØ¥„ÄÇ12345678910111213141516voidumain(int argc, char **argv)&#123; static_assert(sizeof(struct File) == 256);//Ê£ÄÊü•ÁªìÊûÑ binaryname = "fs"; cprintf("FS is running\n"); // Check that we are able to do I/O outw(0x8A00, 0x8A00); cprintf("FS can do I/O\n");//Ê£ÄÊü•‰∏Ä‰∏ãFS serve_init();//ÊúçÂä°ÂàùÂßãÂåñ fs_init();//fsÂàùÂßãÂåñ fs_test();//ÊµãËØï serve();//ËøêË°åÊúçÂä°&#125; closeall()1234567891011121314151617181920intclose(int fdnum)&#123; struct Fd *fd; int r; if ((r = fd_lookup(fdnum, &amp;fd)) &lt; 0) return r; else return fd_close(fd, 1);&#125;voidclose_all(void)&#123; int i; for (i = 0; i &lt; MAXFD; i++) close(i);&#125; Â∫îËØ•Â∞±ÊòØÂÖ≥Èó≠ÊâÄÊúâÊñá‰ª∂ÁöÑÊÑèÊÄù„ÄÇÊääËøô‰∏§Ë°åÊ≥®ÈáäÊéâÔºåÂ∞±ÂèØ‰ª•Ê≠£Â∏∏ËøêË°ålab4ÁöÑÊµãËØï„ÄÇ ÂêéÈù¢ÊòØ‰∏ÄÂ§ßÂ†ÜÁêÜËÆ∫ÊÖ¢ÊÖ¢Áúã„ÄÇ File system preliminariesÊàë‰ª¨Â∞ÜË¶ÅÂÆûÁé∞ÁöÑÊñá‰ª∂Á≥ªÁªüËôΩÁÑ∂ÊØîÁúüÂÆûÁöÑÊñá‰ª∂Á≥ªÁªüÁÆÄÂçïÁöÑÂ§öÔºå‰ΩÜÊòØ‰πüË∂≥‰ª•Êèê‰æõ‰∏Ä‰∫õÂü∫Êú¨ÁöÑÁâπÊÄßÔºöÂàõÂª∫„ÄÅËØª„ÄÅÂÜô„ÄÅÂà†Èô§ÁªÑÁªáÂú®ÁõÆÂΩïÁªìÊûÑÂ±ÇÊ¨°‰∏≠ÁöÑÊñá‰ª∂„ÄÇ Êàë‰ª¨Áé∞Âú®ÔºàÁõÆÂâç‰∏∫Ê≠¢ÔºâÂè™ÂºÄÂèëÂçïÁî®Êà∑Êìç‰ΩúÁ≥ªÁªüÔºåÂÆÉÊèê‰æõË∂≥Â§üÁöÑ‰øùÊä§Êù•ÊçïÊçâÈîôËØØÔºå‰ΩÜ‰∏çËÉΩ‰øùÊä§ÂèØÁñëÁöÑÁî®Êà∑Á®ãÂ∫è‰πãÈó¥ÁöÑÂπ≤Êâ∞„ÄÇÂõ†Ê≠§ÔºåÊàë‰ª¨ÁöÑÊñá‰ª∂Á≥ªÁªü‰∏çÊîØÊåÅÊñá‰ª∂ÊâÄÊúâÊùÉÊàñÊùÉÈôêÁöÑUNIXÊ¶ÇÂøµ„ÄÇÊàë‰ª¨ÁöÑÊñá‰ª∂Á≥ªÁªüÁõÆÂâçËøò‰∏çÊîØÊåÅÂÉèÂ§ßÂ§öÊï∞UNIXÊñá‰ª∂Á≥ªÁªüÈÇ£Ê†∑ÁöÑÁ°¨ÈìæÊé•ÔºåÁ¨¶Âè∑ÈìæÊé•ÔºåÊó∂Èó¥Êà≥ÊàñÁâπÊÆäÁöÑËÆæÂ§áÊñá‰ª∂„ÄÇ On-Disk File System StructureÂ§ßÂ§öÊï∞UNIXÊñá‰ª∂Á≥ªÁªüÂ∞ÜÂèØÁî®Á£ÅÁõòÁ©∫Èó¥ÂàÜ‰∏∫‰∏§Áßç‰∏ªË¶ÅÁ±ªÂûãÁöÑÂå∫ÂüüÔºöinodeÂå∫ÂüüÂíåÊï∞ÊçÆÂå∫Âüü„ÄÇ UNIXÊñá‰ª∂Á≥ªÁªü‰∏∫Êñá‰ª∂Á≥ªÁªü‰∏≠ÁöÑÊØè‰∏™Êñá‰ª∂ÂàÜÈÖç‰∏Ä‰∏™inode;Êñá‰ª∂ÁöÑinode‰øùÂ≠òÂÖ≥‰∫éÊñá‰ª∂ÁöÑÂÖ≥ÈîÆÂÖÉÊï∞ÊçÆÔºå‰æãÂ¶ÇÂÖ∂statÂ±ûÊÄßÂíåÊåáÂêëÂÖ∂Êï∞ÊçÆÂùóÁöÑÊåáÈíà„ÄÇÊï∞ÊçÆÂå∫ÂüüË¢´ÂàíÂàÜÊàêÊõ¥Â§ßÔºàÈÄöÂ∏∏‰∏∫8KBÊàñÊõ¥Â§öÔºâÁöÑÊï∞ÊçÆÂùóÔºåÊñá‰ª∂Á≥ªÁªüÂú®ÂÖ∂‰∏≠Â≠òÂÇ®Êñá‰ª∂Êï∞ÊçÆÂíåÁõÆÂΩïÂÖÉÊï∞ÊçÆ„ÄÇÁõÆÂΩïÊù°ÁõÆÂåÖÂê´Êñá‰ª∂ÂêçÂíåÊåáÂêëinodeÁöÑÊåáÈíà;Â¶ÇÊûúÊñá‰ª∂Á≥ªÁªü‰∏≠ÁöÑÂ§ö‰∏™ÁõÆÂΩïÊù°ÁõÆÂºïÁî®ËØ•Êñá‰ª∂ÁöÑinodeÔºåÂàôÊñá‰ª∂Ë¢´Áß∞‰∏∫Á°¨ÈìæÊé•„ÄÇÁî±‰∫éÊàë‰ª¨ÁöÑÊñá‰ª∂Á≥ªÁªü‰∏çÊîØÊåÅÁ°¨ÈìæÊé•ÔºåÊâÄ‰ª•Êàë‰ª¨‰∏çÈúÄË¶ÅËøôÁßçÁ∫ßÂà´ÁöÑÈáçÂÆöÂêëÔºåÂõ†Ê≠§ÂèØ‰ª•Êñπ‰æøÁöÑÁÆÄÂåñÔºöÊàë‰ª¨ÁöÑÊñá‰ª∂Á≥ªÁªüÊ†πÊú¨‰∏ç‰ºö‰ΩøÁî®inodeÔºåËÄåÂè™ÊòØÂú®ÔºàÂîØ‰∏ÄÔºâÁöÑÁõÆÂΩïÊù°ÁõÆ‰∏≠Â≠òÂÇ®ÊâÄÊúâÁöÑÊñá‰ª∂ÔºàÊàñÂ≠êÁõÆÂΩïÔºâÁöÑÂÖÉÊï∞ÊçÆ„ÄÇ Êñá‰ª∂ÂíåÁõÆÂΩïÈÄªËæë‰∏äÈÉΩÊòØÁî±‰∏ÄÁ≥ªÂàóÊï∞ÊçÆÂùóÁªÑÊàêÁöÑÔºåËøô‰∫õÊï∞ÊçÆÂùóÂèØËÉΩÊï£Â∏ÉÂú®Êï¥‰∏™Á£ÅÁõò‰∏äÔºåÂ∞±ÂÉèÁî®Êà∑ÁéØÂ¢ÉÁöÑËôöÊãüÂú∞ÂùÄÁ©∫Èó¥ÁöÑÈ°µÈù¢ÂèØ‰ª•ÂàÜÊï£Âú®Êï¥‰∏™Áâ©ÁêÜÂÜÖÂ≠ò‰∏≠‰∏ÄÊ†∑„ÄÇÊñá‰ª∂Á≥ªÁªüÁéØÂ¢ÉÈöêËóèÊï∞ÊçÆÂùóÂ∏ÉÂ±ÄÁöÑÁªÜËäÇÔºå‰ªÖÂëàÁé∞Âú®Êñá‰ª∂‰ªªÊÑèÂÅèÁßªÈáèÂ§ÑËØª/ÂÜôÂ≠óËäÇÂ∫èÂàóÁöÑÊé•Âè£„ÄÇÊñá‰ª∂Á≥ªÁªüÁéØÂ¢ÉÂ∞ÜÂØπÁõÆÂΩïÁöÑÊâÄÊúâ‰øÆÊîπ‰Ωú‰∏∫Êñá‰ª∂ÂàõÂª∫ÂíåÂà†Èô§Á≠âÊìç‰ΩúÂÜÖÈÉ®Â§ÑÁêÜÁöÑ‰∏ÄÈÉ®ÂàÜ„ÄÇÊàë‰ª¨ÁöÑÊñá‰ª∂Á≥ªÁªüÂÖÅËÆ∏Áî®Êà∑ÁéØÂ¢ÉÁõ¥Êé•ËØªÂèñÁõÆÂΩïÂÖÉÊï∞ÊçÆÔºà‰æãÂ¶ÇÔºåreadÔºâÔºåËøôÊÑèÂë≥ÁùÄÁî®Êà∑ÁéØÂ¢ÉÂèØ‰ª•Ëá™Â∑±ÊâßË°åÁõÆÂΩïÊâ´ÊèèÊìç‰ΩúÔºà‰æãÂ¶ÇÔºåÂÆûÁé∞lsÁ®ãÂ∫èÔºâÔºåËÄå‰∏çÂøÖ‰æùËµñÈ¢ùÂ§ñÁâπÊÆäÁöÑÂØπÊñá‰ª∂Á≥ªÁªüÁöÑË∞ÉÁî®„ÄÇÂØπÁõÆÂΩïÊâ´ÊèèÊñπÊ≥ïÁöÑÁº∫ÁÇπÔºå‰ª•ÂèäÂ§ßÂ§öÊï∞Áé∞‰ª£UNIXÂèò‰ΩìÈòªÊ≠¢ÂÆÉÁöÑÂéüÂõ†Âú®‰∫éÂÆÉ‰ΩøÂ∫îÁî®Á®ãÂ∫è‰æùËµñ‰∫éÁõÆÂΩïÂÖÉÊï∞ÊçÆÁöÑÊ†ºÂºèÔºå‰ΩøÂæóÂú®‰∏çÊõ¥ÊîπÊàñËá≥Â∞ëÈáçÊñ∞ÁºñËØëÂ∫îÁî®Á®ãÂ∫èÁöÑÊÉÖÂÜµ‰∏ãÈöæ‰ª•Êõ¥ÊîπÊñá‰ª∂Á≥ªÁªüÁöÑÂÜÖÈÉ®Â∏ÉÂ±Ä„ÄÇ ÁÆÄÂçïÊù•ËÆ≤ÔºåÊàë‰ª¨Êñá‰ª∂Á≥ªÁªüÂ∞±Âè™Êúâ‰∏Ä‰∏™Êï∞ÊçÆÁªìÊûÑ‰øùÂ≠òÊñá‰ª∂ÔºåÊ≤°ÊúâÁ¥¢Âºï„ÄÇ Sectors and BlocksÂ§ßÂ§öÊï∞Á£ÅÁõò‰∏çËÉΩ‰ª•Â≠óËäÇÁ≤íÂ∫¶ÊâßË°åËØªÂèñÂíåÂÜôÂÖ•ÔºåËÄåÊòØ‰ª•ÊâáÂå∫‰∏∫Âçï‰ΩçÊâßË°åËØªÂèñÂíåÂÜôÂÖ•Êìç‰Ωú„ÄÇÂú®JOS‰∏≠ÔºåÊâáÂå∫‰∏∫512Â≠óËäÇ„ÄÇÊñá‰ª∂Á≥ªÁªüÂÆûÈôÖ‰∏ä‰ª•Âùó‰∏∫Âçï‰ΩçÂàÜÈÖçÂíå‰ΩøÁî®Á£ÅÁõòÂ≠òÂÇ®„ÄÇËØ∑Ê≥®ÊÑè‰∏§‰∏™ÊúØËØ≠‰πãÈó¥ÁöÑÂå∫Âà´ÔºöÊâáÂå∫Â§ßÂ∞èÊòØÁ£ÅÁõòÁ°¨‰ª∂ÁöÑÂ±ûÊÄßÔºåËÄåÂùóÂ§ßÂ∞èÊòØÊìç‰ΩúÁ≥ªÁªü‰ΩøÁî®Á£ÅÁõòÁöÑ‰∏Ä‰∏™ÊñπÈù¢„ÄÇÊñá‰ª∂Á≥ªÁªüÁöÑÂùóÂ§ßÂ∞èÂøÖÈ°ªÊòØÂ∫ïÂ±ÇÁ£ÅÁõòÊâáÂå∫Â§ßÂ∞èÁöÑÂÄçÊï∞„ÄÇ UNIX xv6Êñá‰ª∂Á≥ªÁªü‰ΩøÁî®512Â≠óËäÇÁöÑÂùóÂ§ßÂ∞èÔºå‰∏éÂ∫ïÂ±ÇÁ£ÅÁõòÁöÑÊâáÂå∫Â§ßÂ∞èÁõ∏Âêå„ÄÇÁÑ∂ËÄåÔºåÂ§ßÂ§öÊï∞Áé∞‰ª£Êñá‰ª∂Á≥ªÁªü‰ΩøÁî®Êõ¥Â§ßÁöÑÂùóÂ§ßÂ∞èÔºåÂõ†‰∏∫Â≠òÂÇ®Á©∫Èó¥Â∑≤ÁªèÂèòÂæóÊõ¥‰æøÂÆúÔºåÂπ∂‰∏î‰ª•Êõ¥Â§ßÁöÑÁ≤íÂ∫¶Êù•ÁÆ°ÁêÜÂ≠òÂÇ®ÊïàÁéáÊõ¥È´ò„ÄÇÊàë‰ª¨ÁöÑÊñá‰ª∂Á≥ªÁªüÂ∞Ü‰ΩøÁî®4096Â≠óËäÇÁöÑÂùóÂ§ßÂ∞èÔºåÊñπ‰æøÂú∞ÂåπÈÖçÂ§ÑÁêÜÂô®ÁöÑÈ°µÈù¢Â§ßÂ∞è„ÄÇ ÁÆÄÂçïÊù•ËÆ≤ÔºåÁ£ÅÁõòÈªòËÆ§512Â≠óËäÇÊòØ‰∏Ä‰∏™ÊâáÂå∫ÔºåÊàë‰ª¨Á≥ªÁªü4096Â≠óËäÇ‰∏Ä‰∏™ÂùóÔºå‰πüÂ∞±ÊòØ8‰∏™ÊâáÂå∫‰∏Ä‰∏™Âùó„ÄÇ SuperblocksÊñá‰ª∂Á≥ªÁªüÈÄöÂ∏∏Â∞ÜÊüê‰∫õÁ£ÅÁõòÂùó‰øùÁïôÂú®Á£ÅÁõò‰∏äÁöÑ‚ÄúÊòì‰∫éÊü•Êâæ‚Äù‰ΩçÁΩÆÔºà‰æãÂ¶ÇËµ∑ÂßãÊàñÊúÄÂêéÔºâÔºå‰ª•‰øùÂ≠òÊèèËø∞Êï¥‰∏™Êñá‰ª∂Á≥ªÁªüÂ±ûÊÄßÁöÑÂÖÉÊï∞ÊçÆÔºå‰æãÂ¶ÇÂùóÂ§ßÂ∞èÔºåÁ£ÅÁõòÂ§ßÂ∞èÔºåÊâæÂà∞Ê†πÁõÆÂΩïÊâÄÈúÄÁöÑ‰ªª‰ΩïÂÖÉÊï∞ÊçÆÔºåÊñá‰ª∂Á≥ªÁªü‰∏äÊ¨°ÊåÇËΩΩÁöÑÊó∂Èó¥ÔºåÊñá‰ª∂Á≥ªÁªü‰∏äÊ¨°Ê£ÄÊü•ÈîôËØØÁöÑÊó∂Èó¥Á≠âÁ≠â„ÄÇËøô‰∫õÁâπÊÆäÂùóÁß∞‰∏∫Ë∂ÖÁ∫ßÂùó„ÄÇ Êàë‰ª¨ÁöÑÊñá‰ª∂Á≥ªÁªüÂ∞ÜÂè™Êúâ‰∏Ä‰∏™Ë∂ÖÁ∫ßÂùóÔºåÂÆÉÂ∞ÜÂßãÁªà‰Ωç‰∫éÁ£ÅÁõò‰∏äÁöÑÂùó1„ÄÇÂÆÉÁöÑÂ∏ÉÂ±ÄÁî±struct SuperÂú®inc/fs.h‰∏≠ÂÆö‰πâ„ÄÇÂùó0ÈÄöÂ∏∏‰øùÁïôÁî®‰∫é‰øùÂ≠òÂºïÂØºÂä†ËΩΩÁ®ãÂ∫èÂíåÂàÜÂå∫Ë°®ÔºåÂõ†Ê≠§Êñá‰ª∂Á≥ªÁªüÈÄöÂ∏∏‰∏ç‰ΩøÁî®Á¨¨‰∏Ä‰∏™Á£ÅÁõòÂùó„ÄÇËÆ∏Â§ö‚ÄúÁúüÊ≠£ÁöÑ‚ÄùÊñá‰ª∂Á≥ªÁªüÂÖ∑ÊúâÂ§ö‰∏™Ë∂ÖÁ∫ßÂùóÔºåËøôÂá†‰∏™ÂâØÊú¨Âú®Á£ÅÁõòÁöÑÂá†‰∏™ÂπøÊ≥õÈó¥ÈöîÁöÑÂå∫ÂüüÔºå‰ª•‰æøÂ¶ÇÊûúÂÖ∂‰∏≠‰∏Ä‰∏™Ë¢´ÊçüÂùèÊàñÁ£ÅÁõòÂú®ËØ•Âå∫Âüü‰∏≠‰∫ßÁîüÂ™í‰ΩìÈîôËØØÔºåÂàô‰ªçÁÑ∂ÂèØ‰ª•ÊâæÂà∞ÂÖ∂‰ªñË∂ÖÁ∫ßÂùóÔºåÂπ∂Â∞ÜÂÖ∂Áî®‰∫éËÆøÈóÆÊñá‰ª∂Á≥ªÁªü„ÄÇ ÁÆÄÂçïÊù•ËÆ≤ÔºåÂùó0Êàë‰ª¨Áî®‰∫ÜÔºåÂú®ÂâçÈù¢ËÆ≤ËøáÔºåÂùó1Â∞±ÊòØ‰øùÂ≠ò‰∫Ü‰∏Ä‰∫õÁ£ÅÁõòÂ∏ÉÂ±ÄÔºåÂ∞§ÂÖ∂ÊòØÊ†πÁõÆÂΩï„ÄÇ‰∏≠Èó¥ÂèØËÉΩ‰ºöÊúâ‰∏Ä‰∫õÂùóÁî®‰∫éÁ£ÅÁõòÊÅ¢Â§çÔºåËøòÊúâ‰ΩçÂõæ„ÄÇ12345struct Super &#123; uint32_t s_magic; // Magic number: FS_MAGIC Âï•ÁºñÂè∑ uint32_t s_nblocks; // Total number of blocks on disk ÊÄªÂÖ±ÂùóÊï∞ struct File s_root; // Root directory node Ê†πÁõÆÂΩï&#125;; File Meta-dataÊèèËø∞Êñá‰ª∂Á≥ªÁªü‰∏≠ÁöÑÊñá‰ª∂ÁöÑÂÖÉÊï∞ÊçÆÁöÑÂ∏ÉÂ±ÄÁî±inc/fs.h‰∏≠ÁöÑstruct FileÂÆö‰πâ„ÄÇËØ•ÂÖÉÊï∞ÊçÆÂåÖÊã¨Êñá‰ª∂ÁöÑÂêçÁß∞ÔºåÂ§ßÂ∞èÔºåÁ±ªÂûãÔºàÂ∏∏ËßÑÊñá‰ª∂ÊàñÁõÆÂΩïÔºâ‰ª•ÂèäÊåáÂêëÂåÖÂê´ËØ•Êñá‰ª∂ÁöÑÂùóÁöÑÊåáÈíà„ÄÇÂ¶Ç‰∏äÊâÄËø∞ÔºåÊàë‰ª¨Ê≤°ÊúâinodeÔºåÊâÄ‰ª•ÂÖÉÊï∞ÊçÆÂ≠òÂÇ®Âú®Á£ÅÁõò‰∏äÁöÑÁõÆÂΩïÊù°ÁõÆ‰∏≠„ÄÇ‰∏éÂ§ßÂ§öÊï∞‚ÄúÁúüÂÆû‚ÄùÊñá‰ª∂Á≥ªÁªü‰∏çÂêåÔºå‰∏∫ÁÆÄÂçïËµ∑ËßÅÔºåÊàë‰ª¨Â∞Ü‰ΩøÁî®Ëøô‰∏™struct FileÊù•Ë°®Á§∫Âú®Á£ÅÁõòÂíåÂÜÖÂ≠ò‰∏≠Âá∫Áé∞ÁöÑÊñá‰ª∂ÂÖÉÊï∞ÊçÆ„ÄÇ struct File‰∏≠ÁöÑf_directÊï∞ÁªÑÂåÖÂê´Â≠òÂÇ®Êñá‰ª∂Ââç10‰∏™ÔºàNDIRECTÔºâÂùóÁöÑÂùóÂè∑ÁöÑÁ©∫Èó¥ÔºåËøôÂâç10‰∏™ÂùóË¢´Áß∞‰πã‰∏∫Êñá‰ª∂ÁöÑÁõ¥Êé•Âùó„ÄÇÂØπ‰∫éÂ§ßÂ∞è‰∏∫10 * 4096 = 40KBÁöÑÂ∞èÊñá‰ª∂ÔºåËøôÊÑèÂë≥ÁùÄÊâÄÊúâÊñá‰ª∂ÂùóÁöÑÂùóÂè∑Â∞ÜÁõ¥Êé•ÈÄÇÁî®‰∫éstruct FileÊú¨Ë∫´„ÄÇÁÑ∂ËÄåÔºåÂØπ‰∫éËæÉÂ§ßÁöÑÊñá‰ª∂ÔºåÊàë‰ª¨ÈúÄË¶Å‰∏Ä‰∏™Âú∞ÊñπÊù•‰øùÂ≠òÊñá‰ª∂ÁöÑÂÖ∂‰ªñÂùóÂè∑„ÄÇÂõ†Ê≠§ÔºåÂØπ‰∫éÂ§ß‰∫é40KBÁöÑ‰ªª‰ΩïÊñá‰ª∂ÔºåÊàë‰ª¨ÂàÜÈÖç‰∏Ä‰∏™È¢ùÂ§ñÁöÑÁ£ÅÁõòÂùóÔºåÁß∞‰∏∫Êñá‰ª∂ÁöÑÈó¥Êé•ÂùóÔºåÊúÄÂ§öÂÆπÁ∫≥4096/4 = 1024‰∏™ÈôÑÂä†ÂùóÂè∑„ÄÇÂõ†Ê≠§ÔºåÊàë‰ª¨ÁöÑÊñá‰ª∂Á≥ªÁªüÂÖÅËÆ∏Êñá‰ª∂ÁöÑÂ§ßÂ∞èÂèØËææ1034‰∏™ÂùóÔºåÊàñËÄÖÂàöÂàöË∂ÖËøáÂõõÂÖÜÂ≠óËäÇÂ§ßÂ∞è„ÄÇ‰∏∫‰∫ÜÊîØÊåÅÊõ¥Â§ßÁöÑÊñá‰ª∂Ôºå‚ÄúÁúüÂÆû‚ÄùÊñá‰ª∂Á≥ªÁªüÈÄöÂ∏∏‰πüÊîØÊåÅÂèåÈáçÂíå‰∏âÈáçÈó¥Êé•Âùó„ÄÇÁÆÄÂçïÊù•ËÆ≤ÔºåÂÇ®Â≠òÊñá‰ª∂Êàë‰ª¨Áî® struct FileÔºåÂ∞è‰∫é10‰∏™ÂùóÊàë‰ª¨Áõ¥Êé•ÂÇ®Â≠òÔºåË∂ÖËøá10‰∏™ÂùóÂºÄ‰∏Ä‰∏™Èó¥Êé•ÂùóÊ†áËÆ∞ÈÇ£Âá†‰∏™Âùó123456789101112131415struct File &#123; char f_name[MAXNAMELEN]; // filename Êñá‰ª∂Âêç off_t f_size; // file size in bytes Êñá‰ª∂Â§ßÂ∞è uint32_t f_type; // file type Êñá‰ª∂Á±ªÂûã // Block pointers. // A block is allocated iff its value is != 0. uint32_t f_direct[NDIRECT]; // direct blocks Áõ¥Êé•Âùó uint32_t f_indirect; // indirect block Èó¥Êé•Âùó // Pad out to 256 bytes; must do arithmetic in case we're compiling // fsformat on a 64-bit machine. //Â°´Êª°256Â≠óËäÇÔºåËÉΩÂ§ü 64‰ΩçÊú∫‰∏äËøêË°å sizeof(struct File)ÂàöÂ•Ω256. uint8_t f_pad[256 - MAXNAMELEN - 8 - 4*NDIRECT - 4];&#125; __attribute__((packed)); // required only on some 64-bit machines Directories versus Regular FilesÊàë‰ª¨ÁöÑÊñá‰ª∂Á≥ªÁªü‰∏≠ÁöÑstruct FileÂèØ‰ª•Ë°®Á§∫Â∏∏ËßÑÊñá‰ª∂ÊàñÁõÆÂΩï;Ëøô‰∏§ÁßçÁ±ªÂûãÁöÑ‚ÄúÊñá‰ª∂‚ÄùÈÄöËøástruct File‰∏≠ÁöÑÁ±ªÂûãÂ≠óÊÆµËøõË°åÂå∫ÂàÜ„ÄÇÊñá‰ª∂Á≥ªÁªü‰ª•ÂÆåÂÖ®Áõ∏ÂêåÁöÑÊñπÂºèÁÆ°ÁêÜÂ∏∏ËßÑÊñá‰ª∂ÂíåÁõÆÂΩïÊñá‰ª∂ÔºåÈô§‰∫ÜÂÆÉ‰∏çËß£Èáä‰∏éÂ∏∏ËßÑÊñá‰ª∂Áõ∏ÂÖ≥ËÅîÁöÑÊï∞ÊçÆÂùóÁöÑÂÜÖÂÆπÔºåËÄåÊñá‰ª∂Á≥ªÁªüÂ∞ÜÁõÆÂΩïÊñá‰ª∂ÁöÑÂÜÖÂÆπËß£Èáä‰∏∫‰∏ÄÁ≥ªÂàóÊèèËø∞ÁõÆÂΩï‰∏≠ÁöÑÊñá‰ª∂ÂíåÂ≠êÁõÆÂΩïÁöÑstruct File„ÄÇ123// File types#define FTYPE_REG 0 // Regular file Êñá‰ª∂#define FTYPE_DIR 1 // Directory ÁõÆÂΩï Êàë‰ª¨ÁöÑÊñá‰ª∂Á≥ªÁªü‰∏≠ÁöÑË∂ÖÁ∫ßÂùóÂåÖÂê´‰∏Ä‰∏™struct FileÔºàÂÖ∂ÂÆûstruct Super‰∏≠ÁöÑÊ†πÂ≠óÊÆµÔºâÔºåÂÆÉ‰øùÂ≠òÊñá‰ª∂Á≥ªÁªüÊ†πÁõÆÂΩïÁöÑÂÖÉÊï∞ÊçÆ„ÄÇÊ†πÁõÆÂΩïÊñá‰ª∂ÁöÑÂÜÖÂÆπÊòØÊèèËø∞‰Ωç‰∫éÊñá‰ª∂Á≥ªÁªüÊ†πÁõÆÂΩï‰∏ãÁöÑÊñá‰ª∂ÂíåÁõÆÂΩïÁöÑstruct FileÂ∫èÂàó„ÄÇÊ†πÁõÆÂΩï‰∏≠ÁöÑ‰ªª‰ΩïÂ≠êÁõÆÂΩïÂèØ‰ª•‰æùÊ¨°ÂåÖÂê´Ë°®Á§∫Â≠êÂ≠êÁõÆÂΩïÁöÑÊõ¥Â§öÁöÑstruct FileÔºå‰æùÊ≠§Á±ªÊé®„ÄÇ ÁÆÄÂçïÊù•ËÆ≤ÔºåÊ≤°Âï•ÂèØËÆ≤ÔºåÂ§üÁÆÄÂçï‰∫Ü The File SystemÊú¨labÁöÑÁõÆÊ†á‰∏çÊòØÂÆûÁé∞Êï¥‰∏™Êñá‰ª∂Á≥ªÁªüÔºåËÄåÊòØ‰ªÖÂÆûÁé∞Êüê‰∫õÂÖ≥ÈîÆÁªÑ‰ª∂„ÄÇÁâπÂà´ÊòØÔºåÈúÄË¶ÅÂÆûÁé∞Â∞ÜÂùóËØªÂÖ•ÂùóÈ´òÈÄüÁºìÂ≠òÂπ∂Â∞ÜÂÖ∂Âà∑Êñ∞ÂõûÁ£ÅÁõò;ÂàÜÈÖçÁ£ÅÁõòÂùó;Â∞ÜÊñá‰ª∂ÂÅèÁßªÊò†Â∞ÑÂà∞Á£ÅÁõòÂùó;Âπ∂Âú®IPCÊé•Âè£‰∏≠‰∏≠ÂÆûÁé∞ËØªÔºåÂÜôÂíåÊâìÂºÄ„ÄÇÂõ†‰∏∫‰Ω†‰∏ç‰ºöËá™Â∑±ÂÆûÁé∞ÊâÄÊúâÁöÑÊñá‰ª∂Á≥ªÁªüÔºåÊâÄ‰ª•‰Ω†ÈúÄË¶ÅÁÜüÊÇâÊèê‰æõÁöÑ‰ª£Á†ÅÂíåÂêÑÁßçÊñá‰ª∂Á≥ªÁªüÊé•Âè£„ÄÇÁúãÂà∞ÈÇ£Âá†‰∏™ÊâìÂá∫Ê†áËÆ∞ÁöÑ‰∫Ü‰πàÔºåÈáçÁÇπË¶ÅËÄÉÁöÑ„ÄÇ Disk AccessÊàë‰ª¨Êìç‰ΩúÁ≥ªÁªü‰∏≠ÁöÑÊñá‰ª∂Á≥ªÁªüÁéØÂ¢ÉÈúÄË¶ÅËÉΩÂ§üËÆøÈóÆÁ£ÅÁõòÔºå‰ΩÜÊòØÊàë‰ª¨ËøòÊ≤°ÊúâÂú®ÂÜÖÊ†∏‰∏≠ÂÆûÁé∞‰ªª‰ΩïÁ£ÅÁõòËÆøÈóÆÂäüËÉΩ„ÄÇËÄå‰∏çÊòØÈááÂèñ‰º†ÁªüÁöÑÂçïÂÜÖÊ†∏Êìç‰ΩúÁ≥ªÁªüÁöÑÁ≠ñÁï•Â∞ÜIDEÁ£ÅÁõòÈ©±Âä®Âô®Ê∑ªÂä†Âà∞ÂÜÖÊ†∏‰∏≠ÔºåÂÖÅËÆ∏Êñá‰ª∂Á≥ªÁªü‰ª•Á≥ªÁªüË∞ÉÁî®ËÆøÈóÆÂÆÉÔºåËÄåÊòØÂ∞ÜIDEÁ£ÅÁõòÈ©±Âä®Âô®‰Ωú‰∏∫Áî®Êà∑Á∫ßÊñá‰ª∂Á≥ªÁªüÁöÑ‰∏ÄÈÉ®ÂàÜ„ÄÇÊàë‰ª¨‰ªçÁÑ∂ÈúÄË¶ÅÁ®çÂæÆ‰øÆÊîπÂÜÖÊ†∏Ôºå‰ª•‰æøËÆæÁΩÆÊñá‰ª∂Á≥ªÁªüÁéØÂ¢ÉÂÖ∑ÊúâÂÆûÁé∞Á£ÅÁõòËÆøÈóÆÊâÄÈúÄÁöÑÊùÉÈôê„ÄÇÁî®‰∫∫ËØùÊù•ËÆ≤ÔºåÊàë‰ª¨ÊòØÊääÁ£ÅÁõòËÆøÈóÆÊîæÂú®Áî®Êà∑ÁéØÂ¢ÉÔºåËÆ©Áî®Êà∑ËÉΩËÆøÈóÆÁ£ÅÁõòÔºå‰ΩÜÊòØËøòÈúÄË¶ÅÊîπ‰∏ÄÊîπÂÜÖÊ†∏ Âè™Ë¶ÅÊàë‰ª¨‰æùÈù†ËΩÆËØ¢ÔºåÂü∫‰∫é‚ÄúÂèØÁºñÁ®ãI/O‚ÄùÔºàprogrammed I/O, PIOÔºâÁöÑÁ£ÅÁõòËÆøÈóÆÂπ∂‰∏î‰∏ç‰ΩøÁî®Á£ÅÁõò‰∏≠Êñ≠ÔºåÂ∞±ÂæàÂÆπÊòìÂú®Áî®Êà∑Á©∫Èó¥‰∏≠ÂÆûÁé∞Á£ÅÁõòËÆøÈóÆ„ÄÇ‰πüÂèØ‰ª•Âú®Áî®Êà∑ÊÄÅ‰∏ãÂÆûÁé∞‰∏≠Êñ≠È©±Âä®ÁöÑËÆæÂ§áÈ©±Âä®Ôºà‰æãÂ¶ÇÔºåL3ÂíåL4ÂÜÖÊ†∏ÔºâÔºå‰ΩÜÊòØÁî±‰∫éÂÜÖÊ†∏ÂøÖÈ°ªfieldËÆæÂ§á‰∏≠Êñ≠Âπ∂Â∞ÜÂÖ∂ÂàÜÈÖçÂà∞Ê≠£Á°ÆÁöÑÁî®Êà∑ÊÄÅÁéØÂ¢ÉÔºåÊâÄ‰ª•Êõ¥‰∏∫Âõ∞Èöæ„ÄÇ x86Â§ÑÁêÜÂô®‰ΩøÁî®EFLAGSÂØÑÂ≠òÂô®‰∏≠ÁöÑIOPL‰ΩçÊù•Á°ÆÂÆöÊòØÂê¶ÂÖÅËÆ∏‰øùÊä§Ê®°Âºè‰ª£Á†ÅÊâßË°åÁâπÊÆäÁöÑËÆæÂ§áI/OÊåá‰ª§ÔºåÂ¶ÇINÂíåOUTÊåá‰ª§„ÄÇÁî±‰∫éÊàë‰ª¨ÈúÄË¶ÅËÆøÈóÆÁöÑÊâÄÊúâIDEÁ£ÅÁõòÂØÑÂ≠òÂô®‰Ωç‰∫éx86ÁöÑI/OÁ©∫Èó¥‰∏≠ÔºåËÄå‰∏çÊòØÂÜÖÂ≠òÊò†Â∞ÑÔºåÂõ†Ê≠§‰∏∫Êñá‰ª∂Á≥ªÁªüÁéØÂ¢ÉÊèê‰æõ‚ÄúI/OÁâπÊùÉ‚ÄùÊòØÊàë‰ª¨ÂîØ‰∏ÄÈúÄË¶ÅÂÅöÁöÑÔºå‰ª•‰æøÂÖÅËÆ∏Êñá‰ª∂Á≥ªÁªüËÆøÈóÆËøô‰∫õÂØÑÂ≠òÂô®„ÄÇÂÆûÈôÖ‰∏äÔºåEFLAGSÂØÑÂ≠òÂô®‰∏≠ÁöÑIOPL‰Ωç‰∏∫ÂÜÖÊ†∏Êèê‰æõ‰∫Ü‰∏ÄÁßçÁÆÄÂçïÁöÑ‚ÄúÂÖ®ÊàñÊó†‚ÄùÊñπÊ≥ïÊù•ÊéßÂà∂Áî®Êà∑ÊÄÅ‰ª£Á†ÅËÉΩÂê¶ËÆøÈóÆI/OÁ©∫Èó¥„ÄÇÂú®Êàë‰ª¨ÁöÑÂÆûÁé∞‰∏≠ÔºåÊàë‰ª¨Â∏åÊúõÊñá‰ª∂Á≥ªÁªüÁéØÂ¢ÉËÉΩÂ§üËÆøÈóÆI/OÁ©∫Èó¥Ôºå‰ΩÜÊòØÊàë‰ª¨‰∏çÂ∏åÊúõ‰ªª‰ΩïÂÖ∂‰ªñÁéØÂ¢ÉËÉΩÂ§üËÆøÈóÆI/OÁ©∫Èó¥„ÄÇÁî®‰∫∫ËØùÊù•ËÆ≤ÔºåËÆæÁΩÆ EFLAGS ‰∏≠ÁöÑIOPL ÂèØ‰ª•ËÆ©Áî®Êà∑ËÆøÈóÆ I/O ÁªÉ‰π†1ËÆ©Êàë‰ª¨ÂÆûÁé∞‰∏äËø∞ÈóÆÈ¢ò„ÄÇÊàë‰ª¨Âè™ÈúÄË¶ÅÊ∑ªÂä†‰∏ÄÂè•ËØù„ÄÇ1234567891011121314151617voidenv_create(uint8_t *binary, enum EnvType type)&#123; // LAB 3: Your code here. struct Env * e; int r=env_alloc(&amp;e,0); if(r!=0)&#123; cprintf("%e\n",r); panic("env_create:error"); &#125; load_icode(e,binary); e-&gt;env_type=type; // If this is the file server (type == ENV_TYPE_FS) give it I/O privileges. // LAB 5: Your code here. if(type==ENV_TYPE_FS)e-&gt;env_tf.tf_eflags|=FL_IOPL_MASK; //Ê∑ªÂä†Ëøô‰∏ÄÂè•Âç≥ÂèØ„ÄÇ&#125; Question 1Ë¶Å‰∏çË¶ÅÔºåËÄÉËôëÂàáÊç¢Áî®Êà∑ËøõÁ®ãÁöÑÊùÉÈôêÈóÆÈ¢ò„ÄÇ‰∏çÈúÄË¶ÅÔºåÁî®Êà∑ÁéØÂ¢ÉÂàáÊç¢ÁöÑÊó∂ÂÄôÔºåeflagsÂØÑÂ≠òÂô®ÁöÑÁä∂ÊÄÅÊúâCPUÂéãÂÖ•ÂÜÖÊ†∏Ê†àÔºåÊúÄÂêéÁî±env_pop_tfÁöÑiretÊåá‰ª§ÊÅ¢Â§çeflagsÂØÑÂ≠òÂô®Áä∂ÊÄÅ„ÄÇ ÂêéÈù¢ÂëäËØâ‰Ω†‰∏§‰∏™Êåá‰ª§ÂèØ‰ª•ÊÅ¢Â§çÂàùÂßãÂåñ„ÄÇ The Block CacheÂú®Êàë‰ª¨ÁöÑÊñá‰ª∂Á≥ªÁªü‰∏≠ÔºåÊàë‰ª¨Â∞ÜÂú®Â§ÑÁêÜÂô®ÁöÑËôöÊãüÂÜÖÂ≠òÁ≥ªÁªüÁöÑÂ∏ÆÂä©‰∏ãÂÆûÁé∞‰∏Ä‰∏™ÁÆÄÂçïÁöÑ‚ÄúÁºìÂÜ≤Âå∫ÁºìÂ≠ò‚ÄùÔºàÂÆûÈôÖ‰∏äÂè™ÊòØÂùóÁºìÂ≠òÔºâ„ÄÇÂùóÁºìÂ≠òÁöÑ‰ª£Á†ÅÂú®fs/bc.c‰∏≠„ÄÇ Êàë‰ª¨ÁöÑÊñá‰ª∂Á≥ªÁªüÂ∞ÜÈôê‰∫éÂ§ÑÁêÜÂ§ßÂ∞è‰∏∫3GBÊàñÊõ¥Â∞èÁöÑÁ£ÅÁõò„ÄÇÊàë‰ª¨‰øùÁïô‰∏Ä‰∏™Â§ßÁöÑÔºåÂõ∫ÂÆöÁöÑ3GBÂå∫ÂüüÁöÑÊñá‰ª∂Á≥ªÁªüÁéØÂ¢ÉÁöÑÂú∞ÂùÄÁ©∫Èó¥Ôºå‰ªé0x10000000ÔºàDISKMAPÔºâ~0xD0000000ÔºàDISKMAP + DISKMAXÔºâÔºå‰Ωú‰∏∫Á£ÅÁõòÁöÑ‚ÄúÂÜÖÂ≠òÊò†Â∞Ñ‚ÄùÁâàÊú¨„ÄÇ‰æãÂ¶ÇÔºåÁ£ÅÁõòÂùó0Êò†Â∞Ñ‰∏∫ËôöÊãüÂú∞ÂùÄ0x10000000ÔºåÁ£ÅÁõòÂùó1Êò†Â∞ÑÂà∞ËôöÊãüÂú∞ÂùÄ0x10001000Ôºå‰æùÊ≠§Á±ªÊé®„ÄÇfs/bc.c‰∏≠ÁöÑdiskaddrÂáΩÊï∞ÂÆûÁé∞‰∫Ü‰ªéÁ£ÅÁõòÂùóÂè∑Âà∞ËôöÊãüÂú∞ÂùÄÁöÑËΩ¨Êç¢Ôºà‰ª•Âèä‰∏Ä‰∫õÁêÜÊÄßÊ£ÄÊü•Ôºâ„ÄÇ Áî±‰∫éÊàë‰ª¨ÁöÑÊñá‰ª∂Á≥ªÁªüÁéØÂ¢ÉÂÖ∑ÊúâÁã¨Á´ã‰∫éÁ≥ªÁªü‰∏≠ÊâÄÊúâÂÖ∂‰ªñÁéØÂ¢ÉÁöÑËôöÊãüÂú∞ÂùÄÁ©∫Èó¥ÁöÑËôöÊãüÂú∞ÂùÄÁ©∫Èó¥ÔºåÊñá‰ª∂Á≥ªÁªüÁéØÂ¢ÉÂîØ‰∏ÄÈúÄË¶ÅÂÅöÁöÑÂ∞±ÊòØÂÆûÁé∞Êñá‰ª∂ËÆøÈóÆÔºåÂõ†Ê≠§‰øùÁïôÂ§ßÈÉ®ÂàÜÊñá‰ª∂Á≥ªÁªüÁéØÂ¢ÉÁöÑËøô‰∏™Âú∞ÂùÄÁ©∫Èó¥„ÄÇÁî±‰∫éÁé∞‰ª£Á£ÅÁõòÂ§ß‰∫é3GBÔºåÂõ†Ê≠§Âú®32‰ΩçËÆ°ÁÆóÊú∫‰∏äËøôÊ†∑ÂÆûÁé∞ÁúüÊ≠£ÁöÑÊñá‰ª∂Á≥ªÁªüÂ∞Ü‰ºöÂæàÂ∞¥Â∞¨„ÄÇËøôÊ†∑ÁöÑÁºìÂÜ≤Âå∫È´òÈÄüÁºìÂ≠òÁÆ°ÁêÜÊñπÊ≥ïÂú®ÂÖ∑Êúâ64‰ΩçÂú∞ÂùÄÁ©∫Èó¥ÁöÑÊú∫Âô®‰∏ä‰ªçÁÑ∂ÊòØÂêàÁêÜÁöÑ„ÄÇ ÂΩìÁÑ∂ÔºåÂ∞ÜÊï¥‰∏™Á£ÅÁõòËØªÂÖ•ÂÜÖÂ≠òÈúÄË¶ÅÂæàÈïøÊó∂Èó¥ÔºåÂõ†Ê≠§Êàë‰ª¨Â∞ÜÂÆûÁé∞‰∏ÄÁßçÊåâÈúÄÂàÜÈ°µÁöÑÂΩ¢ÂºèÔºåÂÖ∂‰∏≠Êàë‰ª¨Âè™Âú®Á£ÅÁõòÊò†Â∞ÑÂå∫Âüü‰∏≠ÂàÜÈÖçÈ°µÈù¢ÔºåÂπ∂‰ªéÁ£ÅÁõòËØªÂèñÁõ∏Â∫îÁöÑÂùóÔºå‰ª•ÂìçÂ∫îËøô‰∏™Âå∫ÂüüÁöÑÈ°µÈù¢ÈîôËØØ„ÄÇËøôÊ†∑ÔºåÊàë‰ª¨ÂèØ‰ª•ÂÅáË£ÖÊï¥‰∏™Á£ÅÁõòÈÉΩÂú®ÂÜÖÂ≠ò‰∏≠„ÄÇ ÁÆÄÂçïÊù•ËÆ≤ÔºåÊàë‰ª¨‰øùÁïô‰∫Ü‰∏Ä‰∏™3GB ÁöÑÂÜÖÂ≠òÁî®Êù•ÂÅöÁ£ÅÁõòÊò†Â∞ÑÔºåÂõ†‰∏∫ËØªÂèñÊï¥‰∏™Á£ÅÁõòË¶ÅÂæàÈïøÁöÑÊó∂Èó¥ÔºåÊâÄ‰ª•Êàë‰ª¨Â∞±Áî®ÂàÜÈ°µÂΩ¢Âºè„ÄÇ ÁªÉ‰π†2ËÆ©ÊàëÂÆûÁé∞Âú®fs/bc.cÈáåÈù¢ÁöÑbc_pgfaultÂíåflush_block„ÄÇÈÉΩÂú®‰∏Ä‰∏™Êñá‰ª∂ÈáåÈù¢ÔºåÊàë‰ª¨Áõ¥Êé•ÁúãÁúãÊñá‰ª∂„ÄÇÂú®ÁúãËøô‰∏™Êñá‰ª∂‰πãÂâçÊàë‰ª¨ÂÖàÁúãÁúãide.c ide.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/* * Minimal PIO-based (non-interrupt-driven) IDE driver code. * For information about what all this IDE/ATA magic means, * see the materials available on the class references page. *///ÊúÄÂ∞èÂåñÁöÑÂü∫‰∫éPIOÔºàÈùû‰∏≠Êñ≠È©±Âä®ÁöÑÔºâÁöÑIDEÁ£ÅÁõòÈ©±Âä®„ÄÇ#include "fs.h"#include &lt;inc/x86.h&gt;//‰∏ãÈù¢ËøôÊ≤°ÊúâÊ≥®Èáä‰πü‰∏çÁü•ÈÅìÂπ≤Âï•ÁöÑ#define IDE_BSY 0x80#define IDE_DRDY 0x40#define IDE_DF 0x20#define IDE_ERR 0x01static int diskno = 1;static intide_wait_ready(bool check_error)&#123; int r; while (((r = inb(0x1F7)) &amp; (IDE_BSY|IDE_DRDY)) != IDE_DRDY) /* do nothing */; //Ëøô‰∏™Â∫îËØ•ÊòØÊ£ÄÊü•Á£ÅÁõòÊòØ‰∏çÊòØÂáÜÂ§áÂ•ΩÁöÑ if (check_error &amp;&amp; (r &amp; (IDE_DF|IDE_ERR)) != 0)//Ê£ÄÊü•ÊòØÂê¶Âá∫ÈîôÔºü return -1; return 0;&#125;boolide_probe_disk1(void)&#123; int r, x; // wait for Device 0 to be ready ide_wait_ready(0); // switch to Device 1 outb(0x1F6, 0xE0 | (1&lt;&lt;4)); // check for Device 1 to be ready for a while for (x = 0; x &lt; 1000 &amp;&amp; ((r = inb(0x1F7)) &amp; (IDE_BSY|IDE_DF|IDE_ERR)) != 0; x++) /* do nothing */; // switch back to Device 0 outb(0x1F6, 0xE0 | (0&lt;&lt;4)); cprintf("Device 1 presence: %d\n", (x &lt; 1000)); return (x &lt; 1000);&#125;voidide_set_disk(int d)&#123; if (d != 0 &amp;&amp; d != 1) panic("bad disk number"); diskno = d;&#125;//ÂâçÈù¢‰πü‰∏çÁü•ÈÅìÊòØÂï•Ôºå‰∏çËøá‰∏çÈáçË¶ÅÈáçË¶ÅÁöÑÊòØ‰∏ãÈù¢‰∏§‰∏™ÂáΩÊï∞intide_read(uint32_t secno, void *dst, size_t nsecs) //ÂèÇÊï∞‰∏â‰∏™ÔºåÊâáÂå∫Âè∑ÔºåËôöÊãüÂú∞ÂùÄÔºåÂ∑≤ÁªèËØªÂèñÊâáÂå∫‰∏™Êï∞&#123; int r; assert(nsecs &lt;= 256); ide_wait_ready(0);//Âà§Êñ≠ÊòØ‰∏çÊòØÁ≠âÂæÖ//ÂêéÈù¢Áúã‰∏çÊáÇ‰∫Ü outb(0x1F2, nsecs); outb(0x1F3, secno &amp; 0xFF); outb(0x1F4, (secno &gt;&gt; 8) &amp; 0xFF); outb(0x1F5, (secno &gt;&gt; 16) &amp; 0xFF); outb(0x1F6, 0xE0 | ((diskno&amp;1)&lt;&lt;4) | ((secno&gt;&gt;24)&amp;0x0F)); outb(0x1F7, 0x20); // CMD 0x20 means read sector for (; nsecs &gt; 0; nsecs--, dst += SECTSIZE) &#123; if ((r = ide_wait_ready(1)) &lt; 0) return r; insl(0x1F0, dst, SECTSIZE/4); &#125; return 0;&#125;intide_write(uint32_t secno, const void *src, size_t nsecs)//ÂÜôÂÖ•ÊâáÂå∫ÔºåÂÜôÂÖ•ÂÜÖÂÆπÔºåÂÜôÂÖ•ÊâáÂå∫‰∏™Êï∞&#123; int r; assert(nsecs &lt;= 256); ide_wait_ready(0); outb(0x1F2, nsecs); outb(0x1F3, secno &amp; 0xFF); outb(0x1F4, (secno &gt;&gt; 8) &amp; 0xFF); outb(0x1F5, (secno &gt;&gt; 16) &amp; 0xFF); outb(0x1F6, 0xE0 | ((diskno&amp;1)&lt;&lt;4) | ((secno&gt;&gt;24)&amp;0x0F)); outb(0x1F7, 0x30); // CMD 0x30 means write sector for (; nsecs &gt; 0; nsecs--, src += SECTSIZE) &#123; if ((r = ide_wait_ready(1)) &lt; 0) return r; outsl(0x1F0, src, SECTSIZE/4); &#125; return 0;&#125; ÁúãÂÆåËøô‰∏™Êñá‰ª∂Ôºå‰∏ªË¶ÅË¶ÅËÆ∞‰ΩèÁöÑÂ∞±ÊòØÈÇ£‰∏§‰∏™ÂáΩÊï∞ÂêéÈù¢Áî®ÁöÑ‰∏ä„ÄÇint ide_read(uint32_t secno, void *dst, size_t nsecs)int ide_write(uint32_t secno, const void *src, size_t nsecs) bc123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include "fs.h"// Âü∫‰∫éÁî®Êà∑Á∫ßÈ°µÈîôËØØÂ§ÑÁêÜÊú∫Âà∂ÁöÑÂùóÁºìÂ≠ò„ÄÇ// Return the virtual address of this disk block.void*diskaddr(uint32_t blockno) //ÁúãÁöÑÂá∫Êù•ÊòØËøîÂõûÂØπÂ∫îÂùóÂè∑ÁöÑËôöÊãüÂú∞ÂùÄ&#123; if (blockno == 0 || (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks)) panic("bad block number %08x in diskaddr", blockno); return (char*) (DISKMAP + blockno * BLKSIZE);&#125;// Is this virtual address mapped?boolva_is_mapped(void *va)//Ëøô‰∏™Â∫îËØ•ÊòØÂà§Êñ≠Ëøô‰∏™È°µÊúâÊ≤°ÊúâÊò†Â∞Ñ&#123; return (uvpd[PDX(va)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(va)] &amp; PTE_P);&#125;// Is this virtual address dirty?boolva_is_dirty(void *va)//Ëøô‰∏™ËôöÊãüÂú∞ÂùÄÊòØ‰∏çÊòØ‰øÆÊîπ‰∫Ü&#123; return (uvpt[PGNUM(va)] &amp; PTE_D) != 0;&#125;// Fault any disk block that is read in to memory by// loading it from disk. Ëøô‰∏™Â∫îËØ•Â∞±ÊòØÁº∫È°µÂ§ÑÁêÜ‰∫Üstatic voidbc_pgfault(struct UTrapframe *utf)&#123; void *addr = (void *) utf-&gt;utf_fault_va;//Ëé∑ÂèñÁº∫È°µÂú∞ÂùÄ uint32_t blockno = ((uint32_t)addr - DISKMAP) / BLKSIZE;//ÂØπÂ∫îÂùóÂè∑ int r; // Check that the fault was within the block cache regionÂà§Êñ≠Âú∞ÂùÄÂêà‰∏çÂêàÊ≥ï if (addr &lt; (void*)DISKMAP || addr &gt;= (void*)(DISKMAP + DISKSIZE)) panic("page fault in FS: eip %08x, va %08x, err %04x", utf-&gt;utf_eip, addr, utf-&gt;utf_err); // Sanity check the block number. Ê£ÄÊü•ÂùóÂè∑Âêà‰∏çÂêàÊ≥ï if (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks) panic("reading non-existent block %08x\n", blockno); // Allocate a page in the disk map region, read the contents // of the block from the disk into that page. // Hint: first round addr to page boundary. fs/ide.c has code to read // the disk. fs/ide.c Êúâ‰ª£Á†ÅÂéªËØªÂèñÁ°¨Áõò // // LAB 5: you code here: //ÁªèËøáÁªÉ‰π†ÁöÑÊèêÁ§∫ÔºåÊàë‰ª¨Â∫îËØ•Ë¶ÅÈ°µÂØπÈΩêÁÑ∂ÂêéÂÜçÂàÜÈÖçÂÜÖÂ≠ò addr=ROUNDDOWN(addr,PGSIZE); if(sys_page_alloc(0,addr,PTE_SYSCALL)&lt;0)panic("error page alloc"); //ÂàÜÈÖç‰∏Ä‰∏™È°µ //ÂàÜÈÖçÂÆåÈ°µ‰πãÂêéÔºåÊàë‰ª¨ÈúÄË¶ÅÊääÁ£ÅÁõòÈáåÈù¢ÁöÑÂÜÖÂÆπËØªÂá∫Êù•ÔºåÁªÉ‰π†ÊèêÁ§∫‰∫ÜÊàë‰ª¨ ÂáΩÊï∞ÊòØÊåâÊâáÂå∫Êù•ÁöÑ //ËÄåÊàë‰ª¨ÊòØÊåâÂùóÊù•ÁöÑÔºåËøòÊúâÈ°µÔºåÁ¨¨blockno*8 ‰∏™ÊâáÂå∫ÔºåËØª8‰∏™ÊâáÂå∫ ide_read(blockno*8,addr,8);//ÊääÈ°µÁ£ÅÁõòÈáåÈù¢ÁöÑÂÄºËØªÂá∫Êù• // Clear the dirty bit for the disk block page since we just read the // block from disk ÂàöÂä†ÂÖ•ÁöÑËøòÊ≤°Êúâ‰øÆÊîπÔºåÊâÄ‰ª•ËøòÊòØÂπ≤ÂáÄÁöÑ if ((r = sys_page_map(0, addr, 0, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; 0) panic("in bc_pgfault, sys_page_map: %e", r); // Check that the block we read was allocated. (exercise for // the reader: why do we do this *after* reading the block // in?) Ê£ÄÊü•Ëøô‰∏™ÊòØ‰∏çÊòØÂ∑≤ÁªèÂàÜÈÖç‰∫Ü if (bitmap &amp;&amp; block_is_free(blockno)) panic("reading free block %08x\n", blockno);&#125;// Flush the contents of the block containing VA out to disk if// necessary, then clear the PTE_D bit using sys_page_map.// If the block is not in the block cache or is not dirty, does// nothing. ÊääVAÂú∞ÂùÄÁöÑÂÜÖÂÆπÂÜôÂà∞Á£ÅÁõòÔºåÂ¶ÇÊûúÊ≤°Êúâ‰øÆÊîπÂ∞±‰ªÄ‰πàÈÉΩ‰∏çË¶ÅÂÅö// Hint: Use va_is_mapped, va_is_dirty, and ide_write. Ëøô‰∏â‰∏™ÊòØÂèØ‰ª•Áî®ÁöÑ// Hint: Use the PTE_SYSCALL constant when calling sys_page_map. Áî® sys_page_mapÊ∏ÖÊ•ö ‰øÆÊîπ‰Ωç// Hint: Don't forget to round addr down.‰∏çË¶ÅÂøòËÆ∞È°µÂØπÈΩêvoidflush_block(void *addr)&#123; uint32_t blockno = ((uint32_t)addr - DISKMAP) / BLKSIZE;//Ëé∑ÂèñÂùóÂè∑ if (addr &lt; (void*)DISKMAP || addr &gt;= (void*)(DISKMAP + DISKSIZE))//Ê£ÄÊü•Âú∞ÂùÄ panic("flush_block of bad va %08x", addr); // LAB 5: Your code here. addr=ROUNDDOWN(addr,PGSIZE);//È°µÂØπÈΩê if(!va_is_mapped(addr)||!va_is_dirty(addr))return ;//Ê£ÄÊü•Âú∞ÂùÄÊòØ‰∏çÊòØÂ∑≤ÁªèÊò†Â∞Ñ‰∫ÜÂíå‰øÆÊîπ Â¶ÇÊûúÊ≤°ÊúâÊò†Â∞ÑÔºåÊàñËÄÖÊòØ‰øÆÊîπËØ¥ÊòéÊ≤°ÊúâÂÅö‰ªª‰ΩïÊîπÂèòÔºåÈÇ£‰πà‰ªÄ‰πàÈÉΩ‰∏çÁî®ÂÅö ide_write(blockno*8,addr,8); //‰øÆÊîπ‰∫ÜÂ∞±Ë¶ÅÂÜôÂÖ• sys_page_map(0,addr,0,addr,PTE_SYSCALL);// Ê∏ÖÊ•ö‰øÆÊîπÊ†áÂøó //panic("flush_block not implemented");&#125;// Test that the block cache works, by smashing the superblock and// reading it back. ÊµãËØïÁºìÂ≠òÊòØ‰∏çÊòØÂ∑•‰Ωú„ÄÇstatic voidcheck_bc(void)&#123; struct Super backup; // back up super block memmove(&amp;backup, diskaddr(1), sizeof backup); // smash it strcpy(diskaddr(1), "OOPS!\n"); flush_block(diskaddr(1)); assert(va_is_mapped(diskaddr(1))); assert(!va_is_dirty(diskaddr(1))); // clear it out sys_page_unmap(0, diskaddr(1)); assert(!va_is_mapped(diskaddr(1))); // read it back in assert(strcmp(diskaddr(1), "OOPS!\n") == 0); // fix it memmove(diskaddr(1), &amp;backup, sizeof backup); flush_block(diskaddr(1)); // Now repeat the same experiment, but pass an unaligned address to // flush_block. // back up super block memmove(&amp;backup, diskaddr(1), sizeof backup); // smash it strcpy(diskaddr(1), "OOPS!\n"); // Pass an unaligned address to flush_block. flush_block(diskaddr(1) + 20); assert(va_is_mapped(diskaddr(1))); // Skip the !va_is_dirty() check because it makes the bug somewhat // obscure and hence harder to debug. //assert(!va_is_dirty(diskaddr(1))); // clear it out sys_page_unmap(0, diskaddr(1)); assert(!va_is_mapped(diskaddr(1))); // read it back in assert(strcmp(diskaddr(1), "OOPS!\n") == 0); // fix it memmove(diskaddr(1), &amp;backup, sizeof backup); flush_block(diskaddr(1)); cprintf("block cache is good\n");&#125;voidbc_init(void)//ÂàùÂßãÂåñÁ£ÅÁõò&#123; struct Super super; set_pgfault_handler(bc_pgfault);//ËÆæÁΩÆÁº∫È°µÂ§ÑÁêÜÊâãÊÆµ check_bc();//Ê£ÄÊü•Á£ÅÁõòÁºìÂÜ≤ // cache the super block by reading it once Á¨¨‰∏ÄÊ¨°Âä†ËΩΩÔºåÂú®Ëøô‰∏™Êó∂ÂÄôÊääÊ†πÁõÆÂΩïÂèñÂà∞ÂÜÖÂ≠ò‰∫ÜÔºåÂú®Ëøô‰πãÂêéÊàë‰ª¨Â∞±ÂèØ‰ª•ÈÄöËøásuper ËÆøÈóÆÁ£ÅÁõòÁä∂ÊÄÅ‰∫Ü memmove(&amp;super, diskaddr(1), sizeof super)&#125; Êàë‰ª¨Áé∞Âú®Â∞±ÊúâÁº∫È°µÂ§ÑÁêÜÔºåÂíåÂà∑Êñ∞ÁºìÂ≠òÁöÑÂäüËÉΩ‰∫Ü„ÄÇ fs/fs.c‰∏≠ÁöÑfs_initÂáΩÊï∞ÊòØÂ¶Ç‰Ωï‰ΩøÁî®ÂùóÁºìÂ≠òÁöÑ‰∏ªË¶ÅÁ§∫‰æã„ÄÇÂú®ÂàùÂßãÂåñÂùóÁºìÂ≠ò‰πãÂêéÔºåÂÆÉÂ∞ÜÊåáÈíàÂ≠òÂÇ®Âú®superÂÖ®Â±ÄÂèòÈáèÁöÑÁ£ÅÁõòÊò†Â∞ÑÂå∫Âüü‰∏≠„ÄÇÊ≠§ÂêéÔºåÊàë‰ª¨ÂèØ‰ª•ÁÆÄÂçïÂú∞‰ªéstruct Super‰∏≠ËØªÂèñÔºåÂ∞±ÂÉèÂÆÉ‰ª¨Âú®ÂÜÖÂ≠ò‰∏≠‰∏ÄÊ†∑ÔºåÊàë‰ª¨ÁöÑÈ°µÈù¢ÈîôËØØÂ§ÑÁêÜÁ®ãÂ∫èÂ∞ÜÊ†πÊçÆÈúÄË¶Å‰ªéÁ£ÅÁõòËØªÂèñÂÆÉ‰ª¨„ÄÇÊàë‰ª¨ÁúãÁúãfs_init()1234567891011121314151617181920// Initialize the file systemvoidfs_init(void)&#123; static_assert(sizeof(struct File) == 256);//Ê£ÄÊü•File ÂØπ‰∏çÂØπ // Find a JOS disk. Use the second IDE disk (number 1) if available if (ide_probe_disk1()) //Ëøô‰∏™ÊòØÊâæÁõòÔºüÁúãÊ≥®ÈáäÊòØÁúãÊúâÊ≤°Êúâ1Âè∑ÁõòÔºåÊúâÂ∞±Áî®1Âè∑Ê≤°Êúâ0Âè∑Ôºü ide_set_disk(1); else ide_set_disk(0); bc_init();//Ëøô‰∏™ËÆ≤Ëøá‰∫Ü // Set "super" to point to the super block. super = diskaddr(1);//Âú®bc_initÈáåÈù¢ÂÆûÈôÖ‰∏äÂ∑≤ÁªèÊúâ‰∫Ü ‰πü‰∏çÁü•ÈÅìËøô‰∏§‰∏™ÊúâÂï•Âå∫Âà´ check_super(); // Set "bitmap" to the beginning of the first bitmap block. bitmap = diskaddr(2);//‰ΩçÂõæ Êàë‰ª¨Êé•‰∏ãÊù•Â∞±Ë¶ÅËÆ≤‰∫Ü check_bitmap(); The Block BitmapÂú®fs_initËÆæÁΩÆ‰ΩçÂõæÊåáÈíà‰πãÂêéÔºåÊàë‰ª¨ÂèØ‰ª•Â∞Ü‰ΩçÂõæËßÜ‰∏∫‰∏Ä‰∏™ÊâìÂåÖÊï∞ÁªÑÁöÑ‰ΩçÔºåÊØè‰∏Ä‰∏™‰ΩçÂØπÂ∫î‰∫éÁ£ÅÁõò‰∏äÁöÑÊØè‰∏™Âùó„ÄÇÂèÇËßÅ‰æãÂ¶Çblock_is_freeÔºåÂÆÉÂú®‰ΩçÂõæ‰∏≠Ê£ÄÊü•ÁªôÂÆöÁöÑÂùóÊòØÂê¶Ë¢´Ê†áËÆ∞‰∏∫Á©∫Èó≤„ÄÇÁªÉ‰π†3ÂÆûÁé∞fs/fs.cÈáåÈù¢ÁöÑalloc_block„ÄÇÊàë‰ª¨ÁÆÄÂçïÁúãÁúãÁõ∏ÂÖ≥ÂáΩÊï∞123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// --------------------------------------------------------------// Super block// --------------------------------------------------------------// Validate the file system super-block. Ê£ÄÊü•superÊòØÂê¶Ê≠£Â∏∏voidcheck_super(void)&#123; if (super-&gt;s_magic != FS_MAGIC)//‰∏çÁü•ÈÅìÂπ≤Âï•ÁöÑ panic("bad file system magic number"); if (super-&gt;s_nblocks &gt; DISKSIZE/BLKSIZE)//Ê£ÄÊü•Êñá‰ª∂Á≥ªÁªüÊòØ‰∏çÊòØÊ≠£Â∏∏Â§ßÂ∞è panic("file system is too large"); cprintf("superblock is good\n");&#125;// --------------------------------------------------------------// Free block bitmap// --------------------------------------------------------------// Check to see if the block bitmap indicates that block 'blockno' is free.// Return 1 if the block is free, 0 if not. ÁúãÁöÑÂá∫Êù•ÊòØÊ£ÄÊü•‰∏Ä‰∏™ÂùóÂè∑ÊòØ‰∏çÊòØÁ©∫Èó≤È¢ùÔºå1Á©∫Èó≤0‰∏çÁ©∫Èó≤boolblock_is_free(uint32_t blockno)&#123; if (super == 0 || blockno &gt;= super-&gt;s_nblocks) return 0; if (bitmap[blockno / 32] &amp; (1 &lt;&lt; (blockno % 32))) return 1; return 0;&#125;// Mark a block free in the bitmap //Êää‰∏Ä‰∏™ÂùóÂè∑ÈáäÊîæÊéâvoidfree_block(uint32_t blockno)&#123; // Blockno zero is the null pointer of block numbers. if (blockno == 0) //ËÆ∞‰Ωè0ÊòØ‰∏çËÉΩÁî®ÁöÑ panic("attempt to free zero block"); //uint32_t *bitmap; bitmap ÂÆö‰πâÊòØ 32‰ΩçÔºåÊØè‰Ωç‰ª£Ë°®‰∏Ä‰∏™Âùó bitmap[blockno/32] |= 1&lt;&lt;(blockno%32);&#125;// Search the bitmap for a free block and allocate it. When you// allocate a block, immediately flush the changed bitmap block// to disk.// Êö¥ÂäõÊêúÁ¥¢Á¨¨‰∏Ä‰∏™ÂùóÂè∑ÁÑ∂ÂêéÂàÜÈÖç„ÄÇ// Return block number allocated on success,// -E_NO_DISK if we are out of blocks.//// Hint: use free_block as an example for manipulating the bitmap. ‰ΩøÁî®free_block ‰Ωú‰∏∫‰∏Ä‰∏™ÂàóÂ≠êintalloc_block(void)//Áúã‰∫Ü‰∏äÈù¢ÈÇ£‰∏™Ëøô‰∏™ÂÆûÁé∞Â∞±ÁÆÄÂçïÈ¢ù„ÄÇ&#123; // The bitmap consists of one or more blocks. A single bitmap block // contains the in-use bits for BLKBITSIZE blocks. There are // super-&gt;s_nblocks blocks in the disk altogether. //ÂëäËØâ‰Ω†ÊÄªÂÖ±Êúâ super-&gt;s_nblocks Ëøô‰πàÂ§ö‰∏™Âùó // LAB 5: Your code here. for(int i=0;i&lt;super-&gt;s_nblocks;i++)&#123;//Áõ¥Êé•Êö¥ÂäõÊâÄÊúâÂùó if(block_is_free(i))&#123; //Ê£ÄÊü•ÊòØ‰∏çÊòØÁ©∫Èó≤ bitmap[i/32] ^= (1&lt;&lt;(i%32)); //‰∏çÊáÇÂºÇÊàñ ÁöÑÂèØ‰ª•Áî® bitmap[i/32]&amp;=~(1&lt;&lt;(i%32); ‰ª£Êõø flush_block(diskaddr(i));//Âà∑Êñ∞ÁºìÂ≠ò„ÄÇ return i; &#125; &#125; //panic("alloc_block not implemented"); return -E_NO_DISK;&#125;// Validate the file system bitmap.//// Check that all reserved blocks -- 0, 1, and the bitmap blocks themselves --// are all marked as in-use. Ê£ÄÊü•‰ΩçÂõæÔºåÊ≤°ÊúâÊàë‰ª¨ÈúÄË¶ÅÊìç‰ΩúÁöÑÂú∞ÊñπÔºåÁúã‰∏Ä‰∏ãÂ∞±Ë°åvoidcheck_bitmap(void)&#123; uint32_t i; // Make sure all bitmap blocks are marked in-use Ê£ÄÊü•‰ΩçÂõæÂùóÈÉΩË¢´‰ΩøÁî®‰∫Ü for (i = 0; i * BLKBITSIZE &lt; super-&gt;s_nblocks; i++) assert(!block_is_free(2+i)); // Make sure the reserved and root blocks are marked in-use. assert(!block_is_free(0)); assert(!block_is_free(1)); cprintf("bitmap is good\n");&#125; File OperationsÊàë‰ª¨Âú®fs/fs.c‰∏≠Êèê‰æõ‰∫ÜÂêÑÁßçÂáΩÊï∞Ôºå‰ª•ÂÆûÁé∞Ëß£ÈáäÂíåÁÆ°ÁêÜstruct FileÔºåÊâ´ÊèèÂíåÁÆ°ÁêÜÁõÆÂΩïÊù°ÁõÆÊâÄÈúÄÁöÑÂü∫Êú¨ÂäüËÉΩÔºåÂπ∂‰ªéÊñá‰ª∂Á≥ªÁªüÁöÑÊ†πÁõÆÂΩïÂºÄÂßãÈÅçÂéÜ‰ª•Ëß£ÊûêÁªùÂØπË∑ØÂæÑÂêç„ÄÇÈòÖËØªfs/fs.c‰∏≠ÁöÑÊâÄÊúâ‰ª£Á†ÅÔºåÂπ∂Á°Æ‰øùÊÇ®‰∫ÜËß£ÊØè‰∏™ÂáΩÊï∞ÊâßË°åÁöÑÊìç‰Ωú„ÄÇÂàöÊâçÊàë‰ª¨Â∑≤ÁªèÁúã‰∫Ü‰∏ÄÈÉ®ÂàÜ‰∫ÜÔºåÁÑ∂ÂêéËøòÊòØÁü≠Áü≠ÁöÑ‰∏ÄÈÉ®ÂàÜ„ÄÇÁªÉ‰π†4 Êàë‰ª¨ÈúÄË¶ÅÂÆûÁé∞file_block_walk Âíå file_get_blockÔºåËøô‰∏§‰∏™ÂäüËÉΩÂçÅÂàÜÈáçË¶Å„ÄÇfile_block_walkËøô‰∏™ÊòØÊâæÂà∞Êñá‰ª∂ÈáåÈù¢Á¨¨filebnoÂùóÂè∑Âú∞ÂùÄÔºåÊòØÊåáÂêëÂùóÂè∑ÁöÑÂú∞ÂùÄÔºåÂπ∂‰∏çÊòØÂùóÁöÑÂÖ∑‰ΩìÂú∞ÂùÄÔºåfile_get_blockÂäüËÉΩÊòØÊâæÂà∞ filebnoÂØπÂ∫îÁöÑÂùóÂè∑ÊòØÂ§öÂ∞ëÔºåÂπ∂ËøîÂõûÂùóÂè∑Âú∞ÂùÄÔºåËøô‰∏™ÊòØÂÖ∑‰ΩìÂú∞ÂùÄÂü∫Êú¨‰∏äÊâÄÊúâÊñá‰ª∂Êìç‰ΩúÈÉΩË¶ÅÈÄöËøá‰∏äËø∞‰∏§‰∏™ÂáΩÊï∞„ÄÇ file_block_walkÂíåfile_get_block1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// Find the disk block number slot for the 'filebno'th block in file 'f'.// Set '*ppdiskbno' to point to that slot. // The slot will be one of the f-&gt;f_direct[] entries,// or an entry in the indirect block.// When 'alloc' is set, this function will allocate an indirect block// if necessary.//Âú®f Êñá‰ª∂ÈáåÈù¢ÊâæÂà∞Á¨¨ filebno ÂùóÂØπÂ∫îÁöÑÂú∞ÂùÄÔºåÂÇ®Â≠òÂà∞*ppdiskbnoÔºåÂèØËÉΩÂú® f-&gt;f_direct[] ÈáåÈù¢//ÊàñËÄÖ Èó¥Êé•ÂùóÈáåÈù¢ÔºåÂ¶ÇÊûúÊàë‰ª¨ ÂàÜÈÖç‰ΩçÁΩÆËÆæÁΩÆ‰∫ÜÔºåÂ∞±ÂàÜÈÖç‰∏Ä‰∏™// Returns:// *ppdiskbno ÂÇ®Â≠òÁöÑÊòØÂùóÂè∑// 0 on success (but note thatppdiskbno might equal 0).ÂàÜÈÖçÂÜ≤‰∏™ËøîÂõû0// -E_NOT_FOUND if the function needed to allocate an indirect block, but// alloc was 0. Ê≤°ÊúâÊâæÂà∞ ‰∏îÊ≤°ÊúâËÆæÁΩÆÂàÜÈÖç‰Ωç// -E_NO_DISK if there's no space on the disk for an indirect block.Ê≤°Á©∫Èó¥‰∫Ü// -E_INVAL if filebno is out of range (it's &gt;= NDIRECT + NINDIRECT).//Ë∂ÖÂá∫ËåÉÂõ¥// Analogy: This is like pgdir_walk for files.Âíåpgdir_walkÂæàÂÉè// Hint: Don't forget to clear any block you allocate.‰∏çË¶ÅÂøòËÆ∞Ê∏ÖÊ•ö‰Ω†ÂàÜÈÖçÁöÑÂùóstatic intfile_block_walk(struct File *f, uint32_t filebno, uint32_t **ppdiskbno, bool alloc)//f Êñá‰ª∂ filenoÊñá‰ª∂‰∏≠ÁöÑÁ¨¨Âá†Âùó ppdiskbnoÂÇ®Â≠òÂú∞ÂùÄ allocÊòØÂê¶ÂèØ‰ª•ÂàÜÈÖçÈó¥Êé•Âùó&#123; // LAB 5: Your code here. //NDIRECT NINDIRECT ‰∏§‰∏™Âú®fs.h ÈáåÈù¢ÊúâÂÆö‰πâ if(filebno&gt;=NDIRECT+NINDIRECT)return -E_INVAL;//Êñá‰ª∂ÂùóÊï∞Ë∂ÖÂá∫‰∫ÜÊúÄÂ§ßÂÄº if(filebno&lt;NDIRECT)&#123;//Â¶ÇÊûúÂú®Áõ¥Êé•ÂùóÈáåÈù¢ ÔºåÂ∞±Áõ¥Êé•ËøîÂõûÂú∞ÂùÄ if(ppdiskbno)&#123; *ppdiskbno=&amp;f-&gt;f_direct[filebno]; &#125; return 0; &#125; //Â¶ÇÊûúÊ≤°ÊúâÂú®Áõ¥Êé•ÂùóÈáåÈù¢ÔºåÈÇ£‰πàÂ∞±Âè™ËÉΩÂú®Èó¥Êé•ÂùóÈáåÔºåÁÑ∂ÂêéÊàë‰ª¨ÊÄé‰πàÂà§Êñ≠ÊúâÊ≤°ÊúâÈó¥Êé•ÂùóÂë¢ÔºüÔºüÔºü //Âú®Ëøô‰∏™Êñá‰ª∂ÈáåÈù¢ÊêúÁ¥¢ `f_indirectf`ÔºåÂèëÁé∞Âú® file_truncate_blocksÂáΩÊï∞ÁöÑÂâçÈù¢ //ÊúâËØ¥Êòé f-&gt;f_indirect != 0‰ª£Ë°®Ê≤°Êúâ Áâπ‰πàËøô‰∏™ÂáΩÊï∞‰∏çÂëäËØâÊàëÔºåÂà´ÈóÆÊàëÁªèÂéÜ‰∫Ü‰ªÄ‰πà if((f-&gt;f_indirect)==0)&#123;//Âà§Êñ≠Ê≤°ÊúâÈó¥Êé•Âùó if(alloc==0)return -E_NOT_FOUND;//Ê≤°ÊúâËÆæÁΩÆÂàÜÈÖç‰ΩçÔºåÂ∞±ËøîÂõûÊ≤°ÊúâÊâæÂà∞ int r=alloc_block();//ÂàÜÈÖç‰∏Ä‰∏™Âùó if(r&lt;=0)return -E_NO_DISK; f-&gt;f_indirect=r;//Èó¥Êé•Âø´ÂùóÂè∑ memset(diskaddr(f-&gt;f_indirect), 0, BLKSIZE);//Âá∫‰∫ãÂåñ‰∏∫0 flush_block(diskaddr(f-&gt;f_indirect));//Âà∑Êñ∞ÁºìÂ≠ò &#125; if (ppdiskbno)//Âè™ÊòØËøîÂõûÂú∞ÂùÄÔºåÊ≤°ÊúâÂÖ∑‰ΩìÁöÑÂÄº„ÄÇ *ppdiskbno = &amp;((uint32_t *)diskaddr(f-&gt;f_indirect))[filebno-NDIRECT];//Ê≠§Êó∂ *ppdiskbno ÊòØÂùóÂè∑ return 0; //panic("file_block_walk not implemented");&#125;// Set *blk to the address in memory where the filebno'th// block of file 'f' would be mapped.//ËÆæÁΩÆ *blk ‰∏∫ Âú® f Êñá‰ª∂Ëøû ÁöÑÁ¨¨ fileno ÁöÑÂú∞ÂùÄ„ÄÇÊòéÊòæÊòØË¶ÅÁî®Âà∞‰∏ä‰∏Ä‰∏™ÂáΩÊï∞„ÄÇ// Returns 0 on success, &lt; 0 on error. Errors are:ËøîÂõû0ÊàêÂäü// -E_NO_DISK if a block needed to be allocated but the disk is full. Ê≤°ÊúâÁ©∫Èó¥‰∫ÜËøîÂõû // -E_INVAL if filebno is out of range. Ë∂ÖÂá∫ËåÉÂõ¥//// Hint: Use file_block_walk and alloc_block. ‰ΩøÁî®Ëøô‰∏§‰∏™ÂáΩÊï∞intfile_get_block(struct File *f, uint32_t filebno, char **blk)&#123; // LAB 5: Your code here. uint32_t *ppdiskbno,blocknoÔºõ int r=0; //È¶ñÂÖàÂæóÁü•ÈÅìÂØπÂ∫îÁ£ÅÁõò‰∏≠ÁöÑÂùóÂè∑ÊòØÂ§öÂ∞ëÔºå //ÈÄöËøáËøô‰∏™ÂáΩÊï∞ ppdiskbno Â∞±ÊòØÊåáÂêëÂØπÂ∫îÁ£ÅÁõòÂùóÂè∑ÁöÑÂú∞ÂùÄÔºå‰πüÂ∞±ÊòØ *ppdiskbno Â≠òÁöÑÊòØÂùóÂè∑„ÄÇ if ((r = file_block_walk(f, filebno, &amp;ppdiskbno, true)) &lt; 0) return r; if ((*ppdiskbno)==0) &#123;//ÂùóÂè∑ÊòØ 0 ËØ¥ÊòéËøòÊ≤°ÊúâÂàÜÈÖçÂùó if ((r = alloc_block()) &lt; 0)//ÂàÜÈÖç‰∏Ä‰∏™Âùó return r; blockno = r; *ppdiskbno = blockno;//ÊåáÂêëÈÇ£‰∏™Âùó flush_block(diskaddr(*ppdiskbno));//Âà∑Êñ∞ÁºìÂ≠ò &#125; if (blk) *blk = (char *)diskaddr(*ppdiskbno);//ÂùóÂè∑Âú®Á£ÅÁõò‰∏≠ÁöÑÂú∞ÂùÄ ÊòØ *blkÂ≠òÁöÑÊòØËôöÊãüÂú∞ÂùÄÊåáÈíà return 0; //panic("file_get_block not implemented");&#125; ÁúãÊáÇ‰∏äÈù¢‰∏§‰∏™ÂáΩÊï∞ÔºåÂÖ∂‰ªñÁöÑÂ∞±ÈÉΩÁÆÄÂçï‰∫Ü„ÄÇÊàë‰ª¨Êù•ÁúãÁúãÂÖ∂‰ªñÂáΩÊï∞„ÄÇ fs.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304// Try to find a file named "name" in dir. If so, set *file to it.// Âú®ÁõÆÂΩïÈáåÈù¢Êâæ‰∏Ä‰∏™name ÁöÑÊñá‰ª∂// Returns 0 and sets *file on success, &lt; 0 on error. Errors are:// -E_NOT_FOUND if the file is not found Ê≤°ÊâæÂà∞static intdir_lookup(struct File *dir, const char *name, struct File **file)&#123; int r; uint32_t i, j, nblock; char *blk; struct File *f; // Search dir for name. // We maintain the invariant that the size of a directory-file // is always a multiple of the file system's block size. assert((dir-&gt;f_size % BLKSIZE) == 0); nblock = dir-&gt;f_size / BLKSIZE; for (i = 0; i &lt; nblock; i++) &#123; if ((r = file_get_block(dir, i, &amp;blk)) &lt; 0) return r; f = (struct File*) blk; for (j = 0; j &lt; BLKFILES; j++)//Â∞±ÊòØÁÆÄÂçïÁöÑ‰∏Ä‰∏™‰∏™ÊØîËæÉ if (strcmp(f[j].f_name, name) == 0) &#123; *file = &amp;f[j]; return 0; &#125; &#125; return -E_NOT_FOUND;&#125;// Set *file to point at a free File structure in dir. The caller is// responsible for filling in the File fields. Âú®ÁõÆÂΩïÈáåÈù¢Ê∑ªÂä†‰∏Ä‰∏™Êñá‰ª∂static intdir_alloc_file(struct File *dir, struct File **file)&#123; int r; uint32_t nblock, i, j; char *blk; struct File *f; assert((dir-&gt;f_size % BLKSIZE) == 0); nblock = dir-&gt;f_size / BLKSIZE; for (i = 0; i &lt; nblock; i++) &#123; if ((r = file_get_block(dir, i, &amp;blk)) &lt; 0) return r; f = (struct File*) blk; for (j = 0; j &lt; BLKFILES; j++) if (f[j].f_name[0] == '\0') &#123; *file = &amp;f[j];//ÊâæÂà∞Á¨¨‰∏Ä‰∏™ËÉΩÊîæ Êñá‰ª∂ÊèèËø∞Á¨¶ÁöÑ‰ΩçÁΩÆ return 0; &#125; &#125; dir-&gt;f_size += BLKSIZE;//Êñá‰ª∂Â§ßÂ∞èÂ¢ûÂä† if ((r = file_get_block(dir, i, &amp;blk)) &lt; 0)//‰∏çÁü•ÈÅì‰∏∫Âï•ËøòË¶ÅÂú®Êâæ‰∏ÄÊ¨° return r; f = (struct File*) blk; *file = &amp;f[0]; return 0;&#125;// Skip over slashes.static const char* //Ë∑≥ËøáÊñúÊù†ÁöÑÁ¨¨‰∏Ä‰∏™Â≠óÁ¨¶skip_slash(const char *p)&#123; while (*p == '/') p++; return p;&#125;// Evaluate a path name, starting at the root. ‰∏Ä‰∏™Ë∑ØÂæÑ ‰ªéÊ†πÁõÆÂΩïÂºÄÂßã// On success, set *pf to the file we found ÊàêÂäüËÆæÁΩÆÊñá‰ª∂ÊåáÈíàpf Âíå Ë∑ØÂæÑÊåáÈíàpdir// and set *pdir to the directory the file is in.// If we cannot find the file but find the directory // it should be in, set *pdir and copy the final path// element into lastelem.Â¶ÇÊûúÊàë‰ª¨Ê≤°ÊúâÊâæÂà∞‰∏Ä‰∏™Êñá‰ª∂‰ΩÜÊòØÊâæÂà∞‰∫ÜË∑ØÂæÑÔºåÈÇ£‰πàÂ∞±ÊääË∑ØÂæÑÊåáËøáÂéªÔºåÂÜçÂ§çÂà∂ÊúÄÂêé‰∏Ä‰∏™ÂÖÉÁ¥†static intwalk_path(const char *path, struct File **pdir, struct File **pf, char *lastelem)&#123; const char *p; char name[MAXNAMELEN]; struct File *dir, *f; int r; // if (*path != '/') // return -E_BAD_PATH; path = skip_slash(path); f = &amp;super-&gt;s_root; dir = 0; name[0] = 0; if (pdir) *pdir = 0; *pf = 0; while (*path != '\0') &#123; dir = f; p = path; while (*path != '/' &amp;&amp; *path != '\0') path++; if (path - p &gt;= MAXNAMELEN) return -E_BAD_PATH; memmove(name, p, path - p); name[path - p] = '\0'; path = skip_slash(path); if (dir-&gt;f_type != FTYPE_DIR) return -E_NOT_FOUND; if ((r = dir_lookup(dir, name, &amp;f)) &lt; 0) &#123; if (r == -E_NOT_FOUND &amp;&amp; *path == '\0') &#123; if (pdir) *pdir = dir; if (lastelem) strcpy(lastelem, name); *pf = 0; &#125; return r; &#125; &#125; if (pdir) *pdir = dir; *pf = f; return 0;&#125;// --------------------------------------------------------------// File operations// --------------------------------------------------------------// Create "path". On success set *pf to point at the file and return 0.// On error return &lt; 0. Âú®path ÂàõÂª∫Êñá‰ª∂Ôºå*pfÊåáÂêëÊñá‰ª∂ÔºüÔºüÔºüÔºüintfile_create(const char *path, struct File **pf)&#123; char name[MAXNAMELEN]; int r; struct File *dir, *f; if ((r = walk_path(path, &amp;dir, &amp;f, name)) == 0) return -E_FILE_EXISTS; if (r != -E_NOT_FOUND || dir == 0) return r; if ((r = dir_alloc_file(dir, &amp;f)) &lt; 0) return r; strcpy(f-&gt;f_name, name); *pf = f; file_flush(dir); return 0;&#125;// Open "path". On success set *pf to point at the file and return 0.// On error return &lt; 0. ÊâìÂºÄÊñá‰ª∂Ôºåpf ÊåáÂêëÊñá‰ª∂intfile_open(const char *path, struct File **pf)&#123; return walk_path(path, 0, pf, 0);&#125;// Read count bytes from f into buf, starting from seek position// offset. This meant to mimic the standard pread function.// Returns the number of bytes read, &lt; 0 on error.//Ëøô‰∏™ÂáΩÊï∞Ë¶ÅÁúãÊáÇÔºåÂÖ∂ÂÆûÂ∞±ÊòØÂú® f ÈáåÈù¢ËØª count ‰∏™Êñá‰ª∂Âà∞bufÈáåÈù¢Ôºåoffset ‰Ω†ÂèØ‰ª•ÁêÜËß£ÊàêÂÖâÊ†ássize_tfile_read(struct File *f, void *buf, size_t count, off_t offset)&#123; int r, bn; off_t pos; char *blk; if (offset &gt;= f-&gt;f_size)//Âà§Êñ≠ÂÖâÊ†áÊòØ‰∏çÊòØÊñá‰ª∂Â∞æ return 0; count = MIN(count, f-&gt;f_size - offset);//ÊúÄÂ§öËÉΩÂÜôËøô‰πàÂ§ö‰∏™ for (pos = offset; pos &lt; offset + count; ) &#123; if ((r = file_get_block(f, pos / BLKSIZE, &amp;blk)) &lt; 0) return r; bn = MIN(BLKSIZE - pos % BLKSIZE, offset + count - pos); memmove(buf, blk + pos % BLKSIZE, bn);//ËØªÂèñ pos += bn; buf += bn; &#125; return count;&#125;// Write count bytes from buf into f, starting at seek position// offset. This is meant to mimic the standard pwrite function.// Extends the file if necessary.// Returns the number of bytes written, &lt; 0 on error.//Âú®ÂÖâÊ†áÂêéÈù¢ÂÜô count ‰∏™Êñá‰ª∂intfile_write(struct File *f, const void *buf, size_t count, off_t offset)&#123; int r, bn; off_t pos; char *blk; // Extend file if necessary if (offset + count &gt; f-&gt;f_size)//Âà§Êñ≠ÈúÄ‰∏çÈúÄË¶ÅÊâ©Â§ßÊñá‰ª∂ if ((r = file_set_size(f, offset + count)) &lt; 0) return r; for (pos = offset; pos &lt; offset + count; ) &#123; if ((r = file_get_block(f, pos / BLKSIZE, &amp;blk)) &lt; 0) return r; bn = MIN(BLKSIZE - pos % BLKSIZE, offset + count - pos); memmove(blk + pos % BLKSIZE, buf, bn);//Â§çÂà∂ Ëøô‰∏™Êó∂ÂÄôÂÜôÂÆåÂÖ∂ÂÆûËøòÊòØÂú®ÂÜÖÂ≠òÈáåÈù¢ÔºåÂπ∂Ê≤°ÊúâÂÜôÂà∞Á£ÅÁõò pos += bn; buf += bn; &#125; return count;&#125;// Remove a block from file f. If it's not there, just silently succeed.// Returns 0 on success, &lt; 0 on error. ‰ªéf ÈáåÈù¢Âà†Èô§Âùó Á¨¨filebnostatic intfile_free_block(struct File *f, uint32_t filebno)&#123; int r; uint32_t *ptr; if ((r = file_block_walk(f, filebno, &amp;ptr, 0)) &lt; 0) return r; if (*ptr) &#123; free_block(*ptr); *ptr = 0; &#125; return 0;&#125;// Remove any blocks currently used by file 'f',// but not necessary for a file of size 'newsize'.// For both the old and new sizes, figure out the number of blocks required,// and then clear the blocks from new_nblocks to old_nblocks.// If the new_nblocks is no more than NDIRECT, and the indirect block has// been allocated (f-&gt;f_indirect != 0), then free the indirect block too.// (Remember to clear the f-&gt;f_indirect pointer so you'll know// whether it's valid!)// Do not change f-&gt;f_size.//ÊääÊñ∞Â§ßÂ∞èÂà∞ ÊóßÁöÑÂ§ßÂ∞è‰πãÈó¥ÁöÑÂùóÂÖ®ÈÉ®Âà†Èô§„ÄÇÂ¶ÇÊûú‰∏çÈúÄË¶ÅÈó¥Êé•Âùó‰∫ÜÔºåÊää‰ªñ‰πüÂà†‰∫ÜÔºå‰∏çÁî®‰øÆÊîπÊñá‰ª∂Â§ßÂ∞èstatic voidfile_truncate_blocks(struct File *f, off_t newsize)&#123; int r; uint32_t bno, old_nblocks, new_nblocks; old_nblocks = (f-&gt;f_size + BLKSIZE - 1) / BLKSIZE; new_nblocks = (newsize + BLKSIZE - 1) / BLKSIZE; for (bno = new_nblocks; bno &lt; old_nblocks; bno++) if ((r = file_free_block(f, bno)) &lt; 0) cprintf("warning: file_free_block: %e", r); if (new_nblocks &lt;= NDIRECT &amp;&amp; f-&gt;f_indirect) &#123; free_block(f-&gt;f_indirect); f-&gt;f_indirect = 0; &#125;&#125;// Set the size of file f, truncating or extending as necessary. ËÆæÁΩÆÊñá‰ª∂Â§ßÂ∞èintfile_set_size(struct File *f, off_t newsize)&#123; if (f-&gt;f_size &gt; newsize) file_truncate_blocks(f, newsize); f-&gt;f_size = newsize; flush_block(f); return 0;&#125;// Flush the contents and metadata of file f out to disk.// Loop over all the blocks in file.// Translate the file block number into a disk block number// and then check whether that disk block is dirty. If so, write it out.//Âà∑Êñ∞Êñá‰ª∂ ÂÜôÂÖ•Âà∞Á£ÅÁõò‰∫Üvoidfile_flush(struct File *f)&#123; int i; uint32_t *pdiskbno; for (i = 0; i &lt; (f-&gt;f_size + BLKSIZE - 1) / BLKSIZE; i++) &#123; if (file_block_walk(f, i, &amp;pdiskbno, 0) &lt; 0 || pdiskbno == NULL || *pdiskbno == 0) continue; flush_block(diskaddr(*pdiskbno)); &#125; flush_block(f); if (f-&gt;f_indirect) flush_block(diskaddr(f-&gt;f_indirect));&#125;// Sync the entire file system. A big hammer. Âà∑Êñ∞ Êï¥‰∏™Êñá‰ª∂Á≥ªÁªüvoidfs_sync(void)&#123; int i; for (i = 1; i &lt; super-&gt;s_nblocks; i++) flush_block(diskaddr(i));&#125; Áªà‰∫éÁúãÂÆå‰∫Ü„ÄÇÁúãÂÆå‰πãÂêéÂëäËØâ‰Ω†ÔºåÂÆûÈôÖ‰∏äÊ≤°Âï•ÂçµÁî®„ÄÇ The file system interfaceÁé∞Âú®Êàë‰ª¨ÁöÑÊñá‰ª∂Á≥ªÁªüÁéØÂ¢ÉÂ∑≤ÁªèÂÖ∑ÊúâÂøÖË¶ÅÁöÑÂäüËÉΩÔºåÊàë‰ª¨ÂøÖÈ°ªËÆ©ÂÖ∂‰ªñÂ∏åÊúõ‰ΩøÁî®Êñá‰ª∂Á≥ªÁªüÁöÑÁî®Êà∑ÁéØÂ¢ÉÂèØ‰ª•ËÆøÈóÆÊñá‰ª∂Á≥ªÁªü„ÄÇÁî±‰∫éÂÖ∂‰ªñÁî®Êà∑ÁéØÂ¢É‰∏çËÉΩÁõ¥Êé•Ë∞ÉÁî®Êñá‰ª∂Á≥ªÁªüÁéØÂ¢É‰∏≠ÁöÑÂáΩÊï∞ÔºåÂõ†Ê≠§Êàë‰ª¨Â∞ÜÈÄöËøáËøúÁ®ãËøáÁ®ãË∞ÉÁî®ÔºàRPCÔºâÂç≥Âú®JOSÁöÑIPCÊú∫Âà∂‰∏äÂ∞ÅË£ÖÊûÑÂª∫ÁöÑÂØπÊñá‰ª∂Á≥ªÁªüÁéØÂ¢ÉÁöÑËÆøÈóÆÊé•Âè£„ÄÇÂ¶Ç‰∏ãÂõæÊâÄÁ§∫ÔºåÂØπÊñá‰ª∂Á≥ªÁªüÊúçÂä°Âô®ÁöÑË∞ÉÁî®ÔºàÊØîÂ¶ÇËØ¥ÔºåreadÔºâÔºö Regular env FS env +---------------+ +---------------+ | read | | file_read | | (lib/fd.c) | | (fs/fs.c) | ...|.......|.......|...|.......^.......|............... | v | | | | RPC mechanism | devfile_read | | serve_read | | (lib/file.c) | | (fs/serv.c) | | | | | ^ | | v | | | | | fsipc | | serve | | (lib/file.c) | | (fs/serv.c) | | | | | ^ | | v | | | | | ipc_send | | ipc_recv | | | | | ^ | +-------|-------+ +-------|-------+ | | +-------------------+ ÁÆÄÂçïÊù•ËÆ≤ÔºåÂ∞±ÊòØÊàëË¶ÅËÆøÈóÆÁ£ÅÁõòÔºåÂÖàÈÄöËøáIPCÂèëÁªôÂè¶‰∏Ä‰∏™ËøõÁ®ãÔºåÁÑ∂ÂêéÂè¶‰∏Ä‰∏™ËøõÁ®ãÂ∏ÆÊàëËÆøÈóÆÔºåÂ∞±ÊòØËøôÊ†∑‰∫Ü ËôöÁ∫ø‰ª•‰∏ãÁöÑÊâÄÊúâÂÜÖÂÆπÈÉΩÂè™ÊòØ‰ªéÂ∏∏ËßÑÁî®Êà∑ÁéØÂ¢ÉÂà∞Êñá‰ª∂Á≥ªÁªüÁéØÂ¢ÉÁöÑËØªÂèñËØ∑Ê±ÇÁöÑÊú∫Âà∂„ÄÇ‰ªéÊúÄÂºÄÂßãÔºåreadÈÄÇÁî®‰∫é‰ªª‰ΩïÊñá‰ª∂ÊèèËø∞Á¨¶ÔºåÂπ∂‰∏îÁÆÄÂçïÂú∞ÂàÜÂèëÂà∞ÈÄÇÂΩìÁöÑËÆæÂ§áËØªÂèñÂáΩÊï∞ÔºåÂú®ËøôÁßçÊÉÖÂÜµ‰∏ã‰∏∫devfile_readÊàë‰ª¨ÂèØ‰ª•ÊúâÊõ¥Â§öÁöÑËÆæÂ§áÁ±ªÂûãÔºåÂ¶ÇÁÆ°ÈÅì„ÄÇdevfile_read‰∏ìÈó®ÂÆûÁé∞‰∏∫ËØªÂèñÁ£ÅÁõòÊñá‰ª∂„ÄÇlib/file.c‰∏≠ÁöÑdevfile_readÂíåÂÖ∂‰ªñdevfile_*ÂáΩÊï∞ÂÆûÁé∞‰∫ÜÂÆ¢Êà∑Á´ØFSÊìç‰ΩúÔºåÂπ∂‰∏îÈÉΩ‰ª•Â§ßËá¥Áõ∏ÂêåÁöÑÊñπÂºèÂ∑•‰ΩúÔºåÂú®requestÁªìÊûÑ‰Ωì‰∏≠Â∞ÅË£ÖÂèÇÊï∞ÔºåË∞ÉÁî®fsipcÂèëÈÄÅIPCËØ∑Ê±ÇÔºåÂπ∂Ëß£ÂåÖÂíåËøîÂõûÁªìÊûú„ÄÇ fsipcÂáΩÊï∞ÁÆÄÂçïÂú∞Â§ÑÁêÜÂêëÊúçÂä°Âô®ÂèëÈÄÅËØ∑Ê±ÇÂπ∂Êé•Êî∂ÂõûÂ§çÁöÑÂ∏∏ËßÅÁªÜËäÇ„ÄÇ Êñá‰ª∂Á≥ªÁªüÊúçÂä°Âô®‰ª£Á†ÅÂèØ‰ª•Âú®fs/serv.c‰∏≠ÊâæÂà∞„ÄÇÂÆÉÂú®serveÂáΩÊï∞‰∏≠Âæ™ÁéØÔºåÊó†‰ºëÊ≠¢Âú∞ÈÄöËøáIPCÊé•Êî∂ËØ∑Ê±ÇÔºåÂ∞ÜËØ•ËØ∑Ê±ÇÂàÜÂèëÂà∞ÈÄÇÂΩìÁöÑÂ§ÑÁêÜÂáΩÊï∞ÔºåÂπ∂ÈÄöËøáIPCÂèëÈÄÅÁªìÊûú„ÄÇÂú®readÁ§∫‰æã‰∏≠ÔºåserveÂáΩÊï∞Â∞ÜËØ∑Ê±ÇÂàÜÂèëÂà∞serve_readÔºåÂÆÉÂ∞ÜÂ§ÑÁêÜreadËØ∑Ê±ÇÊåáÂÆöÁöÑIPCÁªÜËäÇÔºå‰æãÂ¶ÇËß£ÂåÖrequestÁªìÊûÑ‰ΩìÔºåÊúÄÂêéË∞ÉÁî®file_readÊù•ÂÆûÈôÖÊâßË°åÊñá‰ª∂ËØªÂèñ„ÄÇ ÂõûÊÉ≥‰∏Ä‰∏ãÔºåJOSÁöÑIPCÊú∫Âà∂ÂÖÅËÆ∏Áî®Êà∑ÁéØÂ¢ÉÂèëÈÄÅ‰∏Ä‰∏™32‰ΩçÊï∞Â≠óÔºåÂπ∂‰∏îÂèØÈÄâÂú∞ÂÖ±‰∫´‰∏Ä‰∏™È°µÈù¢„ÄÇË¶Å‰ªéÂÆ¢Êà∑Á´ØÂèëÈÄÅËØ∑Ê±ÇÂà∞ÊúçÂä°Âô®ÔºåÊàë‰ª¨‰ΩøÁî®32‰ΩçÊï∞Â≠ó‰Ωú‰∏∫ËØ∑Ê±ÇÁ±ªÂûãÔºàÊñá‰ª∂Á≥ªÁªüÊúçÂä°Âô®RPC‰πüÊòØÂÉèÁ≥ªÁªüË∞ÉÁî®ÁºñÂè∑ÈÇ£Ê†∑ÁºñÂè∑ÔºâÔºåÂπ∂Â∞ÜÂèÇÊï∞Â≠òÂÇ®Âú®ÈÄöËøáIPCÂÖ±‰∫´È°µÈù¢ÁöÑFsipcËÅîÂêàÁ±ªÂûã‰∏≠ÁöÑrequestÁªìÊûÑ‰Ωì‰∏≠„ÄÇÂú®ÂÆ¢Êà∑Á´ØÔºåÊàë‰ª¨ÊÄªÊòØÂú®fsipcbufÂÖ±‰∫´È°µÈù¢;Âú®ÊúçÂä°Âô®Á´ØÔºåÊàë‰ª¨Â∞Ü‰º†ÂÖ•ËØ∑Ê±ÇÈ°µÊò†Â∞ÑÂà∞fsreqÔºà0x0ffff000Ôºâ„ÄÇÁÆÄÂçïÊù•ËØ¥Ôºå32‰Ωç‰Ωú‰∏∫ËØ∑Ê±ÇÁ±ªÂûãÔºåÈ°µÊîæÂà∞fsreqÔºåÂπ∂‰∏îÂÇ®Â≠òÂà∞request`ÁªìÊûÑ‰Ωì‰∏≠ ÊúçÂä°Âô®ËøòÈÄöËøáIPCÂèëÂõûÂìçÂ∫î„ÄÇÊàë‰ª¨‰ΩøÁî®32‰ΩçÊï∞Â≠ó‰Ωú‰∏∫ÂáΩÊï∞ÁöÑËøîÂõûÁ†Å„ÄÇÂØπ‰∫éÂ§ßÂ§öÊï∞RPCÔºåËøô‰∫õÊòØ‰ªñ‰ª¨ËøîÂõûÁöÑÂÖ®ÈÉ®ÂÜÖÂÆπ„ÄÇFSREQ_READÂíåFSREQ_STAT‰πüËøîÂõûÊï∞ÊçÆÔºåÂÆÉ‰ª¨Âè™ÊòØÂ∞ÜÊï∞ÊçÆÂÜôÂÖ•ÂÆ¢Êà∑Á´ØÂèëÈÄÅËØ∑Ê±ÇÁöÑÈ°µÈù¢„ÄÇÊó†ÈúÄÂú®ÂìçÂ∫îIPC‰∏≠ÂèëÈÄÅÊ≠§È°µÈù¢ÔºåÂõ†‰∏∫ÂÆ¢Êà∑Á´ØÈ¶ñÂÖà‰∏éÊñá‰ª∂Á≥ªÁªüÊúçÂä°Âô®ÂÖ±‰∫´„ÄÇÊ≠§Â§ñÔºåÂú®ÂÖ∂ÂõûÂ§ç‰∏≠ÔºåFSREQ_OPEN‰∏éÂÆ¢Êà∑Á´ØÂÖ±‰∫´‰∏Ä‰∏™Êñ∞ÁöÑFd page„ÄÇÊàë‰ª¨Â∞ÜÂæàÂø´ËøîÂõûÂà∞Êñá‰ª∂ÊèèËø∞Á¨¶È°µÈù¢„ÄÇÁªÉ‰π†5ÂíåÁªÉ‰π†6 ËÆ©Êàë‰ª¨ÂÆûÁé∞serve_readÂíåserve_writeÔºådevfile_writeÔºåÊàë‰ª¨Áõ¥Êé•‰∏ÄËµ∑Áúã‰∫Ü„ÄÇÂú®ÂÅö‰πãÂâç‰∫ÜËß£‰∏Ä‰∏ã1234567891011121314151617181920212223242526// The file system server maintains three structures// for each open file.//ÊúçÂä°Âô®ÁöÑ‰∏âÂ±Ç ÁªìÊûÑ// 1. The on-disk 'struct File' is mapped into the part of memory// that maps the disk. This memory is kept private to the file// server. //Á£ÅÁõòÊñá‰ª∂Â±Ç Â∞±ÊòØ struct FileÔºåÂâçÈù¢ÊàëÂ∑≤ÁªèÁúãËøá‰∫Ü// 2. Each open file has a 'struct Fd' as well, which sort of// corresponds to a Unix file descriptor. This 'struct Fd' is kept// on *its own page* in memory, and it is shared with any// environments that have the file open. // ÊØè‰∏™ÂºÄÊîæÁöÑÊñá‰ª∂ÈÉΩÊúâ‰ªñËá™Â∑±ÁöÑ ÊèèËø∞ struct FdÔºå‰æõÊâÄÊúâÁéØÂ¢É‰ΩøÁî®// 3. 'struct OpenFile' links these other two structures, and is kept// private to the file server. The server maintains an array of// all open files, indexed by "file ID". (There can be at most// MAXOPEN files open concurrently.) The client uses file IDs to// communicate with the server. File IDs are a lot like// environment IDs in the kernel. Use openfile_lookup to translate// file IDs to struct OpenFile. struct OpenFile' Â∞Ü‰∏§ËÄÖËÅîÁ≥ªËµ∑Êù•ÔºåÂπ∂‰øùÊåÅÁßÅÊúâ// ÂÆ¢ÊúçÁ´ØÈÄöËøáid‰∏é ÊúçÂä°Âô®ÈÄö‰ø°ÔºåÂ∞±ÂÉèËøõÁ®ãIDÔºå‰ΩøÁî® openfile_lookup ÂèØ‰ª•Ëé∑ÂæóÂØπÂ∫îOpenFilestruct OpenFile &#123; uint32_t o_fileid; // file id struct File *o_file; // mapped descriptor for open file int o_mode; // open mode struct Fd *o_fd; // Fd page&#125;; Êàë‰ª¨ÂÖàÁúãÁúãreadÊòØÊÄé‰πàÊâßË°åÁöÑÂêß„ÄÇ readread‰∏ÄÂºÄÂßãÂú®file.c ÈáåÈù¢Ë∞ÉÁî®devfile_readÔºåÊàë‰ª¨ÁúãÁúãÊÄé‰πàÂÆûÁé∞ÁöÑ„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839// Read at most 'n' bytes from 'fd' at the current position into 'buf'.//cong fd ËØªn ‰∏™Â≠óËäÇÂà∞buf ÈáåÈù¢„ÄÇ// Returns:// The number of bytes successfully read.// &lt; 0 on error.static ssize_tdevfile_read(struct Fd *fd, void *buf, size_t n)&#123; // fd Â∫îËØ•ÊòØÊâìÂºÄÁöÑÊñá‰ª∂ÔºåbufÔºå‰øùÂ≠òËØªÂá∫Êù•ÁöÑÂÄºÔºånÊòØËØªÁöÑÂ§ßÂ∞è ËøîÂõû‰∫ÜËØª‰∫ÜÂá†‰∏™ÂÄº // Make an FSREQ_READ request to the file system server after // filling fsipcbuf.read with the request arguments. The // bytes read will be written back to fsipcbuf by the file // system server. int r; fsipcbuf.read.req_fileid = fd-&gt;fd_file.id; //fsipcbuf ‰Ωú‰∏∫‰ø°ÊÅØ‰º†ÈÄí fsipcbuf.read.req_n = n; if ((r = fsipc(FSREQ_READ, NULL)) &lt; 0)//fsipc Â∞±ÊòØÂàÜÈÖçÂáΩÊï∞ return r; assert(r &lt;= n); assert(r &lt;= PGSIZE); memmove(buf, fsipcbuf.readRet.ret_buf, r);//ËøîÂõûÁöÑÂÄºÂú®ret_buf ÈáåÈù¢ return r;&#125;static intfsipc(unsigned type, void *dstva) //Ëøô‰∏™Êó∂ÂÄôdstva Â∫îËØ•ÊòØÁ©∫&#123; static envid_t fsenv; if (fsenv == 0) fsenv = ipc_find_env(ENV_TYPE_FS); static_assert(sizeof(fsipcbuf) == PGSIZE); if (debug) cprintf("[%08x] fsipc %d %08x\n", thisenv-&gt;env_id, type, *(uint32_t *)&amp;fsipcbuf); ipc_send(fsenv, type, &amp;fsipcbuf, PTE_P | PTE_W | PTE_U); return ipc_recv(NULL, dstva, NULL);//ÁõÆÂâçÊù•ËØ¥ Ëøô‰∏™dstva ÊòØ‰∏™Á©∫ÂÄºÔºåÊâÄ‰ª•ÂÆûÈôÖ‰∏äÊ≤°Âï•ËøîÂõûÂÄº„ÄÇ ÂÜôÂõûÊòØÈÄöËøáÂÖ±‰∫´È°µÈù¢ÂÆûÁé∞ÁöÑ„ÄÇÂÖ±‰∫´‰∫ÜËøô‰∏™fsipcbuf&#125; ÁÑ∂ÂêéÂ∞±ÂèëÈÄÅÂà∞‰∫ÜÊàë‰ª¨ÂéüÊú¨ËØ¥ÁöÑserv.cÈáåÈù¢Âéª‰∫Ü„ÄÇserv.cÊúÄÁªàËøêË°å‰∫Üserve„ÄÇ1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162voidserve(void)&#123; uint32_t req, whom; int perm, r; void *pg; while (1) &#123; //ÊòéÊòæÊòØ‰∏™Êó†ÈôêÂæ™ÁéØÔºåÊâÄ‰ª•Ëøô‰∏™ËøõÁ®ãÂÄºÂú®ËøôËøêË°å perm = 0; //Âú®ËøôÁ≠âÂæÖÊé•Êî∂ÔºåÊàë‰ª¨Áé∞Âú®ËøôÁßçÊÉÖÂÜµÔºåÂ∞±ÊòØÊé•Êî∂Âà∞‰∫Ü ÂàöÊâçÂèëÈÄÅÁöÑÈÇ£‰∏™ req = ipc_recv((int32_t *) &amp;whom, fsreq, &amp;perm); if (debug) cprintf("fs req %d from %08x [page %08x: %s]\n", req, whom, uvpt[PGNUM(fsreq)], fsreq); // All requests must contain an argument page if (!(perm &amp; PTE_P)) &#123; cprintf("Invalid request from %08x: no argument page\n", whom); continue; // just leave it hanging... &#125; pg = NULL; if (req == FSREQ_OPEN) &#123; r = serve_open(whom, (struct Fsreq_open*)fsreq, &amp;pg, &amp;perm); &#125; else if (req &lt; ARRAY_SIZE(handlers) &amp;&amp; handlers[req]) &#123; //Ëøô‰∏™ÂÜôÊ≥ïÈùûÂ∏∏È™öÊ∞îÔºå r = handlers[req](whom, fsreq);//Ëøô‰∏™Êó∂ÂÄôÊ†πÊçÆreqÂàÜÈÖç‰∫ÜÂáΩÊï∞„ÄÇÊàë‰ª¨Áé∞Âú®‰πüÂ∞±ÊòØserve_read &#125; else &#123; cprintf("Invalid request code %d from %08x\n", req, whom); r = -E_INVAL; &#125; ipc_send(whom, r, pg, perm); sys_page_unmap(0, fsreq); &#125;&#125;// ÊâÄ‰ª•Êàë‰ª¨Â∞±Ë∑ëÂà∞‰∫ÜËøô‰∏™ÂáΩÊï∞// Read at most ipc-&gt;read.req_n bytes from the current seek position// in ipc-&gt;read.req_fileid. Return the bytes read from the file to// the caller in ipc-&gt;readRet, then update the seek position. Returns// the number of bytes successfully read, or &lt; 0 on error.//Fsipc ÈáåÈù¢Â≠ò‰∫ÜÊàë‰ª¨ÊâÄÈúÄË¶ÅÁöÑ‰∏úË•ø„ÄÇintserve_read(envid_t envid, union Fsipc *ipc)&#123; struct Fsreq_read *req = &amp;ipc-&gt;read;//ËØ∑Ê±Ç struct Fsret_read *ret = &amp;ipc-&gt;readRet;//ËøîÂõûÁöÑÁªìÊûú if (debug) cprintf("serve_read %08x %08x %08x\n", envid, req-&gt;req_fileid, req-&gt;req_n); // Lab 5: Your code here: int r=0; struct OpenFile *o; //openfile_lookupËøô‰∏™ÂáΩÊï∞ÊòØÊü•Êâæ ÊâìÂºÄÁöÑÊñá‰ª∂ if ((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;o)) &lt; 0) return r; r=file_read(o-&gt;o_file,ret,req-&gt;req_n,o-&gt;o_fd-&gt;fd_offset); if(r&gt;=0)o-&gt;o_fd-&gt;fd_offset+=r; return r;&#125; writeÁúãÂÆåreadÔºåwrite‰πüÊòØ‰∏ÄÊ†∑ÁöÑÁÖßÊê¨Â∞±Ë°å‰∫Ü„ÄÇ 123456789101112131415161718192021// Write at most 'n' bytes from 'buf' to 'fd' at the current seek position.//// Returns:// The number of bytes successfully written.// &lt; 0 on error.static ssize_tdevfile_write(struct Fd *fd, const void *buf, size_t n)&#123; // Make an FSREQ_WRITE request to the file system server. Be // careful: fsipcbuf.write.req_buf is only so large, but // remember that write is always allowed to write *fewer* // bytes than requested. // LAB 5: Your code here if ( n &gt; sizeof (fsipcbuf.write.req_buf)) n = sizeof (fsipcbuf.write.req_buf); fsipcbuf.write.req_fileid = fd-&gt;fd_file.id; fsipcbuf.write.req_n = n; memmove(fsipcbuf.write.req_buf, buf, n); //ÂÖàÊääÂÜôÁöÑÂÜÖÂÆπÂ§çÂà∂ return fsipc(FSREQ_WRITE, NULL);//ÁÑ∂ÂêéÂèëÈÄÅËøáÂéª //panic("devfile_write not implemented");&#125; 123456789101112131415161718192021// Write req-&gt;req_n bytes from req-&gt;req_buf to req_fileid, starting at// the current seek position, and update the seek position// accordingly. Extend the file if necessary. Returns the number of// bytes written, or &lt; 0 on error.intserve_write(envid_t envid, struct Fsreq_write *req)&#123; if (debug) cprintf("serve_write %08x %08x %08x\n", envid, req-&gt;req_fileid, req-&gt;req_n); // LAB 5: Your code here. int r=0; struct OpenFile *o; if ((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;o)) &lt; 0) return r; //ÂâçÈù¢ËÇØÂÆö‰∏ÄÊ†∑ÁöÑ r=file_write(o-&gt;o_file,req-&gt;req_buf,req-&gt;req_n,o-&gt;o_fd-&gt;fd_offset);//‰∏çÂêåÁöÑÂ∞±Âè™ÊúâËøôÔºåËøôË∞ÉÁî®ÁöÑÊòØfile_write if(r&gt;=0)o-&gt;o_fd-&gt;fd_offset+=r; return r; //panic("serve_write not implemented");&#125; ÂÖ∂‰ªñÂáΩÊï∞ÁöÑË∞ÉÁî®ËøáÁ®ãËá™Ë°åÂàÜÊûê‰∫Ü„ÄÇ Spawning ProcessesÊàë‰ª¨Â∑≤ÁªèÁªô‰Ω†Êèê‰æõ‰∫ÜÁîüÊàê‰∏Ä‰∏™Êñ∞ÁöÑÁî®Êà∑ÁéØÂ¢ÉspawnÁöÑ‰ª£Á†ÅÔºàÂèÇËßÅlib/spawn.cÔºâÔºåÂ∞ÜÊñá‰ª∂Á≥ªÁªü‰∏≠ÁöÑÁ®ãÂ∫èÈïúÂÉèÂä†ËΩΩÂà∞Áî®Êà∑ÁéØÂ¢É‰∏≠ÔºåÁÑ∂ÂêéÂêØÂä®ËøêË°åÊ≠§Á®ãÂ∫èÁöÑÂ≠êÁéØÂ¢É„ÄÇÁÑ∂ÂêéÔºåÁà∂ËøõÁ®ãÁªßÁª≠Áã¨Á´ã‰∫éËØ•Â≠êËøõÁ®ãËøêË°å„ÄÇspawnÂáΩÊï∞Â∞±ÂÉèUNIX‰∏≠forkÂêéÈù¢Á¥ßÊé•ÁùÄÂú®Â≠êËøõÁ®ã‰∏≠ÊâßË°åexec„ÄÇ Êàë‰ª¨ÂÆûÁé∞‰∫ÜspawnËÄå‰∏çÊòØ‰∏Ä‰∏™UNIXÈ£éÊ†ºÁöÑexecÔºåÂõ†‰∏∫Âú®exkernelÊñπÂºè‰∏ãÔºåÂú®Áî®Êà∑Á©∫Èó¥‰∏çÂÄüÂä©ÂÜÖÊ†∏ÁöÑÁâπÊÆäÂ∏ÆÂä©‰∏≠Êõ¥ÂÆπÊòìÂÆûÁé∞spawn„ÄÇÊÉ≥ÊÉ≥‰Ω†Âú®Áî®Êà∑Á©∫Èó¥ÂÆûÁé∞execÊó∂ÂøÖÈ°ªÂÅö‰ªÄ‰πàÔºåÂπ∂Á°Æ‰øù‰Ω†ÊòéÁôΩ‰∏∫‰ªÄ‰πàÊõ¥Èöæ„ÄÇÁªÉ‰π†7 Âè™Ë¶ÅÊàë‰ª¨ÂÆûÁé∞sys_env_set_trapframe„ÄÇÊàë‰ª¨ÂÖàÁúãÁúãspawn ÂÅö‰∫ÜÂï•123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134// Spawn a child process from a program image loaded from the file system. // ‰ªéÊñá‰ª∂Âä†ËΩΩ‰∫Ü‰∏Ä‰∏™Â≠êËøõÁ®ã// prog: the pathname of the program to run. Êñá‰ª∂Ë∑ØÂæÑ// argv: pointer to null-terminated array of pointers to strings, ÂèÇÊï∞// which will be passed to the child as its command-line arguments.// Returns child envid on success, &lt; 0 on failure.intspawn(const char *prog, const char **argv)&#123; unsigned char elf_buf[512]; struct Trapframe child_tf; envid_t child; int fd, i, r; struct Elf *elf; struct Proghdr *ph; int perm; // This code follows this procedure: // ÂêéÈù¢ËôΩÁÑ∂Êúâ‰∏ÄÂ§ßÂ†ÜÔºå‰ΩÜÊòØÂ§ßÈÉ®ÂàÜÊ≤°Âï•Áî® // - Open the program file. // // - Read the ELF header, as you have before, and sanity check its // magic number. (Check out your load_icode!) // ËØªÂèñELF // - Use sys_exofork() to create a new environment. // ÂàõÂª∫ËøõÁ®ã // - Set child_tf to an initial struct Trapframe for the child. // ËÆæÁΩÆtf // - Call the init_stack() function above to set up // the initial stack page for the child environment. // ÂàùÂßãÂåñÂ†ÜÊ†àÔºåÊúâÂÖ¥Ë∂£ÁöÑËá™Â∑±ÁúãÁúãÁúã ÂêéÈù¢ÈÉΩÊòØÂÜôÁªÜËäÇ‰∫Ü // - Map all of the program's segments that are of p_type // ELF_PROG_LOAD into the new environment's address space. // Use the p_flags field in the Proghdr for each segment // to determine how to map the segment: // // * If the ELF flags do not include ELF_PROG_FLAG_WRITE, // then the segment contains text and read-only data. // Use read_map() to read the contents of this segment, // and map the pages it returns directly into the child // so that multiple instances of the same program // will share the same copy of the program text. // Be sure to map the program text read-only in the child. // Read_map is like read but returns a pointer to the data in // *blk rather than copying the data into another buffer. // // * If the ELF segment flags DO include ELF_PROG_FLAG_WRITE, // then the segment contains read/write data and bss. // As with load_icode() in Lab 3, such an ELF segment // occupies p_memsz bytes in memory, but only the FIRST // p_filesz bytes of the segment are actually loaded // from the executable file - you must clear the rest to zero. // For each page to be mapped for a read/write segment, // allocate a page in the parent temporarily at UTEMP, // read() the appropriate portion of the file into that page // and/or use memset() to zero non-loaded portions. // (You can avoid calling memset(), if you like, if // page_alloc() returns zeroed pages already.) // Then insert the page mapping into the child. // Look at init_stack() for inspiration. // Be sure you understand why you can't use read_map() here. // // Note: None of the segment addresses or lengths above // are guaranteed to be page-aligned, so you must deal with // these non-page-aligned values appropriately. // The ELF linker does, however, guarantee that no two segments // will overlap on the same page; and it guarantees that // PGOFF(ph-&gt;p_offset) == PGOFF(ph-&gt;p_va). // // - Call sys_env_set_trapframe(child, &amp;child_tf) to set up the // correct initial eip and esp values in the child. // // - Start the child process running with sys_env_set_status(). if ((r = open(prog, O_RDONLY)) &lt; 0) return r; fd = r; // Read elf header elf = (struct Elf*) elf_buf; //readn Âú®fd.cÈáåÈù¢ ÂèØ‰ª•ÁúãÁúãÂ∫ïÂ±ÇË∞ÉÁî®‰∫Ü dev_read Â∫îËØ•Â∞±ÊòØÂâçÈù¢ÂÆûÁé∞ÁöÑÈÇ£‰∏™ÂáΩÊï∞ if (readn(fd, elf_buf, sizeof(elf_buf)) != sizeof(elf_buf)//ËØªÂèñelf Â§¥ÈÉ® || elf-&gt;e_magic != ELF_MAGIC) &#123; close(fd); cprintf("elf magic %08x want %08x\n", elf-&gt;e_magic, ELF_MAGIC); return -E_NOT_EXEC; &#125; // Create new child environment if ((r = sys_exofork()) &lt; 0) return r; child = r; //Â§çÂà∂ËøõÁ®ã // Set up trap frame, including initial stack.ÂàùÂßãÂåñtf child_tf = envs[ENVX(child)].env_tf; child_tf.tf_eip = elf-&gt;e_entry; if ((r = init_stack(child, argv, &amp;child_tf.tf_esp)) &lt; 0) return r; // Set up program segments as defined in ELF header. Ëøô‰∏™ÂæàÁúºÁÜüÂêß ph = (struct Proghdr*) (elf_buf + elf-&gt;e_phoff); for (i = 0; i &lt; elf-&gt;e_phnum; i++, ph++) &#123; if (ph-&gt;p_type != ELF_PROG_LOAD) continue; perm = PTE_P | PTE_U; if (ph-&gt;p_flags &amp; ELF_PROG_FLAG_WRITE) perm |= PTE_W; if ((r = map_segment(child, ph-&gt;p_va, ph-&gt;p_memsz, fd, ph-&gt;p_filesz, ph-&gt;p_offset, perm)) &lt; 0) goto error; &#125; close(fd); fd = -1; // Copy shared library state. if ((r = copy_shared_pages(child)) &lt; 0) panic("copy_shared_pages: %e", r); child_tf.tf_eflags |= FL_IOPL_3; // devious: see user/faultio.c if ((r = sys_env_set_trapframe(child, &amp;child_tf)) &lt; 0)//Âú®Ëøô‰∏™Âú∞ÊñπË∞ÉÁî®‰∫Üsys_env_set_trapframe Êàë‰ª¨ÂèØ‰ª•ÁúãÂà∞ child_tf ÂâçÈù¢Â∑≤ÁªèÂ∏ÆÊàë‰ª¨ËÆæÁΩÆÂ•Ω‰∫Ü„ÄÇ panic("sys_env_set_trapframe: %e", r); if ((r = sys_env_set_status(child, ENV_RUNNABLE)) &lt; 0) panic("sys_env_set_status: %e", r); return child;error: sys_env_destroy(child); close(fd); return r;&#125; Âõ†‰∏∫‰º†ËøõÊù•ÁöÑtfÂ∑≤ÁªèËÆæÁΩÆÂ•Ω‰∫ÜÔºåÊâÄ‰ª•Êàë‰ª¨Áõ¥Êé•ÊîπÂ∞±Ë°å‰∫Ü123456789101112131415161718192021222324// Set envid's trap frame to 'tf'.// tf is modified to make sure that user environments always run at code// protection level 3 (CPL 3), interrupts enabled, and IOPL of 0.//// Returns 0 on success, &lt; 0 on error. Errors are:// -E_BAD_ENV if environment envid doesn't currently exist,// or the caller doesn't have permission to change envid.static intsys_env_set_trapframe(envid_t envid, struct Trapframe *tf)&#123; // LAB 5: Your code here. // Remember to check whether the user has supplied us with a good // address! struct Env *child; if((envid2env(envid,&amp;child,1))&lt;0)&#123; return -E_BAD_ENV; &#125;//Âà§Êñ≠ËøõÁ®ãid ÊòØ‰∏çÊòØÊúâÊïàÁöÑ child-&gt;env_tf=*tf;//Áõ¥Êé•ÊåáËøáÂéª child-&gt;env_tf.tf_cs |= 0x3; //‰øÆÊîπ‰∏Ä‰∏ãÊèêÁ§∫Ë¶ÅÊ±ÇÁöÑÂÄº child-&gt;env_tf.tf_eflags &amp;= (~FL_IOPL_MASK); child-&gt;env_tf.tf_eflags |= FL_IF; return 0; //panic("sys_env_set_trapframe not implemented");&#125; ËÆæÁΩÆÂÆåÂêéËÆ∞ÂæóÊ∑ªÂä†syscall.12 case SYS_env_set_trapframe:return sys_env_set_trapframe((envid_t)a1,(struct Trapframe*)a2); ËØ¥‰∏Ä‰∏ãÊàëÊµãËØïÁöÑÊó∂ÂÄôÂèëÁé∞ÔºåÊµãËØïÊñá‰ª∂ÈáåÈù¢Êúâ‰∏Ä‰∏™ÂçïËØçÂíå‰ª£Á†Å‰∏ç‰∏ÄÊ†∑„ÄÇÂú®grade-lab5ÈáåÈù¢Êúâ‰∏Ä‰∏™environmentsÂçïËØçÂíå‰ª£Á†ÅÈáåÈù¢Â∑Æ‰∫Ü‰∏Ä‰∏™a,Êàë‰øÆÊîπ‰∫Ü‰∏Ä‰∏ãÔºåÂ¶ÇÊûúÊ≤°ÈîôÁöÑËØùÔºåÂΩìÊàëÊ≤°ËØ¥„ÄÇenvironmentsÂíåenvironmeantsÊêú‰∫Ü‰∏Ä‰∏ãÂçïËØçÊÑèÊÄùÂ•ΩÂÉèÊòØ‰∏ÄÊ†∑ÁöÑ„ÄÇ1234567@test(10, "spawn via spawnhello")def test_spawn(): r.user_test("spawnhello") r.match('i am parent environment 00001001', 'hello, world', 'i am environment 00001002', 'No runnable environmeants in the system!') Sharing library state across fork and spawnUNIXÊñá‰ª∂ÊèèËø∞Á¨¶ÊòØ‰∏Ä‰∏™ÊôÆÈÅçÁöÑÊ¶ÇÂøµÔºåÂÆÉÂåÖÊã¨ÁÆ°ÈÅìÔºåÊéßÂà∂Âè∞I/OÁ≠â„ÄÇÂú®JOS‰∏≠ÔºåÊØè‰∏Ä‰∏™ËøôÊ†∑ÁöÑËÆæÂ§áÁ±ªÂûãÁöÑÈÉΩÂÖ∑ÊúâÁõ∏Â∫îÁöÑstruct DevÔºåËØ•ÁªìÊûÑ‰Ωì‰∏≠ÊúâÊåáÂêëÂÆûÁé∞ËØ•ËÆæÂ§áÁ±ªÂûãËØª/ÂÜôÁ≠âÊìç‰ΩúÁöÑÂáΩÊï∞ÊåáÈíà„ÄÇlib/fd.cÂú®struct Dev‰πã‰∏äÂÆûÁé∞‰∫Ü‰∏ÄËà¨ÁöÑÁ±ªUNIXÊñá‰ª∂ÊèèËø∞Á¨¶Êé•Âè£„ÄÇÊØè‰∏™struct FdË°®Á§∫ÂÖ∂ËÆæÂ§áÁ±ªÂûãÔºåÂπ∂‰∏îlib/fd.c‰∏≠ÁöÑÂ§ßÂ§öÊï∞ÂáΩÊï∞ÁÆÄÂçïÂú∞Â∞ÜÊìç‰ΩúÂàÜÂèëÂà∞ÂêàÈÄÇÁöÑstruct Dev‰∏≠ÁöÑÂáΩÊï∞„ÄÇ lib/fd.cËøòÂú®ÊØè‰∏™Â∫îÁî®Á®ãÂ∫èÁéØÂ¢ÉÁöÑÂú∞ÂùÄÁ©∫Èó¥ËôöÊãüÂú∞ÂùÄFDTABLEÂºÄÂßã‰∏≠Â§ÑÊä§Êñá‰ª∂ÊèèËø∞Á¨¶Ë°®Âå∫Âüü„ÄÇËØ•Âå∫Âüü‰∏∫Â∫îÁî®Á®ãÂ∫èÂèØ‰ª•‰∏ÄÊ¨°ËÉΩÊúÄÂ§öÊâìÂºÄMAXFDÔºàÂΩìÂâç‰∏∫32Ôºâ‰∏™Êñá‰ª∂ÊèèËø∞Á¨¶ÁöÑÊØè‰∏™Êñá‰ª∂ÊèèËø∞Á¨¶‰øùÁïô‰∏Ä‰∏™È°µÈù¢Ôºà4KBÔºâÂ§ßÂ∞èÁöÑÂú∞ÂùÄÁ©∫Èó¥„ÄÇÂú®‰ªª‰ΩïÊó∂ÂÄôÔºåÂΩì‰∏î‰ªÖÂΩìÁõ∏Â∫îÁöÑÊñá‰ª∂ÊèèËø∞Á¨¶Ë¢´‰ΩøÁî®Êó∂ÔºåÊñá‰ª∂ÊèèËø∞Á¨¶Ë°®È°µ‰ºöË¢´Êò†Â∞Ñ„ÄÇÊØè‰∏™Êñá‰ª∂ÊèèËø∞Á¨¶ËøòÊúâ‰∏Ä‰∏™Âú®FILEDATAÂºÄÂßãÁöÑÂå∫ÂüüÂèØÈÄâÁöÑ‚ÄúÊï∞ÊçÆÈ°µ‚ÄùÔºåÂ¶ÇÊûúÈÄâÊã©‰∫ÜÊï∞ÊçÆÂå∫ÂüüÔºåËÆæÂ§áÂ∞±ÂèØ‰ª•‰ΩøÁî®ËØ•Âå∫Âüü„ÄÇ Êàë‰ª¨ÊÉ≥Âú®forkÂíåspawn‰πãÈó¥ÂÖ±‰∫´Êñá‰ª∂ÊèèËø∞Á¨¶Áä∂ÊÄÅÔºå‰ΩÜÊñá‰ª∂ÊèèËø∞Á¨¶Áä∂ÊÄÅ‰øùÂ≠òÂú®Áî®Êà∑Á©∫Èó¥ÂÜÖÂ≠ò‰∏≠„ÄÇÁé∞Âú®ÔºåforkÂÆåÊàê‰πãÂêéÔºåÂÜÖÂ≠òÂ∞ÜË¢´Ê†áËÆ∞‰∏∫copy-on-writeÔºåÊâÄ‰ª•Áä∂ÊÄÅÂ∞ÜË¢´ÈáçÂ§çËÄå‰∏çÊòØÂÖ±‰∫´„ÄÇ ÔºàËøôÊÑèÂë≥ÁùÄÁéØÂ¢ÉÂ∞ÜÊó†Ê≥ïÂú®‰ªñ‰ª¨Ê≤°ÊúâÊâìÂºÄËá™Â∑±ÁöÑÊñá‰ª∂‰∏≠Êü•ÊâæÔºåÂπ∂‰∏îÁÆ°ÈÅìÂ∞ÜÂú®fork‰πãÂêé‰πü‰∏çËÉΩËøêË°å„ÄÇÔºâspawnÂÆåÊàê‰πãÂêéÔºåÂÜÖÂ≠òÂ∞ÜË¢´‰∏¢ÂºÉÔºåÂÆåÂÖ®‰∏ç‰ºöË¢´Â§çÂà∂„ÄÇÔºàÊúâÊïàÂú∞ÔºåspawnÁöÑÁî®Êà∑ÁéØÂ¢ÉÂú®Ê≤°ÊúâÊâìÂºÄÁöÑÊñá‰ª∂ÊèèËø∞Á¨¶Áä∂ÊÄÅ‰∏ãÂºÄÂßãËøêË°å„ÄÇÔºâ Êàë‰ª¨Â∞ÜÊõ¥ÊîπforkÔºåËÆ©forkÊó∂‰∫ÜËß£Êüê‰∫õÂå∫ÂüüÁöÑÂÜÖÂ≠òÊòØÁî±‚ÄúÂ∫ìÊìç‰ΩúÁ≥ªÁªü‚Äù‰ΩøÁî®ÔºåÂ∫îÂßãÁªàÂÖ±‰∫´„ÄÇËÄå‰∏çÊòØÂú®Êüê‰∏™Âú∞ÊñπÁ°¨ÁºñÁ†Å‰∏Ä‰∏™Âå∫ÂüüÂàóË°®ÔºåÊàë‰ª¨Â∞ÜÂú®È°µË°®È°π‰∏≠ËÆæÁΩÆ‰∏Ä‰∏™Êú™‰ΩøÁî®ÁöÑ‰ΩçÔºàÂ∞±ÂÉèÊàë‰ª¨Âú®fork‰∏≠‰ΩøÁî®PTE_COW‰Ωç‰∏ÄÊ†∑ÔºâÊù•Á°ÆÂÆöÂÖ±‰∫´Âå∫Âüü„ÄÇ Êàë‰ª¨Â∑≤ÁªèÂú®inc/lib.h‰∏≠ÂÆö‰πâ‰∫Ü‰∏Ä‰∏™Êñ∞ÁöÑPTE_SHARE‰Ωç„ÄÇËØ•‰ΩçÊòØIntelÂíåAMDÊâãÂÜå‰∏≠Ê†áËÆ∞‰∏∫‚ÄúÂèØÁî®‰∫éËΩØ‰ª∂‰ΩøÁî®‚ÄùÁöÑ‰∏â‰∏™PTE‰Ωç‰πã‰∏Ä„ÄÇÊàë‰ª¨Á∫¶ÂÆöÔºåÂ¶ÇÊûú‰∏Ä‰∏™È°µË°®È°π‰∏≠ËØ•‰ΩçÁΩÆ‰ΩçÔºåÂ∫îËØ•Âú®forkÂíåspawn‰∏≠Áõ¥Êé•Â∞ÜËØ•PTE‰ªéÁà∂ÂØπË±°Â§çÂà∂Âà∞Â≠êÁéØÂ¢É„ÄÇËØ∑Ê≥®ÊÑèÔºåËøô‰∏çÂêå‰∫éÊ†áËÆ∞PTE‰∏∫copy-on-writeÔºöÂ¶ÇÁ¨¨‰∏ÄÊÆµÊâÄËø∞ÔºåÊàë‰ª¨Ë¶ÅÁ°Æ‰øùÂÖ±‰∫´È°µÈù¢Êõ¥Êñ∞„ÄÇÁÆÄÂçïÊù•ËØ¥ÔºåÂ∞±ÊòØÊàë‰ª¨ÂÆö‰πâ‰∫Ü‰∏Ä‰∏™PTE_SHARE‰ΩçÔºåË°®Á§∫ÂàÜ‰∫´Ëøô‰∏™È°µÔºåÂàÜ‰∫´ÁöÑËøô‰∏™È°µ‰∏çÁî®ÂÜôÊó∂Â§çÂà∂„ÄÇÁªÉ‰π†8 Â∞±ÊòØ‰øÆÊîπ‰∫ÜËøô‰∫õ‰∏úË•ø„ÄÇÊ∑ªÂä†‰∏Ä‰∏™ifÂ∞±Ë°å‰∫Ü„ÄÇ12345678910111213141516171819202122static intduppage(envid_t envid, unsigned pn)&#123; int r; // LAB 4: Your code here. void* vaddr=(void*)(pn*PGSIZE); if(uvpt[pn]&amp;PTE_SHARE)&#123;//Â§öÊ∑ªÂä†Ëøô‰∏™ifÂ∞±Ë°å‰∫Ü if((r=sys_page_map(0,vaddr,envid,vaddr,uvpt[pn]&amp;PTE_SYSCALL))&lt;0)return r; &#125; else if((uvpt[pn] &amp; PTE_W) || (uvpt[pn] &amp; PTE_COW))&#123; if ((r = sys_page_map(0, vaddr, envid, vaddr, PTE_P | PTE_U | PTE_COW)) &lt; 0) return r; if ((r = sys_page_map(0, vaddr, 0, vaddr, PTE_P | PTE_U | PTE_COW)) &lt; 0) return r; &#125; else if((r = sys_page_map(0, vaddr, envid, vaddr, PTE_P | PTE_U)) &lt; 0) &#123; return r; &#125; //panic("duppage not implemented"); return 0;&#125; Âè¶Â§ñ‰∏Ä‰∏™Áõ¥Êé•Êö¥ÂäõÊâæÂ∞±Ë°å‰∫ÜÊ≤°Âï•Â§™Â§ßÁöÑÂå∫Âà´„ÄÇ1234567891011121314// Copy the mappings for shared pages into the child address space.static intcopy_shared_pages(envid_t child)&#123; // LAB 5: Your code here. int r=0,pn=0; for (pn=PGNUM(UTEXT); pn&lt;PGNUM(USTACKTOP); pn++)&#123; if ((uvpd[pn &gt;&gt; 10] &amp; PTE_P) &amp;&amp;uvpt[pn] &amp; PTE_SHARE) if ( (r = sys_page_map(thisenv-&gt;env_id, (void *)(pn*PGSIZE), child, (void *)(pn*PGSIZE), uvpt[pn] &amp; PTE_SYSCALL )) &lt; 0) return r; &#125; return 0;&#125; The keyboard interfaceÂÄíÁùÄ‰πãÂêéÔºåÂÆûÈ™åËÆ©Êàë‰ª¨ÂÅöÁöÑ‰∏úË•øÈùûÂ∏∏ÁÆÄÂçïÔºå‰ΩÜÊòØÂèàÊúâÂ•ΩÂ§ö‰∏úË•øËøòÊ≤°ÊêûÊ∏ÖÊ•ö„ÄÇ ‰∏∫‰∫Ü‰ΩøshellÂ∑•‰ΩúÔºåÊàë‰ª¨ÈúÄË¶Å‰∏ÄÁßçÊñπÊ≥ïÂú®shell‰∏≠ËæìÂÖ•„ÄÇ QEMU‰∏ÄÁõ¥Âú®ÊòæÁ§∫Êàë‰ª¨Âú®CGAÊòæÁ§∫Âô®Âíå‰∏≤Ë°åÁ´ØÂè£ÁöÑËæìÂá∫ÂÜÖÂÆπÔºå‰ΩÜÂà∞ÁõÆÂâç‰∏∫Ê≠¢ÔºåÊàë‰ª¨Âè™ËÉΩÂú®ÂÜÖÊ†∏ÁõëËßÜÂô®‰∏≠ËæìÂÖ•„ÄÇÂú®QEMU‰∏≠ÔºåÂú®ÂõæÂΩ¢Á™óÂè£‰∏≠ÁöÑËæìÂÖ•ÊòæÁ§∫‰∏∫‰ªéÈîÆÁõòËæìÂÖ•Âà∞JOSÔºå‰ªéÊéßÂà∂Âè∞ÁöÑËæìÂÖ•ÊòæÁ§∫‰∏∫‰∏≤Ë°åÁ´ØÂè£‰∏äÁöÑÂ≠óÁ¨¶„ÄÇkern/console.cÂåÖÂê´ÈîÆÁõòÂíå‰∏≤Ë°åÈ©±Âä®Á®ãÂ∫èÔºå‰ªélab1ÂºÄÂßãÂÜÖÊ†∏ÁõëËßÜÂô®Â∞±‰∏ÄÁõ¥Âú®‰ΩøÁî®Ôºå‰ΩÜÁé∞Âú®‰Ω†ÈúÄË¶ÅÂ∞ÜÂÆÉ‰ª¨ÈôÑÂä†Âà∞Á≥ªÁªüÁöÑÂÖ∂‰ΩôÈÉ®ÂàÜ„ÄÇÁªÉ‰π†9ËÆ©Êàë‰ª¨Ê∑ªÂä†kbd_intrÂ§ÑÁêÜIRQ_OFFSET+IRQ_KBDÂíå serial_intrÂ§ÑÁêÜIRQ_OFFSET+IRQ_SERIAL„ÄÇÁõ¥Êé•Âú®trap_dispatchÊ∑ªÂä†Â∞±Ë°å‰∫Ü„ÄÇ12345678910case IRQ_OFFSET+IRQ_KBD:&#123; lapic_eoi(); kbd_intr(); break;&#125;case IRQ_OFFSET+IRQ_SERIAL:&#123; lapic_eoi(); serial_intr(); break;&#125; Êàë‰ª¨Âú®lib/console.c‰∏≠‰∏∫‰Ω†ÂÆûÁé∞‰∫ÜÊéßÂà∂Âè∞ËæìÂÖ•/ËæìÂá∫Êñá‰ª∂Á±ªÂûã„ÄÇkbd_intrÂíåserial_intrÁî®ÊúÄËøëËØªÂèñÁöÑËæìÂÖ•Â°´ÂÖÖÁºìÂÜ≤Âå∫ÔºåÊéßÂà∂Âè∞Êñá‰ª∂Á±ªÂûãÊ∏ÖÁ©∫ÁºìÂÜ≤Âå∫ÔºàÈªòËÆ§ÊÉÖÂÜµ‰∏ãÔºåÊéßÂà∂Âè∞Êñá‰ª∂Á±ªÂûãÁî®‰∫éstdin/stdoutÔºåÈô§ÈùûÁî®Êà∑ÈáçÂÆöÂêëÂÆÉ‰ª¨Ôºâ„ÄÇ The ShellËøêË°åmake run-icodeÊàñmake run-icode-noxÂëΩ‰ª§„ÄÇËøôÂ∞ÜËøêË°åÊÇ®ÁöÑÂÜÖÊ†∏Âπ∂ÂêØÂä®user/icode„ÄÇicode spawn initÔºåÂÆÉÂ∞ÜÊéßÂà∂Âè∞ËÆæÁΩÆ‰∏∫Êñá‰ª∂ÊèèËø∞Á¨¶0Âíå1ÔºàÊ†áÂáÜËæìÂÖ•ÂíåÊ†áÂáÜËæìÂá∫Ôºâ„ÄÇÁÑ∂Âêéspawn shÔºåshellÁ®ãÂ∫è„ÄÇ‰Ω†Â∫îËØ•ËÉΩÂ§üËøêË°å‰ª•‰∏ãÂëΩ‰ª§Ôºö echo hello world | catcat lorem |catcat lorem |numcat lorem |num |num |num |num |numlsfd ËØ∑Ê≥®ÊÑèÔºåÁî®Êà∑Â∫ì‰æãÁ®ãcprintfÁõ¥Êé•ÊâìÂç∞Âà∞ÊéßÂà∂Âè∞ÔºåËÄå‰∏ç‰ΩøÁî®Êñá‰ª∂ÊèèËø∞Á¨¶‰ª£Á†Å„ÄÇËøôÈÄÇÁî®‰∫éË∞ÉËØïÔºå‰ΩÜ‰∏çÈÄÇÂêà‰∏éÂÖ∂‰ªñÁ®ãÂ∫èËøõË°åÁÆ°ÈÅìÈÄö‰ø°„ÄÇË¶ÅÂ∞ÜËæìÂá∫ÊâìÂç∞Âà∞ÁâπÂÆöÊñá‰ª∂ÊèèËø∞Á¨¶Ôºà‰æãÂ¶ÇÔºå1ÔºåÊ†áÂáÜËæìÂá∫ÔºâÔºåËØ∑‰ΩøÁî®fprintfÔºà1Ôºå‚Äú...‚ÄùÔºå...Ôºâ„ÄÇ printfÔºà‚Äú...‚ÄùÔºå...ÔºâÊòØÊâìÂç∞Âà∞FD 1ÁöÑÂø´Êç∑ÊñπÂºè„ÄÇÊúâÂÖ≥Á§∫‰æãÔºåËØ∑ÂèÇÈòÖuser/lsfd.c„ÄÇÁªÉ‰π†10 ËÆ©Êàë‰ª¨ÂÆûÁé∞user/sh.cÈáåÈù¢ÁöÑ&lt;ÈáçÂÆöÂêë,ÈáåÈù¢Â∞±Êúâ&gt;ÁöÑÈáçÂÆöÂêëÔºåÂ§çÂà∂‰∏Ä‰∏ãÂ∞±Ê≤°‰∫Ü„ÄÇ123456789// LAB 5: Your code here.if ((fd = open(t, O_RDONLY)) &lt; 0) &#123; cprintf("open %s for write: %e", t, fd); exit();&#125;if (fd != 1) &#123; dup(fd, 0); close(fd);&#125; Âà∞ËøôÈáåÊàë‰ª¨Â∞±ÂÅöÂÆå‰∫ÜÊâÄÊúâÁªÉ‰π†‰∫Ü„ÄÇÁÑ∂ËÄåÊàëÂπ∂‰∏çÁü•ÈÅìÂêéÈù¢ÂèëÁîü‰∫Ü‰ªÄ‰πà„ÄÇÊâÄ‰ª•Êàë‰ª¨Êù•ÂàÜÊûêÁî®Êà∑Êñá‰ª∂„ÄÇÁõ¥Êé•make qemu,‰ºöËæìÂá∫‰∏ãÈù¢Ëøô‰∫õ‰∏úË•ø„ÄÇ123456789101112131415/*Âú®Ëøô‰πãÂâçÁöÑ‰∏ÄÂ§ßÂ†Ü ÈÉΩÊòØ ÂÜÖÊ†∏ÔºåÂíåÊñá‰ª∂Á≥ªÁªüÈÄ†ÊàêÁöÑ*/icode: read /motdThis is /motd, the message of the day.Welcome to the JOS kernel, now with a file system!icode: close /motdicode: spawn /initicode: exitinginit: runninginit: data seems okayinit: bss seems okayinit: args: 'init' 'initarg1' 'initarg2'init: running shinit: starting sh Êàë‰ª¨È¶ñÂÖàËøõÂÖ•‰∫Üuser/icode.cËøô‰∏™Êñá‰ª∂ÈáåÈù¢ÁöÑumainÔºå‰πüÂ∞±ÊòØÂÜÖÊ†∏ÈáåÈù¢ÁöÑÈÇ£‰∏™ÁéØÂ¢ÉÂàõÂª∫ËøêË°åÁöÑÈÇ£‰∏™„ÄÇ1234567891011121314151617181920212223242526272829#include &lt;inc/lib.h&gt;voidumain(int argc, char **argv)&#123; int fd, n, r; char buf[512+1]; binaryname = "icode"; cprintf("icode startup\n"); cprintf("icode: open /motd\n");//ËøôÂá†‰∏™ÂÄºÈÉΩÁúãÂà∞‰∫Ü if ((fd = open("/motd", O_RDONLY)) &lt; 0)//ÊâìÂºÄÊ†πÁõÆÂΩï‰∏ãÁöÑ/motd panic("icode: open /motd: %e", fd); //ÊàëÈó®ÂèØ‰ª•ÊâæÂà∞find ÊâæÂà∞motd Êñá‰ª∂Âú® ./fs/ ÁõÆÂΩï‰∏ãÔºåÊâÄ‰ª•fs Â∞±ÊòØÊàë‰ª¨ÁöÑÊ†πÁõÆÂΩï cprintf("icode: read /motd\n"); while ((n = read(fd, buf, sizeof buf-1)) &gt; 0)//ËØªÂèñ‰∫Übuf ‰∏™Â≠óÁ¨¶ sys_cputs(buf, n);//ËæìÂá∫‰∫Ü‰ªñ cprintf("icode: close /motd\n"); close(fd); cprintf("icode: spawn /init\n"); if ((r = spawnl("/init", "init", "initarg1", "initarg2", (char*)0)) &lt; 0) panic("icode: spawn /init: %e", r); //Áî®spawnlÂàõÂª∫‰∫Üinit ÔºåÊâÄ‰ª•Êé•‰∏ãÊù•Êàë‰ª¨Âéª‰∫Üinit cprintf("icode: exiting\n");&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;inc/lib.h&gt;struct &#123; char msg1[5000]; char msg2[1000];&#125; data = &#123; "this is initialized data", "so is this"&#125;;char bss[6000];intsum(const char *s, int n)&#123; int i, tot = 0; for (i = 0; i &lt; n; i++) tot ^= i * s[i]; return tot;&#125;voidumain(int argc, char **argv)&#123; int i, r, x, want; char args[256]; //ÂâçÈù¢‰∏ÄÂ§ßÂ†ÜÊòØÂàùÂßãÂåñÁî®ÁöÑ cprintf("init: running\n"); want = 0xf989e; if ((x = sum((char*)&amp;data, sizeof data)) != want) cprintf("init: data is not initialized: got sum %08x wanted %08x\n", x, want); else cprintf("init: data seems okay\n"); if ((x = sum(bss, sizeof bss)) != 0) cprintf("bss is not initialized: wanted sum 0 got %08x\n", x); else cprintf("init: bss seems okay\n"); // output in one syscall per line to avoid output interleaving strcat(args, "init: args:"); for (i = 0; i &lt; argc; i++) &#123; strcat(args, " '"); strcat(args, argv[i]); strcat(args, "'"); &#125; cprintf("%s\n", args); cprintf("init: running sh\n"); // being run directly from kernel, so no file descriptors open yet close(0);//Âõ†‰∏∫Ê†πÁõÆÂΩïÊòØÂú®ÂÜÖ‰∫å‰∏äÔºåÊâÄ‰ª•Ê≤°ÊúâÊñá‰ª∂ÊâìÂºÄ„ÄÇ if ((r = opencons()) &lt; 0)//ÊâìÂºÄÊéßÂà∂Âè∞ÔºüÔºü panic("opencons: %e", r); if (r != 0) panic("first opencons used fd %d", r); if ((r = dup(0, 1)) &lt; 0)//Êää0Â§çÂà∂Âà∞‰∫Ü 1 panic("dup: %e", r); while (1) &#123; cprintf("init: starting sh\n"); r = spawnl("/sh", "sh", (char*)0);//Ëøô‰∏™Êó∂ÂÄôÂèàË∑ë‰∫Üsh if (r &lt; 0) &#123; cprintf("init: spawn sh: %e\n", r); continue; &#125; wait(r);//ÁÑ∂ÂêéÊó†Á∫øÂæ™ÁéØËøô‰∏™Á®ãÂ∫è &#125;&#125; shÈáåÈù¢Â∞±ÊòØÊàë‰ª¨ÁöÑshell‰∫ÜÔºåÂëäËæû„ÄÇ]]></content>
      <categories>
        <category>Êìç‰ΩúÁ≥ªÁªü</category>
        <category>MIT6.828</category>
      </categories>
      <tags>
        <tag>MIT6.828</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT6.828(Âõõ)Lab4:Preemptive Multitasking]]></title>
    <url>%2F2020%2F02%2F18%2FMIT-6.828-(%E5%9B%9B)-Lab-4-Preemptive-Multitasking%2F</url>
    <content type="text"><![CDATA[‰∏∫‰∫ÜÊñπ‰æøÊü•ÁúãÊúÄÁªàÊ∫êÁ†ÅÔºåÊàëÂ∞Ü‰ª£Á†ÅÊîæÂà∞‰∫ÜÊàëÁöÑgithub‰∏ä„ÄÇÂêéÈù¢‰ºöÊääÂâçÈù¢labÁöÑ‰πü‰ºöÊ∑ªÂä†ËøõÂéª„ÄÇlab4ÊúâÂæàÂ§öÁªÜËäÇÔºåÊâÄ‰ª•Êúâ‰∫õ‰∏úË•øÊàë‰ºöÂàÜ‰∏Ä‰∏ãÊµãËØïÁ®ãÂ∫è„ÄÇ Lab 4: Preemptive Multitasking PartA: ‰∏∫JOSÂ¢ûÊ∑ªÂ§öÂ§ÑÁêÜÂô®ÊîØÊåÅÁâπÊÄß„ÄÇ ÂÆûÁé∞round-robin schedulingÂæ™ÁéØË∞ÉÂ∫¶„ÄÇ Ê∑ªÂä†‰∏Ä‰∏™Âü∫Êú¨ÁöÑÁéØÂ¢ÉÔºàËøõÁ®ãÔºâÁÆ°ÁêÜÁ≥ªÁªüË∞ÉÁî®ÔºàÂàõÂª∫ÂíåÈîÄÊØÅÁéØÂ¢ÉÔºåÂàÜÈÖçÂíåÊò†Â∞ÑÂÜÖÂ≠òÔºâ„ÄÇ PartB: ÂÆûÁé∞‰∏Ä‰∏™Á±ªUnixÁöÑfork(),ÂÖ∂ÂÖÅËÆ∏‰∏Ä‰∏™Áî®Êà∑Ê®°ÂºèÁöÑÁéØÂ¢ÉËÉΩÂàõÂª∫‰∏Ä‰ªΩÂÆÉËá™Ë∫´ÁöÑÊã∑Ë¥ù„ÄÇ PartC: ÊîØÊåÅËøõÁ®ãÈó¥ÈÄö‰ø°Ôºàinter-process communication, IPCÔºâ ÊîØÊåÅÁ°¨‰ª∂Êó∂Èíü‰∏≠Êñ≠ÂíåÊä¢Âç† ÂÅö‰∏™Â§ßËá¥‰ªãÁªçËÆ©‰Ω†ÊòéÁôΩË¶ÅÂÅöÂï•„ÄÇÁÑ∂ÂêéÂ∞±ËÆ©‰Ω†ÂàáÊç¢Âà∞lab4ÔºåÊØè‰∏™lab ÂøÖÈ°ªÂÅöÁöÑ‰∫ãÊÉÖÔºåÁÑ∂Âêé‰ºöÂ§öÂá∫Êù•‰∏Ä‰∫õÊñá‰ª∂„ÄÇÊØè‰∏™Êñá‰ª∂ÁöÑ‰ΩúÁî®ÁúãÁøªËØëÂ∫îËØ•Â∞±ËÉΩÊòéÁôΩÔºåÂú®ÊàëÁöÑgithubÊØè‰∏™Êñá‰ª∂ÊúÄÂâçÈù¢‰πüÊúâÊ≥®Èáä„ÄÇ Part A: Multiprocessor Support and Cooperative MultitaskingÂÖàÊòØ‰∏ÄÂ†Ü‰ªãÁªçÔºåÂ∞±ÊòØÂëäËØâ‰Ω†Ë¶ÅÂÆûÁé∞ËΩÆËΩ¨Ë∞ÉÂ∫¶„ÄÇÂêéÈù¢‰ºö‰∏∫‰Ω†ÂÆûÁé∞Êä¢Âç†ÂºèË∞ÉÂ∫¶„ÄÇËøòÊúâË¶ÅÂ§öCPU ÊîØÊåÅ„ÄÇ Multiprocessor SupportÊàë‰ª¨Â∞ÜËÆ© JOS ÊîØÊåÅÂØπÁß∞Â§öÂ§ÑÁêÜÂô®Ôºàsymmetric multiprocessingÔºåSMPÔºâÔºåÂÖ∑‰ΩìÊòØ‰ªÄ‰πà‰∏úË•øËá™Â∑±ÂéªÁúãËÆ≤Êìç‰ΩúÁ≥ªÁªüÁöÑ‰π¶„ÄÇCPUÂäüËÉΩÂü∫Êú¨ÈÉΩÊòØ‰∏ÄÊ†∑ÁöÑÔºå‰ΩÜÊòØÂú®ÂºïÂØºËøáÁ®ã‰∏≠ÂèØ‰ª•ÂàÜ‰∏∫‰∏§Á±ªÔºö ÂºïÂØºÂ§ÑÁêÜÂô®ÔºàBSPÔºâÔºöË¥üË¥£ÂàùÂßãÂåñÁ≥ªÁªüÂíåÂºïÂØºÊìç‰ΩúÁ≥ªÁªü; Â∫îÁî®Á®ãÂ∫èÂ§ÑÁêÜÂô®ÔºàAPÔºâÔºöÂè™ÊúâÂú®Êìç‰ΩúÁ≥ªÁªüÂêØÂä®Âπ∂ËøêË°åÂêéÔºåBSPÊâç‰ºöÊøÄÊ¥ªÂ∫îÁî®Á®ãÂ∫èÂ§ÑÁêÜÂô®„ÄÇ Âú®Êàë‰ª¨ÂâçÈù¢ÊâÄÂÅöËøáÁöÑÊâÄÊúâÂÆûÈ™åÈÉΩÊòØÂú®BSP‰∏äÈù¢ÔºåÁé∞Âú®Êàë‰ª¨Ë¶ÅÂÅöÁöÑÂ∞±ÊòØÂú®BSP‰∏äÂêØÂä®AP„ÄÇÂØπ‰∫éÂì™‰∏Ä‰∏™CPUÊòØBSPÊòØÁ°¨‰ª∂ÂÜ≥ÂÆöÁöÑ„ÄÇÊØè‰∏™CPUÈÉΩÊúâËá™Â∑±ÁöÑAPICÔºå‰πüÂ∞±ÊòØLAPIC„ÄÇAPIC ‰∏ÄÂè•ËØùÊù•ËØ¥Â∞±ÊòØÂèØÁºñÁ®ã‰∏≠Êñ≠„ÄÇ Ê†πÊçÆLAPICËØÜÂà´Á†Å(APIC ID)Âå∫Âà´Êàë‰ª¨ÁöÑ‰ª£Á†ÅËøêË°åÂú®Âì™‰∏™CPU‰∏ä„ÄÇÔºàcpunum()Ôºâ ‰ªéBSPÂêëAPsÂèëÈÄÅSTARTUPÂ§ÑÁêÜÂô®Èó¥‰∏≠Êñ≠ÔºàIPIÔºâÂéªÂî§ÈÜíÂÖ∂‰ªñÁöÑCPU„ÄÇÔºàlapic_startap()Ôºâ Âú®Part CÔºåÊàë‰ª¨ÁºñÂÜôLAPICÁöÑÂÜÖÁΩÆÂÆöÊó∂Âô®Êù•Ëß¶ÂèëÊó∂Èíü‰∏≠Êñ≠Ôºå‰ª•ÊîØÊåÅÊä¢Âç†ÂºèÂ§ö‰ªªÂä°Ôºàpic_init()Ôºâ„ÄÇ ÂØπ‰∫éËøô‰∫õÊàë‰ª¨Êù•ÁúãÁúãËøô‰∏™Êñá‰ª∂kern/lapic.cÔºå‰∏ÄÂ¶ÇÊó¢ÂæÄÔºåÊàë‰ª¨‰∏çÁî®Áü•ÈÅìÂÖ∑‰ΩìÂÆûÁé∞ÔºåÁü•ÈÅì‰∏Ä‰∫õÈáçË¶ÅÁöÑ‰∏úË•øÂ∞±Ë°å„ÄÇ lapic.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185// The local APIC manages internal (non-I/O) interrupts.// See Chapter 8 &amp; Appendix C of Intel processor manual volume 3./*Kernel code driving the local APIC unit in each processorÂÜÖÊ†∏‰ª£Á†Å Áî®Êù•ËØªÂèñÊØè‰∏™Â§ÑÁêÜÂô®Âú∞ÊñπAPICÂçïÂÖÉ„ÄÇ‰∏çÁü•ÈÅìÊòØÁî®Êù•Âπ≤Âï•ÁöÑ */#include &lt;inc/types.h&gt;#include &lt;inc/memlayout.h&gt;#include &lt;inc/trap.h&gt;#include &lt;inc/mmu.h&gt;#include &lt;inc/stdio.h&gt;#include &lt;inc/x86.h&gt;#include &lt;kern/pmap.h&gt;#include &lt;kern/cpu.h&gt;// Local APIC registers, divided by 4 for use as uint32_t[] indices. // LAPIC ÂØÑÂ≠òÂô® Áî®4ÂàÜÊàê‰∏Ä‰∏™‰∏™Á¥¢Âºï„ÄÇ#define ID (0x0020/4) // ID#define VER (0x0030/4) // Version#define TPR (0x0080/4) // Task Priority#define EOI (0x00B0/4) // EOI#define SVR (0x00F0/4) // Spurious Interrupt Vector ‰º™‰∏≠Êñ≠ÂêëÈáè #define ENABLE 0x00000100 // Unit Enable ÂçïÂÖÉÂèØÁî®#define ESR (0x0280/4) // Error Status ÈîôËØØ‰ø°ÊÅØ#define ICRLO (0x0300/4) // Interrupt Command #define INIT 0x00000500 // INIT/RESET ÂàùÂßãÂåñ #define STARTUP 0x00000600 // Startup IPI ÂºÄÂßãIPI #define DELIVS 0x00001000 // Delivery status #define ASSERT 0x00004000 // Assert interrupt (vs deassert) #define DEASSERT 0x00000000 #define LEVEL 0x00008000 // Level triggered #define BCAST 0x00080000 // Send to all APICs, including self. #define OTHERS 0x000C0000 // Send to all APICs, excluding self. #define BUSY 0x00001000 #define FIXED 0x00000000#define ICRHI (0x0310/4) // Interrupt Command [63:32]#define TIMER (0x0320/4) // Local Vector Table 0 (TIMER) #define X1 0x0000000B // divide counts by 1 #define PERIODIC 0x00020000 // Periodic#define PCINT (0x0340/4) // Performance Counter LVT#define LINT0 (0x0350/4) // Local Vector Table 1 (LINT0)#define LINT1 (0x0360/4) // Local Vector Table 2 (LINT1)#define ERROR (0x0370/4) // Local Vector Table 3 (ERROR) #define MASKED 0x00010000 // Interrupt masked#define TICR (0x0380/4) // Timer Initial Count#define TCCR (0x0390/4) // Timer Current Count#define TDCR (0x03E0/4) // Timer Divide Configurationphysaddr_t lapicaddr; // Initialized in mpconfig.cvolatile uint32_t *lapic;static voidlapicw(int index, int value)&#123; lapic[index] = value; lapic[ID]; // wait for write to finish, by reading&#125;voidlapic_init(void) //Ëøô‰∏™Âà∞Âæàpart C Êâç‰ºöÁî®Âà∞ÔºåÁî®‰∫éÊä¢Âç†ÂºèË∞ÉÂ∫¶&#123; if (!lapicaddr) return; // lapicaddr is the physical address of the LAPIC's 4K MMIO //Êò†Â∞ÑËøô‰∏™Âú∞ÂùÄËÉΩËÆ©ÊàëÁî®ËôöÊãüÂú∞ÂùÄËÆøÈóÆ // region. Map it in to virtual memory so we can access it. lapic = mmio_map_region(lapicaddr, 4096); // Enable local APIC; set spurious interrupt vector. ÂºÄÂêØ ‰º™‰∏≠Êñ≠ lapicw(SVR, ENABLE | (IRQ_OFFSET + IRQ_SPURIOUS)); // The timer repeatedly counts down at bus frequency // from lapic[TICR] and then issues an interrupt. // If we cared more about precise timekeeping, //ÈáçË¥üÊó∂Èó¥‰∏≠Êñ≠ÔºåÂèØ‰ª•Áî®Â§ñÈù¢Êó∂ÈíüÊù•Ê†°ÂáÜ // TICR would be calibrated using an external time source. lapicw(TDCR, X1); lapicw(TIMER, PERIODIC | (IRQ_OFFSET + IRQ_TIMER)); lapicw(TICR, 10000000); // Leave LINT0 of the BSP enabled so that it can get // interrupts from the 8259A chip. //‰∏çÊáÇÂï•ÊÑèÊÄù // According to Intel MP Specification, the BIOS should initialize // BSP's local APIC in Virtual Wire Mode, in which 8259A's // INTR is virtually connected to BSP's LINTIN0. In this mode, // we do not need to program the IOAPIC. if (thiscpu != bootcpu) lapicw(LINT0, MASKED); // Disable NMI (LINT1) on all CPUs Ëøô‰∏™‰πü‰∏çÁü•ÈÅì lapicw(LINT1, MASKED); // Disable performance counter overflow interrupts // on machines that provide that interrupt entry. if (((lapic[VER]&gt;&gt;16) &amp; 0xFF) &gt;= 4) lapicw(PCINT, MASKED); // Map error interrupt to IRQ_ERROR. Êò†Â∞ÑÈîôËØØ‰∏≠Êñ≠ lapicw(ERROR, IRQ_OFFSET + IRQ_ERROR); // Clear error status register (requires back-to-back writes). Ê∏ÖÊ•öÂØÑÂ≠òÂô® lapicw(ESR, 0); lapicw(ESR, 0); // Ack any outstanding interrupts. lapicw(EOI, 0); // Send an Init Level De-Assert to synchronize arbitration ID's. lapicw(ICRHI, 0); lapicw(ICRLO, BCAST | INIT | LEVEL); while(lapic[ICRLO] &amp; DELIVS) ; // Enable interrupts on the APIC (but not on the processor).ÂêØÁî® ‰∏≠Êñ≠ lapicw(TPR, 0);&#125;intcpunum(void) //Ëøô‰∏™Áî®Âà∞ÁöÑÈùûÂ∏∏Â§öÔºåËøîÂõûÂΩìÂâçCPUÊòØÁ¨¨Âá†‰∏™&#123; if (lapic) return lapic[ID] &gt;&gt; 24; return 0;&#125;// Acknowledge interrupt. Á°ÆËÆ§‰∏≠Êñ≠ÔºåÊ≤°ÊÄé‰πàÁî®Âà∞voidlapic_eoi(void)&#123; if (lapic) lapicw(EOI, 0);&#125;// Spin for a given number of microseconds.// On real hardware would want to tune this dynamically.static voidmicrodelay(int us)&#123;&#125;#define IO_RTC 0x70// Start additional processor running entry code at addr. ÂêØÂä®È¢ùÂ§ñÂ§ÑÁêÜÂô® ÂêéÈù¢Â∞±‰ºöÁî®Âà∞// See Appendix B of MultiProcessor Specification.voidlapic_startap(uint8_t apicid, uint32_t addr)&#123; int i; uint16_t *wrv; // "The BSP must initialize CMOS shutdown code to 0AH // and the warm reset vector (DWORD based at 40:67) to point at // the AP startup code prior to the [universal startup algorithm]." outb(IO_RTC, 0xF); // offset 0xF is shutdown code outb(IO_RTC+1, 0x0A); wrv = (uint16_t *)KADDR((0x40 &lt;&lt; 4 | 0x67)); // Warm reset vector wrv[0] = 0; wrv[1] = addr &gt;&gt; 4; // "Universal startup algorithm." // Send INIT (level-triggered) interrupt to reset other CPU. lapicw(ICRHI, apicid &lt;&lt; 24); lapicw(ICRLO, INIT | LEVEL | ASSERT); microdelay(200); lapicw(ICRLO, INIT | LEVEL); microdelay(100); // should be 10ms, but too slow in Bochs! // Send startup IPI (twice!) to enter code. // Regular hardware is supposed to only accept a STARTUP // when it is in the halted state due to an INIT. So the second // should be ignored, but it is part of the official Intel algorithm. // Bochs complains about the second one. Too bad for Bochs. for (i = 0; i &lt; 2; i++) &#123; lapicw(ICRHI, apicid &lt;&lt; 24); lapicw(ICRLO, STARTUP | (addr &gt;&gt; 12)); microdelay(200); &#125;&#125;voidlapic_ipi(int vector)&#123; lapicw(ICRLO, OTHERS | FIXED | vector); while (lapic[ICRLO] &amp; DELIVS) ;&#125; Áúã‰∫Ü‰∏äÈù¢ÁöÑÔºåÂÖ∂ÂÆûÂï•ÈÉΩ‰∏çÁü•ÈÅìÔºåÂ∞±ËÄΩËØØ‰∫Ü‰∏ãÊó∂Èó¥„ÄÇ„ÄÇ„ÄÇ„ÄÇLAPICÁöÑ hole ÂºÄÂßã‰∫éÁâ©ÁêÜÂú∞ÂùÄ0xFE000000(4GB‰πã‰∏ãÁöÑ32MB)Ôºå‰ΩÜÊòØËøôÂú∞ÂùÄÂ§™È´òÊàë‰ª¨Êó†Ê≥ïËÆøÈóÆÈÄöËøáËøáÂéªÁöÑÁõ¥Êé•Êò†Â∞Ñ(ËôöÊãüÂú∞ÂùÄ0xF0000000Êò†Â∞Ñ0x0ÔºåÂç≥Âè™Êúâ256MB)„ÄÇ‰ΩÜÊòØJOSËôöÊãüÂú∞ÂùÄÊò†Â∞ÑÈ¢ÑÁïô‰∫Ü4MBÁ©∫Èó¥Âú®MMIOBASEÂ§ÑÔºåÊàë‰ª¨ÈúÄË¶ÅÂàÜÈÖçÊò†Â∞ÑÁ©∫Èó¥„ÄÇÁªÉ‰π† 1 Ë¶ÅÊàë‰ª¨ÂÆûÁé∞ kern/pmap.c ÈáåÁöÑmmio_map_regionÔºåÂàöÊâçÊàë‰ª¨‰∏äÈù¢ÈÇ£‰∏™Êñá‰ª∂Êúâ‰∏ÄÂè•lapic = mmio_map_region(lapicaddr, 4096);„ÄÇÂíåÊàë‰ª¨ÂÆûÁé∞ËøáÁöÑboot_map_regionÂæàÂÉèÔºåÁÖßÁùÄÊù•Â∞±Ë°å‰∫Ü„ÄÇ12345678910111213141516171819202122232425262728293031323334353637383940//// Reserve size bytes in the MMIO region and map [pa,pa+size) at this// location. Return the base of the reserved region. size does *not*// have to be multiple of PGSIZE.// Êò†Â∞Ñ size Â§ßÂ∞èÁöÑ Á©∫Èó¥ÔºåÂøÖÈ°ªÈ°µÂØπÈΩê„ÄÇvoid *mmio_map_region(physaddr_t pa, size_t size)&#123; // Where to start the next region. Initially, this is the // beginning of the MMIO region. Because this is static, its // value will be preserved between calls to mmio_map_region // (just like nextfree in boot_alloc). //Ëøô‰∏™Âíåboot_alloc ÊòØ‰∏ÄÊ†∑ÁöÑÔºå‰∏ã‰∏ÄÊ¨°ËøõÂÖ•Ëøô‰∏™ÂáΩÊï∞Âú∞ÂùÄÂ∞±ÊòØ‰∏ä‰∏Ä‰∏™Âú∞ÂùÄ ÁöÑÂêéÈù¢ static uintptr_t base = MMIOBASE; // Reserve size bytes of virtual memory starting at base and // map physical pages [pa,pa+size) to virtual addresses Êò†Â∞Ñpa Âà∞base // [base,base+size). Since this is device memory and not Âõ†‰∏∫‰∏çÊòØDRAM ÂÜÖÂ≠ò // regular DRAM, you'll have to tell the CPU that it isn't ‰Ω†‰∏çËÆ∏ÂëäËØâCPUÊòØ‰∏çÂÆâÂÖ®ÁöÑÂéªÈ´òÈÄüÁºìÂ≠òÁõ¥Êé•ËÆøÈóÆËøô‰∏™ÂÜÖÂ≠ò„ÄÇ // safe to cache access to this memory. Luckily, the page Âπ∏ËøêÁöÑÊòØ È°µË°®Êèê‰æõËøôÁßçÊ®°Êùø // tables provide bits for this purpose; simply create the ÁÆÄÂçïÁöÑÁî®‰∫Ü‰∏§‰∏™Ê†áÂøó‰ΩçPTE_PCD|PTE_PWT // mapping with PTE_PCD|PTE_PWT (cache-disable and // write-through) in addition to PTE_W. (If you're interested // in more details on this, see section 10.5 of IA32 volume // 3A.) // // Be sure to round size up to a multiple of PGSIZE and to //Á°Æ‰øù‰πüÂØπÂÖ∂ Ê≤°ÊúâÊ∫¢Âá∫ MMIOLIM ‰∏çÁÑ∂Â∞±ÊòØ panic // handle if this reservation would overflow MMIOLIM (it's // okay to simply panic if this happens). // // Hint: The staff solution uses boot_map_region. // // Your code here: size = ROUNDUP(size, PGSIZE);//È°µÂØπÈΩêÁÑ∂ÂêéÊò†Â∞Ñ ÂêéÈù¢Ëøô‰∏™Ê†áÂøó‰ΩçÔºåÂ∞±ÊòØÂâçÈù¢ËÆæÂÆöÁöÑ //‰∏™‰∫∫ÊÑüËßâÂ¶ÇÊûúËøô‰∏™Âú∞ÊñπÊ∫¢Âá∫‰∫ÜÂ∫îËØ•Ë¶ÅÂà§Êñ≠‰∏Ä‰∏ãÔºå‰ΩÜÊòØÂ•ΩÂÉèÂπ∂Ê≤°ÊúâËøô‰∏™ÊµãËØïÊâÄ‰ª•Â•ΩÂÉèÊ≤°Âï•ÈóÆÈ¢ò„ÄÇ boot_map_region(kern_pgdir, base, size, pa, PTE_W | PTE_PWT | PTE_PCD); base += size; return (void *)base-size; //github ‰∏äÈù¢ÂíåËøô‰∏™‰∏ç‰∏ÄÊ†∑‰ΩÜÊòØÂ∑ÆË∑ù‰πü‰∏çÂ§ß„ÄÇ //panic("mmio_map_region not implemented");&#125; Application Processor BootstrapÂú®Êàë‰ª¨ÂêØÂä®APs‰πãÂâçBSPÈúÄË¶ÅÊî∂ÈõÜ‰ªñ‰ª¨ÁöÑ‰ø°ÊÅØ„ÄÇÊØîÂ¶ÇÊï∞ÈáèÔºåAPICID Âíå‰ªñ‰ª¨Êò†Â∞ÑÁöÑÂú∞ÂùÄ„ÄÇkern/mpconfig.cÈáåÈù¢ÁöÑmp_initÂ∞±ÊòØÂπ≤Ëøô‰∏™ÁöÑ„ÄÇÊàë‰ª¨ÂéªÁúãÁúã‰ªñÂú®Âì™Ë∞ÉÁî®ÁöÑÔºåËøô‰∫õ‰∏úË•øËÇØÂÆöÊòØÂú®ÂàùÂßãÂåñÂáΩÊï∞ÈáåÈù¢„ÄÇ i386_init123456789101112131415161718192021222324252627282930313233343536373839voidi386_init(void)&#123; // Initialize the console. // Can't call cprintf until after we do this! cons_init(); cprintf("6828 decimal is %o octal!\n", 6828); // Lab 2 memory management initialization functions mem_init(); // Lab 3 user environment initialization functions env_init(); trap_init(); //Âú®Ëøô‰πãÂâçÈÉΩÊòØÊ≤°ÊúâÂèòÁöÑ„ÄÇ // Lab 4 multiprocessor initialization functions mp_init(); //Ëøô‰∏™Â∞±ÊòØÊî∂ÈõÜ‰ø°ÊÅØ„ÄÇ lapic_init();//ÂàùÂßãÂåñËá™Â∑±lapic Ëøô‰∏™Êó∂ÂÄôÂÖ∂‰ªñCPUËøòÊ≤°ÊúâÂêØÂä®ÔºåÊ≠§Êó∂ËøòÊòØBSP // Lab 4 multitasking initialization functions pic_init(); //Â§ö‰Ωú‰∏öÂàùÂßãÂåñÔºåÁ≠â‰ºöË¶ÅÁúãÁúã // Acquire the big kernel lock before waking up APs // Your code here: lock_kernel(); //Ëøô‰∏™ÊòØÊàëÂÜôÁöÑÔºåÊòØÂêéÈù¢ÁöÑÔºå‰∏çÁî®ÁùÄÊÄ•„ÄÇ // Starting non-boot CPUs boot_aps(); //Ëøô‰∏™Âú∞ÊñπÂ∞±ÊòØÂºïÂØºÁ®ãÂ∫è‰∫Ü„ÄÇ#if defined(TEST) // Don't touch -- used by grading script! ENV_CREATE(TEST, ENV_TYPE_USER);#else // Touch all you want. ENV_CREATE(user_primes, ENV_TYPE_USER); #endif // TEST* // Schedule and run the first user environment!ÂºÄÂßãË∞ÉÂ∫¶ sched_yield();&#125; ÁúãÂÆåÂêéÊàë‰ª¨ÂéªÁúãÁúãmp_init()„ÄÇÂπ∂Ê≤°ÊúâË¶ÅÊàë‰ª¨ÂÆûÁé∞ÔºåËøá‰∏ÄÁúºÂ∞±Ë°å‰∫ÜÔºåÁî±‰∫éÊ≥®ÈáäÂ§™Â∞ëÔºåÊâÄ‰ª•Ê≤°ÁúãÊáÇ„ÄÇÁü•ÈÅì‰ªñÊääÊâÄÊúâCPU‰ø°ÊÅØÊî∂ÈõÜÂÆåÂ∞±Ë°å‰∫Ü„ÄÇboot_aps() ÊòØÂºïÂØºÂÖ∂‰ªñCPUÂêØÂä®ÁöÑ„ÄÇ‰ªñÂíåbootloader Â∑Æ‰∏çÂ§ö„ÄÇÊâÄ‰ª•‰ªñ‰πüÊòØ‰ªéÂÆûÊ®°ÂºèÂºÄÂßãÁöÑ„ÄÇÊàë‰ª¨Â∞Ükern/mpentry.SÂä†ËΩΩÂà∞0x7000ÔºåÂæàÁúºÁÜü‚Ä¶,Â•ΩÂÉèÂè™Ë¶ÅÊòØÊ≤°ÊúâÁî®ÁöÑÈ°µÂØπÈΩêÁöÑ‰Ωé‰∫é640ÁöÑÂú∞ÂùÄÈÉΩÂèØ‰ª•„ÄÇÁÑ∂ÂêéÊ¨ßÁæéÂ∞±ÂéªÁúãÁúã‰ªñÂÅö‰∫ÜÂï•„ÄÇ boot_aps123456789101112131415161718192021222324252627// Start the non-boot (AP) processors.static voidboot_aps(void)&#123; extern unsigned char mpentry_start[], mpentry_end[]; //ÈÇ£ÊÆµ‰ª£Á†ÅÁöÑÂºÄÂßãÂíåÁªìÊùü void *code; struct CpuInfo *c; // Write entry code to unused memory at MPENTRY_PADDR #define MPENTRY_PADDR 0x7000 code = KADDR(MPENTRY_PADDR); //ÊâæÂà∞Ëøô‰∏™Âú∞ÂùÄ Âú®memlayout ÈáåÈù¢ÂÆèÂÆö‰πâ‰∫Ü„ÄÇ memmove(code, mpentry_start, mpentry_end - mpentry_start);//Êää‰ª£Á†ÅÂ§çÂà∂ËøõÂéª // Boot each AP one at a time for (c = cpus; c &lt; cpus + ncpu; c++) &#123; //CPUS ÊòØÂï• NCPU ÊòØÂï•ÔºüÔºüÔºü Â∞±ÊòØÂâçÈù¢ÈÇ£‰∏™Êàë‰ª¨Ê≤°ÊúâËÆ≤ÁöÑÊñá‰ª∂ÈáåÈù¢Êî∂ÈõÜÁöÑÔºåcpus ÊòØ ÊâÄÊúâCPUSÁöÑÊï∞ÁªÑÔºåncpu ÊòØ‰∏™Êï∞ if (c == cpus + cpunum()) // We've started already. ‰∏çÊòØËá™Â∑±Ëøô‰∏™CPU continue; // Tell mpentry.S what stack to use Ëøô‰∏™ÊòØÊØè‰∏™CPUÁöÑÊ†àÔºåÁé∞Âú®ËøòÊ≤°ÊúâÊò†Â∞ÑÔºåÁ≠â‰ºöË¶ÅÂÅöÁöÑÂ∞±ÊòØËøô‰∏™ mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE; // Start the CPU at mpentry_start lapic_startap(c-&gt;cpu_id, PADDR(code)); //Ëøô‰∏™Â∞±ÊòØÂºÄÂßãÂêØÂä®CPUS4‰∫Ü // Wait for the CPU to finish some basic setup in mp_main() while(c-&gt;cpu_status != CPU_STARTED) //Á≠âÂæÖËøô‰∏™CPUÂêØÂä®Áé© ; //Âú® mp_mainÈáåÊúâËøô‰πà‰∏ÄË°å xchg(&amp;thiscpu-&gt;cpu_status, CPU_STARTED); // tell boot_aps() we're up &#125;&#125; ÁÑ∂ÂêéÊàë‰ª¨ÂéªÁúãÁúãmp_main()Âú®Âì™ËøõÂÖ•ÁöÑ„ÄÇÊàë‰ª¨ËÉΩÂ§üÁúãÂá∫boot_aps,ËÆ©ÊàëÊÖ¢ÊÖ¢Ë∑ëÂéª‰∫Ümpentry_start„ÄÇ mpentry_start12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/* See COPYRIGHT for copyright information. *//*Assembly-language entry code for non-boot CPUs Ê±áÁºñ‰ª£Á†ÅÂêØÂä® ÈùûÂºïÂØºCPU Â∫îËØ•‰∏ç‰ºöË¶ÅÂä®ÔºåËøôÁßç‰∏úË•ø‰∏ÄËà¨ÈÉΩÊòØÂõ∫ÂÆöÁöÑ*/#include &lt;inc/mmu.h&gt;#include &lt;inc/memlayout.h&gt;#################################################################### entry point for APs#################################################################### Each non-boot CPU ("AP") is started up in response to a STARTUP# IPI from the boot CPU. Section B.4.2 of the Multi-Processor# Specification says that the AP will start in real mode with CS:IP# set to XY00:0000, where XY is an 8-bit value sent with the# STARTUP. Thus this code must start at a 4096-byte boundary.# ‰ª£Á†ÅÂøÖÈ°ª‰ªé4096ÂºÄÂßãËøêË°åÔºåÂíåÈÇ£‰∏™bootloader Ê≤°Â§öÂ§ßÂ∑ÆË∑ùÔºåÈô§‰∫ÜÊàë‰ª¨ËÉΩÊéßÂà∂Âú®Âì™ËøêË°å# Because this code sets DS to zero, it must run from an address in# the low 2^16 bytes of physical memory.## boot_aps() (in init.c) copies this code to MPENTRY_PADDR (which# satisfies the above restrictions). Then, for each AP, it stores the# address of the pre-allocated per-core stack in mpentry_kstack, sends# the STARTUP IPI, and waits for this code to acknowledge that it has# started (which happens in mp_main in init.c).## This code is similar to boot/boot.S except that# - it does not need to enable A20# - it uses MPBOOTPHYS to calculate absolute addresses of its# symbols, rather than relying on the linker to fill them#define RELOC(x) ((x) - KERNBASE)#define MPBOOTPHYS(s) ((s) - mpentry_start + MPENTRY_PADDR) //Ëøô‰∏™ÊòØÂõ†‰∏∫BSPÂ∑≤ÁªèÊòØÂú®‰øùÊä§Ê®°Âºè‰∏ã‰∫ÜÊ≤°Ê≥ïÁõ¥Êé•ËÆøÈóÆÔºåÂΩìÂâçCPUÂèàÂú®ÂÆûÊ®°ÂºèÔºåÊòØ‰∏çËÉΩËÆøÈóÆÂë¢ 1M‰ª•‰∏äÁöÑÂÜÖÂ≠òÔºåÊâÄ‰ª•Ë¶ÅÊò†Â∞Ñ‰∏Ä‰∏ã„ÄÇ.set PROT_MODE_CSEG, 0x8 # kernel code segment selector.set PROT_MODE_DSEG, 0x10 # kernel data segment selector.code16 .globl mpentry_startmpentry_start: cli xorw %ax, %ax movw %ax, %ds movw %ax, %es movw %ax, %ss lgdt MPBOOTPHYS(gdtdesc) movl %cr0, %eax orl $CR0_PE, %eax movl %eax, %cr0 ljmpl $(PROT_MODE_CSEG), $(MPBOOTPHYS(start32)).code32start32: movw $(PROT_MODE_DSEG), %ax movw %ax, %ds movw %ax, %es movw %ax, %ss movw $0, %ax movw %ax, %fs movw %ax, %gs # Set up initial page table. We cannot use kern_pgdir yet because # we are still running at a low EIP. movl $(RELOC(entry_pgdir)), %eax movl %eax, %cr3 # Turn on paging. movl %cr0, %eax orl $(CR0_PE|CR0_PG|CR0_WP), %eax movl %eax, %cr0 # Switch to the per-cpu stack allocated in boot_aps() movl mpentry_kstack, %esp movl $0x0, %ebp # nuke frame pointer # Call mp_main(). (Exercise for the reader: why the indirect call?) Âú®Ëøô‰∏™Âú∞ÊñπÊàë‰ª¨Ë∑ëÂéª‰∫Ü mp_main movl $mp_main, %eax call *%eax # If mp_main returns (it shouldn't), loop.spin: jmp spin# Bootstrap GDT.p2align 2 # force 4 byte alignmentgdt: SEG_NULL # null seg SEG(STA_X|STA_R, 0x0, 0xffffffff) # code seg SEG(STA_W, 0x0, 0xffffffff) # data seggdtdesc: .word 0x17 # sizeof(gdt) - 1 .long MPBOOTPHYS(gdt) # address gdt.globl mpentry_endmpentry_end: nop ÂÜçÁúãÁúãmp_main1234567891011121314151617181920212223// Setup code for APsvoidmp_main(void)&#123; // We are in high EIP now, safe to switch to kern_pgdir lcr3(PADDR(kern_pgdir)); //Âä†ËΩΩÂÜÖÊ†∏È°µ cprintf("SMP: CPU %d starting\n", cpunum()); lapic_init();//Ëøô‰∏â‰∏™ÂàùÂßãÂåñ‰∏Ä‰∫õ‰∏úË•øÔºåÂ∫îËØ•ÁúãÁöÑÂá∫ÂàùÂßãÂåñ‰∫ÜÂï•„ÄÇ env_init_percpu(); trap_init_percpu(); xchg(&amp;thiscpu-&gt;cpu_status, CPU_STARTED); // tell boot_aps() we're up // Now that we have finished some basic setup, call sched_yield() // to start running processes on this CPU. But make sure that // only one CPU can enter the scheduler at a time! // // Your code here: lock_kernel();//Ëøô‰∏™ÊòØÂÜÖÊ†∏ÈîÅÔºåÂêéÈù¢‰ºöËÆ≤ÁöÑ„ÄÇ // Remove this after you finish Exercise 6 //for (;;); sched_yield();&#125; Êàë‰ª¨ÁªÉ‰π†2ËÆ©Êàë‰ª¨ÂÜçÂºÄ‰∏Ä‰∫õÂÜÖÂ≠òÁªô‰ªñÂêØÂä®Áî®„ÄÇËøô‰∏™Âú∞ÊñπÊàëÂú®ÊÄùËÄÉÔºåËøêË°åÂÆå‰πãÂêéÈöæÈÅì‰∏çÁî®ÊääËøôÂùóÂÜÖÂ≠òÈáçÊñ∞Âä†ÂÖ•ÂÜÖÂ≠òÁ©∫Èó≤ÂàóË°®ÂêóÔºüÔºüÂú®Êàë‰ª¨page_init ÂêéÈù¢ÁªßÁª≠Ê∑ªÂä†Âá†Ë°åÂ∞±ÂèØ‰ª•‰∫Ü„ÄÇ1234567// LAB 4:// Change your code to mark the physical page at MPENTRY_PADDR// as in use// ÊääMPENTRY_PADDRËøôÂùóÂú∞ÂùÄ‰πüÂú®Á©∫Èó≤ÂàóË°®ÈáåÈù¢Âà†Èô§„ÄÇuint32_t range_mpentry = PGNUM(MPENTRY_PADDR);pages[range_mpentry+1].pp_link=pages[range_mpentry].pp_link;pages[range_mpentry].pp_link=NULL; Question boot.S‰∏≠ÔºåÁî±‰∫éÂ∞öÊ≤°ÊúâÂêØÁî®ÂàÜÈ°µÊú∫Âà∂ÔºåÊâÄ‰ª•Êàë‰ª¨ËÉΩÂ§üÊåáÂÆöÁ®ãÂ∫èÂºÄÂßãÊâßË°åÁöÑÂú∞Êñπ‰ª•ÂèäÁ®ãÂ∫èÂä†ËΩΩÁöÑÂú∞ÂùÄÔºõ‰ΩÜÊòØÔºåÂú®mpentry.SÁöÑÊó∂ÂÄôÔºåÁî±‰∫é‰∏ªCPUÂ∑≤ÁªèÂ§Ñ‰∫é‰øùÊä§Ê®°Âºè‰∏ã‰∫ÜÔºåÂõ†Ê≠§ÊòØ‰∏çËÉΩÁõ¥Êé•ÊåáÂÆöÁâ©ÁêÜÂú∞ÂùÄÁöÑÔºåÁªôÂÆöÁ∫øÊÄßÂú∞ÂùÄÔºåÊò†Â∞ÑÂà∞Áõ∏Â∫îÁöÑÁâ©ÁêÜÂú∞ÂùÄÊòØÂÖÅËÆ∏ÁöÑ„ÄÇ Per-CPU State and InitializationÂú®Â§öÂ§ÑÁêÜÂô®CPU‰∏≠ÔºåÁü•ÈÅìËá™Â∑±ÊòØÂì™‰∏™CPUÂçÅÂàÜÈáçË¶Å„ÄÇÂâçÈù¢Êàë‰ª¨Â∑≤ÁªèÂàÜÊûêËøáÊÄé‰πàËé∑ÂèñÊâÄÊúâCPUÁöÑ‰ø°ÊÅØ (ÂÅáË£ÖÊàë‰ª¨Áü•ÈÅìËøáÁ®ã)„ÄÇkern/cpu.hÈáåÈù¢ÂÆö‰πâ‰∫ÜÂêÑÁßçÊàë‰ª¨ÊÉ≥Ë¶ÅÁöÑ‰ø°ÊÅØ„ÄÇ1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*Kernel-private definitions for multiprocessor supportÂ§öÂ§ÑÁêÜÂô®ÊîØÊåÅÁöÑÁßÅÊúâÂÜÖÊ†∏ÂÆö‰πâÂ∫îËØ•ÊòØ ÂÆö‰πâ‰∫Ü Â§öÂ§ÑÁêÜÂô®ÁöÑ‰∏Ä‰∫õÊìç‰Ωú */#ifndef JOS_INC_CPU_H#define JOS_INC_CPU_H#include &lt;inc/types.h&gt;#include &lt;inc/memlayout.h&gt;#include &lt;inc/mmu.h&gt;#include &lt;inc/env.h&gt;// Maximum number of CPUs#define NCPU 8// Values of status in struct Cpuenum &#123; //Ëøô‰∏™ÊòØCPUÁä∂ÊÄÅ CPU_UNUSED = 0, CPU_STARTED, CPU_HALTED,&#125;;// Per-CPU statestruct CpuInfo &#123; //CPU‰ø°ÊÅØ uint8_t cpu_id; // Local APIC ID; index into cpus[] below Á¨¨Âá†‰∏™CPU volatile unsigned cpu_status; // The status of the CPU Áä∂ÊÄÅ struct Env *cpu_env; // The currently-running environment. ÂΩìÂâçËøêË°åÁöÑÁéØÂ¢É struct Taskstate cpu_ts; // Used by x86 to find stack for interrupt cpu‰∏≠Êñ≠Ê†à&#125;;// Initialized in mpconfig.cextern struct CpuInfo cpus[NCPU]; //ËøôÂá†‰∏™Â∞±ÊòØÊî∂ÈõÜÂà∞ÁöÑ‰ø°ÊÅØ...extern int ncpu; // Total number of CPUs in the system Êï∞Èáèextern struct CpuInfo *bootcpu; // The boot-strap processor (BSP) BSPÁöÑ‰ø°ÊÅØextern physaddr_t lapicaddr; // Physical MMIO address of the local APIC Áâ©ÁêÜÂú∞ÂùÄ// Per-CPU kernel stacksextern unsigned char percpu_kstacks[NCPU][KSTKSIZE]; ///ÊØè‰∏™CPUÁöÑÂÜÖÊ†∏Ê†à int cpunum(void); //Ëé∑ÂèñËá™Â∑±Ëøô‰∏™CPUÁöÑid#define thiscpu (&amp;cpus[cpunum()]) //ÊåáÂêëËá™Â∑±Ëøô‰∏™CPUvoid mp_init(void); //Êî∂ÈõÜÊâÄÊúâCPU‰ø°ÊÅØvoid lapic_init(void);//‰∏≠Êñ≠ÂàùÂßãÂåñvoid lapic_startap(uint8_t apicid, uint32_t addr);//CPUÂêØÂä®void lapic_eoi(void);//Acknowledge interrupt.void lapic_ipi(int vector);//‰∏çÁü•ÈÅìÊòØÂï•#endif ÊØè‰∏™CPUÁã¨ÊúâÁöÑÂ±ûÊÄßÔºö Per-CPU kernel stackÔºåÂõ†‰∏∫‰∏çÂêåÁöÑCPUÂèØËÉΩÂêåÊó∂Èô∑ÂÖ•Âà∞ÂÜÖÊ†∏ÔºåÂõ†Ê≠§ÊØè‰∏™CPUÈúÄË¶ÅÊúâ‰∏çÂêåÁöÑÂÜÖÊ†∏Ê†àÈò≤Ê≠¢ÂΩºÊ≠§‰πãÈó¥ÁöÑÂπ≤Êâ∞„ÄÇÊï∞ÁªÑpercpu_kstacks[NCPU][KSTKSIZE]ÁªôNCPU‰∏™CPU‰øùÁïô‰∫ÜÂÜÖÊ†∏Ê†àÁöÑÁ©∫Èó¥„ÄÇÂú®lab2‰∏≠ÔºåÂ∞ÜÁâ©ÁêÜÂú∞ÂùÄbootstackÊò†Â∞ÑÂà∞BSPÁöÑÂÜÖÊ†∏Ê†àÁöÑËôöÊãüÂú∞ÂùÄKSTACKTOP-KSTKSIZE„ÄÇÁõ∏‰ººÁöÑÔºåÂú®Êú¨Ê¨°ÂÆûÈ™å‰∏≠Ôºå‰Ω†Â∞ÜÊò†Â∞ÑÊØè‰∏™CPUÁöÑÂÜÖÊ†∏Ê†àÂà∞Ëøô‰∏™Âå∫ÂüüÔºåÂπ∂‰∏îÊØè‰∏™Ê†à‰πãÈó¥Áõ∏Èöî‰∏Ä‰∏™guard pages‰Ωú‰∏∫ÁºìÂÜ≤„ÄÇCPU0ÁöÑÊ†àÂ∞Ü‰ªéKSTACKTOPÂêë‰∏ãÂ¢ûÈïøÔºåCPU 1ÁöÑÊ†àÂ∞ÜÂú®CPU 0ÁöÑÊ†àÂ¢ûÈïøÊñπÂêëÁöÑÂ∫ïÈÉ®‰πãÂêéÁöÑKSTKGAPÂ≠óËäÇÂºÄÂßã„ÄÇ Per-CPU TSS and TSS descriptorÔºåÊØè‰∏™CPUÁöÑÈÉΩÈúÄË¶Å‰ªªÂä°Áä∂ÊÄÅÊÆµÁî®‰ª•Âå∫ÂàÜ‰∏çÂêåÁöÑCPUÂÜÖÊ†∏Ê†àÁöÑ‰ΩçÁΩÆ„ÄÇCPU iÁöÑTSSÂú®cpus[i].cpu_ts‰∏≠Â≠òÂÇ®ÔºåÁõ∏Â∫îÁöÑTSSÊèèËø∞Á¨¶Âú®GDTË°®È°πgdt[(GD_TSS0 &gt;&gt; 3) + i]‰∏≠„ÄÇÂÆö‰πâÂú®kern/trapÂÖ®Â±ÄÂèòÈáètsÂ∞Ü‰∏ç‰ºöÂÜç‰ΩøÁî®„ÄÇ Per-CPU current environment pointerÔºåÁî±‰∫éÊØè‰∏™CPUÂèØ‰ª•ÂêåÊó∂ËøêË°å‰∏çÂêåÁöÑÁî®Êà∑ÁéØÂ¢ÉÔºåÊàë‰ª¨ÂÆö‰πâÁ¨¶Âè∑curenvË°®Á§∫cpus[cpunum()].cpu_env(ÊàñËÄÖÊòØthiscpu-&gt;cpu_env)ÔºåÊåáÂêëÊ≠£Âú®ÂΩìÂâçCPU‰∏äËøêË°åÁöÑÁî®Êà∑ÁéØÂ¢É„ÄÇ Per-CPU system registersÔºåÂåÖÊã¨Á≥ªÁªüÂØÑÂ≠òÂô®Âú®ÂÜÖÁöÑÊâÄÊúâÂØÑÂ≠òÂô®ÂØπÊØè‰∏™CPUÊù•ËØ¥ÈÉΩÊòØÁßÅÊúâÁöÑ„ÄÇÂõ†Ê≠§ÔºåÂàùÂßãÂåñËøô‰∫õÂØÑÂ≠òÂô®ÁöÑÊåá‰ª§ÔºåÂ¶Çlcr3(), ltr(), lgdt(), lidt()Á≠âÁ≠âÂøÖÈ°ªÂú®ÊØè‰∏™CPU‰∏äÊâßË°å‰∏ÄÊ¨°„ÄÇÂáΩÊï∞env_init_percpu()Âíåtrap_init_percpu()Â∞±ÊòØ‰∏∫‰∫ÜÂÆûÁé∞Ëøô‰∏™ÂäüËÉΩ„ÄÇ ÁªÉ‰π†3 ËÆ©ÊàëÂÆûÁé∞ÂÜÖÂ≠òÊØè‰∏™CPUÁöÑÊ†àÂàÜÈÖçÔºåÂú®kern/pmap.c‰∏≠ÁöÑmem_init_mp()„ÄÇ mem_init_mp1234567891011121314151617181920212223242526272829// Modify mappings in kern_pgdir to support SMP// - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)//Êò†Â∞ÑÂéªÊîØÊåÅSMP Êò†Â∞ÑÂú∞ÂùÄÊòØ [KSTACKTOP-PTSIZE, KSTACKTOP)static voidmem_init_mp(void)&#123; // Map per-CPU stacks starting at KSTACKTOP, for up to 'NCPU' CPUs. //Êò†Â∞ÑÂú∞ÂùÄ‰ªé KSTACKTOP ÂºÄÂßã // For CPU i, use the physical memory that 'percpu_kstacks[i]' refers ÊØè‰∏™CPU i ÁöÑÁâ©ÁêÜÂú∞ÂùÄÊòØ 'percpu_kstacks[i] // to as its kernel stack. CPU i's kernel stack grows down from virtual // address kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP), and is ÂºÄÂßãÂú∞ÂùÄÊòØ kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP) // divided into two pieces, just like the single stack you set up in // mem_init: Ëøô‰∏™ÊòØ‰∏çÊòØÂæàÁúºÁÜüÔºåÂíåÂâçÈù¢ÂçïCPUÊòØ‰∏ÄÊ†∑ÁöÑ Êúâ‰∏ÄÂùóÊòØ‰∏çÁî®Êò†Â∞ÑÁöÑÔºåËøôÊ†∑Â¶ÇÊûúÊ†àÊ∫¢Âá∫ÔºåÂ∞±Áõ¥Êé•RE // * [kstacktop_i - KSTKSIZE, kstacktop_i) // -- backed by physical memory // * [kstacktop_i - (KSTKSIZE + KSTKGAP), kstacktop_i - KSTKSIZE) // -- not backed; so if the kernel overflows its stack, // it will fault rather than overwrite another CPU's stack. // Known as a "guard page". // Permissions: kernel RW, user NONE // // LAB 4: Your code here: for (size_t i = 0; i &lt; NCPU; i++) &#123; /* code Áõ¥Êé•Êò†Â∞ÑÂç≥ÂèØ */ boot_map_region(kern_pgdir,KSTACKTOP-i*(KSTKSIZE+KSTKGAP)-KSTKSIZE,KSTKSIZE,PADDR(percpu_kstacks[i]),PTE_W); &#125; &#125; ÁªÉ‰π† 4 ËÆ©Êàë‰ª¨ÂÆûÁé∞ÊØè‰∏™CPUÁöÑ‰∏≠Êñ≠ÂàùÂßãÂåñÔºåÂú® kern/trap.c‰∏≠ÁöÑtrap_init_percpu()„ÄÇ12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// Initialize and load the per-CPU TSS and IDT ÂàùÂßãÂåñÊØè‰∏™CPUÁöÑTSS ÂíåIDTvoidtrap_init_percpu(void)&#123; // The example code here sets up the Task State Segment (TSS) and // the TSS descriptor for CPU 0. But it is incorrect if we are // running on other CPUs because each CPU has its own kernel stack. // Fix the code so that it works for all CPUs. //Â∑≤ÁªèÊúâ‰∫Ü‰∏Ä‰∏™TSSÊèèËø∞ÂÖ≥‰∫éCPU 0Ôºå‰ΩÜÊòØÊàë‰ª¨ÈúÄË¶ÅÂàùÂßãÂåñÂ§ö‰∏™CPUÁöÑ // Hints: // - The macro "thiscpu" always refers to the current CPU's // struct CpuInfo; Áî®thiscpu ÊåáÂêëÂΩìÂâçCPU ÁöÑCPUinfo // - The ID of the current CPU is given by cpunum() or // thiscpu-&gt;cpu_id; Ëé∑ÂèñID // - Use "thiscpu-&gt;cpu_ts" as the TSS for the current CPU, // rather than the global "ts" variable; Ëé∑Âèñts // - Use gdt[(GD_TSS0 &gt;&gt; 3) + i] for CPU i's TSS descriptor;Ëé∑Âèñ TSS ÊèèËø∞ // - You mapped the per-CPU kernel stacks in mem_init_mp() Êò†Â∞ÑÁöÑÂ†ÜÊ†à // - Initialize cpu_ts.ts_iomb to prevent unauthorized environments // from doing IO (0 is not the correct value!) ÂàùÂßãÂåñ cpu_ts.ts_iomb // // ltr sets a 'busy' flag in the TSS selector, so if you // accidentally load the same TSS on more than one CPU, you'll ÊØè‰∏™CPUÁöÑTSS ‰∏ç‰∏ÄÊ†∑ // get a triple fault. If you set up an individual CPU's TSS Â¶ÇÊûúÁõ∏ÂêåÁöÑTSS Â∞±‰ºöÊä•Èîô // wrong, you may not get a fault until you try to return from // user space on that CPU. // // LAB 4: Your code here int i=thiscpu-&gt;cpu_id;//Áõ¥Êé•Êää ts ÊîπÊàêthiscpu-&gt;cpu_ts thiscpu-&gt;cpu_ts.ts_esp0=KSTACKTOP-i*(KSTKSIZE+KSTKGAP);//Âú∞ÂùÄË¶ÅÂèò thiscpu-&gt;cpu_ts.ts_ss0=GD_KD; thiscpu-&gt;cpu_ts.ts_iomb = sizeof(struct Taskstate); //ÂàùÂßãÂåñgdt Ê†πÊçÆÂâçÈù¢ÁöÑÊù•Â∞±Ë°å‰∫Ü gdt[(GD_TSS0 &gt;&gt; 3) + i] = SEG16(STS_T32A, (uint32_t) (&amp;(thiscpu-&gt;cpu_ts)), sizeof(struct Taskstate) - 1, 0); gdt[(GD_TSS0 &gt;&gt; 3) + i].sd_s = 0; // // Setup a TSS so that we get the right stack // // when we trap to the kernel. // ts.ts_esp0 = KSTACKTOP; // ts.ts_ss0 = GD_KD; // ts.ts_iomb = sizeof(struct Taskstate); // // Initialize the TSS slot of the gdt. // gdt[GD_TSS0 &gt;&gt; 3] = SEG16(STS_T32A, (uint32_t) (&amp;ts), // sizeof(struct Taskstate) - 1, 0); // gdt[GD_TSS0 &gt;&gt; 3].sd_s = 0; // Load the TSS selector (like other segment selectors, the // bottom three bits are special; we leave them 0) ltr(GD_TSS0+8*i); //ÊØè‰∏™Âç†3‰Ωç ‰πüÂ∞±ÊòØ 1&lt;&lt;3=8 // Load the IDT lidt(&amp;idt_pd);&#125; ËøêË°åmake qemu CPUS=4Â∞±‰ºöÂá∫Áé∞ÂÆòÁΩë‰∏äÁöÑÈÇ£‰∫õ‰∏úË•ø„ÄÇ LockingÂ§ßÂÜÖÊ†∏ÈîÅÔºåÁÆÄÂçïÊù•ËÆ≤ÔºåÂ∞±ÊòØÂΩì‰∏Ä‰∏™CPUËøõÂÖ•ÂÜÖÊ†∏ÁöÑÊó∂ÂÄôÔºåÂÜÖÊ†∏ÈîÅ‰ΩèÔºåÂõ†‰∏∫Â§ö‰∏™CPUÂêåÊòØÂú®ÂÜÖÊ†∏ÈáåÈù¢ËøêË°åÂèØËÉΩÂá∫Èîô„ÄÇÂèØ‰ª•Ëá™Ë°åÁôæÂ∫¶‰∏Ä‰∏ã„ÄÇÂú®kern/spinlock.hÂÆö‰πâ‰∫ÜÈÇ£‰∫õÈîÅ„ÄÇÊàë‰ª¨ÂéªÁúãÁúã„ÄÇ kern/spinlock.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116// Mutual exclusion spin locks./* Â§¥Êñá‰ª∂ ‰ªãÁªçËøá‰∫Ü ÔºåËøô‰∏™‰πü‰∏çÁî®Â§öËØ¥‰∫ÜÂêß*/#include &lt;inc/types.h&gt;#include &lt;inc/assert.h&gt;#include &lt;inc/x86.h&gt;#include &lt;inc/memlayout.h&gt;#include &lt;inc/string.h&gt;#include &lt;kern/cpu.h&gt;#include &lt;kern/spinlock.h&gt;#include &lt;kern/kdebug.h&gt;// The big kernel lockstruct spinlock kernel_lock = &#123;#ifdef DEBUG_SPINLOCK .name = "kernel_lock"#endif&#125;;#ifdef DEBUG_SPINLOCK// Record the current call stack in pcs[] by following the %ebp chain. Ëøô‰∏™‰∏çÁü•ÈÅìÁî®Êù•Âô∂Âï•ÁöÑÊ≤°Áî®ÁÜ¨Ëøá static voidget_caller_pcs(uint32_t pcs[])&#123; uint32_t *ebp; int i; ebp = (uint32_t *)read_ebp(); for (i = 0; i &lt; 10; i++)&#123; if (ebp == 0 || ebp &lt; (uint32_t *)ULIM) break; pcs[i] = ebp[1]; // saved %eip ebp = (uint32_t *)ebp[0]; // saved %ebp &#125; for (; i &lt; 10; i++) pcs[i] = 0;&#125;// Check whether this CPU is holding the lock. Ê£ÄÊü•ÂΩìÂâçCPUÊòØÂê¶ÊúâÈîÅstatic intholding(struct spinlock *lock)&#123; return lock-&gt;locked &amp;&amp; lock-&gt;cpu == thiscpu;&#125;#endifvoid__spin_initlock(struct spinlock *lk, char *name)//ÂàùÂßãÂåñÈîÅÁöÑÊ†∑Â≠ê&#123; lk-&gt;locked = 0;#ifdef DEBUG_SPINLOCK lk-&gt;name = name; lk-&gt;cpu = 0;#endif&#125;// Acquire the lock.// Loops (spins) until the lock is acquired.// Holding a lock for a long time may cause// other CPUs to waste time spinning to acquire it.//ÈîÅ‰ΩèÂÜÖÊ†∏voidspin_lock(struct spinlock *lk)&#123;#ifdef DEBUG_SPINLOCK if (holding(lk)) panic("CPU %d cannot acquire %s: already holding", cpunum(), lk-&gt;name);#endif // The xchg is atomic. // It also serializes, so that reads after acquire are not // reordered before it. while (xchg(&amp;lk-&gt;locked, 1) != 0) //Â¶ÇÊûúÊòØÂ∑≤ÁªèÈîÅ‰ΩèÁöÑÔºåÂ∞±‰∏ÄÁõ¥Á≠âÂæÖ asm volatile ("pause"); // Record info about lock acquisition for debugging.#ifdef DEBUG_SPINLOCK lk-&gt;cpu = thiscpu; //ÈîÅ‰ΩèÁöÑCPUÂèòÊàêËá™Â∑± get_caller_pcs(lk-&gt;pcs);#endif&#125;// Release the lock. Ëß£Èô§ÈîÅvoidspin_unlock(struct spinlock *lk)&#123;#ifdef DEBUG_SPINLOCK if (!holding(lk)) &#123; int i; uint32_t pcs[10]; // Nab the acquiring EIP chain before it gets released memmove(pcs, lk-&gt;pcs, sizeof pcs); cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", cpunum(), lk-&gt;name, lk-&gt;cpu-&gt;cpu_id); for (i = 0; i &lt; 10 &amp;&amp; pcs[i]; i++) &#123; struct Eipdebuginfo info; if (debuginfo_eip(pcs[i], &amp;info) &gt;= 0) cprintf(" %08x %s:%d: %.*s+%x\n", pcs[i], info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name, pcs[i] - info.eip_fn_addr); else cprintf(" %08x\n", pcs[i]); &#125; panic("spin_unlock"); &#125; lk-&gt;pcs[0] = 0; lk-&gt;cpu = 0;#endif // The xchg instruction is atomic (i.e. uses the "lock" prefix) with // respect to any other instruction which references the same memory. // x86 CPUs will not reorder loads/stores across locked instructions // (vol 3, 8.2.2). Because xchg() is implemented using asm volatile, // gcc will not reorder C statements across the xchg. xchg(&amp;lk-&gt;locked, 0);//ÈáäÊîæÂÜÖÊ†∏&#125; ÈáåÈù¢Áî®ÁöÑ‰∏äÁöÑÂáΩÊï∞Ôºå‰πüÂ∞±‰∏§‰∏™spin_lockÂíåspin_unlockÔºå‰ªñ‰ª¨Âú®spinlock.hÈáåÈù¢Áî®lock_kernelÂíåunlock_kernelË∞ÉÁî®„ÄÇÂú®‰ª£Á†Å‰∏≠ÊÄªÂÖ±Êúâ4Â§Ñ‰ΩøÁî®‰∫ÜÂ§ßÂÜÖÊ†∏ÈîÅÔºö Âú®i386_init()ÂáΩÊï∞‰∏≠ÔºåBSPÂÖàËé∑ÂæóÂ§ßÂÜÖÊ†∏ÈîÅÁÑ∂ÂêéÂÜçÂêØÂä®ÂÖ∂‰ΩôÁöÑCPU Âú®mp_main()ÂáΩÊï∞‰∏≠ÔºåÂú®ÂàùÂßãÂåñAPÂêéËé∑ÂæóÂ§ßÂÜÖÊ†∏ÈîÅÔºåÁÑ∂ÂêéË∞ÉÁî®sched_yield()ÂºÄÂßãÂú®Ëøô‰∏™AP‰∏äËøêË°åÁî®Êà∑ÁéØÂ¢É„ÄÇ Âú®trap()ÂáΩÊï∞‰∏≠Ôºå‰ªéÁî®Êà∑ÊÄÅÈô∑ÂÖ•Âà∞ÂÜÖÊ†∏ÊÄÅÂøÖÈ°ªËé∑ÂæóÂ§ßÂÜÖÊ†∏ÈîÅÔºåÈÄöËøáÊ£ÄÊü•tf_csÁöÑ‰Ωé‰ΩçÁ°ÆÂÆöËøô‰∏™Èô∑ÂÖ•ÂèëÁîüÂú®Áî®Êà∑ÊÄÅËøòÊòØÂú®ÂÜÖÊ†∏ÊÄÅ Âú®env_run()ÂáΩÊï∞‰∏≠ÔºåÂú®ÂàáÊç¢Âà∞Áî®Êà∑ÊÄÅ‰πãÂâçÈáäÊîæÂ§ßÂÜÖÊ†∏ÈîÅÔºå‰∏çË¶ÅÂ§™Êó©‰πü‰∏çË¶ÅÂ§™ÊôöÔºåÂê¶ÂàôÂ∞±‰ºö‰ΩìÈ™å‰∏ÄÊääÁ´û‰∫âÊàñËÄÖÊ≠ªÈîÅÁöÑÊÉÖÂÜµ„ÄÇ ÁªÉ‰π†5Â∞±ÊòØËÆ©Êàë‰ª¨Âú®ËøôÂá†‰∏™Âú∞ÊñπË∞ÉÁî®„ÄÇÁ¨¨‰∏Ä‰∏™ i386_init ÈáåÈù¢12345// Acquire the big kernel lock before waking up APs// Your code here:lock_kernel();// Starting non-boot CPUs Âú®Ëøô‰∏™ÂêØÂä®‰πãÂâçË∞ÉÁî®lock_kernel();boot_aps(); Á¨¨‰∫å‰∏™ mp_mainÈáåÈù¢12345678910// Now that we have finished some basic setup, call sched_yield()// to start running processes on this CPU. But make sure that// only one CPU can enter the scheduler at a time!//// Your code here:lock_kernel();//ÈîÅ‰ΩèÂÜÖÊ†∏// Remove this after you finish Exercise 6//for (;;); Ëøô‰∏™ÂèØ‰ª•Ê≥®ÈáäÊéâ‰∫ÜÔºåËôΩÁÑ∂ËØ¥ÊòØÁªÉ‰π† 6ÔºåÁ≠â‰ºöÊ≥®Èáä‰πüÊòØ‰∏ÄÊ†∑ÁöÑ ÂêéÈù¢ÊòØË∞ÉÂ∫¶Á®ãÂ∫èsched_yield(); Á¨¨‰∏â‰∏™trap123456if ((tf-&gt;tf_cs &amp; 3) == 3) &#123; // Trapped from user mode. Â¶ÇÊûúÊòØ‰ªéÁî®Êà∑Ê®°ÂºèËøáÊù•Â∞±ÈîÅ‰ΩèÂÜÖÊ†∏„ÄÇ // Acquire the big kernel lock before doing any // serious kernel work. // LAB 4: Your code here. lock_kernel(); Á¨¨4‰∏™env_run() Ëøô‰∏™ÂáΩÊï∞Ë∑ëÁî®Êà∑ÊÄÅÂéª‰∫ÜÔºåÊâÄ‰ª•Ë¶ÅÈáäÊîæÂÜÖÊ†∏„ÄÇ12unlock_kernel(); //Âú®ËΩ¨Áßª‰πãÂâçÈáäÊîæÂÜÖÊ†∏env_pop_tf(&amp;curenv-&gt;env_tf); ÂÖ∂ÂÆûËøòÁî®ÂæàÂ§öÈîÅ‰ΩèÂÜÖÊ†∏ÔºåÂíåÈáäÊîæÂÜÖÊ†∏Ôºå‰ΩÜÊòØÊàë‰ª¨ÂÆûÈ™åÂπ∂Ê≤°ÊúâËÆ©Êàë‰ª¨ÂÆûÁé∞„ÄÇ Question 2Ê≤°Ëß£ÂÜ≥ÂëäËæû„ÄÇ Round-Robin SchedulingÂÆûÁé∞ËΩÆËΩ¨Ë∞ÉÂ∫¶„ÄÇ kern/sched.c‰∏≠ÁöÑsched_yield()ÂáΩÊï∞Ë¥üË¥£ÈÄâÂèñ‰∏Ä‰∏™Êñ∞Áî®Êà∑ÁéØÂ¢ÉËøêË°å„ÄÇ‰ªéÂàöÂàöËøêË°åÁöÑÁî®Êà∑ÁéØÂ¢ÉÂºÄÂßã‰ª•Âæ™ÁéØÁöÑÊñπÂºè‰æùÊ¨°ÊêúÁ¥¢envs[]Êï∞ÁªÑÔºàÂ¶ÇÊûú‰πãÂâçÊ≤°ÊúâËøêË°åËøáÁöÑÁî®Êà∑ÁéØÂ¢ÉÔºåÂ∞±‰ªéÊï∞ÁªÑÁöÑÁ¨¨‰∏Ä‰∏™ÂÖÉÁ¥†ÂºÄÂßãÔºâÔºåÈÄâÊã©ÂèëÁé∞ÁöÑÁ¨¨‰∏Ä‰∏™Áä∂ÊÄÅ‰∏∫ENV_RUNNABLEÁöÑÁî®Êà∑ÁéØÂ¢ÉÔºåÁÑ∂ÂêéË∞ÉÁî®env_run()Ë∑≥ËΩ¨Âà∞ÈÄâ‰∏≠ÁöÑÁî®Êà∑ÁéØÂ¢É‰∏äËøêË°å„ÄÇ sched_yield()‰∏çËÉΩÂêåÊó∂Âú®‰∏§‰∏™CPU‰∏äËøêË°åÁõ∏ÂêåÁöÑÁî®Êà∑ÁéØÂ¢É„ÄÇÈÄöËøáÂà§Êñ≠Áî®Êà∑ÁéØÂ¢ÉÁöÑÁä∂ÊÄÅÂ∞±ÂèØ‰ª•Á°ÆÂÆöËØ•ÁéØÂ¢ÉÊòØÂê¶Ê≠£Âú®ËøêË°å Êàë‰ª¨Â∑≤ÁªèÂÆûÁé∞‰∫Ü‰∏Ä‰∏™Êñ∞ÁöÑÁ≥ªÁªüË∞ÉÁî®sys_yield()ÔºåÁî®Êà∑ÁéØÂ¢ÉÂèØ‰ª•Ë∞ÉÁî®‰ª•ÊâßË°åÂÜÖÊ†∏ÊÄÅÁöÑsched_yield()ÂÆûÁé∞‰ª•Ëá™Âä®ÊîæÂºÉCPUÁöÑÊéßÂà∂ÊùÉ„ÄÇ ÁªÉ‰π†6 ËÆ©Êàë‰ª¨ÂÆûÁé∞Ëøô‰∏™Ë∞ÉÂ∫¶Á®ãÂ∫è„ÄÇ sched_yield123456789101112131415161718192021222324252627282930313233343536373839404142// Choose a user environment to run and run it. ÈÄâÊã©‰∏Ä‰∏™ÁéØÂ¢ÉÂéªËøêË°å‰ªñvoidsched_yield(void)&#123; struct Env *idle; // Implement simple round-robin scheduling. // ÂÆûÁé∞ÁÆÄÂçïÁöÑËΩÆËΩ¨Ë∞ÉÂ∫¶ // Search through 'envs' for an ENV_RUNNABLE environment in // circular fashion starting just after the env this CPU was // last running. Switch to the first such environment found. // ‰ªéÂΩìÂâçËøêË°åÁéØÂ¢ÉÂºÄÂßã ÊâæÂà∞‰∏ãÈù¢Á¨¨‰∏Ä‰∏™ÁéØÂ¢É„ÄÇ // If no envs are runnable, but the environment previously // running on this CPU is still ENV_RUNNING, it's okay to // choose that environment. //Â¶ÇÊûúÊ≤°ÊúâÂÖ∂‰ªñÁ®ãÂ∫èÊòØ Â∞±Áª™Áä∂ÊÄÅ Â∞±ÁªßÁª≠ËøêË°åËá™Â∑± // Never choose an environment that's currently running on // another CPU (env_status == ENV_RUNNING). If there are // no runnable environments, simply drop through to the code // below to halt the cpu. //Ê∞∏Ëøú‰∏ç‰ºöËøêË°åÂÖ∂‰ªñCPU ‰∏äÊ≠£Âú®ËøêË°åÁöÑÁéØÂ¢ÉÔºåÂ¶ÇÊûúÊ≤°ÊúâÂèØ‰ª•ËøêË°åÁöÑCPU Â∞±ÊòØÂÅúÊ≠¢ Ëøô‰∏™CPU // LAB 4: Your code here. int i, nxenvid; if (curenv) nxenvid = ENVX(curenv-&gt;env_id); else nxenvid = 0; //Â¶ÇÊûúÊòØÁ¨¨‰∏ÄË∞ÉÂ∫¶ÊòØ 0 //Êûö‰∏æÊâÄÊúâËøõÁ®ãÔºåÁúãÊúâÊ≤°ÊúâËÉΩÂ§üËøêË°åÁöÑÔºåÊúâÁöÑËøêË°å„ÄÇ for (i = 0; i &lt; NENV; i++) &#123; if (envs[(nxenvid + i) % NENV].env_status == ENV_RUNNABLE)&#123; envs[(nxenvid + i) % NENV].env_cpunum=cpunum(); env_run(&amp;envs[(nxenvid + i) % NENV]); &#125; &#125; if (curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)&#123;//Ê≤°ÊúâÂÖ∂‰ªñÁöÑÂ∞±ËøêË°åÂΩìÂâçÁöÑÁéØÂ¢É curenv-&gt;env_cpunum=cpunum(); env_run(curenv); &#125; // sched_halt never returns ÂΩìÂâçÁéØÂ¢ÉÂ¶ÇÊûúÈÉΩ‰∏çÂèØËøêË°å‰∫ÜÂ∞±Áõ¥Êé• ÂÅúÊ≠¢CPU sched_halt();&#125; ÂÆûÁé∞‰∫Üsched_yieldÊàë‰ª¨ËøòÈúÄË¶ÅÂú®Á≥ªÁªüË∞ÉÁî®ÈáåÈù¢‰ΩøÁî®‰ªñÔºå‰∏çÁÑ∂Â∞±‰∏ç‰ºö‰ªé‰∏Ä‰∏™ÁéØÂ¢ÉÈáåÈù¢Âá∫Êù•„ÄÇÂú®syscall.c ÈáåÈù¢ÂÆö‰πâ‰∫Ü‰∏Ä‰∏™Ë∞ÉÁî®‰ªñÁöÑsyscall„ÄÇÁÑ∂ÂêéÊàë‰ª¨ÈúÄË¶Å‰ΩøÁî®‰ªñ„ÄÇ123456789101112131415161718192021// Deschedule current environment and pick a different one to run.static voidsys_yield(void)&#123; sched_yield();&#125; //Âú®syscall()ÈáåÈù¢Âä†ÂÖ• SYS_yield switch (syscallno) &#123; case (SYS_cputs): sys_cputs((const char *)a1, a2); return 0; case (SYS_cgetc): return sys_cgetc(); case (SYS_getenvid): return sys_getenvid(); case (SYS_env_destroy): return sys_env_destroy(a1); case (SYS_yield)://Â§öÂä†ÂÖ•Ëøô‰∏ÄË°å sys_yield(); return 0; ÂÜçÂú®mp_mainÊúÄÂêéË∞ÉÁî®‰∏Ä‰∏ãÊ≥®ÈáäÊéâÊó†Á∫øÂæ™ÁéØ„ÄÇ123// Remove this after you finish Exercise 6//for (;;);sched_yield(); ÁÑ∂ÂêéÊàë‰ª¨ÈúÄË¶ÅÈ™åËØÅ‰∏Ä‰∏ãÔºåË¶ÅÂú®initÈáåÈù¢Ê∑ªÂä†ÊµãËØïÊ†∑‰æã„ÄÇ123456789101112#if defined(TEST) // Don't touch -- used by grading script! ENV_CREATE(TEST, ENV_TYPE_USER);#else // Touch all you want. // ENV_CREATE(user_primes, ENV_TYPE_USER);//ÊääËøô‰∏™Ê≠åÊ≥®ÈáäÊéâÔºåÊ∑ªÂä†‰∏ãÈù¢ 3‰∏™ËøõÁ®ã ENV_CREATE(user_yield, ENV_TYPE_USER); ENV_CREATE(user_yield, ENV_TYPE_USER); ENV_CREATE(user_yield, ENV_TYPE_USER);#endif // TEST* ÁÑ∂ÂêéËøêË°åmake qemu CPUS=2ÂèØ‰ª•ÁúãÂà∞ÂíåÂÆòÁΩë‰∏äËØ¥ÁöÑ‰∏ÄÊ†∑ÁöÑÁªìÊûú„ÄÇ‰∏∫‰ªÄ‰πà‰ºöÂá∫Áé∞ËøôÁßçÁªìÊûúÂèØ‰ª•Êü•Áúãuser/yield.c1234567891011121314151617// yield the processor to other environments#include &lt;inc/lib.h&gt;voidumain(int argc, char **argv)&#123; int i; cprintf("Hello, I am environment %08x.\n", thisenv-&gt;env_id); for (i = 0; i &lt; 5; i++) &#123; sys_yield(); cprintf("Back in environment %08x, iteration %d.\n", thisenv-&gt;env_id, i); &#125; cprintf("All done in environment %08x.\n", thisenv-&gt;env_id);&#125; Question 3Ëøô‰∏™ÈóÆÈ¢òÊòØÔºå‰∏∫‰ªÄ‰πàlrc3ÂàáÊç¢‰∫ÜÈ°µË°®‰ΩÜÊòØÔºåÂØπ‰∫éËøõÁ®ãÁöÑeÊåáÈíàËøòÊòØ‰∏çÁî®ÂèòÔºåÂõ†‰∏∫[UENVSÔºå UENVS+PTSIZE)ÁöÑÊò†Â∞ÑÁâ©ÁêÜÂú∞ÂùÄÈÉΩÊòØ‰∏ÄÊ†∑ÁöÑ„ÄÇ Question 4‰∏∫‰ªÄ‰πàË¶Å‰øùÂ≠òÔºåÂØÑÂ≠òÂô®ÁöÑÁä∂ÊÄÅ„ÄÇÁâπ‰πàËøòË¶ÅÈóÆ‰πà„ÄÇÂëäËæû„ÄÇÂõ†‰∏∫‰∏ç‰øùÂ≠ò‰∏ãÊù•Â∞±Êó†Ê≥ïÊ≠£Á°ÆÂú∞ÊÅ¢Â§çÂà∞ÂéüÊù•ÁöÑÁéØÂ¢É„ÄÇ System Calls for Environment CreationÁé∞Âú®Êàë‰ª¨ÁöÑÁ≥ªÁªüÂ∑≤ÁªèËÉΩÂ§üÁéØÂ¢ÉËøêË°å‰∫Ü‰ΩÜÊòØËøòÊòØ‰∏çËÉΩÁî®Êà∑ÂàõÂª∫ËøõÁ®ãÔºåÂú®unix‰∏≠Êàë‰ª¨Áî®ÁöÑforkÂáΩÊï∞ÂàõÂª∫ËøõÁ®ãÔºåÊâÄ‰ª•Êàë‰ª¨Áé∞Âú®Ë¶ÅÂÆûÁé∞‰∏Ä‰∏™ÁÆÄÂçïforkÂáΩÊï∞„ÄÇ‰∏∫‰∫ÜÂÆûÁé∞Ëøô‰∏™ÂáΩÊï∞ÔºåÊàë‰ª¨ÈúÄË¶Å‰∏ãÈù¢Ëøô‰∫õÁ≥ªÁªüË∞ÉÁî®„ÄÇ sys_exoforkÔºöËøô‰∏™Á≥ªÁªüË∞ÉÁî®Â∞ÜÂàõÂª∫‰∏Ä‰∏™Êñ∞ÁöÑÁ©∫ÁôΩÁî®Êà∑ÁéØÂ¢ÉÔºåÊ≤°ÊúâÊò†Â∞ÑÁöÑÁî®Êà∑Á©∫Èó¥‰∏îÊó†Ê≥ïËøêË°å„ÄÇÂú®Ë∞ÉÁî®ÂáΩÊï∞Êó∂Êñ∞Áî®Êà∑ÁéØÂ¢ÉÁöÑÂØÑÂ≠òÂô®Áä∂ÊÄÅ‰∏éÁà∂ËøõÁ®ãÁõ∏Âêå„ÄÇÂú®Áà∂Áî®Êà∑ÁéØÂ¢É‰∏≠Ôºå‰ºöËøîÂõûÂ≠êÁî®Êà∑ÁéØÂ¢ÉÁöÑenvid_tÔºàÂ¶ÇÊûúÁî®Êà∑ÁéØÂ¢ÉÂàÜÈÖçÂ§±Ë¥•ÔºåËøîÂõû‰∏Ä‰∏™Ë¥üÂÄºÁöÑÈîôËØØÁ†ÅÔºâ„ÄÇËÄåÂ≠êÁî®Êà∑ÁéØÂ¢É‰∏≠Ôºå‰ºöËøîÂõû0„ÄÇÔºàÁî±‰∫éÂ≠êÁî®Êà∑ÁéØÂ¢ÉÂºÄÂßãÊ†áËÆ∞‰∏∫‰∏çÂèØËøêË°åÔºåsys_exoforkÂÆûÈôÖ‰∏äÊòØ‰∏ç‰ºöËøîÂõûÂà∞Â≠êÁî®Êà∑ÁéØÂ¢ÉÁõ¥Âà∞Áà∂Áî®Êà∑ÁéØÂ¢ÉÊ†áËÆ∞Â≠êÁî®Êà∑ÁéØÂ¢ÉÂèØ‰ª•ËøêË°å‚Ä¶Ôºâ sys_env_set_statusÔºöËøô‰∏™Á≥ªÁªüË∞ÉÁî®Â∞ÜÁâπÂÆöÁî®Êà∑ÁéØÂ¢ÉÁöÑÁä∂ÊÄÅËÆæÁΩÆ‰∏∫ENV_RUNNABLEÊàñËÄÖENV_NOT_RUNNABLE„ÄÇ‰∏ÄÊó¶‰∏Ä‰∏™Êñ∞ÁöÑÁî®Êà∑ÁéØÂ¢ÉÁöÑÂú∞ÂùÄÁ©∫Èó¥ÂíåÊâÄÊúâÂØÑÂ≠òÂô®ÈÉΩÂÆåÂÖ®ÂàùÂßãÂåñÔºåËøô‰∏™Á≥ªÁªüË∞ÉÁî®Áî®Êù•Ê†áËÆ∞Ëøô‰∏™Áî®Êà∑ÁéØÂ¢ÉÂáÜÂ§áËøêË°å„ÄÇ sys_page_allocÔºöÂàÜÈÖç‰∏Ä‰∏™È°µÁöÑÁâ©ÁêÜÂÜÖÂ≠òÔºåÂπ∂Â∞ÜÂÖ∂Êò†Â∞ÑÂà∞ÁªôÂÆöÁî®Êà∑ÁéØÂ¢ÉÂú∞ÂùÄÁ©∫Èó¥ÁöÑÁªôÂÆöËôöÊãüÂú∞ÂùÄ„ÄÇ sys_page_mapÔºö‰ªé‰∏Ä‰∏™Áî®Êà∑ÁéØÂ¢ÉÊã∑Ë¥ù‰∏Ä‰∏™È°µÁöÑÊò†Â∞ÑÂà∞Âè¶Â§ñ‰∏Ä‰∏™Áî®Êà∑ÁéØÂ¢ÉÔºåËøôÊ†∑Â∞±ÂÆåÊàê‰∫ÜÂÜÖÂ≠òÂÖ±‰∫´Ôºå‰ΩøÊñ∞ÊóßÁöÑÊò†Â∞ÑÈÉΩÊòØÊåáÂêå‰∏ÄÈ°µÁöÑÁâ©ÁêÜÂÜÖÂ≠ò„ÄÇ sys_page_unmapÔºöÂèñÊ∂àÁªôÂÆöÁî®Êà∑ÁéØÂ¢ÉÁªôÂÆöËôöÊãüÂú∞ÂùÄÁöÑÊò†Â∞Ñ„ÄÇ ‰ª•‰∏äÊâÄÊúâÁöÑÁ≥ªÁªüË∞ÉÁî®ÈÉΩÊé•Êî∂Áî®Êà∑ÁéØÂ¢ÉIDÔºåJOSÂÜÖÊ†∏ÊîØÊåÅÂ∞Ü0‰Ωú‰∏∫ÂΩìÂâçËøêË°åÁöÑÁî®Êà∑ÁéØÂ¢ÉÁöÑIDÁöÑÊÉØ‰æãÔºåËøô‰∏™ÊÉØ‰æãÈÄöËøákern/env.c‰∏≠ÁöÑenvid2env()ÂÆûÁé∞„ÄÇÊàë‰ª¨ÈúÄË¶ÅÂÆûÁé∞fork Êù•ÈÄöËøá user/dumbfork.c„ÄÇÊàë‰ª¨ÂÖàÂéªÁúãÁúãËøô‰∏™Á®ãÂ∫èÂÅö‰∫ÜÂï•„ÄÇ12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// Ping-pong a counter between two processes.// Only need to start one of these -- splits into two, crudely.#include &lt;inc/string.h&gt;#include &lt;inc/lib.h&gt;envid_t dumbfork(void);voidumain(int argc, char **argv)&#123; envid_t who; int i; // fork a child process who = dumbfork();//ÂèØ‰ª•ÁÆÄÂçïËÆ§‰∏∫ËøôÂ∞±ÊòØ‰∏™fork ÂáΩÊï∞ // print a message and yield to the other a few times for (i = 0; i &lt; (who ? 10 : 20); i++) &#123; cprintf("%d: I am the %s!\n", i, who ? "parent" : "child"); sys_yield();//ËæìÂá∫ÂÆåÂêéÂ∞±Ë∞ÉÂ∫¶ &#125;&#125;voidduppage(envid_t dstenv, void *addr)&#123; int r; // This is NOT what you should do in your fork. if ((r = sys_page_alloc(dstenv, addr, PTE_P|PTE_U|PTE_W)) &lt; 0)//ÂºÄËæü‰∫Ü‰∏Ä‰∏™Á©∫Èó¥ panic("sys_page_alloc: %e", r); if ((r = sys_page_map(dstenv, addr, 0, UTEMP, PTE_P|PTE_U|PTE_W)) &lt; 0)//Êò†Â∞Ñ‰∫ÜÁ©∫Èó¥ panic("sys_page_map: %e", r); memmove(UTEMP, addr, PGSIZE);//Â§çÂà∂‰∏Ä‰ªΩ if ((r = sys_page_unmap(0, UTEMP)) &lt; 0)//ÂèñÊ∂àÊò†Â∞Ñ„ÄÇ panic("sys_page_unmap: %e", r);&#125;envid_tdumbfork(void)&#123; envid_t envid; uint8_t *addr; int r; extern unsigned char end[]; // Allocate a new child environment. // The kernel will initialize it with a copy of our register state, // so that the child will appear to have called sys_exofork() too - // except that in the child, this "fake" call to sys_exofork() // will return 0 instead of the envid of the child. envid = sys_exofork(); if (envid &lt; 0) panic("sys_exofork: %e", envid); if (envid == 0) &#123; // We're the child. // The copied value of the global variable 'thisenv' // is no longer valid (it refers to the parent!). // Fix it and return 0. thisenv = &amp;envs[ENVX(sys_getenvid())];//Â¶ÇÊûúÊòØÂÑøÂ≠êÂ∞±ÊääÊñ∞ÁéØÂ¢ÉÈáçÊñ∞ÊåáÂêë‰∏Ä‰∏ã return 0; &#125; // We're the parent. // Eagerly copy our entire address space into the child. // This is NOT what you should do in your fork implementation. for (addr = (uint8_t*) UTEXT; addr &lt; end; addr += PGSIZE)//Â¶ÇÊûúÊòØÁà∂‰∫≤Êàë‰ª¨ÈúÄË¶ÅÊã∑Ë¥ù‰∏Ä‰ªΩÂú∞ÂùÄ duppage(envid, addr);//Ëøô‰∏™Èü©ÂºèËá™Â∑±Áúã‰∏Ä‰∏ã // Also copy the stack we are currently running on. duppage(envid, ROUNDDOWN(&amp;addr, PGSIZE));//Â§çÂà∂Ê†à // Start the child environment running if ((r = sys_env_set_status(envid, ENV_RUNNABLE)) &lt; 0)//Âî§ÈÜíÂÑøÂ≠ê panic("sys_env_set_status: %e", r); return envid;&#125; ÁÆÄÂçïÊù•ËÆ≤Ëß£ÈáäÂÜô‰∫Ü‰∏Ä‰∏™ÁÆÄÂçïÁöÑforkÁ®ãÂ∫èÈÄöËøáÁ≥ªÁªüË∞ÉÁî®ÊääÂÜÖÂ≠òÂ§çÂà∂‰∫Ü‰∏Ä‰ªΩÔºàËøô‰∏™Êó∂ÂÄôËøòÊ≤°ÊúâÂÜôÊó∂Â§çÂà∂ÔºåÊâÄ‰ª•ÊòØÁõ¥Êé•copyÂÜÖÂ≠òÁöÑÔºâÔºåÁÑ∂ÂêéËæìÂá∫‰∫Ü‰∏Ä‰∫õÂÄº„ÄÇÂú®Êàë‰ª¨ÂÜôÁ≥ªÁªüË∞ÉÁî®fork‰πãÂâçÈúÄË¶ÅÁúãÁúãenvid2env„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839404142434445//// Converts an envid to an env pointer. Êääid ËΩ¨Êç¢Êàêenv// If checkperm is set, the specified environment must be either the// current environment or an immediate child of the current environment.//ÈúÄ‰∏çÈúÄË¶ÅÂà§Êñ≠ÊòØÂΩìÂâçËøõÁ®ãÊàñËÄÖÂ≠êËøõÁ®ã// RETURNS// 0 on success, -E_BAD_ENV on error. //0ÊàêÂäüÂÖ∂‰ªñÂá∫Èîô// On success, sets *env_store to the environment. //ÊàêÂäüËÆæÁΩÆÁéØÂ¢É// On error, sets *env_store to NULL.//‰∏çÊàêÂäü‰øùÂ≠òNULL//intenvid2env(envid_t envid, struct Env **env_store, bool checkperm)&#123; struct Env *e; //Â¶ÇÊûúidÊòØ 0Áõ¥Êé•ËøîÂõûÂΩìÂâçÁéØÂ¢É // If envid is zero, return the current environment. if (envid == 0) &#123; *env_store = curenv; return 0; &#125; // Look up the Env structure via the index part of the envid, // then check the env_id field in that struct Env // to ensure that the envid is not stale // (i.e., does not refer to a _previous_ environment // that used the same slot in the envs[] array). e = &amp;envs[ENVX(envid)]; if (e-&gt;env_status == ENV_FREE || e-&gt;env_id != envid) &#123;//Â¶ÇÊûúËøõÁ®ãÂ∑≤ÁªèÈáäÊîæÔºåÂ∞±GG *env_store = 0; return -E_BAD_ENV; &#125; // Check that the calling environment has legitimate permission // to manipulate the specified environment. // If checkperm is set, the specified environment // must be either the current environment // or an immediate child of the current environment.//Âà§Êñ≠ÊòØ‰∏çÊòØËá™Â∑±ÊàñËÄÖÂ≠êËøõÁ®ã if (checkperm &amp;&amp; e != curenv &amp;&amp; e-&gt;env_parent_id != curenv-&gt;env_id) &#123; *env_store = 0; return -E_BAD_ENV; &#125; *env_store = e; return 0;&#125; ÊâÄ‰ª•ËØ¥ËØ¥‰∏äÈù¢Â∞±ÊòØÂà§Êñ≠‰∏Ä‰∏ãËøõÁ®ãÊòØ‰∏çÊòØÂèØÁî®ÁöÑ„ÄÇÂ¶ÇÊûúchekpermÊòØ1ËøòÈúÄË¶ÅÊ£ÄÊü•ÊòØ‰∏çÊòØÂΩìÂâçËøõÁ®ãÊòØ‰∏çÊòØÂΩìÂâçËøõÁ®ãÊàñÂ≠êËøõÁ®ã„ÄÇÁªÉ‰π†7ÂÆûÁé∞ÂâçÈù¢ËØ¥È¢ùÈÇ£Âá†‰∏™ÂáΩÊï∞‰∫Ü„ÄÇÁ¨¨‰∏Ä‰∏™sys_exofork123456789101112131415161718192021222324// Allocate a new environment. ÂàÜÈÖç‰∏Ä‰∏™Êñ∞ÁöÑËøõÁ®ãÔºå‰Ω†ÂèØ‰ª•ÁêÜËß£ÊàêPCB// Returns envid of new environment, or &lt; 0 on error. Errors are: // -E_NO_FREE_ENV if no free environment is available. Ê≤°ÊúâËøõÁ®ãÂèØ‰ª•Áî®‰∫ÜËøîÂõû// -E_NO_MEM on memory exhaustion. Ê≤°ÊúâÂÜÖÂ≠ò‰∫ÜËøîÂõûstatic envid_tsys_exofork(void)&#123; // Create the new environment with env_alloc(), from kern/env.c.Áî®env_allocÂàÜÈÖçËøõÁ®ã // It should be left as env_alloc created it, except that ËÆæÁΩÆÊàêENV_NOT_RUNNABLE // status is set to ENV_NOT_RUNNABLE, and the register set is copied //ÂØÑÂ≠òÂô®Â§çÂà∂ÂΩìÂâçÁéØÂ¢É // from the current environment -- but tweaked so sys_exofork // will appear to return 0. ÈúÄË¶ÅÊääËøîÂõûÂÄºËÆæÁΩÆÊàê0 // LAB 4: Your code here. struct Env*child=NULL; int r=env_alloc(&amp;child,curenv-&gt;env_id); if(r!=0)return r; child-&gt;env_tf=curenv-&gt;env_tf; //Â§çÂà∂tfÔºåËøô‰∏™tfÂΩìÂâçËøêË°åÁöÑ‰ΩçÁΩÆÂ∫îËØ•ÊòØfork ‰πãÂêéÁöÑÁ¨¨‰∏ÄÊù°ËØ≠Âè• child-&gt;env_status=ENV_NOT_RUNNABLE; //ËÆæÁΩÆÁéØÂ¢É //cprintf("status:%d\n",child-&gt;env_status); child-&gt;env_tf.tf_regs.reg_eax = 0;//ËøîÂõûÂÄºÂèòÊàê0 return child-&gt;env_id; //Áà∂‰∫≤ËøîÂõûÁöÑÊòØÂÑøÂ≠êÁöÑid //panic("sys_exofork not implemented");&#125; ‰∏ãÈù¢Â∞±ÊòØsys_env_set_statusÊõ¥ÊîπËøõÁ®ãÁä∂ÊÄÅ„ÄÇ123456789101112131415161718192021222324252627// Set envid's env_status to status, which must be ENV_RUNNABLE// or ENV_NOT_RUNNABLE. Êõ¥ÊîπÁöÑÁä∂ÊÄÅÂøÖÈ°ªÊòØ ENV_RUNNABLE ÂíåENV_NOT_RUNNABLE//// Returns 0 on success, &lt; 0 on error. Errors are: Â§±Ë¥•ËøîÂõû&lt;0// -E_BAD_ENV if environment envid doesn't currently exist,// or the caller doesn't have permission to change envid. //Â¶ÇÊûúÁéØÂ¢É‰∏çÂ≠òÂú®ÊàñËÄÖËøõÁ®ãÈîôËØØ// -E_INVAL if status is not a valid status for an environment. Â¶ÇÊûúÂÄºÈîô‰∫Üstatic intsys_env_set_status(envid_t envid, int status)&#123; // Hint: Use the 'envid2env' function from kern/env.c to translate an // envid to a struct Env. Áî®envid2envÊù•Ê£ÄÊü•ËøõÁ®ã // You should set envid2env's third argument to 1, which will // check whether the current environment has permission to set // envid's status. //Êàë‰ª¨ËÆ≤Ê£ÄÊü•ÂΩìÂâçÁéØÂ¢ÉÊòØÂê¶Ê≠£Á°Æ // LAB 4: Your code here. struct Env * env=NULL; int r=envid2env(envid,&amp;env,1);//Ê£ÄÊü•ËøõÁ®ãidÊòØ‰∏çÊòØÂØπÁöÑ if(r&lt;0)return -E_BAD_ENV; else &#123; if(status!=ENV_NOT_RUNNABLE&amp;&amp;status!=ENV_RUNNABLE)return -E_INVAL;//Ê£ÄÊü•ÁéØÂ¢ÉÂÄºÊòØ‰∏çÊòØÂØπÁöÑ env-&gt;env_status=status; &#125; return 0; //panic("sys_env_set_status not implemented");&#125; ÁÑ∂ÂêéÂ∞±ÊòØÂÖ≥‰∫éÂÜÖÂ≠òÁöÑsys_page_allocÔºåsys_page_map,sys_page_unmapÔºåÈÉΩÂ∑Æ‰∏çÂ§ö„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113// Allocate a page of memory and map it at 'va' with permission// 'perm' in the address space of 'envid'. ÂàÜÈÖç‰∏Ä‰∏™È°µÁöÑÂÜÖÂ≠òÊò†Â∞Ñ envid// The page's contents are set to 0. È°µÈù¢ÂÜÖÂÆπËÆæÁΩÆ‰∏∫ 0Ôºå‰πüÂ∞±ÊòØÂàùÂßãÂåñ‰∏∫0// If a page is already mapped at 'va', that page is unmapped as a// side effect. Â¶ÇÊûúvaÊòØÂ∑≤ÁªèÊò†Â∞ÑÁöÑÂ∞±ÈúÄË¶ÅÔºåÂèñÊ∂àÊò†Â∞Ñ//// perm -- PTE_U | PTE_P must be set, PTE_AVAIL | PTE_W may or may not be set, PTE_U | PTE_PÊùÉÈôêÂøÖÈ°ªËÆæÁΩÆ PTE_AVAIL | PTE_W ÂèØ‰ª•‰∏çËÆæÁΩÆ// but no other bits may be set. See PTE_SYSCALL in inc/mmu.h.// ÂÖ∂‰ªñÊùÉÈôê PTE_SYSCALL ‰πüËÆ∏ÂèØ‰ª•Ë¢´ËÆæÁΩÆÔºåÊÑèÂë≥ÁùÄË∂ÖËøáËøô‰∏™ÊùÉÈôêÈÉΩÊòØÈîôÁöÑ„ÄÇ// Return 0 on success, &lt; 0 on error. Errors are: Â§±Ë¥•ËøîÂõû Ë¥üÊï∞// -E_BAD_ENV if environment envid doesn't currently exist,// or the caller doesn't have permission to change envid.//ÁéØÂ¢ÉidÈîôËØØ// -E_INVAL if va &gt;= UTOP, or va is not page-aligned.//Âú∞ÂùÄ‰∏çÂú®Áî®Êà∑Áä∂ÊÄÅÊàñËÄÖ‰∏çÊòØÈ°µÂØπÈΩê// -E_INVAL if perm is inappropriate (see above). ÊùÉÈôêÈîôËØØ// -E_NO_MEM if there's no memory to allocate the new page,//Ê≤°ÊúâÂÜÖÂ≠ò‰∫Ü// or to allocate any necessary page tables.static intsys_page_alloc(envid_t envid, void *va, int perm)&#123; // Hint: This function is a wrapper around page_alloc() and // page_insert() from kern/pmap.c. ÂèØ‰ª•‰ΩøÁî®page_allocÂíåpage_insert // Most of the new code you write should be to check the // parameters for correctness. // If page_insert() fails, remember to free the page you // allocated!//Â¶ÇÊûúÊèíÂÖ•Â§±Ë¥•ËÆ∞ÂæóÈáäÊîæÂÜÖÂ≠ò // LAB 4: Your code here. ÂêéÈù¢Â∞±ÁÖßÁùÄÊèêÁ§∫‰∏Ä‰∏™‰∏™Âà§Êñ≠Â∞±Ë°å‰∫Ü struct Env * env; if(envid2env(envid,&amp;env,1)&lt;0)return -E_BAD_ENV;//Âà§Êñ≠ËøõÁ®ã if((uintptr_t)va&gt;=UTOP||PGOFF(va))return -E_INVAL;//Âà§Êñ≠Âú∞ÂùÄ int flag=PTE_U | PTE_P; if((perm &amp; ~(PTE_SYSCALL))!=0||(perm&amp;flag)!=flag)return -E_INVAL;//Âà§Êñ≠ÊùÉÈôê struct PageInfo* pi=page_alloc(1);//ÂàÜÈÖç‰∏Ä‰∏™È°µ if(pi==NULL)return -E_NO_MEM; if(page_insert(env-&gt;env_pgdir,pi,va,perm)&lt;0)&#123;//Êò†Â∞Ñ‰∏äÂéª page_free(pi); return -E_NO_MEM; &#125; return 0; //panic("sys_page_alloc not implemented");&#125;// Map the page of memory at 'srcva' in srcenvid's address space// at 'dstva' in dstenvid's address space with permission 'perm'.// Perm has the same restrictions as in sys_page_alloc, except// that it also must not grant write access to a read-only// page.//Ëøô‰∏™ÊòØÊää Ê∫ê ËôöÊãüÂú∞ÂùÄÊò†Â∞ÑÂà∞ ÁõÆÁöÑ ËôöÊãüÂú∞ÂùÄ // Return 0 on success, &lt; 0 on error. Errors are://‰∏ÄÂ†ÜÈîôËØØÊèêÁ§∫// -E_BAD_ENV if srcenvid and/or dstenvid doesn't currently exist,// or the caller doesn't have permission to change one of them.// -E_INVAL if srcva &gt;= UTOP or srcva is not page-aligned,// or dstva &gt;= UTOP or dstva is not page-aligned.// -E_INVAL is srcva is not mapped in srcenvid's address space.// -E_INVAL if perm is inappropriate (see sys_page_alloc).// -E_INVAL if (perm &amp; PTE_W), but srcva is read-only in srcenvid's// address space.// -E_NO_MEM if there's no memory to allocate any necessary page tables.static intsys_page_map(envid_t srcenvid, void *srcva, envid_t dstenvid, void *dstva, int perm)&#123; // Hint: This function is a wrapper around page_lookup() and // page_insert() from kern/pmap.c. // Again, most of the new code you write should be to check the // parameters for correctness. // Use the third argument to page_lookup() to // check the current permissions on the page. // LAB 4: Your code here. int r=0; struct Env * srccur=NULL,*dstcur=NULL; r=envid2env(srcenvid,&amp;srccur,1); if(r&lt;0)return -E_BAD_ENV; r=envid2env(dstenvid,&amp;dstcur,1);//Âà§Êñ≠‰∏§‰∏™ËøõÁ®ã if(r&lt;0)return -E_BAD_ENV; if((uintptr_t)srcva &gt;= UTOP||(uintptr_t)dstva &gt;= UTOP||PGOFF(srcva)|| PGOFF(dstva))return -E_INVAL;//Âà§Êñ≠È°µÂú∞ÂùÄÂíåÁõÆÁöÑÂú∞ÂùÄ pte_t * store=NULL; struct PageInfo* pg=NULL; if((pg=page_lookup(srccur-&gt;env_pgdir,srcva,&amp;store))==NULL)return -E_INVAL;//Êü•Áúã‰∏Ä‰∏™È°µ int flag=PTE_U | PTE_P; if((perm &amp; ~(PTE_SYSCALL))!=0||(perm&amp;flag)!=flag)return -E_INVAL; if((perm&amp;PTE_W)&amp;&amp;!(*store&amp;PTE_W))return E_INVAL;//Âà§Êñ≠ÊùÉÈôê if (page_insert(dstcur-&gt;env_pgdir, pg, dstva, perm) &lt; 0) //ÊèíÂÖ•Âà∞‰∏Ä‰∏™È°µ return -E_NO_MEM; return 0; //panic("sys_page_map not implemented");&#125;// Unmap the page of memory at 'va' in the address space of 'envid'.// If no page is mapped, the function silently succeeds.//ÂèñÊ∂à‰∏Ä‰∏™ËøõÁ®ã ÂØπva ÁöÑÊò†Â∞Ñ„ÄÇ// Return 0 on success, &lt; 0 on error. Errors are:// -E_BAD_ENV if environment envid doesn't currently exist,// or the caller doesn't have permission to change envid.// -E_INVAL if va &gt;= UTOP, or va is not page-aligned.static intsys_page_unmap(envid_t envid, void *va)&#123; // Hint: This function is a wrapper around page_remove(). // LAB 4: Your code here. struct Env *env; int r=envid2env(envid,&amp;env,1); if(r&lt;0)return -E_BAD_ENV; if((uintptr_t)va&gt;=UTOP||PGOFF(va))return -E_INVAL; page_remove(env-&gt;env_pgdir,va); return 0; //panic("sys_page_unmap not implemented");&#125; ÁÑ∂ÂêéÂ∞±ÂèØ‰ª•ËøêË°å‰∫Ü„ÄÇÊúÄÂêé‰∏çË¶ÅÂøòËÆ∞Êää‰ªñÂ°´Âà∞syscallÈáåÈù¢„ÄÇ12345678910case SYS_exofork: return sys_exofork();case SYS_env_set_status: return sys_env_set_status((envid_t)a1, (int)a2);case SYS_page_alloc: return sys_page_alloc((envid_t)a1, (void *)a2, (int)a3); case SYS_page_map: return sys_page_map((envid_t)a1, (void *)a2, (envid_t)a3, (void *)a4, (int)a5); case SYS_page_unmap: return sys_page_unmap((envid_t)a1, (void *)a2); ÁÑ∂ÂêéÂ∞±ÂÆåÊàê‰∫ÜPART A‰∫Ü„ÄÇ Part B: Copy-on-Write ForkÂÜôÊó∂Â§çÂà∂ÔºåÂØπ‰∫éËøô‰∏™Êú∫Âà∂Â∫îËØ•ÈÉΩÂæàÊ∏ÖÊ•ö„ÄÇÂ§ßÈÉ®ÂàÜÁ®ãÂ∫èfork‰πãÂêéÂ∞±Ë∞ÉÁî®‰∫ÜexecÊâÄ‰ª•ÔºåÊàëÈó®ÔºåÂπ∂Ê≤°ÊúâÂ§çÂà∂ÂÜÖÂ≠òÔºå‰πüÂ∞±ÊòØÂ∞ë‰∫ÜdumbforkÈáåÈù¢ÁöÑmemmove(UTEMP, addr, PGSIZE);„ÄÇ‰ΩÜÊòØËøôÊ†∑ÂÅöÂ∞±Êúâ‰∫Ü‰∏™Áº∫Èô∑ÔºåÂ¶ÇÊûúÊ≤°ÊúâË∞ÉÁî®execÔºåÂ≠êËøõÁ®ãÂèàËÆøÈóÆ‰∫ÜÂ∞±Ë¶ÅËøõË°åÁº∫È°µ‰∏≠Êñ≠„ÄÇÊâÄ‰ª•ËøôÊ¨°ÊàëÊàë‰ª¨ÁöÑ‰ªªÂä°Â∞±ÊòØÂÆûÁé∞Ëøô‰∫õ‰∏úË•ø„ÄÇ User-level page fault handling‰∏Ä‰∏™Áî®Êà∑Á∫ßÂÜôÊó∂Êã∑Ë¥ùÁöÑforkÂáΩÊï∞ÈúÄË¶ÅÁü•ÈÅìÂì™‰∫õpage faultÊòØÂú®ÂÜô‰øùÊä§È°µÊó∂Ëß¶ÂèëÁöÑÔºåÂÜôÊó∂Â§çÂà∂Âè™ÊòØÁî®Êà∑Á∫ßÁº∫È°µ‰∏≠Êñ≠Â§ÑÁêÜÁöÑ‰∏ÄÁßç„ÄÇÈÄöÂ∏∏Âª∫Á´ãÂú∞ÂùÄÁ©∫Èó¥‰ª•‰æøpage faultÊèêÁ§∫‰ΩïÊó∂ÈúÄË¶ÅÊâßË°åÊüê‰∫õÊìç‰Ωú„ÄÇ‰æãÂ¶ÇÂ§ßÂ§öÊï∞UnixÂÜÖÊ†∏ÂàùÂßãÂè™ÁªôÊñ∞ËøõÁ®ãÁöÑÊ†àÊò†Â∞Ñ‰∏Ä‰∏™È°µÔºå‰ª•ÂêéÊ†àÂ¢ûÈïø‰ºöÂØºËá¥page fault‰ªéËÄåÊò†Â∞ÑÊñ∞ÁöÑÈ°µ„ÄÇ‰∏Ä‰∏™ÂÖ∏ÂûãÁöÑUnixÂÜÖÊ†∏ÂøÖÈ°ªËÆ∞ÂΩïÂú®ËøõÁ®ãÂú∞ÂùÄÁ©∫Èó¥ÁöÑ‰∏çÂêåÂå∫ÂüüÂèëÁîüpage faultÊó∂ÔºåÂ∫îËØ•ÊâßË°å‰ªÄ‰πàÊìç‰Ωú„ÄÇ‰æãÂ¶ÇÊ†à‰∏äÁº∫È°µÔºå‰ºöÂÆûÈôÖÂàÜÈÖçÂíåÊò†Â∞ÑÊñ∞ÁöÑÁâ©ÁêÜÂÜÖÂ≠ò„ÄÇBSSÂå∫ÂüüÁº∫È°µ‰ºöÂàÜÈÖçÊñ∞ÁöÑÁâ©ÁêÜÈ°µÔºåÂ°´ÂÖÖ0ÔºåÁÑ∂ÂêéÊò†Â∞Ñ„ÄÇËøôÁßçËÆæËÆ°Âú®ÂÆö‰πâ‰ªñ‰ª¨ÁöÑÂÜÖÂ≠òÂå∫ÂüüÁöÑÊó∂ÂÄôÂÖ∑ÊúâÊûÅÂ§ßÁöÑÁÅµÊ¥ªÂ∫¶„ÄÇ Setting the Page Fault Handler‰∏∫‰∫ÜÂ§ÑÁêÜËá™Â∑±ÁöÑÁº∫È°µ‰∏≠Êñ≠ÔºåÁî®Êà∑ÁéØÂ¢ÉÈúÄË¶ÅÂú®JOSÂÜÖÊ†∏‰∏≠Ê≥®ÂÜåÁº∫È°µ‰∏≠Êñ≠Â§ÑÁêÜÁ®ãÂ∫èÁöÑÂÖ•Âè£„ÄÇÁî®Êà∑ÁéØÂ¢ÉÈÄöËøásys_env_set_pgfault_upcallÁ≥ªÁªüË∞ÉÁî®Ê≥®ÂÜåÂÆÉÁöÑÁº∫È°µ‰∏≠Êñ≠ÂÖ•Âè£„ÄÇÊàë‰ª¨Âú®EnvÁªìÊûÑ‰Ωì‰∏≠Â¢ûÂä†‰∫Ü‰∏Ä‰∏™Êñ∞ÊàêÂëòenv_pgfault_upcallÊù•ËÆ∞ÂΩïËøô‰∏Ä‰ø°ÊÅØ„ÄÇÁªÉ‰π†8Â∞±ÊòØËÆ©‰Ω†ÂÆûÁé∞Áº∫È°µ‰∏≠Êñ≠ÁöÑÂÖ•Âè£ÔºåÂ∞±ÊòØ‰Ω†Áî®ÂÜôÊó∂Â§çÂà∂ÔºåÂ¶ÇÊûú‰øÆÊîπ‰∫ÜËØ•ÊÄé‰πàÂ§ÑÁêÜÔºåË∞ÉÁî®Âì™‰∏™Á®ãÂ∫èÂéªÂ§ÑÁêÜ„ÄÇÊàë‰ª¨ÈúÄË¶ÅÂéªÂÆûÁé∞Ëøô‰∏™sys_env_set_pgfault_upcall„ÄÇ12345678910111213141516171819// Set the page fault upcall for 'envid' by modifying the corresponding struct// Env's 'env_pgfault_upcall' field. When 'envid' causes a page fault, the// kernel will push a fault record onto the exception stack, then branch to// 'func'.//ÂèÇÊï∞‰º†ËøõÂéª‰∏Ä‰∏™ÂáΩÊï∞ÊåáÈíàÔºåÁõ¥Êé•ÊääÂ§ÑÁêÜÁº∫È°µ‰∏≠Êñ≠ÁöÑÂèòÈáèÊåáÂêëÂ∞±ÂèØ‰ª•‰∫Ü// Returns 0 on success, &lt; 0 on error. Errors are:// -E_BAD_ENV if environment envid doesn't currently exist,// or the caller doesn't have permission to change envid.static intsys_env_set_pgfault_upcall(envid_t envid, void *func)&#123; // LAB 4: Your code here. struct Env * env; if(envid2env(envid,&amp;env,1)&lt;0)return -E_BAD_ENV;//ÂÖàÂà§Êñ≠ËøõÁ®ãÂèØ‰∏çÂèØ‰ª•Áî® env-&gt;env_pgfault_upcall=func;//ÊÑèÊÄùÂ∞±ÊòØÂ§ÑÁêÜ‰∏≠Êñ≠ÁöÑÊó∂ÂÄôÁî®func Ëøô‰∏™ÂáΩÊï∞„ÄÇ return 0; //panic("sys_env_set_pgfault_upcall not implemented");&#125; ÂçÉ‰∏áÂà´ÂøòËÆ∞ÊääËøô‰∏™Ê∑ªËøõsyscallÔºåÊàëËøô‰∏™Âú∞ÊñπÂøòËÆ∞Ê∑ªÂä†‰∫ÜÔºåÊâæ‰∫ÜÂçäÂ§©‰∏çÁü•ÈÅì‰∏∫Âï•„ÄÇ12case SYS_env_set_pgfault_upcall: return sys_env_set_pgfault_upcall(a1,(void *)a2); Normal and Exception Stacks in User EnvironmentsÂú®Ê≠£Â∏∏ËøêË°åÊúüÈó¥ÔºåÁî®Êà∑ËøõÁ®ãËøêË°åÂú®Áî®Êà∑Ê†à‰∏äÔºåÂºÄÂßãËøêË°åÊó∂Ê†àÈ°∂ÂØÑÂ≠òÂô®ESPÊåáÂêëUSTACKTOPÔºåÂéãÂÖ•Â†ÜÊ†àÁöÑÊï∞ÊçÆ‰Ωç‰∫é[USTACKTOP-PGSIZE ~ USTACKTOP-1]‰πãÈó¥ÁöÑÈ°µ„ÄÇÂΩì‰∏Ä‰∏™È°µÈîôËØØÂá∫Áé∞Âú®Áî®Êà∑Ê®°Âºè‰∏ãÔºåÂÜÖÊ†∏ÈáçÂêØÁî®Êà∑ÁéØÂ¢ÉËÆ©ÂÖ∂Âú®Áî®Êà∑ÂºÇÂ∏∏Ê†à‰∏äËøêË°åÊåáÂÆöÁöÑÁî®Êà∑Á∫ßÁº∫È°µÂ§ÑÁêÜÁ®ãÂ∫è„ÄÇÊàë‰ª¨Â∞Ü‰ΩøJOS‰ª£ÊõøÁî®Êà∑ÁéØÂ¢ÉÂÆûÁé∞Ëá™Âä®ÁöÑ‚ÄúÊ†àÂàáÊç¢‚ÄùÔºåÂ∞±Â¶ÇÂêåx86Â§ÑÁêÜÂô®‰ª£ÊõøJOSÂÜÖÊ†∏ÂÆûÁé∞‰ªéÁî®Êà∑Ê®°ÂºèÂà∞ÂÜÖÊ†∏Ê®°ÂºèÁöÑÊ†àÂàáÊç¢„ÄÇ JOSÁöÑÁî®Êà∑ÂºÇÂ∏∏Ê†àÁöÑÂ§ßÂ∞è‰∏∫‰∏Ä‰∏™È°µÔºåÂàùÂßãÊ†àÈ°∂ÂÆö‰πâÂú®UXSTACKTOP„ÄÇÂõ†Ê≠§ÊúâÊïàÁöÑÁî®Êà∑ÂºÇÂ∏∏Ê†àÁöÑÂå∫Èó¥ÊòØ[UXSTACKTOP-PGSIZE ~ UXSTACKTOP-1]„ÄÇËøêË°åÂú®ÂºÇÂ∏∏Ê†à‰∏äÁöÑÁî®Êà∑Á∫ßÁöÑÈ°µÈîôËØØÂ§ÑÁêÜÁ®ãÂ∫èÂèØ‰ª•‰ΩøÁî®JOSÁöÑÂ∏∏ËßÑÁöÑÁ≥ªÁªüË∞ÉÁî®ÔºåÊù•Êò†Â∞ÑÊñ∞ÁöÑÈ°µÊàñËÄÖË∞ÉÊï¥Êò†Â∞ÑÔºåÊù•‰øÆÂ§çÂØºËá¥È°µÈîôËØØÁöÑÈóÆÈ¢ò„ÄÇÁÑ∂ÂêéÁî®Êà∑Á∫ßÂà´È°µÈîôËØØÂ§ÑÁêÜÁ®ãÂ∫èÈÄöËøá‰∏Ä‰∏™Ê±áÁºñËØ≠Ë®ÄstubËøîÂõûÂà∞ÂéüÂßãÊ†àÁöÑÈîôËØØ‰ª£Á†ÅÂ§Ñ„ÄÇ ÊØè‰∏Ä‰∏™ÊÉ≥Ë¶ÅÊîØÊåÅÁî®Êà∑Á∫ßÂà´È°µÈîôËØØÂ§ÑÁêÜÁöÑÁî®Êà∑ÁéØÂ¢ÉÈÉΩÈúÄË¶Å‰∏∫Ëá™Â∑±ÁöÑÂºÇÂ∏∏Ê†àÂàÜÈÖçÂÜÖÂ≠òÔºåËøôÂ∞±Áî®Âà∞‰∫ÜÂú®part A‰∏≠ÂºïÂÖ•ÁöÑsys_page_alloc()Á≥ªÁªüË∞ÉÁî®ÂáΩÊï∞„ÄÇËøô‰∏™Êó∂ÂÄôÊàë‰ª¨Â∞±ÈúÄË¶Å‰∏Ä‰∏™Êñ∞ÁöÑÊ†àÔºåÂè´ÂÅöÁî®Êà∑ÂºÇÂ∏∏Ê†à„ÄÇ Invoking the User Page Fault HandlerÊàë‰ª¨Áé∞Âú®ÈúÄË¶Å‰øÆÊîπkern/trap.cÈáåÈù¢ÁöÑÁî®Êà∑Ê®°ÂºèÁöÑÁº∫È°µÈîôËØØÔºåÂõ†‰∏∫Áé∞Âú®Êàë‰ª¨Êúâ‰∫ÜÁî®Êà∑ÁöÑÁº∫È°µÂ§ÑÁêÜÂáΩÊï∞„ÄÇÁé∞Âú®Êàë‰ª¨Â¶ÇÊûúËÆæÁΩÆ‰∫ÜÔºåÁº∫È°µÂ§ÑÁêÜÂáΩÊï∞ÔºåÂ∞±Ë∞ÉÁî®Áº∫È°µÂ§ÑÁêÜÂáΩÊï∞ÔºåÊ≤°ÊúâÊàë‰ª¨Â∞±ÈîÄÊØÅËøô‰∏™ËøõÁ®ã„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283voidpage_fault_handler(struct Trapframe *tf)&#123; uint32_t fault_va; // Read processor's CR2 register to find the faulting address fault_va = rcr2(); // Handle kernel-mode page faults. // LAB 3: Your code here. if(tf-&gt;tf_cs &amp;&amp; 0x01 == 0) &#123; panic("page_fault in kernel mode, fault address %d\n", fault_va); &#125; // We've already handled kernel-mode exceptions, so if we get here, // the page fault happened in user mode. // Call the environment's page fault upcall, if one exists. Set up a // page fault stack frame on the user exception stack (below // UXSTACKTOP), then branch to curenv-&gt;env_pgfault_upcall. // Âª∫Á´ã‰∏Ä‰∏™Áî®Êà∑ÂºÇÂ∏∏Ê†à Âú® UXSTACKTOP ÁÑ∂ÂêéË∑≥ËΩ¨Âà∞ curenv-&gt;env_pgfault_upcall ËøêË°å // The page fault upcall might cause another page fault, in which case // we branch to the page fault upcall recursively, pushing another // page fault stack frame on top of the user exception stack. // ÂèØËÉΩÂá∫Áé∞Â§öÁ∫ß‰∏≠Êñ≠ // It is convenient for our code which returns from a page fault // (lib/pfentry.S) to have one word of scratch space at the top of the // trap-time stack; it allows us to more easily restore the eip/esp. In // the non-recursive case, we don't have to worry about this because // the top of the regular user stack is free. In the recursive case, // this means we have to leave an extra word between the current top of // the exception stack and the new stack frame because the exception // stack _is_ the trap-time stack. // // If there's no page fault upcall, the environment didn't allocate a // page for its exception stack or can't write to it, or the exception // stack overflows, then destroy the environment that caused the fault. // Note that the grade script assumes you will first check for the page // fault upcall and print the "user fault va" message below if there is // none. The remaining three checks can be combined into a single test. // // Hints: // user_mem_assert() and env_run() are useful here. // To change what the user environment runs, modify 'curenv-&gt;env_tf' // (the 'tf' variable points at 'curenv-&gt;env_tf'). // LAB 4: Your code here. struct UTrapframe *utf; if (curenv-&gt;env_pgfault_upcall) &#123; //Â¶ÇÊûúÂ∑≤ÁªèÊúâ‰∫ÜÂºÇÂ∏∏Ê†àÔºåÊàë‰ª¨Â∞±Áõ¥Êé•Âú®ÂêéÈù¢Ê∑ªÂä†‰∏Ä‰∏™UTrapframeÔºåÂê¶ÂàôÂ∞±ÂÖàÊääË∑≥Âà∞ÂºÇÂ∏∏Ê†à„ÄÇ ËøôÊòØ‰∏∫‰∫ÜÂ§ÑÁêÜÂ§öÁ∫ß‰∏≠Êñ≠ if (tf-&gt;tf_esp &gt;= UXSTACKTOP-PGSIZE &amp;&amp; tf-&gt;tf_esp &lt; UXSTACKTOP) &#123; // ÂºÇÂ∏∏Ê®°Âºè‰∏ãÈô∑ÂÖ• utf = (struct UTrapframe *)(tf-&gt;tf_esp - sizeof(struct UTrapframe) - 4); &#125; else &#123; // ÈùûÂºÇÂ∏∏Ê®°Âºè‰∏ãÈô∑ÂÖ• utf = (struct UTrapframe *)(UXSTACKTOP - sizeof(struct UTrapframe)); &#125; // Ê£ÄÊü•ÂºÇÂ∏∏Ê†àÊòØÂê¶Ê∫¢Âá∫ user_mem_assert(curenv, (const void *) utf, sizeof(struct UTrapframe), PTE_P|PTE_W); utf-&gt;utf_fault_va = fault_va; utf-&gt;utf_err = tf-&gt;tf_trapno; utf-&gt;utf_regs = tf-&gt;tf_regs; utf-&gt;utf_eflags = tf-&gt;tf_eflags; // ‰øùÂ≠òÈô∑ÂÖ•Êó∂Áé∞Âú∫ÔºåÁî®‰∫éËøîÂõû utf-&gt;utf_eip = tf-&gt;tf_eip; utf-&gt;utf_esp = tf-&gt;tf_esp; // ÂÜçÊ¨°ËΩ¨ÂêëÊâßË°å curenv-&gt;env_tf.tf_eip = (uint32_t) curenv-&gt;env_pgfault_upcall; // ÂºÇÂ∏∏Ê†à curenv-&gt;env_tf.tf_esp = (uint32_t) utf; env_run(curenv); &#125; else &#123; // Destroy the environment that caused the fault. Ê≤°ÊúâÂÆö‰πâÂ∞±Áõ¥Êé•ÈîÄÊØÅ cprintf("[%08x] user fault va %08x ip %08x\n", curenv-&gt;env_id, fault_va, tf-&gt;tf_eip); print_trapframe(tf); env_destroy(curenv); &#125;&#125; User-mode Page Fault EntrypointÊé•‰∏ãÊù•ÔºåÂ∞±ÈúÄË¶ÅÂÆûÁé∞Ê±áÁºñ‰æãÁ®ãË¥üË¥£Ë∞ÉÁî®CÁöÑÁº∫È°µÂºÇÂ∏∏Â§ÑÁêÜÁ®ãÂ∫èÂπ∂ÊÅ¢Â§çÊâßË°åÂéüÊù•Âá∫ÈîôÁöÑÊåá‰ª§„ÄÇËøô‰∏™Ê±áÁºñ‰æãÁ®ãÔºàlib/pfentry.S‰∏≠ÁöÑ_pgfault_upcallÔºâÂ∞±ÊòØÈúÄË¶Å‰ΩøÁî®sys_env_set_pgfault_upcall()Á≥ªÁªüË∞ÉÁî®Ê≥®ÂÜåÂà∞ÂÜÖÊ†∏ÁöÑÂ§ÑÁêÜÁ®ãÂ∫è„ÄÇËøô‰∏™ÁªÉ‰π†ÊàëÊ≤°ÁúãÊáÇ„ÄÇÊâÄ‰ª•ÊàëÂ∞±Áõ¥Êé• Ë¥¥Âà´‰∫∫ÁöÑ‰ª£Á†Å‰∫Ü12345678910111213141516 // Struct PushRegs size = 32 addl $8, %esp // esp+8 -&gt; PushRegs over utf_fault_va utf_errmovl 0x20(%esp), %eax // eax = (esp+0x20 -&gt; utf_eip )subl $4, 0x28(%esp) // for trap time eip ‰øùÁïô32bit, esp+48 = utf_espmovl 0x28(%esp), %edx // %edx = utf_esp-4 movl %eax, (%edx) // %eax = eip ----&gt; esp-4 ‰ª•Ëá≥‰∫éretÂèØ‰ª•Áõ¥Êé•ËØªÂèñÂÖ∂ÁªßÁª≠ÊâßË°åÁöÑÂú∞ÂùÄpopal // after popal esp-&gt;utf_eipaddl $4, %esp // esp+4 -&gt; utf_eflagspopflpopl %espret // ËøôÈáåÂçÅÂàÜÂ∑ßÂ¶ôÔºå ret‰ºöËØªÂèñespÊåáÂêëÁöÑÁ¨¨‰∏Ä‰∏™ÂÜÖÂÆπÔºå ‰πüÂ∞±ÊòØÊàë‰ª¨Á¨¨‰∏ÄÊ≠•ÂÜôÂÖ•ÁöÑeip ÁªÉ‰π†11 Â∞±ÊòØËÆ©‰Ω†ÂÆûÁé∞lib/pgfault.c.ÈáåÈù¢ÁöÑset_pgfault_handler„ÄÇ 123456789101112131415161718192021222324//// Set the page fault handler function. ËÆæÁΩÆÈÇ£‰∏™Áº∫È°µÂ§ÑÁêÜ// If there isn't one yet, _pgfault_handler will be 0.// The first time we register a handler, we need to// allocate an exception stack (one page of memory with its top// at UXSTACKTOP), and tell the kernel to call the assembly-language// _pgfault_upcall routine when a page fault occurs. Â¶ÇÊûúÊòØÁ¨¨‰∏ÄÊ¨°ÂàÜÈÖçÈ°µÊàë‰ª¨ÈúÄË¶ÅÂàÜÈÖç‰∏Ä‰∏™ÂºÇÂ∏∏Ê†à„ÄÇ//voidset_pgfault_handler(void (*handler)(struct UTrapframe *utf))&#123; int r; if (_pgfault_handler == 0) &#123; // First time through! // LAB 4: Your code here. if ((r = sys_page_alloc(thisenv-&gt;env_id, (void *)(UXSTACKTOP - PGSIZE), PTE_P | PTE_W | PTE_U)) &lt; 0) panic("set_pgfault_handler: %e", r); sys_env_set_pgfault_upcall(thisenv-&gt;env_id, _pgfault_upcall); &#125; // Save handler pointer for assembly to call. _pgfault_handler = handler;&#125; Implementing Copy-on-Write ForkÊúÄÂêéÂ∞±ÊòØÂÆûÁé∞ÂÜôÊó∂Â§çÂà∂‰∫Ü„ÄÇÂâçÈù¢Êàë‰ª¨Êúâ‰∏Ä‰∏™ÊµãËØïÁ®ãÂ∫èÔºåuser/dumbforkÔºåËøô‰∏™ÈáåÈù¢Â∑≤ÁªèÊúâ‰∫ÜÊ®°ÊùøÔºåÊàë‰ª¨Áé∞Âú®Ë¶ÅÂÅöÁöÑÂ∞±ÊòØÂÆûÁé∞‰∏Ä‰∏™Â∑Æ‰∏çÂ§öÁöÑfork„ÄÇ‰ªñÁöÑÂü∫Êú¨ÊµÅÁ®ãÊòØÔºö Áà∂ËøõÁ®ãÂ∞Üpgfault()ÂáΩÊï∞‰Ωú‰∏∫CËØ≠Ë®ÄÂÆûÁé∞ÁöÑÈ°µÈîôËØØÂ§ÑÁêÜÔºå‰ºöÁî®Âà∞‰∏äÈù¢ÁöÑÂÆûÁé∞ÁöÑset_pgfault_handler()ÂáΩÊï∞ËøõË°åËÆæÁΩÆ„ÄÇÁà∂ËøõÁ®ãË∞ÉÁî®sys_exofork()ÂàõÂª∫‰∏Ä‰∏™Â≠êËøõÁ®ãÁéØÂ¢É„ÄÇ Âú®UTOP‰πã‰∏ãÁöÑÂú®Âú∞ÂùÄÁ©∫Èó¥ÈáåÁöÑÊØè‰∏Ä‰∏™ÂèØÂÜôÊàñcopy-on-writeÁöÑÈ°µÔºåÁà∂ËøõÁ®ãÂ∞±‰ºöË∞ÉÁî®duppageÔºåÂÆÉ‰ºöÂ∞Ücopy-on-writeÈ°µÊò†Â∞ÑÂà∞Â≠êËøõÁ®ãÁöÑÂú∞ÂùÄÁ©∫Èó¥ÔºåÁÑ∂ÂêéÈáçÊñ∞Êò†Â∞Ñcopy-on-writeÈ°µÂà∞Ëá™Â∑±ÁöÑÂú∞ÂùÄÁ©∫Èó¥„ÄÇ[Ê≥®ÊÑèËøôÈáåÁöÑÈ°∫Â∫èÂçÅÂàÜÈáçË¶ÅÔºÅÂÖàÂ∞ÜÂ≠êËøõÁ®ãÁöÑÈ°µÊ†áËÆ∞‰∏∫COWÔºåÁÑ∂ÂêéÂ∞ÜÁà∂ËøõÁ®ãÁöÑÈ°µÊ†áËÆ∞‰∏∫COW„ÄÇÁü•ÈÅì‰∏∫‰ªÄ‰πàÂêóÔºü‰Ω†ÂèØ‰ª•Â∞ùËØïÊÄùËÄÉÂ∞ÜËØ•È°∫Â∫èÂºÑÂèç‰ºöÊòØÈÄ†ÊàêÊÄéÊ†∑ÁöÑÈ∫ªÁÉ¶]„ÄÇduppageÂ∞ÜCOWÁöÑÈ°µÁöÑPTEsËÆæÁΩÆ‰∏∫‰∏çËÉΩÂÜôÁöÑÔºåÁÑ∂ÂêéÂú®PTEÁöÑavailÂüüËÆæÁΩÆPTE_COWÊù•Âå∫Âà´ copy-on-write pagesÂèäÁúüÊ≠£ÁöÑÂè™ËØªÈ°µ ÂºÇÂ∏∏Ê†àÂπ∂‰∏çÊòØÂ¶Ç‰∏äÈáçÊñ∞Êò†Â∞ÑÔºåÂú®Â≠êËøõÁ®ã‰∏≠ÈúÄË¶Å‰∏∫ÂºÇÂ∏∏Ê†àÂàÜÈÖç‰∏Ä‰∏™Êñ∞ÁöÑÈ°µ„ÄÇÁî±‰∫éÁº∫È°µÂºÇÂ∏∏Â§ÑÁêÜÁ®ãÂ∫èÂ∞ÜÊâßË°åÂÆûÈôÖÁöÑÊã∑Ë¥ù,ËÄå‰∏îÁº∫È°µÂºÇÂ∏∏Â§ÑÁêÜÁ®ãÂ∫èÂú®ÂºÇÂ∏∏Ê†à‰∏äËøêË°å,ÂºÇÂ∏∏Ê†à‰∏çÂ∫îËØ•Ë¢´ËÆæÁΩÆ‰∏∫cow„ÄÇfork()ÂêåÊ†∑Ë¶ÅËß£ÂÜ≥Âú®ÂÜÖÂ≠ò‰∏≠ÁöÑÈ°µÔºå‰ΩÜÈ°µÊó¢‰∏çÂèØÂÜô‰πü‰∏çÊòØcopy-on-write„ÄÇ Áà∂ËøõÁ®ã‰∏∫Â≠êËøõÁ®ãËÆæÁΩÆÁî®Êà∑È°µÈîôËØØÂÖ•Âè£„ÄÇ Â≠êËøõÁ®ãÁé∞Âú®ÂèØ‰ª•ËøêË°åÔºåÁÑ∂ÂêéÁà∂ËøõÁ®ãÂ∞ÜÂÖ∂Ê†áËÆ∞‰∏∫ÂèØËøêË°å„ÄÇ ÊØèÊ¨°Ëøô‰∏§ËøõÁ®ã‰∏≠ÁöÑ‰∏Ä‰∏™Âêë‰∏Ä‰∏™Â∞öÊú™ÂÜôËøáÁöÑcopy-on-writeÈ°µÂÜôÊó∂ÔºåÂ∞±‰ºö‰∫ßÁîü‰∏Ä‰∏™È°µÈîôËØØ„ÄÇ‰∏ãÈù¢ÊòØÁî®Êà∑È°µÈîôËØØÂ§ÑÁêÜÁöÑÊéßÂà∂ÊµÅÔºö ÂÜÖÊ†∏‰º†Êí≠È°µÈîôËØØÂà∞_pgfault_upcallÔºåË∞ÉÁî®fork()ÁöÑpgfault()Â§ÑÁêÜÊµÅÁ®ã„ÄÇ pgfault()Ê£ÄÊü•ÈîôËØØ‰ª£Á†Å‰∏≠ÁöÑFEC_WRÔºàÂç≥ÊòØÂÜôÂØºËá¥ÁöÑÔºâÔºå‰ª•ÂèäÈ°µÂØπÂ∫îÁöÑPTEÊ†áËÆ∞‰∏∫PTE_COW„ÄÇÊ≤°ÊúâÁöÑËØùÔºåpanic„ÄÇ pgfault()ÂàÜÈÖç‰∏Ä‰∏™Êò†Â∞ÑÂú®‰∏Ä‰∏™‰∏¥Êó∂‰ΩçÁΩÆÁöÑÊñ∞ÁöÑÈ°µÔºåÁÑ∂ÂêéÂ∞ÜÈîôËØØÈ°µ‰∏≠ÁöÑÂÜÖÂÆπÂ§çÂà∂ËøõÂéª„ÄÇÁÑ∂ÂêéÈ°µÈîôËØØÂ§ÑÁêÜÁ®ãÂ∫èÊò†Â∞ÑÊñ∞ÁöÑÈ°µÂà∞ÂºïËµ∑page faultÁöÑËôöÊãüÂú∞ÂùÄÔºåÂπ∂ËÆæÁΩÆPTEÂÖ∑ÊúâËØªÂÜôÊùÉÈôê„ÄÇ Áî®Êà∑Á∫ßÁöÑlib/fork.cÂøÖÈ°ªËÆøÈóÆÁî®Êà∑ÁéØÂ¢ÉÁöÑÈ°µË°®ÂÆåÊàê‰ª•‰∏äÁöÑÂá†‰∏™Êìç‰Ωú(‰æãÂ¶ÇÂ∞Ü‰∏Ä‰∏™È°µÂØπÂ∫îÁöÑPTEÊ†áËÆ∞‰∏∫PTE_COW)„ÄÇÂÜÖÊ†∏Êò†Â∞ÑÁî®Êà∑ÁéØÂ¢ÉÁöÑÈ°µË°®Âà∞ËôöÊãüÂú∞ÂùÄUVPTÁöÑÁî®ÊÑèÂ∞±Âú®‰∫éÊ≠§„ÄÇÂÆÉ‰ΩøÁî®‰∫Ü‰∏ÄÁßçËÅ™ÊòéÁöÑÊâãÊÆµËÆ©Áî®Êà∑‰ª£Á†ÅÂæàÊñπ‰æøÁöÑÊ£ÄÁ¥¢PTE„ÄÇlib/entry.SËÆæÁΩÆuvptÂíåuvpd‰ΩøÂæólib/fork.c‰∏≠ÁöÑÁî®Êà∑‰ª£Á†ÅËÉΩÂ§üËΩªÊùæÂú∞Ê£ÄÁ¥¢È°µË°®‰ø°ÊÅØ„ÄÇÁªÉ‰π†12Â∞±ÊòØËÆ©Êàë‰ª¨ÂÆûÁé∞fork.cÈáåÈù¢ÁöÑfork, duppage Âíå pgfault„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141// implement fork from user space#include &lt;inc/string.h&gt;#include &lt;inc/lib.h&gt;// PTE_COW marks copy-on-write page table entries.// It is one of the bits explicitly allocated to user processes (PTE_AVAIL).#define PTE_COW 0x800//// Custom page fault handler - if faulting page is copy-on-write,// map in our own private writable copy.// Áî®Êà∑Â§ÑÁêÜÁº∫È°µstatic voidpgfault(struct UTrapframe *utf)&#123; void *addr = (void *) utf-&gt;utf_fault_va; uint32_t err = utf-&gt;utf_err; int r; // Check that the faulting access was (1) a write, and (2) to a // copy-on-write page. If not, panic. // Hint: Ê£ÄÊü•ÊòØ‰∏çÊòØÂõ†‰∏∫Âõ†‰∏∫ÂÜôÂÖ•ÂØºËá¥ÁöÑÈîôËØØÔºå‰∏çÊòØÂ∞±paic // Use the read-only page table mappings at uvpt // (see &lt;inc/memlayout.h&gt;). uvpt Âíåuvpd Âú®memlayout Ëøô‰∏™ÈáåÈù¢ÊúâÂÆö‰πâÔºåÂæà‰πÖ‰πãÂâçÊàë‰ª¨Â∞±ÁúãËøá‰∫Ü„ÄÇ ‰∏Ä‰∏™È°µÁõÆÂΩï‰∏Ä‰∏™ÊòØÈ°µË°®ÁöÑ„ÄÇ // LAB 4: Your code here. if (!( (err &amp; FEC_WR) &amp;&amp; (uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_COW) )) panic("Neither the fault is a write nor copy-on-write page.\n");//Â¶ÇÊûú‰∏çÊòØÂõ†‰∏∫Ëøô‰∏™ÂéüÂõ† Â∞±panic // Allocate a new page, map it at a temporary location (PFTEMP), // copy the data from the old page to the new page, then move the new // page to the old page's address. // Hint: ÂàÜÈÖç‰∏Ä‰∏™È°µÈù¢Áªô‰ªñÔºåÁÑ∂ÂêéÂ§çÂà∂‰∏Ä‰ªΩÂ∞±ËøôÊ†∑ // You should make three system calls. // LAB 4: Your code here. if((r = sys_page_alloc(0, PFTEMP, PTE_U | PTE_P | PTE_W)) &lt; 0)&#123; panic("sys_page_alloc: %e\n", r);//ÂàÜÈÖç‰∫Ü‰∏Ä‰∏™È°µ &#125; addr = ROUNDDOWN(addr, PGSIZE);//È°µÂØπÈΩê memcpy((void *)PFTEMP, addr, PGSIZE);//ÊääËøô‰∏™ÂÜôÊó∂Â§çÂà∂ÁöÑÈ°µÂÜÖÂÆπÂ§çÂà∂‰∏ÄÈÅç if ((r = sys_page_map(0, (void *)PFTEMP, 0, addr, PTE_P | PTE_U | PTE_W)) &lt; 0) panic("sys_page_map: %e\n", r);//ÊääÂΩìÂâçÊò†Â∞ÑÁöÑ Âú∞ÂùÄ ÊåáÂêëPFTEMP Êñ∞ÂàÜÈÖçÁöÑÈ°µ if ((r = sys_page_unmap(0, (void *)PFTEMP)) &lt; 0) //ÂèñÊ∂àPFTEMP ÁöÑÊò†Â∞ÑÔºåËøôÊ†∑Â∞±ÊääËôöÊãüÂú∞ÂùÄÊåáÂêë‰∫Ü‰∏Ä‰∏™Êñ∞ÁöÑÈ°µ„ÄÇ panic("sys_page_unmap: %e\n", r); //panic("pgfault not implemented");&#125;//// Map our virtual page pn (address pn*PGSIZE) into the target envid// at the same virtual address. If the page is writable or copy-on-write,// the new mapping must be created copy-on-write, and then our mapping must be// marked copy-on-write as well. (Exercise: Why do we need to mark ours// copy-on-write again if it was already copy-on-write at the beginning of// this function?)//Êää Êàë‰ª¨ËôöÊãüÈ°µ pn*PGSIZEÊò†Â∞ÑÂà∞ Áõ∏ÂêåÁöÑËôöÊãüÂú∞ÂùÄÔºåÂ¶ÇÊûúÂéüÊú¨Â∞±ÊòØÂÜôÊó∂Â§çÂà∂ÈÇ£‰πàÊñ∞ÁöÑ‰πüË¶ÅÊ†áËÆ∞Êàê ÂÜôÊó∂Â§çÂà∂// Returns: 0 on success, &lt; 0 on error.// It is also OK to panic on error.//static intduppage(envid_t envid, unsigned pn)&#123; int r; // LAB 4: Your code here. void* vaddr=(void*)(pn*PGSIZE); if((uvpt[pn] &amp; PTE_W) || (uvpt[pn] &amp; PTE_COW))&#123; if ((r = sys_page_map(0, vaddr, envid, vaddr, PTE_P | PTE_U | PTE_COW)) &lt; 0) return r;//Êò†Â∞ÑÂΩìÂâçÈ°µ‰∏∫ÂÜôÊó∂Á¨¶Âêà if ((r = sys_page_map(0, vaddr, 0, vaddr, PTE_P | PTE_U | PTE_COW)) &lt; 0) return r;//ÊääËá™Â∑±ÂΩìÂâçÈ°µÈ°µÊ†áËÆ∞ÊàêÂÜôÊó∂Â§çÂà∂„ÄÇ &#125; else if((r = sys_page_map(0, vaddr, envid, vaddr, PTE_P | PTE_U)) &lt; 0) &#123; return r;//Â¶ÇÊûúÂΩìÂâçÈ°µÂ∑≤ÁªèÊòØÂÜôÊó∂Â§çÂà∂ Â∞±‰∏çÈúÄË¶ÅÊõ¥Êîπ‰∫Ü &#125; //panic("duppage not implemented"); return 0;&#125;//// User-level fork with copy-on-write. ÂÜôÊó∂Â§çÂà∂// Set up our page fault handler appropriately.ËÆæÁΩÆÁº∫È°µÂ§ÑÁêÜ// Create a child. ÂàõÂª∫‰∏Ä‰∏™ÂÑøÂ≠ê// Copy our address space and page fault handler setup to the child. Â§çÂà∂Á©∫Èó¥ÂíåËÆæÁΩÆÁº∫È°µÂ§ÑÁêÜ// Then mark the child as runnable and return. Ê†áËÆ∞ÂÑøÂ≠ê‰∏∫ runable//// Returns: child's envid to the parent, 0 to the child, &lt; 0 on error.// It is also OK to panic on error. Áà∂‰∫≤ËøîÂõû ÂÑøÂ≠êid ÂÑøÂ≠êËøîÂõû 0 ËøîÂõû &lt;0 Âá∫Èîô//// Hint:// Use uvpd, uvpt, and duppage. ‰ΩøÁî® uvpd, uvpt, Âíå duppage// Remember to fix "thisenv" in the child process.// Neither user exception stack should ever be marked copy-on-write,// so you must allocate a new page for the child's user exception stack.// ‰∏çÁî®ÊääÂºÇÂ∏∏Ê†àÊ†áËÆ∞‰∏∫ÂÜôÊó∂Â§çÂà∂ ÊâÄ‰ª•ÂøÖÈ°ªÂàÜÈÖçÊñ∞ÁöÑ‰∏ÄÈ°µÁªôÂÑøÂ≠êenvid_tfork(void)&#123; // LAB 4: Your code here. envid_t cenvid; unsigned pn; int r; set_pgfault_handler(pgfault); //ËÆæÁΩÆ Áº∫È°µÂ§ÑÁêÜ if ((cenvid = sys_exofork()) &lt; 0)&#123; //ÂàõÂª∫‰∫Ü‰∏Ä‰∏™ËøõÁ®ã„ÄÇ panic("sys_exofork failed"); return cenvid; &#125; if(cenvid&gt;0)&#123;//Â¶ÇÊûúÊòØ Áà∂‰∫≤ËøõÁ®ã for (pn=PGNUM(UTEXT); pn&lt;PGNUM(USTACKTOP); pn++)&#123; //Â§çÂà∂UTEXT Âà∞USTACKTOPÁöÑÈ°µ if ((uvpd[pn &gt;&gt; 10] &amp; PTE_P) &amp;&amp; (uvpt[pn] &amp; PTE_P)) if ((r = duppage(cenvid, pn)) &lt; 0) return r; &#125; if ((r = sys_page_alloc(cenvid, (void *)(UXSTACKTOP-PGSIZE), PTE_U | PTE_P | PTE_W)) &lt; 0) //ÂàÜÈÖç‰∏Ä‰∏™Êñ∞ÁöÑÈ°µ return r; extern void _pgfault_upcall(void); //Áº∫È°µÂ§ÑÁêÜ if ((r = sys_env_set_pgfault_upcall(cenvid, _pgfault_upcall)) &lt; 0) return r; //‰∏∫ÂÑøÂ≠êËÆæÁΩÆ‰∏Ä‰∏™Áº∫È°µÂ§ÑÁêÜÂàÜÊîØ if ((r = sys_env_set_status(cenvid, ENV_RUNNABLE)) &lt; 0)//ËÆæÁΩÆÊàêÂèØËøêË°å return r; return cenvid; &#125; else &#123; thisenv = &amp;envs[ENVX(sys_getenvid())];//Â¶ÇÊûúÊòØÂÑøÂ≠êÂ∞±Áõ¥Êé•ËøêË°å„ÄÇ return 0; &#125; //panic("fork not implemented"); &#125;// Challenge!intsfork(void)&#123; //Ëøô‰∏™ÊåëÊàòÁöÑÂÜÖÂÆπÔºåÊàëÊ≤°ÁúãÊáÇË¶ÅÂÅö‰ªÄ‰πà„ÄÇ panic("sfork not implemented"); return -E_INVAL;&#125; Part C: Preemptive Multitasking and Inter-Process communication (IPC)Áé∞Âú®Êàë‰ª¨Ë¶ÅÂÆûÁé∞Êä¢Âç†ÂºèË∞ÉÂ∫¶ÂíåËøõÁ®ãÈó¥ÈÄö‰ø°„ÄÇ Clock Interrupts and PreemptionËøêË°åuser/spin‰ºöÊ≠ªÂæ™ÁéØ„ÄÇ123456789101112131415161718192021222324252627282930// Test preemption by forking off a child process that just spins forever.// Let it run for a couple time slices, then kill it.#include &lt;inc/lib.h&gt;voidumain(int argc, char **argv)&#123; envid_t env; cprintf("I am the parent. Forking the child...\n"); if ((env = fork()) == 0) &#123; cprintf("I am the child. Spinning...\n"); while //(1) Âú®Ëøô‰∏™Âú∞ÊñπÊ≠ªÂæ™ÁéØ‰∫Ü /* do nothing */; &#125; cprintf("I am the parent. Running the child...\n"); sys_yield(); sys_yield(); sys_yield(); sys_yield(); sys_yield(); sys_yield(); sys_yield(); sys_yield(); cprintf("I am the parent. Killing the child...\n"); sys_env_destroy(env);//Â¶ÇÊûúÊòØÊä¢Âç†Âºè Â∞±‰ºöÂú®Ëøô‰∏™Âú∞ÊñπÁªôÊØÅ‰∫ÜÂ≠êËøõÁ®ã„ÄÇ&#125; ÂÆûÁé∞Êä¢Âç†ÂºèÔºåÂøÖÈ°ªË¶ÅÊúâÁ°¨‰ª∂ÁöÑÊîØÊåÅ„ÄÇ Interrupt disciplineÂ§ñÈÉ®‰∏≠Êñ≠ÔºàÂç≥ÔºåËÆæÂ§á‰∏≠Êñ≠ÔºâË¢´Áß∞‰∏∫IRQ„ÄÇÊúâ16‰∏™ÂèØËÉΩÁöÑIRQÔºåÁºñÂè∑‰ªé0Âà∞15.IRQÁºñÂè∑Âà∞IDTË°®È°πÁöÑÊò†Â∞Ñ‰∏çÊòØÂõ∫ÂÆöÁöÑ„ÄÇpicirq.c‰∏≠ÁöÑpic_initÂ∞Ü0~15ÁöÑIRQÁºñÂè∑Êò†Â∞ÑÂà∞IDTË°®È°π Ôºå[IRQ_OFFSET ~ IRQ_OFFSET +15]„ÄÇ Âú®inc/trap.h‰∏≠ÔºåIRQ_OFFSETÁöÑÂÄºÊòØ32.Âõ†Ê≠§IDTË°®È°π[32~ 47]ÂØπÂ∫î0~15ÁöÑIRQÁºñÂè∑„ÄÇ‰æãÂ¶ÇÔºåÊó∂Èíü‰∏≠Êñ≠ÊòØIRQ 0ÔºåÂõ†Ê≠§IDT[32]ÂåÖÂê´ÂÜÖÊ†∏‰∏≠ÁöÑÊó∂Èíü‰∏≠Êñ≠Â§ÑÁêÜ‰æãÁ®ãÁöÑÂú∞ÂùÄ„ÄÇIRQ_OFFSETÁöÑÈÄâÊã©‰∏ªË¶ÅÊòØ‰∏∫‰∫ÜËÆæÂ§á‰∏≠Êñ≠‰∏ç‰∏éÂ§ÑÁêÜÂô®ÂºÇÂ∏∏ÈáçÂè†„ÄÇ Âú®JOS‰∏≠ÔºåÂØπÊØîxv6 UnixÔºåÊàë‰ª¨ÂÅö‰∫ÜÂÖ≥ÈîÆÁöÑÁÆÄÂåñ„ÄÇÂú®ÂÜÖÊ†∏‰∏≠ÁöÑÊó∂ÂÄôÔºåÂ§ñÈÉ®ËÆæÂ§á‰∏≠Êñ≠Âü∫Êú¨‰∏äÊòØÂÖ≥Èó≠ÁöÑÔºàÂÉèxv6‰∏ÄÊ†∑ÔºåÂú®Áî®Êà∑Á©∫Èó¥ÊâìÂºÄÔºâ„ÄÇÂ§ñÈÉ®ËÆæÂ§á‰∏≠Êñ≠Áî±%eflagsÂØÑÂ≠òÂô®‰∏äÁöÑFL_IFÊ†áÂøó‰ΩçÊéßÂà∂„ÄÇÂΩìËøô‰∏™‰ΩçÁΩÆ‰ΩçÔºåÂ§ñÈÉ®‰∏≠Êñ≠‰ΩøËÉΩ„ÄÇËøô‰∏™‰ΩçÂèØ‰ª•ÈÄöËøáÂá†ÁßçÈÄîÂæÑ‰øÆÊîπÔºåÁî±‰∫éÊàë‰ª¨ÁöÑÁÆÄÂåñÔºåÊàë‰ª¨‰ªÖÈÄöËøáÂú®ËøõÂÖ•ÂÜÖÊ†∏Êó∂ÂÄô‰øùÂ≠ò%eflagsÂØÑÂ≠òÂô®ÔºåÈÄÄÂá∫ÂÜÖÊ†∏Êó∂ÊÅ¢Â§ç%eflagsÂØÑÂ≠òÂô®Ëøô‰∏™ËøáÁ®ãÊù•‰øÆÊîπFL_IFÊ†áÂøó‰Ωç„ÄÇ Â∫îËØ•Á°Æ‰øùÂú®Áî®Êà∑ÊÄÅFL_IFÊ†áÂøó‰ΩçÊòØÁΩÆ‰ΩçÁöÑÔºåËøôÊ†∑‰∏≠Êñ≠ÊâçËÉΩ‰º†ÈÄíÁªôÂ§ÑÁêÜÂô®ÔºåÂπ∂ÊúÄÁªàË¢´‰∏≠Êñ≠‰ª£Á†ÅÂ§ÑÁêÜ„ÄÇÂê¶ÂàôÔºå‰∏≠Êñ≠Ë¢´Â±èËîΩÊàñÂøΩÁï•ÔºåÁõ¥Âà∞ÈáçÊñ∞ÂêØÁî®‰∏≠Êñ≠„ÄÇBootloaderÊúÄÂàùÂá†Êù°Êåá‰ª§Â∞±Â±èËîΩ‰∫Ü‰∏≠Êñ≠ÔºåÂà∞ÁõÆÂâç‰∏∫Ê≠¢ÔºåÊàë‰ª¨‰ªéÊù•Ê≤°ÊúâÈáçÊñ∞ÂêØÁî®ÂÆÉ‰ª¨„ÄÇÁªÉ‰π† 13 Ë¶ÅÊàëÂÉèÂΩìÂàùÂÆûÁé∞ÂÜÖÈÉ®‰∏≠Êñ≠‰∏ÄÊ†∑ÔºåÂÆûÁé∞ËøôÂá†‰∏™Â§ñÈÉ®‰∏≠Êñ≠„ÄÇ‰∏ÄÊ†∑ÁöÑÊ≤°Âï•Âå∫Âà´„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354TRAPHANDLER_NOEC(IRQ0, IRQ_OFFSET)TRAPHANDLER_NOEC(IRQ1, IRQ_OFFSET+1)TRAPHANDLER_NOEC(IRQ2, IRQ_OFFSET+2)TRAPHANDLER_NOEC(IRQ3, IRQ_OFFSET+3)TRAPHANDLER_NOEC(IRQ4, IRQ_OFFSET+4)TRAPHANDLER_NOEC(IRQ5, IRQ_OFFSET+5)TRAPHANDLER_NOEC(IRQ6, IRQ_OFFSET+6)TRAPHANDLER_NOEC(IRQ7, IRQ_OFFSET+7)TRAPHANDLER_NOEC(IRQ8, IRQ_OFFSET+8)TRAPHANDLER_NOEC(IRQ9, IRQ_OFFSET+9)TRAPHANDLER_NOEC(IRQ10, IRQ_OFFSET+10)TRAPHANDLER_NOEC(IRQ11, IRQ_OFFSET+11)TRAPHANDLER_NOEC(IRQ12, IRQ_OFFSET+12)TRAPHANDLER_NOEC(IRQ13, IRQ_OFFSET+13)TRAPHANDLER_NOEC(IRQ14, IRQ_OFFSET+14)TRAPHANDLER_NOEC(IRQ15, IRQ_OFFSET+15)void IRQ0();void IRQ1();void IRQ2();void IRQ3();void IRQ4();void IRQ5();void IRQ6();void IRQ7();void IRQ8();void IRQ9();void IRQ10();void IRQ11();void IRQ12();void IRQ13();void IRQ14();void IRQ15();// trap_init SETGATE(idt[IRQ_OFFSET], 0, GD_KT, IRQ0, 0); SETGATE(idt[IRQ_OFFSET+1], 0, GD_KT, IRQ1, 0); SETGATE(idt[IRQ_OFFSET+2], 0, GD_KT, IRQ2, 0); SETGATE(idt[IRQ_OFFSET+3], 0, GD_KT, IRQ3, 0); SETGATE(idt[IRQ_OFFSET+4], 0, GD_KT, IRQ4, 0); SETGATE(idt[IRQ_OFFSET+5], 0, GD_KT, IRQ5, 0); SETGATE(idt[IRQ_OFFSET+6], 0, GD_KT, IRQ6, 0); SETGATE(idt[IRQ_OFFSET+7], 0, GD_KT, IRQ7, 0); SETGATE(idt[IRQ_OFFSET+8], 0, GD_KT, IRQ8, 0); SETGATE(idt[IRQ_OFFSET+9], 0, GD_KT, IRQ9, 0); SETGATE(idt[IRQ_OFFSET+10], 0, GD_KT, IRQ10, 0); SETGATE(idt[IRQ_OFFSET+11], 0, GD_KT, IRQ11, 0); SETGATE(idt[IRQ_OFFSET+12], 0, GD_KT, IRQ12, 0); SETGATE(idt[IRQ_OFFSET+13], 0, GD_KT, IRQ13, 0); SETGATE(idt[IRQ_OFFSET+14], 0, GD_KT, IRQ14, 0); SETGATE(idt[IRQ_OFFSET+15], 0, GD_KT, IRQ15, 0); // Per-CPU setup ËøòÈúÄË¶ÅÂºÄÂêØËøô‰∏™‰∏≠Êñ≠ÔºåÂú®env_allocÈáåÈù¢„ÄÇ123// Enable interrupts while in user mode.// LAB 4: Your code here.e-&gt;env_tf.tf_eflags |= FL_IF; Handling Clock InterruptsÂú®user/spinÁ®ãÂ∫è‰∏≠ÔºåÂ≠êËøõÁ®ãÂºÄÂßãËøêË°å‰πãÂêéÂ∞±ËøõÂÖ•Ê≠ªÂæ™ÁéØÔºåÂÜÖÊ†∏‰∏ç‰ºöÂÜçËé∑ÂèñÊéßÂà∂ÊùÉ„ÄÇÊàë‰ª¨Áé∞Âú®ÈúÄË¶ÅÂØπÁ°¨‰ª∂ÁºñÁ®ã‰ª•ÊØèÈöî‰∏ÄÂÆöÁöÑÊó∂Èó¥ÁîüÊàêÊó∂Èíü‰∏≠Êñ≠ÔºåËøôÊ†∑‰ºöÂº∫Âà∂Â∞ÜÊéßÂà∂ÊùÉËøîÂõûÁªôÂÜÖÊ†∏ÔºåÂÜÖÊ†∏ÂèØ‰ª•ÂàáÊç¢Âà∞‰∏çÂêåÁöÑÁî®Êà∑ÁéØÂ¢É‰∏äËøêË°å„ÄÇ i386_init()ÂáΩÊï∞Ë∞ÉÁî®lapic_initÂíåpic_initÔºåËÆæÁΩÆÊó∂Èíü‰ª•Âèä‰∏≠Êñ≠ÊéßÂà∂Âô®ÁîüÊàê‰∏≠Êñ≠ÔºåÁé∞Âú®ÈúÄË¶ÅÁºñÂÜô‰ª£Á†ÅÂ§ÑÁêÜËøô‰∫õ‰∏≠Êñ≠„ÄÇËøô‰∏™Êó∂ÂÄôÊùêË¥® lapic_init Âíåpic_init ÊòØÁî®Êù•Âπ≤Âï•ÁöÑ„ÄÇÂêéÊù•ÂèëÁé∞lapicw(TICR, 10000000);Ëøô‰∏™ÊòØËÆæÁΩÆ‰∏≠Êñ≠Êó∂Èó¥ÂÖ∑‰ΩìÁªÜËäÇÂ∞±‰∏çÁü•ÈÅì‰∫ÜÔºåÂ∫îËØ•ÂíåÂµåÂÖ•ÂºèÊúâÂÖ≥„ÄÇÁªÉ‰π† 14ËÆ©Êàë‰ª¨trap_dispatchÈáåÈù¢ÂÆûÁé∞Ë∞ÉÂ∫¶Ôºå‰πüÂ∞±ÊòØÊä¢Âç†ÂºèË∞ÉÂ∫¶„ÄÇ12345case IRQ_OFFSET + IRQ_TIMER:&#123; lapic_eoi(); sched_yield(); break; &#125; Inter-Process communication (IPC)ÊúÄÂêé‰∏Ä‰∏™Â∞±ÊòØËøõÁ®ãÈÄö‰ø°„ÄÇÊàë‰ª¨Âà∞ÁõÆÂâç‰∏∫Ê≠¢ÔºåÈÉΩÊòØÂÅáË£Ö‰∏Ä‰∏™ÁîµËÑëÂ∞±Âè™Êúâ‰∏Ä‰∏™ËøõÁ®ãÔºåÁé∞Âú®Êàë‰ª¨Ë¶ÅÂºÄÂßãÁÉ§ÁÇâ‰∏§‰∏™ËøõÁ®ã‰πãÈó¥ÁöÑÁõ∏‰∫íÂΩ±Âìç„ÄÇÊàë‰ª¨ÈúÄË¶ÅÂÆûÁé∞‰∏Ä‰∏™ÁÆÄÂçïÁöÑËøõÁ®ãÈÄö‰ø°„ÄÇ IPC in JOSÊàë‰ª¨ÈúÄË¶ÅÂÆûÁé∞‰∏§‰∏™Á≥ªÁªüË∞ÉÁî®sys_ipc_recv Âíå sys_ipc_try_sendÂπ∂‰∏îÊàë‰ª¨Â∑≤ÁªèÁî®ipc_recvÂíåipc_sendÂ∞ÅË£ÖÂ•Ω‰∫Ü‰ªñ(CËØ≠Ë®ÄÈáåÈù¢ÊúâÂ∞ÅË£ÖÁöÑÊ¶ÇÂøµÔºüÔºü)ÔºåÊàë‰ª¨ÂèëÈÄÅÁöÑ‰ø°ÊÅØÊòØ‰∏Ä‰∏™32‰ΩçÁöÑÂÄºÂíåÂèØÈÄâÁöÑ‰∏Ä‰∏™ÂçïÈ°µÊò†Â∞Ñ„ÄÇÂÖÅËÆ∏Áî®Êà∑ÁéØÂ¢ÉÂú®Ê∂àÊÅØ‰∏≠‰º†ÈÄíÈ°µÈù¢Êò†Â∞ÑÊèê‰æõ‰∫Ü‰∏ÄÁßç‰º†ËæìÊõ¥Â§öÁöÑÊï∞ÊçÆÁöÑÊúâÊïàÁöÑÊñπÊ≥ïÔºåËÄå‰∏ç‰ªÖ‰ªÖÊòØÂçï‰∏™32‰ΩçÊï¥Êï∞ÔºåÂπ∂‰∏îËøòÂÖÅËÆ∏Áî®Êà∑ÁéØÂ¢ÉËΩªÊùæÂú∞Âª∫Á´ãÂÖ±‰∫´ÂÜÖÂ≠òÂ∏ÉÂ±Ä„ÄÇ Sending and Receiving MessagesÁî®Êà∑ÁéØÂ¢ÉË∞ÉÁî®sys_ipc_recvÊé•Êî∂Ê∂àÊÅØ„ÄÇÊ≠§Á≥ªÁªüË∞ÉÁî®‰ºöË∞ÉÂ∫¶ÂΩìÂâçÁéØÂ¢ÉÔºå‰ΩøÂæóÂú®Êî∂Âà∞Ê∂àÊÅØ‰πãÂâç‰∏çÂÜçËøêË°åÂÆÉ„ÄÇÂΩìÁî®Êà∑ÁéØÂ¢ÉÁ≠âÂæÖÊé•Êî∂Ê∂àÊÅØÊó∂Ôºå‰ªª‰ΩïÂÖ∂‰ªñÁî®Êà∑ÁéØÂ¢ÉÈÉΩÂèØ‰ª•ÂêëÂÖ∂ÂèëÈÄÅÊ∂àÊÅØ‚Äì ËÄå‰∏ç‰ªÖ‰ªÖÊòØÁâπÂÆöÁöÑÁéØÂ¢ÉÔºåËÄå‰∏ç‰ªÖ‰ªÖÊòØ‰∏éÊé•Êî∂Ê∂àÊÅØÁöÑÁî®Êà∑ÁéØÂ¢ÉÂÖ∑ÊúâÁöÑÁà∂/Â≠êÂÖ≥Á≥ªÁöÑÁî®Êà∑ÁéØÂ¢É„ÄÇÊç¢ËÄåË®Ä‰πãÔºåÂú®PartA‰∏≠ÂÆûÁé∞ÁöÑÊùÉÈôêÊ£ÄÊü•‰∏çÂÜçÈÄÇÁî®‰∫éIPCÔºåÂõ†‰∏∫IPCÁ≥ªÁªüË∞ÉÁî®ÊòØÁ≤æÂøÉËÆæËÆ°ÁöÑÔºå‰ª•‰æøÊòØ‚ÄúÂÆâÂÖ®ÁöÑ‚ÄùÔºöÁî®Êà∑ÁéØÂ¢É‰∏çËÉΩ‰ªÖ‰ªÖÈÄöËøáÂèëÈÄÅÊ∂àÊÅØËÄåÂØºËá¥Âè¶‰∏Ä‰∏™ÁéØÂ¢ÉÊïÖÈöúÔºàÈô§ÈùûÁõÆÊ†áÁéØÂ¢É‰πüÊòØÈîôËØØÁöÑÔºâ„ÄÇ Áî®Êà∑ÁéØÂ¢É‰ª•Êé•Êî∂Ê∂àÊÅØÁöÑÁî®Êà∑ÁéØÂ¢ÉÁöÑid‰ª•ÂèäÂæÖÂèëÈÄÅÁöÑÂÄº‰∏∫ÂèÇÊï∞Ë∞ÉÁî®sys_ipc_try_sendÂèëÈÄÅ‰∏Ä‰∏™ÂÄº„ÄÇÂ¶ÇÊûúÊé•Êî∂Ê∂àÊÅØÁöÑÁî®Êà∑ÁéØÂ¢ÉÊòØÂê¶Ê≠£Âú®Êé•Êî∂Ê∂àÊÅØÔºàËØ•Áî®Êà∑ÁéØÂ¢ÉË∞ÉÁî®sys_ipc_recvÁ≥ªÁªüË∞ÉÁî®Ôºå‰ΩÜËøòÊ≤°ÊúâÊé•Êî∂Âà∞ÂÄºÔºâÔºåsys_ipc_try_sendÁ≥ªÁªüË∞ÉÁî®‰º†ÈÄÅÊ∂àÊÅØÂπ∂ËøîÂõû0ÔºåÂê¶ÂàôËøîÂõû-E_IPC_NOT_RECVË°®Á§∫ÁõÆÊ†áÁéØÂ¢ÉÂΩìÂâç‰∏çÂ∏åÊúõÊé•Êî∂Âà∞‰∏Ä‰∏™ÂÄº„ÄÇ Áî®Êà∑Á©∫Èó¥ÁöÑÂ∫ìÂáΩÊï∞ipc_recvË¥üË¥£Ë∞ÉÁî®sys_ipc_recv,ÁÑ∂ÂêéÂú®ÂΩìÂâçÁéØÂ¢ÉÁöÑstruct Env‰∏≠Êü•ÊâæÊúâÂÖ≥Êé•Êî∂Âà∞ÁöÑÂÄºÁöÑ‰ø°ÊÅØ„ÄÇ Á±ª‰ººÁöÑÔºåÁî®Êà∑Á©∫Èó¥ÁöÑÂ∫ìÂáΩÊï∞ipc_sendÂê¶ÂàôÂèçÂ§çË∞ÉÁî®sys_ipc_try_sendÁõ¥Âà∞Ê∂àÊÅØÂèëÈÄÅÊàêÂäü„ÄÇ Transferring PagesÂΩìÁî®Êà∑ÁéØÂ¢É‰ΩøÁî®ÊúâÊïàÁöÑdstvaÂèÇÊï∞Ôºà‰Ωé‰∫éUTOPÔºâË∞ÉÁî®sys_ipc_recvÊó∂ÔºåÁéØÂ¢ÉË°®Á§∫ÂÆÉÊÑøÊÑèÊé•Êî∂È°µÈù¢Êò†Â∞Ñ„ÄÇÂ¶ÇÊûúÂèëÈÄÅËÄÖÂèëÈÄÅ‰∏Ä‰∏™È°µÈù¢ÔºåÈÇ£‰πàËØ•È°µÈù¢Â∫îËØ•Âú®Êé•Êî∂ËÄÖÁöÑÂú∞ÂùÄÁ©∫Èó¥‰∏≠ÁöÑdstvaÊò†Â∞Ñ„ÄÇÂ¶ÇÊûúÊé•Êî∂ËÄÖÂ∑≤ÁªèÂú®dstva‰∏äÊò†Â∞Ñ‰∫Ü‰∏Ä‰∏™È°µÈù¢ÔºåÈÇ£‰πà‰πãÂâçÁöÑÈ°µÊò†Â∞ÑË¢´ÂèñÊ∂à„ÄÇ ÂΩìÁî®Êà∑ÁéØÂ¢É‰ª•ÊúâÊïàÁöÑsrcvaÔºàÂú®UTOP‰∏ãÈù¢Ôºâ‰ª•ÂèäÊùÉÈôêperm‰∏∫ÂèÇÊï∞Ë∞ÉÁî®sys_ipc_try_sendÊó∂ÔºåËøôÊÑèÂë≥ÁùÄÂèëÈÄÅËÄÖÊÉ≥Ë¶ÅÂ∞ÜÂΩìÂâçÊò†Â∞ÑÂà∞srcvaÁöÑÈ°µÈù¢ÂèëÈÄÅÁªôÊé•Êî∂ËÄÖ„ÄÇÂú®ÊàêÂäüÁöÑIPC‰πãÂêéÔºåÂèëÈÄÅÊñπÂú®ÂÖ∂Âú∞ÂùÄÁ©∫Èó¥‰∏≠ÁöÑsrcva‰øùÊåÅÈ°µÈù¢ÁöÑÂéüÂßãÊò†Â∞ÑÔºå‰ΩÜÊòØÊé•Êî∂ÊñπÂú®ÂÖ∂Âú∞ÂùÄÁ©∫Èó¥ÊúÄÂàùÊåáÂÆöÁöÑdstvaÂ§ÑËé∑Âæó‰∫Ü‰∏éÂèëÈÄÅËÄÖÂêå‰∏ÄÁâ©ÁêÜÈ°µÁöÑÊò†Â∞Ñ„ÄÇÂõ†Ê≠§ÔºåËØ•È°µÈù¢Âú®ÂèëÈÄÅËÄÖÂíåÊé•Êî∂ËÄÖ‰πãÈó¥ÂÖ±‰∫´„ÄÇ Â¶ÇÊûúÂèëÈÄÅËÄÖÊàñÊé•Êî∂ËÄÖÊ≤°ÊúâÊåáÁ§∫‰∏Ä‰∏™È°µÈù¢Â∫îËØ•Ë¢´‰º†ÈÄÅÔºåÈÇ£‰πàÊ≤°ÊúâÈ°µÈù¢Ë¢´‰º†ÈÄÅ„ÄÇÂú®‰ªª‰ΩïIPC‰πãÂêéÔºåÂÜÖÊ†∏Â∞ÜÊé•Êî∂ËÄÖÁöÑEnvÁªìÊûÑ‰∏≠ÁöÑÊñ∞Â≠óÊÆµenv_ipc_permËÆæÁΩÆ‰∏∫Êé•Êî∂Âà∞ÁöÑÈ°µÈù¢ÁöÑÊùÉÈôêÔºåÂ¶ÇÊûúÊ≤°ÊúâÊé•Êî∂Âà∞È°µÈù¢ÔºåÂàô‰∏∫Èõ∂„ÄÇ Implementing IPC‰ªãÁªç‰∫ÜËøô‰πàÂ§ö‰∏úË•øÂÖ∂ÂÆû‰πüÂ∞±ÊòØ‰∏∫‰∫ÜÊúÄÂêéËøô‰∏™„ÄÇÁªÉ‰π†15 ÂÆûÁé∞sys_ipc_recvÂíåsys_ipc_recv„ÄÇ sys_ipc_recv12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// Try to send 'value' to the target env 'envid'.// If srcva &lt; UTOP, then also send page currently mapped at 'srcva',// so that receiver gets a duplicate mapping of the same page.// ÂèëËøá srcva &lt; UTOP Êää‰ªñÂØπÂ∫îÁöÑÁâ©ÁêÜÈ°µÈÄÅËøáÂéª// The send fails with a return value of -E_IPC_NOT_RECV if the// target is not blocked, waiting for an IPC.// Â§±Ë¥•ËøîÂõû E_IPC_NOT_RECV Â¶ÇÊûúÁõÆÊ†áÊòØ‰∏çÂ†µÂ°ûÁöÑÂ∞±Á≠âÂæÖIPC// The send also can fail for the other reasons listed below.//// Otherwise, the send succeeds, and the target's ipc fields are// updated as follows: //Â¶ÇÊûúÂèëÈÄÅÊàêÂäüÊõ¥Êñ∞‰∏ãÈù¢Ëøô‰∫õ‰∏úË•ø// env_ipc_recving is set to 0 to block future sends; ËÆæÁΩÆ 0Êù•ÈòªÂ°û// env_ipc_from is set to the sending envid;//ËÆæÁΩÆÂèëÈÄÅÁöÑID// env_ipc_value is set to the 'value' parameter; ËÆæÁΩÆÂÄº// env_ipc_perm is set to 'perm' if a page was transferred, 0 otherwise.ËÆæÁΩÆÂèëÈÄÅÈ°µÈù¢ÊùÉÈôê// The target environment is marked runnable again, returning 0 Ê†áËÆ∞ÁõÆÊ†áÁéØÂ¢É‰∏∫runnable// from the paused sys_ipc_recv system call. (Hint: does the// sys_ipc_recv function ever actually return?)ÊöÇÂÅúsys_ipc_recv//// If the sender wants to send a page but the receiver isn't asking for one,// then no page mapping is transferred, but no error occurs.// The ipc only happens when no errors occur.// Â¶ÇÊûúÂΩìÂâçËøõÁ®ãÂèëÈÄÅ‰∫Ü‰∏Ä‰∏™È°µÔºå‰ΩÜÊòØ ÁõÆÊ†áËøõÁ®ãÊ≤°ÊúâË¶ÅÊ±Ç‰∏Ä‰∏™È°µÔºåÁÑ∂ÂêéÊ≤°Êúâ È°µ‰ºöË¢´ÂèëÈÄÅÔºå‰∏ç‰ºö‰∫ßÁîüÈîôËØØ„ÄÇ// Returns 0 on success, &lt; 0 on error.// Errors are:// -E_BAD_ENV if environment envid doesn't currently exist.// (No need to check permissions.)//Â¶ÇÊûúËøõÁ®ãÈîôËØØ// -E_IPC_NOT_RECV if envid is not currently blocked in sys_ipc_recv,// or another environment managed to send first.//ÁõÆÊ†áÊ≤°ÊúâÊé•Âèó// -E_INVAL if srcva &lt; UTOP but srcva is not page-aligned.//È°µÂú∞ÂùÄÈîôËØØ// -E_INVAL if srcva &lt; UTOP and perm is inappropriate//È°µÊùÉÈôêÈîôËØØ// (see sys_page_alloc).// -E_INVAL if srcva &lt; UTOP but srcva is not mapped in the caller's// address space.//È°µÊ≤°ÊúâÊò†Â∞Ñ// -E_INVAL if (perm &amp; PTE_W), but srcva is read-only in the// current environment's address space.//È°µÂè™ËØª// -E_NO_MEM if there's not enough memory to map srcva in envid's// address space.//Ê≤°ÊúâË∂≥Â§üÁöÑÁ©∫Èó¥static intsys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)&#123; // LAB 4: Your code here. struct Env* env; if(envid2env(envid,&amp;env,0)&lt;0)return -E_BAD_ENV;//ÁéØÂ¢É if(env-&gt;env_ipc_recving==0)return -E_IPC_NOT_RECV;//ÊòØÂê¶ÈòªÂ°û env-&gt;env_ipc_perm = 0;//ÊùÉÈôê unsigned flag= PTE_P | PTE_U; if((uintptr_t)srcva&lt;UTOP)&#123;//È°µÂú∞ÂùÄÂ∞è‰∫éUTOP if(PGOFF(srcva))return -E_INVAL;//‰∏çÊòØÈ°µÂØπÈΩê if ((perm &amp; ~(PTE_SYSCALL)) || ((perm &amp; flag) != flag))return -E_INVAL;//ÊùÉÈôêÈîôËØØ if (user_mem_check(curenv, (const void *)srcva, PGSIZE, PTE_U) &lt; 0)//È°µ‰∏çÂ≠òÂú® return -E_INVAL; if (perm&amp; PTE_W&amp;&amp;user_mem_check(curenv, (const void *)srcva, PGSIZE, PTE_U |PTE_W) &lt; 0)//È°µÊùÉÈôêÈîôËØØ return -E_INVAL; if((uintptr_t)(env-&gt;env_ipc_dstva)&lt;UTOP)&#123;//Êé•ÂèóÈ°µÁöÑÂú∞ÂùÄ env-&gt;env_ipc_perm=perm; struct PageInfo *pi = page_lookup(curenv-&gt;env_pgdir, srcva, 0); if (page_insert(env-&gt;env_pgdir, pi, env-&gt;env_ipc_dstva, perm) &lt; 0)//Êò†Â∞Ñ‰∏Ä‰∏ãÔºåÊò†Â∞ÑÂ§±Ë¥•ËøîÂõûÊ≤°ÊúâÂÜÖÂ≠ò‰∫Ü„ÄÇ return -E_NO_MEM; &#125; &#125; //ËÆæÁΩÆ‰∏Ä‰∏ãÂÄº env-&gt;env_ipc_recving = false; env-&gt;env_ipc_from = curenv-&gt;env_id; env-&gt;env_ipc_value = value; env-&gt;env_status = ENV_RUNNABLE; env-&gt;env_tf.tf_regs.reg_eax = 0; return 0; //panic("sys_ipc_try_send not implemented");&#125; sys_ipc_recv12345678910111213141516171819202122232425// Block until a value is ready. Record that you want to receive// using the env_ipc_recving and env_ipc_dstva fields of struct Env,// mark yourself not runnable, and then give up the CPU.// Âú®Á≠âÂà∞Êé•Âèó‰πãÂâç‰∏ÄÁõ¥ ÈòªÂ°ûÔºåÈáäÊîæCPU// If 'dstva' is &lt; UTOP, then you are willing to receive a page of data.// 'dstva' is the virtual address at which the sent page should be mapped.//Â¶ÇÊûú dstva &lt;UTOP Ê†áÁ§∫‰Ω†ÊÑøÊÑèÊé•Âèó‰∏Ä‰∏™È°µ„ÄÇÈÄÅËøáÊù•ÁöÑÈ°µÂ∞ÜÊò†Â∞ÑÂà∞dstva// This function only returns on error, but the system call will eventually// return 0 on success.// Return &lt; 0 on error. Errors are:// -E_INVAL if dstva &lt; UTOP but dstva is not page-aligned.//Âè™ÊúâËøôÊ†∑‰ºö‰øùÂ≠òstatic intsys_ipc_recv(void *dstva)&#123; // LAB 4: Your code here. if((dstva &lt; (void *)UTOP) &amp;&amp; PGOFF(dstva))//Êä•Èîô return -E_INVAL; curenv-&gt;env_ipc_recving = true; curenv-&gt;env_ipc_dstva = dstva; curenv-&gt;env_status = ENV_NOT_RUNNABLE; sched_yield(); //panic("sys_ipc_recv not implemented"); return 0;&#125; ÊúÄÂêéÂà´Âøò‰∫ÜÔºåsyscall12345case SYS_ipc_try_send: return sys_ipc_try_send((envid_t)a1, (uint32_t)a2, (void *)a3, (unsigned)a4); case SYS_ipc_recv: return sys_ipc_recv((void *)a1); default: ÁÑ∂ÂêéËÆ©Êàë‰ª¨ÂÆûÁé∞lib/ipc.cÈáåÈù¢ÁöÑipc_recvÂíåipc_send„ÄÇ ipc.c12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// User-level IPC library routines#include &lt;inc/lib.h&gt;// Receive a value via IPC and return it. Êé•Âèó‰∏Ä‰∏™IPC// If 'pg' is nonnull, then any page sent by the sender will be mapped at// that address. Â¶ÇÊûúpgÈùûÁ©∫‰ºöÂèëÈÄÅ‰ªñ// If 'from_env_store' is nonnull, then store the IPC sender's envid in// *from_env_store. Â¶ÇÊûúfrom_env_storeÈùûÁ©∫Â∞±‰ºöÊääÂèëÈÄÅËøõÁ®ãÁöÑid ÊîæÂà∞ from_env_store// If 'perm_store' is nonnull, then store the IPC sender's page permission// in *perm_store (this is nonzero iff a page was successfully// transferred to 'pg'). Â¶ÇÊûúperm_storeÈùûÁ©∫Â∞±‰ºöÂÇ®Â≠òÈ°µÊùÉÈôêÂú®Ëøô// If the system call fails, then store 0 in *fromenv and *perm (if// they're nonnull) and return the error. Â¶ÇÊûúÈîô‰∫ÜÂ∞±‰ºöÊää0Â≠òÂà∞fromenvÂíåpermÂ¶ÇÊûú‰ªñ‰ª¨ÈùûÁ©∫„ÄÇ// Otherwise, return the value sent by the sender Âê¶ÂàôËøîÂõûÂÄº//// Hint:// Use 'thisenv' to discover the value and who sent it. Áî®thisenvÂèëÁé∞ÊòØË∞ÅÈÄÅÁöÑ// If 'pg' is null, pass sys_ipc_recv a value that it will understand// as meaning "no page". (Zero is not the right value, since that's// a perfectly valid place to map a page.)int32_tipc_recv(envid_t *from_env_store, void *pg, int *perm_store)&#123; // LAB 4: Your code here. pg = (pg == NULL ? (void *)UTOP : pg); int r; if ((r = sys_ipc_recv(pg)) &lt; 0) &#123;//UTOP Áõ∏ÂΩì‰∫éÊ≤°ÊúâÂú∞ÂùÄ‰ºöËøîÂõû0 if (from_env_store != NULL) *from_env_store = 0; if (perm_store != NULL) *perm_store = 0; return r; &#125; //Â¶ÇÊûúpg==NULL ÂêéÈù¢Ëøô‰∏§‰∏™ÂÄºÈÉΩÊØ´Êó†ÊÑè‰πâ if (from_env_store != NULL) *from_env_store = thisenv-&gt;env_ipc_from; if (perm_store != NULL) *perm_store = thisenv-&gt;env_ipc_perm; return thisenv-&gt;env_ipc_value; //panic("ipc_recv not implemented"); return 0;&#125;// Send 'val' (and 'pg' with 'perm', if 'pg' is nonnull) to 'toenv'.// This function keeps trying until it succeeds.// It should panic() on any error other than -E_IPC_NOT_RECV.// Â¶ÇÊûú‰∏çÊòØ E_IPC_NOT_RECV Â∞±Êä•Èîô„ÄÇ// Hint:// Use sys_yield() to be CPU-friendly.// If 'pg' is null, pass sys_ipc_try_send a value that it will understand// as meaning "no page". (Zero is not the right value.) voidipc_send(envid_t to_env, uint32_t val, void *pg, int perm)&#123; // LAB 4: Your code here. int r; while((r=sys_ipc_try_send(to_env,val, (pg == NULL ? (void *)UTOP : pg),perm))&lt;0)&#123; if(r!=-E_IPC_NOT_RECV)panic("sys_ipc_try_send: %e\n", r); sys_yield();//ÈáäÊîæCPU &#125;//‰∏ÄÁõ¥ÂèëÈÄÅÁõ¥Âà∞ÊàêÂäü... //panic("ipc_send not implemented");&#125;// Find the first environment of the given type. We'll use this to// find special environments.// Returns 0 if no such environment exists.envid_tipc_find_env(enum EnvType type)&#123; int i; for (i = 0; i &lt; NENV; i++) if (envs[i].env_type == type) return envs[i].env_id; return 0;&#125;]]></content>
      <categories>
        <category>Êìç‰ΩúÁ≥ªÁªü</category>
        <category>MIT6.828</category>
      </categories>
      <tags>
        <tag>MIT6.828</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT6.828(‰∏â)Lab3:User Environments]]></title>
    <url>%2F2020%2F02%2F18%2FMIT-6.828-(%E4%B8%89)-Lab-3-User-Environments%2F</url>
    <content type="text"><![CDATA[(ÊúÄËøëÊúâÁÇπ‰∫ãÔºåÂÅöÁöÑÊØîËæÉÊÖ¢„ÄÇÂì¶Ôºå‰∏çÔºåÊäÑÁöÑÊØîËæÉÊÖ¢„ÄÇ„ÄÇ„ÄÇ) Lab 3: User EnvironmentsIntroductionÂú®Ëøô‰∏™ÂÆûÈ™å‰∏≠ÔºåÊàë‰ª¨Â∞ÜÂÆûÁé∞Êìç‰ΩúÁ≥ªÁªüÁöÑ‰∏Ä‰∫õÂü∫Êú¨ÂäüËÉΩÔºåÊù•ÂÆûÁé∞Áî®Êà∑ÁéØÂ¢É‰∏ãÁöÑËøõÁ®ãÁöÑÊ≠£Â∏∏ËøêË°å„ÄÇ‰Ω†Â∞Ü‰ºöÂä†Âº∫JOSÂÜÖÊ†∏ÁöÑÂäüËÉΩÔºå‰∏∫ÂÆÉÂ¢ûÊ∑ª‰∏Ä‰∫õÈáçË¶ÅÁöÑÊï∞ÊçÆÁªìÊûÑÔºåÁî®Êù•ËÆ∞ÂΩïÁî®Êà∑ËøõÁ®ãÁéØÂ¢ÉÁöÑ‰∏Ä‰∫õ‰ø°ÊÅØÔºõÂàõÂª∫‰∏Ä‰∏™Âçï‰∏ÄÁöÑÁî®Êà∑ÁéØÂ¢ÉÔºåÂπ∂‰∏îÂä†ËΩΩ‰∏Ä‰∏™Á®ãÂ∫èËøêË°åÂÆÉ„ÄÇ‰Ω†‰πüÂèØ‰ª•ËÆ©JOSÂÜÖÊ†∏ËÉΩÂ§üÂÆåÊàêÁî®Êà∑ÁéØÂ¢ÉÊâÄ‰ΩúÂá∫ÁöÑ‰ªª‰ΩïÁ≥ªÁªüË∞ÉÁî®Ôºå‰ª•ÂèäÂ§ÑÁêÜÁî®Êà∑ÁéØÂ¢É‰∫ßÁîüÁöÑÂêÑÁßçÂºÇÂ∏∏„ÄÇ Getting StartedÁÖßÁùÄÂÆòÁΩë‰∏äÂÅöÂ∞±Ë°å‰∫Ü„ÄÇÁÑ∂Âêé‰ºöÂ§öÂá∫‰ªñËØ¥ÁöÑÈÇ£‰∫õÊñá‰ª∂ÔºåÂêéÈù¢Áî®Âà∞ÁöÑÊó∂ÂÄôÂÜçËØ¥„ÄÇ Part A: User Environments and Exception HandlingËÆ©Êàë‰ª¨ÁúãÁúãinc/env.hÁöÑÊñá‰ª∂ÔºåÈáåÈù¢ÊúâÁî®Êà∑ÁéØÂ¢ÉÁöÑ‰∏Ä‰∫õÂü∫Êú¨ÂÆö‰πâ„ÄÇÊàë‰ª¨Áõ¥Êé•ÂàÜÊûêÂàÜÊûê‰∏Ä‰∏ã„ÄÇÂÜÖÊ†∏‰ΩøÁî®EnvÊï∞ÊçÆÁªìÊûÑÊù•Ë∑üË∏™ÊØè‰∏™Áî®Êà∑ÁéØÂ¢É„ÄÇ Âú®Êú¨ÂÆûÈ™å‰∏≠ÔºåÊúÄÂàùÂè™‰ºöÂàõÂª∫‰∏Ä‰∏™ÁéØÂ¢ÉÔºå‰ΩÜÊÇ®ÈúÄË¶ÅËÆæËÆ°JOSÂÜÖÊ†∏‰ª•ÊîØÊåÅÂ§ö‰∏™ÁéØÂ¢É; lab4Â∞ÜÈÄöËøáÂÖÅËÆ∏Áî®Êà∑ÁéØÂ¢ÉforkÂÖ∂‰ªñÁéØÂ¢ÉÊù•Âà©Áî®Ê≠§ÂäüËÉΩ„ÄÇ env.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* See COPYRIGHT for copyright information. */#ifndef JOS_INC_ENV_H#define JOS_INC_ENV_H#include &lt;inc/types.h&gt;#include &lt;inc/trap.h&gt;#include &lt;inc/memlayout.h&gt;typedef int32_t envid_t; //Áî®Êà∑ÁéØÂ¢ÉID ÂèòÈáèÔºå32‰ΩçÁöÑ„ÄÇ// An environment ID 'envid_t' has three parts://// +1+---------------21-----------------+--------10--------+// |0| Uniqueifier | Environment |// | | | Index |// +------------------------------------+------------------+// \--- ENVX(eid) --///// The environment index ENVX(eid) equals the environment's index in the// 'envs[]' array. The uniqueifier distinguishes environments that were// created at different times, but share the same environment index.// Ëøô‰∏™ENV(eid) ÂèØ‰ª•Ëé∑ÂèñÂú®envs Êï∞ÁªÑÈáåÈù¢ÁöÑÁ¨¨Âá†‰∏™„ÄÇ// All real environments are greater than 0 (so the sign bit is zero).// envid_ts less than 0 signify errors. The envid_t == 0 is special, and// stands for the current environment. ÊâÄÊúâÁöÑ ÁéØÂ¢ÉÊòØÂ§ß‰∫é0 ÁöÑÔºåenvid_tsÂ∞è‰∫é0ÊòØÈîôËØØÁöÑ Ôºåenvid_t == 0 Ê†áÁ§∫ÂΩìÂâçÊ≠£Âú®ËøêË°å//ÊúÄÂ§ßËÉΩÊîØÊåÅÂêåÊó∂Ê¥ªË∑ÉÁöÑËøõÁ®ãÊï∞Èáè#define LOG2NENV 10#define NENV (1 &lt;&lt; LOG2NENV)#define ENVX(envid) ((envid) &amp; (NENV - 1))// Values of env_status in struct Envenum &#123; ENV_FREE = 0,//Á©∫Èó≤ ENV_DYING,//ÂÉµÂ∞∏ËøõÁ®ã ENV_RUNNABLE,//ÂáÜÂ§áÂ∞±Áª™ ENV_RUNNING,//ËøêË°åÊÄÅ ENV_NOT_RUNNABLE//ÈòªÂ°ûÁä∂ÊÄÅ&#125;;// Special environment types ÁéØÂ¢ÉÁöÑÁâπÊÆäÁ±ªÂûãenum EnvType &#123; ENV_TYPE_USER = 0,&#125;;// ÁéØÂ¢ÉÁªìÊûÑ‰Ωì Â∞±ÊòØ‰∏Ä‰∏™PCB ÂØπËøô‰∏™ÊúâÂÖ¥Ë∂£ÁöÑÂêåÂøóÂèØ‰ª•ÁúãÁúãÊàë ÁöÑÂâñÊûê linux1.0 Ê∫êÁ†ÅÔºåËøô‰∏™Â∞±ÊòØÁÆÄÂåñÁâàÁöÑÈÇ£‰∏™‰∏úË•ø„ÄÇstruct Env &#123; struct Trapframe env_tf; // Saved registers ÂÇ®Â≠òÂØÑÂ≠òÂô®ÔºåÁî®‰∫éÊÅ¢Â§çÁä∂ÊÄÅ struct Env *env_link; // Next free Env ‰∏ã‰∏Ä‰∏™Á©∫Èó≤ÁªìÊûÑ‰Ωì envid_t env_id; // Unique environment identifier Áã¨Á´ãÁöÑÊ†áËØÜÁ¨¶ envid_t env_parent_id; // env_id of this env's parent Áà∂‰∫≤Ê†áËØÜÁ¨¶ enum EnvType env_type; // Indicates special system environments Áî®‰∫éÂå∫Âà´Âá∫Êù•ÊüêÁâπÂÆöÁöÑÁî®Êà∑ÁéØÂ¢É unsigned env_status; // Status of the environment ÂâçÈù¢ÂÆö‰πâÁöÑÈÇ£Âá†‰∏™Áä∂ÊÄÅ uint32_t env_runs; // Number of times environment has run ËøêË°åÁöÑÊ¨°Êï∞ // Address space pde_t *env_pgdir; // Kernel virtual address of page dir Ëøô‰∏™ÂèòÈáèÂ≠òÊîæÁùÄËøô‰∏™ÁéØÂ¢ÉÁöÑÈ°µÁõÆÂΩïÁöÑËôöÊãüÂú∞ÂùÄ&#125;;#endif // !JOS_INC_ENV_H ÂàÜÊûêÂÆåÂêéÔºåÂ∞±ÂéªÁúã kern/env.c„ÄÇËøô‰∏™Êñá‰ª∂ÂÖà‰∏çÁúãÂÆåÔºåÂ∞±ÁúãÁúã‰ªñÂÆö‰πâ‰∫Ü‰ªÄ‰πà‰∏úË•ø„ÄÇ123struct Env *envs = NULL; // All environments ÊâÄÊúâÁöÑÁéØÂ¢Éstruct Env *curenv = NULL; // The current env ÂΩìÂâçÁéØÂ¢Éstatic struct Env *env_free_list; // Free environment list Á©∫Èó≤ÁéØÂ¢ÉÂàóË°® ÂêéÈù¢Êúâ‰∏ÄÂ§ßÂ†Ü‰ªãÁªç„ÄÇTrapframeËøô‰∏™ÈáåÈù¢ÂÖ∑‰ΩìÊúâÂï•ÔºåÊàë‰ª¨ÂêéÈù¢Áî®Âà∞ÁöÑÊó∂ÂÄôÂÜçÁúã„ÄÇ Allocating the Environments ArrayÂâç‰∏§‰∏™ ÁªìÊûÑ‰ΩìÔºåÂú®kern/env.h ÈáåÈù¢ÊúâËøõË°åÊâ©Â±ïÔºåÁé∞Âú®ÁªÉ‰π†ËÆ©Êàë‰ª¨Ôºå‰∏∫‰ªñÂàÜÈÖç‰∏Ä‰∏™Á©∫Èó¥Âπ∂Êò†Â∞ÑÔºåÂ∞±ÊòØÂÉè‰∏äÊ¨°‰∏∫kern_pagesÂàÜÈÖçÁ©∫Èó¥‰∏ÄÊ†∑ÔºåÂπ∂ËøõË°åÊò†Â∞Ñ„ÄÇ12345//////////////////////////////////////////////////////////////////////// Make 'envs' point to an array of size 'NENV' of 'struct Env'.// LAB 3: Your code here.envs=(struct Env*)boot_alloc(NENV*sizeof(struct Env));memset(envs,0,NENV*sizeof(struct Env)); Ëøô‰∏™ ÂíåÔºå‰∏äÊ¨°ÂÆûÈ™åÊòØ‰∏ÄÊ†∑ÁöÑÔºåÂíåÂàÜÈÖçkern_pgdirÊòØ‰∏ÄÊ®°‰∏ÄÊ†∑ÁöÑ„ÄÇ12345678//////////////////////////////////////////////////////////////////////// Map the 'envs' array read-only by the user at linear address UENVS// (ie. perm = PTE_U | PTE_P).// Permissions:// - the new image at UENVS -- kernel R, user R// - envs itself -- kernel RW, user NONE// LAB 3: Your code here.boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U); Âè¶Â§ñÂÜçÂ§ç‰π†‰∏Ä‰∏ã‰∏äËäÇËØæÁöÑÂÜÖÂ≠òÂàÜÈÖç (‰∏ãÈù¢ÂèàÊòØÁõóÁöÑÂõæÔºåÂìàÂìà~ )„ÄÇ Creating and Running EnvironmentsÁé∞Âú®‰Ω†ÈúÄË¶ÅÂéªÁºñÂÜô kern/env.c Êñá‰ª∂Êù•ËøêË°å‰∏Ä‰∏™Áî®Êà∑ÁéØÂ¢É‰∫Ü„ÄÇÁî±‰∫é‰Ω†Áé∞Âú®Ê≤°ÊúâÊñá‰ª∂Á≥ªÁªüÔºåÊâÄ‰ª•ÂøÖÈ°ªÊääÂÜÖÊ†∏ËÆæÁΩÆÊàêËÉΩÂ§üÂä†ËΩΩÂÜÖÊ†∏‰∏≠ÁöÑÈùôÊÄÅ‰∫åËøõÂà∂Á®ãÂ∫èÊò†ÂÉèÊñá‰ª∂„ÄÇLab3 ÈáåÈù¢ÁöÑ GNUmakefile Êñá‰ª∂Âú®obj/user/ÁõÆÂΩï‰∏ãÈù¢ÁîüÊàê‰∫Ü‰∏ÄÁ≥ªÂàóÁöÑ‰∫åËøõÂà∂Êò†ÂÉèÊñá‰ª∂„ÄÇÂ¶ÇÊûú‰Ω†Áúã‰∏Ä‰∏ã kern/Makefrag Êñá‰ª∂Ôºå‰Ω†‰ºöÂèëÁé∞‰∏Ä‰∫õÂ•áÂ¶ôÁöÑÂú∞ÊñπÔºåËøô‰∫õÂú∞ÊñπÊää‰∫åËøõÂà∂Êñá‰ª∂Áõ¥Êé•ÈìæÊé•Âà∞ÂÜÖÊ†∏ÂèØÊâßË°åÊñá‰ª∂‰∏≠ÔºåÂè™Ë¶ÅËøô‰∫õÊñá‰ª∂ÊòØ.oÊñá‰ª∂„ÄÇÂÖ∂‰∏≠Âú®ÈìæÊé•Âô®ÂëΩ‰ª§Ë°å‰∏≠ÁöÑ-b binary ÈÄâÈ°π‰ºö‰ΩøËøô‰∫õÊñá‰ª∂Ë¢´ÂΩìÂÅö‰∫åËøõÂà∂ÊâßË°åÊñá‰ª∂ÈìæÊé•Âà∞ÂÜÖÊ†∏‰πãÂêé„ÄÇÂú®kern/ini.c‰∏≠ÁöÑi386_init(),‰Ω†‰ºöÁúãÂà∞‰ª£Á†ÅËøêË°åÁöÑÁéØÂ¢É‰∏≠ÔºåËøô‰∫õ‰∫åËøõÂà∂ÂõæÂÉè‰πã‰∏Ä„ÄÇÁÑ∂ËÄåÔºåÂÖ≥ÈîÆÁöÑÂäüËÉΩËÆæÁΩÆÁî®Êà∑ÁéØÂ¢ÉÊòØ‰∏çÂÆåÊï¥ÁöÑ;ÊÇ®ÈúÄË¶ÅÂ°´ÂÜô‰ªñ‰ª¨ËøõÊù•„ÄÇÊàë‰ª¨ÁÖßÁùÄ‰ªñÁöÑÊÑèÊÄùÂéªÁúãÁúãÔºåÂèëÁé∞Áõ∏ËæÉ‰∫éÂâçÂá†Ê¨°ÂÆûÈ™åÔºåÂ§ö‰∫ÜÂá†Ë°å„ÄÇ1234567891011121314 // Lab 3 user environment initialization functions env_init(); trap_init();#if defined(TEST) // Don't touch -- used by grading script! Ëøô‰∫õ‰∏çË¶ÅÁ¢∞ÔºåÊòØ‰ªéÊù•ÊµãËØïÁöÑ ENV_CREATE(TEST, ENV_TYPE_USER); //env_create#else // Touch all you want. ENV_CREATE(user_hello, ENV_TYPE_USER);#endif // TEST* // We only have one user environment for now, so just run it. env_run(&amp;envs[0]); Âú® kern/env.h ÈáåÈù¢ÂèØ‰ª•ÁúãËßÅËøô‰∏™ÂÆèÁöÑÂéüÂûãÔºåÂ∞±ÂΩì‰ªñËøêË°å‰∫ÜÂá†‰∏™‰∏çÂêåÁöÑÊµãËØïÂêß„ÄÇÊàëÊ≤°ÊâæÂà∞ËøôÂá†‰∏™Âú®Âì™„ÄÇ12345678#define ENV_PASTE3(x, y, z) x ## y ## z#define ENV_CREATE(x, type) \ do &#123; \ extern uint8_t ENV_PASTE3(_binary_obj_, x, _start)[]; \ env_create(ENV_PASTE3(_binary_obj_, x, _start), \ type); \ &#125; while (0) ‰∏çÂá∫ÊÑèÂ§ñÔºåÊàë‰ª¨ÁöÑ‰ªªÂä° Â∞±ÊòØË°•ÂÖÖÂ§öÂá∫Êù•ÁöÑËøôÂá†‰∏™ÂáΩÊï∞‰∫Ü„ÄÇ env_init(): ÂàùÂßãÂåñÊâÄÊúâÁöÑÂú®envsÊï∞ÁªÑ‰∏≠ÁöÑ EnvÁªìÊûÑ‰ΩìÔºåÂπ∂ÊääÂÆÉ‰ª¨Âä†ÂÖ•Âà∞ env_free_list‰∏≠„ÄÇ ËøòË¶ÅË∞ÉÁî® env_init_percpuÔºåËøô‰∏™ÂáΩÊï∞Ë¶ÅÈÖçÁΩÆÊÆµÂºèÂÜÖÂ≠òÁÆ°ÁêÜÁ≥ªÁªüÔºåËÆ©ÂÆÉÊâÄÁÆ°ÁêÜÁöÑÊÆµÔºåÂèØËÉΩÂÖ∑Êúâ‰∏§ÁßçËÆøÈóÆ‰ºòÂÖàÁ∫ßÂÖ∂‰∏≠ÁöÑ‰∏ÄÁßçÔºå‰∏Ä‰∏™ÊòØÂÜÖÊ†∏ËøêË°åÊó∂ÁöÑ0‰ºòÂÖàÁ∫ßÔºå‰ª•ÂèäÁî®Êà∑ËøêË°åÊó∂ÁöÑ3‰ºòÂÖàÁ∫ß„ÄÇ env_setup_vm(): ‰∏∫‰∏Ä‰∏™Êñ∞ÁöÑÁî®Êà∑ÁéØÂ¢ÉÂàÜÈÖç‰∏Ä‰∏™È°µÁõÆÂΩïË°®ÔºåÂπ∂‰∏îÂàùÂßãÂåñËøô‰∏™Áî®Êà∑ÁéØÂ¢ÉÁöÑÂú∞ÂùÄÁ©∫Èó¥‰∏≠ÁöÑÂíåÂÜÖÊ†∏Áõ∏ÂÖ≥ÁöÑÈÉ®ÂàÜ„ÄÇ region_alloc(): ‰∏∫Áî®Êà∑ÁéØÂ¢ÉÂàÜÈÖçÁâ©ÁêÜÂú∞ÂùÄÁ©∫Èó¥ load_icode(): ÂàÜÊûê‰∏Ä‰∏™ELFÊñá‰ª∂ÔºåÁ±ª‰ºº‰∫éboot loaderÂÅöÁöÑÈÇ£Ê†∑ÔºåÊàë‰ª¨ÂèØ‰ª•ÊääÂÆÉÁöÑÂÜÖÂÆπÂä†ËΩΩÂà∞Áî®Êà∑ÁéØÂ¢É‰∏ã„ÄÇ env_create(): Âà©Áî®env_allocÂáΩÊï∞Âíåload_icodeÂáΩÊï∞ÔºåÂä†ËΩΩ‰∏Ä‰∏™ELFÊñá‰ª∂Âà∞Áî®Êà∑ÁéØÂ¢É‰∏≠ env_run(): Âú®Áî®Êà∑Ê®°Âºè‰∏ãÔºåÂºÄÂßãËøêË°å‰∏Ä‰∏™Áî®Êà∑ÁéØÂ¢É„ÄÇ Áé∞Âú®ÂºÄÂßãÔºåË°•ÂÖÖkern/env.c, env_init()12345678910111213141516171819202122// Mark all environments in 'envs' as free, set their env_ids to 0,// and insert them into the env_free_list. ÊääÊâÄÊúâenv Âä†ÂÖ• Á©∫Èó≤ÂàóË°®ÔºåÁÑ∂ÂêéËÆæÁΩÆ id=0// Make sure the environments are in the free list in the same order// they are in the envs array (i.e., so that the first call to// env_alloc() returns envs[0]). Â∞±ÊòØÈ°∫Â∫è‰ªé 0 ÈÄíÂ¢û //voidenv_init(void)&#123; // Set up envs array // LAB 3: Your code here. //‰∏äÈù¢ÂàÜÊûêËøá Ë¶Å‰ªé0 ÂºÄÂßãÔºåÊâÄ‰ª•Êàë‰ª¨ÂÄíÁùÄÈÅçÂéÜ„ÄÇ env_free_list=NULL; for (size_t i=NENV-1;i&gt;=0;i--)&#123; envs[i]-&gt;env_id=0; envs[i]-&gt;env_status=ENV_FREE; envs[i]-&gt;env_link=env_free_list; env_free_list=&amp;envs[i]; &#125; // Per-CPU part of the initialization env_init_percpu();&#125; Âú®env_init() ‰∏≠Ë∞ÉÁî®‰∫Üenv_init_percpu() ‰∏çÁü•ÈÅìËøô‰∏™ÊòØÂπ≤Âï•ÁöÑ„ÄÇÊ†πÊçÆÊ≥®ÈáäÔºåÊòØÂàùÂßãÂåñ‰∫ÜGDTÂíåÊÆµÊèèËø∞Á¨¶„ÄÇ1234567891011121314151617181920// Load GDT and segment descriptors.voidenv_init_percpu(void)&#123; lgdt(&amp;gdt_pd); // The kernel never uses GS or FS, so we leave those set to // the user data segment. asm volatile("movw %%ax,%%gs" : : "a" (GD_UD|3)); asm volatile("movw %%ax,%%fs" : : "a" (GD_UD|3)); // The kernel does use ES, DS, and SS. We'll change between // the kernel and user data segments as needed. asm volatile("movw %%ax,%%es" : : "a" (GD_KD)); asm volatile("movw %%ax,%%ds" : : "a" (GD_KD)); asm volatile("movw %%ax,%%ss" : : "a" (GD_KD)); // Load the kernel text segment into CS. asm volatile("ljmp %0,$1f\n 1:\n" : : "i" (GD_KT)); // For good measure, clear the local descriptor table (LDT), // since we don't use it. lldt(0);&#125; env_setup_vm()ÂàùÂßãÂåñÂÆå ‰πãÂêéÔºåÂõ†‰∏∫trap()ÊòØ‰∏ã‰∏Ä‰∏™ÁöÑÊöÇÊó∂‰∏çÁî®ÁÆ°ÔºåÊâÄ‰ª•Êàë‰ª¨Áõ¥Êé•Ë∑≥Âà∞create_envÔºåÂàõÂª∫Ëøô‰∏™Á¨¨‰∏Ä‰∏™Ë¶ÅÂπ≤ÁöÑËÇØÂÆöÊòØÂàÜÈÖçÂÜÖÂ≠ò,ÊúÄÂºÄÂßãË¶ÅÂÅöÁöÑÊòØÂàÜÈÖç‰∏Ä‰∏™È°µÁõÆÂΩï„ÄÇËøô‰∏™È°µÁõÆÂΩïÔºåËÇØÂÆöÊòØË¶ÅÂ§çÂà∂ÂÜÖÊ†∏ÁöÑ‰∏ÄÈÉ®ÂàÜÔºåÂõ†‰∏∫ÂÜÖÊ†∏ÈÇ£‰∏ÄÈÉ®ÂàÜÔºå‰Ω†ÊòØÁªùÂØπ‰∏çËÉΩÂä®ÁöÑ„ÄÇ1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//// Initialize the kernel virtual memory layout for environment e. ÂàùÂßãÂåñÂÜÖÊ†∏ËôöÊãüÂ∏ÉÂ±Ä// Allocate a page directory, set e-&gt;env_pgdir accordingly, ÂàÜÈÖç‰∏Ä‰∏™È°µÁõÆÂΩïÁªôe-&gt;env_pgdir// and initialize the kernel portion of the new environment's address space// Do NOT (yet) map anything into the user portion// of the environment's virtual address space.//ÂàùÂßãÂåñÂÜÖÊ†∏ÈÉ®ÂàÜÔºå‰∏çÁî®Êò†Â∞Ñ Áî®Êà∑ÈÉ®ÂàÜ„ÄÇ// Returns 0 on success, &lt; 0 on error. Errors include:// -E_NO_MEM if page directory or table could not be allocated.//ÊàêÂäüËøîÂõû 0 Âê¶ÂàôËøîÂõû -E_NO_MEMstatic intenv_setup_vm(struct Env *e)&#123; int i; struct PageInfo *p = NULL; // Allocate a page for the page directory ÂàÜÈÖç‰∫Ü‰∏Ä‰∏™È°µÁõÆÂΩï if (!(p = page_alloc(ALLOC_ZERO))) return -E_NO_MEM; // Now, set e-&gt;env_pgdir and initialize the page directory. //Áé∞Âú®ËÆæÁΩÆ e-&gt;env_pgdir ÁÑ∂ÂêéÂàùÂßãÂåñÈ°µÈù¢ÁõÆÂΩï // Hint: // - The VA space of all envs is identical above UTOP // (except at UVPT, which we've set below).va ÊâÄÊúâ envs ÁöÑËôöÊãüÂú∞ÂùÄ ÈÉΩÊòØÁõ∏ÂêåÁöÑÂú®UTOP‰∏äÈù¢ // See inc/memlayout.h for permissions and layout. // Can you use kern_pgdir as a template? Hint: Yes. ÂèØ‰ª•Áî®kern_pgdirÂÅö‰∏Ä‰∏™Ê®°Êùø // (Make sure you got the permissions right in Lab 2.) // - The initial VA below UTOP is empty. ÂàùÂßãÂåñ ËôöÊãüÂú∞ÂùÄÂú® UTOP ÊòØÁ©∫ÁöÑ // - You do not need to make any more calls to page_alloc. ‰Ω†‰∏çÈúÄË¶ÅÂéªÂÅö‰ªª‰ΩïÁöÑpage_alloc // - Note: In general, pp_ref is not maintained for // physical pages mapped only above UTOP, but env_pgdir // is an exception -- you need to increment env_pgdir's // pp_ref for env_free to work correctly. // - The functions in kern/pmap.h are handy. // Ëá™Â∑±ÁøªËØëÂêßÔºåÂè™ÂèØÊÑè‰ºö‰∏çÂèØË®Ä‰º† // LAB 3: Your code here. p-&gt;pp_ref++; e-&gt;env_pgdir=(pde_t *)page2kva(p); memcpy(e-&gt;env_pgdir, kern_pgdir, PGSIZE); // UVPT maps the env's own page table read-only. // Permissions: kernel R, user R e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U; return 0;&#125; region_allocÂàÜÈÖçÂÆåÈ°µÁõÆÂΩïÔºåÁÑ∂ÂêéÂ∞±ÊòØË¶ÅÁªôÁî®Êà∑ÂàõÂª∫Á©∫Èó¥„ÄÇÂè™Êúâ‰∏Ä‰∏™È°µÁõÆÂΩïÔºåËÇØÂÆöÊòØ‰∏çË°åÁöÑÔºå‰Ω†ÂøÖÈ°ªË¶ÅÁªôÁî®Êà∑Á®ãÂ∫è‰ΩøÁî®ÁöÑÁ©∫Èó¥„ÄÇ123456789101112131415161718192021222324252627282930//// Allocate len bytes of physical memory for environment env,// and map it at virtual address va in the environment's address space.// Does not zero or otherwise initialize the mapped pages in any way.// Pages should be writable by user and kernel.// Panic if any allocation attempt fails.//ÂàÜÈÖçlen Â≠óËäÇÁöÑ Áâ©ÁêÜÁ©∫Èó¥Áªô Áî®Êà∑ÁéØÂ¢ÉenvÔºåÊò†Â∞Ñ‰ªñÁöÑËôöÊãüÂú∞ÂùÄÂú®ÁéØÂ¢ÉÁöÑÂú∞ÂùÄÁ©∫Èó¥Ôºå‰∏çË¶ÅÁî®‰ªª‰ΩïÊñπÂºèÂàùÂßãÂåñÈ°µÈù¢„ÄÇÊùÉÈôêÊòØÂÜÖÊ†∏Áî®Êà∑ÂèØÂÜôÔºåÂá∫ÈîôÂ∞± panicstatic voidregion_alloc(struct Env *e, void *va, size_t len)&#123; // LAB 3: Your code here. // (But only if you need it for load_icode.) // // Hint: It is easier to use region_alloc if the caller can pass // 'va' and 'len' values that are not page-aligned. // You should round va down, and round (va + len) up. // (Watch out for corner-cases!) void *start=ROUNDDOWN(va,PGSIZE),*end=ROUNDUP(va+len,PGSIZE); for (void * addr=start;addr&lt;end;addr+=PGSIZE)&#123; struct PageInfo* p=page_alloc(0); if(p==NULL)&#123; panic("region alloc failed: No more page to be allocated.\n"); &#125; else &#123; if(page_insert(e-&gt;env_pgdir,p,addr, PTE_U | PTE_W)==-E_NO_MEM)&#123; panic("region alloc failed: page table couldn't be allocated.\n"); &#125; &#125; &#125;&#125; ÂÜô‰∏™ÂáΩÊï∞‰πãÂâçÔºåÊàë‰ª¨ÂÖàÂéªÁúãÁúãtrap.h load_icodeÂõ†‰∏∫ÁõÆÂâçÂπ∂Ê≤°ÊúâÊñá‰ª∂Á≥ªÁªüÔºåÊâÄ‰ª•Êàë‰ª¨Ë¶ÅÈúÄË¶ÅÂàÜÈÖçÁöÑÂ†ÜÊ†àÔºåÂπ∂‰∏çÊòØÊù•Ëá™Êñá‰ª∂Âä†ËΩΩÂá∫Êù•ÁöÑ„ÄÇ‰∏∫‰∫ÜÊñπ‰æøÂÆûÈ™åÔºåJOSËÆ©Êàë‰ª¨ÂÉèÂä†ËΩΩÊìç‰ΩúÁ≥ªÁªü‰∏ÄÊ†∑Âä†ËΩΩËøô‰∫õÊñá‰ª∂„ÄÇËøô‰∏™ÈáåÈù¢Áî®Âà∞‰∫ÜTrapframe,ÊàëÂéªÁúã‰∫ÜÁúãËøô‰∏™‰∏úË•øÔºåÂØπ‰∫éÊüê‰∏™Â≠óÊÆµÊòØÂπ≤Âï•ÁöÑÂÆåÂÖ®Ê≤°ÊúâÊ≥®ÈáäÊâÄ‰ª•Êàë‰πü‰∏çÁü•ÈÅìËØ•ÂàÜÊûê„ÄÇ1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//// Set up the initial program binary, stack, and processor flags// for a user process. ÂàùÂßãÂåñËøõÁ®ãÁöÑ ‰∫åËøõÂà∂ Ê†à Âíå Â§ÑÁêÜÂô®// This function is ONLY called during kernel initialization,// before running the first user-mode environment.//Ëøô‰∏™Á®ãÂ∫èÂè™ËÉΩË∞ÉÁî®Âú®ÂÜÖÊ†∏ÂàùÂßãÂåñÔºåÂú®ËøêË°åÁ¨¨‰∏Ä‰∏™Áî®Êà∑Ê®°ÂºèÁéØÂ¢É// This function loads all loadable segments from the ELF binary image// into the environment's user memory, starting at the appropriate// virtual addresses indicated in the ELF program header. Âä†ËΩΩÊâÄÊúâÁöÑ ÂèØË£ÖËΩΩÁ®ãÂ∫è ‰ªé ELF‰∫åËøõÂà∂Êò†Ë±°Êñá‰ª∂Âà∞ÂÜÖÂ≠òÔºåÂºÄÂßãÂú®ÈÄÇÂΩìÁöÑËôöÊãüÂú∞ÂùÄÂú®ELF ÁöÑÂ§¥ÈÉ®// At the same time it clears to zero any portions of these segments ÊÆµ‰∏≠‰ªª‰ΩïÈÉ®ÂàÜÂàùÂßãÂåñ‰∏∫0// that are marked in the program header as being mapped// but not actually present in the ELF file - i.e., the program's bss section.//// All this is very similar to what our boot loader does, except the boot// loader also needs to read the code from disk. Take a look at// boot/main.c to get ideas. ÂæàÂÉèboot loader ÂÅöÁöÑÔºåÂèØ‰ª•ÂèÇËÄÉ//// Finally, this function maps one page for the program's initial stack.//Ëøô‰∏™ÂáΩÊï∞Êò†Â∞Ñ‰∏Ä‰∏™È°µ‰∏∫‰∫ÜÂàùÂßãÂåñÂ†ÜÊ†à// load_icode panics if it encounters problems.// - How might load_icode fail? What might be wrong with the given input?//static voidload_icode(struct Env *e, uint8_t *binary)&#123; // Hints: // Load each program segment into virtual memory // at the address specified in the ELF segment header.Âä†ËΩΩÊØè‰∏™Á®ãÂ∫èÊÆµÂà∞ËôöÊãüÂÜÖÂ≠ò Âú® ÂÖ∑‰ΩìÁöÑELF Â§¥Êñá‰ª∂ // You should only load segments with ph-&gt;p_type == ELF_PROG_LOAD. Âè™ÈúÄË¶ÅÂä†ËΩΩph-&gt;p_type == ELF_PROG_LOAD // Each segment's virtual address can be found in ph-&gt;p_va ÊØè‰∏™ÊÆµÁöÑËôöÊãüÂú∞ÂùÄÂèØ‰ª•Âú®ph-&gt;p_vaÊâæÂà∞ // and its size in memory can be found in ph-&gt;p_memsz. Â§ßÂ∞èÊòØ ph-&gt;p_memsz // The ph-&gt;p_filesz bytes from the ELF binary, starting at Êñá‰ª∂ÂºÄÂßãÂú®binary + ph-&gt;p_offsetÔºåÂ∫îËØ•Ë¢´Â§çÂà∂Âà∞ ËôöÊãüÂú∞ÂùÄ ph-&gt;p_va„ÄÇ // 'binary + ph-&gt;p_offset', should be copied to virtual address // ph-&gt;p_va. Any remaining memory bytes should be cleared to zero.ÂÖ∂‰ªñÂâ©‰∏ãÁöÑÁ©∫Èó¥ÂàùÂßãÂåñ‰∏∫0 // (The ELF header should have ph-&gt;p_filesz &lt;= ph-&gt;p_memsz.) Â§¥ÈÉ®Êñá‰ª∂Â∫îËØ• ph-&gt;p_filesz &lt;= ph-&gt;p_memsz // Use functions from the previous lab to allocate and map pages. //‰ΩøÁî®Ëøô‰∏™ÂâçÈù¢ÊâÄÂÜôÁöÑÂáΩÊï∞ // All page protection bits should be user read/write for now. ÊâÄÊúâÈ°µÈÉΩÊòØÁî®Êà∑ÂèØËØªÂÜôÁöÑ // ELF segments are not necessarily page-aligned, but you can ELF ÊÆµÂèØËÉΩ‰∏çÊòØÈ°µÂØπÈΩê„ÄÇ // assume for this function that no two segments will touch // the same virtual page.ÂÅáËÆæËøô‰∏™ÂáΩÊï∞ ‰∏ç‰ºö‰∏§‰∏™ÊÆµÂú®Âêå‰∏Ä‰∏™ËôöÊãüÈ°µ // // You may find a function like region_alloc useful. ‰Ω†ÂèØ‰ª•ÂèëÁé∞ region_allocÊòØÊúâÁî®ÁöÑ // // Loading the segments is much simpler if you can move data // directly into the virtual addresses stored in the ELF binary. // So which page directory should be in force during // this function? Â¶ÇÊûú‰Ω†ÂèØ‰ª•Áõ¥Êé•ÁßªÂä®Êï∞ÊçÆÂ≠òÂà∞ELF Â∫èÂàóÈáåÈù¢ Êû∂Â≠êÊÆµÂ∞±ÂæàÂÆπÊòìÔºåÊâÄ‰ª• È°µÁõÆÂΩïÂ∫îÂΩì‰ΩøÁî®Âú®Ëøô‰∏™ÂáΩÊï∞ // // You must also do something with the program's entry point, // to make sure that the environment starts executing there. // What? (See env_run() and env_pop_tf() below.) // ‰Ω†ÂøÖÈ°ªÂØπÁ®ãÂ∫èÂÖ•Âè£ÊåáÈíàÂÅöÁÇπ‰ªÄ‰πà Á°Æ‰øù ÂêéÈù¢Áî®ÁöÑ‰∏ä„ÄÇ // LAB 3: Your code here. //Ê†πÊçÆÔºåÂàÜÊûê È¶ñÂÖàÈúÄË¶ÅÂÅöÁöÑ‰∏Ä‰ª∂‰∫ã Â∫îËØ•ÊòØËÆ≤binary ËΩ¨Êç¢Êàê ELFÔºåÂèÇÁÖßbootmain„ÄÇ struct Proghdr *ph, *eph; struct Elf * ELF=(struct Elf *)binary; if (ELFHDR-&gt;e_magic != ELF_MAGIC)panic("The loaded file is not ELF format!\n"); ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR-&gt;e_phoff); eph = ph + ELFHDR-&gt;e_phnum; //Ë£ÖËΩΩ Áî®Êà∑ÁõÆÂΩï lcr3(PADDR(e-&gt;env_pgdir)); //Á¨¨‰∫åÈÉ®Â∫îËØ•ÊòØÂä†ËΩΩÊÆµÂà∞ÂÜÖÂ≠ò for(;ph&lt;eph;ph++)&#123; //Âä†ËΩΩÊù°‰ª∂ÊòØ ph-&gt;p_type == ELF_PROG_LOADÔºåÂú∞ÂùÄÊòØ ph-&gt;p_va Â§ßÂ∞èph-&gt;p_memsz if(ph-&gt;p_type == ELF_PROG_LOAD)&#123; if (ph-&gt;p_filesz &gt; ph-&gt;p_memsz) panic("load_icode failed: p_memsz &lt; p_filesz.\n"); region_alloc(e, ph-&gt;p_va,ph-&gt;p_memsz); //Â§çÂà∂ph-&gt;p_filesz bytes ÔºåÂÖ∂‰ªñÁöÑË°•0 memset(ph-&gt;p_va,0,ph-&gt;p_memsz); memcpy(ph-&gt;p_va,binary + ph-&gt;p_offset,ph-&gt;p_filesz); &#125; &#125; lcr3(PADDR(kern_pgdir)); //ÊúÄÂêéÊòØÂÖ•Âè£Âú∞ÂùÄ Ëøô‰∏™ÂÆûÂú® inc/trap.h ÈáåÈù¢ÂÆö‰πâÁöÑ e-&gt;env_tf.tf_eip = ELFHDR-&gt;e_entry; // Now map one page for the program's initial stack // at virtual address USTACKTOP - PGSIZE. Ëøô‰∏™ÂáΩÊï∞ÂàöÂÜôËøá // LAB 3: Your code here. gion_alloc(e, (void *)(USTACKTOP - PGSIZE), PGSIZE);&#125; Âú®ÂÜôenc_creat‰πãÂâçÔºåÊàë‰ª¨ÂÖàÊù•ÂàÜÊûê‰∏Ä‰∏ãÔºåÊàë‰ª¨Âπ∂‰∏çÈúÄË¶ÅÂÜô env_allocÔºåËøô‰∏™ÂáΩÊï∞‰Ω†ÂèØ‰ª•ÁêÜËß£‰∏∫ÂàùÂßãÂåñ‰∏Ä‰∏™env„ÄÇ Êàë‰ª¨‰∏çÈúÄË¶ÅÁü•ÈÅìËøáÂàÜÁöÑÁªÜËäÇÔºå‰ΩÜÊòØÈúÄË¶Å‰∫ÜËß£‰ªñÂÅö‰∫Ü‰ªÄ‰πà„ÄÇ env_alloc1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//// Allocates and initializes a new environment.// On success, the new environment is stored in *newenv_store.// ÂàÜÈÖç‰∫Ü‰∏Ä‰∏™Êñ∞ÁöÑ ÁéØÂ¢ÉÔºåÊàêÂäü Â∞±Â≠òÂú®‰∫Ü *newenv_store// Returns 0 on success, &lt; 0 on failure. Errors include: Â§±Ë¥•ËøîÂõû‰∏§Áßç// -E_NO_FREE_ENV if all NENV environments are allocated// -E_NO_MEM on memory exhaustion//intenv_alloc(struct Env **newenv_store, envid_t parent_id)&#123; int32_t generation; int r; struct Env *e; //È¶ñÂÖàÂà§Êñ≠Á©∫Èó≤ ÁéØÂ¢É if (!(e = env_free_list)) return -E_NO_FREE_ENV; //ËÆæÁΩÆÈ°µÁõÆÂΩï // Allocate and set up the page directory for this environment. if ((r = env_setup_vm(e)) &lt; 0) return r; // Generate an env_id for this environment. ËÆæÁΩÆ env_id generation = (e-&gt;env_id + (1 &lt;&lt; ENVGENSHIFT)) &amp; ~(NENV - 1); if (generation &lt;= 0) // Don't create a negative env_id. generation = 1 &lt;&lt; ENVGENSHIFT; e-&gt;env_id = generation | (e - envs); // Set the basic status variables. ËÆæÁΩÆÂü∫Á°Ä‰ø°ÊÅØ e-&gt;env_parent_id = parent_id; e-&gt;env_type = ENV_TYPE_USER; e-&gt;env_status = ENV_RUNNABLE; e-&gt;env_runs = 0; // Clear out all the saved register state, // to prevent the register values // of a prior environment inhabiting this Env structure // from "leaking" into our new environment. Ê∏ÖÁ©∫ÂØÑÂ≠òÂô®Áä∂ÊÄÅ memset(&amp;e-&gt;env_tf, 0, sizeof(e-&gt;env_tf)); // Set up appropriate initial values for the segment registers. // GD_UD is the user data segment selector in the GDT, and // GD_UT is the user text segment selector (see inc/memlayout.h). // The low 2 bits of each segment register contains the // Requestor Privilege Level (RPL); 3 means user mode. When // we switch privilege levels, the hardware does various // checks involving the RPL and the Descriptor Privilege Level // (DPL) stored in the descriptors themselves. ËÆæÁΩÆÂàùÂßãÂÄº e-&gt;env_tf.tf_ds = GD_UD | 3; e-&gt;env_tf.tf_es = GD_UD | 3; e-&gt;env_tf.tf_ss = GD_UD | 3; e-&gt;env_tf.tf_esp = USTACKTOP; e-&gt;env_tf.tf_cs = GD_UT | 3; // You will set e-&gt;env_tf.tf_eip later. Ëøô‰∏™ÂæàÁúºÁÜüÂêßÔºåÂ∞±ÊòØ‰∏ä‰∏™ÂáΩÊï∞Áî®ÁöÑÔºåËøô‰∏™Â∞±ÊòØÂÖ•Âè£Âú∞ÂùÄ // commit the allocation Á©∫Èó≤ÁéØÂ¢É ÊåáÂêëÂè¶‰∏Ä‰∏™„ÄÇ env_free_list = e-&gt;env_link; *newenv_store = e; cprintf("[%08x] new env %08x\n", curenv ? curenv-&gt;env_id : 0, e-&gt;env_id); return 0;&#125; env_createÂáΩÊï∞‰ΩúÁî®Â∞±ÊòØÊ†πÊçÆbinary ÂàõÂª∫‰∏Ä‰∏™env „ÄÇ1234567891011121314151617181920//// Allocates a new env with env_alloc, loads the named elf// binary into it with load_icode, and sets its env_type.// This function is ONLY called during kernel initialization,// before running the first user-mode environment.// The new env's parent ID is set to 0.// ÂàÜÈÖç‰∏Ä‰∏™Êñ∞ÁöÑenv ÈÄöËøáenv_alloc Âä†ËΩΩelfÔºåËÆæÁΩÆ‰ªñÁöÑits env_type Ëøô‰∏™ÂáΩÊï∞Âè™Âú®ÂÜÖÊ†∏ÂàùÂßãÂåñÊäµÁî®ÔºåÂú®Ë∑ëÁ¨¨‰∏Ä‰∏™Áî®Êà∑ÁéØÂ¢ÉÔºåÁà∂‰∫≤ËÆæÁΩÆ‰∏∫ 0voidenv_create(uint8_t *binary, enum EnvType type)&#123; // LAB 3: Your code here. struct Env * e; int r=env_alloc(&amp;e,0); if(r!=0)&#123; cprintf("%e\n",r); panic("env_create:error"); &#125; load_icode(e,binary); e-&gt;env_type=type;&#125; env_runËøô‰∏™Â∞±ÊòØÁúüÊ≠£ÁöÑÁî®Êà∑ÁéØÂ¢ÉËøêË°å‰∫Ü„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839/// Context switch from curenv to env e. ‰∏ä‰∏ãÊñáÂàáÊç¢Âà∞ e// Note: if this is the first call to env_run, curenv is NULL.//Â¶ÇÊûúÁ¨¨‰∏Ä‰∏™Ë∞ÉÁî® curenv ÊòØÁ©∫ÁöÑ// This function does not return.//voidenv_run(struct Env *e)&#123; // Step 1: If this is a context switch (a new environment is running): Â¶ÇÊûúÊúâ‰∏ä‰∏ãÊñáÂàáÊç¢ // 1. Set the current environment (if any) back to Á¨¨‰∏ÄÊ≠•ÂΩìÂâçÁéØÂ¢É Â∞±Áª™Áä∂ÊÄÅ // ENV_RUNNABLE if it is ENV_RUNNING (think about // what other states it can be in), // 2. Set 'curenv' to the new environment, ÂΩìÂâçËøêË°åÂèòÊàê Êñ∞ÁöÑÁéØÂ¢É // 3. Set its status to ENV_RUNNING, ËÆæÁΩÆ‰ªñÁöÑÁä∂ÊÄÅ‰∏∫ ËøêË°å // 4. Update its 'env_runs' counter, Êõ¥Êñ∞ËÆ°Êï∞ // 5. Use lcr3() to switch to its address space. ‰øÆÊîπÂú∞ÂùÄÁ©∫Èó¥ // Step 2: Use env_pop_tf() to restore the environment's Á¨¨‰∫åÈÉ® ‰ΩøÁî®ÈÇ£‰∏™Âï•ÊÅ¢Â§çÁéØÂ¢É // registers and drop into user mode in the // environment. // Hint: This function loads the new environment's state from Ëøô‰∏™ÂáΩÊï∞ÈáçÊñ∞Âä†ËΩΩ Êñ∞ÁöÑÁî®Êà∑ËΩ¨Âè∞ ‰ªéÂï• // e-&gt;env_tf. Go back through the code you wrote above // and make sure you have set the relevant parts of // e-&gt;env_tf to sensible values. Á°Æ‰øù ÈÇ£‰∏™ÂìàÊòØ‰∏™ÁúüÁ°ÆÁöÑÂÄº // LAB 3: Your code here. if(curenv!=NULL&amp;&amp;curenv-&gt;env_status==ENV_RUNNING)&#123; curenv-&gt;env_status=ENV_RUNNABLE; &#125; curenv=e; // if(&amp;curenv-&gt;env_tf==NULL)cprintf("***"); e-&gt;env_status=ENV_RUNNING; e-&gt;env_runs++; lcr3(PADDR(curenv-&gt;env_pgdir)); cprintf("%x\n",curenv-&gt;env_tf.tf_eip); env_pop_tf(&amp;curenv-&gt;env_tf); panic("env_run not yet implemented");//Ëøô‰∏™Ê≥®Èáä‰∏çÊ≥®ÈáäÊ≤°Âï•ÂΩ±ÂìçÔºåÂõ†‰∏∫Êàë‰ª¨Áé∞Âú®Â∞±ËøêË°å‰∫Ü‰∏Ä‰∏™ envÔºå‰∏äÈù¢ÈÇ£‰∏™ÂáΩÊï∞Â∑≤ÁªèËΩ¨Áßª‰∫ÜÔºåÁ≠â‰ªñÂÜçÊù•ËøêË°åËøô‰∏ÄË°åÔºåËØ¥ÊòéÊï¥‰∏™Êìç‰ΩúÁ≥ªÁªüÂ∑≤ÁªèÁªìÊùü‰∫Ü„ÄÇ&#125; Êàë‰ª¨ÂÜçÂàÜÊûêÂàÜÊûêËøô‰∏™Êñá‰ª∂ÈáåÈù¢‰∏Ä‰∫õÂÖ∂‰ªñÁöÑÂáΩÊï∞„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//// Frees env e and all memory it uses.//voidenv_free(struct Env *e)&#123; pte_t *pt; uint32_t pdeno, pteno; physaddr_t pa; // If freeing the current environment, switch to kern_pgdir // before freeing the page directory, just in case the page // gets reused. if (e == curenv) lcr3(PADDR(kern_pgdir)); //ÂàáÊç¢Âà∞ÂÜÖÊ†∏ // Note the environment's demise. cprintf("[%08x] free env %08x\n", curenv ? curenv-&gt;env_id : 0, e-&gt;env_id);//ÊâìÂç∞‰ø°ÊÅØ // Flush all mapped pages in the user portion of the address space static_assert(UTOP % PTSIZE == 0); //Âà∑Êñ∞ÊâÄÊúâÊò†Â∞Ñ for (pdeno = 0; pdeno &lt; PDX(UTOP); pdeno++) &#123; // only look at mapped page tables if (!(e-&gt;env_pgdir[pdeno] &amp; PTE_P)) continue; // find the pa and va of the page table pa = PTE_ADDR(e-&gt;env_pgdir[pdeno]); pt = (pte_t*) KADDR(pa); // unmap all PTEs in this page table ÂèñÊ∂àÊâÄÊúâÊò†Â∞Ñ for (pteno = 0; pteno &lt;= PTX(~0); pteno++) &#123; if (pt[pteno] &amp; PTE_P) page_remove(e-&gt;env_pgdir, PGADDR(pdeno, pteno, 0)); &#125; // free the page table itself e-&gt;env_pgdir[pdeno] = 0; page_decref(pa2page(pa)); &#125; // free the page directory ÊääÈ°µÁõÆÂΩïÂà†Êéâ pa = PADDR(e-&gt;env_pgdir); e-&gt;env_pgdir = 0; page_decref(pa2page(pa)); // return the environment to the free list e-&gt;env_status = ENV_FREE; e-&gt;env_link = env_free_list; env_free_list = e;&#125;//// Frees environment e.//voidenv_destroy(struct Env *e)&#123; env_free(e); cprintf("Destroyed the only environment - nothing more to do!\n"); while (1) monitor(NULL);&#125;//// Restores the register values in the Trapframe with the 'iret' instruction.// This exits the kernel and starts executing some environment's code.//// This function does not return. //voidenv_pop_tf(struct Trapframe *tf) //Ëøô‰∏™Â∞±ÊòØË∑≥ËΩ¨Ôºå&#123; asm volatile( "\tmovl %0,%%esp\n" "\tpopal\n" "\tpopl %%es\n" "\tpopl %%ds\n" "\taddl $0x8,%%esp\n" /* skip tf_trapno and tf_errcode */ "\tiret\n" : : "g" (tf) : "memory"); panic("iret failed"); /* mostly to placate the compiler */&#125; ‰∏ÄÊó¶‰Ω†ÂÆåÊàê‰∏äËø∞Â≠êÂáΩÊï∞ÁöÑ‰ª£Á†ÅÔºåÂπ∂‰∏îÂú®QEMU‰∏ãÁºñËØëËøêË°åÔºåÁ≥ªÁªü‰ºöËøõÂÖ•Áî®Êà∑Á©∫Èó¥ÔºåÂπ∂‰∏îÂºÄÂßãÊâßË°åhelloÁ®ãÂ∫èÔºåÁõ¥Âà∞ÂÆÉÂÅöÂá∫‰∏Ä‰∏™Á≥ªÁªüË∞ÉÁî®Êåá‰ª§int„ÄÇ‰ΩÜÊòØËøô‰∏™Á≥ªÁªüË∞ÉÁî®Êåá‰ª§‰∏çËÉΩÊàêÂäüËøêË°åÔºåÂõ†‰∏∫Âà∞ÁõÆÂâç‰∏∫Ê≠¢ÔºåJOSËøòÊ≤°ÊúâËÆæÁΩÆÁõ∏ÂÖ≥Á°¨‰ª∂Êù•ÂÆûÁé∞‰ªéÁî®Êà∑ÊÄÅÂêëÂÜÖÊ†∏ÊÄÅÁöÑËΩ¨Êç¢ÂäüËÉΩ„ÄÇÂΩìCPUÂèëÁé∞ÔºåÂÆÉÊ≤°ÊúâË¢´ËÆæÁΩÆÊàêËÉΩÂ§üÂ§ÑÁêÜËøôÁßçÁ≥ªÁªüË∞ÉÁî®‰∏≠Êñ≠Êó∂ÔºåÂÆÉ‰ºöËß¶Âèë‰∏Ä‰∏™‰øùÊä§ÂºÇÂ∏∏ÔºåÁÑ∂ÂêéÂèëÁé∞Ëøô‰∏™‰øùÊä§ÂºÇÂ∏∏‰πüÊó†Ê≥ïÂ§ÑÁêÜÔºå‰ªéËÄåÂèà‰∫ßÁîü‰∏Ä‰∏™ÈîôËØØÂºÇÂ∏∏ÔºåÁÑ∂ÂêéÂèàÂèëÁé∞‰ªçÊóßÊó†Ê≥ïËß£ÂÜ≥ÈóÆÈ¢òÔºåÊâÄ‰ª•ÊúÄÂêéÊîæÂºÉÔºåÊàë‰ª¨ÊääËøô‰∏™Âè´ÂÅö‚Äùtriple fault‚Äù„ÄÇÈÄöÂ∏∏Êù•ËØ¥ÔºåÊé•‰∏ãÊù•CPU‰ºöÂ§ç‰ΩçÔºåÁ≥ªÁªü‰ºöÈáçÂêØ„ÄÇ ÊâÄ‰ª•Êàë‰ª¨È©¨‰∏äË¶ÅÊù•Ëß£ÂÜ≥Ëøô‰∏™ÈóÆÈ¢òÔºå‰∏çËøáËß£ÂÜ≥‰πãÂâçÊàë‰ª¨ÂèØ‰ª•‰ΩøÁî®Ë∞ÉËØïÂô®Êù•Ê£ÄÊü•‰∏Ä‰∏ãÁ®ãÂ∫èË¶ÅËøõÂÖ•Áî®Êà∑Ê®°ÂºèÊó∂ÂÅö‰∫Ü‰ªÄ‰πà„ÄÇ‰ΩøÁî®make qemu-gdb Âπ∂‰∏îÂú® env_pop_tf Â§ÑËÆæÁΩÆÊñ≠ÁÇπÔºåËøôÊù°Êåá‰ª§Â∫îËØ•ÊòØÂç≥Â∞ÜËøõÂÖ•Áî®Êà∑Ê®°Âºè‰πãÂâçÁöÑÊúÄÂêé‰∏ÄÊù°Êåá‰ª§„ÄÇÁÑ∂ÂêéËøõË°åÂçïÊ≠•Ë∞ÉËØïÔºåÂ§ÑÁêÜ‰ºöÂú®ÊâßË°åÂÆåiret Êåá‰ª§ÂêéËøõÂÖ•Áî®Êà∑Ê®°Âºè„ÄÇÁÑ∂Âêé‰æùÊóßÂèØ‰ª•ÁúãÂà∞ËøõÂÖ•Áî®Êà∑ÊÄÅÂêéÊâßË°åÁöÑÁ¨¨‰∏ÄÊù°Êåá‰ª§‰∫ÜÔºåËØ•Êåá‰ª§ÊòØ‰∏Ä‰∏™cmpÊåá‰ª§ÔºåÂºÄÂßã‰∫éÊñá‰ª∂ lib/entry.S ‰∏≠„ÄÇ Áé∞Âú®‰ΩøÁî® b *0x... ËÆæÁΩÆ‰∏Ä‰∏™Êñ≠ÁÇπÂú®helloÊñá‰ª∂Ôºàobj/user/hello.asmÔºâ‰∏≠ÁöÑsys_cputsÂáΩÊï∞‰∏≠ÁöÑ int $0x30 Êåá‰ª§Â§Ñ„ÄÇËøô‰∏™intÊåá‰ª§ÊòØ‰∏Ä‰∏™Á≥ªÁªüË∞ÉÁî®ÔºåÁî®Êù•Â±ïÁ§∫‰∏Ä‰∏™Â≠óÁ¨¶Âà∞ÊéßÂà∂Âè∞„ÄÇÂ¶ÇÊûú‰Ω†ÁöÑÁ®ãÂ∫èËøêË°å‰∏çÂà∞Ëøô‰∏™intÊåá‰ª§ÔºåËØ¥ÊòéÊúâÈîôËØØ„ÄÇÂÖ∂ÂÆû‰∏çÁî®‰∏äÈù¢ÈÇ£‰πàÈ∫ªÁÉ¶ÔºåÁõ¥Êé•ËøêË°åmake qemu-gdb ÁÑ∂ÂêéËæìÂÖ•cÊåá‰ª§ÔºåÊúÄÁªàmake gdb ‰ºöÂÅúÂú® int $0x30,ÁÑ∂Âêéqemu ‰ºöÊòæÁ§∫ÈîôËØØ‚Äùtriple fault‚Äù„ÄÇ (ÂêéÈù¢Â§ßÈÉ®ÂàÜÈÉΩÊòØÁêÜËÆ∫ÊñáÂ≠óÔºåÂ§ßÈÉ®ÂàÜÈÉΩÊòØÁøªËØëËøáÊù•ÁöÑÔºåÊâÄ‰ª•Áõ¥Êé•ÁÖßÊê¨‰∫ÜÂ§ß‰Ω¨Èó®ÂçöÂÆ¢ÈáåÈù¢ÁöÑ„ÄÇËã±ËØ≠Ê∞¥Âπ≥‰∏çÂ•ΩÔºåÊÄïÁøªËØë‰∫ÜÁúã‰∏çÊáÇ) Handling Interrupts and Exceptions Âà∞ÁõÆÂâç‰∏∫Ê≠¢ÔºåÂΩìÁ®ãÂ∫èËøêË°åÂà∞Á¨¨‰∏Ä‰∏™Á≥ªÁªüË∞ÉÁî®int $0x30 Êó∂ÔºåÂ∞±‰ºöËøõÂÖ•ÈîôËØØÁöÑÁä∂ÊÄÅÔºåÂõ†‰∏∫Áé∞Âú®Á≥ªÁªüÊó†Ê≥ï‰ªéÁî®Êà∑ÊÄÅÂàáÊç¢Âà∞ÂÜÖÊ†∏ÊÄÅ„ÄÇÊâÄ‰ª•‰Ω†ÈúÄË¶ÅÂÆûÁé∞‰∏Ä‰∏™Âü∫Êú¨ÁöÑÂºÇÂ∏∏/Á≥ªÁªüË∞ÉÁî®Â§ÑÁêÜÊú∫Âà∂Ôºå‰ΩøÂæóÂÜÖÊ†∏ÂèØ‰ª•‰ªéÁî®Êà∑ÊÄÅËΩ¨Êç¢‰∏∫ÂÜÖÊ†∏ÊÄÅ„ÄÇ‰Ω†Â∫îËØ•ÂÖàÁÜüÊÇâ‰∏Ä‰∏ãX86ÁöÑÂºÇÂ∏∏‰∏≠Êñ≠Êú∫Âà∂„ÄÇ Basics of Protected Control Transfer&emsp;ÂºÇÂ∏∏(Exception)Âíå‰∏≠Êñ≠(Interrupts)ÈÉΩÊòØ‚ÄúÂèóÂà∞‰øùÊä§ÁöÑÊéßÂà∂ËΩ¨ÁßªÊñπÊ≥ï‚ÄùÔºåÈÉΩ‰ºö‰ΩøÂ§ÑÁêÜÂô®‰ªéÁî®Êà∑ÊÄÅËΩ¨Áßª‰∏∫ÂÜÖÊ†∏ÊÄÅ„ÄÇÂú®IntelÁöÑÊúØËØ≠‰∏≠Ôºå‰∏Ä‰∏™‰∏≠Êñ≠ÊåáÁöÑÊòØÁî±Â§ñÈÉ®ÂºÇÊ≠•‰∫ã‰ª∂ÂºïËµ∑ÁöÑÂ§ÑÁêÜÂô®ÊéßÂà∂ÊùÉËΩ¨ÁßªÔºåÊØîÂ¶ÇÂ§ñÈÉ®IOËÆæÂ§áÂèëÈÄÅÊù•ÁöÑ‰∏≠Êñ≠‰ø°Âè∑„ÄÇ‰∏Ä‰∏™ÂºÇÂ∏∏ÂàôÊòØÁî±‰∫éÂΩìÂâçÊ≠£Âú®ËøêË°åÁöÑÊåá‰ª§ÊâÄÂ∏¶Êù•ÁöÑÂêåÊ≠•ÁöÑÂ§ÑÁêÜÂô®ÊéßÂà∂ÊùÉÁöÑËΩ¨ÁßªÔºåÊØîÂ¶ÇÈô§Èõ∂Ê∫¢Âá∫ÂºÇÂ∏∏„ÄÇ &emsp;‰∏∫‰∫ÜËÉΩÂ§üÁ°Æ‰øùËøô‰∫õÊéßÂà∂ÁöÑËΩ¨ÁßªËÉΩÂ§üÁúüÊ≠£Ë¢´‰øùÊä§Ëµ∑Êù•ÔºåÂ§ÑÁêÜÂô®ÁöÑ‰∏≠Êñ≠/ÂºÇÂ∏∏Êú∫Âà∂ÈÄöÂ∏∏Ë¢´ËÆæËÆ°‰∏∫ÔºöÁî®Êà∑ÊÄÅÁöÑ‰ª£Á†ÅÊó†ÊùÉÈÄâÊã©ÂÜÖÊ†∏‰∏≠ÁöÑ‰ª£Á†Å‰ªéÂì™ÈáåÂºÄÂßãÊâßË°å„ÄÇÂ§ÑÁêÜÂô®ÂèØ‰ª•Á°Æ‰øùÂè™ÊúâÂú®Êüê‰∫õÊù°‰ª∂‰∏ãÔºåÊâçËÉΩËøõÂÖ•ÂÜÖÊ†∏ÊÄÅ„ÄÇÂú®X86‰∏äÔºåÊúâ‰∏§ÁßçÊú∫Âà∂ÈÖçÂêàÂ∑•‰ΩúÊù•Êèê‰æõËøôÁßç‰øùÊä§Ôºö ‰∏≠Êñ≠ÂêëÈáèË°®ÔºöÂ§ÑÁêÜÂô®‰øùËØÅ‰∏≠Êñ≠ÂíåÂºÇÂ∏∏Âè™ËÉΩÂ§üÂºïËµ∑ÂÜÖÊ†∏ËøõÂÖ•Âà∞‰∏Ä‰∫õÁâπÂÆöÁöÑÔºåË¢´‰∫ãÂÖàÂÆö‰πâÂ•ΩÁöÑÁ®ãÂ∫èÂÖ•Âè£ÁÇπÔºåËÄå‰∏çÊòØÁî±Ëß¶Âèë‰∏≠Êñ≠ÁöÑÁ®ãÂ∫èÊù•ÂÜ≥ÂÆö‰∏≠Êñ≠Á®ãÂ∫èÂÖ•Âè£ÁÇπ„ÄÇ &emsp;X86ÂÖÅËÆ∏Â§öËææ256‰∏™‰∏çÂêåÁöÑ‰∏≠Êñ≠ÂíåÂºÇÂ∏∏ÔºåÊØè‰∏Ä‰∏™ÈÉΩÈÖçÂ§á‰∏Ä‰∏™Áã¨‰∏ÄÊó†‰∫åÁöÑ‰∏≠Êñ≠ÂêëÈáè„ÄÇ‰∏Ä‰∏™ÂêëÈáèÊåáÁöÑÂ∞±ÊòØ0Âà∞255‰∏≠ÁöÑ‰∏Ä‰∏™Êï∞„ÄÇ‰∏Ä‰∏™‰∏≠Êñ≠ÂêëÈáèÁöÑÂÄºÊòØÊ†πÊçÆ‰∏≠Êñ≠Ê∫êÊù•ÂÜ≥ÂÆöÁöÑÔºö‰∏çÂêåËÆæÂ§áÔºåÈîôËØØÊù°‰ª∂Ôºå‰ª•ÂèäÂØπÂÜÖÊ†∏ÁöÑËØ∑Ê±ÇÈÉΩ‰ºö‰∫ßÁîüÂá∫‰∏çÂêåÁöÑ‰∏≠Êñ≠Âíå‰∏≠Êñ≠ÂêëÈáèÁöÑÁªÑÂêà„ÄÇCPUÂ∞Ü‰ΩøÁî®Ëøô‰∏™ÂêëÈáè‰Ωú‰∏∫Ëøô‰∏™‰∏≠Êñ≠Âú®‰∏≠Êñ≠ÂêëÈáèË°®‰∏≠ÁöÑÁ¥¢ÂºïÔºåËøô‰∏™Ë°®ÊòØÁî±ÂÜÖÊ†∏ËÆæÁΩÆÁöÑÔºåÊîæÂú®ÂÜÖÊ†∏Á©∫Èó¥‰∏≠ÔºåÂíåGDTÂæàÂÉè„ÄÇÈÄöËøáËøô‰∏™Ë°®‰∏≠ÁöÑ‰ªªÊÑè‰∏Ä‰∏™Ë°®È°πÔºåÂ§ÑÁêÜÂô®ÂèØ‰ª•Áü•ÈÅìÔºöÈúÄË¶ÅÂä†ËΩΩÂà∞EIPÂØÑÂ≠òÂô®‰∏≠ÁöÑÂÄºÔºåËøô‰∏™ÂÄºÊåáÂêë‰∫ÜÂ§ÑÁêÜËøô‰∏™‰∏≠Êñ≠ÁöÑ‰∏≠Êñ≠Â§ÑÁêÜÁ®ãÂ∫èÁöÑ‰ΩçÁΩÆ„ÄÇ ÈúÄË¶ÅÂä†ËΩΩÂà∞CSÂØÑÂ≠òÂô®‰∏≠ÁöÑÂÄºÔºåÈáåÈù¢ËøòÂåÖÂê´‰∫ÜËøô‰∏™‰∏≠Êñ≠Â§ÑÁêÜÁ®ãÂ∫èÁöÑËøêË°åÁâπÊùÉÁ∫ß„ÄÇÔºàÂç≥Ëøô‰∏™Á®ãÂ∫èÊòØÂú®Áî®Êà∑ÊÄÅËøòÊòØÂÜÖÊ†∏ÊÄÅ‰∏ãËøêË°å„ÄÇÔºâ ‰ªªÂä°Áä∂ÊÄÅÊÆµ:Â§ÑÁêÜÂô®ËøòÈúÄË¶Å‰∏Ä‰∏™Âú∞ÊñπÊù•Â≠òÊîæÔºåÂΩìÂºÇÂ∏∏/‰∏≠Êñ≠ÂèëÁîüÊó∂ÔºåÂ§ÑÁêÜÂô®ÁöÑÁä∂ÊÄÅÔºåÊØîÂ¶ÇEIPÂíåCSÂØÑÂ≠òÂô®ÁöÑÂÄº„ÄÇËøôÊ†∑ÁöÑËØùÔºå‰∏≠Êñ≠Â§ÑÁêÜÁ®ãÂ∫è‰∏Ä‰ºöÂèØ‰ª•ÈáçÊñ∞ËøîÂõûÂà∞ÂéüÊù•ÁöÑÁ®ãÂ∫è‰∏≠„ÄÇËøôÊÆµÂÜÖÂ≠òËá™ÁÑ∂‰πüË¶Å‰øùÊä§Ëµ∑Êù•Ôºå‰∏çËÉΩË¢´Áî®Êà∑ÊÄÅÁöÑÁ®ãÂ∫èÊâÄÁØ°Êîπ„ÄÇ Ê≠£Âõ†‰∏∫Â¶ÇÊ≠§ÔºåÂΩì‰∏Ä‰∏™x86Â§ÑÁêÜÂô®Ë¶ÅÂ§ÑÁêÜ‰∏Ä‰∏™‰∏≠Êñ≠ÔºåÂºÇÂ∏∏Âπ∂‰∏î‰ΩøËøêË°åÁâπÊùÉÁ∫ß‰ªéÁî®Êà∑ÊÄÅËΩ¨‰∏∫ÂÜÖÊ†∏ÊÄÅÊó∂ÔºåÂÆÉ‰πü‰ºöÊääÂÆÉÁöÑÂ†ÜÊ†àÂàáÊç¢Âà∞ÂÜÖÊ†∏Á©∫Èó¥‰∏≠„ÄÇ‰∏Ä‰∏™Âè´ÂÅö ‚Äú‰ªªÂä°Áä∂ÊÄÅÊÆµÔºàTSSÔºâ‚ÄùÁöÑÊï∞ÊçÆÁªìÊûÑÂ∞Ü‰ºöËØ¶ÁªÜËÆ∞ÂΩïËøô‰∏™Â†ÜÊ†àÊâÄÂú®ÁöÑÊÆµÁöÑÊÆµÊèèËø∞Á¨¶ÂíåÂú∞ÂùÄ„ÄÇÂ§ÑÁêÜÂô®‰ºöÊääSSÔºåESPÔºåEFLAGSÔºåCSÔºåEIP‰ª•Âèä‰∏Ä‰∏™ÂèØÈÄâÈîôËØØÁ†ÅÁ≠âÁ≠âËøô‰∫õÂÄºÂéãÂÖ•Âà∞Ëøô‰∏™Â†ÜÊ†à‰∏ä„ÄÇÁÑ∂ÂêéÂä†ËΩΩ‰∏≠Êñ≠Â§ÑÁêÜÁ®ãÂ∫èÁöÑCSÔºåEIPÂÄºÔºåÂπ∂‰∏îËÆæÁΩÆESPÔºåSSÂØÑÂ≠òÂô®ÊåáÂêëÊñ∞ÁöÑÂ†ÜÊ†à„ÄÇ Â∞ΩÁÆ°TSSÈùûÂ∏∏Â§ßÔºåÂπ∂‰∏îËøòÊúâÂæàÂ§öÂÖ∂‰ªñÁöÑÂäüËÉΩÔºå‰ΩÜÊòØJOS‰ªÖ‰ªÖ‰ΩøÁî®ÂÆÉÊù•ÂÆö‰πâÂ§ÑÁêÜÂô®‰ªéÁî®Êà∑ÊÄÅËΩ¨ÂêëÂÜÖÊ†∏ÊÄÅÊâÄÈááÁî®ÁöÑÂÜÖÊ†∏Â†ÜÊ†àÔºåÁî±‰∫éJOS‰∏≠ÁöÑÂÜÖÊ†∏ÊÄÅÊåáÁöÑÂ∞±ÊòØÁâπÊùÉÁ∫ß0ÔºåÊâÄ‰ª•Â§ÑÁêÜÂô®Áî®TSS‰∏≠ÁöÑESP0ÔºåSS0Â≠óÊÆµÊù•ÊåáÊòéËøô‰∏™ÂÜÖÊ†∏Â†ÜÊ†àÁöÑ‰ΩçÁΩÆÔºåÂ§ßÂ∞è„ÄÇ Types of Exceptions and Interrupts &emsp;ÊâÄÊúâÁöÑÁî±X86Â§ÑÁêÜÂô®ÂÜÖÈÉ®‰∫ßÁîüÁöÑÂºÇÂ∏∏ÁöÑÂêëÈáèÂÄºÊòØ0Âà∞31‰πãÈó¥ÁöÑÊï¥Êï∞„ÄÇÊØîÂ¶ÇÔºåÈ°µË°®ÈîôÊâÄÂØπÂ∫îÁöÑÂêëÈáèÂÄºÊòØ14.ËÄåÂ§ß‰∫é31Âè∑ÁöÑ‰∏≠Êñ≠ÂêëÈáèÂØπÂ∫îÁöÑÊòØËΩØ‰ª∂‰∏≠Êñ≠ÔºåÁî±intÊåá‰ª§ÁîüÊàêÔºõÊàñËÄÖÊòØÂ§ñÈÉ®‰∏≠Êñ≠ÔºåÁî±Â§ñÈÉ®ËÆæÂ§áÁîüÊàê„ÄÇ&emsp;Âú®Ëøô‰∏ÄÁ´†ÔºåÊàë‰ª¨Â∞ÜÊâ©Â±ïJOSÁöÑÂäüËÉΩÔºå‰ΩøÂÆÉËÉΩÂ§üÂ§ÑÁêÜ0~31Âè∑ÂÜÖÈÉ®ÂºÇÂ∏∏„ÄÇÂú®‰∏ã‰∏ÄÁ´†‰ºöËÆ©JOSËÉΩÂ§üÂ§ÑÁêÜ48Âè∑ËΩØ‰ª∂‰∏≠Êñ≠Ôºå‰∏ªË¶ÅË¢´Áî®Êù•ÂÅöÁ≥ªÁªüË∞ÉÁî®„ÄÇÂú®Lab 4‰∏≠‰ºöÁªßÁª≠Êâ©Â±ïJOS‰ΩøÂÆÉËÉΩÂ§üÂ§ÑÁêÜÂ§ñÈÉ®Á°¨‰ª∂‰∏≠Êñ≠ÔºåÊØîÂ¶ÇÊó∂Èíü‰∏≠Êñ≠„ÄÇ An ExampleËÆ©Êàë‰ª¨ËØï‰∏Ä‰∏ãÈô§0 Â§ÑÁêÜÂô®‰ºöÈ¶ñÂÖàÂàáÊç¢Ëá™Â∑±ÁöÑÂ†ÜÊ†àÔºåÂàáÊç¢Âà∞Áî±TSSÁöÑSS0ÔºåESP0Â≠óÊÆµÊâÄÊåáÂÆöÁöÑÂÜÖÊ†∏Â†ÜÊ†àÂå∫ÔºåËøô‰∏§‰∏™Â≠óÊÆµÂàÜÂà´Â≠òÊîæÁùÄGD_KDÂíåKSTACKTOPÁöÑÂÄº„ÄÇ Â§ÑÁêÜÂô®ÊääÂºÇÂ∏∏ÂèÇÊï∞ÂéãÂÖ•Âà∞ÂÜÖÊ†∏Â†ÜÊ†à‰∏≠ÔºåËµ∑Âßã‰∫éÂú∞ÂùÄKSTACKTOPÔºö Âõ†‰∏∫Êàë‰ª¨Ë¶ÅÂ§ÑÁêÜÁöÑÊòØÈô§Èõ∂ÂºÇÂ∏∏ÔºåÂÆÉÁöÑ‰∏≠Êñ≠ÂêëÈáèÊòØ0ÔºåÂ§ÑÁêÜÂô®‰ºöËØªÂèñIDTË°®‰∏≠ÁöÑ0Âè∑Ë°®È°πÔºåÂπ∂‰∏îÊääCS:EIPÁöÑÂÄºËÆæÁΩÆ‰∏∫0Âè∑‰∏≠Êñ≠Â§ÑÁêÜÂáΩÊï∞ÁöÑÂú∞ÂùÄÂÄº„ÄÇ ‰∏≠Êñ≠Â§ÑÁêÜÂáΩÊï∞ÂºÄÂßãÊâßË°åÂ§ÑÁêÜ‰∏≠Êñ≠„ÄÇ ÂØπ‰∫éÊüê‰∫õÁâπÂÆöÁ±ªÂûãÁöÑx86ÂºÇÂ∏∏ÔºåÈô§‰∫Ü‰∏äÈù¢Âõæ‰∏≠Ë¶Å‰øùÂ≠ò5‰∫î‰∏™Â≠ó‰πãÂ§ñÔºåËøòË¶ÅÂÜçÂéãÂÖ•‰∏Ä‰∏™Â≠óÔºåÂè´ÂÅöÈîôËØØÁ†Å„ÄÇÊØîÂ¶ÇÈ°µÈîôËØØÔºåÂ∞±ÊòØÂÖ∂‰∏≠‰∏Ä‰∏™ÂÆû‰æã„ÄÇÂΩìÂéãÂÖ•ÈîôËØØÁ†Å‰πãÂêéÔºåÂÜÖÊ†∏Â†ÜÊ†àÁöÑÁä∂ÊÄÅÂ¶Ç‰∏ãÔºö Nested Exceptions and InterruptsÂ§ÑÁêÜÂô®Âú®Áî®Êà∑ÊÄÅ‰∏ãÂíåÂÜÖÊ†∏ÊÄÅ‰∏ãÈÉΩÂèØ‰ª•Â§ÑÁêÜÂºÇÂ∏∏Êàñ‰∏≠Êñ≠„ÄÇÂè™ÊúâÂΩìÂ§ÑÁêÜÂô®‰ªéÁî®Êà∑ÊÄÅÂàáÊç¢Âà∞ÂÜÖÊ†∏ÊÄÅÊó∂ÔºåÊâç‰ºöËá™Âä®Âú∞ÂàáÊç¢Â†ÜÊ†àÔºåÂπ∂‰∏îÊää‰∏Ä‰∫õÂØÑÂ≠òÂô®‰∏≠ÁöÑÂéüÊù•ÁöÑÂÄºÂéãÂÖ•Âà∞Â†ÜÊ†à‰∏äÔºåÂπ∂‰∏îË∞ÉÁî®IDTÊåáÂÆöÁöÑÂêàÈÄÇÁöÑÂºÇÂ∏∏Â§ÑÁêÜÁ®ãÂ∫è„ÄÇ‰ΩÜÂ¶ÇÊûúÂ§ÑÁêÜÂô®Â∑≤ÁªèÁî±‰∫éÊ≠£Âú®Â§ÑÁêÜ‰∏≠Êñ≠ËÄåÂ§ÑÂú®ÂÜÖÊ†∏ÊÄÅ‰∏ãÊó∂ÔºàCSÂØÑÂ≠òÂô®ÁöÑ‰Ωé‰∏§‰ΩçÂ∑≤ÁªèÈÉΩÊòØ0ÔºâÔºåÊ≠§Êó∂CPUÂè™‰ºöÂêëÂÜÖÊ†∏Â†ÜÊ†àÂéãÂÖ•Êõ¥Â§öÁöÑÂÄº„ÄÇÈÄöËøáËøôÁßçÊñπÂºèÔºåÂÜÖÊ†∏Â∞±ÂèØÂ§ÑÁêÜÂµåÂ•ó‰∏≠Êñ≠„ÄÇ Â¶ÇÊûúÂ§ÑÁêÜÂô®Â∑≤ÁªèÂú®ÂÜÖÊ†∏ÊÄÅ‰∏ãÂπ∂‰∏îÈÅáÂà∞ÂµåÂ•ó‰∏≠Êñ≠ÔºåÂõ†‰∏∫ÂÆÉ‰∏çÈúÄË¶ÅÂàáÊç¢Â†ÜÊ†àÔºåÊâÄ‰ª•ÂÆÉ‰∏çÈúÄË¶ÅÂ≠òÂÇ®ÂéüÊù•ÁöÑSSÔºåESPÂØÑÂ≠òÂô®ÁöÑÂÄº„ÄÇÂ¶ÇÊûúËøô‰∏™ÂºÇÂ∏∏Á±ªÂûã‰∏çÂéãÂÖ•ÈîôËØØÁ†ÅÔºåÊ≠§Êó∂ÂÜÖÊ†∏Â†ÜÊ†àÁöÑÂ∞±ÂÉè‰∏ãÈù¢Ëøô‰∏™Ê†∑Â≠êÔºöËøôÈáåÊúâ‰∏Ä‰∏™ÈáçË¶ÅÁöÑË≠¶Âëä,Â¶ÇÊûúÂ§ÑÁêÜÂô®Âú®ÂÜÖÊ†∏ÊÄÅ‰∏ãÊé•Âèó‰∏Ä‰∏™ÂºÇÂ∏∏ÔºåËÄå‰∏îÁî±‰∫é‰∏Ä‰∫õÂéüÂõ†ÔºåÊØîÂ¶ÇÂ†ÜÊ†àÁ©∫Èó¥‰∏çË∂≥Ôºå‰∏çËÉΩÊääÂΩìÂâçÁöÑÁä∂ÊÄÅ‰ø°ÊÅØÔºàÂØÑÂ≠òÂô®ÁöÑÂÄºÔºâÂéãÂÖ•Âà∞ÂÜÖÊ†∏Â†ÜÊ†à‰∏≠Êó∂ÔºåÈÇ£‰πàÂ§ÑÁêÜÂô®ÊòØÊó†Ê≥ïÊÅ¢Â§çÂà∞ÂéüÊù•ÁöÑÁä∂ÊÄÅ‰∫ÜÔºåÂÆÉ‰ºöËá™Âä®ÈáçÂêØ„ÄÇ Setting Up the IDT(ÂèàË¶ÅÂáÜÂ§áÂπ≤Ê¥ª‰∫Ü) ‰Ω†Áé∞Âú®Â∫îËØ•Êúâ‰∫ÜÂª∫Á´ãIDTË°®‰ª•ÂèäJOSÂ§ÑÁêÜÂºÇÂ∏∏ÁöÑÂü∫Êú¨‰ø°ÊÅØ„ÄÇÊàë‰ª¨Áé∞Âú®Âè™ÈúÄË¶ÅÂºÄÂßãÂª∫Á´ãË°®Â∞±Ë°å‰∫Ü„ÄÇÊòØÂê¶ËÆ∞Âæólab 2ÈáåÈù¢ÁöÑÂÜÖÂ≠òÂàÜÂ∏ÉÔºåÊúÄ‰ΩéÁöÑÈÇ£‰∏ÄÈ°µÂ∞±ÊòØÂ≠òËøô‰∏™ÁöÑ„ÄÇÁÑ∂ÂêéÊàë‰ª¨ÂéªÁúãÁúãinc/trap.h,ÈÇ£‰∏™kern/trap.hËá™Â∑±ÁúãÁúãÂ∞±Ë°å‰∫Ü„ÄÇÂ¶ÇÊûúÊÉ≥Áü•ÈÅìÂêÑ‰∏™‰∏≠Êñ≠ÂÖ∑‰ΩìÊòØÂï•ÁúãËøô‰∏™„ÄÇ trap.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#ifndef JOS_INC_TRAP_H#define JOS_INC_TRAP_H// Trap numbers// These are processor defined: ËøôÊòØÂêÑÁßç‰∏≠Êñ≠ ÂØπ‰∫éËøô‰∫õÂª∫ËÆÆÂ§ßÂÆ∂Â≠¶Â≠¶ÂµåÂÖ•ÂºèÔºåÊâãÂÜô‰∏™CPUÔºàÊàëÁöÑgithub ‰∏äÊúâ‰∏™ÁÆÄÂçïÁöÑ...Ôºâ ‰∏ãÈù¢ÂêÑÁßçÈîôËØØËøòÊòØÂ§ßÂÆ∂Ëá™Ë°åÁôæÂ∫¶ÔºåÊàëËß£ÈáäÂá†‰∏™Â∏∏Áî®ÁöÑ#define T_DIVIDE 0 // divide error Èô§0#define T_DEBUG 1 // debug exception #define T_NMI 2 // non-maskable interrupt ÈùûÂ±èËîΩ‰∏≠Êñ≠ÔºüÔºüÔºü#define T_BRKPT 3 // breakpoint Êñ≠ÁÇπ#define T_OFLOW 4 // overflow Ê∫¢Âá∫#define T_BOUND 5 // bounds check ËæπÁïåÊ£ÄÊü•Ôºü#define T_ILLOP 6 // illegal opcode ÈùûÊ≥ïÊìç‰ΩúÁ†Å #define T_DEVICE 7 // device not available ËÆæÂ§á‰∏çÂèØÁî®#define T_DBLFLT 8 // double fault /* #define T_COPROC 9 */ // reserved (not generated by recent processors)#define T_TSS 10 // invalid task switch segment Êó†Êïà‰ªªÂä°ÊÆµÂàáÊç¢#define T_SEGNP 11 // segment not present ÊÆµ‰∏çÂ≠òÂú®#define T_STACK 12 // stack exception Ê†àÂºÇÂ∏∏#define T_GPFLT 13 // general protection fault#define T_PGFLT 14 // page fault È°µÈîôËØØ/* #define T_RES 15 */ // reserved#define T_FPERR 16 // floating point error ÊµÆÁÇπÈîôËØØ#define T_ALIGN 17 // aligment check ÂØπÈΩêÊ£ÄÊü•#define T_MCHK 18 // machine check #define T_SIMDERR 19 // SIMD floating point error// These are arbitrarily chosen, but with care not to overlap ‰∏ãÈù¢ÂèØ‰ª•‰ªªÊÑèÈÄâÊã©Ôºå‰ΩÜÊòØ‰∏çË¶ÅÈáçÂè†// processor defined exceptions or interrupt vectors. Â∫îËØ•Â∞±ÊòØ Ëá™ÂÆö‰πâ ÂºÇÂ∏∏#define T_SYSCALL 48 // system call#define T_DEFAULT 500 // catchall#define IRQ_OFFSET 32 // IRQ 0 corresponds to int IRQ_OFFSET Â§ñÈÉ®‰∏≠Êñ≠// Hardware IRQ numbers. We receive these as (IRQ_OFFSET+IRQ_WHATEVER)#define IRQ_TIMER 0#define IRQ_KBD 1#define IRQ_SERIAL 4#define IRQ_SPURIOUS 7#define IRQ_IDE 14#define IRQ_ERROR 19#ifndef __ASSEMBLER__#include &lt;inc/types.h&gt;//‰øùÂ≠òÈÄöÁî®ÂØÑÂ≠òÂô®ÁöÑÂÄºstruct PushRegs &#123; /* registers as pushed by pusha */ uint32_t reg_edi; uint32_t reg_esi; uint32_t reg_ebp; uint32_t reg_oesp; /* Useless */ uint32_t reg_ebx; uint32_t reg_edx; uint32_t reg_ecx; uint32_t reg_eax;&#125; __attribute__((packed));//‰ªªÂä°ÊÆµstruct Trapframe &#123; struct PushRegs tf_regs; uint16_t tf_es; uint16_t tf_padding1; uint16_t tf_ds; uint16_t tf_padding2; uint32_t tf_trapno; /* below here defined by x86 hardware ‰∏ãÈù¢ÊòØx86 Á°¨‰ª∂ÂÆö‰πâÁöÑ */ uint32_t tf_err; uintptr_t tf_eip; uint16_t tf_cs; uint16_t tf_padding3; uint32_t tf_eflags; /* below here only when crossing rings, such as from user to kernel ‰∏çÁü•ÈÅìÊòØÂï•*/ uintptr_t tf_esp; uint16_t tf_ss; uint16_t tf_padding4;&#125; __attribute__((packed));#endif /* !__ASSEMBLER__ */#endif /* !JOS_INC_TRAP_H */ ÊúÄÂêé‰Ω†Ë¶ÅÂÆûÁé∞ÁöÑÊéßÂà∂ÊµÅÁöÑÊïàÊûúÂ¶Ç‰∏ãÔºöÊØè‰∏Ä‰∏™‰∏≠Êñ≠ÊàñÂºÇÂ∏∏ÈÉΩÊúâÁõ∏Â∫îÂÆö‰πâÂú®trapentry.S‰∏≠‰∏≠Êñ≠Â§ÑÁêÜÁ®ãÂ∫è,trap_init()Â∞ÜÁî®Ëøô‰∫õ‰∏≠Êñ≠Â§ÑÁêÜÁ®ãÂ∫èÁöÑÂú∞ÂùÄÂàùÂßãÂåñIDT„ÄÇÊØè‰∏Ä‰∏™Â§ÑÁêÜÁ®ãÂ∫èÈÉΩÂ∫îËØ•Âú®Â†ÜÊ†à‰∏äÊûÑÂª∫‰∏Ä‰∏™ÁªìÊûÑ‰Ωìstruct TrapframeÔºåÂπ∂‰∏îË∞ÉÁî®trap()ÂáΩÊï∞ÊåáÂêëËøô‰∏™ÁªìÊûÑ‰ΩìÔºåtrap()ÁÑ∂ÂêéÂ§ÑÁêÜÂºÇÂ∏∏/‰∏≠Êñ≠ÔºåÁªô‰ªñÂàÜÈÖç‰∏Ä‰∏™‰∏≠Êñ≠Â§ÑÁêÜÂáΩÊï∞„ÄÇ ÁªÉ‰π†4 Ë¶Å‰Ω†ÁºñËæë‰∏äÈù¢ËØ¥Ëøô‰∫õ‰∏úË•ø„ÄÇÊàë‰ª¨Ë∑üÁùÄ‰ªñËµ∞ÔºåTRAPHANDLER_NOECÂíåTRAPHANDLER_NOECÔºåÊàë‰ª¨ÁúãÁúãÊòØÂï•„ÄÇ TRAPHANDLER_NOECÂíåTRAPHANDLER_NOECÂú®Ëøô‰∏™Êñá‰ª∂ÈáåÈù¢Ôºå‰πüÂ∞±ÊòØ‰∏∫ÊØè‰∏™‰∏≠Êñ≠ÂàõÂª∫‰∏Ä‰∏™ÂáΩÊï∞ÔºåÁÑ∂ÂêéË∞ÉÁî®trap()1234567891011121314151617181920212223242526272829303132333435#################################################################### exceptions/interrupts###################################################################/* TRAPHANDLER defines a globally-visible function for handling a trap. ÂÆö‰πâ‰∫Ü‰∏Ä‰∏™ÂÖ®Â±ÄÂèØËßÅÁöÑÂáΩÊï∞ÔºåÁî®Êù•Â§ÑÁêÜtrap * It pushes a trap number onto the stack, then jumps to _alltraps. * Use TRAPHANDLER for traps where the CPU automatically pushes an error code. * ‰ªñ‰ºöÊää Èô∑Èò±Âè∑Ëá™Êé®ÂÖ•Â†ÜÊ†àÔºåÁÑ∂ÂêéË∑≥ËΩ¨ _alltrapsÔºå‰ΩøÁî®Ëøô‰∏™ÂèØ‰ª•Ëá™Âä®Êé®ÂÖ• ÈîôËØØÁ†Å„ÄÇ * You shouldn't call a TRAPHANDLER function from C, but you may * need to _declare_ one in C (for instance, to get a function pointer * during IDT setup). You can declare the function with * void NAME(); Â¶ÇÊûú‰Ω†ÊÉ≥Âú®CÈáåÈù¢Áî®Ë¶ÅÂ£∞Êòé‰∏Ä‰∏ã * where NAME is the argument passed to TRAPHANDLER. */ /* ÁøªËØëËøáÊù• Â∞±ÊòØÂàõÂª∫‰∫Ü‰∏Ä‰∏™ ÂáΩÊï∞Ôºåname ÔºåÁÑ∂ÂêéÂÅö‰∫Ü‰∏ãÈù¢Ëøô‰∫õ‰∫ã*/#define TRAPHANDLER(name, num) \ .globl name; /* define global symbol for 'name' Á¨¨‰∏ÄÂÖ®Â±ÄÁ¨¶Âè∑name */ \ .type name, @function; /* symbol type is function Á¨¶Âè∑Á±ªÂûãÊòØÂáΩÊï∞*/ \ .align 2; /* align function definition ÂØπÈΩêÂáΩÊï∞ÂÆö‰πâ */ \ name: /* function starts here ÂáΩÊï∞ÂÆö‰πâ */ \ pushl $(num); \ jmp _alltraps/* Use TRAPHANDLER_NOEC for traps where the CPU doesn't push an error code. * It pushes a 0 in place of the error code, so the trap frame has the same * format in either case. Ëøô‰∏™ Âíå‰∏äÈù¢ÁöÑÂå∫Âà´Â∞±ÊòØ‰∏ç‰ºö ÂéãÂÖ• ÈîôËØØÁ†ÅÔºåÁî®0Êù•Êõø‰ª£‰∫ÜÔºüÔºü */#define TRAPHANDLER_NOEC(name, num) \ .globl name; \ .type name, @function; \ .align 2; \ name: \ pushl $0; \ pushl $(num); \ jmp _alltraps inc/trap.hÂ∑≤ÁªèÂàÜÊûêËøá‰∫Ü„ÄÇÁÑ∂Âêé‰ªñËØ¥ Êàë‰ª¨ÈúÄË¶ÅÂÆûÁé∞_alltraps„ÄÇËøòÈúÄË¶ÅÂú®trap_init() ÈáåÈù¢ÂÆûÁé∞ÂàùÂßãÂåñÂÖ•Âè£ÂÆö‰πâ„ÄÇÁÑ∂ÂêéSETGATE‰ºöÂ∏ÆÂä©Êàë‰ª¨„ÄÇÊâÄ‰ª•Êàë‰ª¨ÂéªÁúãÁúãSTEGATEÂπ≤‰∫ÜÂï•.Áî±‰∫éÊàëÂπ∂‰∏çÁü•ÈÅì‰ªñÂú®Âì™ÔºåÊâÄ‰ª•Êàë‰ª¨Áî®grepÊêú‰∏Ä‰∏ã„ÄÇÂèëÁé∞Âú®mmu.hÈáåÈù¢Ôºå‰∏äÊ¨°Êàë‰ª¨ÂàÜÊûê‰∫Ü‰∏ÄÈÉ®ÂàÜÔºåÂõ†‰∏∫ÂêéÈù¢ÁöÑÊ≤°ÊúâÁî®‰∏äÔºåÊàëÂ∞±Ê≥®Èáä‰∫Ü‰∏ÄÈÉ®ÂàÜ„ÄÇÂ¶ÇÊûúÂ∑≤ÁªèÁü•ÈÅìÁöÑ‰∫ÜÂ∞±Áõ¥Êé•Ë∑≥Ëøá„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142// Set up a normal interrupt/trap gate descriptor. ËÆæÁΩÆ‰∏Ä‰∏™Ê≠£Â∏∏‰∏≠Êñ≠Èô∑Èò±ÂÖ•Âè£ ÊèèËø∞Á¨¶// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate. 1ÊòØtrap 0ÊòØinterrupt // see section 9.6.1.3 of the i386 reference: "The difference between //ÁúãÁúãÈÇ£‰∏™Âï• // an interrupt gate and a trap gate is in the effect on IF (the //‰∏≠Êñ≠Èó®ÂíåÈô∑Èò±Èó®ÊúâÂï•‰∏ç‰∏ÄÊ†∑Âú®IFÔºà‰∏≠Êñ≠ÂÖÅËÆ∏ÁöÑÊ†áÂøóÔºâ‰∏äÈù¢ // interrupt-enable flag). An interrupt that vectors through an//‰∏≠Êñ≠ÂêëÈáèÈÄöËøá ‰∏≠Êñ≠Èó®ÈáçÁΩÆ IF ‰ªéËÄåÁªÑÁªáÂÖ∂‰ªñ‰∏≠Êñ≠‰∏≠Êñ≠ÂΩìÂâç‰∏≠Êñ≠„ÄÇ // interrupt gate resets IF, thereby preventing other interrupts from // interfering with the current interrupt handler. A subsequent IRET // ÁÑ∂ÂêéÁÑ∂ÂêéÁî®IRET ÊÅ¢Â§ç„ÄÇ // instruction restores IF to the value in the EFLAGS image on the // stack. An interrupt through a trap gate does not change IF." //ËØ¥ÁöÑÁÆÄÂçïÁÇπÔºå‰∏≠Êñ≠‰∏çËÉΩÂÜçÊ¨°‰∏≠Êñ≠Ôºåtrap ÂèØ‰ª•Ë¢´‰∏≠Êñ≠„ÄÇ// - sel: Code segment selector for interrupt/trap handler ‰ª£Á†ÅÊÆµÂú∞ÂùÄ// - off: Offset in code segment for interrupt/trap handler //‰ª£Á†ÅÊÆµÂÅèÁßª// - dpl: Descriptor Privilege Level - ÁâπÊùÉÁ≠âÁ∫ß// the privilege level required for software to invoke //ËΩØ‰ª∂Á≠âÁ∫ß// this interrupt/trap gate explicitly using an int instruction.//int Êåá‰ª§Ë∞ÉÁî®Ôºü#define SETGATE(gate, istrap, sel, off, dpl) \&#123; \ (gate).gd_off_15_0 = (uint32_t) (off) &amp; 0xffff; \ (gate).gd_sel = (sel); \ (gate).gd_args = 0; \ (gate).gd_rsv1 = 0; \ (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32; \ (gate).gd_s = 0; \ (gate).gd_dpl = (dpl); \ (gate).gd_p = 1; \ (gate).gd_off_31_16 = (uint32_t) (off) &gt;&gt; 16; \&#125;// Set up a call gate descriptor. //Âª∫Á´ãÂëºÂè´Èó®ÊèèËø∞ÔºüÔºüÔºü Âíå‰∏äÈù¢Â•ΩÂÉèÊ≤°Âï•Â∑ÆË∑ùÔºåÂ∞±ÊòØÂ∞ë‰∫Ü‰∏™istrap#define SETCALLGATE(gate, sel, off, dpl) \&#123; \ (gate).gd_off_15_0 = (uint32_t) (off) &amp; 0xffff; \ (gate).gd_sel = (sel); \ (gate).gd_args = 0; \ (gate).gd_rsv1 = 0; \ (gate).gd_type = STS_CG32; \ (gate).gd_s = 0; \ (gate).gd_dpl = (dpl); \ (gate).gd_p = 1; \ (gate).gd_off_31_16 = (uint32_t) (off) &gt;&gt; 16; \&#125; ÂêéÈù¢Â∞±ÊòØÂëäËØâ‰Ω†_alltraps Ë¶ÅÂÆûÁé∞Âï•„ÄÇÊàë‰ª¨ËøòÊòØÂÖàÂÆûÁé∞Á¨¨‰∏Ä‰∏™trapentry.S.12345678910111213141516171819202122232425262728293031323334353637383940414243.text/* * Lab 3: Your code here for generating entry points for the different traps. */ /* ÊàëÁé∞Âú®‰πü‰∏çÁü•ÈÅì‰∏∫Âï•Ëøô‰∏™ÊòØËøô‰∏™ ÈÇ£‰∏™ÊòØÈÇ£‰∏™*/TRAPHANDLER_NOEC(t_divide, T_DIVIDE)TRAPHANDLER_NOEC(t_debug, T_DEBUG)TRAPHANDLER_NOEC(t_nmi, T_NMI)TRAPHANDLER_NOEC(t_brkpt, T_BRKPT)TRAPHANDLER_NOEC(t_oflow, T_OFLOW)TRAPHANDLER_NOEC(t_bound, T_BOUND)TRAPHANDLER_NOEC(t_illop, T_ILLOP)TRAPHANDLER_NOEC(t_device, T_DEVICE)TRAPHANDLER(t_dblflt, T_DBLFLT)TRAPHANDLER(t_tss, T_TSS)TRAPHANDLER(t_segnp, T_SEGNP)TRAPHANDLER(t_stack, T_STACK)TRAPHANDLER(t_gpflt, T_GPFLT)TRAPHANDLER(t_pgflt, T_PGFLT)TRAPHANDLER_NOEC(t_fperr, T_FPERR)TRAPHANDLER(t_align, T_ALIGN)TRAPHANDLER_NOEC(t_mchk, T_MCHK)TRAPHANDLER_NOEC(t_simderr, T_SIMDERR)TRAPHANDLER_NOEC(t_syscall, T_SYSCALL)/* * Lab 3: Your code here for _alltraps */ _alltraps: pushl %ds pushl %es pushal /* push all general registers */ movl $GD_KD, %eax movw %ax, %ds movw %ax, %es push %esp call trap ÁÑ∂Âêé trap_init()Ôºõ12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void t_divide();void t_debug();void t_nmi();void t_brkpt();void t_oflow();void t_bound();void t_illop();void t_device();void t_dblflt();void t_tss();void t_segnp();void t_stack();void t_gpflt();void t_pgflt();void t_fperr();void t_align();void t_mchk();void t_simderr();void t_syscall();voidtrap_init(void)&#123; extern struct Segdesc gdt[]; // LAB 3: Your code here. SETGATE(idt[T_DIVIDE], 0, GD_KT, t_divide, 0); SETGATE(idt[T_DEBUG], 0, GD_KT, t_debug, 0); SETGATE(idt[T_NMI], 0, GD_KT, t_nmi, 0); SETGATE(idt[T_BRKPT], 0, GD_KT, t_brkpt, 3); SETGATE(idt[T_OFLOW], 0, GD_KT, t_oflow, 0); SETGATE(idt[T_BOUND], 0, GD_KT, t_bound, 0); SETGATE(idt[T_ILLOP], 0, GD_KT, t_illop, 0); SETGATE(idt[T_DEVICE], 0, GD_KT, t_device, 0); SETGATE(idt[T_DBLFLT], 0, GD_KT, t_dblflt, 0); SETGATE(idt[T_TSS], 0, GD_KT, t_tss, 0); SETGATE(idt[T_SEGNP], 0, GD_KT, t_segnp, 0); SETGATE(idt[T_STACK], 0, GD_KT, t_stack, 0); SETGATE(idt[T_GPFLT], 0, GD_KT, t_gpflt, 0); SETGATE(idt[T_PGFLT], 0, GD_KT, t_pgflt, 0); SETGATE(idt[T_FPERR], 0, GD_KT, t_fperr, 0); SETGATE(idt[T_ALIGN], 0, GD_KT, t_align, 0); SETGATE(idt[T_MCHK], 0, GD_KT, t_mchk, 0); SETGATE(idt[T_SIMDERR], 0, GD_KT, t_simderr, 0); SETGATE(idt[T_SYSCALL], 0, GD_KT, t_syscall, 3); // Per-CPU setup trap_init_percpu();&#125; Áî®Ëøô‰∏™ÂèØ‰ª•Ëøá‰∫ÜÔºå‰ΩÜÊòØÊàëÁúãÂà∞‰∏Ä‰∏™ÈùûÂ∏∏È™öÁöÑÊìç‰ΩúÔºå‰πüÂ∞±ÊòØÊåëÊàò.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#define TRAPHANDLER(name, num, ec, user) \.text; \ .globl name; /* define global symbol for 'name' */ \ .type name, @function; /* symbol type is function */ \ .align 2; /* align function definition */ \ name: /* function starts here */ \ .if ec==0; \ pushl $0; \ .endif; \ pushl $(num); \ jmp _alltraps; \.data; \ .long num, name, user.data .globl trapEntry trapEntry:.textTRAPHANDLER(trapEntry0, T_DIVIDE, 0, 0);TRAPHANDLER(trapEntry1, T_DEBUG, 0, 0);TRAPHANDLER(trapEntry2, T_NMI, 0, 0);TRAPHANDLER(trapEntry3, T_BRKPT, 0, 3);TRAPHANDLER(trapEntry4, T_OFLOW, 0, 0);TRAPHANDLER(trapEntry5, T_BOUND, 0, 0);TRAPHANDLER(trapEntry6, T_ILLOP, 0, 0);TRAPHANDLER(trapEntry7, T_DEVICE, 0, 0);TRAPHANDLER(trapEntry8, T_DBLFLT, 1, 0);TRAPHANDLER(trapEntry10, T_TSS, 1, 0);TRAPHANDLER(trapEntry11, T_SEGNP, 1, 0);TRAPHANDLER(trapEntry12, T_STACK, 1, 0);TRAPHANDLER(trapEntry13, T_GPFLT, 1, 0);TRAPHANDLER(trapEntry14, T_PGFLT, 1, 0);TRAPHANDLER(trapEntry16, T_FPERR, 0, 0);TRAPHANDLER(trapEntry17, T_ALIGN, 1, 0);TRAPHANDLER(trapEntry18, T_MCHK, 0, 0);TRAPHANDLER(trapEntry19, T_SIMDERR, 0, 0);//TRAPHANDLER(trapEntry20, T_SYSCALL, 1, 3);.data .long 0, 0, 0/* * Lab 3: Your code here for _alltraps */.text_alltraps: pushl %ds pushl %es pushal /* push all general registers */ movw $GD_KD, %ax movw %ax, %ds movw %ax, %es pushl %esp call trapvoidtrap_init(void)&#123; extern struct Segdesc gdt[]; extern long trapEntry[][3]; // trapEntry[][0]: interrupt/exception vector // trapEntry[][1]: interrupt/exception handler trapEntry point // trapEntry[][2]: DPL for (int i = 0; trapEntry[i][1] != 0; i++ ) SETGATE(idt[trapEntry[i][0]], 0, GD_KT, trapEntry[i][1], trapEntry[i][2]); // Per-CPU setup trap_init_percpu();&#125; Á•û‰ªôÂÜôÊ≥ïÔºåÁúã‰∏çÊáÇÔºå‰ΩÜÊòØÂ§ßËá¥ËÉΩÁêÜËß£Âï•ÊÑèÊÄù„ÄÇÈ™ö‰∏çËøáÔºåÈ™ö‰∏çËøáÔºåÁúüÁöÑÈ™ö‰∏çËøá„ÄÇ QuestionÁ¨¨‰∏Ä‰∏™Ê≤°ÊúâÂøÖË¶ÅÂõûÁ≠î‰∫ÜÂêß„ÄÇ‰∏çÂêå‰∏≠Êñ≠Â§ÑÁêÜ‰∏çÂêå„ÄÇÁ¨¨‰∫å‰∏™ÈóÆÈ¢òÔºåÂ•ΩÂÉèÈóÆuser/softint‰∏∫Âï•‰ºö‰∫ßÁîü trap 13 ‰∏≠Êñ≠„ÄÇÊü•Áúãuser/softint.c123456789// buggy program - causes an illegal software interrupt#include &lt;inc/lib.h&gt;voidumain(int argc, char **argv)&#123; asm volatile("int $14"); // page fault&#125; Ë∞ÉÁî®int $14‰∫ßÁîü‰∫Ü‰∏Ä‰∏™ËΩØ‰∏≠Êñ≠„ÄÇÂΩìÂºÇÂ∏∏Êàñ‰∏≠Êñ≠ÊòØÁî±int n,int 3,int 0Êåá‰ª§‰∫ßÁîüÊó∂ÔºåÂ§ÑÁêÜÂô®Êâç‰ºöÊ£ÄÊü•‰∏≠Êñ≠ÊàñÈô∑Èò±Èó®ÁöÑDPL„ÄÇÊ≠§Êó∂CPLÊï∞ÂÄº‰∏äÂøÖÈ°ªÂ∞è‰∫éÊàñÁ≠â‰∫éDPL„ÄÇËøô‰∏™ÈôêÂà∂ÂèØ‰ª•Èò≤Ê≠¢ÁâπÊùÉÁ∫ß‰∏∫3ÁöÑÂ∫îÁî®Á®ãÂ∫è‰ΩøÁî®ËΩØ‰ª∂‰∏≠Êñ≠ËÆøÈóÆÈáçË¶ÅÁöÑÂºÇÂ∏∏Â§ÑÁêÜËøáÁ®ã„ÄÇÂΩìÁî®Êà∑Á∫ß‰ΩøÁî®ËΩØ‰ª∂‰∏≠Êñ≠Êó∂‰ºöÂºïÂèë‰∏Ä‰∏™General Protection ExceptionÔºåÂç≥trap 13„ÄÇ Part B: Page Faults, Breakpoints Exceptions, and System CallsÊàë‰ª¨Áé∞Âú®Â∑≤ÁªèÊúâ‰∫ÜÂ§ÑÁêÜ‰∏ÄÈÉ®ÂàÜ‰∏≠Êñ≠ÁöÑËÉΩÂäõ‰∫ÜÔºåÁÑ∂Êàë‰ª¨Êù•ÁúãÁúã‰ªñÂÅö‰∫ÜÂï•„ÄÇÂú®‰∏≠Êñ≠ÊúÄÂêé‰∏Ä‰∏™ÂáΩÊï∞_alltrapsË∞ÉÁî®‰∫Ütrap(),ÁÑ∂ÂêéÊàë‰ª¨Âéª‰∫Ükern/trap()ÈáåÈù¢„ÄÇÊàë‰ª¨Êù•ÂàÜÊûêÂàÜÊûê„ÄÇ1234567891011121314151617181920212223242526272829303132333435363738394041voidtrap(struct Trapframe *tf)&#123; // The environment may have set DF and some versions // of GCC rely on DF being clear CLD Ê∏ÖÈô§DF Â§ç‰Ωç Âπ≤Âï•ÁöÑ‰πü‰∏çÁü•ÈÅì asm volatile("cld" ::: "cc"); // Check that interrupts are disabled. If this assertion // fails, DO NOT be tempted to fix it by inserting a "cli" in // the interrupt path. Áúã‰∏≠Êñ≠ÊúâÊ≤°ÊúâÂÖ≥‰∫Ü assert(!(read_eflags() &amp; FL_IF));//Ê£ÄÊü•EFLAGSÂØÑÂ≠òÂô®ÁöÑIFÊ†áÂøó‰ΩçÊòØÂê¶ÁΩÆ0ÔºåÂç≥ÂøΩÁï•ÂèØÂ±èËîΩÁöÑÂ§ñÈÉ®‰∏≠Êñ≠ cprintf("Incoming TRAP frame at %p\n", tf); if ((tf-&gt;tf_cs &amp; 3) == 3) &#123;//ifËØ≠Âè•Âà§Êñ≠TrapFrame‰∏≠ÁöÑcsÂØÑÂ≠òÂô®ÁöÑCPLÊòØÂê¶Á≠â‰∫é3ÔºåÂç≥ÊòØÂê¶ÊòØ‰ªéÁî®Êà∑ÊÄÅËß¶ÂèëÁöÑ‰∏≠Êñ≠ //Â¶ÇÊûú‰ªéÁî®Êà∑ÊÄÅËß¶ÂèëÁöÑ‰∏≠Êñ≠ÔºåÊ£ÄÊü•ÂΩìÂâçËøõÁ®ãÊòØÂê¶Â≠òÂú®ÔºåËøô‰∏™Â∫îËØ•ÊòØÊ£ÄÊü•monitor‰∏ãÊòØ‰∏çËÉΩÂá∫Áé∞‰∏≠Êñ≠ÁöÑÔºåÁÑ∂ÂêéÊõ¥Êñ∞ÂΩìÂâçËøõÁ®ãÁöÑenv_tfÂüüÔºåÂπ∂ÊúÄÁªàÂ∞ÜtfÊåáÈíàÊõ¥Êñ∞‰∏∫ËøõÁ®ãÁöÑenv_tfÂüüÁöÑÊåáÈíàÔºåËøô‰πàÂÅöÁöÑÂéüÂõ†‰ºöÂú®‰∏ã‰∏ÄÁØáÊñáÁ´†[ÂêØÂä®Áî®Êà∑ËøõÁ®ãÔºå‰∫ßÁîü‰∏≠Êñ≠„ÄÅÁ≥ªÁªüË∞ÉÁî®ÁöÑËøáÁ®ãÂàÜÊûê]‰∏≠ËØ¥Êòé // Trapped from user mode. assert(curenv); // Copy trap frame (which is currently on the stack) // into 'curenv-&gt;env_tf', so that running the environment // will restart at the trap point. curenv-&gt;env_tf = *tf; // The trapframe on the stack should be ignored from here on. tf = &amp;curenv-&gt;env_tf; &#125; // Record that tf is the last real trapframe so // print_trapframe can print some additional information. //Êõ¥Êñ∞last_tf last_tf = tf; // Dispatch based on what type of trap occurred //‰∫éÂèëÁîüÁöÑ‰∏≠Êñ≠ÁöÑÁ±ªÂûãËøõË°åÂàÜÂèë„ÄÇ trap_dispatch(tf); // Return to the current environment, which should be running. //ÂõûÂà∞ËøõÁ®ãÁöÑÁî®Êà∑ÊÄÅ assert(curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING); env_run(curenv);&#125; ‰πüÂ∞±ÊòØËØ¥ ÔºåÊàë‰ª¨Âú® trap_dispatch()ÂØπ‰∏≠Êñ≠ËøõË°å‰∫ÜÂàÜÈÖç„ÄÇ Handling Page FaultsÁº∫È°µÊïÖÈöúÁöÑ‰∏≠Êñ≠ÂêëÈáè‰∏∫14(T_PGFLT)ÊòØ‰∏Ä‰∏™ÂæàÈáçË¶ÅÁöÑÂºÇÂ∏∏ÔºåÂõ†‰∏∫Êàë‰ª¨Âú®ÂêéÁª≠ÁöÑÂÆûÈ™å‰∏≠ÔºåÈùûÂ∏∏‰æùËµñ‰∫éËÉΩÂ§üÂ§ÑÁêÜÁº∫È°µ‰∏≠Êñ≠ÁöÑËÉΩÂäõ„ÄÇÂΩìÁº∫È°µ‰∏≠Êñ≠ÂèëÁîüÊó∂ÔºåÁ≥ªÁªü‰ºöÊääÂºïËµ∑‰∏≠Êñ≠ÁöÑÁ∫øÊÄßÂú∞ÂùÄÂ≠òÊîæÂà∞ÊéßÂà∂ÂØÑÂ≠òÂô®CR2‰∏≠„ÄÇÂú®trap.c‰∏≠ÔºåÂ∑≤ÁªèÊèê‰æõ‰∫Ü‰∏Ä‰∏™ËÉΩÂ§üÂ§ÑÁêÜËøôÁßçÁº∫È°µÂºÇÂ∏∏ÁöÑÂáΩÊï∞page_fault_handler()„ÄÇÊâÄ‰ª•Êàë‰ª¨Â∞±Ë¶ÅÂàÜÈÖçÂà∞Ëøô‰∏™ÂáΩÊï∞„ÄÇËøô‰∏™if else ÊàñËÄÖswitch Âà§Êñ≠‰∏Ä‰∏ãÂ∞±Ë°åÔºåÊ≤°Âï•ËØ¥ÁöÑ‰∏çÈúÄË¶ÅÂÖàÂÅö‰ªª‰ΩïÊìç‰Ωú„ÄÇ1234switch(tf-&gt;tf_trapno) &#123; case (T_PGFLT): page_fault_handler(tf); break; Â∞±ËøôÊ†∑Â∞±Ë°å‰∫Ü„ÄÇÊé•ÁùÄÊàë‰ª¨ÂéªÁúãÁúã page_fault_handler()123456789101112131415161718192021222324voidpage_fault_handler(struct Trapframe *tf)&#123; uint32_t fault_va; // Read processor's CR2 register to find the faulting address fault_va = rcr2(); // Handle kernel-mode page faults. // LAB 3: Your code here. if(tf-&gt;tf_cs &amp;&amp; 0x01 == 0) &#123; //ÂèëÁîüÂú®ÂÜÖÊ†∏ÊÄÅ Â∞±Êä•ÈîôÔºåÂõ†‰∏∫Â¶ÇÊûúÊòØÂÜÖÊ†∏ÊÄÅÂá∫ÈîôÔºåËØ¥ÊòéÂÜÖÊ†∏Âá∫ÈóÆÈ¢ò‰∫Ü panic("page_fault in kernel mode, fault address %d\n", fault_va); &#125; // We've already handled kernel-mode exceptions, so if we get here, // the page fault happened in user mode. // Destroy the environment that caused the fault. //Â¶ÇÊûúÊòØÁî®Êà∑ÊÄÅÔºåÂ∞±Âà†Èô§Ëøô‰∏™ËøõÁ®ã cprintf("Áî®Êà∑ÊÄÅÂÜÖÂ≠òÂá∫Èîô Ôºö[%08x] user fault va %08x ip %08x\n", curenv-&gt;env_id, fault_va, tf-&gt;tf_eip); print_trapframe(tf); env_destroy(curenv);&#125; ÂêéÈù¢Ëøò‰ºöÁªßÁª≠ÂÆåÂñÑÔºåÂΩìÊàë‰ª¨ÂÆåÊàêÁ≥ªÁªüË∞ÉÁî® The Breakpoint ExceptionÊñ≠ÁÇπÂºÇÂ∏∏ÁöÑ‰∏≠Êñ≠ÂêëÈáè‰∏∫3(T_BRKPT)ÔºåËøô‰∏™ÂºÇÂ∏∏ÂèØ‰ª•ËÆ©Ë∞ÉËØïÂô®ËÉΩÂ§üÁªôÁ®ãÂ∫èÂä†‰∏äÊñ≠ÁÇπ„ÄÇÂä†Êñ≠ÁÇπÁöÑÂü∫Êú¨ÂéüÁêÜÂ∞±ÊòØÊääË¶ÅÂä†Êñ≠ÁÇπÁöÑËØ≠Âè•Áî®‰∏Ä‰∏™1Â≠óËäÇÁöÑINT 3ËΩØ‰ª∂‰∏≠Êñ≠Êåá‰ª§ÊõøÊç¢ÔºåÊâßË°åÂà∞INT 3Êó∂Ôºå‰ºöËß¶ÂèëËΩØ‰∏≠Êñ≠„ÄÇÂú®JOS‰∏≠ÔºåÊàë‰ª¨Â∞ÜÈÄöËøáÊääËøô‰∏™ÂºÇÂ∏∏ËΩ¨Êç¢Êàê‰∏Ä‰∏™‰º™Á≥ªÁªüË∞ÉÁî®ÔºåËøôÊ†∑ÁöÑËØù‰ªª‰ΩïÁî®Êà∑ÁéØÂ¢ÉÈÉΩÂèØ‰ª•‰ΩøÁî®Ëøô‰∏™‰º™Á≥ªÁªüË∞ÉÁî®Êù•Ëß¶ÂèëJOS kernel monitor„ÄÇÂ¶ÇÊûúÂ∞ÜJOS kernel monitorÂΩìÂÅöÂéüÂßãÁöÑË∞ÉËØïÂô®ÁöÑËØùÔºåÊñ≠ÁÇπÂºÇÂ∏∏ÁöÑËøôÁßçÁî®Ê≥ïÂÆûÈôÖ‰∏äÊòØÂêàÁêÜÁöÑ„ÄÇlib/panic.c‰∏≠panic()ÂáΩÊï∞ÁöÑÁî®Êà∑ÊÄÅÂÆûÁé∞Â∞±ÊòØÂú®Â±ïÁ§∫panic‰ø°ÊÅØ‰πãÂêéÔºåË∞ÉÁî®int 3„ÄÇ Ëøô‰∏™Êàë‰πüÊØè‰∏™ÊêûÊáÇÔºå‰∏∫Âï•ÊòØË∞ÉÁî®monitor. 123case (T_BRKPT): monitor(tf); break; ÂêéÈù¢ÁöÑÊåëÊàòÔºåÊòØË¶ÅÊàë‰ª¨ÂÆûÁé∞ÔºåÂçïÊ≠•Ë∞ÉËØïÂï•ÁöÑ„ÄÇÊàë‰∏ç‰ºöÂëäËæû„ÄÇ Question ÈóÆ‰Ω†‰∏∫Âï•ËøêË°åbreakpoint(ÊÄé‰πàËøêË°åËøô‰∏™ÔºåÂâçÈù¢Êúâ‰∏™ÁªÉ‰π†ÊòØËØ¥‰∫Ü run-name)ÂèØ‰ª•ÊòØGeneral Protection ‰πüÂèØ‰ª•ÊòØÊòØBreakpoint.Ëøô‰∏™ÊòØÁî±trap_init ÂàùÂßãÂåñÁöÑÊó∂ÂÄôÂÅöÁöÑ„ÄÇÂíåÁªÉ‰π†‰∫åÊòØ‰∏ÄÊ†∑ÁöÑÈóÆÈ¢ò„ÄÇSETGATE(idt[T_BRKPT], 0, GD_KT, t_brkpt, 3);ÊääÊúÄÂêéËøô‰∏™3 Êç¢Êàê0Ôºå‰Ω†ÂÜçË∑ë‰∏Ä‰∏ãÂ∞±Áü•ÈÅì‰∏∫Âï•‰∫Ü„ÄÇDPLÂ≠óÊÆµ‰ª£Ë°®ÁöÑÂê´‰πâÊòØÊÆµÊèèËø∞Á¨¶‰ºòÂÖàÁ∫ßÔºàDescriptor Privileged LevelÔºâÔºåÂ¶ÇÊûúÊàë‰ª¨ÊÉ≥Ë¶ÅÂΩìÂâçÊâßË°åÁöÑÁ®ãÂ∫èËÉΩÂ§üË∑≥ËΩ¨Âà∞Ëøô‰∏™ÊèèËø∞Á¨¶ÊâÄÊåáÂêëÁöÑÁ®ãÂ∫èÂì™ÈáåÁªßÁª≠ÊâßË°åÁöÑËØùÔºåÊúâ‰∏™Ë¶ÅÊ±ÇÔºåÂ∞±ÊòØË¶ÅÊ±ÇÂΩìÂâçËøêË°åÁ®ãÂ∫èÁöÑCPLÔºåRPLÁöÑÊúÄÂ§ßÂÄºÈúÄË¶ÅÂ∞è‰∫éÁ≠â‰∫éDPLÔºåÂê¶ÂàôÂ∞±‰ºöÂá∫Áé∞‰ºòÂÖàÁ∫ß‰ΩéÁöÑ‰ª£Á†ÅËØïÂõæÂéªËÆøÈóÆ‰ºòÂÖàÁ∫ßÈ´òÁöÑ‰ª£Á†ÅÁöÑÊÉÖÂÜµÔºåÂ∞±‰ºöËß¶Âèëgeneral protection exception„ÄÇÈÇ£‰πàÊàë‰ª¨ÁöÑÊµãËØïÁ®ãÂ∫èÈ¶ñÂÖàËøêË°å‰∫éÁî®Êà∑ÊÄÅÔºåÂÆÉÁöÑCPL‰∏∫3ÔºåÂΩìÂºÇÂ∏∏ÂèëÁîüÊó∂ÔºåÂÆÉÂ∏åÊúõÂéªÊâßË°å int 3Êåá‰ª§ÔºåËøôÊòØ‰∏Ä‰∏™Á≥ªÁªüÁ∫ßÂà´ÁöÑÊåá‰ª§ÔºåÁî®Êà∑ÊÄÅÂëΩ‰ª§ÁöÑCPL‰∏ÄÂÆöÂ§ß‰∫é int 3 ÁöÑDPLÔºåÊâÄ‰ª•Â∞±‰ºöËß¶Âèëgeneral protection exceptionÔºå‰ΩÜÊòØÂ¶ÇÊûúÊääIDTËøô‰∏™Ë°®È°πÁöÑDPLËÆæÁΩÆ‰∏∫3Êó∂ÔºåÂ∞±‰∏ç‰ºöÂá∫Áé∞ËøôÊ†∑ÁöÑÁé∞Ë±°‰∫ÜÔºåËøôÊó∂Â¶ÇÊûúÂÜçÂá∫Áé∞ÂºÇÂ∏∏ÔºåËÇØÂÆöÊòØÂõ†‰∏∫Êàë‰ª¨ËøòÊ≤°ÊúâÁºñÂÜôÂ§ÑÁêÜbreak point exceptionÁöÑÁ®ãÂ∫èÊâÄÂºïËµ∑ÁöÑÔºåÊâÄ‰ª•ÊòØbreak point exception„ÄÇ ÁÆÄÂçïÊù•ËØ¥ÔºåÂ∞±ÊòØbreakpointÂÅáÂ¶ÇËÆæÁΩÆÂú®ÂÜÖÊ†∏ÊÄÅÔºåÁî®Êà∑ÊÄÅÂ∞±ÈúÄË¶Å‰øùÊä§‰∏Ä‰∏ãÔºåËøõÂÖ•ÂÜÖÊ†∏ÊÄÅ„ÄÇ Ëøô‰∏™Âíå‰∏äÈù¢Â∑Æ‰∏çÂ§ö„ÄÇSystem callsÁî®Êà∑Á®ãÂ∫èÈÄöËøáÁ≥ªÁªüË∞ÉÁî®ËÆ©ÂÜÖÊ†∏Â∏ÆÂÆÉÂÅö‰∫ã„ÄÇÂΩìÁî®Êà∑Á®ãÂ∫èËß¶ÂèëÁ≥ªÁªüË∞ÉÁî®ÔºåÂ§ÑÁêÜÂô®ËøõÂÖ•ÂÜÖÊ†∏ÊÄÅ„ÄÇÂ§ÑÁêÜÂô®ÂíåÂÜÖÊ†∏Âêà‰Ωú‰øùÂ≠òËØ•Áî®Êà∑Á®ãÂ∫èÂΩìÂâçÁöÑÁä∂ÊÄÅÔºåÁÑ∂ÂêéÁî±ÂÜÖÊ†∏Â∞ÜÊâßË°åÁõ∏Â∫îÁöÑ‰ª£Á†ÅÂÆåÊàêÁ≥ªÁªüË∞ÉÁî®ÔºåÊúÄÁªàÂõûÂà∞Áî®Êà∑Á®ãÂ∫èÁªßÁª≠ÊâßË°å„ÄÇËÄåÁî®Êà∑Á®ãÂ∫èÂà∞Â∫ïÊòØÂ¶Ç‰ΩïÂºïËµ∑ÂÜÖÊ†∏ÁöÑÊ≥®ÊÑèÔºå‰ª•ÂèäÂÆÉÂ¶Ç‰ΩïËØ¥ÊòéÂÆÉÂ∏åÊúõÊìç‰ΩúÁ≥ªÁªüÂÅö‰ªÄ‰πà‰∫ãÊÉÖÁöÑÊñπÊ≥ïÊòØÊúâÂæàÂ§ö‰∏çÂêåÁöÑÂÆûÁé∞ÊñπÂºèÁöÑ„ÄÇ Âú®JOSÂÜÖÊ†∏‰∏≠ÔºåÊàë‰ª¨‰ºöÈááÁî®intÊåá‰ª§Ëß¶Âèë‰∏Ä‰∏™Â§ÑÁêÜÂô®ÁöÑ‰∏≠Êñ≠„ÄÇÁâπÂà´ÁöÑÔºåÊàë‰ª¨Áî®int $0x30Êù•‰ª£Ë°®Á≥ªÁªüË∞ÉÁî®‰∏≠Êñ≠„ÄÇÊ≥®ÊÑèÔºå‰∏≠Êñ≠0x30‰∏çÊòØÈÄöËøáÁ°¨‰ª∂‰∫ßÁîüÁöÑÔºåÂ∫îËØ•ÂÖÅËÆ∏Áî®Êà∑‰ª£Á†ÅËÉΩÂ§ü‰∫ßÁîü0x30‰∏≠Êñ≠„ÄÇ Â∫îÁî®Á®ãÂ∫è‰ºöÊääÁ≥ªÁªüË∞ÉÁî®Âè∑‰ª•ÂèäÁ≥ªÁªüË∞ÉÁî®ÁöÑÂèÇÊï∞ÊîæÂà∞ÂØÑÂ≠òÂô®‰∏≠„ÄÇÈÄöËøáËøôÁßçÊñπÊ≥ïÔºåÂÜÖÊ†∏Â∞±‰∏çÈúÄË¶ÅÂéªÊü•ËØ¢Áî®Êà∑Á®ãÂ∫èÁöÑÂ†ÜÊ†àÊàñÊåá‰ª§ÊµÅ‰∫Ü„ÄÇÁ≥ªÁªüË∞ÉÁî®Âè∑Â≠òÊîæÂà∞%eax‰∏≠ÔºåÂèÇÊï∞ÂàôÂ≠òÊîæÂú®%edx,%ecx,%ebx,%edi, Âíå %esi ‰∏≠„ÄÇÂÜÖÊ†∏‰ºöÊääËøîÂõûÂÄºÈÄÅÂà∞%eax‰∏≠„ÄÇÂú®lib/syscall.c‰∏≠ÁöÑsyscall()ÂáΩÊï∞Â∞±ÊòØËß¶Âèë‰∏Ä‰∏™Á≥ªÁªüË∞ÉÁî®ÁöÑ‰ª£Á†Å„ÄÇ‰∏çÁî®ËØ¥‰∫ÜÔºåÊàë‰ª¨ÂÖàÂéªÁúãÁúã„ÄÇ12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// System call stubs.#include &lt;inc/syscall.h&gt;#include &lt;inc/lib.h&gt;/* Êù•Ëá™‰∏Ä‰∏™Â§ß‰Ω¨* Âú®JOS‰∏≠ÊâÄÊúâÁ≥ªÁªüË∞ÉÁî®ÈÄöËøásyscallËøô‰∏™ÂáΩÊï∞ËøõË°åÔºöÊâßË°åint T_SYSCALLÔºåÊääÂáΩÊï∞ÂèÇÊï∞Â≠òÂÖ•Ëã•Âπ≤ÊåáÂÆöÁöÑÂØÑÂ≠òÂô®* Âπ∂ÊåáÂÆöÂáΩÊï∞ËøîÂõûÂÄºËøîÂõûÂà∞ÂØÑÂ≠òÂô®ax‰∏≠* Áî®Á¨¨‰∏Ä‰∏™ÂèÇÊï∞numÊù•Á°ÆÂÆöÂà∞Â∫ïÊòØÂì™‰∏™Á≥ªÁªüË∞ÉÁî®* ÂèÇÊï∞num == SYS_cputsÔºåcheck == 0Ôºåa1 == b-&gt;bufÔºå a2 == b-&gt;idxÔºåÂâ©‰∏ãa3„ÄÅa4„ÄÅa5ÈÉΩ‰∏∫0*/static inline int32_tsyscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)&#123; int32_t ret; asm volatile("int %1\n" //Ê±áÁºñÊåá‰ª§Ê®°ÊùøÔºå%1ÊòØÂç†‰ΩçÁ¨¶ÔºåÂØπÂ∫îÂêéÈù¢ÁöÑT_SYSCALL : "=a" (ret) //=Ë°®Á§∫Âú®Ê±áÁºñÈáåÂè™ËÉΩÊîπÂèòËØ•CÂèòÈáèÁöÑÂÄºÔºåËÄå‰∏çËÉΩÂèñÂÆÉÁöÑÂÄº //retÂÄº‰∏é%axÁõ∏ËÅîÁ≥ªÔºåÂç≥Êåá‰ª§ÊâßË°åÂÆåÂêéaxÁöÑÂÄºÂ≠òÂÖ•ÂèòÈáèret : "i" (T_SYSCALL), //‰∏≠Êñ≠ÂêëÈáèT_SYSCALLÔºåÊòØÁ´ãÂç≥Êï∞ "a" (num), //ËæìÂÖ•ÂèÇÊï∞numÔºåÊåá‰ª§ÊâßË°åÂâçÂÖàÂ∞ÜnumÂèòÈáèÁöÑÂÄºÂ≠òÂÖ•%ax "d" (a1), //ËæìÂÖ•ÂèÇÊï∞a1ÔºåÊåá‰ª§ÊâßË°åÂâçÂÖàÂ∞Üa1ÂèòÈáèÁöÑÂÄºÂ≠òÂÖ•%dx "c" (a2), //ÂèÇÊï∞a2Â≠òÂÖ•%cx "b" (a3), //ÂèÇÊï∞a3Â≠òÂÖ•%bx "D" (a4), //ÂèÇÊï∞a4Â≠òÂÖ•%di "S" (a5), //ÂèÇÊï∞a5Â≠òÂÖ•%si : "cc", "memory"); //ÂêëgccÂ£∞ÊòéÂú®ËøôÊù°Ê±áÁºñËØ≠Ë®ÄÊâßË°åÂêéÔºåÊ†áÂøóÂØÑÂ≠òÂô®eflagsÂíåÂÜÖÂ≠òÂèØËÉΩÂèëÁîüÊîπÂèò //Âä†ÂÖ•‚Äúmemory‚ÄùÔºåÂëäËØâGCCÂÜÖÂ≠òÂ∑≤ÁªèË¢´‰øÆÊîπÔºåGCCÂæóÁü•Ëøô‰∏™‰ø°ÊÅØÂêéÔºå //Â∞±‰ºöÂú®ËøôÊÆµÊåá‰ª§‰πãÂâçÔºåÊèíÂÖ•ÂøÖË¶ÅÁöÑÊåá‰ª§Â∞ÜÂâçÈù¢Âõ†‰∏∫‰ºòÂåñÁºìÂ≠òÂà∞ÂØÑÂ≠òÂô®‰∏≠ //ÁöÑÂèòÈáèÂÄºÂÖàÂÜôÂõûÂÜÖÂ≠òÔºåÂ¶ÇÊûú‰ª•ÂêéÂèàË¶Å‰ΩøÁî®Ëøô‰∫õÂèòÈáèÂÜçÈáçÊñ∞ËØªÂèñ„ÄÇ if(check &amp;&amp; ret &gt; 0) panic("syscall %d returned %d (&gt; 0)", num, ret); return ret;&#125;//‰∏ãÈù¢ÊòØÂêÑ‰∏™ÂáΩÊï∞„ÄÇ //ËæìÂá∫ÔºüÔºü Âú®ÊéßÂà∂Âè∞ËæìÂÖ•ËæìÂá∫ ÊòØË¶ÅËøõÂÖ•ÂÜÖÊ†∏ÊÄÅÁöÑvoidsys_cputs(const char *s, size_t len)&#123; syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);&#125;//Ëé∑ÂèñÔºüÔºüÔºüintsys_cgetc(void)&#123; return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);&#125;//Âà†Èô§ÔºüÔºüÔºüintsys_env_destroy(envid_t envid)&#123; return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);&#125;//Ëé∑ÂèñidÔºüÔºüÔºüenvid_tsys_getenvid(void)&#123; return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);&#125; ÁúãÂÆå‰πãÂêéÊù•ÂÅöÁªÉ‰π†7ÔºåÈÇ£‰∏™Âï•ÔºåËÆ©Êàë‰ª¨ÂéªÊääËøô‰∏™Âä†ÂÖ•ÂºÇÂ∏∏ÔºåÊàë‰ª¨ÂéüÊú¨Â∞±Â∑≤ÁªèÂä†ÂÖ•ËøõÂéª‰∫ÜÔºå‰∏çÁî®ÁÆ°„ÄÇÂêéÈù¢ÊàëÂ∞±Áúã‰∏çÊáÇ‰∫Ü‚Ä¶ÔºåÊàëÂèëÁé∞Á≥ªÁªüÂÜÖÊ†∏ÈáåÈù¢ËøòÊúâ‰∏™kern/syscall.cËøô‰∏™ÊòØÂπ≤Âï•ÁöÑ„ÄÇÂà∞Â∫ïË∞ÉÁî®Âì™‰∏™„ÄÇ„ÄÇ„ÄÇÂà´‰∫∫ËØ¥kern/syscall.cÊòØÂ§ñÂ£≥Ôºå‰ΩÜÊòØÊàë‰∏™‰∫∫ÊÑüËßâinc/syscall.cÊâçÊòØ„ÄÇÊàëËßâÂæóÂ∫îËØ•ÊòØinc/syscall.cË∞ÉÁî®‰∫Ükern/syscal.c‰∏çÁü•ÈÅìÂØπ‰∏çÂØπÔºåÊàëÂçïÊ≠•Ë∞ÉËØïÔºåÂπ∂Êü•Áúãhello.asmÊñá‰ª∂ÂÖ∂‰∏≠Ë∞ÉÁî®‰∫Üsys_getenvid „ÄÇÂ∞ÜÊñ≠ÁÇπÊâìÂà∞0x800b15ÂèØ‰ª•ÁúãËßÅ„ÄÇË¶ÅÂú®lib/libmain.cÈáåÈù¢Ë∞ÉÁî®sys_getenvid„ÄÇÂÖà‰∏çÁî®ÁÆ°Ëøô‰∏™ÊòØÂï•Ôºå‰∏ã‰∏™ÂÆûÈ™å‰ºöËÆ≤ÔºåÂÖàÊääËøô‰∏™Ê∑ªËøõÂéªË∞ÉËØï„ÄÇ1234567891011121314151617voidlibmain(int argc, char **argv)&#123; // set thisenv to point at our Env structure in envs[]. // LAB 3: Your code here. thisenv = &amp;envs[ENVX(sys_getenvid())]; // save the name of the program so that panic() can use it if (argc &gt; 0) binaryname = argv[0]; // call user main routine umain(argc, argv); // exit gracefully exit();&#125; 123456789101112131415161718 800b15: 55 push %ebp 800b16: 89 e5 mov %esp,%ebp 800b18: 57 push %edi 800b19: 56 push %esi 800b1a: 53 push %ebx//// The last clause tells the assembler that this can// potentially change the condition codes and arbitrary// memory locations.asm volatile("int %1\n" 800b1b: ba 00 00 00 00 mov $0x0,%edx 800b20: b8 02 00 00 00 mov $0x2,%eax 800b25: 89 d1 mov %edx,%ecx 800b27: 89 d3 mov %edx,%ebx 800b29: 89 d7 mov %edx,%edi 800b2b: 89 d6 mov %edx,%esi 800b2d: cd 30 int $0x30 ËÉΩÂ§üÊòéÊòæÁöÑÁúãËßÅË∞ÉÁî®È¢ù int30,ÊâÄ‰ª•Â∫îËØ•ÊòØ Áî®Êà∑ÈÄöËøáinc/syscall.cËøõË°åÁ≥ªÁªüË∞ÉÁî®„ÄÇÂêéÈù¢Â∞±ÊØîËæÉÁÆÄÂçï‰∫Ü„ÄÇÂâçÈù¢‰πüÂ∑≤ÁªèÊèêÁ§∫‰Ω†‰∫ÜÔºåÊâÄ‰ª•Êàë‰ª¨Áõ¥Êé•Ë∞ÉÁî®Â∞±ÂèØ‰ª•‰∫Ü„ÄÇ123456789case (T_SYSCALL): ret_code = syscall( tf-&gt;tf_regs.reg_eax, tf-&gt;tf_regs.reg_edx, tf-&gt;tf_regs.reg_ecx, tf-&gt;tf_regs.reg_ebx, tf-&gt;tf_regs.reg_edi, tf-&gt;tf_regs.reg_esi); tf-&gt;tf_regs.reg_eax = ret_code; Âú®sysycallÈáåÈù¢Âà§Êñ≠‰ø°Âè∑,ÂàÜÂà´Ë∞ÉÁî®Âì™Âá†‰∏™ÂáΩÊï∞„ÄÇ 123456789101112131415161718192021222324// Dispatches to the correct kernel function, passing the arguments.int32_tsyscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)&#123; // Call the function corresponding to the 'syscallno' parameter. // Return any appropriate return value. // LAB 3: Your code here. // panic("syscall not implemented"); switch (syscallno) &#123; case (SYS_cputs): sys_cputs((const char *)a1, a2); return 0; case (SYS_cgetc): return sys_cgetc(); case (SYS_getenvid): return sys_getenvid(); case (SYS_env_destroy): return sys_env_destroy(a1); default: return -E_INVAL; &#125;&#125; Â§ßÂÆ∂Â§öÁî®gdb Ë∞ÉËØïËá™Â∑±Êü•ÁúãÁ®ãÂ∫èËøêË°åËøáÁ®ãÔºåËøôÊ†∑ÂèØ‰ª•ÁêÜËß£Êõ¥Âø´„ÄÇ ÊåëÊàòÊàëÂ∞±‰∏çÁúã‰∫ÜÔºå‰∏ÄËà¨ÈÉΩÊòØÂÅö‰∏çÂá∫Êù•ÁöÑÔºå‰∏ªË¶ÅÊòØÊ≤°Êó∂Èó¥Êü•ÁúãÁõ∏ÂÖ≥ËµÑÊñô„ÄÇ User-mode startup‰∏ä‰∏Ä‰∏™ÂÆûÈ™åÂ∑≤ÁªèÊää‰ª£Á†ÅÁªô‰∫ÜÔºåÊúÄÂêéÈÇ£‰∏ÄÂùóÂ¶ÇÊûúÂ•ΩÂ•ΩÁêÜËß£‰∫ÜÁöÑËØùÔºåËøô‰∏™Âü∫Êú¨‰∏äÂ∞±ËÉΩÁõ¥Êé•Ëøá‰∫Ü„ÄÇÁî®Êà∑Á®ãÂ∫èÁúüÊ≠£ÂºÄÂßãËøêË°åÁöÑÂú∞ÊñπÊòØÂú®lib/entry.SÊñá‰ª∂‰∏≠„ÄÇËØ•Êñá‰ª∂‰∏≠ÔºåÈ¶ñÂÖà‰ºöËøõË°å‰∏Ä‰∫õËÆæÁΩÆÔºåÁÑ∂ÂêéÂ∞±‰ºöË∞ÉÁî®lib/libmain.c Êñá‰ª∂‰∏≠ÁöÑ libmain() ÂáΩÊï∞„ÄÇ‰Ω†È¶ñÂÖàË¶Å‰øÆÊîπ‰∏Ä‰∏ã libmain() ÂáΩÊï∞Ôºå‰ΩøÂÆÉËÉΩÂ§üÂàùÂßãÂåñÂÖ®Â±ÄÊåáÈíà thisenvÔºåËÆ©ÂÆÉÊåáÂêëÂΩìÂâçÁî®Êà∑ÁéØÂ¢ÉÁöÑ Env ÁªìÊûÑ‰Ωì„ÄÇÁÑ∂Âêé libmain() ÂáΩÊï∞Â∞±‰ºöË∞ÉÁî® umainÔºåËøô‰∏™ umain Á®ãÂ∫èÊÅ∞Â•ΩÊòØ user/hello.c ‰∏≠Ë¢´Ë∞ÉÁî®ÁöÑÂáΩÊï∞„ÄÇÂú®‰πãÂâçÁöÑÂÆûÈ™å‰∏≠Êàë‰ª¨ÂèëÁé∞Ôºåhello.cÁ®ãÂ∫èÂè™‰ºöÊâìÂç∞ hello, world ËøôÂè•ËØùÔºåÁÑ∂ÂêéÂ∞±‰ºöÊä•Âá∫ page fault ÂºÇÂ∏∏ÔºåÂéüÂõ†Â∞±ÊòØ thisenv-&gt;env_id ËøôÊù°ËØ≠Âè•„ÄÇÁé∞Âú®‰Ω†Â∑≤ÁªèÊ≠£Á°ÆÂàùÂßãÂåñ‰∫ÜËøô‰∏™ thisenvÁöÑÂÄºÔºåÂÜçÊ¨°ËøêË°åÂ∞±Â∫îËØ•‰∏ç‰ºöÊä•Èîô‰∫Ü„ÄÇ ‰∏çÁêÜËß£ÁöÑÂèØ‰ª•ÁªßÁª≠ÂçïÊ≠•Ë∞ÉËØï„ÄÇÊñ≠ÁÇπÊâìÂú®f0103003 Page faults and memory protectionËøô‰∏™ÁªÉ‰π†ÔºåÊàë‰ª¨Â∑≤ÁªèÂÅö‰∫Ü‰∏ÄÁÇπ‰∫ÜÔºåÂâçÈÇ£‰∏™ÂáΩÊï∞ÂàÜÈÖçpage_fault_handlerÁöÑÊó∂ÂÄôÊàëÂ∑≤ÁªèÊääpage_fault_handler ÂÆåÂñÑ‰∫Ü„ÄÇËøôÈáåÂ∞±ÊòØÂëäËØâ‰Ω† ÂÜÖÊ†∏Â¶ÇÊûúÁº∫È°µÔºåËØ¥ÊòéÂÜÖÊ†∏Âá∫ÈóÆÈ¢ò‰∫ÜÔºå‰∏çËÉΩÁªßÁª≠ËøêË°å‰∫ÜÔºåÂøÖÈ°ªÊä•Èîôpanic„ÄÇÂ¶ÇÊûúÊòØÁî®Êà∑ËÉΩËß£ÂÜ≥Â∞±Ëß£ÂÜ≥ÔºåËß£ÂÜ≥‰∏ç‰∫ÜÂ∞±Âà†Èô§„ÄÇ1234567891011121314151617181920212223voidpage_fault_handler(struct Trapframe *tf)&#123; uint32_t fault_va; // Read processor's CR2 register to find the faulting address fault_va = rcr2(); // Handle kernel-mode page faults. // LAB 3: Your code here. if(tf-&gt;tf_cs &amp;&amp; 0x01 == 0) &#123; panic("page_fault in kernel mode, fault address %d\n", fault_va); &#125; // We've already handled kernel-mode exceptions, so if we get here, // the page fault happened in user mode. // Destroy the environment that caused the fault. cprintf("[%08x] user fault va %08x ip %08x\n", curenv-&gt;env_id, fault_va, tf-&gt;tf_eip); print_trapframe(tf); env_destroy(curenv);&#125; ÁÑ∂ÂêéÊ†πÊçÆÈ¢òÁõÆÁöÑË¶ÅÊ±ÇÔºåÊàë‰ª¨ËøòË¶ÅÁªßÁª≠ÂÆåÂñÑ kern/pmap.c Êñá‰ª∂‰∏≠ÁöÑ user_mem_assert , user_mem_check ÂáΩÊï∞ÔºåÈÄöËøáËßÇÂØü user_mem_assert ÂáΩÊï∞Êàë‰ª¨ÂèëÁé∞ÔºåÂÆÉË∞ÉÁî®‰∫Ü user_mem_check ÂáΩÊï∞„ÄÇËÄå user_mem_check ÂáΩÊï∞ÁöÑÂäüËÉΩÊòØÊ£ÄÊü•‰∏Ä‰∏ãÂΩìÂâçÁî®Êà∑ÊÄÅÁ®ãÂ∫èÊòØÂê¶ÊúâÂØπËôöÊãüÂú∞ÂùÄÁ©∫Èó¥ [va, va+len] ÁöÑ perm| PTE_P ËÆøÈóÆÊùÉÈôê„ÄÇËá™ÁÑ∂Êàë‰ª¨Ë¶ÅÂÅöÁöÑ‰∫ãÊÉÖÂ∫îËØ•ÊòØÔºåÂÖàÊâæÂà∞Ëøô‰∏™ËôöÊãüÂú∞ÂùÄËåÉÂõ¥ÂØπÂ∫î‰∫éÂΩìÂâçÁî®Êà∑ÊÄÅÁ®ãÂ∫èÁöÑÈ°µË°®‰∏≠ÁöÑÈ°µË°®È°πÔºåÁÑ∂ÂêéÂÜçÂéªÁúã‰∏Ä‰∏ãËøô‰∏™È°µË°®È°π‰∏≠ÊúâÂÖ≥ËÆøÈóÆÊùÉÈôêÁöÑÂ≠óÊÆµÔºåÊòØÂê¶ÂåÖÂê´ perm | PTE_PÔºåÂè™Ë¶ÅÊúâ‰∏Ä‰∏™È°µË°®È°πÊòØ‰∏çÂåÖÂê´ÁöÑÔºåÂ∞±‰ª£Ë°®Á®ãÂ∫èÂØπËøô‰∏™ËåÉÂõ¥ÁöÑËôöÊãüÂú∞ÂùÄÊ≤°Êúâ perm|PTE_P ÁöÑËÆøÈóÆÊùÉÈôê„ÄÇ‰ª•‰∏äÂ∞±ÊòØËøôÊÆµ‰ª£Á†ÅÁöÑÂ§ßËá¥ÊÄùÊÉ≥„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445//Ëøô‰∏™ÂáΩÊï∞ÂàÜÊûê ÂÖàÊåñ‰∏™ÂùëÔºåÂÅö‰∏ã‰∏™ÂÆûÈ™å‰πãÂâçÔºåÊù•Â°´‰∏Ä‰∏ã„ÄÇ//// Check that an environment is allowed to access the range of memory// [va, va+len) with permissions 'perm | PTE_P'. Ê£ÄÊü•ÂÜÖÂ≠òÊùÉÈôê// Normally 'perm' will contain PTE_U at least, but this is not required. ÊùÉÈôêËá≥Â∞ëÊòØPTE_u// 'va' and 'len' need not be page-aligned; you must test every page that// contains any of that range. You will test either 'len/PGSIZE',// 'len/PGSIZE + 1', or 'len/PGSIZE + 2' pages.// Ëøô‰∏™Âú∞ÊñπÂëäËØâ‰Ω† Ôºåva Âíålen ËÇØËÉΩ‰∏çÊòØÈ°µÂØπÈΩêÁöÑÔºå ÈúÄË¶Å‰Ω†Êêû‰∏Ä‰∏ã„ÄÇ// A user program can access a virtual address if (1) the address is below// ULIM, and (2) the page table gives it permission. These are exactly// the tests you should implement here.// Âú∞ÂùÄ Â∫îËØ•Âú®ULIM‰πã‰∏ã ÊùÉÈôêÂ∫îËØ•ÂØπ// If there is an error, set the 'user_mem_check_addr' variable to the first// erroneous virtual address. Â¶ÇÊûúÂá∫Èîô‰∫Ü Êää user_mem_check_addrÂú∞ÂùÄÊåáÂêëÁ¨¨‰∏Ä‰∏™Âá∫ÈîôÁöÑ//// Returns 0 if the user program can access this range of addresses,// and -E_FAULT otherwise.//intuser_mem_check(struct Env *env, const void *va, size_t len, int perm)&#123; // LAB 3: Your code here. char * end = NULL; char * start = NULL; start = ROUNDDOWN((char *)va, PGSIZE); //Ëøô‰∏™Âú∞ÊñπÊòØÈ°µÂØπÈΩê end = ROUNDUP((char *)(va + len), PGSIZE); pte_t *cur = NULL; //ËôöÊãüÂú∞ÂùÄÂØπÂ∫îÁöÑ Áâ©ÁêÜÂú∞ÂùÄ for(; start &lt; end; start += PGSIZE) &#123; cur = pgdir_walk(env-&gt;env_pgdir, (void *)start, 0); //ÈÅçÂéÜËøô‰∏™ËôöÊãüÂú∞ÂùÄ //Ê£ÄÊü•Âú∞ÂùÄ‰ΩçÁΩÆ ÔºåÊùÉÈôê if((int)start &gt; ULIM || cur == NULL || ((uint32_t)(*cur) &amp; perm) != perm) &#123; if(start == ROUNDDOWN((char *)va, PGSIZE)) &#123; //Ëøô‰∏™ÁöÑÊÑèÊÄùÊòØÂ¶ÇÊûú‰∏ÄÂºÄÂú∫Â∞±Èîô‰∫ÜËØ¥ÊòéÂá∫ÈîôÂú®va user_mem_check_addr = (uintptr_t)va; &#125; else &#123; user_mem_check_addr = (uintptr_t)start; &#125; return -E_FAULT; &#125; &#125; return 0;&#125; 1234567891011121314// Print a string to the system console.// The string is exactly 'len' characters long.// Destroys the environment on memory errors.static voidsys_cputs(const char *s, size_t len)&#123; // Check that the user has permission to read memory [s, s+len). // Destroy the environment if not:. //ÂàöÊâçÊàë‰ª¨Â∑≤ÁªèÂÜôËøá‰∫ÜÊ£ÄÊü•ÁöÑÂáΩÊï∞ÔºåË∞ÉÁî®Â∞±ÂèØ‰ª•‰∫Ü„ÄÇ // LAB 3: Your code here. user_mem_assert(curenv, s, len, 0); // Print the string supplied by the user. cprintf("%.*s", len, s);&#125; ÊúÄÁªàÁöÑtrap_dispatch1234567891011121314151617181920212223242526272829303132333435static voidtrap_dispatch(struct Trapframe *tf)&#123; // Handle processor exceptions. // LAB 3: Your code here. // Unexpected trap: The user process or the kernel has a bug. switch(tf-&gt;tf_trapno) &#123; case (T_PGFLT): page_fault_handler(tf); break; case (T_BRKPT): monitor(tf); break; case (T_SYSCALL): // print_trapframe(tf); int32_t ret_code = syscall( tf-&gt;tf_regs.reg_eax, tf-&gt;tf_regs.reg_edx, tf-&gt;tf_regs.reg_ecx, tf-&gt;tf_regs.reg_ebx, tf-&gt;tf_regs.reg_edi, tf-&gt;tf_regs.reg_esi); tf-&gt;tf_regs.reg_eax = ret_code; break; default: // Unexpected trap: The user process or the kernel has a bug. print_trapframe(tf); if (tf-&gt;tf_cs == GD_KT) panic("unhandled trap in kernel"); else &#123; env_destroy(curenv); return; &#125; &#125;&#125; Â¶ÇÊûúÊñáÁ´†ÊúâÈîôËØØÊàñËÄÖÁúã‰∏çÊáÇÔºåÁº∫‰∫ÜÂï•ÁöÑÂèØ‰ª•ÁïôË®Ä„ÄÇ]]></content>
      <categories>
        <category>Êìç‰ΩúÁ≥ªÁªü</category>
        <category>MIT6.828</category>
      </categories>
      <tags>
        <tag>MIT6.828</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT6.828(‰∫å)Lab2:Memory management]]></title>
    <url>%2F2020%2F02%2F18%2FMIT-6.828-(%E4%BA%8C)-Lab-2-Memory-management%2F</url>
    <content type="text"><![CDATA[Lab 2: Memory managementÂÅöËøô‰∏™ÂÆûÈ™å‰πãÂâçÈ¶ñÂÖàÈúÄË¶ÅÁü•ÈÅì‰ªÄ‰πàÊòØÂàÜÈ°µ„ÄÇÂàÜÊÆµÂú®Ëøô‰∏™ÂÆûÈ™åÈáåÈù¢Ê≤°Áî®Âà∞Ëøá„ÄÇ ÂâçÈù¢ÊòØ‰∏ÄÂ§ßÂ†ÜÊïô‰Ω†ÊÄé‰πàËé∑Âèñlab2ËµÑÊ∫êÁöÑÔºåÊàë‰∏çÁü•ÈÅìÊÄé‰πàÂºÑÔºåÂêéÊù•‰π±Êêû‰∫Ü‰∏Ä‰∏ãÔºåÂ∞±Êäälab1ÁöÑË¶ÜÁõñÊéâ‰∫ÜÔºåÂèòÊàê‰∫Ülab2„ÄÇËøô‰∏™ÊàëÁõ∏‰ø°Â∞±Êàë‰∏çÊáÇ„ÄÇ Part 1: Physical Page ManagementÁ¨¨‰∏Ä‰∏™ÊòØÁâ©ÁêÜÈ°µÈù¢ÁÆ°ÁêÜ„ÄÇ12345boot_alloc() //Ëøô‰∏™ÊòØÁ≥ªÁªüÂä†ËΩΩÂâçÂÅö‰∏™Áâ©ÁêÜÂÜÖÂ≠òÂàÜÈÖçÔºå‰πüÂ∞±ÂàùÂßãÂåñÁî®‰∫Ü‰∏Ä‰∏ãmem_init() // È°æÂêçÊÄù‰πâÔºåÂÜÖÂ≠òÂàùÂßãÂåñpage_init() //È°µÈù¢ÂàùÂßãÂåñpage_alloc() //ÁúüÊ≠£ÁöÑÂàÜÈÖçÁâ©ÁêÜÈ°µÈù¢page_free() // È°µÈù¢ÈáäÊîæ È¶ñÂÖàÔºåÊàë‰ª¨ÂÖàËßÇÂØü‰∏Ä‰∏ãinit.cÊñá‰ª∂ÔºåËøô‰∏™ÊòØÂÜÖÊ†∏ÂàùÂßãÂåñË∞ÉÁî®ÁöÑÔºå‰∏ä‰∏™ÂÆûÈ™åÂ∑≤ÁªèÊ∏ÖÊ•ö‰∫Ü„ÄÇ init.c123456789101112131415161718192021222324voidi386_init(void)&#123; extern char edata[], end[]; //ËøôÊòØÂÜÖÊ†∏Êï∞ÊçÆ ‰πüÂ∞±ÊòØÂä†ËΩΩELF ÈáåÈù¢ÁöÑBSSÊÆµÔºåÂÖ®Â±ÄÂèòÈáèÂíåÈùôÊÄÅÂèòÈáè„ÄÇ // Before doing anything else, complete the ELF loading process. // Clear the uninitialized global data (BSS) section of our program. // This ensures that all static/global variables start out zero. memset(edata, 0, end - edata);//ÂàùÂßãÂåñ‰∏∫0 // Initialize the console. // Can't call cprintf until after we do this! //Ëøô‰∏™Â∫îËØ•Áü•ÈÅìÂêßÔºå‰∏ä‰∏™ÂÆûÈ™åËÆ≤ËøáÔºåÂàùÂßãÂåñprintf‰πãÂÜÖÁöÑ cons_init(); cprintf("6828 decimal is %o octal!\n", 6828); //‰∏çËØ¥‰∫ÜÂõ†‰∏∫ÂàáÊç¢Âà∞lab2 ÂèàÂºÄÂßãËæìÂá∫XXÂèØ‰ª•ÂõûÂéªÊîπ‰∏Ä‰∏ã„ÄÇÊîπ‰πüÊ≤°‰∫ãÔºåËøô‰∏™ÂÆûÈ™åÁî®‰∏ç‰∏ä„ÄÇ // Lab 2 memory management initialization functions mem_init(); //Ëøô‰∏™Â∞±ÊòØËøôÊ¨°ÂÆûÈ™åÁöÑÊ†∏ÂøÉÔºå‰∏ªË¶ÅÂ∞±ÊòØËøô‰∏™ ÂêéÈù¢ÁöÑÂ∞±‰∏çÁÆ°‰∫Ü„ÄÇ // Drop into the kernel monitor. while (1) monitor(NULL);&#125; Áúã mem_init()Êàë‰ª¨ÂÖàÁúãÁúãkern/pmap.h Âíåinc/memlayout.hÈáåÈù¢Êúâ‰ªÄ‰πàÔºåÊ≤°ÁúãÊáÇÂ∞±ÁÆó‰∫ÜÔºåÊàë‰πüÊ≤°ÁúãÊáÇÔºåÂ§ßËá¥Áü•ÈÅìÊúâ‰∫õÂï•Â∞±Ë°å‰∫Ü„ÄÇË°•ÂÖÖ‰∏Ä‰∏™inc/mmu.h ‰∏çÁî®Áü•ÈÅìÂÖ∑‰ΩìÂÆûÁé∞Ôºå‰ΩÜÊòØ‰∏Ä‰∫õ‰∏úË•øÂêéÈù¢Áî®ÁöÑË∂ÖÂ§ö„ÄÇ mmu.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318#ifndef JOS_INC_MMU_H#define JOS_INC_MMU_H/* * This file contains definitions for the x86 memory management unit (MMU), * including paging- and segmentation-related data structures and constants, * the %cr0, %cr4, and %eflags registers, and traps. * Ëøô‰∏™Êñá‰ª∂ ÂÆö‰πâ‰∫ÜX86 ÁöÑÂÜÖÂ≠òÁÆ°ÁêÜÂçïÂÖÉÔºåÂåÖÊã¨ÂàÜÊÆµÊä•ÂáΩÊï∞ÔºåËøòÊúâ‰∏Ä‰∫õÂï•ÂØÑÂ≠òÂô®ÔºåÂíåÈô∑Èò±ÔºåÂÖà‰∏çÁÆ°Ëøô‰∫õ„ÄÇ *//* * * Part 1. Paging data structures and constants. *ÈáçÁÇπÂ∞±ÊòØËøô‰∏™È°µÁöÑÁªìÊûÑ Ôºå‰∏ªË¶ÅÂ∞±ÊòØËøô‰∏™ ÂÖ∂‰ªñÁöÑ‰ª•ÂêéÂÜçËØ¥ */// A linear address 'la' has a three-part structure as follows:// ‰∏âÈÉ®ÂàÜÁªìÊûÑ ‰∏Ä‰∏™ ÈìæÊé•Âú∞ÂùÄ È°µÁõÆÂΩï È°µË°® ÂÅèÁßªÂú∞ÂùÄ ÔºåÂ¶ÇÊûúËøô‰∏â‰∏™‰∏çÁü•ÈÅìÔºå‰∫≤!ËøôËæπÂª∫ËÆÆÈáç‰øÆÊìç‰ΩúÁ≥ªÁªüÂíåËÆ°ÁÆóÊú∫ÁªÑÊàêÂéüÁêÜ„ÄÇ ÁÑ∂Âêé PDX PTX PGOFF Áü•ÈÅìÊòØÂÅöÂï•ÁöÑ‰∫ÜÂêß// +--------10------+-------10-------+---------12----------+// | Page Directory | Page Table | Offset within Page |// | Index | Index | |// +----------------+----------------+---------------------+// \--- PDX(la) --/ \--- PTX(la) --/ \---- PGOFF(la) ----/// \---------- PGNUM(la) ----------///// The PDX, PTX, PGOFF, and PGNUM macros decompose linear addresses as shown.// To construct a linear address la from PDX(la), PTX(la), and PGOFF(la),// use PGADDR(PDX(la), PTX(la), PGOFF(la)).// page number field of address#define PGNUM(la) (((uintptr_t) (la)) &gt;&gt; PTXSHIFT)// page directory index#define PDX(la) ((((uintptr_t) (la)) &gt;&gt; PDXSHIFT) &amp; 0x3FF)// page table index#define PTX(la) ((((uintptr_t) (la)) &gt;&gt; PTXSHIFT) &amp; 0x3FF)// offset in pag #define PGOFF(la) (((uintptr_t) (la)) &amp; 0xFFF)// construct linear address from indexes and offset ÈÄöËøá3‰∏™ÂÄº ÊûÑÂª∫ËôöÊãüÂú∞ÂùÄ #define PGADDR(d, t, o) ((void*) ((d) &lt;&lt; PDXSHIFT | (t) &lt;&lt; PTXSHIFT | (o)))// Page directory and page table constants. È°µÁõÆÂΩïÂÖ∂ÂÆûÂ∞±ÊòØ‰∏Ä‰∏™È°µË°® ‰∏ãÈù¢ÊòØ‰ªñ‰ª¨ÂåÖÂê´‰∫ÜÂï•#define NPDENTRIES 1024 // page directory entries per page directory#define NPTENTRIES 1024 // page table entries per page table#define PGSIZE 4096 // bytes mapped by a page ‰∏Ä‰∏™È°µÁöÑÂ§ßÂ∞è#define PGSHIFT 12 // log2(PGSIZE)#define PTSIZE (PGSIZE*NPTENTRIES) // bytes mapped by a page directory entry#define PTSHIFT 22 // log2(PTSIZE)#define PTXSHIFT 12 // offset of PTX in a linear address#define PDXSHIFT 22 // offset of PDX in a linear address#define PTE_P 0x001 // Present ÂØπÂ∫îÁâ©ÁêÜÈ°µÈù¢ÊòØÂê¶Â≠òÂú®#define PTE_W 0x002 // Writeable ÂØπÂ∫îÁâ©ÁêÜÈ°µÈù¢ÊòØÂê¶ÂèØÂÜô#define PTE_U 0x004 // User ÂØπÂ∫îÁâ©ÁêÜÈ°µÈù¢Áî®Êà∑ÊÄÅÊòØÂê¶ÂèØ‰ª•ËÆøÈóÆ#define PTE_PWT 0x008 // Write-Through ÂØπÂ∫îÁâ©ÁêÜÈ°µÈù¢Âú®ÂÜôÂÖ•Êó∂ÊòØÂê¶ÂÜôÈÄè(Âç≥ÂêëÊõ¥‰ΩéÁ∫ßÂÇ®Â≠òËÆæÂ§áÂÜôÂÖ•)#define PTE_PCD 0x010 // Cache-Disable ÂØπÂ∫îÁâ©ÁêÜÈ°µÈù¢ÊòØÂê¶ËÉΩË¢´ÊîæÂÖ•È´òÈÄüÁºìÂ≠ò#define PTE_A 0x020 // Accessed ÂØπÂ∫îÁâ©ÁêÜÈ°µÈù¢ÊòØÂê¶Ë¢´ËÆøÈóÆ#define PTE_D 0x040 // Dirty ÂØπÂ∫îÁâ©ÁêÜÈ°µÈù¢ÊòØÂê¶Ë¢´ÂÜô#define PTE_PS 0x080 // Page Size ÂØπÂ∫îÁâ©ÁêÜÈ°µÈù¢ÁöÑÈ°µÈù¢Â§ßÂ∞è#define PTE_G 0x100 // Global Ëøô‰∏™Êàë‰πü‰∏çÁü•ÈÅì// The PTE_AVAIL bits aren't used by the kernel or interpreted by the// hardware, so user processes are allowed to set them arbitrarily.#define PTE_AVAIL 0xE00 // Available for software use// Flags in PTE_SYSCALL may be used in system calls. (Others may not.) Ëøô‰∏§‰∏™Ê≤°Áî®Âà∞Ëøá#define PTE_SYSCALL (PTE_AVAIL | PTE_P | PTE_W | PTE_U)// Address in page table or page directory entry //ÂèñÈ°µË°®ÂÖ•Âè£Âú∞ÂùÄ#define PTE_ADDR(pte) ((physaddr_t) (pte) &amp; ~0xFFF)0xFFF//ÂêéÈù¢ÁöÑ‰∏úË•ø Áî®ÁöÑÊØîËæÉÂ∞ëÔºåÊÑüÂÖ¥Ë∂£ÁöÑËá™Â∑±ÂéªÈÄÅ‰∫∫Â§¥Âêß// Control Register flags#define CR0_PE 0x00000001 // Protection Enable#define CR0_MP 0x00000002 // Monitor coProcessor#define CR0_EM 0x00000004 // Emulation#define CR0_TS 0x00000008 // Task Switched#define CR0_ET 0x00000010 // Extension Type#define CR0_NE 0x00000020 // Numeric Errror#define CR0_WP 0x00010000 // Write Protect#define CR0_AM 0x00040000 // Alignment Mask#define CR0_NW 0x20000000 // Not Writethrough#define CR0_CD 0x40000000 // Cache Disable#define CR0_PG 0x80000000 // Paging#define CR4_PCE 0x00000100 // Performance counter enable#define CR4_MCE 0x00000040 // Machine Check Enable#define CR4_PSE 0x00000010 // Page Size Extensions#define CR4_DE 0x00000008 // Debugging Extensions#define CR4_TSD 0x00000004 // Time Stamp Disable#define CR4_PVI 0x00000002 // Protected-Mode Virtual Interrupts#define CR4_VME 0x00000001 // V86 Mode Extensions// Eflags register#define FL_CF 0x00000001 // Carry Flag#define FL_PF 0x00000004 // Parity Flag#define FL_AF 0x00000010 // Auxiliary carry Flag#define FL_ZF 0x00000040 // Zero Flag#define FL_SF 0x00000080 // Sign Flag#define FL_TF 0x00000100 // Trap Flag#define FL_IF 0x00000200 // Interrupt Flag#define FL_DF 0x00000400 // Direction Flag#define FL_OF 0x00000800 // Overflow Flag#define FL_IOPL_MASK 0x00003000 // I/O Privilege Level bitmask#define FL_IOPL_0 0x00000000 // IOPL == 0#define FL_IOPL_1 0x00001000 // IOPL == 1#define FL_IOPL_2 0x00002000 // IOPL == 2#define FL_IOPL_3 0x00003000 // IOPL == 3#define FL_NT 0x00004000 // Nested Task#define FL_RF 0x00010000 // Resume Flag#define FL_VM 0x00020000 // Virtual 8086 mode#define FL_AC 0x00040000 // Alignment Check#define FL_VIF 0x00080000 // Virtual Interrupt Flag#define FL_VIP 0x00100000 // Virtual Interrupt Pending#define FL_ID 0x00200000 // ID flag// Page fault error codes#define FEC_PR 0x1 // Page fault caused by protection violation#define FEC_WR 0x2 // Page fault caused by a write#define FEC_U 0x4 // Page fault occured while in user mode/* * * Part 2. Segmentation data structures and constants. * */#ifdef __ASSEMBLER__/* * Macros to build GDT entries in assembly. */#define SEG_NULL \ .word 0, 0; \ .byte 0, 0, 0, 0#define SEG(type,base,lim) \ .word (((lim) &gt;&gt; 12) &amp; 0xffff), ((base) &amp; 0xffff); \ .byte (((base) &gt;&gt; 16) &amp; 0xff), (0x90 | (type)), \ (0xC0 | (((lim) &gt;&gt; 28) &amp; 0xf)), (((base) &gt;&gt; 24) &amp; 0xff)#else // not __ASSEMBLER__#include &lt;inc/types.h&gt;// Segment Descriptorsstruct Segdesc &#123; unsigned sd_lim_15_0 : 16; // Low bits of segment limit unsigned sd_base_15_0 : 16; // Low bits of segment base address unsigned sd_base_23_16 : 8; // Middle bits of segment base address unsigned sd_type : 4; // Segment type (see STS_ constants) unsigned sd_s : 1; // 0 = system, 1 = application unsigned sd_dpl : 2; // Descriptor Privilege Level unsigned sd_p : 1; // Present unsigned sd_lim_19_16 : 4; // High bits of segment limit unsigned sd_avl : 1; // Unused (available for software use) unsigned sd_rsv1 : 1; // Reserved unsigned sd_db : 1; // 0 = 16-bit segment, 1 = 32-bit segment unsigned sd_g : 1; // Granularity: limit scaled by 4K when set unsigned sd_base_31_24 : 8; // High bits of segment base address&#125;;// Null segment#define SEG_NULL &#123; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 &#125;// Segment that is loadable but faults when used#define SEG_FAULT &#123; 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0 &#125;// Normal segment#define SEG(type, base, lim, dpl) \&#123; ((lim) &gt;&gt; 12) &amp; 0xffff, (base) &amp; 0xffff, ((base) &gt;&gt; 16) &amp; 0xff, \ type, 1, dpl, 1, (unsigned) (lim) &gt;&gt; 28, 0, 0, 1, 1, \ (unsigned) (base) &gt;&gt; 24 &#125;#define SEG16(type, base, lim, dpl) (struct Segdesc) \&#123; (lim) &amp; 0xffff, (base) &amp; 0xffff, ((base) &gt;&gt; 16) &amp; 0xff, \ type, 1, dpl, 1, (unsigned) (lim) &gt;&gt; 16, 0, 0, 1, 0, \ (unsigned) (base) &gt;&gt; 24 &#125;#endif /* !__ASSEMBLER__ */// Application segment type bits#define STA_X 0x8 // Executable segment#define STA_E 0x4 // Expand down (non-executable segments)#define STA_C 0x4 // Conforming code segment (executable only)#define STA_W 0x2 // Writeable (non-executable segments)#define STA_R 0x2 // Readable (executable segments)#define STA_A 0x1 // Accessed// System segment type bits#define STS_T16A 0x1 // Available 16-bit TSS#define STS_LDT 0x2 // Local Descriptor Table#define STS_T16B 0x3 // Busy 16-bit TSS#define STS_CG16 0x4 // 16-bit Call Gate#define STS_TG 0x5 // Task Gate / Coum Transmitions#define STS_IG16 0x6 // 16-bit Interrupt Gate#define STS_TG16 0x7 // 16-bit Trap Gate#define STS_T32A 0x9 // Available 32-bit TSS#define STS_T32B 0xB // Busy 32-bit TSS#define STS_CG32 0xC // 32-bit Call Gate#define STS_IG32 0xE // 32-bit Interrupt Gate#define STS_TG32 0xF // 32-bit Trap Gate/* * * Part 3. Traps. * */#ifndef __ASSEMBLER__// Task state segment format (as described by the Pentium architecture book)struct Taskstate &#123; uint32_t ts_link; // Old ts selector uintptr_t ts_esp0; // Stack pointers and segment selectors uint16_t ts_ss0; // after an increase in privilege level uint16_t ts_padding1; uintptr_t ts_esp1; uint16_t ts_ss1; uint16_t ts_padding2; uintptr_t ts_esp2; uint16_t ts_ss2; uint16_t ts_padding3; physaddr_t ts_cr3; // Page directory base uintptr_t ts_eip; // Saved state from last task switch uint32_t ts_eflags; uint32_t ts_eax; // More saved state (registers) uint32_t ts_ecx; uint32_t ts_edx; uint32_t ts_ebx; uintptr_t ts_esp; uintptr_t ts_ebp; uint32_t ts_esi; uint32_t ts_edi; uint16_t ts_es; // Even more saved state (segment selectors) uint16_t ts_padding4; uint16_t ts_cs; uint16_t ts_padding5; uint16_t ts_ss; uint16_t ts_padding6; uint16_t ts_ds; uint16_t ts_padding7; uint16_t ts_fs; uint16_t ts_padding8; uint16_t ts_gs; uint16_t ts_padding9; uint16_t ts_ldt; uint16_t ts_padding10; uint16_t ts_t; // Trap on task switch uint16_t ts_iomb; // I/O map base address&#125;;// Gate descriptors for interrupts and trapsstruct Gatedesc &#123; unsigned gd_off_15_0 : 16; // low 16 bits of offset in segment unsigned gd_sel : 16; // segment selector unsigned gd_args : 5; // # args, 0 for interrupt/trap gates unsigned gd_rsv1 : 3; // reserved(should be zero I guess) unsigned gd_type : 4; // type(STS_&#123;TG,IG32,TG32&#125;) unsigned gd_s : 1; // must be 0 (system) unsigned gd_dpl : 2; // descriptor(meaning new) privilege level unsigned gd_p : 1; // Present unsigned gd_off_31_16 : 16; // high bits of offset in segment&#125;;// Set up a normal interrupt/trap gate descriptor.// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate. // see section 9.6.1.3 of the i386 reference: "The difference between // an interrupt gate and a trap gate is in the effect on IF (the // interrupt-enable flag). An interrupt that vectors through an // interrupt gate resets IF, thereby preventing other interrupts from // interfering with the current interrupt handler. A subsequent IRET // instruction restores IF to the value in the EFLAGS image on the // stack. An interrupt through a trap gate does not change IF."// - sel: Code segment selector for interrupt/trap handler// - off: Offset in code segment for interrupt/trap handler// - dpl: Descriptor Privilege Level -// the privilege level required for software to invoke// this interrupt/trap gate explicitly using an int instruction.#define SETGATE(gate, istrap, sel, off, dpl) \&#123; \ (gate).gd_off_15_0 = (uint32_t) (off) &amp; 0xffff; \ (gate).gd_sel = (sel); \ (gate).gd_args = 0; \ (gate).gd_rsv1 = 0; \ (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32; \ (gate).gd_s = 0; \ (gate).gd_dpl = (dpl); \ (gate).gd_p = 1; \ (gate).gd_off_31_16 = (uint32_t) (off) &gt;&gt; 16; \&#125;// Set up a call gate descriptor.#define SETCALLGATE(gate, sel, off, dpl) \&#123; \ (gate).gd_off_15_0 = (uint32_t) (off) &amp; 0xffff; \ (gate).gd_sel = (sel); \ (gate).gd_args = 0; \ (gate).gd_rsv1 = 0; \ (gate).gd_type = STS_CG32; \ (gate).gd_s = 0; \ (gate).gd_dpl = (dpl); \ (gate).gd_p = 1; \ (gate).gd_off_31_16 = (uint32_t) (off) &gt;&gt; 16; \&#125;// Pseudo-descriptors used for LGDT, LLDT and LIDT instructions.struct Pseudodesc &#123; uint16_t pd_lim; // Limit uint32_t pd_base; // Base address&#125; __attribute__ ((packed));#endif /* !__ASSEMBLER__ */#endif /* !JOS_INC_MMU_H */ memlayout.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196#ifndef JOS_INC_MEMLAYOUT_H#define JOS_INC_MEMLAYOUT_H#ifndef __ASSEMBLER__#include &lt;inc/types.h&gt;#include &lt;inc/mmu.h&gt;#endif /* not __ASSEMBLER__ *//* * This file contains definitions for memory management in our OS, * which are relevant to both the kernel and user-mode software. */// Global descriptor numbers ‰∏Ä‰∫õÂÖ®Â±ÄÊèèËø∞Áî®ÁöÑ‰∏úË•øÔºå‰∏ãÈù¢Â•ΩÂÉèÊ≤°ÊÄé‰πàÁî®Âà∞Ëøá#define GD_KT 0x08 // kernel text#define GD_KD 0x10 // kernel data#define GD_UT 0x18 // user text#define GD_UD 0x20 // user data#define GD_TSS0 0x28 // Task segment selector for CPU 0/*1. Â∞ÜËôöÊãüÂÜÖÂ≠òÂÖ±ËÆ°4GÁöÑÁ©∫Èó¥ÁöÑÊúÄÈ´ò‰ΩçÁΩÆÁöÑ256MÈ¢ÑÁïôÔºåÁî®Êù•‰Ωú‰∏∫Áâ©ÁêÜÂÜÖÂ≠òÁöÑÊò†Â∞ÑÔºåÂú®JOSÁöÑÂÜÖÂ≠ò‰ΩøÁî®‰∏≠‰∏ç‰ºöÁõ¥Êé•‰ΩøÁî®ËøôÊÆµÁ©∫Èó¥„ÄÇÂú®JOS‰∏≠‰ΩøÁî®ÁöÑÊüê‰∏™È°µÈù¢Ôºå‰ºöÈÄöËøámmuÊò†Â∞ÑÂà∞ËøôÊÆµÁ©∫Èó¥ÔºåÂÜçÈÄöËøáÊò†Â∞ÑÂíåÂÆûÈôÖÁöÑÁâ©ÁêÜÂÜÖÂ≠òÁõ∏ÂØπÂ∫î„ÄÇËøô‰πüÊòØJOSÊúÄÂ§öÂè™ËÉΩÁÆ°ÁêÜ256MÁâ©ÁêÜÂÜÖÂ≠òÁöÑÂéüÂõ†„ÄÇ ÔºàËøôÊàëÁé∞Âú®ËøòÊ≤°ÁêÜËß£‰ªÄ‰πàÊÑèÊÄùÔºåÊò†Â∞ÑÈöæÈÅì‰∏çÊòØÈÄöËøáÈ°µË°®ÂêóÔºüÔºâ2. ULIMÊòØÂå∫ÂàÜÂÜÖÊ†∏ÂíåÁî®Êà∑Á©∫Èó¥ÁöÑ‰ΩçÁΩÆ„ÄÇËØ•‰ΩçÁΩÆ‰ª•‰∏ä‰∏∫ÂÜÖÊ†∏Á©∫Èó¥ÔºåÁî®Êà∑Á®ãÂ∫è‰∏çÂèØËßÅÔºõËÄåÁ¥ßÈöèÂÖ∂‰∏ãÁöÑÁ©∫Èó¥‰øùÂ≠ò‰∫ÜÁî®Êà∑Á©∫Èó¥ÁöÑËôöÊãüÈ°µË°®(UVPT)‰∏éÁéØÂ¢ÉÂèÇÊï∞ÔºåÁÑ∂ÂêéÊòØÂºÇÂ∏∏Â§ÑÁêÜÊ†àÔºåÂÜçÂÖ∂‰∏ã‰∏∫Áî®Êà∑Ê†àÔºåÂêë‰∏ãÂ¢ûÈïø„ÄÇ3. Áî®Êà∑ÁöÑÁ®ãÂ∫èÊï∞ÊçÆ‰∏éÂ†ÜÁöÑ‰ΩçÁΩÆ‰ªéUTEXT=0x00800000=8MÂ§ÑÂºÄÂßã„ÄÇÂÖ∂‰∏ãÁî®‰∫éÁî®Êà∑Á®ãÂ∫èÁöÑ‰∏¥Êó∂È°µÈù¢Êò†Â∞ÑÊó∂‰ΩøÁî®„ÄÇÂêåÊó∂ÈÅøÂºÄ‰∫ÜÊúÄ‰∏ãÈù¢ÁöÑ1MÁ©∫Èó¥ÔºåÂõ†‰∏∫ËØ•Á©∫Èó¥ÂÜÖ640K-1MÂ§Ñ‰∏∫Á≥ªÁªüÈ¢ÑÁïôÁ©∫Èó¥ÔºåÊó†Ê≥ï‰ΩøÁî®ÔºåÂõ†Ê≠§0-640KÁöÑÂÜÖÂ≠ò‰∏éÂÖ∂‰∏äÊó†Ê≥ïËøûÁª≠Ôºå‰ΩøÁî®Ëµ∑Êù•‰ºöÊØîËæÉÂ§çÊùÇ„ÄÇ4. Áî®‰∫éÁî®Êà∑‰∏¥Êó∂È°µÈù¢Êò†Â∞ÑÁöÑÁ©∫Èó¥‰∏∫4M-8MÂ§Ñ„ÄÇËÄå8M‰ΩçÁΩÆÂêë‰∏ãÁöÑ4K‰∏∫PFTEMPÁöÑÁ©∫Èó¥ÔºåÁî®‰∫éÁî®Êà∑È°µÈù¢ÂàÜÈÖçÂá∫Èîô(page-fault)Â§ÑÁêÜÊó∂‰Ωú‰∏∫Êò†Â∞ÑÁ©∫Èó¥„ÄÇ5. ÂÜÖÊ†∏Ê†àÂ§ßÂ∞è‰∏∫KSTKSIZE=(8*PGSIZE)=32KB.*//*Ëøô‰∏™ÊòØËôöÊãüÂÜÖÂ≠òÔºåÊò†Â∞ÑÁöÑÊó∂ÂÄô‰ºöÁî®‰∏ä * Virtual memory map: Permissions * kernel/user * * 4 Gig --------&gt; +------------------------------+ * | | RW/-- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ * : . : * : . : * : . : * |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/-- * | | RW/-- * | Remapped Physical Memory | RW/-- * | | RW/-- * KERNBASE, ----&gt; +------------------------------+ 0xf0000000 --+ * KSTACKTOP | CPU0's Kernel Stack | RW/-- KSTKSIZE | * | - - - - - - - - - - - - - - -| | * | Invalid Memory (*) | --/-- KSTKGAP | * +------------------------------+ | * | CPU1's Kernel Stack | RW/-- KSTKSIZE | * | - - - - - - - - - - - - - - -| PTSIZE * | Invalid Memory (*) | --/-- KSTKGAP | * +------------------------------+ | * : . : | * : . : | * MMIOLIM ------&gt; +------------------------------+ 0xefc00000 --+ * | Memory-mapped I/O | RW/-- PTSIZE * ULIM, MMIOBASE --&gt; +------------------------------+ 0xef800000 * | Cur. Page Table (User R-) | R-/R- PTSIZE * UVPT ----&gt; +------------------------------+ 0xef400000 * | RO PAGES | R-/R- PTSIZE * UPAGES ----&gt; +------------------------------+ 0xef000000 * | RO ENVS | R-/R- PTSIZE * UTOP,UENVS ------&gt; +------------------------------+ 0xeec00000 * UXSTACKTOP -/ | User Exception Stack | RW/RW PGSIZE * +------------------------------+ 0xeebff000 * | Empty Memory (*) | --/-- PGSIZE * USTACKTOP ---&gt; +------------------------------+ 0xeebfe000 * | Normal User Stack | RW/RW PGSIZE * +------------------------------+ 0xeebfd000 * | | * | | * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ * . . * . . * . . * |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| * | Program Data &amp; Heap | * UTEXT --------&gt; +------------------------------+ 0x00800000 * PFTEMP -------&gt; | Empty Memory (*) | PTSIZE * | | * UTEMP --------&gt; +------------------------------+ 0x00400000 --+ * | Empty Memory (*) | | * | - - - - - - - - - - - - - - -| | * | User STAB Data (optional) | PTSIZE * USTABDATA ----&gt; +------------------------------+ 0x00200000 | * | Empty Memory (*) | | * 0 ------------&gt; +------------------------------+ --+ * * (*) Note: The kernel ensures that "Invalid Memory" is *never* mapped. * "Empty Memory" is normally unmapped, but user programs may map pages * there if desired. JOS user programs map pages temporarily at UTEMP. */// All physical memory mapped at this address ÊâÄÊúâÁöÑÁâ©ÁêÜÂÜÖÂ≠òÊò†Â∞ÑÂú®Ê≠§Âú∞ÂùÄ#define KERNBASE 0xF0000000// At IOPHYSMEM (640K) there is a 384K hole for I/O. From the kernel,// IOPHYSMEM can be addressed at KERNBASE + IOPHYSMEM. The hole ends// at physical address EXTPHYSMEM. Ëøô‰∏™ Â∞±ÊòØ‰∏äÊ¨°ÂÆûÈ™åËØ¥ÁöÑ Á©∫Ê¥û#define IOPHYSMEM 0x0A0000#define EXTPHYSMEM 0x100000// Kernel stack. Ëøô‰∏™ÊòØÊ†àÔºåÂêéÈù¢Áî®ÁöÑ‰∏äÁöÑ#define KSTACKTOP KERNBASE#define KSTKSIZE (8*PGSIZE) // size of a kernel stack#define KSTKGAP (8*PGSIZE) // size of a kernel stack guard// Memory-mapped IO. #define MMIOLIM (KSTACKTOP - PTSIZE)#define MMIOBASE (MMIOLIM - PTSIZE)#define ULIM (MMIOBASE)/* * User read-only mappings! Anything below here til UTOP are readonly to user. * They are global pages mapped in at env allocation time. */// User read-only virtual page table (see 'uvpt' below)#define UVPT (ULIM - PTSIZE)// Read-only copies of the Page structures#define UPAGES (UVPT - PTSIZE)// Read-only copies of the global env structures#define UENVS (UPAGES - PTSIZE)/* * Top of user VM. User can manipulate VA from UTOP-1 and down! */// Ëøô‰∏™Âú∞ÊñπÂ∞±ÊòØÁî®Êà∑ÊÄÅ‰∫ÜÔºå‰πü‰∏çÁü•ÈÅìÂÖ∑‰ΩìÊúâ‰ªÄ‰πàÁî®ÔºåÊàëÁé∞Âú®Â∞±Áü•ÈÅìÂ§ßËá¥ÂàÜÂ∏ÉÔºå‰∏çÁü•ÈÅìÂêéÈù¢ÂÆûÈ™å‰ºö‰∏ç‰ºöËÆ≤// Top of user-accessible VM#define UTOP UENVS// Top of one-page user exception stack#define UXSTACKTOP UTOP// Next page left invalid to guard against exception stack overflow; then:// Top of normal user stack#define USTACKTOP (UTOP - 2*PGSIZE)// Where user programs generally begin#define UTEXT (2*PTSIZE)// Used for temporary page mappings. Typed 'void*' for convenience#define UTEMP ((void*) PTSIZE)// Used for temporary page mappings for the user page-fault handler// (should not conflict with other temporary page mappings)#define PFTEMP (UTEMP + PTSIZE - PGSIZE)// The location of the user-level STABS data structure#define USTABDATA (PTSIZE / 2)#ifndef __ASSEMBLER__//‰∏ãÈù¢Ëøô‰∏§‰∏™ ‰∏Ä‰∏™ ÊòØÈ°µÁõÆÂΩï ‰∏Ä‰∏™È°µË°®typedef uint32_t pte_t;typedef uint32_t pde_t;#if JOS_USER/* * The page directory entry corresponding to the virtual address range * [UVPT, UVPT + PTSIZE) points to the page directory itself. Thus, the page * directory is treated as a page table as well as a page directory. * * One result of treating the page directory as a page table is that all PTEs * can be accessed through a "virtual page table" at virtual address UVPT (to * which uvpt is set in lib/entry.S). The PTE for page number N is stored in * uvpt[N]. (It's worth drawing a diagram of this!) * * A second consequence is that the contents of the current page directory * will always be available at virtual address (UVPT + (UVPT &gt;&gt; PGSHIFT)), to * which uvpd is set in lib/entry.S. */extern volatile pte_t uvpt[]; // VA of "virtual page table"extern volatile pde_t uvpd[]; // VA of current page directory#endif/* * Page descriptor structures, mapped at UPAGES. * Read/write to the kernel, read-only to user programs. * * Each struct PageInfo stores metadata for one physical page. * Is it NOT the physical page itself, but there is a one-to-one * correspondence between physical pages and struct PageInfo's. * You can map a struct PageInfo * to the corresponding physical address * with page2pa() in kern/pmap.h. */ //È°µ ÁöÑÊï∞ÊçÆÁªìÊûÑstruct PageInfo &#123; // Next page on the free list.‰∏ã‰∏ÄÈ°µ struct PageInfo *pp_link; // pp_ref is the count of pointers (usually in page table entries) // to this page, for pages allocated using page_alloc. // Pages allocated at boot time using pmap.c's // boot_alloc do not have valid reference count fields. // È°µË°®ËÆ°Êï∞Âô® uint16_t pp_ref;&#125;;#endif /* !__ASSEMBLER__ */#endif /* !JOS_INC_MEMLAYOUT_H */ kern/pmap.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/* See COPYRIGHT for copyright information. */#ifndef JOS_KERN_PMAP_H#define JOS_KERN_PMAP_H#ifndef JOS_KERNEL# error "This is a JOS kernel header; user programs should not #include it"#endif#include &lt;inc/memlayout.h&gt;#include &lt;inc/assert.h&gt;//Ëøô‰∏™Âá†‰∏™Êâ©Â±ïÂèòÈáèËåÉÂõ¥Âà∞‰∫ÜÂÖ∑‰ΩìÂÆö‰πâÂÜçËØ¥extern char bootstacktop[], bootstack[];extern struct PageInfo *pages;extern size_t npages;extern pde_t *kern_pgdir;/* This macro takes a kernel virtual address -- an address that points above * KERNBASE, where the machine's maximum 256MB of physical memory is mapped -- * and returns the corresponding physical address. It panics if you pass it a * non-kernel virtual address. Â∞ÜËôöÊãüÂú∞ÂùÄËΩ¨Êç¢ÊàêÁâ©ÁêÜÂú∞ÂùÄ */#define PADDR(kva) _paddr(__FILE__, __LINE__, kva)static inline physaddr_t_paddr(const char *file, int line, void *kva)&#123;//ÂÖ∑‰ΩìÂàÜÊûê‰∏çËøáÊù•ÂëäËæû if ((uint32_t)kva &lt; KERNBASE) _panic(file, line, "PADDR called with invalid kva %08lx", kva); return (physaddr_t)kva - KERNBASE;&#125;/* This macro takes a physical address and returns the corresponding kernel * virtual address. It panics if you pass an invalid physical address. */ //Ëøô‰∏™ÊòØÁâ©ÁêÜÂú∞ÂùÄËΩ¨Êç¢ÊàêËôöÊãüÂú∞ÂùÄ#define KADDR(pa) _kaddr(__FILE__, __LINE__, pa)static inline void*_kaddr(const char *file, int line, physaddr_t pa)&#123; if (PGNUM(pa) &gt;= npages) _panic(file, line, "KADDR called with invalid pa %08lx", pa); return (void *)(pa + KERNBASE);&#125;enum &#123; // For page_alloc, zero the returned physical page. ALLOC_ZERO = 1&lt;&lt;0,&#125;;// ÂêéÈù¢Â∞±ÊòØÂá†‰∏™ÂáΩÊï∞ÁöÑÂ£∞ÊòéÔºåÂêéÈù¢‰ºöÁúãÂà∞ÁöÑvoid mem_init(void);void page_init(void);struct PageInfo *page_alloc(int alloc_flags);void page_free(struct PageInfo *pp);int page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm);void page_remove(pde_t *pgdir, void *va);struct PageInfo *page_lookup(pde_t *pgdir, void *va, pte_t **pte_store);void page_decref(struct PageInfo *pp);void tlb_invalidate(pde_t *pgdir, void *va);static inline physaddr_tpage2pa(struct PageInfo *pp)&#123; //Â∞Ü PagaInfo ËΩ¨Êç¢ÊàêÁúüÊ≠£ÁöÑÁâ©ÁêÜÂú∞ÂùÄ return (pp - pages) &lt;&lt; PGSHIFT;&#125;static inline struct PageInfo*pa2page(physaddr_t pa)&#123; // ÊàñÂæóÁâ©ÁêÜÂú∞ÂùÄÁöÑÊï∞ÊçÆÁªìÊûÑ if (PGNUM(pa) &gt;= npages) panic("pa2page called with invalid pa"); return &amp;pages[PGNUM(pa)];&#125;static inline void*page2kva(struct PageInfo *pp)&#123; //Â∞ÜÈ°µÁöÑÊï∞ÊçÆÁªìÊûÑËΩ¨Êç¢ÊàêËôöÊãüÂú∞ÂùÄ return KADDR(page2pa(pp));&#125;pte_t *pgdir_walk(pde_t *pgdir, const void *va, int create);#endif /* !JOS_KERN_PMAP_H */ Êé•‰∏ãÊù•Êàë‰ª¨Â∞±ÂºÄÂßãÁúãÂÜÖÂ≠òÊÄé‰πàÂàùÂßãÂåñÁöÑ‰∫Ü„ÄÇËøô‰∏™Êó∂ÂÄôÂ∞±Ë¶ÅÊâìÂºÄkern/pmap.cÔºåÁúãÈáåÈù¢ÁöÑmem_int();Êàë‰ª¨‰∏ÄÊÆµ‰∏ÄÊÆµÁöÑÊù•„ÄÇÂÖàÁúãÁúãÂÆö‰πâ‰∫ÜÂï•12345678 // These variables are set by i386_detect_memory() size_t npages; // Amount of physical memory (in pages) Áâ©ÁêÜÂÜÖÂ≠òÁöÑÈ°µÊï∞ static size_t npages_basemem; // Amount of base memory (in pages) basememÁöÑÈ°µÊï∞// These variables are set in mem_init() ËøôÂá†‰∏™ÂèòÈáèÂ∞±ÊòØÂéüÊú¨pmap.hÊâ©Â±ïÁöÑÈÇ£Âá†‰∏™pde_t *kern_pgdir; // Kernel's initial page directory ÂÜÖÊ†∏ÂàùÂßãÂåñÈ°µÁõÆÂΩïstruct PageInfo *pages; // Physical page state array Áâ©ÁêÜÂÜÖÂ≠òÈ°µË°®Êï∞ÁªÑstatic struct PageInfo *page_free_list; // Free list of physical pages Á©∫Èó≤È°µË°®ÊèèËø∞ÁªìÊûÑ‰ΩìÊåáÈíà ÁÑ∂ÂêéÊàë‰ª¨Áõ¥Êé•Ë∑üÁùÄ mem_init()ÁöÑËøáÁ®ãËµ∞„ÄÇ123456 uint32_t cr0; //ÂÆö‰πâ‰∫Ü‰∏§‰∏™ÂèòÈáèÔºåÂπ≤Âï•ÁöÑËøò‰∏çÊ∏ÖÊ•öÊé•ÁùÄËµ∞ size_t n; // Find out how much memory the machine has (npages &amp; npages_basemem). i386_detect_memory(); //Ëøô‰∏™ÊòØÊü•ÁúãÊúâÂ§öÂ∞ë‰∏™È°µ ËøòÊúâ‰∏™È°µÂü∫Á°ÄÂÜÖÂ≠ò Ëøô‰∏™ÂáΩÊï∞Âπ∂Ê≤°ÊúâË¶ÅÊàë‰ª¨ÂÆûÁé∞ÁöÑÊÑèÊÄùÂ∞±‰∏çÁÆ°‰ªñ‰∫ÜÔºåÁúãÁúãÔºå‰πüÂ∞±ÊòØÂ∏ÆÊàë‰ª¨Êü•ÁúãÊúâÂ§öÂ∞ëÂÜÖÂ≠òÔºå‰∏çËøá‰∏çÁü•ÈÅì‰∏∫Âï•Ëøô‰∏™Êü•Âá∫Êù•Âè™Êúâ 128 M Â∞ë‰∫Ü‰∏ÄÂçä„ÄÇ // Remove this line when you're ready to test this function.// panic("mem_init: This function is not finished\n"); Ëøô‰∏™Ê≥®ÈáäÂ∞±Ë°å‰∫Ü... ÂêéÈù¢ËøêË°å‰∫ÜËøô‰∏™ boot_alloc ‰ΩúÁî®ÂæàÊòéÊòæÔºåÂ∞±ÊòØÂàõÂª∫‰∏Ä‰∏™È°µÁõÆÂΩï„ÄÇ1234//////////////////////////////////////////////////////////////////////// create initial page directory.kern_pgdir = (pde_t *) boot_alloc(PGSIZE);memset(kern_pgdir, 0, PGSIZE); boot_alloc()12345678910111213141516171819202122232425262728293031323334353637383940// This simple physical memory allocator is used only while JOS is setting// up its virtual memory system. page_alloc() is the real allocator.// Ëøô‰∏™Âè™ÊòØÁÆÄÂçïÁöÑÁâ©ÁêÜÂÜÖÂ≠òÂàÜÈÖçÔºåÂú®Âª∫Á´ãËôöÊãüÂ≠òÂÇ®Á≥ªÁªüÁöÑÊó∂ÂÄô‰ΩøÁî®Ôºåpage_alloc ÊâçÊòØÁúüÊ≠£ÁöÑÂÜÖÂ≠òÂàÜÈÖç// If n&gt;0, allocates enough pages of contiguous physical memory to hold 'n'// bytes. Doesn't initialize the memory. Returns a kernel virtual address.//ÂΩìn&gt;0 ÂàÜÈÖç‰∏Ä‰∏™nÂ≠óËäÇÁöÑÂÜÖÂ≠òÂÜÖÂ≠òÔºåËøîÂõû‰∏Ä‰∏™ËôöÊãüÂú∞ÂùÄ// If n==0, returns the address of the next free page without allocating// anything. Â¶ÇÊûún==0 ËøîÂõû ‰∏ã‰∏Ä‰∏™Á©∫Èó≤ÁöÑÈ°µÂï•ÈÉΩ‰∏çÂÅö//// If we're out of memory, boot_alloc should panic. Â¶ÇÊûúË∂ÖÂá∫ÂÜÖÂ≠ò Â∞±panic// This function may ONLY be used during initialization, ÂáΩÊï∞Âè™Áî®‰∫éÂàùÂßãÂåñ// before the page_free_list list has been set up.static void *boot_alloc(uint32_t n)&#123; static char *nextfree; // virtual address of next byte of free memory char *result; // Initialize nextfree if this is the first time. // 'end' is a magic symbol automatically generated by the linker, // which points to the end of the kernel's bss segment: // the first virtual address that the linker did *not* assign // to any kernel code or global variables. Âú®Ëøô‰πãÂâçÔºåÈÄöËøáELF Êñá‰ª∂Êàë‰ª¨Â∑≤ÁªèÂä†ËΩΩ‰∫Ü‰∏ÄÈÉ®ÂàÜÂÜÖÂ≠ò //ÊâÄ‰ª•Êàë‰ª¨Â¶ÇÊûúÊòØÁ¨¨‰∏ÄÊ¨°ÂàÜÈÖçÂÜÖÂ≠òÔºåÂ∞±Ë¶ÅÂÖàÊâæÂà∞‰∏ä‰∏ÄÊ¨°ÁöÑÔºåÊ≤°ÊúâË¶ÅÊàë‰ª¨ÂÆûÁé∞‰ªñÂ∑≤ÁªèÂ∏ÆÊàë‰ª¨ÂÜôÂ•Ω‰∫Ü if (!nextfree) &#123; extern char end[]; nextfree = ROUNDUP((char *) end, PGSIZE); &#125; // Allocate a chunk large enough to hold 'n' bytes, then update // nextfree. Make sure nextfree is kept aligned // to a multiple of PGSIZE. ÂàÜÈÖçn Â≠óËäÇÔºåÂàÜÈÖçÁöÑÁ©∫Èó¥Ë¶ÅÊòØPGSIZEÁöÑÂÄçÊï∞„ÄÇ // // LAB 2: Your code here. result = nextfree; nextfree=ROUNDUP(nextfree+n,PGSIZE); if((uint32_t)nextfree - KERNBASE &gt; (npages*PGSIZE))//Â¶ÇÊûúÂàÜÈÖçË∂ÖÂá∫ÂÜÖÂ≠òpanic panic("Out of memory!\n"); return result; //Ê≤°ÊúâÂ∞±ËøîÂõûËøô‰∏™&#125; Áúã‰ª£Á†ÅÂÆûÁé∞ËøòÊòØÊå∫ÂÆπÊòìÁêÜËß£ÁöÑ„ÄÇkern_pgdir = (pde_t *) boot_alloc(PGSIZE)ËøôÂè•Â∞±Áõ∏ÂΩì‰∫éÁõ¥Êé•Âú®ÂêéÈù¢ÂºÄ‰∫Ü‰∏Ä‰∏™PGSIZEÂ§ßÂ∞èÁöÑ‰Ωú‰∏∫ÂàùÂßãÂåñÈ°µÁõÆÂΩïÔºåÁÑ∂ÂêéÊää‰ªñÂàùÂßãÂåñ‰∏∫0‰∫Ü„ÄÇPGSIZE =4096ÁöÑÂÆö‰πâÊòØÂú®‰∏ä‰∏ÄÊ¨°ÁöÑÂÆûÈ™å„ÄÇ‰πüÂ∞±ÊòØ4096‰∏™Â≠óËäÇÔºåÊâÄ‰ª•kern_pgdirÂç†4096B ‰∏Ä‰∏™È°µË°®È°πÊòØ4B,ÊâÄ‰ª•ÊÄªÂÖ±ÊòØ1024‰∏™È°µË°®„ÄÇÔºàËøô‰∏™Êó∂ÂÄôÊàëÂú®ÊÉ≥‰ª¨ÊòØ‰∏çÊòØ ÊØè‰∏™È°µË°®‰πüÊòØ 1024 ‰∏™È°µ,‰∏Ä‰∏™È°µ 4KB ËøôÊ†∑ÂÜÖÂ≠òÂ∞±ÊòØ 102410244KB Â∞±ÊòØ4GÔºå‰∏çÁü•ÈÅìÊòØ‰∏çÊòØËøôÊ†∑ÔºåÁ∫ØÂ±ûÁåúÊµã„ÄÇÔºâÂêéÈù¢ÊúâËøô‰πà‰∏ÄÊÆµ12345678//////////////////////////////////////////////////////////////////////// Recursively insert PD in itself as a page table, to form// a virtual page table at virtual address UVPT.// (For now, you don't have understand the greater purpose of the// following line.)// Permissions: kernel R, user Rkern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;//ÂêéÈù¢Ëøô‰∏§‰∏™ÂèÇË¶ÅÁúãmmu.h Ëá™Â∑±Êú¨Ë∫´Â∞±ÊòØÈ°µË°®ÔºåÊâÄ‰ª•ÊääËá™Â∑±ÊèíÂÖ•ËøõÂéª„ÄÇÂ§ßÂÆ∂ÂèØ‰ª•ËØïËØïËæìÂá∫Ëøô‰∏™Âá†‰∏™ÂÄºÁúãÁúãÔºåÂÜçÂØπÁÖßÂâçÈù¢ÈÇ£‰∏™ÂÜÖÂ≠ò„ÄÇÁ¥ßÊé•ÁùÄ Â∞±ÊòØÂàÜÈÖçÈ°µ‰∫Ü12345678910//////////////////////////////////////////////////////////////////////// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.// The kernel uses this array to keep track of physical pages: for// each physical page, there is a corresponding struct PageInfo in this// array. 'npages' is the number of physical pages in memory. Use memset// to initialize all fields of each struct PageInfo to 0.// Your code goes here:// ÊääÊØè‰∏™È°µÁöÑÁªìÊûÑÂ≠ò‰∏ãÊù•ÔºåÊîæÂà∞pagesÈáåÈù¢Ôºånpages ÊòØ È°µË°®ÁöÑ‰∏™Êï∞ÔºåÁü•ÈÅìËøô‰∫õ ‰πüÂ∞±ÁÆÄÂçï‰∫Ü„ÄÇpages=(struct PageInfo *) boot_alloc(npages *sizeof(struct PageInfo));memset(pages,0,npages*sizeof(struct PageInfo));//ÂàùÂßãÂåñ Â§ßÂÆ∂Ëá™Ë°åËæìÂá∫ Ëøô‰∏™Á©∫Èó¥ÁöÑÂ§ßÂ∞è„ÄÇÂ¶ÇÊûúÊ≤°ÈîôÁöÑËØùÔºån=32768 ,PageInfo=8 256KB„ÄÇËøôÊòØÊúÄÂêé‰∏ÄÊ¨°‰ΩøÁî®boot_alloc,‰ªñÁöÑ‰ΩúÁî®‰πüÂ∞±Âπ≤‰∫Ü‰∏§‰ª∂‰∫ãÔºå‰∏Ä‰ª∂‰∫ãÊòØÂàÜÈÖçÈ°µÁõÆÂΩïÔºåÁ¨¨‰∫å‰∏™ÊòØ‰∏∫ÊØè‰∏™È°µÂàÜÈÖçÊï∞ÊçÆÁªìÊûÑ„ÄÇ Êé•ÁùÄÂ∞±ËøêË°å‰∫Üpage_init()Ëøô‰∏™Êó∂ÂÄô‰Ω†ÈúÄË¶ÅÁü•ÈÅìÁ©∫Èó≤ÂàóË°®ÔºåÂâçÈù¢Âä†ËΩΩÂÜÖÊ†∏ÁöÑÊó∂ÂÄôÊúâ‰∏ÄÈÉ®ÂàÜÂÜÖÂ≠òÊòØ‰∏çËÉΩÁî®ÁöÑ„ÄÇ1234567891011////////////////////////////////////////////////////////////////////// // Now that we've allocated the initial kernel data structures, we set // up the list of free physical pages. Once we've done so, all further // memory management will go through the page_* functions. In // particular, we can now map memory using boot_map_region // or page_insert Êàë‰ª¨Â∑≤ÁªèÂàùÂßãÂåñ‰∫ÜÊï∞ÊçÆÁªìÊûÑÁé∞Âú®ÔºåÈúÄË¶ÅÁü•ÈÅìÁ©∫Èó≤ÂàóË°®Ôºå‰ª•Âêé‰ΩøÁî®ÂÜÖÂ≠òÂ∞±ÈÄöËøápage_*ÂáΩÊï∞ÔºåÂ∞§ÂÖ∂ÊòØÁöÑÊòØÊàë‰ª¨ÂèØ‰ª•Áî® boot_map_region Âíåpage_insert ËøõË°åÊò†Â∞Ñ„ÄÇ page_init(); check_page_free_list(1); check_page_alloc(); check_page(); Êé•‰∏ãÊù•Êàë‰ª¨Â∞±Ë¶ÅÂÆûÁé∞ page_init() page_init()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// --------------------------------------------------------------// Tracking of physical pages.// The 'pages' array has one 'struct PageInfo' entry per physical page.// Pages are reference counted, and free pages are kept on a linked list.// --------------------------------------------------------------//ËøΩË∏™Áâ©ÁêÜÂÜÖÂ≠òÔºåpages ‰øùÂ≠òÁöÑÊØè‰∏Ä‰∏™È°µÁöÑ‰ø°ÊÅØÔºåÊúâ‰∫õÈ°µÂÆûÈôÖ‰∏äÊòØ‰∏çËÉΩÁî®ÁöÑ„ÄÇ//// Initialize page structure and memory free list.ÂàùÂßãÂåñÈ°µÈù¢ÁªìÊûÑÂíåÁ©∫Èó≤ÂÜÖÂ≠ò// After this is done, NEVER use boot_alloc again. ONLY use the page// allocator functions below to allocate and deallocate physical// memory via the page_free_list.//‰ªéËøô‰ª•Âêé Â∞±ÂÜç‰πü‰∏ç‰ºöÁî® boot_alloc Âè™ÊúâpageÂàÜÈÖçÂáΩÊï∞Âú® page_free_list ‰∏äÈù¢ËøõË°åÊìç‰Ωú‰∫ÜÔºå‰Ω†‰πüÂèØ‰ª•ÁêÜËß£‰∏∫ÔºåËøô‰∏™Êó∂ÂÄôÂ∞±ÂºÄÂßã‰∫ÜÁúüÊ≠£ÁöÑÂàÜÈ°µ‰∫ÜÔºåÂêéÈù¢ÊâÄÊúâÁöÑÊìç‰ΩúÈÉΩÊòØËôöÊãüÂú∞ÂùÄÊò†Â∞Ñ„ÄÇvoidpage_init(void)&#123; // The example code here marks all physical pages as free.ÂÆû‰æã‰ª£Á†ÅÂ∏Æ‰Ω†ÊääÊâÄÊúâÈ°µÈÉΩÂèòÊàê‰∫ÜÁ©∫Èó≤È°µ // However this is not truly the case. What memory is free? ÁÑ∂ÂêéÂÖ∂‰∏≠Êúâ‰∫õ‰∏çÊòØÁ©∫Èó≤ÁöÑ // 1) Mark physical page 0 as in use. 0Âè∑È°µ ‰ªñÂ≠ò‰∫ÜÂÆûÊ®°Âºè‰∏ãÈù¢ÁöÑIDT ÂíåBIOS ÁªìÊûÑËôΩÁÑ∂Êàë‰ª¨‰ªéÊú™Áî®ËøáÔºå‰ΩÜÊòØ‰Ω†ËøòÊòØË¶ÅÁïô‰∏ã„ÄÇ // This way we preserve the real-mode IDT and BIOS structures // in case we ever need them. (Currently we don't, but...) // 2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE) // is free. Â∞±ÊòØËøô‰∏ÄÊÆµ‰ΩéÂú∞ÂùÄÁöÑÂÖ∂‰ªñÈÉ®ÂàÜÊòØÂèØ‰ª•Áî®ÁöÑ„ÄÇ // 3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must // never be allocated. ‰∏çÊòØÊúâ‰∏ÄÂùóÊòØÁªôIO Áî®ÁöÑ ÂÜÖÂ≠òÁ©∫Ê¥ûÔºå‰∏çËÉΩÂàÜÈÖç // 4) Then extended memory [EXTPHYSMEM, ...). ÁÑ∂ÂêéÂ∞±ÊòØÊâ©Â±ïÂÜÖÂ≠òÔºåÊúâ‰∏ÄÈÉ®ÂàÜÂ∑≤ÁªèË¢´ÂÜÖÊ†∏Áî®‰∫ÜÔºåÊàë‰∏ÄÁõ¥Âú®ÊÄùËÄÉÔºåÈÇ£‰∏™È°µË°®‰∏ç‰πüÊòØË¢´Áî®‰∫Ü‰πàÔºå‰∏∫Âï•Ëøô‰∏™Âú∞ÊñπÊ≤°ÊúâËÄÉËôë„ÄÇ‰πüÊ≤°ÊúâÂ§ß‰Ω¨ÂèØ‰ª•ÈóÆ...‰πüÂ∞±Ëá™Â∑±ÁåúÊµã‰∏Ä‰∏ãÔºåÂ∫îËØ•‰πüË¢´ÁÆóËøõÈÇ£‰∏™ÂÜÖÊ†∏ÂÜÖÂ≠òÈ¢ù„ÄÇ // Some of it is in use, some is free. Where is the kernel // in physical memory? Which pages are already in use for // page tables and other data structures? // // Change the code to reflect this. // NB: DO NOT actually touch the physical memory corresponding to // free pages! size_t i; for (i = 0; i &lt; npages; i++) &#123; pages[i].pp_ref = 0; pages[i].pp_link = page_free_list; page_free_list = &amp;pages[i]; //‰∏çÁü•ÈÅì‰∏∫Âï•Ëøô‰∏™listÊòØÂÄíËøáÊù•ËøûÊé•ÁöÑ &#125; // Ê†πÊçÆ‰∏äÈù¢‰ªñÁªôÁöÑÊèêÁ§∫ÂÜôÔºå1) ÊòØ 0 Âè∑ È°µÊòØÂÆûÊ®°ÂºèÁöÑIDT Âíå BIOS ‰∏çÂ∫îËØ•Ê∑ªÂä†Âà∞Á©∫Èó≤È°µÔºåÊâÄ‰ª• pages[1].pp_link=pages[0].pp_link; pages[0].pp_ref = 1;//ÂèØ‰ª•‰∏çÂêåËÆæÁΩÆÔºåÂõ†‰∏∫Ëøô‰∏™ È°µÈÉΩÊ≤°ÊúâËøõfree list Ê∞∏ËøúÈÉΩ‰∏çÂèØËÉΩÁî®ÂéªÂàÜÈÖç pages[0].pp_link=NULL; //2)ÊòØËØ¥ÈÇ£‰∏ÄÂùóÂèØ‰ª•Áî®Ôºå‰πüÂ∞±ÊòØ‰∏ä‰∏ÄÊ¨°ÂÆûÈ™åËØ¥ÁöÑ‰ΩéÂú∞ÂùÄÔºåÊâÄ‰ª•‰∏çÁî®ÂÅö‰øÆÊîπ //3)ÊòØËØ¥ ‰∏äËäÇËØæËÆ≤ÁöÑÊúâ‰∏ÄÈÉ®ÂàÜ ÊòØ‰∏çËÉΩÁî®ÁöÑÔºåÂ≠òIOÁöÑÈÇ£‰∏ÄÂùóÔºå‰ªñÂëäËØâ‰Ω†Âú∞ÂùÄÊòØ‰ªé[IOPHYSMEM,EXTPHYSMEM) size_t range_io=PGNUM(IOPHYSMEM),range_ext=PGNUM(EXTPHYSMEM); pages[range_ext].pp_link=pages[range_io].pp_link; for (i = range_io; i &lt; range_ext; i++) pages[i].pp_link = NULL; //4)ÂêéÈù¢ÂàÜÈÖç‰∫Ü‰∏Ä‰∫õÂÜÖÂ≠òÈ°µÈù¢ÁªôÂÜÖÊ†∏ÔºåÊâÄ‰ª•ÈÇ£‰∏ÄÂùó‰πüÊòØ‰∏çËÉΩÁî®ÁöÑÔºåÁúã‰∫ÜÂçäÂ§©ÔºåÂíå‰∏äÈù¢ÊòØËøûÁª≠ÁöÑ...Á™ÅÁÑ∂ÂèëÁé∞ÔºåÂ§ß‰Ω¨ÂÜôÈ¢ù‰ª£Á†ÅÈáåÈù¢ ÊòØÁõ¥Êé• ÊâæÂà∞‰∫Ü boot_alloc(0),Áû¨Èó¥ÊòéÁôΩ..Ëøô‰∏™Áõ¥Êé•ÊääÈ°µË°®ÁöÑÁ©∫Èó¥‰πüÁÆó‰∏äÂéª‰∫ÜÔºåÊâÄ‰ª•ÂáÜÁ°ÆÊù•ËØ¥Â∫îËØ•ÊòØÂÜÖÊ†∏+È°µË°®+È°µÁõÆÂΩïÁöÑÂÜÖÂ≠òÔºàÂèØËÉΩÂÜÖÊ†∏ÂåÖÊã¨È°µË°®ÂíåÈ°µÁõÆÂΩï..Ôºâ„ÄÇ size_t free_top = PGNUM(PADDR(boot_alloc(0))); pages[free_top].pp_link = pages[range_ext].pp_link; for(i = range_ext; i &lt; free_top; i++) pages[i].pp_link = NULL;&#125; ÂêéÈù¢Â∞±Ë¶ÅÂÆûÁé∞‰∏§‰∏™ÂáΩÊï∞‰∏Ä‰∏™ÊòØÂÜÖÂ≠òÂàÜÈÖçpage_allocÔºå‰∏Ä‰∏™ÊòØÂÜÖÂ≠òÈáäÊîæpage_free„ÄÇ page_alloc12345678910111213141516171819202122232425262728//// Allocates a physical page. If (alloc_flags &amp; ALLOC_ZERO), fills the entire// returned physical page with '\0' bytes. Does NOT increment the reference// count of the page - the caller must do these if necessary (either explicitly// or via page_insert).// ÂàÜÈÖç ‰∏Ä‰∏™È°µ ÁÑ∂ÂêéËøîÂõû‰∏Ä‰∏™È°µÁªìÊûÑÔºåÂ¶ÇÊûú Âï• Â∞±ÂàùÂßãÂåñ‰∏∫0 ‰∏çÁî®Â¢ûÂä† ËÆ°Êï∞„ÄÇ// Be sure to set the pp_link field of the allocated page to NULL so// page_free can check for double-free bugs.// Êúâ‰∏§Áßç Ê£ÄÊü•// Returns NULL if out of free memory.// // Hint: use page2kva and memsetstruct PageInfo *page_alloc(int alloc_flags)&#123; // Fill this function in //Ëøô‰∏™Â∞±ÊòØÁúüÊ≠£ÁöÑÂÜÖÂ≠òÂàÜÈÖçÂáΩÊï∞‰∫Ü if(page_free_list)&#123; //ÊòØÂê¶ÊúâÁ©∫Èó≤=È°µ struct PageInfo *allocated = page_free_list; page_free_list = allocated-&gt;pp_link;// ÊúâÂ∞±ÊääËøô‰∏™ÂèñÂá∫Êù• allocated-&gt;pp_link = NULL; if (alloc_flags &amp; ALLOC_ZERO) //ÈúÄ‰∏çÈúÄË¶ÅÂàùÂßãÂåñÔºüÔºüÔºüÔºü memset(page2kva(allocated), 0, PGSIZE); return allocated; &#125; else return NULL; //return 0;&#125; page_free()123456789101112131415//// Return a page to the free list. Êääpage ÈáçÊñ∞Âä†ÂÖ• Á©∫Èó≤ÂàóË°®// (This function should only be called when pp-&gt;pp_ref reaches 0.)//voidpage_free(struct PageInfo *pp)&#123; // Fill this function in // Hint: You may want to panic if pp-&gt;pp_ref is nonzero or // pp-&gt;pp_link is not NULL. // ÂâçÈù¢‰∏§‰∏™ÊèêÁ§∫‰Ω†‰∫ÜÔºå‰∏Ä‰∏™Âà§Êñ≠ pp_ref ÊòØ‰∏çÊòØÈùû0 Ôºå‰∏Ä‰∏™ÊòØpp_link ÊòØ‰∏çÊòØÈùûÁ©∫ if(pp-&gt;pp_ref &gt; 0||pp-&gt;pp_link != NULL)panic("Page table entries point to this physical page."); pp-&gt;pp_link = page_free_list; page_free_list = pp;&#125; Âà∞Ê≠§ Áâ©ÁêÜÂÜÖÂ≠òÂàÜÈÖçÂÆûÈ™åÂÖ®ÈÉ®ÁªìÊùü‰∫ÜÔºåÊÄªÁöÑÊù•ËØ¥ÂÖ∂ÂÆûÂ∞±Âπ≤‰∫Ü‰∏â‰ª∂‰∫ãÔºö Âª∫‰∫Ü‰∫Ü‰∏Ä‰∏™È°µÁõÆÂΩïÔºåÂØπÊâÄÊúâÈ°µÂª∫‰∫Ü‰∏Ä‰∏™Êï∞ÊçÆÁªìÊûÑ ÊääÊâÄÊúâÁ©∫Èó≤ÁöÑÁ©∫Èó¥Âª∫Êàê‰∫Ü‰∏Ä‰∏™Á©∫Èó≤ÈìæË°®„ÄÇ Êèê‰æõ‰∫Ü‰∏Ä‰∏™Áâ©ÁêÜÂÜÖÂ≠òÔºåÈáäÊîæ‰∏Ä‰∏™Áâ©ÁêÜÂÜÖÂ≠ò Ëøô‰∏™ÊòØ‰ªéÊàëÁ¨¨‰∏Ä‰∏™ËµÑÊ∫êËé∑ÂèñÈÇ£ÈáåÈù¢‰∏Ä‰∏™Â§ß‰Ω¨ÈÇ£ÁõóËøáÊù•ÁöÑ„ÄÇ Part 2: Virtual MemoryÈ¶ñÂÖàËøô‰∏™ÂÆûÈ™åËÆ©‰Ω† ÂÖàËØïËØïÊ∞¥ÔºåËÆ©‰Ω†‰∫ÜËß£‰∏ãÁâ©ÁêÜÂú∞ÂùÄÂíåËôöÊãüÂú∞ÂùÄÁöÑÂ∑ÆË∑ù„ÄÇÂú®ËôöÊãüÂÜÖÂ≠òÈáåÈù¢ÈÉΩÊòØËøûÁª≠ÁöÑÁ©∫Èó¥ÔºåËΩ¨Êç¢Êàê‰∫ÜÁâ©ÁêÜÂú∞ÂùÄÂ∞±ÊòØ‰∏ÄÈ°µ‰∏ÄÈ°µÁöÑ‰∫Ü„ÄÇÊú¨Êù•ËøòÊúâÂàÜÊÆµÊìç‰ΩúÔºå‰ΩÜÊòØÂë¢Ëøô‰∏™ÈáåÈù¢Ê≤°ÊúâÁî®‰∏äÔºåÁªôÁ¶ÅÁî®‰∫Ü„ÄÇÊòØÂê¶ËÆ∞Âæó ÈÇ£Âπ¥Â§èÂ§©Êàë‰ª¨ÊâÄÂÅöËøáÁöÑ Lab 1 part3 Áî®‰∫Ü‰∏Ä‰∏™ÁÆÄÂçïÁöÑÈ°µË°®ÔºåÂ∞±Êò†Â∞Ñ‰∫Ü 4MBÔºåËÄåÁé∞Âú®Êàë‰ª¨Ë¶ÅÊò†Â∞Ñ256MB„ÄÇQuestion 1 ËÇØÂÆöÊòØËôöÊãüÂú∞ÂùÄÂïä„ÄÇ ÁÑ∂ÂêéËÆ≤‰∫ÜKADDRÔºåPADDRÔºåÂâçÈù¢‰ª£Á†ÅÈÇ£‰∏™Âï•Êñá‰ª∂ÈáåÈù¢ÊúâÔºåÁúã‰∏Ä‰∏ãÂ∞±ÂèØ‰ª•Áü•ÈÅì‰∫Ü„ÄÇÂêéÈù¢ÂèàÊâØ‰∫Ü‰∏ÄÂ§ßÂ†ÜÔºåÁúã‰∏ÄÁúã‰∫ÜËß£‰∏Ä‰∏ãÂ∞±Ë°å‰∫Ü„ÄÇÁÑ∂ÂêéÂèàÁªßÁª≠ÊàëÁöÑÁúãÊ∫êÁ†ÅÂ§ß‰∏ö‰∫Ü„ÄÇËøôÊ¨°ÂáΩÊï∞Âπ∂Ê≤°ÊúâÂú® mem_init() ÈáåÈù¢‰ΩøÁî®Ôºå‰ΩÜÊòØÂë¢ÂÜô‰∫Ü‰∏Ä‰∫õÊµãËØïÁöÑ‰∏úË•ø„ÄÇÊàë‰ª¨Â∞±ÁÖßÁùÄÂÆûÈ™å‰∏äÊù•‰∏Ä‰∏™‰∏™ÂÆûÁé∞ÂáΩÊï∞„ÄÇ12345pgdir_walk()boot_map_region()page_lookup()page_remove()page_insert() Ëøô‰∏™ÂáΩÊï∞ÁúãÊáÇ‰∫Ü‰ºöÂèóÁõäÂæàÂ§ßÁöÑ„ÄÇ pgdir_walk()123456789101112131415161718192021222324252627282930313233343536373839404142// Given 'pgdir', a pointer to a page directory, pgdir_walk returns// a pointer to the page table entry (PTE) for linear address 'va'.// This requires walking the two-level page table structure.// Áªô‰∏Ä‰∏™ È°µÁõÆÂΩï ËøîÂõû‰∏Ä‰∏™È°µË°®È°πÔºå‰∏§Á∫ßÈ°µË°®ÁªìÊûÑ// The relevant page table page might not exist yet. Áõ∏ÂÖ≥È°µË°®ÂèØËÉΩ‰∏çÂ≠òÂú®// If this is true, and create == false, then pgdir_walk returns NULL.Â¶ÇÊûúÁúüÁöÑ‰∏çÂ≠òÂú® ‰∏îcreate Ê†áÂøó‰∏∫false Â∞±ËøîÂõûNULL// Otherwise, pgdir_walk allocates a new page table page with page_alloc. Âê¶ÂàôÁî®paga_allocÂàõÂª∫‰∏Ä‰∏™// - If the allocation fails, pgdir_walk returns NULL. ÂàõÂª∫Â§±Ë¥•ËøîÂõûNULL// - Otherwise, the new page's reference count is incremented, Âê¶ÂàôÊñ∞ÁöÑÈ°µÂºïÁî®Ê¨°Êï∞++// the page is cleared,È°µÊ∏ÖÁ©∫// and pgdir_walk returns a pointer into the new page table page.ËøîÂõûÈ°µÊåáÈíà//// Hint 1: you can turn a PageInfo * into the physical address of the// page it refers to with page2pa() from kern/pmap.h. ‰Ω†ÂèØ‰ª•ÈÄöËøá page2pa() ËΩ¨Êç¢ÊàêÁâ©ÁêÜÂú∞ÂùÄÔºå//Ëøô‰∏™ÂéªÈáåÈù¢ÁúãÁúã Â∞±Áü•ÈÅì‰∏∫‰ªÄ‰πà‰∫Ü„ÄÇ// Hint 2: the x86 MMU checks permission bits in both the page directory// and the page table, so it's safe to leave permissions in the page// directory more permissive than strictly necessary.// x86 MMU Ê£ÄÊü•È°µÁõÆÂΩï ÂíåÈ°µË°®ÔºåÊâÄ‰ª• È°µÁõÆÂΩïÊØî È°µË°®ÊùÉÈôêÊõ¥‰∏•Ê†º// Hint 3: look at inc/mmu.h for useful macros that manipulate page// table and page directory entries.//Âéª mmu.h ÁúãÁúãÊúâÁî®ÁöÑÂÆè pte_t *pgdir_walk(pde_t *pgdir, const void *va, int create)&#123; // Fill this function in struct PageInfo * np; //ËøôÂèØËÉΩÊúâÁÇπÁªï //PDX ÊòØÈ°µÁõÆÂΩïÈáåÈù¢ÁöÑÁ¥¢ÂºïÔºå pgdir ÊòØ È°µÁõÆÂΩïÔºåÁî®‰∏Ä‰∏™ ÊåáÈíàÊåáÂêëËøô‰∏™Âú∞ÂùÄ pte_t * pd_entry =&amp;pgdir[PDX(va)]; //PTE_P Âà§Êñ≠ÊòØ‰∏çÊòØÂ∑≤ÁªèÂ≠òÂú®ËØ•È°µÔºåÊòØÁöÑËØùÂ∞±Áõ¥Êé•ËøîÂõûÔºåËøîÂõûÁöÑËøô‰∏™Âú∞ÂùÄÔºåÂ∞±ÊòØÈ°µÂú∞ÂùÄ+ÂÅèÁßªÂú∞ÂùÄ if(*pd_entry &amp; PTE_P) //Â¶ÇÊûúËøô‰∏™È°πÂ≠òÂú®Â∞±Áõ¥Êé•ËøîÂõûÈ°µÂú∞ÂùÄÔºåÁúã‰∫ÜÂçäÂ§©ÔºåÂ¶ÇÊûúPTX(va) Âè™Âèñ‰∫ÜÈ°µÂÅèÁßªÂú∞ÂùÄÔºåÊâÄ‰ª• Ëøô‰∏™Êó∂ÂÄôËøîÂõûÁöÑÂÆûÈôÖ‰∏äÊòØ‰∏Ä‰∏™ È°µÁöÑÂú∞ÂùÄÔºåËÄå‰∏çÊòØÈ°µË°®ÁöÑÂÖ•Âè£Âú∞ÂùÄ„ÄÇËøô‰∏™Âú∞ÊñπËøîÂõûÁöÑÂÄºÂ∫îËØ•ÊúâÁÇπÊ¨†Áº∫„ÄÇ return (pte_t *)KADDR(PTE_ADDR(*pd_entry))+PTX(va);//PTE_ADDR ÂèñÈ°µË°®È°πÈáåÈù¢ÁöÑÂÄº ÁÑ∂ÂêéËΩ¨Êç¢ÊàêËôöÊãüÂú∞ÂùÄ + ‰∏äÂÅèÁßªÈáèÂ∞±ÊòØÈ°µË°®ÁöÑ‰ΩçÁΩÆ Â∞±Áõ∏ÂΩì‰∫éÊõøÊç¢‰∫ÜËôöÊãüÂú∞ÂùÄÈáåÈù¢ÁöÑ È°µÁõÆÂΩïÁ¥¢Âºï„ÄÇ else if(create == true &amp;&amp; (np=page_alloc(ALLOC_ZERO)))&#123; //Â¶ÇÊûúÂèØ‰ª•ÂàõÂª∫Â∞±ÂàõÂª∫‰∏Ä‰∏™ np-&gt;pp_ref++; // page2pa ÊääPageInfo ÁªìÊûÑËΩ¨Êç¢Êàê Áâ©ÁêÜÂú∞ÂùÄ„ÄÇ *pd_entry=page2pa(np)|PTE_P|PTE_U|PTE_W; //ËÆæÁΩÆ‰∏Ä‰∫õÂÄº return (pte_t *)KADDR(PTE_ADDR(*pd_entry)) + PTX(va); &#125; else return NULL;&#125; boot_map_region()123456789101112131415161718192021222324//// Map [va, va+size) of virtual address space to physical [pa, pa+size)// in the page table rooted at pgdir. Size is a multiple of PGSIZE, and// va and pa are both page-aligned. È°µÂØπÈΩêÔºåÊääpa Êò†Â∞ÑÂà∞ va// Use permission bits perm|PTE_P for the entries. ‰ΩøÁî®Ëøô‰∏™ÊùÉÈôêÔºü//// This function is only intended to set up the ``static'' mappings// above UTOP. As such, it should *not* change the pp_ref field on the// mapped pages.//Ëøô‰∏™ÂáΩÊï∞ Âª∫Á´ã‰∏Ä‰∏™ÈùôÊÄÅÊò†Â∞ÑÔºåÂè™Áî®Âú® UTOP ‰ª•‰∏äÔºå‰∏çÂ∫îËØ•ÊîπÂèòÊò†Â∞ÑÂå∫Âüü// Hint: the TA solution uses pgdir_walkstatic voidboot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)&#123; // Fill this function in uintptr_t vStep; pte_t *ptep; for(vStep=0;vStep&lt;size;vStep+=PGSIZE)&#123; // ‰∏çÁü•ÈÅì‰∏∫Âï•ÊàëÊÄªÊÑüËßâ pgdir_walk ÊÄªÊÑüËßâËøîÂõûÁöÑÊòØÂÖ∑‰ΩìÈ°µÔºåËÄå‰∏çÊòØÈ°µË°®ÂÖ•Âè£Âú∞ÂùÄ„ÄÇÂèØËÉΩpaÂ∞±ÊòØ‰∏Ä‰∏™È°µË°®ÂÖ•Âè£Âú∞ÂùÄÂêß...‰πüÊúâÂèØËÉΩÈ°µË°®Êú¨Ë∫´‰πüÊòØ‰∏Ä‰∏™È°µÔºåËøôÂú∞ÊñπÁõ¥Êé•ÂΩìÂÅö‰∏ÄÁ∫ßÈ°µË°®Áî®‰∫ÜÔºå‰πü‰∏çÊòØÊ≤°ÊúâÂèØËÉΩ ptep=pgdir_walk(pgdir,(void *)va+vStep,true);//ÊâæÂà∞ vaËôöÊãüÂú∞ÂùÄÂØπÂ∫îÁöÑÈ°µË°®ÂÖ•Âè£Âú∞ÂùÄ if(ptep)*ptep=pa|perm|PTE_P;//ÁÑ∂ÂêéÊääËøô‰∏™ÂÖ•Âè£Âú∞ÂùÄ ÊåáÂêë Áâ©ÁêÜÂú∞ÂùÄ pa pa+=PGSIZE; &#125;&#125; page_lookup()1234567891011121314151617181920212223242526//// Return the page mapped at virtual address 'va'.// If pte_store is not zero, then we store in it the address// of the pte for this page. This is used by page_remove and// can be used to verify page permissions for syscall arguments,// but should not be used by most callers.//Â¶ÇÊûú pte_store ‰∏çÊòØ0 Â∞ÜÁâ©ÁêÜÈ°µÂØπÂ∫îÁöÑÈ°µË°®È°πÊåáÈíàÂ≠òÂÇ®‰∫éÂÖ∂‰∏≠// Return NULL if there is no page mapped at va.//Â¶ÇÊûúÊ≤°ÊúâÊò†Â∞Ñ ËøîÂõûÁ©∫// Hint: the TA solution uses pgdir_walk and pa2page.//struct PageInfo *page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)&#123; // Fill this function in //Â∞±ÂΩìÂÅö ptep ÊåáÂêëÈ°µË°®ÂÖ•Âè£Âú∞ÂùÄ pte_t *ptep =pgdir_walk(pgdir,va,false); if(ptep&amp;&amp;(*ptep&amp;PTE_P))&#123; if(pte_store)&#123; *pte_store=ptep; &#125; //ËøîÂõûÂØπÂ∫îPageInfo return pa2page(PTE_ADDR(*ptep)); &#125; return NULL;&#125; page_remove()123456789101112131415161718192021222324252627//// Unmaps the physical page at virtual address 'va'.// If there is no physical page at that address, silently does nothing.//Â¶ÇÊûúÊ≤°ÊúâÊò†Â∞ÑÁâ©ÁêÜÂú∞ÂùÄÂ∞±Âï•ÈÉΩ‰∏çÂÅö// Details:// - The ref count on the physical page should decrement. refÂ∫îËØ•--// - The physical page should be freed if the refcount reaches 0. Â¶ÇÊûúÂà∞0Â∫îËØ•ÈáäÊîæ// - The pg table entry corresponding to 'va' should be set to 0.È°µË°® ÂÖ•Âè£Âú∞ÂùÄÂ∫îËØ•ÁΩÆ0// (if such a PTE exists)// - The TLB must be invalidated if you remove an entry from // the page table.// TLB Â∫îËØ•Âà†Èô§ÂÖ•Âè£Âú∞ÂùÄ// Hint: The TA solution is implemented using page_lookup,// tlb_invalidate, and page_decref.//voidpage_remove(pde_t *pgdir, void *va)&#123; // Fill this function in pte_t* pte_store; struct PageInfo *pgit=page_lookup(pgdir, va, &amp;pte_store); if(pgit)&#123; page_decref(pgit); *pte_store=0; tlb_invalidate(pgdir,va);//Ëøô‰∏™ÂáΩÊï∞ÊòØ‰∏çÁî®Êàë‰ª¨ÂÆûÁé∞ÁöÑ &#125;&#125; page_insert()1234567891011121314151617181920212223242526272829303132333435363738//// Map the physical page 'pp' at virtual address 'va'.// The permissions (the low 12 bits) of the page table entry// should be set to 'perm|PTE_P'.//// Requirements// - If there is already a page mapped at 'va', it should be page_remove()d.Â¶ÇÊûú‰∏ÄÁ∫ßÂ≠òÂú®Â∞±ÈúÄË¶Å Êää‰ªñÂà†Èô§// - If necessary, on demand, a page table should be allocated and inserted// into 'pgdir'. Â¶ÇÊûúÊúâÂøÖË¶ÅÔºå‰∏Ä‰∏™È°µË°®ÈúÄË¶ÅË¢´ÂàÜÈÖçÔºåÊèíÂÖ•Âà∞ pgdirÈáåÈù¢// - pp-&gt;pp_ref should be incremented if the insertion succeeds. refÂ∫îËØ•ÈÄíÂ¢û// - The TLB must be invalidated if a page was formerly present at 'va'.// TLB Â∫îËØ•Ë¢´Âà†Èô§ Â¶ÇÊûúÂ≠òÂú®va ÁöÑÈ°µ// Corner-case hint: Make sure to consider what happens when the same// pp is re-inserted at the same virtual address in the same pgdir.// However, try not to distinguish this case in your code, as this// frequently leads to subtle bugs; there's an elegant way to handle// everything in one code path.// ÊûÅÁ´ØÊÑèËØÜ Á°Æ‰øùÂú®Áõ∏ÂêåÁöÑÈ°µË°®ÂÜçÊ¨°ÊèíÂÖ•Âà∞È°µÁõÆÂΩï‰∏≠ÔºåÁøªËØë‰∏çËøáÊù•ÂëäËæû„ÄÇ// RETURNS:// 0 on success// -E_NO_MEM, if page table couldn't be allocated//// Hint: The TA solution is implemented using pgdir_walk, page_remove,// and page2pa.//intpage_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)&#123; // Fill this function in pte_t *ptep=pgdir_walk(pgdir, va, true); if(ptep)&#123; pp-&gt;pp_ref++; if(*ptep&amp;PTE_P)page_remove(pgdir, va);//Â¶ÇÊûúÂ∑≤ÁªèÊúâ‰∫Ü Â∞±ÂÖàÂà†‰∫Ü.. *ptep = page2pa(pp) | perm | PTE_P; return 0; &#125; return -E_NO_MEM;&#125; Permissions and Fault IsolationÁé∞Âú® Â∞±ÊòØËÆ©‰Ω†Êò†Â∞ÑÂÜÖÊ†∏Âå∫Âüü‰∫Ü„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839//////////////////////////////////////////////////////////////////////// Map 'pages' read-only by the user at linear address UPAGES// Permissions:// - the new image at UPAGES -- kernel R, user R// (ie. perm = PTE_U | PTE_P)// - pages itself -- kernel RW, user NONE// Your code goes here: //‰ªîÁªÜÂàÜÊûê‰∫Ü‰∏ãÔºåÂ•ΩÂÉèÊòØÊää UPAGES ËôöÊãüÂÜÖÂ≠ò ÊåáÂêë pages„ÄÇÊò†Â∞ÑÂ§ßÂ∞èÊòØ PTSIZE ‰∏Ä‰∏™È°µË°®ÁöÑÂ§ßÂ∞è 4MÔºåboot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U|PTE_P);//////////////////////////////////////////////////////////////////////// Use the physical memory that 'bootstack' refers to as the kernel// stack. The kernel stack grows down from virtual address KSTACKTOP.// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)// to be the kernel stack, but break this into two pieces:// * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory// * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if// the kernel overflows its stack, it will fault rather than// overwrite memory. Known as a "guard page".// Permissions: kernel RW, user NONE// ‰ΩøÁî®Áâ©ÁêÜÂÜÖÂ≠ò bootstack ÊåáÂêë ÂÜÖÊ†∏ÁöÑÊ†àÔºåÂÜÖÊ†∏ÁöÑÊ†à ‰ªéKSTACKTOP ÂºÄÂßãÂêë‰∏ãÂ¢ûÈïø//ÂàÜ‰∫Ü‰∏§ÂùóÔºåÁ¨¨‰∏ÄÂùó[KSTACKTOP-KSTKSIZE, KSTACKTOP)ÔºåËøô‰∏ÄÂùóÈúÄË¶ÅÊò†Â∞Ñ//[KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE)Ëøô‰∏ÄÂùó‰∏çÊò†Â∞ÑÔºåËøôÊ†∑Â¶ÇÊûúÁÇ∏Ê†à‰∫ÜÂ∞±Áõ¥Êé•Êä•REÈîôËØØÔºåËÄå‰∏çÊòØË¶ÜÁõñ‰ΩéÂú∞ÂùÄÁöÑÊï∞ÊçÆ„ÄÇ// Your code goes here:// Âõ†‰∏∫ÊòØ‰ªéÈ´òÂà∞Â∫ïÔºåÊâÄ‰ª•Êò†Â∞ÑÂ∞±‰ªé KSTACKTOP-KSTKSIZE Âà∞ KSTACKTOP„ÄÇboot_map_region(kern_pgdir, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);//////////////////////////////////////////////////////////////////////// Map all of physical memory at KERNBASE.// Ie. the VA range [KERNBASE, 2^32) should map to// the PA range [0, 2^32 - KERNBASE)// We might not have 2^32 - KERNBASE bytes of physical memory, but// we just set up the mapping anyway.// Permissions: kernel RW, user NONE// Your code goes here://Ëøô‰∏™Â∞±ÊòØÂÜÖÊ†∏ÊÄÅÔºåÈáåÈù¢ÂèØ‰ª•ÈÄöÁî®ÁöÑÂÜÖÂ≠òÔºåÊÄªÂÖ±256Mboot_map_region(kern_pgdir, KERNBASE, 0x10000000, 0, PTE_W); //Âà∞Ê≠§‰ΩçÁΩÆÂÆûÈ™åË¶ÅÂÜôÁöÑ‰ª£Á†ÅÂ∑≤ÁªèÂÜôÂÆåÊàê‰∫Ü„ÄÇ Ëøô‰∏™Êó∂ÂÄôËøêË°åÂ∑≤ÁªèÊ≤°‰ªÄ‰πàÈóÆÈ¢ò‰∫Ü„ÄÇ Ëøô‰∏™‰πüÊòØÁõóÁöÑÔºö Question: 2. Âà∞ÁõÆÂâç‰∏∫Ê≠¢È°µÁõÆÂΩïË°®‰∏≠Â∑≤ÁªèÂåÖÂê´Â§öÂ∞ëÊúâÊïàÈ°µÁõÆÂΩïÈ°πÔºü‰ªñ‰ª¨ÈÉΩÊò†Â∞ÑÂà∞Âì™ÈáåÔºü 3BDÂè∑È°µÁõÆÂΩïÈ°πÔºåÊåáÂêëÁöÑÊòØkern_pgdir 3BCÂè∑È°µÁõÆÂΩïÈ°πÔºåÊåáÂêëÁöÑÊòØpagesÊï∞ÁªÑ 3BFÂè∑È°µÁõÆÂΩïÈ°πÔºåÊåáÂêëÁöÑÊòØbootstack 3C0~3FFÂè∑È°µÁõÆÂΩïÈ°πÔºåÊåáÂêëÁöÑÊòØkernel 3. Â¶ÇÊûúÊàë‰ª¨ÊääkernelÂíåuser environmentÊîæÂú®‰∏Ä‰∏™Áõ∏ÂêåÁöÑÂú∞ÂùÄÁ©∫Èó¥‰∏≠„ÄÇ‰∏∫‰ªÄ‰πàÁî®Êà∑Á®ãÂ∫è‰∏çÂêåËØªÂèñÔºåÂÜôÂÖ•ÂÜÖÊ†∏ÁöÑÂÜÖÂ≠òÁ©∫Èó¥ÔºüÁî®‰ªÄ‰πàÊú∫Âà∂‰øùÊä§ÂÜÖÊ†∏ÁöÑÂú∞ÂùÄËåÉÂõ¥„ÄÇ Áî®Êà∑Á®ãÂ∫è‰∏çËÉΩÂéªÈöèÊÑè‰øÆÊîπÂÜÖÊ†∏‰∏≠ÁöÑ‰ª£Á†ÅÔºåÊï∞ÊçÆÔºåÂê¶ÂàôÂèØËÉΩ‰ºöÁ†¥ÂùèÂÜÖÊ†∏ÔºåÈÄ†ÊàêÁ®ãÂ∫èÂ¥©Ê∫É„ÄÇ Ê≠£Â∏∏ÁöÑÊìç‰ΩúÁ≥ªÁªüÈÄöÂ∏∏ÈááÁî®‰∏§‰∏™ÈÉ®‰ª∂Êù•ÂÆåÊàêÂØπÂÜÖÊ†∏Âú∞ÂùÄÁöÑ‰øùÊä§Ôºå‰∏Ä‰∏™ÊòØÈÄöËøáÊÆµÊú∫Âà∂Êù•ÂÆûÁé∞ÁöÑÔºå‰ΩÜÊòØJOS‰∏≠ÁöÑÂàÜÊÆµÂäüËÉΩÂπ∂Ê≤°ÊúâÂÆûÁé∞„ÄÇ‰∫åÂ∞±ÊòØÈÄöËøáÂàÜÈ°µÊú∫Âà∂Êù•ÂÆûÁé∞ÔºåÈÄöËøáÊääÈ°µË°®È°π‰∏≠ÁöÑ Supervisor/User‰ΩçÁΩÆ0ÔºåÈÇ£‰πàÁî®Êà∑ÊÄÅÁöÑ‰ª£Á†ÅÂ∞±‰∏çËÉΩËÆøÈóÆÂÜÖÂ≠ò‰∏≠ÁöÑËøô‰∏™È°µ„ÄÇ 4. Ëøô‰∏™Êìç‰ΩúÁ≥ªÁªüÁöÑÂèØ‰ª•ÊîØÊåÅÁöÑÊúÄÂ§ßÊï∞ÈáèÁöÑÁâ©ÁêÜÂÜÖÂ≠òÊòØÂ§öÂ§ßÔºü Áî±‰∫éËøô‰∏™Êìç‰ΩúÁ≥ªÁªüÂà©Áî®‰∏Ä‰∏™Â§ßÂ∞è‰∏∫4MBÁöÑÁ©∫Èó¥UPAGESÊù•Â≠òÊîæÊâÄÊúâÁöÑÈ°µÁöÑPageInfoÁªìÊûÑ‰Ωì‰ø°ÊÅØÔºåÊØè‰∏™ÁªìÊûÑ‰ΩìÁöÑÂ§ßÂ∞è‰∏∫8BÔºåÊâÄ‰ª•‰∏ÄÂÖ±ÂèØ‰ª•Â≠òÊîæ512K‰∏™PageInfoÁªìÊûÑ‰ΩìÔºåÊâÄ‰ª•‰∏ÄÂÖ±ÂèØ‰ª•Âá∫Áé∞512K‰∏™Áâ©ÁêÜÈ°µÔºåÊØè‰∏™Áâ©ÁêÜÈ°µÂ§ßÂ∞è‰∏∫4KBÔºåËá™ÁÑ∂ÊÄªÁöÑÁâ©ÁêÜÂÜÖÂ≠òÂç†2GB„ÄÇ 5. Â¶ÇÊûúÁé∞Âú®ÁöÑÁâ©ÁêÜÂÜÖÂ≠òÈ°µËææÂà∞ÊúÄÂ§ß‰∏™Êï∞ÔºåÈÇ£‰πàÁÆ°ÁêÜËøô‰∫õÂÜÖÂ≠òÊâÄÈúÄË¶ÅÁöÑÈ¢ùÂ§ñÁ©∫Èó¥ÂºÄÈîÄÊúâÂ§öÂ∞ëÔºü ËøôÈáå‰∏çÂ§™ÊòéÁôΩÔºåÂèÇËÄÉÂà´ÁöÑÁ≠îÊ°àÊòØÔºåÈ¶ñÂÖàÈúÄË¶ÅÂ≠òÊîæÊâÄÊúâÁöÑPageInfoÔºåÈúÄË¶Å4MBÔºåÈúÄË¶ÅÂ≠òÊîæÈ°µÁõÆÂΩïË°®Ôºåkern_pgdirÔºå4KBÔºåËøòÈúÄË¶ÅÂ≠òÊîæÂΩìÂâçÁöÑÈ°µË°®ÔºåÂ§ßÂ∞è‰∏∫2MB„ÄÇÊâÄ‰ª•ÊÄªÁöÑÂºÄÈîÄÂ∞±ÊòØ6MB + 4KB„ÄÇ 6. ÂõûÈ°æentry.SÊñá‰ª∂‰∏≠ÔºåÂΩìÂàÜÈ°µÊú∫Âà∂ÂºÄÂêØÊó∂ÔºåÂØÑÂ≠òÂô®EIPÁöÑÂÄº‰ªçÊóßÊòØ‰∏Ä‰∏™Â∞èÁöÑÂÄº„ÄÇÂú®Âì™‰∏™‰ΩçÁΩÆ‰ª£Á†ÅÊâçÂºÄÂßãËøêË°åÂú®È´ò‰∫éKERNBASEÁöÑËôöÊãüÂú∞ÂùÄÁ©∫Èó¥‰∏≠ÁöÑÔºüÂΩìÁ®ãÂ∫è‰Ωç‰∫éÂºÄÂêØÂàÜÈ°µ‰πãÂêéÂà∞ËøêË°åÂú®KERNBASE‰πã‰∏äËøô‰πãÈó¥ÁöÑÊó∂ÂÄôÔºåEIPÁöÑÂÄºÊòØÂ∞èÁöÑÂÄºÔºåÊÄé‰πà‰øùËØÅÂèØ‰ª•ÊääËøô‰∏™ÂÄºËΩ¨Êç¢‰∏∫ÁúüÂÆûÁâ©ÁêÜÂú∞ÂùÄÁöÑÔºü Âú®entry.SÊñá‰ª∂‰∏≠Êúâ‰∏Ä‰∏™Êåá‰ª§ jmp *%eaxÔºåËøô‰∏™Êåá‰ª§Ë¶ÅÂÆåÊàêË∑≥ËΩ¨ÔºåÂ∞±‰ºöÈáçÊñ∞ËÆæÁΩÆEIPÁöÑÂÄºÔºåÊääÂÆÉËÆæÁΩÆ‰∏∫ÂØÑÂ≠òÂô®eax‰∏≠ÁöÑÂÄºÔºåËÄåËøô‰∏™ÂÄºÊòØÂ§ß‰∫éKERNBASEÁöÑÔºåÊâÄ‰ª•Â∞±ÂÆåÊàê‰∫ÜEIP‰ªéÂ∞èÁöÑÂÄºÂà∞Â§ß‰∫éKERNBASEÁöÑÂÄºÁöÑËΩ¨Êç¢„ÄÇ Âú®entry_pgdirËøô‰∏™È°µË°®‰∏≠Ôºå‰πüÊääËôöÊãüÂú∞ÂùÄÁ©∫Èó¥[0, 4MB)Êò†Â∞ÑÂà∞Áâ©ÁêÜÂú∞ÂùÄÁ©∫Èó¥[0, 4MB)‰∏äÔºåÊâÄ‰ª•ÂΩìËÆøÈóÆ‰Ωç‰∫é[0, 4MB)‰πãÈó¥ÁöÑËôöÊãüÂú∞ÂùÄÊó∂ÔºåÂèØ‰ª•ÊääÂÆÉ‰ª¨ËΩ¨Êç¢‰∏∫Áâ©ÁêÜÂú∞ÂùÄ„ÄÇAddress Space Layout Alternatives ËøõÁ®ãÁöÑËôöÊãüÂú∞ÂùÄÁ©∫Èó¥ÁöÑÂ∏ÉÂ±Ä‰∏çÊòØÂè™ÊúâÊàë‰ª¨ËÆ®ËÆ∫ÁöÑËøôÁßçÂîØ‰∏ÄÁöÑÊÉÖÂÜµÔºåÊàë‰ª¨‰πüÂèØ‰ª•ÊääÂÜÖÊ†∏Êò†Â∞ÑÂà∞‰ΩéÂú∞ÂùÄÂ§Ñ„ÄÇ‰ΩÜÊòØJOS‰πãÊâÄ‰ª•Ë¶ÅËøô‰πàÂÅöÔºåÊòØ‰∏∫‰∫Ü‰øùËØÅx86ÁöÑÂêëÂêéÂÖºÂÆπÊÄß„ÄÇ Âè™Ë¶ÅÊàë‰ª¨ËÉΩÂ§ü‰ªîÁªÜËÆæËÆ°ÔºåËôΩÁÑ∂ÂæàÈöæÔºå‰ΩÜÊòØÊàë‰ª¨‰πüËÉΩËÆæËÆ°Âá∫Êù•‰∏ÄÁßçÂÜÖÊ†∏ÁöÑÂ∏ÉÂ±ÄÊñπÂºèÔºå‰ΩøÂæóËøõÁ®ãÁöÑÂú∞ÂùÄÁ©∫Èó¥Â∞±ÊòØ‰ªé0Âà∞4GBÔºåÊó†ÈúÄ‰∏∫ÂÜÖÊ†∏È¢ÑÁïô‰∏ÄÈÉ®ÂàÜÁ©∫Èó¥Ôºå‰ΩÜÊòØ‰ªçÁÑ∂ËÉΩÂ§ü‰øùËØÅÔºåÁî®Êà∑ËøõÁ®ã‰∏ç‰ºöÁ†¥ÂùèÊìç‰ΩúÁ≥ªÁªüÁöÑÊåá‰ª§ÔºåÊï∞ÊçÆ„ÄÇ]]></content>
      <categories>
        <category>Êìç‰ΩúÁ≥ªÁªü</category>
        <category>MIT6.828</category>
      </categories>
      <tags>
        <tag>MIT6.828</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT6.828(‰∏Ä)Lab1:Booting a PC]]></title>
    <url>%2F2020%2F02%2F18%2FMIT-6.828-(%E4%B8%80)-Lab-1-Booting-a-PC%2F</url>
    <content type="text"><![CDATA[Ëé∑ÂèñÂÆåËµÑÊ∫êÂ∞±ÂºÄÂßãÂπ≤‰∫Ü„ÄÇÊàëËøôÈáåÂ∞±ÂÅö‰∫Ü‰∏™Â§ßÊ¶ÇÁöÑÂÜÖÂÆπÂàÜÊûêÔºåÂÖ∑‰ΩìÁöÑËøòÊòØË∑üÁùÄÈÇ£Âá†‰∏™Â§ß‰Ω¨Âêß ÂâçÈù¢‰∏ÄÂ§ßÂ†ÜÈÉΩÊòØÊ≤°Áî®ÁöÑÔºåÂ∞±ÊòØÂëäËØâ‰∏Ä‰∫õ‰Ωú‰∏öÁöÑÊèê‰∫§„ÄÇ Part 1: PC BootstrapËøô‰∏™Âπ∂Ê≤°ÊúâË¶Å‰Ω†ÂÅöÂï•ÔºåÂ∞±ÊòØËÆ©‰Ω† ÁÜüÊÇâ‰∏ãÊ±áÁºñ„ÄÇ ÁÑ∂ÂêéËÆ©‰Ω†Áü•ÈÅìÊÄé‰πàËøêË°åÈÇ£‰∏™ÂÜÖÊ†∏ÁöÑÔºåËøô‰∫õÈÉΩÊòØ‰∫õ‰∏çÁî®ËÆ≤ÁöÑ‰∏úË•øÔºåÁúãÁúãÂ∞±Ë°å‰∫Ü„ÄÇËØ¥‰∏Ä‰∏ãÔºåËøô‰∏™ÂÜÖÊ†∏ÈÄÄÂá∫ËØ¥ÊòØctrl+a x,ÊÑèÊÄùÊòØÂÖàÊåâctrl+a,ÂÜçÊåâx ÁÑ∂ÂêéÂ∞±ÂºÄÂßãÊù•ÈáçÁÇπ‰∫ÜÔºåÁ¨¨‰∏Ä‰∏™ÊòØËÆ©‰Ω†Áü•ÈÅìÁé∞Âú®ËÆ°ÁÆóÊú∫ÂÜÖÂ≠òÁöÑÂàÜÂ∏É„ÄÇ The PC‚Äôs Physical Address SpaceÔºàPCÁöÑÁâ©ÁêÜÂú∞ÂùÄÁ©∫Èó¥Ôºâ The ROM BIOSÂêéÈù¢Â∞±ÊØîËæÉÁõ¥Êé•‰∫ÜÔºåÁõ¥Êé•ËÆ©‰Ω†ÂéªËøêË°åËøô‰∏™ÂÜÖÊ†∏Ôºå‰∏ÄÊ≠•Ê≠•Êù•Áúã‰ªñÊòØÊÄé‰πàËøêË°åÁöÑ„ÄÇ Â∞±ÊòØËÆ©‰Ω†ËøôÊ†∑ËøêË°å‰∏§‰∏™ÁªàÁ´ØÔºåË∑ëGDB Ë∞ÉËØïÔºåÁ¨¨‰∏Ä‰∏™ËøêË°åmake qemu-gdb,Á¨¨‰∫å‰∏™ËøêË°åmake gdb„ÄÇ‰∏çÂá∫ÊÑèÂ§ñÔºåÂú®make gdb ÈáåÈù¢Âá∫Áé∞ÁöÑÁ¨¨‰∏ÄÊù°Êåá‰ª§ÊòØË∑≥ËΩ¨Êåá‰ª§„ÄÇË∑≥Âà∞‰∫ÜÂì™ÈáåÂéªÔºåËøô‰∏™Âú∞ÂùÄÂÆòÊñπÊòØÁªô‰∫Ü‰Ω†Ëß£ÈáäÁöÑÔºåÂ∞±ÊòØÊÆµÂú∞ÂùÄ*16Âä†ÂÅèÁßªÂú∞Á∫∏ÔºåÂæàÊòæÁÑ∂Ôºå‰ªñÁöÑÂú∞ÂùÄÊòØÂú®BIOS‰∏≠„ÄÇÁÑ∂ÂêéÂõûËÆ©‰Ω†‰∏ÄÊ≠•Ê≠•ÊâßË°åÁúãÂèëÁîü‰∫Ü‰ªÄ‰πà„ÄÇ‰∏çÈöæÂèëÁé∞ÔºåËÆ°ÁÆóÊú∫ÁöÑËøêË°åÊúÄÂÖàÂºÄÂßãÁöÑÊòØ BIOS„ÄÇ ÂêéÈù¢‰∏ÄÊ≠•Ê≠•ÔºåÊâßË°åÁöÑÂÜÖÂÆπÊàëÂ∞±Áúã‰∏çÊáÇÔºåÂè™Áü•ÈÅì‰ªñÂ∞±ÂÅö‰∫Ü‰∏Ä‰∫õÂàùÂßãÂåñÂ∑•‰ΩúÔºåÊÉ≥‰∫ÜËß£ÁöÑÂéªÁúãÁúãÂ§ß‰Ω¨ÁöÑÂçöÂÆ¢Âêß„ÄÇ Part 2: The Boot LoaderÂàùÂßãÂåñÂÆåÊàêBIOS ‰πãÂêéÔºåÂ∞±ËøêË°åBoot LoaderÔºåÂ∞±ÊòØÂºïÂØºÊìç‰ΩúÁ≥ªÁªüÔºåËøô‰∏™‰∏úË•ø‰∏ÄÁõ¥ÈÉΩÊòØÊîæÂú®ËÆ°ÁÆóÊú∫Á£ÅÁõòÁöÑÁ¨¨‰∏Ä‰∏™ÊâáÂå∫Ôºà‰πüÁî®ÂèØËÉΩÊòØÂÖ∂‰ªñÁöÑÂºïÂØºÔºåËøô‰∏™ÁôæÂ∫¶Êêú‰∏ÄÊêúËÉΩÊêúÂá∫Êù•ÔºåÂè¶Â§ñ‰∏Ä‰∏™ÊúÄÂ∏∏ËßÅÁöÑÂ∞±ÊòØUÁõòÂêØÂä®ÔºåÂ≠¶ËÆ°ÁÆóÊú∫ÁöÑÈáçË£ÖÁ≥ªÁªüËá≥Â∞ë‰πüÊúâÂçÅÊ¨°ÂÖ´Ê¨°‰∫ÜÂêßÔºåÊâÄ‰ª•Ëøô‰∏™ÂæàÂÆπÊòìÁêÜËß£ÔºåÊàë‰ª¨ÈáçË£ÖÁ≥ªÁªüÁöÑÊ≠•È™§‰∏çÂ∞±ÊòØÁé∞Âú®BIOSÈáåÈù¢ÈÄâ‰∫ÜUÁõòÂºïÂØºÔºåÂπ≤ÁöÑÂ∞±ÊòØËøô‰∏™‰∫ÜÔºâ„ÄÇÁÑ∂ÂêéBIOS‰ºöÊääËøô‰∏™ËøêË°åÁöÑÂºïÂØºÁ®ãÂ∫èË£ÖÂÖ•Âà∞ÂÜÖÂ≠ò0x7c00-0x7dff„ÄÇÊàë‰∏çÁü•ÈÅìÁé∞‰ª£Êìç‰ΩúÁ≥ªÁªüÊòØ‰∏çÊòØËøôÔºå‰ΩÜÊòØËøô‰∏™Á≥ªÁªüÊòØÁöÑ„ÄÇËøô‰∏™ÂºïÂØºÁ≥ªÁªü‰∏ªË¶ÅÂ∞±Âπ≤‰∫Ü‰∏§‰ª∂‰∫ãÔºö ÂÆûÊ®°ÂºèËΩ¨Êç¢Êàê‰øùÊä§Ê®°ÂºèÔºåÂå∫Âà´ÁôæÂ∫¶‰∏Ä‰∏ãÊúâËÆ≤Ëß£ÁöÑÔºåÂè¶Â§ñÂèëÁé∞‰∫ÜÂè¶‰∏Ä‰∏™Êìç‰ΩúÁ≥ªÁªüÂ≠¶‰π†ËµÑÊ∫ê,Â•ΩÂÉèÊñáÊ°£ËøòÊå∫ÈΩêÂÖ®ÁöÑ„ÄÇ ÂºïÂØºÂä†ËΩΩÁ®ãÂ∫èÈÄöËøáx86ÁöÑÁâπÊÆäI / OÊåá‰ª§Áõ¥Êé•ËÆøÈóÆIDEÁ£ÅÁõòËÆæÂ§áÂØÑÂ≠òÂô®Ôºå‰ªéËÄå‰ªéÁ°¨ÁõòËØªÂèñÂÜÖÊ†∏„ÄÇ ÂêéÈù¢‰ºöËÆ©‰Ω†ÂéªÁúãÊ∫êÁ†ÅÔºåÁü•ÈÅìÊÄé‰πàËøêË°åÁöÑBoot LoaderÔºåËøô‰∏™ÂêÑ‰ΩçÂ∞±Ëá™Â∑±ÁøªÁøªÂçöÂÆ¢ÂêßÔºåÊàëÂ∞±‰∏çÁªÜËÆ≤‰∫ÜÔºåË¥¥‰∏™Ëá™Â∑±ÁöÑÂ§ßËá¥‰ªãÁªç„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;inc/mmu.h&gt;# Start the CPU: switch to 32-bit protected mode, jump into C.# The BIOS loads this code from the first sector of the hard disk into# memory at physical address 0x7c00 and starts executing in real mode# with %cs=0 %ip=7c00..set PROT_MODE_CSEG, 0x8 # kernel code segment selector.set PROT_MODE_DSEG, 0x10 # kernel data segment selector.set CR0_PE_ON, 0x1 # protected mode enable flag.globl startstart: # ÂºÄÂßãÁ®ãÂ∫èÈ¶ñÂÖàÂÖ≥‰∫Ü‰∏≠Êñ≠ÔºåÂíå‰∏≤Â§ÑÁêÜÊìç‰ΩúÁöÑÁßªÂä®ÊåáÈíà(Ëøô‰∏™ÊöÇÊó∂‰∏çÁî®ÁÆ°) .code16 # Assemble for 16-bit mode cli # Disable interrupts cld # String operations increment#ÂàùÂßãÂåñ Êï∞ÊçÆÊÆµ Êâ©Â±ïÊÆµ Âíå Ê†à ÁöÑÊÆµÂØÑÂ≠òÂô® Áî®‰∫é‰øùÊä§Ê®°Âºè # Set up the important data segment registers (DS, ES, SS). xorw %ax,%ax # Segment number zero movw %ax,%ds # -&gt; Data Segment movw %ax,%es # -&gt; Extra Segment movw %ax,%ss # -&gt; Stack Segment # Enable A20: # For backwards compatibility with the earliest PCs, physical # address line 20 is tied low, so that addresses higher than # 1MB wrap around to zero by default. This code undoes this.seta20.1: #ÂºÄÂêØA20‰∏∫‰∫ÜÂÖºÂÆπ ‰ΩéÁâàÊú¨ÁöÑ Â§ÑÁêÜÂô® inb $0x64,%al # Wait for not busy testb $0x2,%al jnz seta20.1 movb $0xd1,%al # 0xd1 -&gt; port 0x64 outb %al,$0x64seta20.2: inb $0x64,%al # Wait for not busy testb $0x2,%al jnz seta20.2 movb $0xdf,%al # 0xdf -&gt; port 0x60 outb %al,$0x60 # Switch from real to protected mode, using a bootstrap GDT # and segment translation that makes virtual addresses # identical to their physical addresses, so that the # effective memory map does not change during the switch. lgdt gdtdesc # Â≠òÊîæ GDTË°®‰ø°ÊÅØ movl %cr0, %eax # Áî®ÊàñÊìç‰Ωú ÊääÊúÄÂêé‰∏Ä‰ΩçÁΩÆ1 ÂºÄÂêØ‰øùÊä§Ê®°Âºè orl $CR0_PE_ON, %eax movl %eax, %cr0 # Jump to next instruction, but in 32-bit code segment. # Switches processor into 32-bit mode. ljmp $PROT_MODE_CSEG, $protcseg # Ëøô‰∏™Êó∂ÂÄôË∑≥Âà∞‰∫Ü 32Ê®°Âºè‰∏ã‰∫Ü .code32 # Assemble for 32-bit modeprotcseg: # Ëøô‰∏™‰øÆÊîπ‰∏Ä‰∫õÂØÑÂ≠òÂô®ÁöÑÂÄºÔºåÂÖ∑‰ΩìÂÅö‰∫ÜÂï•‰πü‰∏çÊ∏ÖÊ•ö Â∫îËØ•ÊòØËßÑÂÆöÁöÑ‰∏Ä‰∫õÊìç‰Ωú # Set up the protected-mode data segment registers movw $PROT_MODE_DSEG, %ax # Our data segment selector movw %ax, %ds # -&gt; DS: Data Segment movw %ax, %es # -&gt; ES: Extra Segment movw %ax, %fs # -&gt; FS movw %ax, %gs # -&gt; GS movw %ax, %ss # -&gt; SS: Stack Segment # ÁÆÄÂçïÊù•ËÆ≤ ‰∏äÈù¢ Â∞±ÊòØÂàùÂßãÂåñ‰∫Ü‰∏Ä‰∫õÂØÑÂ≠òÂô®ÔºåÁÑ∂ÂêéÂ∞±Âéª boot main ÈáåÈù¢‰∫Ü # Set up the stack pointer and call into C. movl $start, %esp call bootmain # If bootmain returns (it shouldn't), loop.spin: # Ëøô‰∏™ÁøªËØë‰∏äÈù¢Ëã±ÊñáÂ∞±Â•Ω jmp spin# Bootstrap GDT.p2align 2 # force 4 byte alignmentgdt: # GDT Ë°®‰ø°ÊÅØÔºåÂÖ∑‰ΩìÁöÑ‰∏çÊ∏ÖÊ•ö SEG_NULL # null seg SEG(STA_X|STA_R, 0x0, 0xffffffff) # code seg SEG(STA_W, 0x0, 0xffffffff) # data seggdtdesc: .word 0x17 # sizeof(gdt) - 1 .long gdt # address gdt Áî±‰∏äÈù¢ËøôÊ≥®ÈáäÔºåÂ∫îËØ•ÂæàÂÆπÊòìÂæóÂá∫‰ªñÈóÆÁöÑÈóÆÈ¢òÁöÑÁ≠îÊ°à„ÄÇ ÂêéÈù¢Êúâ‰∏Ä‰∏™ËÆ©‰Ω†ËøêË°å‰∏Ä‰∏™CËØ≠Ë®ÄÊåáÈíàÁ®ãÂ∫èÔºåÈÇ£‰∏™ÊúâÁÇπÂü∫Á°ÄÂ∫îËØ•Â∞±ÁúãÂæóÊáÇ„ÄÇÂ∞±‰∏çÂ§öËØ¥‰∫Ü„ÄÇ main.cÈáåÈù¢Ôºå‰∏ªË¶ÅÊòØÂä†ËΩΩELFÊñá‰ª∂Ôºå‰πüÂ∞±ÊòØ‰Ω†ÁöÑÊìç‰ΩúÁ≥ªÁªüÔºå‰ªÄ‰πàÊòØELFÔºåËøô‰∏™ÂèØ‰ª•Âú®ÁôæÂ∫¶ÁôæÁßëÈáåÈù¢‰∫ÜËß£Âà∞„ÄÇ boot main.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;inc/x86.h&gt;#include &lt;inc/elf.h&gt;/********************************************************************** * This a dirt simple boot loader, whose sole job is to boot * an ELF kernel image from the first IDE hard disk. * * DISK LAYOUT * * This program(boot.S and main.c) is the bootloader. It should * be stored in the first sector of the disk. * * * The 2nd sector onward holds the kernel image. * * * The kernel image must be in ELF format. * * BOOT UP STEPS * * when the CPU boots it loads the BIOS into memory and executes it * * * the BIOS intializes devices, sets of the interrupt routines, and * reads the first sector of the boot device(e.g., hard-drive) * into memory and jumps to it. * * * Assuming this boot loader is stored in the first sector of the * hard-drive, this code takes over... * * * control starts in boot.S -- which sets up protected mode, * and a stack so C code then run, then calls bootmain() * * * bootmain() in this file takes over, reads in the kernel and jumps to it. **********************************************************************/#define SECTSIZE 512#define ELFHDR ((struct Elf *) 0x10000) // scratch spacevoid readsect(void*, uint32_t);void readseg(uint32_t, uint32_t, uint32_t);voidbootmain(void)&#123; struct Proghdr *ph, *eph; // read 1st page off disk ÊääÂÜÖÊ†∏ÁöÑËµ∑ÂßãÂú∞ÂùÄÁ¨¨‰∏Ä‰∏™È°µÂä†ËΩΩÂà∞ÂÜÖÂ≠ò,ELFHDRÂ§Ñ ‰∏ÄÈ°µ‰∏∫ 512*8=4M readseg((uint32_t) ELFHDR, SECTSIZE*8, 0);//‰∏ÄËà¨ÊòØÊìç‰ΩúÁ≥ªÁªüÊò†Ë±°Êñá‰ª∂ÁöÑelf Â§¥ÈÉ® // is this a valid ELF? ÊòØ‰∏Ä‰∏™ELFÊñá‰ª∂ Â∞±ÁªßÁª≠Âê¶‰æßÂ§±Ë¥• if (ELFHDR-&gt;e_magic != ELF_MAGIC) goto bad; //Âä†ËΩΩ Á®ãÂ∫èË°®Â§¥Âà∞ ph // load each program segment (ignores ph flags) ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR-&gt;e_phoff); eph = ph + ELFHDR-&gt;e_phnum;//Ëøô‰∏™ÊòØ Ë°®Êú™ e_phnum Â≠òÁöÑÊòØË°®È°π‰∏™Êï∞ for (; ph &lt; eph; ph++) //Ëøô‰∏™Â∞±ÊòØÊääË°®ÈáåÈù¢ÁöÑÈÉΩÂä†ËΩΩÂà∞ÂÜÖÂ≠ò // p_pa is the load address of this segment (as well // as the physical address) readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset); // call the entry point from the ELF header // note: does not return! ((void (*)(void)) (ELFHDR-&gt;e_entry))();//e_entry ÊòØÁ®ãÂ∫èËøêË°åÁöÑÂÖ•Âè£ ‰πüÂ∞±ÊòØÂú®Ëøô‰∏™Êó∂ÂÄô Êìç‰ΩúÁ≥ªÁªüÂºÄÂßãÂä†ËΩΩ‰∫Übad: //ÂÖ∑‰ΩìÂπ≤Âï•ÁöÑ Êàë‰∏çÁü•ÈÅì Â¶ÇÊûúÊ≤°ÁåúÈîô Â∞±ÊòØÊâßË°å Ê≤°ÊúâÂä†ËΩΩÂà∞Á≥ªÁªüÁöÑÊìç‰ΩúÔºå outw(0x8A00, 0x8A00); outw(0x8A00, 0x8E00); while (1) /* do nothing */;&#125;// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.// Might copy more than asked // È°æÂêçÊÄù‰πâ ÔºåÂ∞±ÊòØÂä†ËΩΩ ÂÅèÁßªÈáè‰∏∫ offset ÁöÑ ËøûÁª≠ count ‰∏™Â≠óËäÇ Âà∞Âú∞ÂùÄ pavoidreadseg(uint32_t pa, uint32_t count, uint32_t offset)&#123; uint32_t end_pa; end_pa = pa + count; // round down to sector boundary pa &amp;= ~(SECTSIZE - 1); // translate from bytes to sectors, and kernel starts at sector 1 offset = (offset / SECTSIZE) + 1; // If this is too slow, we could read lots of sectors at a time. // We'd write more to memory than asked, but it doesn't matter -- // we load in increasing order. while (pa &lt; end_pa) &#123; // Since we haven't enabled paging yet and we're using // an identity segment mapping (see boot.S), we can // use physical addresses directly. This won't be the // case once JOS enables the MMU. readsect((uint8_t*) pa, offset); pa += SECTSIZE; offset++; &#125;&#125;voidwaitdisk(void)&#123; // Âà§Á£ÅÁõòÊòØ‰∏çÊòØÂáÜÂ§á Â•Ω‰∫Ü // wait for disk reaady while ((inb(0x1F7) &amp; 0xC0) != 0x40) /* do nothing */;&#125;voidreadsect(void *dst, uint32_t offset)&#123; // wait for disk to be ready waitdisk(); outb(0x1F2, 1); // count = 1 outb(0x1F3, offset); outb(0x1F4, offset &gt;&gt; 8); outb(0x1F5, offset &gt;&gt; 16); outb(0x1F6, (offset &gt;&gt; 24) | 0xE0); outb(0x1F7, 0x20); // cmd 0x20 - read sectors // wait for disk to be ready waitdisk(); // read a sector ËØª‰∏Ä‰∏™ÊâáÂå∫ insl(0x1F0, dst, SECTSIZE/4);&#125; ÂêéÈù¢Âá†Ê≠•ËøòÊòØË¶ÅËá™Â∑±Â•ΩÂ•ΩÂùê‰∏ÄÂùêÔºåÊàëÊ≤°ÊúâÂÅö‰ªÄ‰πàËØ¶ÁªÜÁöÑ‰ªãÁªç„ÄÇ‰∏ÄÂ¶ÇÊó¢ÂæÄÂ§ß‰Ω¨ÂçöÂÆ¢,ÂÉèÊàëËøôÊ†∑ÁöÑËèúÈ∏°ÊòØÊó†Ê≥ïÁêÜËß£ÁöÑ„ÄÇ ÊúÄÂêéËÆ©‰Ω†ÂÅö‰∏™ÊµãËØïÔºåËøêË°åBoot Loader ÂâçÁúã‰∏ã0x00100000Â§ÑÁöÑ8‰∏™ÂÜÖÂ≠òÂ≠óÔºåËøêË°åÂêéÂÜçÁúã‰∏Ä‰∏ã,ÂèëÁé∞ÂéüÊú¨ÊòØ ÂÖ®ÊòØ 0ÔºåÂêéÈù¢Â∞±Êúâ‰∫Ü‰∏ÄÂ§ßÂ†Ü‰π±‰∏ÉÂÖ´Á≥üÁöÑÂÄº„ÄÇËøô‰∏™‰∏çÊòØÂæàÊòéÊòæÂêóÔºåÁúãÊàë‰∏äÈù¢main.cÁöÑÊ≥®ÈáäÔºåÊòéÊòæÊúâ‰∏™ÂáΩÊï∞ÊääÁ°¨ÁõòÈáåÈù¢ÁöÑÂÄºËØªÂà∞‰∫ÜÂÜÖÂ≠ò„ÄÇ Part 3: The KernelÂêéÈù¢ÁöÑÂÆûÈ™åÔºåËøô‰∏™Â§ß‰Ω¨ÁöÑGitHubÂ∞±ÂÖ®ÈÉΩÊúâ‰∫Ü„ÄÇ ÊàëÂÅö‰∏™ÁÆÄÂçïÁöÑÁ¨îËÆ∞„ÄÇ1movl %eax, %cr0 ËøôÊù°ËØ≠Âè•ÂÆûÁé∞‰∫ÜÔºåÊò†Â∞ÑÔºåÂ∞ÜÈ´òÂú∞ÂùÄÊò†Â∞ÑÂà∞‰∫ÜÁâ©ÁêÜÂú∞ÂùÄÁöÑ‰ΩéÂú∞ÂùÄÔºåËøôÊòØÂõ†‰∏∫ËÆ°ÁÆóÊú∫Â∏åÊúõÊìç‰ΩúÁ≥ªÁªüÊòØËøêË°åÂú®È´òÂú∞ÂùÄÔºåÁî®Êà∑ËøêË°åÂú®‰ΩéÂú∞ÂùÄÔºåËØ¶ÁªÜÂÜÖÂÆπÔºå‰∏ã‰∏ÄÊ¨°ÂÆûÈ™å‰ºöËÆ≤Ê∏ÖÊ•ö„ÄÇ ÁªÉ‰π†8 ËÆ©‰Ω†ÂÆåÂñÑÈÇ£‰∏™printfÈáåÈù¢ÁöÑ%o‰πüÂ∞±ÊòØ8ËøõÂà∂ËæìÂá∫„ÄÇ Ëøô‰∏™ÂæàÂÆπÊòì‰∫ÜÔºåÊääÂâçÈù¢16ËøõÂà∂ËæìÂá∫Â§çÂà∂‰∏ÄÈÅçÂ∞±Ë°å‰∫ÜÔºå‰∏çÂÅöËØ¶ÁªÜ‰ªãÁªç‰∫Ü„ÄÇ ÁÑ∂Âêé‰Ω†ÈúÄË¶ÅÂõûÁ≠î4‰∏™ÈóÆÈ¢ò printf‰πãÈó¥ÁöÑÂÖ≥Á≥ª‰æùÊóßÊâæÂ§ß‰Ω¨ÁöÑÂçöÂÆ¢ 12345671 if (crt_pos &gt;= CRT_SIZE) &#123;2 int i;3 memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));4 for (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)5 crt_buf[i] = 0x0700 | ' ';6 crt_pos -= CRT_COLS;7 &#125; Ëß£ÈáäËøô‰∏™ÔºåÁúãËµ∑Êù•Â∞±ÊòØÂ¶ÇÊûúË∂ÖËøá‰∫Ü‰∏ÄÈ°µÔºåÂ∞±ÊääÊúÄÂâçÈù¢ÁöÑÈÇ£‰∏ÄË°åÂà†ÊéâÔºüÔºüÔºåÁÑ∂ÂêéÁªßÁª≠ËæìÂá∫‰∏ã‰∏ÄË°åÔºüÔºüÔºü‰∏çÁü•ÈÅìÁêÜËß£ÂØπÊ≤°„ÄÇ Ëøô‰∏™ÊòØ‰∏™ÈáçÁÇπ ÔºåËøô‰∏™ÂÆûÈ™åÂæàÂÆπÊòìÁúãÂá∫Êù•CËØ≠Ë®ÄÂéãÊ†àÁöÑÈ°∫Â∫èÊòØ‰ªéÂêéÂæÄÂâçÂéãÊ†à„ÄÇ Ëøô‰∏™‰∏çËØ¥‰∫ÜÔºåÂ∞±ÊòØÊåâÊ†ºÂºèËæìÂá∫ Ëøô‰∏™Â∞±ÊòØÔºåÊàë‰ª¨ÁªèÂ∏∏Áî®ÁöÑprintfÔºåÂ¶ÇÊûúÂ∞ë‰∫Ü‰∏Ä‰∏™ÂèÇÊï∞‰ºöÂíãÊ†∑ÔºåÈÄöËøáÁúãÂÜÖÂ≠òÂ∫îËØ•Â∞±Áü•ÈÅìÔºå‰ºöËæìÂá∫‰∏Ä‰∏™ÈöèÊú∫ÂÄº„ÄÇÂ§ö‰∏Ä‰∏™Â§öÁöÑÂÖ∂ÂÆûÂ∞±Ê≤°Âï•Áî®„ÄÇ Ëøô‰∏™Â∞±ÊòØÂéãÊ†àÊòØ‰ªéÂêéÂæÄÂâçÂéãÔºåÊâÄ‰ª•ÂèØ‰ª•ÂÆûÁé∞ÔºåÂ§ö‰∏™ÂèÇÊï∞„ÄÇÂ¶ÇÊûúÊòØ‰ªéÂâçÂæÄÂêéÂéãËØ•ÊÄé‰πàÂäûÔºüÊàëËøò‰∏çÁü•ÈÅìÊÄé‰πàÂ§ÑÁêÜ„ÄÇ ÁªÉ‰π†9 ÈóÆÂï•Êó∂ÂÄôÂàùÂßãÂåñÂ†ÜÊ†àÔºåËøô‰∏™ÁúãÁúãÂ§ß‰Ω¨ÁöÑÂçöÂÆ¢Â∞±Ë°å.ÁªÉ‰π†10 Ëøô‰∏™Â∞±ÊòØËÆ©‰Ω†ÊòéÁôΩÊòØÊÄé‰πàË∞ÉÁî®ÂáΩÊï∞ÁöÑÔºåÂèàÊòØÊÄé‰πàËøîÂõûÁöÑ„ÄÇ ‰∏ÄËà¨Êù•ËØ¥ÔºåÊ†àÂü∫Âú∞ÂùÄÊåáÂêëÁöÑÊòØÊ†àÂ∫ïÔºåÊ†àÊåáÈíàÊåáÂêëÁöÑÊòØÊ†àÈ°∂„ÄÇÂ§ßÊ¶ÇË∞ÉÁî®‰∏Ä‰∏™ÂáΩÊï∞Â∞±ÊòØËøô‰πàÂπ≤ÁöÑÔºåÊÄé‰πàËøîÂõûÁöÑÂ∞±‰∏çÁî®ÊàëËØ¥‰∫ÜÂêß„ÄÇË∞ÉÁî®ÂèÇÊï∞‰πüÂ∞±ÊòØÈÄöËøáÊ†àÊù•ÁöÑÔºåÂ¶ÇÊûúË∂ÖËøá‰∫Ü‰∫î‰∏™ÂèÇÊï∞Êàë‰πü‰∏çÁü•ÈÅì‰ºöÂèëÁîüÂï•ÔºåÂèçÊ≠£Ëøô‰∏äÈù¢Ê≤°ËØ¥„ÄÇÁªÉ‰π† 11 ‰πüÂ∞±ÊòØËÆ©‰Ω†ÂÜô‰∏™ËæìÂá∫Ê†àÈáåÈù¢ÁöÑÂÜÖÂÆπ„ÄÇ ÁªÉ‰π† 12 ËÆ©‰Ω†ÂÆûÁé∞‰∏Ä‰∏™Ë∞ÉËØï‰ø°ÊÅØÁöÑÊåá‰ª§„ÄÇÊîπ‰∏â‰∏™Âú∞Êñπ„ÄÇÂâç‰∏§‰∏™ÈÉΩÂú®kern/monitor.c„ÄÇÁ¨¨‰∏Ä‰∏™12345static struct Command commands[] = &#123; &#123; "help", "Display this list of commands", mon_help &#125;, &#123; "kerninfo", "Display information about the kernel", mon_kerninfo &#125;, &#123;"backtrace","Display stack backtrace", mon_backtrace&#125;, &#125;; ÂêéÈù¢ÈÇ£‰∏™ÊòØÂ§öÂä†ÁöÑÔºåÂâçÈù¢ÈÇ£‰∏§‰∏™ÂæàÁúºÁÜüÂêß„ÄÇ1234567891011121314151617181920intmon_backtrace(int argc, char **argv, struct Trapframe *tf)&#123; // Your code here. // return 0; uint32_t ebp,eip,*p; struct Eipdebuginfo info; ebp=read_ebp(); while(ebp!=0)&#123; p=(uint32_t*)ebp; eip=p[1]; cprintf("ebp %x eip %x args %08x %08x %08x %08x %08x\n",ebp,p[1],p[2],p[3],p[4],p[5],p[6]); if(debuginfo_eip(eip,&amp;info)==0)&#123; int fn_offset=eip-info.eip_fn_addr; cprintf("%s:%d:%.*s+%d\n",info.eip_file,info.eip_line,info.eip_fn_namelen,info.eip_fn_name,fn_offset); &#125; ebp=p[0]; &#125; return 0;&#125; Ëøô‰∏™‰πüÂæàÁúºÁÜüÂêßÔºåÂâçÈù¢ÊîπËøá„ÄÇÂà∞Ëøô‰∏™Âú∞ÊñπÂÆûÈôÖ‰∏äÂ∑≤ÁªèËÉΩÂ§üËøêË°å‰∫ÜÔºåÂè™ÊòØÊ≤°ÊúâË°åÂè∑„ÄÇ ÊúÄÂêé‰∏Ä‰∏™Âú®kern/kdebug.c123456stab_binsearch(stabs, &amp;lfun, &amp;rfun, N_SLINE, addr - info-&gt;eip_fn_add r); if (lfun &lt;= rfun)&#123; info-&gt;eip_line = stabs[lfun].n_desc;&#125; Ëøô‰∏™ÂÖ∑‰ΩìÂéüÁêÜÊàë‰πü‰∏çÁü•ÈÅìÔºåÊäÑÂà´‰∫∫ÁöÑ„ÄÇÁôæÂ∫¶ËÉΩÊêúÂà∞„ÄÇÂà∞Ê≠§ÔºåÂÆûÈ™å‰∏ÄÂ∞±ÂÖ®ÈÉ®ÂÆåÊàê‰∫ÜÔºåÁõÆÂâçÊàëËÉΩ‰∫ÜËß£ÁöÑÂ∞±Ëøô‰πàÂ§ö„ÄÇ]]></content>
      <categories>
        <category>Êìç‰ΩúÁ≥ªÁªü</category>
        <category>MIT6.828</category>
      </categories>
      <tags>
        <tag>MIT6.828</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[manjaro18 xfceÁâà ÁªàÁ´ØÂ≠ó‰ΩìÈó¥Ë∑ùË¥ºÂ§ß]]></title>
    <url>%2F2020%2F02%2F18%2Fmanjaro18-xfce%E7%89%88-%E7%BB%88%E7%AB%AF%E5%AD%97%E4%BD%93%E9%97%B4%E8%B7%9D%E8%B4%BC%E5%A4%A7%2F</url>
    <content type="text"><![CDATA[manjaro18 xfceÁâà ÁªàÁ´ØÂ≠ó‰ΩìÈó¥Ë∑ùË¥ºÂ§ß 12sudo pacman -S wqy-bitmapfontsudo pacman -S wqy-zenhei]]></content>
      <categories>
        <category>ÈÖçÁΩÆ</category>
      </categories>
      <tags>
        <tag>ÈÖçÁΩÆ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT-6.828(Èõ∂)ÊèêÂâçÂÅöÂ•ΩÈÄÅ‰∫∫Â§¥ÂáÜÂ§áÈöèÊó∂Ë∑ëË∑Ø]]></title>
    <url>%2F2020%2F02%2F17%2FMIT-6.828(%E9%9B%B6)%E6%8F%90%E5%89%8D%E5%81%9A%E5%A5%BD%E9%80%81%E4%BA%BA%E5%A4%B4%E5%87%86%E5%A4%87%E9%9A%8F%E6%97%B6%E8%B7%91%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[Ë¢´Êüê‰∏™Â§ß‰Ω¨Â∏¶ÂÖ•ÂùëÔºåÁúãÁúã‰∫ÜËØÑ‰ª∑Â•ΩÂÉèÁ°ÆÂÆû‰∏çÈîôÔºåÊâÄ‰ª•Â∞±ÂºÄÂßãÂπ≤‰∫Ü„ÄÇÈ¶ñÂÖàÁ¨¨‰∏Ä‰ª∂‰∫ãÂ∞±ÊòØÊêúÁ¥¢ËµÑÊ∫êÔºåÂÉèÊàëËøô‰πàËèúÁöÑÔºåË¶ÅÊòØÊ≤°‰∫∫ÂëäËØâÊàëÊÄé‰πàÂÅöÔºåÂü∫Êú¨‰∏äÊòØÊ≤°Âï•Â∏åÊúõÁöÑ„ÄÇ ËµÑÊ∫êÁ¨¨‰∏Ä‰∏™ËÇØÂÆöÂ∞±ÊòØÂÆòÊñπÁöÑ‰∫ÜÔºåÂè¶Â§ñËøòÊúâÔºå2019ÁöÑ. ÁÑ∂ÂêéÂ∞±ÊòØ‰∏Ä‰∫õÊØîËæÉÂ•ΩÁöÑÂ§ß‰Ω¨ÁöÑËµÑÊ∫ê„ÄÇÁü•‰πéË∂ÖÁ∫ßËØ¶ÁªÜÁöÑÊüê‰∏™Â§ß‰Ω¨2014 Â§ß‰Ω¨githubËøô‰∏™‰πüÊòØÊúâ‰∫õÂ∫îËØ•Â§üÁî®‰∫ÜÔºå‰πüËÆ∏Â§ü‰∫ÜÔºåÂóØÔºå‰πüËÆ∏Â§ü‰∫ÜÔºåÂõ†‰∏∫Êàë‰πüÂè™ÊòØÂàöÂºÄÂßã„ÄÇ„ÄÇ ËôöÊãüÊú∫Â¶ÇÊûúÂÅöÁöÑ‰∫ã 2018Âπ¥‰πãÂâçÁöÑ Èöè‰æøÁî®Âï•Á≥ªÁªü ÔºåÂ¶ÇÊûú‰∫ã 2019 ÁöÑÂª∫ËÆÆ Áî®manjaro „ÄÇ Â¶ÇÊûúÁî®ÁöÑËôöÊãüÊú∫Ê≥®ÊÑè‰∏ãÔºåÂÜÖÂ≠òË¶ÅÂ§ß‰∫é 4G ÔºåÂ¶ÇÊûúÂ∞è‰∫ÜÁöÑËØùÔºåËøô‰∏™ÂÜÖÊ†∏ÊòØËøêË°å‰∏ç‰∫ÜÁöÑ ÁéØÂ¢ÉÊê≠Âª∫ÂÆâË£ÖÁéØÂ¢ÉÔºåËøôÊñáÁ´†Á°ÆÂÆûÂ§üÁî®‰∫Ü ÁÑ∂ÂêéÁ•ù‰Ω†Â•ΩËøê„ÄÇ„ÄÇ„ÄÇ]]></content>
      <categories>
        <category>Êìç‰ΩúÁ≥ªÁªü</category>
        <category>MIT6.828</category>
      </categories>
      <tags>
        <tag>MIT6.828</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux0.11-sched.h„ÄÅsched.cÂÜÖÊ†∏Ê∫êÁ†ÅÂàÜÊûê]]></title>
    <url>%2F2019%2F12%2F12%2Flinux0.11-sched.h%E3%80%81sched.c%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ËøôÁØáÊñáÁ´† Âè™ÊòØÂ≠¶‰π†Á¨îËÆ∞ÔºåÂ¶ÇÊúâÈîôËØØÊàñÁñëÈóÆÔºåÊ¨¢ËøéÊåáÂá∫„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332#ifndef _SCHED_H#define _SCHED_H#define NR_TASKS 64 //Á≥ªÁªüÊúÄÂ§öÁöÑËøõÁ®ãÊï∞#define HZ 100 // Á≥ªÁªüÊó∂ÈíüÈ¢ëÁéá 100HZ#define FIRST_TASK task[0] //‰ªªÂä°0ÊòØ ÊØîËæÉÁâπÊÆä init()#define LAST_TASK task[NR_TASKS-1] //‰ªªÂä°Êï∞ÁªÑÈáåÈù¢ÊúÄÂêé‰∏Ä‰∏™#include &lt;linux/head.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/mm.h&gt;#include &lt;signal.h&gt;#if (NR_OPEN &gt; 32)#error "Currently the close-on-exec-flags are in one word, max 32 files/proc"#endif//ÂâçÈù¢ËØ¥ËøáÁöÑ Âá†ÁßçÁä∂ÊÄÅ ÂΩìÂâçÁâàÊú¨Âè™ÊúâËøô‰πàÂá†‰∏™#define TASK_RUNNING 0#define TASK_INTERRUPTIBLE 1#define TASK_UNINTERRUPTIBLE 2#define TASK_ZOMBIE 3#define TASK_STOPPED 4#ifndef NULL#define NULL ((void *) 0)#endif// Âá†‰∏™ÂÖ∑‰ΩìÁöÑÂáΩÊï∞ ÂêéÈù¢‰ºöÂú®sched.c ÈáåÈù¢‰ºöËÆ≤ÂÆûÁé∞// Â§çÂà∂ ËøõÁ®ã ÁõÆÂΩïÈ°µË°®extern int copy_page_tables(unsigned long from, unsigned long to, long size);//ÈáäÊîæÈ°µË°®ÊâÄÊåáÂÆöÁöÑ ÂÜÖÂ≠ò ÂíåÈ°µË°®Êú¨Ë∫´extern int free_page_tables(unsigned long from, unsigned long size);//ÂàùÂßãÂåñË∞ÉÂ∫¶extern void sched_init(void);//Ë∞ÉÂ∫¶Á®ãÂ∫èextern void schedule(void);//ÂºÇÂ∏∏‰∏≠Êñ≠Â§ÑÁêÜ ÔºåËÆæÁΩÆ‰∏≠Êñ≠Ë∞ÉÁî®Èó®ÔºåÂπ∂ÂºÄÂêØ‰∏≠Êñ≠extern void trap_init(void);//ÊòæÁ§∫Âá∫Èîô‰ø°ÊÅØÔºåÁÑ∂ÂêéÊ≠ªÂæ™ÁéØextern void panic(const char * str);//Âú® tty ‰∏äÊòæÁ§∫Âà∂ÂÆöÈïøÂ∫¶‰ø°ÊÅØextern int tty_write(unsigned minor,char * buf,int count);// ÂÆö‰πâ‰∏Ä‰∏™ÂáΩÊï∞ÊåáÈíàÁ±ªÂûãtypedef int (*fn_ptr)();//Ëøô‰∏™ÊöÇÊó∂‰∏çÁî®ÁÆ° ÊòØÊï∞Â≠¶Â§ÑÁêÜÂô®‰ΩøÁî®ÁöÑÁªìÊûÑÔºåÊàë‰πü‰∏çÁü•ÈÅìÂÖ∑‰ΩìÊòØÂπ≤Âï•ÁöÑstruct i387_struct &#123; long cwd; long swd; long twd; long fip; long fcs; long foo; long fos; long st_space[20]; /* 8*10 bytes for each FP-reg = 80 bytes */&#125;;// ‰ªªÂä°Áä∂ÊÄÅÊÆµÊï∞ÊçÆÁªìÊûÑ ‰πü‰∏çÁü•ÈÅìÂπ≤Âï•ÁöÑstruct tss_struct &#123; long back_link; /* 16 high bits zero */ long esp0; long ss0; /* 16 high bits zero */ long esp1; long ss1; /* 16 high bits zero */ long esp2; long ss2; /* 16 high bits zero */ long cr3; long eip; long eflags; long eax,ecx,edx,ebx; long esp; long ebp; long esi; long edi; long es; /* 16 high bits zero */ long cs; /* 16 high bits zero */ long ss; /* 16 high bits zero */ long ds; /* 16 high bits zero */ long fs; /* 16 high bits zero */ long gs; /* 16 high bits zero */ long ldt; /* 16 high bits zero */ long trace_bitmap; /* bits: trace 0, bitmap 16-31 */ struct i387_struct i387;&#125;;//1ong 1eader‰ºöËØùÈ¶ñÈ¢Ü„ÄÇ//long start_timeËøõÁ®ãÂºÄÂßãËøêË°åÊó∂Âàª„ÄÇ//unsigned short used_math Ê†áÂøóÔºöÊòØÂê¶‰ΩøÁî®‰∫ÜÂçèÂ§ÑÁêÜÂô®„ÄÇ//int ttyËøõÁ®ã‰ΩøÁî®ttyÁöÑÂ≠êËÆæÂ§áÂè∑„ÄÇ-1Ë°®Á§∫Ê≤°Êúâ‰ΩøÁî®„ÄÇ//unsigned short umaskÊñá‰ª∂ÂàõÂª∫Â±ûÊÄßÂ±èËîΩ‰Ωç„ÄÇ//struct minode*pwd ÂΩìÂâçÂ∑•‰ΩúÁõÆÂΩïiËäÇÁÇπÁªìÊûÑ„ÄÇ//struct m inode*root Ê†πÁõÆÂΩïiËäÇÁÇπÁªìÊûÑ„ÄÇ//struct m inode*executableÊâßË°åÊñá‰ª∂iËäÇÁÇπÁªìÊûÑ„ÄÇ//unsigned 1ong close_on_execÊâßË°åÊó∂ÂÖ≥Èó≠Êñá‰ª∂Âè•ÊüÑ‰ΩçÂõæÊ†áÂøó„ÄÇÔºàÂèÇËßÅinclude/fcntl.hÔºâ//struct file*filp[NR_OPEN]ËøõÁ®ã‰ΩøÁî®ÁöÑÊñá‰ª∂Ë°®ÁªìÊûÑ„ÄÇ//struct desc_struct 1dt[3]Êú¨‰ªªÂä°ÁöÑÂ±ÄÈÉ®Ë°®ÊèèËø∞Á¨¶„ÄÇ0-Á©∫Ôºå1-‰ª£Á†ÅÊÆµcsÔºå2-Êï∞ÊçÆÂíåÂ†ÜÊ†àÊÆµds&amp;ss„ÄÇ// ÈáçÂ§¥ÊàèÔºå‰πüÂ∞±ÊòØÊàë‰ª¨ËØ¥ÁöÑ PCBstruct task_struct &#123;/* these are hardcoded - don't touch */ long state; /* -1 unrunnable, 0 runnable, &gt;0 stopped */ long counter; long priority; long signal; //‰ø°Âè∑ÊâßË°åÂ±ûÊÄßÁªìÊûÑÔºåÂØπÂ∫î‰ø°Âè∑Â∞ÜË¶ÅÊâßË°åÁöÑÊìç‰Ωú struct sigaction sigaction[32]; // ËøõÁ®ã‰ø°Âè∑Â±èËîΩÁ†ÅÔºåËÆ°ÁÆóÊú∫ÁªÑÊàêÂéüÁêÜ‰∏äÈù¢ ÊúâËØ¶ÁªÜËß£Èáä long blocked; /* bitmap of masked signals *//* various fields */ // ‰ªªÂä°ÊâßË°åÈÄÄÂá∫Á†ÅÔºåÁªôÁà∂ËøõÁ®ãÁî®ÁöÑ int exit_code; //‰ª£Á†ÅÊÆµ‰ø°ÊÅØ ÂºÄÂßã ÁªìÊùü Êï∞ÊçÆÊÆµ‰ø°ÊÅØ ÊÄªÈïøÂ∫¶ Â†ÜÊ†àÂú∞ÂùÄ unsigned long start_code,end_code,end_data,brk,start_stack; // Ëá™Â∑± Áà∂‰∫≤ÔºàÊñ∞ÁâàÊú¨‰∏≠ ÊáÇ‰∫ãÁõ¥Êé•Áî® Áà∂‰∫≤ÊåáÈíà ÊåáÂêë‰ªñÁöÑPCBÔºâ ÁªÑÂè∑Ôºå‰ºöËØùÂè∑Ôºå‰ºöËØùÈ¶ñÈ¢Ü long pid,father,pgrp,session,leader; //unsigned short uid Áî®Êà∑Ê†áËØÜÂè∑ÔºàÁî®Êà∑idÔºâ„ÄÇ//euid ÊúâÊïàÁî®Êà∑id„ÄÇsuid ‰øùÂ≠òÁöÑÁî®Êà∑id„ÄÇ// gidÁªÑÊ†áËØÜÂè∑ÔºàÁªÑidÔºâegidÊúâÊïàÁªÑid„ÄÇsgid‰øùÂ≠òÁöÑÁªÑid„ÄÇ unsigned short uid,euid,suid; unsigned short gid,egid,sgid;//1ong alarmÊä•Ë≠¶ÂÆöÊó∂ÂÄºÔºàÊª¥Á≠îÊï∞Ôºâ„ÄÇ long alarm;//1ong utimeÁî®Êà∑ÊÄÅËøêË°åÊó∂Èó¥ÔºàÊª¥Á≠îÊï∞Ôºâ„ÄÇ//long stimeÁ≥ªÁªüÊÄÅËøêË°åÊó∂Èó¥ÔºàÊª¥Á≠îÊï∞Ôºâ„ÄÇ//1ong cutimeÂ≠êËøõÁ®ãÁî®Êà∑ÊÄÅËøêË°åÊó∂Èó¥„ÄÇ// 1ong cstimeÂ≠êËøõÁ®ãÁ≥ªÁªüÊÄÅËøêË°åÊó∂Èó¥„ÄÇ// start_time ÂºÄÂßãËøêË°åÊó∂Èó¥ long utime,stime,cutime,cstime,start_time; // ÊòØÂê¶‰ΩøÁî®‰∫ÜÂçèÂ§ÑÁêÜÂô® unsigned short used_math;/* file system info */// tty ËÆæÂ§á -1 Ë°®Á§∫Ê≤°ÊúâÁî® int tty; /* -1 if no tty, so it must be signed */ // Êñá‰ª∂Á©ø‰ª∂Â±ûÊÄßÂ±èËîΩ‰Ωç unsigned short umask; // ÂΩìÂâçÂ∑•‰ΩúÁõÆÂΩïi ËäÇÁÇπÁªìÊûÑ struct m_inode * pwd; // Êõ¥ÁõÆÂΩï i ËäÇÁÇπÁªìÊûÑ struct m_inode * root; // ÊâßË°åÊñá‰ª∂ i ËäÇÁÇπÁªìÊûÑ struct m_inode * executable; // ÂÖ≥Èó≠Êñá‰ª∂Âè•ÊüÑ‰Ωç ÂõæÊ†áÂøó unsigned long close_on_exec; // ËøõÁ®ã‰ΩøÁî®ÁöÑÊñá‰ª∂Ë°® ÁªìÊûÑ struct file * filp[NR_OPEN];/* ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss */// ‰ªªÂä°Â±ÄÈÉ®Ë°®ÊèèËø∞Á¨¶Ôºå 0 Á©∫ 1‰ª£Á†ÅÊÆµ 2 Êï∞ÊçÆÂíåÂ†ÜÊ†àÊÆµ ds &amp;ssstruct desc_struct ldt[3];/* tss for this task */ // Êú¨ËøõÁ®ãÁöÑ‰ªªÂä°Áä∂ÊÄÅ‰ø°ÊÅØÁªìÊûÑ struct tss_struct tss;&#125;;/* * INIT_TASK is used to set up the first task table, touch at * your own risk!. Base=0, limit=0x9ffff (=640kB) */// Ëøô‰∏™ Áî®‰∫é ËÆæÁΩÆÁ¨¨‰∏Ä‰∏™‰ªªÂä°Ë°® Âà´Âä®Â∞±Ë°å#define INIT_TASK \/* state etc */ &#123; 0,15,15, \/* signals */ 0,&#123;&#123;&#125;,&#125;,0, \/* ec,brk... */ 0,0,0,0,0,0, \/* pid etc.. */ 0,-1,0,0,0, \/* uid etc */ 0,0,0,0,0,0, \/* alarm */ 0,0,0,0,0,0, \/* math */ 0, \/* fs info */ -1,0022,NULL,NULL,NULL,0, \/* filp */ &#123;NULL,&#125;, \ &#123; \ &#123;0,0&#125;, \/* ldt */ &#123;0x9f,0xc0fa00&#125;, \ &#123;0x9f,0xc0f200&#125;, \ &#125;, \/*tss*/ &#123;0,PAGE_SIZE+(long)&amp;init_task,0x10,0,0,0,0,(long)&amp;pg_dir,\ 0,0,0,0,0,0,0,0, \ 0,0,0x17,0x17,0x17,0x17,0x17,0x17, \ _LDT(0),0x80000000, \ &#123;&#125; \ &#125;, \&#125;//‰ªªÂä°ÊåáÈíàÊï∞ÁªÑextern struct task_struct *task[NR_TASKS]; //‰∏ä‰∏Ä‰∏™‰ΩøÁî®Ëøá ÂçèÂ§ÑÁêÜÂô®ÁöÑËøõÁ®ãextern struct task_struct *last_task_used_math;//ÂΩìÂâçËøõÁ®ãextern struct task_struct *current;//ÂºÄÊú∫Êó∂ÂºÄÂßãÊäÄÊúØÊª¥Á≠îÊï∞ 10ms/Êª¥Á≠îextern long volatile jiffies;//ÂºÄÊú∫Êó∂Èó¥„ÄÇ‰ªé 1970:0:0:0 ÂºÄÂßãËÆ°Êó∂ Áßí‰∏∫Âçï‰Ωçextern long startup_time;//ÂΩìÂâçÊó∂Èó¥#define CURRENT_TIME (startup_time+jiffies/HZ)// Ê∑ªÂä†ÂÆöÊó∂Âô® Âà∞Êó∂Èó¥ÊâßË°åÂáΩÊï∞extern void add_timer(long jiffies, void (*fn)(void));// ‰∏çÂèØ‰∏≠Êñ≠ÁöÑÁ≠âÂæÖÁù°Áú†extern void sleep_on(struct task_struct ** p);// ÂèØ‰∏≠Êñ≠ÁöÑextern void interruptible_sleep_on(struct task_struct ** p);//Âî§ÈÜíÁ®ãÂ∫èextern void wake_up(struct task_struct ** p);/* * Entry into gdt where to find first TSS. 0-nul, 1-cs, 2-ds, 3-syscall * 4-TSS0, 5-LDT0, 6-TSS1 etc ... *///#define FIRST_TSS_ENTRY 4#define FIRST_LDT_ENTRY (FIRST_TSS_ENTRY+1)#define _TSS(n) ((((unsigned long) n)&lt;&lt;4)+(FIRST_TSS_ENTRY&lt;&lt;3))#define _LDT(n) ((((unsigned long) n)&lt;&lt;4)+(FIRST_LDT_ENTRY&lt;&lt;3))#define ltr(n) __asm__("ltr %%ax"::"a" (_TSS(n)))#define lldt(n) __asm__("lldt %%ax"::"a" (_LDT(n)))#define str(n) \__asm__("str %%ax\n\t" \ "subl %2,%%eax\n\t" \ "shrl $4,%%eax" \ :"=a" (n) \ :"a" (0),"i" (FIRST_TSS_ENTRY&lt;&lt;3))/* * switch_to(n) should switch tasks to task nr n, first * checking that n isn't the current task, in which case it does nothing. * This also clears the TS-flag if the task we switched to has used * tha math co-processor latest. *///ËøôÊòØ‰∏Ä‰∏™ÂæàÈáçË¶ÅÁöÑË∑≥ËΩ¨ ÔºåÁî®‰∫é‰∏ä‰∏ãÊñáÂàáÊç¢/*switch_toÔºànÔºâÂ∞ÜÂàáÊç¢ÂΩìÂâç‰ªªÂä°Âà∞‰ªªÂä°nrÔºåÂç≥n„ÄÇÈ¶ñÂÖàÊ£ÄÊµã‰ªªÂä°n‰∏çÊòØÂΩìÂâç‰ªªÂä°Ôºå*Â¶ÇÊûúÊòØÂàô‰ªÄ‰πà‰πü‰∏çÂÅöÈÄÄÂá∫„ÄÇÂ¶ÇÊûúÊàë‰ª¨ÂàáÊç¢Âà∞ÁöÑ‰ªªÂä°ÊúÄËøëÔºà‰∏äÊ¨°ËøêË°åÔºâ‰ΩøÁî®ËøáÊï∞Â≠¶ *ÂçèÂ§ÑÁêÜÂô®ÁöÑËØùÔºåÂàôËøòÈúÄÂ§ç‰ΩçÊéßÂà∂ÂØÑÂ≠òÂô®cr0‰∏≠ÁöÑTSÊ†áÂøó„ÄÇ*///Ë∑≥ËΩ¨Âà∞‰∏Ä‰∏™‰ªªÂä°ÁöÑTSSÊÆµÈÄâÊã©Á¨¶ÁªÑÊàêÁöÑÂú∞ÂùÄÂ§Ñ‰ºöÈÄ†ÊàêCPUËøõË°å‰ªªÂä°ÂàáÊç¢Êìç‰Ωú„ÄÇ//ËæìÂÖ•Ôºö%0-ÊåáÂêëtmpÔºõ%1-ÊåáÂêëtmp.bÂ§ÑÔºåÁî®‰∫éÂ≠òÊîæÊñ∞TSSÁöÑÈÄâÊã©Á¨¶Ôºõ//dx-Êñ∞‰ªªÂä°nÁöÑTSSÊÆµÈÄâÊã©Á¨¶Ôºõecx-Êñ∞‰ªªÂä°nÁöÑ‰ªªÂä°ÁªìÊûÑÊåáÈíàtask[n]„ÄÇ//ÂÖ∂‰∏≠‰∏¥Êó∂Êï∞ÊçÆÁªìÊûÑtmpÁî® Ë∑≥ËΩ¨ÔºàfarjumpÔºâÊåá‰ª§ÁöÑÊìç‰ΩúÊï∞„ÄÇËØ•Êìç‰ΩúÊï∞Áî±4Â≠óËäÇÂÅèÁßª//Âú∞ÂùÄÂíå2Â≠óËäÇÁöÑÊÆµÈÄâÊã©Á¨¶ÁªÑÊàê„ÄÇÂõ†Ê≠§tmp‰∏≠aÁöÑÂÄºÊòØ32‰ΩçÂÅèÁßªÂÄºÔºåËÄåbÁöÑ‰Ωé2Â≠óËäÇÊòØÊñ∞TSSÊÆµÁöÑ//ÈÄâÊã©Á¨¶ÔºàÈ´ò2Â≠óËäÇ‰∏çÁî®Ôºâ„ÄÇË∑≥ËΩ¨Âà∞TSSÊÆµÈÄâÊã©Á¨¶‰ºöÈÄ†Êàê‰ªªÂä°ÂàáÊç¢Âà∞ËØ•TSSÂØπÂ∫îÁöÑËøõÁ®ã„ÄÇÂØπ‰∫éÈÄ†Êàê‰ªªÂä°//ÂàáÊç¢ÁöÑÈïøË∑≥ËΩ¨ÔºåaÂÄºÊó†Áî®„ÄÇ177Ë°å‰∏äÁöÑÂÜÖÂ≠òÈó¥Êé•Ë∑≥ËΩ¨Êåá‰ª§‰ΩøÁî®6Â≠óËäÇÊìç‰ΩúÊï∞‰Ωú‰∏∫Ë∑≥ËΩ¨ÁõÆÁöÑÂú∞ÁöÑÈïøÊåáÈíàÔºå//ÂÖ∂Ê†ºÂºè‰∏∫Ôºöjmp16‰ΩçÊÆµÈÄâÊã©Á¨¶Ôºö32‰ΩçÂÅèÁßªÂÄº„ÄÇ‰ΩÜÂú®ÂÜÖÂ≠ò‰∏≠Êìç‰ΩúÊï∞ÁöÑË°®Á§∫È°∫Â∫è‰∏éËøôÈáåÊ≠£Â•ΩÁõ∏Âèç„ÄÇ//‰ªªÂä°ÂàáÊç¢ÂõûÊù•‰πãÂêéÔºåÂú®Âà§Êñ≠Âéü‰ªªÂä°‰∏äÊ¨°ÊâßË°åÊòØÂê¶‰ΩøÁî®ËøáÂçèÂ§ÑÁêÜÂô®Êó∂ÔºåÊòØÈÄöËøáÂ∞ÜÂéü‰ªªÂä°ÊåáÈíà‰∏é‰øùÂ≠òÂú®//last_task used mathÂèòÈáè‰∏≠ÁöÑ‰∏äÊ¨°‰ΩøÁî®ËøáÂçèÂ§ÑÁêÜÂô®‰ªªÂä°ÊåáÈíàËøõË°åÊØîËæÉËÄå‰ΩúÂá∫ÁöÑÔºåÂèÇËßÅÊñá‰ª∂//kernel/sched.c‰∏≠ÊúâÂÖ≥math state restoreÔºâÂáΩÊï∞ÁöÑËØ¥Êòé„ÄÇ#define switch_to(n) &#123;\struct &#123;long a,b;&#125; __tmp; \/* * __asm__("cmpl %%ecx,_current\n\t" \ ÊØîËæÉÊòØ‰∏çÊòØÂΩìÂâçËøêË°åÁöÑËøõÁ®ã "je 1f\n\t" \ ÊòØÁöÑËØùÂï•ÈÉΩ‰∏çÂÅö "movw %%dx,%1\n\t" \ Â∞ÜÊñ∞‰ªªÂä°TSS ÁöÑ16‰Ωç ÈÄâÊã©Á¨¶Â≠òÂÖ• __tmp.b‰∏≠ "xchgl %%ecx,_current\n\t" \ //current=task[n] ecx=Ë¢´Êç¢Âá∫ÁöÑ‰ªªÂä° "ljmp %0\n\t" \ Ë∑≥Âà∞ *&amp;__tmp,‰ªªÂä°ÂàáÊç¢ Ëøô‰∏™Êó∂ÂÄôÂ∑≤Áªè‰∏çÂú®ËøôÈáå‰∫ÜÂøÖÈ°ªË¶ÅÁ≠âÂà∞ÈÇ£‰∏™‰ªªÂä° ÊâßË°åÂÆåÂêé ÈáçÊñ∞ÂõûÂà∞ËøôÈáå "cmpl %%ecx,_last_task_used_math\n\t" \ //Âéü‰ªªÂä°‰ΩøÁî®ËøáÂçèÂ§ÑÁêÜÂô®Âêó "jne 1f\n\t" \ //Ê≤°ÊúâÂàôË∑≥ËΩ¨ ÈÄÄÂá∫ "clts\n" \ //‰ΩøÁî®ËøáÔºåÊ∏ÖÊ•öcr0‰ªªÂä°ÂàáÊç¢ "1:" \ //Ê†áÂøó TS ::"m" (*&amp;__tmp.a),"m" (*&amp;__tmp.b), \ "d" (_TSS(n)),"c" ((long) task[n])); \&#125; * */__asm__("cmpl %%ecx,_current\n\t" \ "je 1f\n\t" \ "movw %%dx,%1\n\t" \ "xchgl %%ecx,_current\n\t" \ "ljmp %0\n\t" \ "cmpl %%ecx,_last_task_used_math\n\t" \ "jne 1f\n\t" \ "clts\n" \ "1:" \ ::"m" (*&amp;__tmp.a),"m" (*&amp;__tmp.b), \ "d" (_TSS(n)),"c" ((long) task[n])); \&#125;#define PAGE_ALIGN(n) (((n)+0xfff)&amp;0xfffff000)#define _set_base(addr,base) \__asm__("movw %%dx,%0\n\t" \ "rorl $16,%%edx\n\t" \ "movb %%dl,%1\n\t" \ "movb %%dh,%2" \ ::"m" (*((addr)+2)), \ "m" (*((addr)+4)), \ "m" (*((addr)+7)), \ "d" (base) \ :"dx")#define _set_limit(addr,limit) \__asm__("movw %%dx,%0\n\t" \ "rorl $16,%%edx\n\t" \ "movb %1,%%dh\n\t" \ "andb $0xf0,%%dh\n\t" \ "orb %%dh,%%dl\n\t" \ "movb %%dl,%1" \ ::"m" (*(addr)), \ "m" (*((addr)+6)), \ "d" (limit) \ :"dx")#define set_base(ldt,base) _set_base( ((char *)&amp;(ldt)) , base )#define set_limit(ldt,limit) _set_limit( ((char *)&amp;(ldt)) , (limit-1)&gt;&gt;12 )#define _get_base(addr) (&#123;\unsigned long __base; \__asm__("movb %3,%%dh\n\t" \ "movb %2,%%dl\n\t" \ "shll $16,%%edx\n\t" \ "movw %1,%%dx" \ :"=d" (__base) \ :"m" (*((addr)+2)), \ "m" (*((addr)+4)), \ "m" (*((addr)+7))); \__base;&#125;)#define get_base(ldt) _get_base( ((char *)&amp;(ldt)) )#define get_limit(segment) (&#123; \unsigned long __limit; \__asm__("lsll %1,%0\n\tincl %0":"=r" (__limit):"r" (segment)); \__limit;&#125;)#endif ÂÖ≥‰∫é sleep_on wait„ÄÇËøôÊòØ‰∏§‰∏™ Â∏ÆÂä© ÁêÜËß£ ÁöÑÂõæÁâáÈáçÁÇπ ÊòØ sleep ÂèØwakeÊ≥®ÊÑè ËøõÁ®ã Êú¨Ë∫´‰ª£Á†ÅÊÆµ ÂíåPCB ‰∏çÊòØ Âêå‰∏Ä‰∏™‰∏úË•ø„ÄÇ sleep_on ‰∏≠ Ë∞ÉÁî® ‰∫Ü schedule();Á≠âÂà∞ ‰ªñËøîÂõûÁöÑÊó∂ÂÄô Ôºå‰Ω†Êç¢Ëøô‰∏™ËøõÁ®ãÂ∑≤ÁªèÂî§ÈÜí‰∫ÜÔºå‰πüÂ∞±ÊòØ ËØ¥ ÔºåÂΩìÂâçËøõÁ®ãÂî§ÈÜí‰πãÂêéÔºåÂÆûÈôÖ‰∏äËøòÂú®sleep on() ÈáåÈù¢. wake() Âè™ÊòØ Êää PCB Ë∞ÉÂÖ•‰∫ÜÂî§ÈÜíÁä∂ÊÄÅ ÔºåÂÆûÈôÖ‰∏ä Ôºå‰ª£Á†ÅÊÆµ Âπ∂Ê≤°ÊúâÊâßË°åÔºå‰ªñËøòÈúÄË¶ÅÁ≠âÂæÖË∞ÉÂ∫¶Ôºåwake() Âè™ÊòØ‰øÆÊîπ‰∫ÜÁä∂ÊÄÅÔºåÂπ∂‰∏çÊòØÁ´ãÈ©¨Ë∞ÉÂ∫¶„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514/* * linux/kernel/sched.c * * (C) 1991 Linus Torvalds *//* * 'sched.c' is the main kernel file. It contains scheduling primitives * (sleep_on, wakeup, schedule etc) as well as a number of simple system * call functions (type getpid(), which just extracts a field from * current-task */#include &lt;linux/sched.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/sys.h&gt;#include &lt;linux/fdreg.h&gt;#include &lt;asm/system.h&gt;#include &lt;asm/io.h&gt;#include &lt;asm/segment.h&gt;#include &lt;signal.h&gt;// ËØªÂèñ nr Âú®‰ø°Âè∑‰ΩçÂõæ‰∏≠ ÂØπÂ∫îÁöÑ‰∫åËøõÂà∂Êï∞ÂÄº#define _S(nr) (1&lt;&lt;((nr)-1))// Èô§‰∫Ü ‰∏ãÈù¢‰∏§‰∏™ ‰ø°Âè∑ ÂÖ∂‰ªñÈÉΩÊòØÂèØÈòªÂ°ûÁöÑ‰ø°Âè∑#define _BLOCKABLE (~(_S(SIGKILL) | _S(SIGSTOP)))//ÂÜÖÊ†∏Ë∞ÉËØïÂáΩÊï∞ ‰∏çÁî®ËØ¶ÁªÜËß£Èáä‰∫ÜÊäävoid show_task(int nr,struct task_struct * p)&#123; int i,j = 4096-sizeof(struct task_struct);// ËøõÁ®ãNr ÁöÑ ËøõÁ®ãÂè∑ Áä∂ÊÄÅ ‰ª•Âèä Â†ÜÊ†àÁ©∫Èó≤Â≠óËäÇÊï∞ printk("%d: pid=%d, state=%d, ",nr,p-&gt;pid,p-&gt;state); i=0; while (i&lt;j &amp;&amp; !((char *)(p+1))[i])//Ê£ÄÊü•ÊåáÂÆö‰ªªÂä°ÁªìÊûÑ‰ª•ÂêéÁ≠â‰∫é 0ÁöÑÂ≠óËäÇÊï∞ i++; printk("%d (of %d) chars free in kernel stack\n\r",i,j);&#125;//Ë∞ÉÁî®ÂâçÈù¢ÈÇ£‰∏™ÂáΩÊï∞ ÔºåÈùûÁ©∫ËøõÁ®ãÂ∞±ÊâìÂç∞void show_stat(void)&#123; int i; for (i=0;i&lt;NR_TASKS;i++) if (task[i]) show_task(i,task[i]);&#125;//È¢ëÁéá / HZ#define LATCH (1193180/HZ)extern void mem_use(void);//Êó∂Èíü‰∏≠Êñ≠Â§ÑÁêÜ ÂÖ∑‰ΩìËßÅ system_call.sextern int timer_interrupt(void);//Á≥ªÁªü ‰∏≠Êñ≠Â§ÑÁêÜ ÂÖ∑‰ΩìËßÅ system_call.sextern int system_call(void);// ‰ªªÂä°Â†ÜÊ†àÊÆµ Ôºå‰ªªÂä°ÂÜÖÊ†∏ÊÄÅÂ†ÜÊ†àÁªìÊûÑunion task_union &#123;//‰ªªÂä°ËÅîÂêàÔºå‰ªªÂä°ÁªìÊûÑ‰Ωì ÂíåstackÂ≠óÁ¨¶Êï∞ÁªÑÊàêÂëò struct task_struct task; //‰ªªÂä°Êï∞ÊçÆÁªìÊûÑÂíåÂÜÖÊ†∏ÊÄÅÂ†ÜÊ†à Âú®ÂêåÊÑèÂÜÖÂ≠òÈ°µ char stack[PAGE_SIZE]; //ÊâÄ‰ª• ss ÂèØ‰ª•ÊàñÂæóÂÖ∂Êï∞ÊçÆÊÆµÈÄâÊã©Á¨¶Âè∑&#125;;//ÂàùÂßãÂåñ‰ªªÂä°ÁªìÊûÑ Â∞±ÊòØÁ¨¨‰∏Ä‰∏™ËøõÁ®ã‰ªªÂä°static union task_union init_task = &#123;INIT_TASK,&#125;;//‰ªéÂºÄÊú∫ÂºÄÂßãÁÆóËµ∑ÁöÑÊª¥Á≠îÊï∞Êó∂Èó¥ÂÄºÂÖ®Â±ÄÂèòÈáèÔºà10ms/Êª¥Á≠îÔºâ„ÄÇÁ≥ªÁªüÊó∂Èíü‰∏≠Êñ≠ÊØèÂèëÁîü‰∏ÄÊ¨°Âç≥‰∏Ä‰∏™Êª¥Á≠î„ÄÇ//ÂâçÈù¢ÁöÑÈôêÂÆöÁ¨¶volatileÔºåËã±ÊñáËß£ÈáäÊòØÊòìÊîπÂèòÁöÑ„ÄÅ‰∏çÁ®≥ÂÆöÁöÑÊÑèÊÄù„ÄÇËøô‰∏™ÈôêÂÆöËØçÁöÑÂê´‰πâÊòØÂêëÁºñËØëÂô®//ÊåáÊòéÂèòÈáèÁöÑÂÜÖÂÆπÂèØËÉΩ‰ºöÁî±‰∫éË¢´ÂÖ∂‰ªñÁ®ãÂ∫è‰øÆÊîπËÄåÂèòÂåñ„ÄÇÈÄöÂ∏∏Âú®Á®ãÂ∫è‰∏≠‰∏≠Êòé‰∏Ä‰∏™ÂèòÈáèÊó∂ÔºåÁºñËØëÂô®‰ºö//Â∞ΩÈáèÊääÂÆÉÂ≠òÊîæÂú®ÈÄöÁî®ÂØÑÂ≠òÂô®‰∏≠Ôºå‰æãÂ¶ÇebxÔºå‰ª•ÊèêÈ´òËÆøÈóÆÊïàÁéá„ÄÇÂΩìCPUÊääÂÖ∂ÂÄºÊîæÂà∞ebx‰∏≠Âêé‰∏ÄËà¨//Â∞±‰∏ç‰ºöÂÜçÂÖ≥ÂøÉËØ•ÂèòÈáèÂØπÂ∫îÂÜÖÂ≠ò‰ΩçÁΩÆ‰∏≠ÁöÑÂÜÖÂÆπ„ÄÇËã•Ê≠§Êó∂ÂÖ∂‰ªñÁ®ãÂ∫èÔºà‰æãÂ¶ÇÂÜÖÊ†∏Á®ãÂ∫èÊàñ‰∏Ä‰∏™‰∏≠Êñ≠ËøáÁ®ãÔºâ//‰øÆÊîπ‰∫ÜÂÜÖÂ≠ò‰∏≠ËØ•ÂèòÈáèÁöÑÂÄºÔºåebx‰∏≠ÁöÑÂÄºÂπ∂‰∏ç‰ºöÈöè‰πãÊõ¥Êñ∞„ÄÇ‰∏∫‰∫ÜËß£ÂÜ≥ËøôÁßçÊÉÖÂÜµÂ∞±ÂàõÂª∫‰∫Üvolatile//ÈôêÂÆöÁ¨¶ÔºåËÆ©‰ª£Á†ÅÂú®ÂºïÁî®ËØ•ÂèòÈáèÊó∂‰∏ÄÂÆöË¶Å‰ªéÊåáÂÆöÂÜÖÂ≠ò‰ΩçÁΩÆ‰∏≠ÂèñÂæóÂÖ∂ÂÄº„ÄÇËøôÈáåÂç≥ÊòØË¶ÅÊ±Çgcc‰∏çË¶ÅÂØπ//jiffies ËøõË°å‰ºòÂåñÂ§ÑÁêÜÔºå‰πü‰∏çË¶ÅÊå™Âä®‰ΩçÁΩÆÔºåÂπ∂‰∏îÈúÄË¶Å‰ªéÂÜÖÂ≠ò‰∏≠ÂèñÂÖ∂ÂÄº„ÄÇÂõ†‰∏∫Êó∂Èíü‰∏≠Êñ≠Â§ÑÁêÜËøáÁ®ã//Á≠âÁ®ãÂ∫è‰ºö‰øÆÊîπÂÆÉÁöÑÂÄº„ÄÇlong volatile jiffies=0;//ËÆ≤Ëøá‰∫Ü ÂºÄÊú∫Êó∂Èó¥long startup_time=0;// ÂΩìÂâç‰ªªÂä° ‰∏ÄÂºÄÂßãÂ∞±ÊòØÁ¨¨‰∏Ä‰∏™‰ªªÂä° Áé∞Âú®ÊòØinit()Á®ãÂ∫èstruct task_struct *current = &amp;(init_task.task);//‰ΩøÁî®ËøáÂçèÂ§ÑÁêÜÂô®‰ªªÂä°ÊåáÈíàstruct task_struct *last_task_used_math = NULL;//‰ªªÂä°ÂàóË°®Ôºå‰∏ÄÂºÄÂßã Â∞±ÊòØ initÔºàÔºâstruct task_struct * task[NR_TASKS] = &#123;&amp;(init_task.task), &#125;;// Áî®Êà∑Â†ÜÊ†à//ÂÆö‰πâÁî®Êà∑Â†ÜÊ†àÔºåÂÖ±1KÈ°πÔºåÂÆπÈáè4KÂ≠óËäÇ„ÄÇÂú®ÂÜÖÊ†∏ÂàùÂßãÂåñÊìç‰ΩúËøáÁ®ã‰∏≠Ë¢´Áî®‰ΩúÂÜÖÊ†∏Ê†àÔºåÂàùÂßãÂåñÂÆåÊàê//‰ª•ÂêéÂ∞ÜË¢´Áî®‰Ωú‰ªªÂä°0ÁöÑÁî®Êà∑ÊÄÅÂ†ÜÊ†à„ÄÇÂú®ËøêË°å‰ªªÂä°0‰πãÂâçÂÆÉÊòØÂÜÖÊ†∏Ê†àÔºå‰ª•ÂêéÁî®‰Ωú‰ªªÂä°0Âíå1ÁöÑÁî®//Êà∑ÊÄÅÊ†à„ÄÇ‰∏ãÈù¢ÁªìÊûÑÁî®‰∫éËÆæÁΩÆÂ†ÜÊ†àss:espÔºàÊï∞ÊçÆÊÆµÈÄâÊã©Á¨¶ÔºåÊåáÈíàÔºâÔºåËßÅhead.sÔºåÁ¨¨23Ë°å„ÄÇ//ssË¢´ËÆæÁΩÆ‰∏∫ÂÜÖÊ†∏Êï∞ÊçÆÊÆµÈÄâÊã©Á¨¶Ôºà0x10ÔºâÔºåÊåáÈíàespÊåáÂú®user_stackÊï∞ÁªÑÊúÄÂêé‰∏ÄÈ°πÂêéÈù¢„ÄÇËøôÊòØ//Âõ†‰∏∫IntelCPUÊâßË°åÂ†ÜÊ†àÊìç‰ΩúÊó∂ÊòØÂÖàÈÄíÂáèÂ†ÜÊ†àÊåáÈíàspÂÄºÔºåÁÑ∂ÂêéÂú®spÊåáÈíàÂ§Ñ‰øùÂ≠òÂÖ•Ê†àÂÜÖÂÆπ„ÄÇlong user_stack [ PAGE_SIZE&gt;&gt;2 ] ;struct &#123; long * a; short b; &#125; stack_start = &#123; &amp; user_stack [PAGE_SIZE&gt;&gt;2] , 0x10 &#125;;/* * 'math_state_restore()' saves the current math information in the * old math state array, and gets the new ones from the current task *//* * Â∞ÜÂÖöÂª∫ÂÜÖÂÆπ ‰øùÂ≠ò Âà∞ ËÄÅÂ§ÑÁêÜÂô®Áä∂ÊÄÅÊï∞ÁªÑ‰∏≠ * Âπ∂ÂõûÂ∞ÜÂΩìÂâç‰ªªÂä°ÁöÑÂçèÂ§ÑÁêÜÂô®ÂÜÖÂÆπÂä†ËΩΩÂà∞ÂçèÂ§ÑÁêÜÂô®‰∏≠ * *///Ê≠§ÂáΩÊï∞Áî®‰∫é‰∏ä‰∏ãÊñáÂàáÊç¢ Ôºå ÂΩì‰ªªÂä° Ë¢´Ë∞ÉÂ∫¶‰∫§Êç¢‰ª•ÂêéÔºåËØ•ÂáΩÊï∞Áî®‰ª•‰øùÂ≠òÂçèÂ§ÑÁêÜÂô®Áä∂ÊÄÅÔºà‰∏ä‰∏ãÊñáÔºâ// Âπ∂ÊÅ¢Â§çÊñ∞ÁöÑË∞ÉÂ∫¶ËøõÊù•ÁöÑÂΩìÂâç‰ªªÂä°ÁöÑÂçèÂ§ÑÁêÜÂô®ËΩ¨Âè∞void math_state_restore()&#123; // ‰ªªÂä°Ê≤°ÊúâÊîπÂèò Â∞±Áõ¥Êé•ËøîÂõû if (last_task_used_math == current) return; //Âú®ÂèëÈÄÅÂçèÂ§ÑÁêÜÂô®ÂëΩ‰ª§‰πãÂâçË¶ÅÂèë wait Êåá‰ª§ÔºåÂ¶ÇÊûú‰∏ä‰∏Ä‰∏™‰ªªÂä°‰ΩøÁî®‰∫ÜÂçèÂ§ÑÁêÜÂô® Â∞±Ë¶Å‰øùÂ≠ò __asm__("fwait"); if (last_task_used_math) &#123; __asm__("fnsave %0"::"m" (last_task_used_math-&gt;tss.i387)); &#125; //ÂçèÂ§ÑÁêÜÂô®ÊåáÂêëËá™Â∑± last_task_used_math=current; //Â¶ÇÊûúÁ¨¨‰∏ÄÁî® Â∞±ÂàùÂßãÂåñ ÂçèÂ§ÑÁêÜÂô® Âê¶Âàô Áõ¥Êé•ÂõûÂ§çÁä∂ÊÄÅ if (current-&gt;used_math) &#123; __asm__("frstor %0"::"m" (current-&gt;tss.i387)); &#125; else &#123; __asm__("fninit"::);//ÂÉèÂçèÂ§ÑÁêÜÂô®ÂèëÈÄÅÂàùÂßãÂåñÂëΩ‰ª§ current-&gt;used_math=1;//Ë°®Á§∫Ëá™Â∑±‰ΩøÁî®ÂçèÂ§ÑÁêÜÂô® &#125;&#125;/* * 'schedule()' is the scheduler function. This is GOOD CODE! There * probably won't be any reason to change this, as it should work well * in all circumstances (ie gives IO-bound processes good response etc). * The one thing you might take a look at is the signal-handler code here. * * NOTE!! Task 0 is the 'idle' task, which gets called when no other * tasks can run. It can not be killed, and it cannot sleep. The 'state' * information in task[0] is never used. *//* * ‰∏äÈù¢ÂëäËØâ ‰Ω† schedule ÊòØ‰∏™ÂæàÂ•ΩÁöÑ‰∏úË•ø Ê≤°ÊúâË¶ÅÊîπÁöÑÂøÖË¶ÅÔºå‰ªª‰ΩïÁéØÂ¢É‰∏ãÈÉΩËÉΩÂ∑•‰Ωú„ÄÇ * ‰Ω†Âè™ÈúÄË¶ÅÊ≥®ÊÑè‰ø°Âè∑Â§ÑÁêÜ‰ª£Á†ÅÂç≥ÂèØ * * Ê≥®ÊÑè!! ‰ªªÂä°0 ÊØîÊòØ‰∏Ä‰∏™Èó≤ÁΩÆ‰ªªÂä°ÔºåÂè™ÊúâÊ≤°ÊúâÂÖ∂‰ªñ‰ªªÂä°ËøêË°åÁöÑÊó∂ÂÄô‰Ω†ÊâçËÉΩË∞ÉÁî® Ôºå * ‰ªñ‰∏çËÉΩÊùÄÊ≠ª ‰πü‰∏çËÉΩÁù°Áú†Ôºå‰ªñÁöÑstate ‰ªéÊù•‰∏çÁî®„ÄÇ * */void schedule(void)&#123; int i,next,c; struct task_struct ** p; //ÊåáÂêë‰ªªÂä°ÁªìÊûÑÊåáÈíàÁöÑÊåáÈíà/* check alarm, wake up any interruptible tasks that have got a signal *//* Ê£ÄÊµãÂà∞alarmÔºàËøõÁ®ãÁöÑÊä•Ë≠¶ÂÆöÊó∂Âô®ÔºâÔºåÂî§ÈÜí‰ªª‰ΩïÂ∑≤ÁªèÂæóÂà∞‰ø°Âè∑ÁöÑÂèØ‰∏≠Êñ≠‰ªªÂä°*////‰ªéÂêéÂæÄÂâçÈÅçÂéÜ ‰ªªÂä°ÔºåË∑≥Ëøá Á©∫ÊåáÈíà for(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p) if (*p) &#123; // Â¶ÇÊûúËÆæÁΩÆ‰∫ÜË≠¶Êä•Ôºå‰∏îÁªèËøá ËøáÊúüÔºåÂ∞±ËÆæÁΩÆsignalÁÑ∂ÂêéÊ∏ÖÈô§alarm if ((*p)-&gt;alarm &amp;&amp; (*p)-&gt;alarm &lt; jiffies) &#123; (*p)-&gt;signal |= (1&lt;&lt;(SIGALRM-1)); (*p)-&gt;alarm = 0; &#125; //Â¶ÇÊûú‰ø°Âè∑‰ΩçÂõæ‰∏≠Ë¢´ÈòªÂ°ûÁöÑ‰ø°Âè∑Â§ñËøòÊúâÂÖ∂‰ªñ‰ø°Âè∑ÔºåÂπ∂‰∏î‰ªªÂä°Â§Ñ‰∫éÂèØ‰∏≠Êñ≠ËΩ¨Âè∞ÔºåÈÖíÂêß‰ªªÂä°Âèò‰∏∫Â∞±Áª™ // ~(_BLOCKABLE &amp; (*p)-&gt;blocked))Áî®‰∫éÂøΩÁï•ÈòªÂ°û‰ø°Âè∑ if (((*p)-&gt;signal &amp; ~(_BLOCKABLE &amp; (*p)-&gt;blocked)) &amp;&amp; (*p)-&gt;state==TASK_INTERRUPTIBLE) (*p)-&gt;state=TASK_RUNNING; &#125;/* this is the scheduler proper: */ //Ë∞ÉÂ∫¶ÁöÑÊ†∏ÂøÉ while (1) &#123; c = -1; next = 0; i = NR_TASKS; p = &amp;task[NR_TASKS]; while (--i) &#123; //Â¶ÇÊûúÊòØÁ©∫ÊåáÈíàÂ∞±Ë∑≥Ëøá if (!*--p) continue; //ÊØîËæÉÊâÄÊúâ Â∞±Áª™Áä∂ÊÄÅ counter ÁöÑÂ§ßÂ∞èÔºåÊâæÂà∞ÊúÄÂ§ßÁöÑ if ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c) c = (*p)-&gt;counter, next = i; &#125; //Â¶ÇÊûúÊâæÂà∞‰∫ÜÂ∞±Ë∑≥Âá∫Âéª if (c) break; // Â¶ÇÊûúÊúÄÂ§ßÁöÑcounter = 0 Â∞±Êõ¥Êñ∞ counter ÔºåÂ∞±ÊòØ‰∏ãÈù¢Ëøô‰∏™ÁÆóÊ≥ï ÔºåÂ∞±ÊòØÂΩìÂâçÂÄº /2 +priority ......Â•ΩÊï∑Ë°çÁöÑÊÑüËßâ for(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p) if (*p) (*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; 1) + (*p)-&gt;priority; &#125; //‰∏ãÈù¢Ëøô‰∏™Â∞±ÊòØË∑≥ËΩ¨ÊâßË°å Â¶ÇÊûúnext=0 ÂÆûÈôÖ‰∏äÂèàÂõûÂà∞‰∫ÜËøô‰∏™ÂáΩÊï∞ switch_to(next);&#125;//ÊöÇÂÅúÂΩìÂâçËøõÁ®ãÔºåË∞ÉÂ∫¶‰∏ã‰∏Ä‰∏™//Ë∞ÉÁî®ÂΩìÂâçÂáΩÊï∞ ‰ºö‰ΩøÂΩìÂâç ËøõÁ®ãËøõÂÖ•Áù°Áú† Áõ¥Âà∞ Êî∂Âà∞‰∏Ä‰∏™‰ø°Âè∑int sys_pause(void)&#123; current-&gt;state = TASK_INTERRUPTIBLE; schedule(); return 0;&#125;/* * ÂáΩÊï∞ Â∞ÜÂΩìÂâç ËøõÁ®ã Áù°Áú† Á≠âÂæÖwakeup * * */// **p ÊòØ Á≠âÂæÖÈòüÂàóÂ§¥ÊåáÈíàÁöÑÊåáÈíàvoid sleep_on(struct task_struct **p)&#123; struct task_struct *tmp; //Â¶ÇÊûúÁ≠âÂæÖÈòüÂàóÊòØÁ©∫ÊåáÈíà Âàô Êó†Êïà if (!p) return; // Â¶ÇÊûú ÂΩìÂâçÊòØ‰ªªÂä° 0 Â∞±Ê≠ªÊú∫‰∫Ü if (current == &amp;(init_task.task)) panic("task[0] trying to sleep"); tmp = *p; *p = current; //ÊääÂΩìÂâçÁä∂ÊÄÅ ÈòªÂ°ûÔºåÁõ¥Âà∞Ë∞ÉÁî®wakeup current-&gt;state = TASK_UNINTERRUPTIBLE; //Ë∞ÉÂ∫¶ schedule(); //ÂΩìË∞ÉÂ∫¶ ÂÆåÊàê‰πãÂêé ÈáçÊñ∞Âî§ÈÜíËøô‰∏™ËøõÁ®ã ‰ª£Á†ÅÂú®ËøôÁªßÁª≠ÊâßË°å if (tmp) //Â¶ÇÊûúÂêéÈù¢ËøòÊúâËøõÁ®ãÂ∞±Êää ‰∏ã‰∏Ä‰∏™‰πüÂî§ÈÜí tmp-&gt;state=0;&#125;/* * ‰∏æ‰∏™‰æãÂ≠ê ÔºåÂ¶ÇÊûúÊúâËØØÊ¨¢ËøéÊåáÂá∫ * * A sleep Ë∞ÉÁî® B ÁÑ∂ÂêéÂÜç sleep Ë∞ÉÁî® C ÁÑ∂ÂêéCË∞ÉÁî®wake Âî§ÈÜí‰∫ÜB ÔºåÂ¶ÇÊûúA B Âú®Âêå‰∏Ä‰∏™ÈòüÂàó ÔºåB ‰πü‰ºöÂî§ÈÜíA * * */void interruptible_sleep_on(struct task_struct **p)&#123; struct task_struct *tmp; if (!p) return; if (current == &amp;(init_task.task)) panic("task[0] trying to sleep"); tmp=*p; *p=current; //ÂâçÈù¢ÈÉΩÊòØ‰∏ÄÊ†∑ÁöÑ.. //ËÆæÁΩÆÂΩìÂâç‰∏≠Êñ≠Á≠âÂæÖÁä∂ÊÄÅrepeat: current-&gt;state = TASK_INTERRUPTIBLE; schedule(); //Â¶ÇÊûúÂΩìÂâçÊâßË°åÁöÑ ËøõÁ®ã Âπ∂‰∏çÊòØ ÂΩìÂâçÁ≠âÂæÖËøõÁ®ãÈòüÂàóÁöÑÁ¨¨‰∏Ä‰∏™ ÈÇ£‰πà Â∞±Êää‰ªñÈáçÊñ∞‰∏¢ÂõûÂéªÔºåÂÜçË∞ÉÂ∫¶‰∏ÄÊ¨° if (*p &amp;&amp; *p != current) &#123; (**p).state=0; goto repeat; &#125; *p=NULL; if (tmp) tmp-&gt;state=0;&#125;// Áõ¥Êé•Âî§ÈÜívoid wake_up(struct task_struct **p)&#123; if (p &amp;&amp; *p) &#123; (**p).state=0; *p=NULL; &#125;&#125;/* * ÂêéÈù¢ÁöÑ‰ª£Á†Å ÊúâÂÖ¥Ë∂£ÁöÑÂèØ‰ª•Ëá™Â∑±ÊêúÁ¥¢ ÁêÜËß£‰∏Ä‰∏ã... * * *//* * OK, here are some floppy things that shouldn't be in the kernel * proper. They are here because the floppy needs a timer, and this * was the easiest way of doing it. */static struct task_struct * wait_motor[4] = &#123;NULL,NULL,NULL,NULL&#125;;static int mon_timer[4]=&#123;0,0,0,0&#125;;static int moff_timer[4]=&#123;0,0,0,0&#125;;unsigned char current_DOR = 0x0C;int ticks_to_floppy_on(unsigned int nr)&#123; extern unsigned char selected; unsigned char mask = 0x10 &lt;&lt; nr; if (nr&gt;3) panic("floppy_on: nr&gt;3"); moff_timer[nr]=10000; /* 100 s = very big :-) */ cli(); /* use floppy_off to turn it off */ mask |= current_DOR; if (!selected) &#123; mask &amp;= 0xFC; mask |= nr; &#125; if (mask != current_DOR) &#123; outb(mask,FD_DOR); if ((mask ^ current_DOR) &amp; 0xf0) mon_timer[nr] = HZ/2; else if (mon_timer[nr] &lt; 2) mon_timer[nr] = 2; current_DOR = mask; &#125; sti(); return mon_timer[nr];&#125;//Á≠âÂæÖÂà∂ÂÆöËΩØÈ©±È©¨ËææÂêØÂä®‰∏ÄÊÆµÊó∂Èó¥ÁÑ∂ÂêéËøîÂõû„ÄÇvoid floppy_on(unsigned int nr)&#123; cli(); //Ëøô‰∏™ÊòØÁ¶ÅÊ≠¢‰∏≠Êñ≠ while (ticks_to_floppy_on(nr)) sleep_on(nr+wait_motor); sti();&#125;//ÁΩÆÂÖ≥Èó≠Áõ∏Â∫î ÁöÑËΩØÈ©±È©¨ËææÂÅúËΩ¨ 3s ‰∏çËÆæÁΩÆ ÊòØ 100svoid floppy_off(unsigned int nr)&#123; moff_timer[nr]=3*HZ;&#125;//ËΩØÁõòÂÆöÊó∂Â§ÑÁêÜÂ≠êÁ®ãÂ∫èvoid do_floppy_timer(void)&#123; int i; unsigned char mask = 0x10; for (i=0 ; i&lt;4 ; i++,mask &lt;&lt;= 1) &#123; if (!(mask &amp; current_DOR)) continue; if (mon_timer[i]) &#123; if (!--mon_timer[i]) wake_up(i+wait_motor); &#125; else if (!moff_timer[i]) &#123; current_DOR &amp;= ~mask; outb(current_DOR,FD_DOR); &#125; else moff_timer[i]--; &#125;&#125;#define TIME_REQUESTS 64// ÂÆöÊó∂Âô®ÈìæË°®ÁªìÊûÑÂíåÂÆöÊó∂Âô®Êï∞ÁªÑstatic struct timer_list &#123; long jiffies; void (*fn)(); struct timer_list * next;&#125; timer_list[TIME_REQUESTS], * next_timer = NULL;// Ê∑ªÂä†ÂÆöÊó∂Âô®ËæìÂÖ•Êó∂Èó¥ ÂíåÁõ∏Â∫îÁöÑÂ§ÑÁêÜÂáΩÊï∞ÊåáÈíàvoid add_timer(long jiffies, void (*fn)(void))&#123; struct timer_list * p; if (!fn) return; cli(); if (jiffies &lt;= 0) (fn)(); else &#123; for (p = timer_list ; p &lt; timer_list + TIME_REQUESTS ; p++) if (!p-&gt;fn) break; if (p &gt;= timer_list + TIME_REQUESTS) panic("No more time requests free"); p-&gt;fn = fn; p-&gt;jiffies = jiffies; p-&gt;next = next_timer; next_timer = p; while (p-&gt;next &amp;&amp; p-&gt;next-&gt;jiffies &lt; p-&gt;jiffies) &#123; p-&gt;jiffies -= p-&gt;next-&gt;jiffies; fn = p-&gt;fn; p-&gt;fn = p-&gt;next-&gt;fn; p-&gt;next-&gt;fn = fn; jiffies = p-&gt;jiffies; p-&gt;jiffies = p-&gt;next-&gt;jiffies; p-&gt;next-&gt;jiffies = jiffies; p = p-&gt;next; &#125; &#125; sti();&#125;//Êó∂Èó¥‰∏≠Êñ≠Â§ÑÁêÜÂáΩÊï∞void do_timer(long cpl)&#123; extern int beepcount; extern void sysbeepstop(void); if (beepcount) if (!--beepcount) sysbeepstop(); if (cpl) current-&gt;utime++; else current-&gt;stime++; if (next_timer) &#123; next_timer-&gt;jiffies--; while (next_timer &amp;&amp; next_timer-&gt;jiffies &lt;= 0) &#123; void (*fn)(void); fn = next_timer-&gt;fn; next_timer-&gt;fn = NULL; next_timer = next_timer-&gt;next; (fn)(); &#125; &#125; if (current_DOR &amp; 0xf0) do_floppy_timer(); if ((--current-&gt;counter)&gt;0) return; current-&gt;counter=0; if (!cpl) return; schedule();&#125;// Ëøô‰∏™ÊòØËÆæÁΩÆÊä•Ë≠¶Êó∂Èó¥ÔºàÁßíÔºâ//seconds Â§ß‰∫é0 ËÆæÁΩÆÊñ∞Êó∂Èó¥ Âπ∂ËøîÂõû ËÄÅÊó∂Èó¥ËøòÂ∑ÆÂ§öÂ∞ëÁßí„ÄÇÂê¶ÂàôËøîÂõû 0int sys_alarm(long seconds)&#123; int old = current-&gt;alarm; if (old) old = (old - jiffies) / HZ; current-&gt;alarm = (seconds&gt;0)?(jiffies+HZ*seconds):0; return (old);&#125;//ÂêéÈù¢ËøôÊòØ‰∏ÄÂ§ßÂ†ÜËé∑ÂèñÂΩìÂâçÁöÑ‰∏Ä‰∫õÂÄºÁöÑÂáΩÊï∞int sys_getpid(void)&#123; return current-&gt;pid;&#125;int sys_getppid(void)&#123; return current-&gt;father;&#125;int sys_getuid(void)&#123; return current-&gt;uid;&#125;int sys_geteuid(void)&#123; return current-&gt;euid;&#125;int sys_getgid(void)&#123; return current-&gt;gid;&#125;int sys_getegid(void)&#123; return current-&gt;egid;&#125;//Èôç‰Ωé‰ºòÂÖàÊùÉint sys_nice(long increment)&#123; if (current-&gt;priority-increment&gt;0) current-&gt;priority -= increment; return 0;&#125;// ËøôÊòØ‰∏Ä‰∏™ÂÜÖÊ†∏ÂàùÂßãÂåñÁ®ãÂ∫èvoid sched_init(void)&#123; int i; struct desc_struct * p; if (sizeof(struct sigaction) != 16) panic("Struct sigaction MUST be 16 bytes"); set_tss_desc(gdt+FIRST_TSS_ENTRY,&amp;(init_task.task.tss)); set_ldt_desc(gdt+FIRST_LDT_ENTRY,&amp;(init_task.task.ldt)); p = gdt+2+FIRST_TSS_ENTRY; for(i=1;i&lt;NR_TASKS;i++) &#123; task[i] = NULL; p-&gt;a=p-&gt;b=0; p++; p-&gt;a=p-&gt;b=0; p++; &#125;/* Clear NT, so that we won't have troubles with that later on */ __asm__("pushfl ; andl $0xffffbfff,(%esp) ; popfl"); ltr(0); lldt(0); outb_p(0x36,0x43); /* binary, mode 3, LSB/MSB, ch 0 */ outb_p(LATCH &amp; 0xff , 0x40); /* LSB */ outb(LATCH &gt;&gt; 8 , 0x40); /* MSB */ set_intr_gate(0x20,&amp;timer_interrupt); outb(inb_p(0x21)&amp;~0x01,0x21); set_system_gate(0x80,&amp;system_call);&#125;]]></content>
      <categories>
        <category>Êìç‰ΩúÁ≥ªÁªü</category>
      </categories>
      <tags>
        <tag>UNIX</tag>
        <tag>linux</tag>
        <tag>Ê∫êÁ†Å</tag>
        <tag>ËøõÁ®ãË∞ÉÂ∫¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-4. ÂØªÊâæ‰∏§‰∏™ÊúâÂ∫èÊï∞ÁªÑÁöÑ‰∏≠‰ΩçÊï∞]]></title>
    <url>%2F2019%2F12%2F12%2Fleetcode-4.-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[ËøôÈ¢òÊå∫ÊúâÊÑèÊÄùÁöÑÔºå‰∏ÄÂºÄÂßãÊÉ≥‰∫ÜÂçäÂ§©ÊÄé‰πàÂ§ÑÁêÜÁªÜËäÇÔºåÊÉ≥‰∫ÜÂçäÂ§©ÔºåÊ≤°ÊÉ≥Âá∫Êù•ÔºåË¶Å‰∏çÊö¥ÂäõÊâÄÊúâÊÉÖÂÜµÔºåÁªìÊûúÁâπ‰πàËøòË∑ëÁöÑÈ£ûÂø´„ÄÇ ËøôÈ¢òÁúã‰∏ÄÁúºËÇØÂÆöÁü•ÈÅìÊòØ‰∫åÂàÜÔºå‰∏§‰∏™ÊúâÂ∫èÊï∞ÁªÑÔºåÊâæÂêàÂπ∂‰πãÂêéÁöÑ‰∏≠‰ΩçÊï∞„ÄÇÈöæÊêûÁöÑÂ∞±ÊòØ‰ºöÂá∫Áé∞Áõ∏ÂêåÊï∞Â≠óÔºåÂíåÊï∞ÁªÑÈïøÂ∫¶ÊòØÂÅ∂Êï∞„ÄÇÊâÄ‰ª•ÊàëÂ∞±Êêû‰∫Ü‰∏Ä‰∏™ÂáΩÊï∞ Áõ¥Êé•ÊâæÁ¨¨ k ‰∏™Âú®Âì™ÔºåÁÑ∂ÂêéÁ¨¨K‰∏™Âú®Âì™ÔºåÂõ†‰∏∫ Á¨¨ k‰∏™ÂèØËÉΩÂú®Á¨¨‰∏Ä‰∏™Êï∞ÁªÑÔºåÂèàÊúâÂèØËÉΩÂú®Á¨¨‰∫å‰∏™Êï∞ÁªÑÔºåÊâÄ‰ª•Ë¶ÅÊâæ‰∏§Ê¨°ÔºåÊâæÁöÑÊó∂ÂÄôÊääÂºïÁî®Êç¢‰∏Ä‰∏ãÂ∞±Ë°å‰∫Ü„ÄÇË¥ºÈ∫ªÁÉ¶ÔºåÁªÜËäÇÂ§™ÈöæÂ§ÑÁêÜ‰∫ÜÔºåÁªÜËäÇÂ§ÑÁêÜÊàëÊâìÂú®‰ª£Á†ÅÊ≥®ÈáäÈáå„ÄÇ ÊÄùÊÉ≥Â∞±ÊòØ Âú®‰∏Ä‰∏™Êï∞ÁªÑÈáåÈù¢‰∫åÂàÜ‰∏≠Èó¥ÂÄº‰ΩçÁΩÆÔºåÈÄöËøáÂú®Âè¶‰∏Ä‰∏™Êï∞ÁªÑÈáåÈù¢‰∫åÂàÜÊâæÂ∞è‰∫éÁ≠â‰∫éÂΩìÂâçÂÄºÁöÑÊï∞ÈáèÂíåËá™Â∑±ÁöÑ‰∏ãÊ†áÁõ∏Âä†ÂèØ‰ª•ÂæóÂà∞Âú®‰∏§‰∏™Êï∞ÁªÑÂêàÂπ∂‰πãÂêéÁöÑ‰ΩçÁΩÆ„ÄÇ12345678910111213141516171819202122232425262728293031323334353637383940414243const int INF=0x3f3f3f3f;class Solution &#123;public: inline int get(int k,vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2)&#123; int l=0,r=nums1.size()-1; while(l&lt;=r)&#123; int mid=(l+r)/2; int num=lower_bound(nums2.begin(),nums2.end(),nums1[mid])-nums2.begin(); //ÊâæÁ¨¨‰∫å‰∏™Êï∞ÁªÑÈáåÈù¢Â∞è‰∫éÁ≠â‰∫énum[mid]ÁöÑ‰∏™Êï∞ if(mid+num&lt;=k)&#123; //Â¶ÇÊûúÂä†Ëµ∑Êù•ÁöÑ‰ΩçÁΩÆÂ∞è‰∫é k ËØ¥ÊòéËøô‰∏™Êï∞ÂèØËÉΩÊòØË¶ÅÊâæÁöÑ Âõ†‰∏∫ÂèØËÉΩÂá∫Áé∞ÂæàÂ§ö‰∏™Áõ∏ÂêåÁöÑÊï∞Â≠óÊâÄ‰ª•‰∏çËÉΩÁÆÄÂçïÁöÑÂà§Á≠â‰∫é int t1=upper_bound(nums2.begin(),nums2.end(),nums1[mid])-nums2.begin(); //ÂΩìÂâçËøô‰∏™ÂÄºÂä†‰∏äÁõ∏ÂêåÁöÑ‰∏™Êï∞ int t2=upper_bound(nums1.begin(),nums1.end(),nums1[mid])-nums1.begin(); //ÂΩìÂâçËøô‰∏™ÂÄºÂä†‰∏äÁõ∏ÂêåÁöÑÂú®num2ÈáåÈù¢ÁöÑ‰∏™Êï∞ if(t1+t2-1&gt;=k)return nums1[mid]; //‰∏§‰∏™Êï∞Áõ∏Âä† -1 Â∞±ÊòØ ‰ΩçÁΩÆÔºå‰∏ãÊ†á‰ªé 0 ÂºÄÂßã /* ‰∏æ‰∏™‰æãÂ≠ê * &#123;1,1,3,3&#125; &#123;1,1,3,3&#125; * ÂÅáËÆæ‰Ω†Ë¶ÅÊâæ k=6 * mid = 2 num1[mid]=3 num=2 mid+num=4 &lt;6 * ÁÑ∂Âêé t1 = 4 t2 = 4 t1+t2-1=7 7&gt;=6 ÊâÄ‰ª• 4-7 ‰πãÈó¥ÈÉΩÊòØÁõ∏ÂêåÁöÑÊï∞ * ÊâÄ‰ª•ÂÆûÈôÖ‰∏ä 3 ÊòØÊâæÂà∞ÁöÑÁ≠îÊ°à * * */ l=mid+1; &#125; else r=mid-1; &#125; return -INF; &#125; inline int Max(int k,vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2)&#123; // Âõ†‰∏∫ÊàëÂ¶ÇÊûúÊ≤°ÊúâÂú®num1 ÈáåÈù¢ÊâæÂà∞ ‰∏ãÊ†áÂàöÂ•Ω‰∏∫ k ÁöÑÂÄºÂ∞±‰ºöËøîÂõû-INFÔºåÊâÄ‰ª•Áõ¥Êé•Âèñ‰∏™MAX Â∞±ÊòØÁ≠îÊ°à // ‰∫§Êç¢‰∏Ä‰∏ãÂºïÁî®Â∞±Áõ∏ÂΩì‰∫é‰ªé num2 ÈáåÈù¢ÊâæÊéíÂêçÁ¨¨kÁöÑÂÄº‰∫Ü return max(get(k,nums1,nums2),get(k,nums2,nums1)); &#125; double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int k=(nums1.size()+nums2.size())/2; if((nums1.size()+nums2.size())%2==0)&#123; //Â¶ÇÊûúÂÅ∂Êï∞‰∏™ Â∞±Êâæ ‰∏§‰∏™ÂÄº int t1=Max(k,nums1,nums2),t2=Max(k-1,nums1,nums2); return (Max(k,nums1,nums2)+Max(k-1,nums1,nums2))/2.0; &#125; else return Max(k,nums1,nums2); &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>‰∫åÂàÜ</category>
      </categories>
      <tags>
        <tag>‰∫åÂàÜ</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Êìç‰ΩúÁ≥ªÁªü-ËøõÁ®ãÁÆ°ÁêÜ]]></title>
    <url>%2F2019%2F12%2F12%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Â§ßÈÉ®ÂàÜÂü∫Áü•ËØÜÁúãÁúãÂ∞±Ë°å ÂÆö‰πâËøõÁ®ãÊòØÂÖ∑ÊúâÁã¨Á´ãÂäüËÉΩÁöÑÁ®ãÂ∫èÂÖ≥‰∫éÊüê‰∏™Êï∞ÊçÆÈõÜÂêà‰∏äÁöÑ‰∏ÄÊ¨°ËøêË°åÊ¥ªÂä®ÔºåÊòØÁ≥ªÁªüËøõË°åËµÑÊ∫êÂàÜÈÖçÂíåË∞ÉÂ∫¶ÁöÑÁã¨Á´ãÂçï‰Ωç ËøõÁ®ãÊòØÁ®ãÂ∫èÁöÑ‰∏ÄÊ¨°ÊâßË°åËøáÁ®ãÔºå‰∏Ä‰∏™Á®ãÂ∫èÊâßË°åÂ§öÊ¨°ÈÇ£ÊòØ‰∏çÂêåÁöÑËøõÁ®ã ÊòØÊ≠£Âú®ËøêË°åÁöÑÁ®ãÂ∫èÁöÑÊäΩË±°ÔºåÊàñËÄÖËØ¥ÊòØÂØπCPUÁöÑ‰∏Ä‰∏™ÊäΩË±° Â∞Ü‰∏Ä‰∏™CPUÂèòÊç¢ÊàêÂ§ö‰∏™ËôöÊãüÁöÑCPU Á≥ªÁªüËµÑÊ∫ê‰ª•ËøõÁ®ã‰∏∫Âçï‰ΩçÂàÜÈÖçÔºåÂ¶ÇÂÜÖÂ≠ò„ÄÅÊñá‰ª∂Á≠âÔºåÊìç‰ΩúÁ≥ªÁªü‰∏∫ÊØè‰∏™Áã¨Á´ãÁöÑËøõÁ®ãÂàÜÈÖç‰∫ÜÁã¨Á´ãÁöÑÂú∞ÂùÄÁ©∫Èó¥ Êìç‰ΩúÁ≥ªÁªüÂ∞ÜCPUË∞ÉÂ∫¶ÁªôÈúÄË¶ÅÁöÑËøõÁ®ãÔºåÂç≥Â∞ÜCPUÁöÑÊéßÂà∂ÊùÉ‰∫§ÁªôÊüê‰∏™ËøõÁ®ãÂ∞±Áß∞‰∏∫Ë∞ÉÂ∫¶ ÁâπÁÇπ ÁªìÊûÑÊÄßÔºöÁî±Êï∞ÊçÆÊÆµ„ÄÅÁ®ãÂ∫èÊÆµ„ÄÅPCBÊûÑÊàê Âä®ÊÄÅÊÄßÔºöÂèØ‰ª•Ë¢´Âä®ÊÄÅÂú∞ÂàõÂª∫„ÄÅÊâßË°å„ÄÅÊí§ÈîÄ Âπ∂ÂèëÊÄßÔºöÂêå‰∏ÄÊó∂Èó¥ÂÜÖÊúâÂ§ö‰∏™ËøõÁ®ãÂú®ËøêË°å Áã¨Á´ãÊÄßÔºöÁã¨Á´ãËøêË°å‰ª•ÂèäËé∑ÂæóOSËµÑÊ∫êÁöÑÂü∫Êú¨Âçï‰Ωç ÂºÇÊ≠•ÊÄßÔºöÂºÇÊ≠•ÊâßË°å Áä∂ÊÄÅ ËøêË°åÁä∂ÊÄÅ ËøõÁ®ãÂ∑≤ÁªèÂç†ÊúâCPUÔºåÂú®CPU‰∏äËøêË°å Â∞±Áª™Áä∂ÊÄÅ ÂÖ∑Â§áËøêË°åÊù°‰ª∂Ôºå‰ΩÜÊòØÁî±‰∫éÊó†CPUÔºåÊöÇÊó∂‰∏çËÉΩËøêË°å ÈòªÂ°ûÁä∂ÊÄÅ Á≠âÂæÖ‰ø°Âè∑‰∏çËÉΩËøêË°å ‰∏âÊÄÅËΩ¨Êç¢ ‰∫îÊÄÅËΩ¨Êç¢ Linux ‰∏ãÁöÑËøõÁ®ãÁä∂ÊÄÅÁâàÊú¨‰∏çÂêåÂèØËÉΩÁä∂ÊÄÅ‰∏çÂêå ÂèØËøêË°åÊÄÅ Â∞±Áª™(TASK_RUNNING)ÔºöÂú®Â∞±Áª™ÈòüÂàó‰∏≠Á≠âÂæÖË∞ÉÂ∫¶„ÄÇ ËøêË°åÔºöÂ∑≤ÁªèÂú®ËøêË°åÁöÑËøõÁ®ã ÈòªÂ°ûÁä∂ÊÄÅ ÂèØ‰∏≠Êñ≠ÈòªÂ°ûÊÄÅ(TASK_INTERRUPTIBLE)Ôºö ËøõÁ®ãÂ§Ñ‰∫éÊüê‰∏™Á≠âÂæÖÈòüÂàó‰∏≠ÔºåÂÆÉËÉΩÂ§üË¢´‰ø°Âè∑ÔºàsignalÔºâÊàñ‰∏≠Êñ≠Âî§ÈÜí„ÄÇÁ≠âÂæÖËµÑÊ∫êÁöÑËØ∑Ê±ÇÊª°Ë∂≥Êó∂Ôºå‰πüË¢´Âî§ÈÜí„ÄÇ ‰∏çÂèØ‰∏≠Êñ≠ÈòªÂ°ûÊÄÅÔºàTASK_UNINTERRUPTIBLEÔºâÔºöËøõÁ®ãÂ§Ñ‰∫éÊüê‰∏™Á≠âÂæÖÈòüÂàó‰∏≠Ôºå‰∏çËÉΩË¢´‰ø°Âè∑Êàñ‰∏≠Êñ≠Âî§ÈÜíÔºåÂè™ÊúâÁ≠âÂæÖÁöÑËµÑÊ∫êË¢´Êª°Ë∂≥Êó∂ÊâçË¢´Âî§ÈÜí„ÄÇ‰æãÂ¶ÇÂΩìËøõÁ®ãÊâìÂºÄ‰∏Ä‰∏™ËÆæÂ§áÊñá‰ª∂Êó∂Ôºå‰ΩøÁî®TASK_UNINTERRUPTIBLE. ÂÉµÊ≠ªÁä∂ÊÄÅ(TASK_ZOMBIE):ËøõÁ®ãÂ∑≤ÁªèÂÅúÊ≠¢Ôºå‰ΩÜËøòÊ≤°ÊúâÈáäÊîæËøõÁ®ãÊéßÂà∂Âùó ÂÅúÊ≠¢ÊÄÅÔºàTASK_STOPPEDÔºâ:ËØ•Áä∂ÊÄÅË°®Á§∫ËøõÁ®ãÁöÑÊâßË°åË¢´ÊöÇÂÅú„ÄÇ‰æãÂ¶ÇÊ≠£Âú®Êé•ÂèóË∞ÉËØïÁöÑËøõÁ®ãÂ§Ñ‰∫éËøôÁßçÁä∂ÊÄÅ„ÄÇ Ê≠ª‰∫°ÊÄÅ(TASK_DEAD):Â§Ñ‰∫éÂÉµÊ≠ªËøõÁ®ãÁöÑÊéßÂà∂ÂùóÁî±ÂÖ∂Áà∂ËøõÁ®ãÂõûÊî∂ÂêéÁöÑÁä∂ÊÄÅ„ÄÇËøõÁ®ãÊéßÂà∂ÂùóÔºàPCBÔºâ‰ΩúÁî®ÔºöÊèèËø∞ËøõÁ®ãÁä∂ÊÄÅ„ÄÅËµÑÊ∫ê„ÄÅÂíå‰∏éÁõ∏ÂÖ≥ËøõÁ®ãÂÖ≥Á≥ªÁöÑÊï∞ÊçÆÁªìÊûÑ„ÄÇÂàõÂª∫ËøõÁ®ãÊó∂ÂàõÂª∫PCBÔºõËøõÁ®ãÊí§ÈîÄÂêéPCBÂêåÊó∂Êí§ÈîÄ„ÄÇ Ê∫êÁ†ÅÈÉ®ÂàÜËß£ÊûêÊ∫êÁ†Å‰∏ãËΩΩÔºåÂéªLinuxÂÆòÁΩë‰∏ãËΩΩÂç≥ÂèØÔºåÂèØ‰ª•‰∏ãËΩΩÂÜÖÊ†∏‰ª£Á†ÅÔºåÂ¶ÇÊûúÂ´å‰∏ãËΩΩÂ§™ÊÖ¢ÂèØ‰ª•ÂéªÔºöhttp://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/‰∏äÈù¢Ê≤°Êúâ 0.11ÁöÑÂÜÖÊ†∏ÔºåÈúÄË¶ÅÂéªÂÖ∂‰ªñÂú∞Êñπ‰∏ãËΩΩ Êñá‰ª∂Âú®Ôºö$‰Ω†ÁöÑÂÜÖÊ†∏ÁõÆÂΩï$/include/linux/sched.hÂ¶ÇÊûúÊâæ‰∏çÂà∞ ÔºåÂèØ‰ª•Áî®find -name sched.h ÂëΩ‰ª§ÂØªÊâæ Âª∫ËÆÆÁî®Â≠¶‰π†ÁöÑÊó∂ÂÄôÁî®ÔºåLinux‰Ωé‰∏ÄÁÇπÁöÑÁâàÊú¨ÔºåËôΩÁÑ∂Â∞ë‰∫ÜÂæàÂ§öÊñ∞‰∏úË•øÔºå‰ΩÜÊòØÂ≠¶‰π†Ëµ∑Êù•Êõ¥ÁÆÄÂçï„ÄÇLinux 1.0 Ê∫êÁ†ÅÂâçÈù¢‰ªãÁªçÁöÑÂá†ÁßçÁä∂ÊÄÅÁöÑÂÆö‰πâ123456#define TASK_RUNNING 0#define TASK_INTERRUPTIBLE 1#define TASK_UNINTERRUPTIBLE 2#define TASK_ZOMBIE 3#define TASK_STOPPED 4#define TASK_SWAPPING 5 Âà∞‰∫Ü linux 2.6.38,‰ª£Á†ÅÊòéÊòæÂ§çÊùÇ‰∫ÜËÆ∏Â§öÔºåËÄå‰∏î‰ΩøÁî®‰∫åËøõÂà∂ÁöÑÁ¨¨Âá†‰ΩçÊù•Ë°®Á§∫Áä∂ÊÄÅ„ÄÇ123456789101112131415161718192021222324252627#define TASK_RUNNING 0#define TASK_INTERRUPTIBLE 1#define TASK_UNINTERRUPTIBLE 2#define __TASK_STOPPED 4#define __TASK_TRACED 8/* in tsk-&gt;exit_state */#define EXIT_ZOMBIE 16#define EXIT_DEAD 32/* in tsk-&gt;state again */#define TASK_DEAD 64#define TASK_WAKEKILL 128#define TASK_WAKING 256#define TASK_STATE_MAX 512#define TASK_STATE_TO_CHAR_STR "RSDTtZXxKW"extern char ___assert_task_state[1 - 2*!!( sizeof(TASK_STATE_TO_CHAR_STR)-1 != ilog2(TASK_STATE_MAX)+1)];/* Convenience macros for the sake of set_task_state */#define TASK_KILLABLE (TASK_WAKEKILL | TASK_UNINTERRUPTIBLE)#define TASK_STOPPED (TASK_WAKEKILL | __TASK_STOPPED)#define TASK_TRACED (TASK_WAKEKILL | __TASK_TRACED)/* Convenience macros for the sake of wake_up */#define TASK_NORMAL (TASK_INTERRUPTIBLE | TASK_UNINTERRUPTIBLE)#define TASK_ALL (TASK_NORMAL | __TASK_STOPPED | __TASK_TRACED) linux1.0 ÈáåÈù¢ÁöÑPCB ÁªìÊûÑ‰Ωì,ÂÜô‰∫Ü‰∏ÄÈÉ®ÂàÜÂÖ∂‰ªñÔºåÂÖ∑‰ΩìÁöÑËá™Â∑±ÂèØ‰ª•ÂéªÊêúÁ¥¢ sched.h ÁöÑÊ∫êÁ†ÅÂâñÊûêÔºåÂèØ‰ª•Áî®grep -rn &quot;ÂÜÖÊüî&quot;Êü•ÊâæÂáΩÊï∞ÂÆûÁé∞123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119// ÂâçÈù¢ÊâÄ‰ªãÁªçÁöÑ Âá†Áßç Áä∂ÊÄÅ#define TASK_RUNNING 0#define TASK_INTERRUPTIBLE 1#define TASK_UNINTERRUPTIBLE 2#define TASK_ZOMBIE 3#define TASK_STOPPED 4#define TASK_SWAPPING 5#ifndef NULL#define NULL ((void *) 0) //Á©∫ÊåáÈíà#endif#ifdef __KERNEL__//Ë∞ÉÂ∫¶Á®ãÂ∫èÂàùÂßãÂåñÂáΩÊï∞ ÂÆûÁé∞ Âú®Ôºàkernel/sched.cÔºâextern void sched_init(void);//ÊòæÁ§∫extern void show_state(void);// ÂºÇÂ∏∏‰∏≠Êñ≠ÂàùÂßãÂåñÂáΩÊï∞ ÂÆûÁé∞Âú®(kernel/traps.c)extern void trap_init(void);//ËøõÁ®ãË∞ÉÂ∫¶ÂáΩÊï∞„ÄÇÂÆûÁé∞Âú®(kernel/sched.c),asmlinkage void schedule(void);#endif /* __KERNEL__ */struct task_struct &#123;/* these are hardcoded - don't touch */ //ËøêË°åÁä∂ÊÄÅ volatile long state; /* -1 unrunnable, 0 runnable, &gt;0 stopped */ // Êó∂Èó¥Áâá long counter; // ËøêË°å‰ºòÂÖàÊï∞ Ôºå‰ªªÂä°ÂºÄÂßãËøêË°åÊó∂counter = priorityÔºåË∂äÂ§ßËøêË°åË∂äÈïø„ÄÇ long priority; //‰ø°Âè∑„ÄÇÊòØ‰ΩçÂõæÔºåÊØè‰∏™ÊØîÁâπ‰Ωç‰ª£Ë°®‰∏ÄÁßç‰ø°Âè∑Ôºå‰ø°Âè∑ÂÄº=‰ΩçÂÅèÁßªÂÄº+1 unsigned long signal; //ËøõÁ®ã‰ø°Âè∑Â±èËîΩÁ†ÅÔºàÂØπÂ∫î‰ø°Âè∑‰ΩçÂõæÔºâ unsigned long blocked; /* bitmap of masked signals */ unsigned long flags; /* per process flags, defined below */ int errno; int debugreg[8]; /* Hardware debugging registers *//* various fields */ //‰∏ã‰∏Ä‰∏™ ‰ª•Âèä‰∏ä‰∏Ä‰∏™ ËøõÁ®ã struct task_struct *next_task, *prev_task; struct sigaction sigaction[32]; unsigned long saved_kernel_stack; unsigned long kernel_stack_page; int exit_code, exit_signal; int elf_executable:1; int dumpable:1; int swappable:1; int did_exec:1; //‰ª£Á†ÅÊÆµ‰ø°ÊÅØ unsigned long start_code,end_code,end_data,start_brk,brk,start_stack,start_mmap; unsigned long arg_start, arg_end, env_start, env_end; //long pid ËøõÁ®ãÊ†áËØÜÂè∑(ËøõÁ®ãÂè∑) int pid,pgrp,session,leader; int groups[NGROUPS]; /* * pointers to (original) parent process, youngest child, younger sibling, * older sibling, respectively. (p-&gt;father can be replaced with * p-&gt;p_pptr-&gt;pid) */ // p_pptr Áà∂‰∫≤ËøõÁ®ã struct task_struct *p_opptr,*p_pptr, *p_cptr, *p_ysptr, *p_osptr; //Á≠âÂæÖÁöÑÂÑøÂ≠ê struct wait_queue *wait_chldexit; /* for wait4() */ /* * For ease of programming... Normal sleeps don't need to * keep track of a wait-queue: every task has an entry of its own */ // long pid ËøõÁ®ãÊ†áËØÜÂè∑(ËøõÁ®ãÂè∑)„ÄÇ // unsigned short euid ÊúâÊïàÁî®Êà∑id„ÄÇ// unsigned short suid ‰øùÂ≠òÁöÑÁî®Êà∑id„ÄÇ// unsigned short gid ÁªÑÊ†áËØÜÂè∑ÔºàÁªÑidÔºâ„ÄÇ// unsigned short egid ÊúâÊïàÁªÑid„ÄÇ// unsigned short sgid ‰øùÂ≠òÁöÑÁªÑid„ÄÇ unsigned short uid,euid,suid; unsigned short gid,egid,sgid; unsigned long timeout; unsigned long it_real_value, it_prof_value, it_virt_value; unsigned long it_real_incr, it_prof_incr, it_virt_incr;// long utime Áî®Êà∑ÊÄÅËøêË°åÊó∂Èó¥ÔºàÊª¥Á≠îÊï∞Ôºâ„ÄÇ// long stime Á≥ªÁªüÊÄÅËøêË°åÊó∂Èó¥ÔºàÊª¥Á≠îÊï∞Ôºâ„ÄÇ// long cutime Â≠êËøõÁ®ãÁî®Êà∑ÊÄÅËøêË°åÊó∂Èó¥„ÄÇ// long cstime Â≠êËøõÁ®ãÁ≥ªÁªüÊÄÅËøêË°åÊó∂Èó¥„ÄÇ long utime,stime,cutime,cstime,start_time; unsigned long min_flt, maj_flt; unsigned long cmin_flt, cmaj_flt; struct rlimit rlim[RLIM_NLIMITS]; unsigned short used_math; unsigned short rss; /* number of resident pages */ char comm[16]; struct vm86_struct * vm86_info; unsigned long screen_bitmap;/* file system info */ int link_count; int tty; /* -1 if no tty, so it must be signed */ unsigned short umask; struct inode * pwd; struct inode * root; struct inode * executable; struct vm_area_struct * mmap; struct shm_desc *shm; struct sem_undo *semun; struct file * filp[NR_OPEN]; fd_set close_on_exec;/* ldt for this task - used by Wine. If NULL, default_ldt is used */ struct desc_struct *ldt;/* tss for this task */ struct tss_struct tss;#ifdef NEW_SWAP unsigned long old_maj_flt; /* old value of maj_flt */ unsigned long dec_flt; /* page fault count of the last time */ unsigned long swap_cnt; /* number of pages to swap on next pass */ short swap_table; /* current page table */ short swap_page; /* current page */#endif NEW_SWAP struct vm_area_struct *stk_vma;&#125;; ÈÄöÂ∏∏PCB ‰ºöÊúâ ÂéüËØ≠ÔºöÂÆåÊàêÊüêÁßçÁâπÂÆöÂäüËÉΩÁöÑ‰∏ÄÊÆµÁ®ãÂ∫èÔºåÂÖ∑Êúâ‰∏çÂèØÂàÜÂâ≤ÊÄßÊàñ‰∏çÂèØ‰∏≠Êñ≠ÊÄßÔºåÂç≥ÂéüËØ≠ÁöÑÊâßË°åÂøÖÈ°ªÊòØËøûÁª≠ÁöÑÔºåÂú®ÊâßË°åËøáÁ®ã‰∏≠‰∏çÂÖÅËÆ∏Ë¢´‰∏≠Êñ≠„ÄÇÂèàÁß∞ÂéüÂ≠êÊìç‰Ωú„ÄÇ ËøõÁ®ãÊéßÂà∂Êìç‰ΩúÂÆåÊàêËøõÁ®ãÂêÑÁä∂ÊÄÅ‰πãÈó¥ÁöÑËΩ¨Êç¢ÔºåÁî±ÂÖ∑ÊúâÁâπÂÆöÂäüËÉΩÁöÑÂéüËØ≠ÔºàÂÖ∂ÂÆûÂ∞±ÊòØÁ®ãÂ∫èÔºåÂè™ÊòØËøô‰∫õÁ®ãÂ∫è‰∏çËÆ∏‰∏éË¢´‰∏≠Êñ≠ÔºâÂÆåÊàê„ÄÇÂÖ≥‰∫éËøõÁ®ãÊéßÂà∂ÁöÑÂéüËØ≠Â¶Ç‰∏ãÔºö ËøõÁ®ãÂàõÂª∫ÂéüËØ≠ ËøõÁ®ãÊí§ÈîÄÂéüËØ≠ ÈòªÂ°ûÂéüËØ≠ Âî§ÈÜíÂéüËØ≠ ÊøÄÊ¥ªÂéüËØ≠ ÊîπÂèòËøõÁ®ã‰ºòÂÖàÁ∫ß ÊòØÂê¶ ÁúãËßÅsched.hÈáåÈù¢Âèà‰∏ÄÈÉ®ÂàÜ ÂáΩÊï∞ÁöÑÂ£∞Êòé„ÄÇÂú®sched.cÈáåÈù¢Êúâ ÂÖ∑‰ΩìÁöÑÂÆûÁé∞ sched_initË∞ÉÂ∫¶ÂàùÂßãÂåñÔºåÂàùÂßãÂåñÂæàÂ§öÈÉΩÁúã‰∏çÊáÇÔºåÁü•ÈÅì‰ªñÊòØÂπ≤Âï•ÁöÑÂ∞±Ë°å„ÄÇ1234567891011121314151617181920212223242526272829sched_init(void)&#123; int i; struct desc_struct * p; bh_base[TIMER_BH].routine = timer_bh; if (sizeof(struct sigaction) != 16) panic("Struct sigaction MUST be 16 bytes"); set_tss_desc(gdt+FIRST_TSS_ENTRY,&amp;init_task.tss); set_ldt_desc(gdt+FIRST_LDT_ENTRY,&amp;default_ldt,1); set_system_gate(0x80,&amp;system_call); p = gdt+2+FIRST_TSS_ENTRY; for(i=1 ; i&lt;NR_TASKS ; i++) &#123; task[i] = NULL; p-&gt;a=p-&gt;b=0; p++; p-&gt;a=p-&gt;b=0; p++; &#125;/* Clear NT, so that we won't have troubles with that later on */ __asm__("pushfl ; andl $0xffffbfff,(%esp) ; popfl"); load_TR(0); load_ldt(0); outb_p(0x34,0x43); /* binary, mode 2, LSB/MSB, ch 0 */ outb_p(LATCH &amp; 0xff , 0x40); /* LSB */ outb(LATCH &gt;&gt; 8 , 0x40); /* MSB */ if (request_irq(TIMER_IRQ,(void (*)(int)) do_timer)!=0) panic("Could not allocate timer IRQ!");&#125; show_taskÂíåshow_stateÁùÄ‰∏§‰∏™‰∏çÁî®Â§öËØ¥Âêß123456789101112131415161718192021222324252627282930313233343536373839static void show_task(int nr,struct task_struct * p)&#123; static char * stat_nam[] = &#123; "R", "S", "D", "Z", "T", "W" &#125;; // 6 ÁßçÁä∂ÊÄÅ printk("%-8s %3d ", p-&gt;comm, (p == current) ? -nr : nr); if (((unsigned) p-&gt;state) &lt; sizeof(stat_nam)/sizeof(char *)) printk(stat_nam[p-&gt;state]); else printk(" "); if (p == current) printk(" current "); else printk(" %08lX ", ((unsigned long *)p-&gt;tss.esp)[3]); printk("%5lu %5d %6d ", p-&gt;tss.esp - p-&gt;kernel_stack_page, p-&gt;pid, p-&gt;p_pptr-&gt;pid); if (p-&gt;p_cptr) printk("%5d ", p-&gt;p_cptr-&gt;pid); else printk(" "); if (p-&gt;p_ysptr) printk("%7d", p-&gt;p_ysptr-&gt;pid); else printk(" "); if (p-&gt;p_osptr) printk(" %5d\n", p-&gt;p_osptr-&gt;pid); else printk("\n");&#125;void show_state(void) //Ë∞ÉÁî®‰∏äÈù¢ÈÇ£‰∏™‰ø°ÊÅØ&#123; int i; printk(" free sibling\n"); printk(" task PC stack pid father child younger older\n"); for (i=0 ; i&lt;NR_TASKS ; i++) if (task[i]) show_task(i,task[i]);&#125; ÈáçÂ§¥Êàè]]></content>
      <categories>
        <category>Êìç‰ΩúÁ≥ªÁªü</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ËøõÁ®ã</tag>
        <tag>Á∫øÁ®ã</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Splay Ê†ëÂ≠¶‰π†Á¨îËÆ∞]]></title>
    <url>%2F2019%2F11%2F12%2FSplay-%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[‰ªãÁªçSplay Ê†ë ÊòØ‰∏ÄÁßçÂπ≥Ë°°‰∫åÂèâÊ†ëÔºåÂÆûÁé∞ÊØîËæÉÁÆÄÂçïÔºåÂèØ‰ª•Âú®ÂùáÊëäÂ§çÊùÇÂ∫¶$log(n)$ÂØπÊ†ëËøõË°å‰øÆÊîπÂíåÊü•ËØ¢„ÄÇÂú®Â≠¶Ëøô‰∏™‰πãÂâçÂæóÁü•ÈÅì‰ªÄ‰πàÊòØ‰∫åÂèâÊêúÁ¥¢Ê†ëÔºå‰∫åÂèâÊêúÁ¥¢Ê†ëÂæàÁÆÄÂçïÔºåÂ∞±ÊòØÂú®Ê†ë‰∏ä‰∏çÊñ≠ÊääÊØî‰ªñÂ§ßÁöÑÂÑøÂ≠êÂæÄÂè≥ËæπÊîæÔºåÊääÊØî‰ªñÂ∞èÁöÑÂÑøÂ≠êÂæÄÂ∑¶ËæπÊîæ„ÄÇÂæàÊòæÁÑ∂ËøôÁßçÁ≠ñÁï•ÊòØÂèØ‰ª•Ë¢´Âç°Âà∞$O(n)$ÁöÑÂ§çÊùÇÂ∫¶ÔºåÊâÄ‰ª•Â∞±Âá∫Áé∞ÂØπËøôÈ¢óÊ†ëËøõË°å‰øÆÊîπÁöÑÂπ≥Ë°°‰∫åÂèâÊ†ëÔºåSplay Ê†ëÂ∞±ÊòØÂÖ∂‰∏≠‰∏ÄÁßç ÂÆûÁé∞ÂÆûÁé∞ÁΩë‰∏äÂ∑≤ÁªèÊúâÂæàÂ§ö‰∫ÜÔºåÊàëÊ†πÊçÆËá™Â∑±ÁêÜËß£ÔºåÂÜô‰∏Ä‰∫õËÆ∞ÂΩï„ÄÇ ÂÖàËØ¥‰∏Ä‰∏ãÂü∫Á°ÄÁöÑÈ¶ñÂÖàÊòØÂÆö‰πâÂèòÈáè123456int ch[maxn][2];//Â∑¶Âè≥ÂÑøÂ≠êint fa[maxn]; //Áà∂‰∫≤int size[maxn]; //Â≠óÊ†ëÂ§ßÂ∞èint cnt[maxn]; //ÂÖ≥ÈîÆÂ≠óÂá∫Áé∞Ê¨°Êï∞int key[maxn]; //ÂÖ≥ÈîÆÂ≠óint sz,root; // Ê†ëÁöÑÂ§ßÂ∞è Ê†πËäÇÁÇπ ÁÑ∂ÂêéÊòØÂá†‰∏™ÁÆÄÂçïÁöÑÂáΩÊï∞ÔºåÊ∏ÖÈô§ÂíåÂà§Êñ≠ÊòØ‰∏çÊòØÂè≥ÂÑøÂ≠ê1234567inline void clear(int x)&#123; ch[x][0]=ch[x][1]=fa[x]=size[x]=cnt[x]=key[x];&#125;inline int get(int x)&#123; return ch[fa[x]][1]==x;&#125; Âõ†‰∏∫Êõ¥Êñ∞‰πãÂêéËäÇÁÇπÁöÑÂ∑¶Âè≥ÂÑøÂ≠ê‰ºöÂèòÔºåÊâÄ‰ª•Â∞±È°∂‰∏Ä‰∏™Êõ¥Êñ∞ÂáΩÊï∞123456789inline void update(int x)&#123; if(x)&#123; size[x]=cnt[x]; if(ch[x][0]) size[x]+=size[ch[x][0]]; if(ch[x][1]) size[x]+=size[ch[x][1]]; &#125;&#125; Ê†∏ÂøÉÁÆóÊ≥ïÔºö rotateÔºåÊóãËΩ¨Êìç‰Ωú„ÄÇÈÄâÊã©‰πüÂæàÁÆÄÂçïÔºåÂú®ÁΩë‰∏äÁõó‰∫ÜÂ§ß‰Ω¨ÁöÑÂõæ„ÄÇÁúã‰∫ÜËøô‰∏§‰∏™ÂõæÔºåÂ∫îËØ•Â∞±ÊòéÁôΩ‰∫ÜÂêßÔºåÊóãËΩ¨Â∞±ÊòØËøô‰πàÁÆÄÂçï„ÄÇÂ¶ÇÊûúÊòØÂè≥ÂÑøÂ≠êÂ∞±Ë¶ÅÊç¢‰∏Ä‰∏ãÊóãËΩ¨„ÄÇ123456789101112inline void rotate(int x)&#123; int old=fa[x],oldf=fa[old],which=get(x); ch[old][which]=ch[x][which^1]; // ÊòØÂÅöÂÑøÂ≠ê ÊääËá™Â∑±Âè≥ÂÑøÂ≠ê ÁªôÁà∂‰∫≤ÁöÑÂ∑¶ËÄ≥Â≠ê Âê¶ÂàôÂèç‰πã fa[ch[old][which]]=old; // Êää‰∫§Êç¢ÁöÑÂÑøÂ≠êÁà∂‰∫≤ËÆæÁΩÆÊàêÁà∂‰∫≤ fa[old]=x; //ÊääÁà∂‰∫≤ËäÇÁÇπÂèòÂÑøÂ≠êËäÇÁÇπ ch[x][which^1]=old; fa[x]=oldf; //ÊääËá™Â∑±Áà∂‰∫≤ËÆæÁΩÆÊàêÁà∂‰∫≤ÁöÑÁà∂‰∫≤ if (oldf) ch[oldf][ch[oldf][1]==old]=x; // ÂèòÊàêÁà∂‰∫≤ÁöÑÁà∂‰∫≤ËäÇÁÇπÁöÑÂÑøÂ≠ê update(old);update(x);&#125; ÁÑ∂ÂêéÂ∞±ÊòØ‰º∏Â±ïÊìç‰ΩúÔºåËøô‰∏™ÁÆóÊ≥ïËÉΩÂÆûÁé∞ ÂùáÊëä$O(log(n))$ÁöÑÂ§çÊùÇÂ∫¶ÔºåÈù†ÁöÑÂ∞±ÊòØËøô‰∏™„ÄÇÊØèÊ¨°Êü•ËØ¢‰∏Ä‰∏™ÂÄºÔºåÈÄöËøá‰∏çÊñ≠ÁöÑrotate Êää‰ªñÂèò‰∏∫Ê†πËäÇÁÇπÔºåÂêåÊ†∑ÔºåÊØèÊ¨°Êü•ËØ¢ÈÉΩ‰ºöÊääË∑ØÂæÑ‰∏äÁöÑÊ∑±Â∫¶ÂáèÂ∞è„ÄÇËøô‰∏™Ëá™Â∑±Áîª‰∏™ÂõæÁêÜËß£‰∏Ä‰∏ã„ÄÇ„ÄÇ„ÄÇ„ÄÇ123456inline void splay(int x)&#123; for (int p;(p=fa[x]);rotate(x)) if (fa[p]) rotate((get(x)==get(p)?p:x));// Âà§Êñ≠‰∏âÁÇπÂÖ±Á∫øÂ∞±ÂÖàÈÄâÊã©Áà∂‰∫≤Ôºå‰øùËØÅÊ∂àÂáèÊ∑±Â∫¶ root=x;&#125; ËøôÂú∞ÊñπÁêÜËß£‰∫ÜÂêéÈù¢Â∞±ÈÉΩÊòØÊâìÈÖ±Ê≤πÁöÑËßíËâ≤‰∫Ü„ÄÇÊü•Êâæ12345678910111213141516inline int find(int v)&#123; int ans=0,now=root; while (1)&#123; if (v&lt;key[now]) //Â¶ÇÊûúÂ∞è‰∫é Â∞±ÂæÄÂ∑¶Êâæ now=ch[now][0]; else&#123; ans+=(ch[now][0]?size[ch[now][0]]:0) //Â§ß‰∫éÂä†‰∏äÂ∑¶Â≠êÊ†ëÁöÑÂ§ßÂ∞è if (v==key[now]) &#123; splay(now); return ans+1; &#125; ans+=cnt[now]; now=ch[now][1]; &#125; &#125;&#125; Êü•ËØ¢Á¨¨ x Â∞è12345678910111213inline int findx(int x)&#123; int now=root; while (1)&#123; if (ch[now][0]&amp;&amp;x&lt;=size[ch[now][0]]) now=ch[now][0]; else&#123; int temp=(ch[now][0]?size[ch[now][0]]:0)+cnt[now]; if (x&lt;=temp) return key[now]; x-=temp;now=ch[now][1]; &#125; &#125;&#125; ÊèíÂÖ•1234567891011121314151617181920212223242526272829303132333435inline void insert(int x)&#123; if(root==0)&#123; //root=0Áõ∏ÂΩì‰∫é Âª∫Ê†ë sz++; ch[sz][0]=ch[sz][1]=fa[sz]=0; key[sz]=x; cnt[sz]=1; size[sz]=1; root=sz; return; &#125; int now=root,p=0; while (1)&#123; if(key[now]==x)&#123; //Â¶ÇÊûúÂ∑≤ÁªèÂ≠òÂú®Â∞±Áõ¥Êé•+1 cnt[now]++; update(now); update(p); splay(now); break; &#125; p=now; now=ch[now][key[now]&lt;x]; if (now==0)&#123; //Â¶ÇÊûú‰∏çÂ≠òÂú®Â∞±Âª∫‰∏Ä‰∏™ËäÇÁÇπ sz++; ch[sz][0]=ch[sz][1]=0; key[sz]=x; size[sz]=1; cnt[sz]=1; fa[sz]=p; ch[p][key[p]&lt;x]=sz; update(p); splay(sz); break; &#125; &#125;&#125; Êü•ËØ¢ÂâçÈ©±ÂíåÂêéÁªß1234567891011inline int pre()&#123; int now=ch[root][0]; while (ch[now][1]) now=ch[now][1]; return now;&#125;inline int next()&#123; int now=ch[root][1]; while (ch[now][0]) now=ch[now][0]; return now;&#125; Âà†Èô§Êìç‰Ωú Ëøô‰∏™Âú∞ÊñπËß£Èáä‰∏Ä‰∏ãÔºåÊúâ‰∏§‰∏™ÂÑøÂ≠êÁöÑÊÉÖÂÜµÔºåÈ¶ñÂÖàfind ÊääÂÄºÁõ¥Êé•ÊèêÂà∞Ê†πËäÇÁÇπÔºåÂ¶ÇÊûúË¶ÅÂà†Èô§Ëøô‰∏™ËäÇÁÇπÔºå‰πüÂ∞±ÊòØËøô‰∏™ÂÄºÁöÑ‰∏™Êï∞ÊòØ1ÁöÑÊÉÖÂÜµÔºåËøô‰∏™Êó∂ÂÄôÁõ¥Êé•Êää‰ªñÁöÑÂâçÈ©±ÊèêÂà∞Ê†πËäÇÁÇπÔºåÁÑ∂ÂêéÂà†‰∫ÜÂéüÊù•ÈÇ£‰∏™ËäÇÁÇπ„ÄÇ ÊääÂâçÈ©±ÊèêÂà∞Ê†πËäÇÁÇπÊúÄÂêé‰∏ÄÂÆöÊòØ‰∏ãÂõæÔºåË¶ÅÂà†Èô§ÁöÑÈÇ£‰∏™ÁÇπ‰∏ÄÂÆöÊ≤°ÊúâÂ∑¶ÂÑøÂ≠êÔºåÊâÄ‰ª•ÂèØ‰ª•Áõ¥Êé•Âà†Èô§„ÄÇ12345678910111213141516171819202122232425inline void del(int x)&#123; int whatever=find(x); if (cnt[root]&gt;1) &#123;cnt[root]--;update(root);return;&#125; //Only One Point if (!ch[root][0]&amp;&amp;!ch[root][1]) &#123;clear(root);root=0;return;&#125; //Only One Child if (!ch[root][0])&#123; int oldroot=root; root=ch[root][1]; fa[root]=0; clear(oldroot); return; &#125; else if (!ch[root][1])&#123; int oldroot=root;root=ch[root][0];fa[root]=0;clear(oldroot);return; &#125; //Two Children int leftbig=pre(),oldroot=root; splay(leftbig); fa[ch[oldroot][1]]=root; ch[root][1]=ch[oldroot][1]; clear(oldroot); update(root); return;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Êï∞ÊçÆÁªìÊûÑ</category>
      </categories>
      <tags>
        <tag>Ê†ë</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FWTÂø´ÈÄüÊ≤ÉÂ∞î‰ªÄÂèòÊç¢-ÁÆÄËß£ÂèäËØÅÊòé]]></title>
    <url>%2F2019%2F09%2F09%2FFWT%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2-%E7%AE%80%E8%A7%A3%E5%8F%8A%E8%AF%81%E6%98%8E%2F</url>
    <content type="text"><![CDATA[FWTÁÆÄ‰ªãFWT Áî®Êù•Ê±ÇÂç∑ÁßØÔºåÂíåFFTÂæàÂÉè.‰∏â‰∏™ÂÖ¨Âºè C_k=\sum_{i|j=k}A_i * B_j C_k=\sum_{i\&j=k}A_i * B_j C_k=\sum_{i\ xor\ j=k}A_i * B_j‰∏âÁßçÂç∑ÁßØÔºåÂØπ‰∫é‰∏âÁßçÂè™ËØ¶Ëß£ÂÖ∂‰∏≠‰∏ÄÁßç„ÄÇ 1.Êàñ(or)Âç∑ÁßØÊ†πÊçÆÂØπFTTÁöÑÁêÜËß£ÔºåÈ¶ñÂÖàÁ¨¨‰∏ÄÊ≠•ËΩ¨Êç¢ÊàêÁÇπÂÄºÔºåÂØπ$C_k=\sum_{i\ +\ j=k}A_i * B_j$Êù•ËØ¥ÔºåÂ∞±ÊúâÁÇπÂÄºÁõ∏ÂêåÁõ∏‰πò$y_c=y_a * y_b$ y Ë°®Á§∫Âú®ÂèñÊüê‰∏™ÂÄºÁöÑÊó∂ÂÄôÂ§öÈ°πÂºèÁöÑÂèñÂÄº„ÄÇ ÂØπ‰∫é‰∏äËø∞Ëøô‰∏™Âç∑ÁßØÊòéÊòæ‰∏çÂêàÈÄÇÔºåÊâÄ‰ª•Êàë‰ª¨ÈúÄË¶ÅÊûÑÈÄ†‰∏Ä‰∏™Êñ∞ÁöÑÂºèÂ≠ê$FWT$Êª°Ë∂≥$FWT(C)=FWT(A) * FWT(B)$„ÄÇÊª°Ë∂≥Êàñ(or)Âç∑ÁßØÁöÑÂºèÂ≠êÂ∞±ÊòØ$FWT(A)[i]=\sum_{j|i=i}A[j]$,Â¶Ç‰ΩïÊù•ÁöÑÂ∞±‰∏çÁü•ÈÅì‰∫ÜÔºå‰ΩÜÊòØÂèØ‰ª•ËØÅÊòéËøô‰∏™ÊòØÂØπÁöÑ„ÄÇÂ∞±Áõ∏ÂΩì‰∫é$FWT(A|B)=FWT(A) * FWT(B)$,ÂØπ‰∫éÂÖ¨ÂºèËØÅÊòéÔºåËøò‰∏çÊ∏ÖÊ•öÔºå‰ΩÜÊòØÊö¥ÂäõÊâì‰∏™Ë°®ÔºåÁî®Êï∞Â≠¶ÂΩíÁ∫≥Ê≥ïËØÅÊòéËßÅÂ§ß‰Ω¨ÂçöÂÆ¢ÔºåÂÄíÊòØÊ≤°ÊúâÈîô. \sum_{i|k=k}C_i=\sum_{i|j=k}(\sum_{t|i=i}A_t*\sum_{p|j=j}B_p) \sum_{i|k=k}(\sum_{o|l=i}A_o * B_l)=\sum_{i|j=k}((\sum_{t|i=i}A_t) * (\sum_{p|j=j}B_p))‰∏äÂºè‰∏çÈöæÁúãÂá∫ÊòØÁõ∏ÂêåÁöÑ,ÂèØ‰ª•ÁÆÄÂçïÁêÜËß£‰∏ãÔºåÂè≥ËæπÊãÜÂºÄÈáåÈù¢ÁöÑ$A_t * B_p$ËÇØÂÆöÈÉΩÊòØÂú®Â∑¶ËæπÁöÑÂ≠êÈõÜÂÜÖ„ÄÇ Áü•ÈÅì‰∏äËø∞Êª°Ë∂≥‰∫ÜÔºåÂ∞±ÁÆÄÂçï‰∫Ü„ÄÇÂØπ‰∫éFFTÂÖàÂèòÊàêÁÇπÈõÜ,ÁÑ∂ÂêéÈÄÜÂèòÊç¢ÂõûÊù•Ôºå‰∏äËø∞ÂêåFFTÔºåÂÖàÂèòÊàê$FWT$,ÁÑ∂ÂêéÈÄÜÂèòÊç¢ÂõûÊù•„ÄÇÈÇ£‰πàÈóÆÈ¢òÊù•‰∫ÜÔºåÊ±Ç$FWT$,‰∏ç‰πüÊòØ$O(n^2)$,Ëøô‰∏™Êó∂ÂÄôÂ∞±ÊòØFWTÁöÑÊ†∏ÂøÉ‰∫Ü„ÄÇÂØπ‰∫éÊàñÂç∑ÁßØÁöÑ$FWT$ÊúâÂ¶Ç‰∏ãÂºèÂ≠ê FWT(A) = \begin{cases} FWT(A_0,A_1+A_0) & [A]>1\\ A, & [A]=1 \end{cases}$A_0$‰∏∫ÂâçÂçäÊÆµÔºå$A_1$‰∏∫ÂêéÂçäÊÆµ„ÄÇËøô‰∏™ÂæàÂÆπÊòìËØÅÊòéÔºåÂ∞±ÂÅáËÆæÊúâ4È°π$\{a_0,a_1,a_2,a_3\}$,ÁÑ∂Âêé‰ΩøÁî®ÂàÜÊ≤ªÂ§ÑÁêÜÁ¨¨‰∏ÄÊ¨°ÔºåÂèØ‰ª•ÂæóÂà∞$\{a_0,a_0+a_1,a_2,a_2+a_3\}$ÔºåÁÑ∂ÂêéÁ¨¨‰∫åÊ¨°Â∞±ÊòØ$\{a_0,a_0+a_1,a_0+a_2,a_0+a_1+a_2+a_3\}$Ôºå$A$Ê±ÇÂÆå‰∫ÜÔºå‰∏æ‰∫ÜËøô‰∏™Ê†óÂ≠êÂ∫îËØ•Â∞±ÊòéÁôΩ‰∫ÜÔºåËøô‰∏™$A$ÁöÑÈïøÂ∫¶Ë¶ÅÊòØ$2^k$,Ëøô‰∏™ÂæàÂÆπÊòìËß£ÂÜ≥Ôºå‰∏çË∂≥ÁöÑÂú∞ÊñπË°•0Â∞±Ë°å‰∫Ü„ÄÇÈÄÜÂèòÊç¢Â∞±ÊòØÊää+ÂèòÊàê-Â∞±Â•Ω‰∫Ü„ÄÇ 2.Âíå(and)Âç∑ÁßØËøô‰∫õÈÉΩÁÆÄÂçïËøá‰∏Ä‰∏ã$FWT$ÂºèÂ≠ê‰∏∫$FWT(A)[i]=\sum_{j\&amp;i=i}A[j]$ÊúâÂ¶Ç‰∏ãÂºèÂ≠ê FWT(A)=\begin{cases}(FWT(A_0+A_1),FWT(A_1)) & [A]\gt1 \\ A & [A]=1\end{cases}3.ÂºÇÊàñ(xor)Âç∑ÁßØÂØπ‰∫éÂºÇÊàñÂç∑ÁßØÊúâÈÇ£‰πà‰∏ÄÁÇπ‰∏ç‰∏ÄÊ†∑ÔºåÊûÑÂª∫ÁöÑÂºèÂ≠êÊúâÁÇπÂ∑ÆË∑ù„ÄÇ$FWT$ÂºèÂ≠ê‰∏∫$FWT(A)[i]=\sum_{i=0}^{n}=(-1)^{|(i|x)|}A[j]$ |x| ‰∫åËøõÂà∂1ÁöÑ‰∏™Êï∞ FWT(A)=\begin{cases}(FWT(A_0)+FWT(A_1),FWT(A_0)-FWT(A_1)) & n>1\\A & [A]=1\end{cases}ÂØπ‰∫éËøô‰∏™ÁöÑÈÄÜÂèòÊç¢ÊúâÁÇπÂ∑ÆÂà´ IFWT(A)=(\frac{IFWT(A_0)+IFWT(A_1)}{2},\frac{IFWT(A_0)-IFWT(A_1)}{2})‰∏çÁî®ÂèòÁ¨¶Âè∑Áõ¥Êé•Èô§2Â∞±Ë°å‰∫Ü„ÄÇ]]></content>
      <categories>
        <category>ACM</category>
        <category>Êï∞ËÆ∫</category>
      </categories>
      <tags>
        <tag>FFT/NTT/FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ê†ëÈìæÂâñÂàÜÂéüÁêÜÂíåÂÆûÁé∞]]></title>
    <url>%2F2019%2F08%2F24%2F%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[ËΩ¨Ëá™Â§ß‰Ω¨: bananananaÂè¶‰∏Ä‰ΩçÂ§ß‰Ω¨:ivanovcraft Ê†ëÈìæÂâñÂàÜÂéüÁêÜÂíåÂÆûÁé∞Ê†ëÈìæÂâñÂàÜÂ∞±ÊòØÂ∞ÜÊ†ëÂàÜÂâ≤ÊàêÂ§öÊù°ÈìæÔºåÁÑ∂ÂêéÂà©Áî®Êï∞ÊçÆÁªìÊûÑÔºàÁ∫øÊÆµÊ†ë„ÄÅÊ†ëÁä∂Êï∞ÁªÑÁ≠âÔºâÊù•Áª¥Êä§Ëøô‰∫õÈìæ„ÄÇ È¶ñÂÖàÂ∞±ÊòØ‰∏Ä‰∫õÂøÖÈ°ªÁü•ÈÅìÁöÑÊ¶ÇÂøµÔºöÈáçÁªìÁÇπÔºöÂ≠êÊ†ëÁªìÁÇπÊï∞ÁõÆÊúÄÂ§öÁöÑÁªìÁÇπÔºõËΩªËäÇÁÇπÔºöÁà∂‰∫≤ËäÇÁÇπ‰∏≠Èô§‰∫ÜÈáçÁªìÁÇπ‰ª•Â§ñÁöÑÁªìÁÇπÔºõÈáçËæπÔºöÁà∂‰∫≤ÁªìÁÇπÂíåÈáçÁªìÁÇπËøûÊàêÁöÑËæπÔºõËΩªËæπÔºöÁà∂‰∫≤ËäÇÁÇπÂíåËΩªËäÇÁÇπËøûÊàêÁöÑËæπÔºõÈáçÈìæÔºöÁî±Â§öÊù°ÈáçËæπËøûÊé•ËÄåÊàêÁöÑË∑ØÂæÑÔºõËΩªÈìæÔºöÁî±Â§öÊù°ËΩªËæπËøûÊé•ËÄåÊàêÁöÑË∑ØÂæÑÔºõÊ†ëÈìæÂâñÂàÜ ÊØîÂ¶Ç‰∏äÈù¢ËøôÂπÖÂõæ‰∏≠ÔºåÁî®ÈªëÁ∫øËøûÊé•ÁöÑÁªìÁÇπÈÉΩÊòØÈáçÁªìÁÇπÔºåÂÖ∂‰ΩôÂùáÊòØËΩªÁªìÁÇπÔºå2-11Â∞±ÊòØÈáçÈìæÔºå2-5Â∞±ÊòØËΩªÈìæÔºåÁî®Á∫¢ÁÇπÊ†áËÆ∞ÁöÑÂ∞±ÊòØËØ•ÁªìÁÇπÊâÄÂú®ÈìæÁöÑËµ∑ÁÇπÔºå‰πüÂ∞±ÊòØÊàë‰ª¨üëáÊèêÂà∞ÁöÑtopÁªìÁÇπÔºåËøòÊúâÊØèÊù°ËæπÁöÑÂÄºÂÖ∂ÂÆûÊòØËøõË°ådfsÊó∂ÁöÑÊâßË°åÂ∫èÂè∑„ÄÇ ÁÆóÊ≥ï‰∏≠ÂÆö‰πâ‰∫Ü‰ª•‰∏ãÁöÑÊï∞ÁªÑÁî®Êù•Â≠òÂÇ®‰∏äËæπÊèêÂà∞ÁöÑÊ¶ÇÂøµÔºö12345678ÂêçÁß∞ Ëß£Èáäsiz[u] ‰øùÂ≠ò‰ª•u‰∏∫Ê†πÁöÑÂ≠êÊ†ëËäÇÁÇπ‰∏™Êï∞top[u] ‰øùÂ≠òÂΩìÂâçËäÇÁÇπÊâÄÂú®ÈìæÁöÑÈ°∂Á´ØËäÇÁÇπson[u] ‰øùÂ≠òÈáçÂÑøÂ≠êdep[u] ‰øùÂ≠òÁªìÁÇπuÁöÑÊ∑±Â∫¶ÂÄºfaz[u] ‰øùÂ≠òÁªìÁÇπuÁöÑÁà∂‰∫≤ËäÇÁÇπtid[u] ‰øùÂ≠òÊ†ë‰∏≠ÊØè‰∏™ËäÇÁÇπÂâñÂàÜ‰ª•ÂêéÁöÑÊñ∞ÁºñÂè∑ÔºàDFSÁöÑÊâßË°åÈ°∫Â∫èÔºârnk[u] ‰øùÂ≠òÂΩìÂâçËäÇÁÇπÂú®Ê†ë‰∏≠ÁöÑ‰ΩçÁΩÆ Èô§Ê≠§‰πãÂ§ñÔºåËøòÂåÖÊã¨‰∏§ÁßçÊÄßË¥®ÔºöÂ¶ÇÊûú(u, v)ÊòØ‰∏ÄÊù°ËΩªËæπÔºåÈÇ£‰πàsize(v) &lt; size(u)/2Ôºõ‰ªéÊ†πÁªìÁÇπÂà∞‰ªªÊÑèÁªìÁÇπÁöÑË∑ØÊâÄÁªèËøáÁöÑËΩªÈáçÈìæÁöÑ‰∏™Êï∞ÂøÖÂÆöÈÉΩÂ∞è‰∏éO(logn)ÔºõÈ¶ñÂÖàÂÆö‰πâ‰ª•‰∏ãÊï∞ÁªÑÔºö123456789const int MAXN = (100000 &lt;&lt; 2) + 10;//Heavy-light Decomposition STARTS FORM HEREint siz[MAXN];//number of sonint top[MAXN];//top of the heavy linkint son[MAXN];//heavy son of the nodeint dep[MAXN];//depth of the nodeint faz[MAXN];//father of the nodeint tid[MAXN];//ID -&gt; DFSIDint rnk[MAXN];//DFSID -&gt; ID ÁÆóÊ≥ïÂ§ßËá¥ÈúÄË¶ÅËøõË°å‰∏§Ê¨°ÁöÑDFSÔºåÁ¨¨‰∏ÄÊ¨°DFSÂèØ‰ª•ÂæóÂà∞ÂΩìÂâçËäÇÁÇπÁöÑÁà∂‰∫≤ÁªìÁÇπÔºàfazÊï∞ÁªÑÔºâ„ÄÅÂΩìÂâçÁªìÁÇπÁöÑÊ∑±Â∫¶ÂÄºÔºàdepÊï∞ÁªÑÔºâ„ÄÅÂΩìÂâçÁªìÁÇπÁöÑÂ≠êÁªìÁÇπÊï∞ÈáèÔºàsizeÊï∞ÁªÑÔºâ„ÄÅÂΩìÂâçÁªìÁÇπÁöÑÈáçÁªìÁÇπÔºàsonÊï∞ÁªÑÔºâ12345678910111213141516171819202122232425void dfs1(int u, int father, int depth) &#123; /* * u: ÂΩìÂâçÁªìÁÇπ * father: Áà∂‰∫≤ÁªìÁÇπ * depth: Ê∑±Â∫¶ */ // Êõ¥Êñ∞dep„ÄÅfaz„ÄÅsizÊï∞ÁªÑ dep[u] = depth; faz[u] = father; siz[u] = 1; // ÈÅçÂéÜÊâÄÊúâÂíåÂΩìÂâçÁªìÁÇπËøûÊé•ÁöÑÁªìÁÇπ for (int i = head[u]; i; i = edg[i].next) &#123; int v = edg[i].to; // Â¶ÇÊûúËøûÊé•ÁöÑÁªìÁÇπÊòØÂΩìÂâçÁªìÁÇπÁöÑÁà∂‰∫≤ÁªìÁÇπÔºåÂàô‰∏çÂ§ÑÁêÜ if (v != faz[u]) &#123; dfs1(v, u, depth + 1); // Êî∂ÊïõÁöÑÊó∂ÂÄôÂ∞ÜÂΩìÂâçÁªìÁÇπÁöÑsizÂä†‰∏äÂ≠êÁªìÁÇπÁöÑsiz siz[u] += siz[v]; // Â¶ÇÊûúÊ≤°ÊúâËÆæÁΩÆËøáÈáçÁªìÁÇπsonÊàñËÄÖÂ≠êÁªìÁÇπvÁöÑsizÂ§ß‰∫é‰πãÂâçËÆ∞ÂΩïÁöÑÈáçÁªìÁÇπsonÔºåÂàôËøõË°åÊõ¥Êñ∞ if (son[u] == -1 || siz[v] &gt; siz[son[u]]) &#123; son[u] = v; &#125; &#125; &#125;&#125; Á¨¨‰∫åÊ¨°DFSÁöÑÊó∂ÂÄôÂàôÂèØ‰ª•Â∞ÜÂêÑ‰∏™ÈáçÁªìÁÇπËøûÊé•ÊàêÈáçÈìæÔºåËΩªËäÇÁÇπËøûÊé•ÊàêËΩªÈìæÔºåÂπ∂‰∏îÂ∞ÜÈáçÈìæÔºàÂÖ∂ÂÆûÂ∞±ÊòØ‰∏ÄÊÆµÂå∫Èó¥ÔºâÁî®Êï∞ÊçÆÁªìÊûÑÔºà‰∏ÄËà¨ÊòØÊ†ëÁä∂Êï∞ÁªÑÊàñÁ∫øÊÆµÊ†ëÔºâÊù•ËøõË°åÁª¥Êä§ÔºåÂπ∂‰∏î‰∏∫ÊØè‰∏™ËäÇÁÇπËøõË°åÁºñÂè∑ÔºåÂÖ∂ÂÆûÂ∞±ÊòØDFSÂú®ÊâßË°åÊó∂ÁöÑÈ°∫Â∫èÔºàtidÊï∞ÁªÑÔºâÔºå‰ª•ÂèäÂΩìÂâçËäÇÁÇπÊâÄÂú®ÈìæÁöÑËµ∑ÁÇπÔºàtopÊï∞ÁªÑÔºâÔºåËøòÊúâÂΩìÂâçËäÇÁÇπÂú®Ê†ë‰∏≠ÁöÑ‰ΩçÁΩÆÔºàrankÊï∞ÁªÑÔºâ„ÄÇ123456789101112131415161718192021222324void dfs2(int u, int t) &#123; /** * uÔºöÂΩìÂâçÁªìÁÇπ * tÔºöËµ∑ÂßãÁöÑÈáçÁªìÁÇπ */ top[u] = t; // ËÆæÁΩÆÂΩìÂâçÁªìÁÇπÁöÑËµ∑ÁÇπ‰∏∫t tid[u] = cnt; // ËÆæÁΩÆÂΩìÂâçÁªìÁÇπÁöÑdfsÊâßË°åÂ∫èÂè∑ rnk[cnt] = u; // ËÆæÁΩÆdfsÂ∫èÂè∑ÂØπÂ∫îÊàêÂΩìÂâçÁªìÁÇπ cnt++; // Â¶ÇÊûúÂΩìÂâçÁªìÁÇπÊ≤°ÊúâÂ§ÑÂú®ÈáçÈìæ‰∏äÔºåÂàô‰∏çÂ§ÑÁêÜ if (son[u] == -1) &#123; return; &#125; // Â∞ÜËøôÊù°ÈáçÈìæ‰∏äÁöÑÊâÄÊúâÁöÑÁªìÁÇπÈÉΩËÆæÁΩÆÊàêËµ∑ÂßãÁöÑÈáçÁªìÁÇπ dfs2(son[u], t); // ÈÅçÂéÜÊâÄÊúâÂíåÂΩìÂâçÁªìÁÇπËøûÊé•ÁöÑÁªìÁÇπ for (int i = head[u]; i; i = edg[i].next) &#123; int v = edg[i].to; // Â¶ÇÊûúËøûÊé•ÁªìÁÇπ‰∏çÊòØÂΩìÂâçÁªìÁÇπÁöÑÈáçÂ≠êÁªìÁÇπÂπ∂‰∏î‰πü‰∏çÊòØuÁöÑÁà∂‰∫≤ÁªìÁÇπÔºåÂàôÂ∞ÜÂÖ∂ÁöÑtopËÆæÁΩÆÊàêËá™Â∑±ÔºåËøõ‰∏ÄÊ≠•ÈÄíÂΩí if (v != son[u] &amp;&amp; v != faz[u])&#123; dfs2(v, v); &#125; &#125;&#125; ËÄå‰øÆÊîπÂíåÊü•ËØ¢Êìç‰ΩúÂéüÁêÜÊòØÁ±ª‰ººÁöÑÔºå‰ª•Êü•ËØ¢Êìç‰Ωú‰∏∫‰æãÔºåÂÖ∂ÂÆûÂ∞±ÊòØ‰∏™LCAÔºå‰∏çËøáËøôÈáå‰ΩøÁî®‰∫ÜtopÊù•ËøõË°åÂä†ÈÄüÔºåÂõ†‰∏∫topÂèØ‰ª•Áõ¥Êé•Ë∑≥ËΩ¨Âà∞ËØ•ÈáçÈìæÁöÑËµ∑ÂßãÁªìÁÇπÔºåËΩªÈìæÊ≤°ÊúâËµ∑ÂßãÁªìÁÇπ‰πãËØ¥Ôºå‰ªñ‰ª¨ÁöÑtopÂ∞±ÊòØËá™Â∑±„ÄÇÈúÄË¶ÅÊ≥®ÊÑèÁöÑÊòØÔºåÊØèÊ¨°Âæ™ÁéØÂè™ËÉΩË∑≥‰∏ÄÊ¨°ÔºåÂπ∂‰∏îËÆ©ÁªìÁÇπÊ∑±ÁöÑÈÇ£‰∏™Êù•Ë∑≥Âà∞topÁöÑ‰ΩçÁΩÆÔºåÈÅøÂÖç‰∏§‰∏™‰∏ÄËµ∑Ë∑≥‰ªéËÄåÊèíËÇ©ËÄåËøá„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657INT64 query_path(int x, int y) &#123; /** * xÔºöÁªìÁÇπx * yÔºöÁªìÁÇπy * Êü•ËØ¢ÁªìÁÇπxÂà∞ÁªìÁÇπyÁöÑË∑ØÂæÑÂíå */ INT64 ans = 0; int fx = top[x], fy = top[y]; // Áõ¥Âà∞xÂíåy‰∏§‰∏™ÁªìÁÇπÊâÄÂú®ÈìæÁöÑËµ∑ÂßãÁªìÁÇπÁõ∏Á≠âÊâçË°®ÊòéÊâæÂà∞‰∫ÜLCA while (fx != fy) &#123; if (dep[fx] &gt;= dep[fy]) &#123; // Â∑≤ÁªèËÆ°ÁÆó‰∫Ü‰ªéxÂà∞ÂÖ∂Èìæ‰∏≠Ëµ∑ÂßãÁªìÁÇπÁöÑË∑ØÂæÑÂíå ans += query(1, tid[fx], tid[x]); // Â∞ÜxËÆæÁΩÆÊàêËµ∑ÂßãÁªìÁÇπÁöÑÁà∂‰∫≤ÁªìÁÇπÔºåËµ∞ËΩªËæπÔºåÁªßÁª≠Âæ™ÁéØ x = faz[fx]; &#125; else &#123; ans += query(1, tid[fy], tid[y]); y = faz[fy]; &#125; fx = top[x], fy = top[y]; &#125; // Âç≥‰æøÊâæÂà∞‰∫ÜLCAÔºå‰ΩÜÊòØÂâçÈù¢‰πüÂè™ÊòØÂàÜÂà´ËÆ°ÁÆó‰∫Ü‰ªé‰∏ÄÂºÄÂßãÂà∞ÊúÄÁªàÂÅúÊ≠¢ÁöÑ‰ΩçÁΩÆÂíåË∑ØÂæÑÂíå // Â¶ÇÊûú‰∏§‰∏™ÁªìÁÇπ‰∏ç‰∏ÄÊ†∑ÔºåË°®Êòé‰ªçÁÑ∂ÈúÄË¶ÅËÆ°ÁÆó‰∏§‰∏™ÁªìÁÇπÂà∞LCAÁöÑË∑ØÂæÑÂíå if (x != y) &#123; if (tid[x] &lt; tid[y]) &#123; ans += query(1, tid[x], tid[y]); &#125; else &#123; ans += query(1, tid[y], tid[x]); &#125; &#125; else ans += query(1, tid[x], tid[y]); return ans;&#125;void update_path(int x, int y, int z) &#123; /** * xÔºöÁªìÁÇπx * yÔºöÁªìÁÇπy * zÔºöÈúÄË¶ÅÂä†‰∏äÁöÑÂÄº * Êõ¥Êñ∞ÁªìÁÇπxÂà∞ÁªìÁÇπyÁöÑÂÄº */ int fx = top[x], fy = top[y]; while(fx != fy) &#123; if (dep[fx] &gt; dep[fy]) &#123; update(1, tid[fx],tid[x], z); x = faz[fx]; &#125; else &#123; update(1, tid[fy], tid[y], z); y = faz[fy]; &#125; fx = top[x], fy = top[y]; &#125; if (x != y) if (tid[x] &lt; tid[y]) update(1, tid[x], tid[y], z); else update(1, tid[y], tid[x], z); else update(1, tid[x], tid[y], z);&#125; ‰∏™‰∫∫ÂÜôÊ≥ï123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172int n, m, r, rt, mod, v[maxn], head[maxn], cnt, fa[maxn], size[maxn], d[maxn], son[maxn], top[maxn], id[maxn], rk[maxn];//fa Áà∂‰∫≤ËäÇÁÇπ size Â§ßÂ∞è d Ê∑±Â∫¶ son ÈáçÂÑøÂ≠ê Ôºå top ÈìæÈ°∂Á´Ø id dfsÂ∫è rk dfsÂ∫èÂØπÂ∫îÁöÑËäÇÁÇπvector&lt;int&gt; G[maxn];void add(int x, int y) &#123; G[x].emplace_back(y);&#125;void dfs1(int x) &#123; size[x] = 1; d[x] = d[fa[x]] + 1; for (auto u:G[x]) &#123; if (u != fa[x]) &#123; fa[u] = x; dfs1(u); size[x] += size[u]; if (size[son[x]] &lt; size[u]) &#123; son[x] = u; &#125; &#125; &#125;&#125;void dfs2(int x, int tp) &#123; top[x] = tp; id[x] = ++cnt; rk[cnt] = x; if (son[x]) &#123; dfs2(son[x], tp); &#125; for (auto u:G[x]) &#123; if (u != fa[x] &amp;&amp; u != son[x]) &#123; dfs2(u, u); &#125; &#125;&#125;inline int sum(int x, int y) &#123; int res = 0; while (top[x] != top[y]) &#123; if (d[top[x]] &lt; d[top[y]]) &#123; swap(x, y); &#125; //TODO res = (res + query(id[top[x]], id[x], rt)) % mod; x = fa[top[x]]; &#125; if (id[x] &gt; id[y]) &#123; swap(x, y); &#125; // TODO res = (res + query(id[x], id[y], rt)) % mod; return res;&#125;inline void updates(int x, int y, int c) &#123; while (top[x] != top[y]) &#123; if (d[top[x]] &lt; d[top[y]]) &#123; swap(x, y); &#125; //TODO update(id[top[x]], id[x], c, rt); x = fa[top[x]]; &#125; if (id[x] &gt; id[y]) &#123; swap(x, y); &#125; // TODO update(id[x], id[y], c, rt);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Êï∞ÊçÆÁªìÊûÑ</category>
      </categories>
      <tags>
        <tag>Ê†ëÈìæÂâñÂàÜ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019ÁâõÂÆ¢ÊöëÊúüÂ§öÊ†°ËÆ≠ÁªÉËê•(Á¨¨ÂçÅÂú∫) J Wood Processing]]></title>
    <url>%2F2019%2F08%2F23%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E5%8D%81%E5%9C%BA%EF%BC%89J%20Wood%20Processing%2F</url>
    <content type="text"><![CDATA[È¢òÊÑè: $n$Âø´Êú®ÊùøÔºåÂêàÊàê$k$ÂùóÊú®Êùø„ÄÇÁõ∏ÂêåÈ´òÂ∫¶ÂèØ‰ª•ÂêàÂπ∂Ôºå‰∏çÂêåÈ´òÂ∫¶ÔºåÈúÄË¶ÅÊääÈ´òÁöÑÊú®ÊùøÁ†çÊàêÂíå‰ΩéÁöÑÊú®Êùø‰∏ÄÊ†∑È´ò„ÄÇÈóÆÂêàÊàê$k$ÂùóÊúÄÂ∞ëÊµ™Ë¥πÂ§öÂ§ßÊú®ÊùøÈù¢ÁßØ„ÄÇÈ¢òËß£: dp[i][j] Ë°®Á§∫Ââçj‰∏™ÂêàÊàêi‰∏™Êú®ÊùøÊúÄÂ∞èËä±Ë¥πÈù¢ÁßØ„ÄÇËΩ¨ÁßªÊñπÁ®ã‰∏∫ dp[i][j]=min(dp[i-1][k]+sum[j]-sum[k]+h[k+1] * (w[j]-w[k]),dp[i][j])ÂÖ∂‰∏≠$w$Ë°®Á§∫Ë°®Á§∫ÂÆΩÂ∫¶ÂâçÁºÄÂíåÔºå$sum$Ë°®Á§∫Èù¢ÁßØÂâçÁºÄÂíåÔºåËΩ¨ÁßªÁöÑË¥°ÁåÆÂ∞±ÊòØÔºå ÂÅáËÆæ‰ªé$k$ËΩ¨Áßª‰ºò‰∫é$l$ÔºåÊúâÂ¶Ç‰∏ã: dp[i-1][k]+sum[j]-sum[k]-h[k+1] * (w[j]-[k])=dp[i-1][l]+sum[j]-sum[l]+h[l+1] * (w[j]-w[l])ÂêàÂπ∂ÂêåÁ±ªÈ°πÂåñÁÆÄÔºå \frac{(dp[i-1][k]-sum[k]+h[k+1] * w[k])-(dp[i-1][l]-sum[l]+h[l+1] * w[l])}{w[k]-w[l]}]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ÊñúÁéá‰ºòÂåñDP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÊñúÁéá‰ºòÂåñDP]]></title>
    <url>%2F2019%2F08%2F23%2F%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96DP%2F</url>
    <content type="text"><![CDATA[‰ªÄ‰πàÊòØÊñúÁéá‰ºòÂåñDPÔºüÈ°æÂêçÊÄù‰πâÔºåÁî®ÊñúÁéá‰ºòÂåñÁöÑDP„ÄÇÊé®Ëçê‰∏ÄÊ≥¢ÂçöÂÆ¢Ëøô‰∏™Â§ßÂì•Â∞ÜÁöÑ‰∏çÈîô„ÄÇÊñúÁéá‰ºòÂåñDPÔºå‰∏ÄÂºÄÂßã‰ºöÂåñÊàê‰∏Ä‰∏™ÂºèÂ≠êÔºåÂÉè \frac{f(j)-f(k)}{g(j)-g(k)}]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ÊñúÁéá‰ºòÂåñDP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Âá∫Á•ûÂÖ•ÂåñÁöÑÂàÜÂùó Educational Codeforces Round 71 (Rated for Div. 2) E Remainder Problem]]></title>
    <url>%2F2019%2F08%2F23%2F%E5%87%BA%E7%A5%9E%E5%85%A5%E5%8C%96%E7%9A%84%E5%88%86%E5%9D%97%2F</url>
    <content type="text"><![CDATA[Educational Codeforces Round 71 (Rated for Div. 2) E Remainder ProblemÈ¢òÊÑè: ‰∏§ÁßçÊìç‰ΩúÔºå‰∏ÄÁßç$a_x+y$,Á¨¨‰∫åÁßçÊü•ËØ¢ \sum_{i=y}^{5e5}a_i,(i\%x==y)ÊâÄÊúâÊ®°$x$Á≠â‰∫é$y$‰ΩçÁΩÆÁöÑÂíå.È¢òËß£: $\%x=y$ Ëøô‰∏çÂ∞±ÊòØÂàÜÂùó‰πàÔºåÂ∞±ÊòØÂàÜÂùóÁöÑÊÄßË¥®ÂïäÔºåÁõ¥Êé•Â§ÑÁêÜ‰∏çÂ∞±OK‰∫ÜÔºüÔºüÔºåÊÉ≥‰ªÄ‰πàÁ∫øÊÆµÊ†ë„ÄÇÁúü6.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include "bits/stdc++.h" using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a)); const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e3 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8; #ifndef ONLINE_JUDGEclock_t prostart = clock();#endif void f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125; //typedef __int128 LLL; template&lt;typename T&gt;void read(T &amp;w) &#123;//ËØªÂÖ• char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125; template&lt;typename T&gt;void output(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125; int n, m; const int B = 1e3;LL q[maxn][maxn];LL a[maxn * 1000]; int main() &#123; f(); read(n); while (n--) &#123; int op, x, y; scanf("%d%d%d", &amp;op, &amp;x, &amp;y); if (op == 1) &#123; a[x] += y; for (int i = 1; i &lt;= B; i++) &#123; q[i][x % i] += y; &#125; &#125; else &#123; if (x &lt;= B) &#123; printf("%lld\n", q[x][y]); &#125; else &#123; LL res = 0; while (y &lt;= 500000) &#123; res += a[y]; y += x; &#125; printf("%lld\n", res); &#125; &#125; &#125; #ifndef ONLINE_JUDGE cout &lt;&lt; "ËøêË°åÊó∂Èó¥:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>ÂàÜÂùó</category>
      </categories>
      <tags>
        <tag>ÂàÜÂùó</tag>
        <tag>Âá∫Á•ûÂÖ•Âåñ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 10 1011 Make Rounddog Happy]]></title>
    <url>%2F2019%2F08%2F22%2F2019-Multi-University-Training-Contest-10-1011-Make-Rounddog-Happy%2F</url>
    <content type="text"><![CDATA[HDU 6701 Make Rounddog HappyÈ¢òÊÑè Ôºö Áªô‰Ω†$n$‰∏™Êï∞ÔºåÂíå$k$,ÊâæÂà∞Âå∫Èó¥[l,r] $max(a_l,\dots,a_r)-(r-l+1)&lt;=k$ ÁöÑÊï∞ÈáèÔºàÂå∫Èó¥ÂÜÖ‰∏çËÉΩÂá∫Áé∞ÊúâÁõ∏ÂêåÊï∞Â≠óÔºâ„ÄÇÈ¢òËß£Ôºö Áõ∏ÂΩì‰∫éÊâæÂå∫Èó¥ÈïøÂ∫¶Â§ß‰∫éÂå∫Èó¥ÊúÄÂ§ßÂÄº-k ÁöÑÂå∫Èó¥Êï∞ÈáèÔºåÁ¨¨‰∏Ä‰∏™ÊÉ≥Âà∞ÂÖ•ÊâãÁöÑËÇØÂÆöÂ∞±ÊòØÂå∫Èó¥ÊúÄÂ§ßÂÄºÔºåÁÑ∂ÂêéÊûö‰∏æÂ∑¶ËæπÊàñÂè≥ËæπÁöÑËæπÁïåÔºåÁÑ∂ÂêéÊâæÂè¶Â§ñ‰∏ÄËæπÁöÑÁöÑ‰∏äÁïå„ÄÇÂÅáËÆæÂØªÊâæÂå∫Èó¥ÊúÄÂ§ßÂÄºÔºåstË°®ËÉΩÂ§üÂÆûÁé∞$O(1)$ÁöÑÊü•ÊâæÔºåÂÅáËÆæÊàë‰ª¨ÊâæÂà∞[l,r]Âå∫Èó¥ÁöÑÊúÄÂ§ßÂÄº‰∏ãÊ†á‰∏∫MIDÔºåËøô‰∏™MIDÂæàÊòæÁÑ∂‰∏ç‰ºöÊÅ∞Â•ΩÂú®Ê≠£‰∏≠Èó¥ÔºåÈÇ£‰πàÊàë‰ª¨ËÇØÂÆöÊòØÂêëÈáåËæπÁïåËøëÁöÑÊñπÂêëÊûö‰∏æÔºåÁÑ∂ÂêéÊü•ËØ¢Âè¶‰∏ÄÁ´ØÁöÑÊÉÖÂÜµ„ÄÇ(Ëøô‰∏™Âè´ÂêØÂèëÂºèÂàÜÊ≤ª ÈòüÂèãÂëäËØâÊàëÊòØ$O(nlog(n))$) „ÄÇÂÅáËÆæÊûö‰∏æÂè≥Á´Ø‰∏ãÊ†á‰∏∫ÂΩìÂâç‰∏ãÊ†ái,Âè¶‰∏ÄÁ´ØÁöÑÊÉÖÂÜµÊÄé‰πàËé∑ÂèñÂë¢Ôºå$O(n)$ÊâæËÇØÂÆö‰∏çË°åÔºåÂè¶‰∏ÄÁ´Ø‰∏äÁïåupËÇØÂÆöÊòØ$i-a[MID]-k$,‰∏ãÂ±äÂë¢Ôºü‰ªéiÂºÄÂßãÁ¨¨‰∏Ä‰∏™Âá∫Áé∞Áõ∏ÂêåÊï∞Â≠óÁöÑ‰ΩçÁΩÆ„ÄÇËøô‰∏™ÂèØ‰ª•$O(n)$ È¢ÑÂ§ÑÁêÜÂá∫Êù•ÔºåÊØè‰∏™‰ΩçÁΩÆ‰∏äÁöÑÊï∞‰∏ä‰∏ÄÊ¨°Âá∫Áé∞ÁöÑ‰ΩçÁΩÆÂèØ‰ª•Áõ¥Êé•Ê±ÇÂá∫Êù•ÔºåÁÑ∂Âêé‰ªéÊüê‰∏Ä‰∏™‰ΩçÁΩÆÂà∞Á¨¨‰∏Ä‰∏™Âá∫Áé∞Áõ∏ÂêåÂÄºÁöÑ‰∏ãÊ†áËÇØÂÆöÊòØÂçïË∞ÉÁöÑÔºåÊâÄ‰ª•ËÉΩ$O(n)$È¢ÑÂ§ÑÁêÜÂá∫Á¨¨‰∏Ä‰∏™‰ªéi‰ΩçÁΩÆÂæÄÂâçÊúÄÈïø‰∏çÂá∫Áé∞Áõ∏ÂêåÂÄºÁöÑ‰ΩçÁΩÆÔºåÂíåÂêëÂêéÊúÄÈïø‰∏çÂá∫Áé∞Áõ∏ÂêåÂÄºÁöÑ‰ΩçÁΩÆ Ëøô‰∏™Âú∞ÊñπÂç°‰∫ÜÁÇπÂ∏∏ÔºåÊàëÁî®2‰∏™STË°®Âç°ÊûÅÈôêÊó∂Èó¥Ëøá‰∫ÜÔºåÂÆûÈôÖ‰∏ä‰∏§‰∏™Êï∞ÁªÑÂ∞±ËÉΩËß£ÂÜ≥ÔºåÊâæÂå∫Èó¥ÊúÄÂ§ßÂÄºÂÆûÈôÖ‰∏ä‰πüËÉΩÁî®ÂçïË∞ÉÊ†àËß£ÂÜ≥ÂèØ‰ª•‰∏çÁî®STË°®„ÄÇÁîª‰∏™ÂõæÁêÜËß£‰∏Ä‰∏ãÂ¶ÇÊûúÊòØÔºåÊûö‰∏æÂ∑¶Ëæπ‰∏ÄÊ†∑ÁöÑÂ§ÑÁêÜ„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 3e5 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;//typedef __int128 LLL;void read(int &amp;w) &#123;//ËØªÂÖ• char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125;void output(LL x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125;const int MXN = 3e5 + 10;int a[maxn];int pre[maxn], nxt[maxn];int dp[MXN][20], pos[MXN][20];int lg[maxn];void init(int n) &#123; int LOG = lg[n] + 1; for (int j = 1; j &lt; LOG; ++j) &#123; if ((1 &lt;&lt; (j - 1)) &gt; n) break; for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) &#123; if (dp[i][j - 1] &gt;= dp[i + (1 &lt;&lt; (j - 1))][j - 1]) &#123; dp[i][j] = dp[i][j - 1]; pos[i][j] = pos[i][j - 1]; &#125; else &#123; dp[i][j] = dp[i + (1 &lt;&lt; (j - 1))][j - 1]; pos[i][j] = pos[i + (1 &lt;&lt; (j - 1))][j - 1]; &#125; &#125; &#125;&#125;inline int query(int l, int r) &#123; int k = lg[r - l + 1]; if (dp[l][k] &gt;= dp[r - (1 &lt;&lt; k) + 1][k]) return pos[l][k]; return pos[r - (1 &lt;&lt; k) + 1][k];&#125;inline int query1(int l, int r) &#123; return pre[r];&#125;inline int query2(int l, int r) &#123; return nxt[l];&#125;int n, k;LL ans = 0;void solve(int l, int r) &#123; if (l &gt; r) return; if (l == r) &#123; if (a[l] - 1 &lt;= k) ++ans; return; &#125; int MID = query(l, r);//ÊúÄÂ§ßÂÄºÁöÑ‰ΩçÁΩÆ if (r - MID &gt; MID - l) &#123; int up = min(query2(MID, r) - 1, r), low; for (int i = MID; i &gt;= l; --i) &#123;//Êûö‰∏æÂ∑¶Á´ØÁÇπ up = min(nxt[i] - 1, up); low = i + (a[MID] - k) - 1; low = max(low, MID); if (up &lt; MID)break; if (low &gt; up)continue; else &#123; ans += up - low + 1; &#125; &#125; &#125; else &#123; int up, low = max(query1(l, MID) + 1, l); for (int i = MID; i &lt;= r; ++i) &#123;//Êûö‰∏æÂè≥Á´ØÁÇπ low = max(pre[i] + 1, low); up = i - (a[MID] - k) + 1; up = min(up, MID); if (low &gt; MID)break; if (low &gt; up)continue; else &#123; ans += up - low + 1; &#125; &#125; &#125; solve(l, MID - 1); solve(MID + 1, r);&#125;int p[maxn];int main() &#123; f(); int T; read(T); for (int i = 1; i &lt;= 3e5; i++) &#123; lg[i] = log2(i); &#125; while (T--) &#123; read(n); read(k); for (int i = 1; i &lt;= n; i++) &#123; read(a[i]); dp[i][0] = a[i]; pos[i][0] = i; &#125; for (int i = 1; i &lt;= n; i++) &#123; p[i] = 0; &#125; for (int i = 1; i &lt;= n; i++) &#123; pre[i] = p[a[i]]; if (i != 1)pre[i] = max(pre[i], pre[i - 1]); p[a[i]] = i; &#125; for (int i = 1; i &lt;= n; i++) &#123; p[i] = n + 1; &#125; for (int i = n; i &gt;= 1; i--) &#123; nxt[i] = p[a[i]]; if (i != n)nxt[i] = min(nxt[i], nxt[i + 1]); p[a[i]] = i; &#125; for (int i = 1; i &lt;= n; ++i) &#123;// dp1[i][0] = pre[i];// dp2[i][0] = nxt[i]; &#125; init(n); ans = 0; solve(1, n); output(ans); puts(""); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>ÂàÜÊ≤ª</category>
      </categories>
      <tags>
        <tag>ÂêØÂèëÂºèÂàÜÊ≤ª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÂàÜÊ≤ªÁÆóÊ≥ï]]></title>
    <url>%2F2019%2F08%2F22%2F%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ÂàÜÊ≤ªÁÆóÊ≥ïÔºåÈ°æÂêçÊÄù‰πâÔºåÂàÜËÄåÊ≤ª‰πã„ÄÇÂàÜÊ≤ªÁÆóÊ≥ïÔºåÊØèÊ¨°Â∞ÜÂå∫Èó¥ÂáèÂçäÔºåÂåñ‰∏∫[l,mid],[mid+1,r]Âå∫Èó¥ÔºåÂÜçÁî®Ëß£ÂÜ≥ÁöÑ‰∏§‰∏™Âå∫Èó¥Êù•Ë∑üÊñ∞[l,r],ÈùûÂ∏∏ÂÖ∏ÂûãÁöÑ‰æãÂ≠êÂ∞±ÊòØÂΩíÂπ∂ÊéíÂ∫è„ÄÇÂΩíÂπ∂ÊéíÂ∫èÔºåÊØèÊ¨°ÂØπ[l,mid],[mid+1,r]Â§ÑÁêÜÔºåÁÑ∂Âêé$O(n)$ÂêàÂπ∂‰∏§‰∏™Êï∞ÁªÑÔºåÂ±ÇÊï∞$O(logn)$,ÊØèÂ±ÇÂêàÂπ∂$O(n)$Â§çÊùÇÂ∫¶Á®≥ÂÆö$O(nlog(n))$„ÄÇ CDQÂàÜÊ≤ªÂÖ∏Âûã‰æãÈ¢ò:Ê¥õË∞∑ 3810 ‰∏âÁª¥ÂÅèÂ∫èÊ¥õË∞∑ 3157 Âä®ÊÄÅÈÄÜÂ∫èÂØπÊú¨Ê†°OJÁöÑÊüê‰∏™È¢òÔºåÈìæÊé•Â§±ÊïàÂæàÊ≠£Â∏∏ ‰∏âÁª¥ÂÅèÂ∫è‰∏âÁª¥ÈÄÜÂ∫èÂØπÊòØ‰∏™ÂæàË£∏ÁöÑÈ¢òÔºåÁõ¥Êé•ÂØπ$x$ÊéíÂ∫èÔºåÊéíÂ∫è‰πãÂêéÂÉèÂΩíÂπ∂ÊéíÂ∫è‰∏ÄÊ†∑ÔºåÂàÜÊ≤ª$y$ÔºåÁÑ∂ÂêéÁî®Ê†ëÁä∂Êï∞ÁªÑÊõ¥Êñ∞$z$„ÄÇÂ∞±ÊòØÊääÂΩíÂπ∂ÊéíÂ∫èÂ§ÑÁêÜÈÄÜÂ∫èÂØπÁöÑÊñπÊ≥ï‰ªéÊûö‰∏æÂèòÊàê‰∫ÜÊ†ëÁä∂Êï∞ÁªÑ„ÄÇÊ†ëÁä∂Êï∞ÁªÑÊõ¥Êñ∞zÂÖ∂ÂÆû‰πüÂèØ‰ª•ÊîπÊàêÁî®cdqÂàÜÊ≤ªÂ§ÑÁêÜÔºåÊç¢ÊàêÂÖ∂‰ªñ$O(nlog(n))$ÁöÑÁÆóÊ≥ïÈÉΩÂèØ‰ª•„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157// luogu-judger-enable-o2#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;//typedef __int128 LLL;template&lt;typename T&gt;void read(T &amp;w) &#123;//ËØªÂÖ• char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125;template&lt;typename T&gt;void output(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125;LL bit[maxn + 1], n, k;LL sum(int i) &#123; LL s = 0; while (i &gt; 0) &#123; s += bit[i]; i -= i &amp; -i; &#125; return s;&#125;void add(int i, LL x) &#123; while (i &lt;= k) &#123; bit[i] += x; i += i &amp; -i; &#125;&#125;struct node &#123; int x, y, z, ans, cnt; bool operator==(const node t) const &#123; return x == t.x &amp;&amp; y == t.y &amp;&amp; z == t.z; &#125;&#125; dat[maxn];int ans[maxn];bool cmp1(node &amp;a, node &amp;b) &#123; if (a.x == b.x)return a.y == b.y ? a.z &lt; b.z : a.y &lt; b.y; return a.x &lt; b.x;&#125;bool cmp2(node &amp;a, node &amp;b) &#123; return a.y == b.y ? a.z &lt; b.z : a.y &lt; b.y;&#125;void cdq(int l, int r) &#123; if (r == l)return; cdq(l, mid); cdq(mid + 1, r); sort(dat + l, dat + mid + 1, cmp2); sort(dat + mid + 1, dat + r + 1, cmp2); int j = mid + 1; int i = l; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (dat[i].y &lt;= dat[j].y) &#123; add(dat[i].z, dat[i].cnt); i++; &#125; else &#123; dat[j].ans += sum(dat[j].z); j++; &#125; &#125; while (i &lt;= mid) &#123; add(dat[i].z, dat[i].cnt); i++; &#125; while (j &lt;= r) &#123; dat[j].ans += sum(dat[j].z); j++; &#125; for (i = l; i &lt;= mid; i++)add(dat[i].z, -dat[i].cnt);&#125;int main() &#123; f(); read(n); read(k); k++; for (int i = 1; i &lt;= n; i++) &#123; read(dat[i].x); read(dat[i].y); read(dat[i].z); &#125; sort(dat + 1, dat + n + 1, cmp1); int cnt = 0, num = 0; for (int i = 1; i &lt;= n; i++) &#123; cnt++; if (dat[i] == dat[i + 1])continue; ++num; dat[num].x = dat[i].x; dat[num].y = dat[i].y; dat[num].z = dat[i].z; dat[num].cnt = cnt; cnt = 0; &#125; cdq(1, num); for (int i = 1; i &lt;= num; i++) &#123; ans[dat[i].ans + dat[i].cnt - 1] += dat[i].cnt; &#125; for (int i = 0; i &lt; n; i++)printf("%d\n", ans[i]);#ifndef ONLINE_JUDGE cout &lt;&lt; "ËøêË°åÊó∂Èó¥:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; endl;#endif return 0;&#125; Âä®ÊÄÅÈÄÜÂ∫èÂØπËß£Ê≥ï1ÔºöÂØπ‰∫éÂä®ÊÄÅÈÄÜÂ∫èÂØπÔºåÂíå‰∏âÁª¥ÂÅèÂ∫èÊòØ‰∏Ä‰∏™ÈóÆÈ¢ò„ÄÇÂØπ‰∫éÊØè‰∏ÄÁßçÂà†Èô§Êìç‰ΩúÔºåÊàë‰ª¨Ê∑ªÂä†‰∏Ä‰∏™Êó∂Èó¥ËΩ¥$t$,ÁÑ∂ÂêéÊää‰∏ãÊ†áÂΩì‰Ωú‰∏ÄÁª¥Â∫¶ÔºåÂ∞±ÂèòÊàê‰∫Ü‰∏âÁª¥ÔºåÂ¶ÇÊ†∑‰æã Ôºö1 5 3 4 2 ÂèòÊàê1231 2 3 4 5 ‰∏ãÊ†á1 5 3 4 2 ÂÄº1 1 1 1 1 Êó∂Èó¥ ÊØèÊ¨°‰øÆÊîπÔºåÂú®$t$Êó∂Èó¥Âà†Èô§‰∫ÜÂÄºa,ÈÇ£‰πàÊää‰ªñÁöÑÊó∂Èó¥ÂèòÊàêÂØπÂ∫î‰øÆÊîπÊó∂Èó¥„ÄÇÂ¶ÇÊ†∑‰æãÂà†Èô§È°∫Â∫è5 1 4 2ÔºåÊ≤°ÊúâÂà†Èô§ÂàùÂßãÂåñ‰∏∫‰∏Ä‰∏™ÊØîËæÉÂ§ßÁöÑÂÄºÔºåË¶ÅÂú®Ê†ëÁä∂Êï∞ÁªÑËåÉÂõ¥ÂÜÖ„ÄÇ1231 2 3 4 5 1 5 3 4 23 2 inf 4 5 Âà†Èô§Êó∂Èó¥ ÁÑ∂Âêé‰∏çÈöæÂèëÁé∞ÔºåÊØèÊ¨°Âà†Èô§‰∏Ä‰∏™Êï∞ÁöÑË¥°ÁåÆÔºåÂ∞±ÊòØÂéü‰∫åÁª¥ÈÄÜÂ∫èÂØπÁöÑÂü∫Á°Ä‰∏äÔºåÂä†‰∏ä‰∏Ä‰∏™Á∫¶ÊùüÊù°‰ª∂ $t_i &lt; t_j$ „ÄÇÁÑ∂ÂêéÁî®ÊÄªÈÄÜÂ∫èÂØπÊï∞ÈáèÂáèÂéªËøô‰∏™ÂΩìÂâçÁöÑÊó∂Èó¥ÁöÑË¥°ÁåÆÂ∞±ÊòØÁ≠îÊ°à„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193// luogu-judger-enable-o2#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;//typedef __int128 LLL;template&lt;typename T&gt;void read(T &amp;w) &#123;//ËØªÂÖ• char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125;template&lt;typename T&gt;void output(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125;struct node &#123; int x, y, z;&#125; dat[maxn];bool cmp1(node &amp;o1, node &amp;o2) &#123; return o1.x == o2.x ? (o1.y == o2.y ? o1.z &lt; o2.z : o1.y &lt; o2.y) : o1.x &gt; o2.x;&#125;bool cmp2(node &amp;o1, node &amp;o2) &#123; return (o1.y == o2.y ? o1.z &lt; o2.z : o1.y &lt; o2.y);&#125;bool cmp3(node &amp;o1, node &amp;o2) &#123; return o1.y &gt; o2.y;&#125;int a[maxn];vector&lt;int&gt; v;LL bit[maxn + 1], n;LL sum(int i) &#123; LL s = 0; while (i &gt; 0) &#123; s += bit[i]; i -= i &amp; -i; &#125; return s;&#125;void add(int i, LL x) &#123; while (i &lt;= n) &#123; bit[i] += x; i += i &amp; -i; &#125;&#125;LL ans[maxn];void cdq(int l, int r) &#123; if (r == l)return; cdq(l, mid); cdq(mid + 1, r); sort(dat + l, dat + mid + 1, cmp2); sort(dat + mid + 1, dat + r + 1, cmp2); int i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (dat[i].y &lt; dat[j].y) &#123; add(dat[i].z, 1); i++; &#125; else &#123; ans[dat[j].z] += sum(dat[j].z); j++; &#125; &#125; while (i &lt;= mid) &#123; add(dat[i].z, 1); i++; &#125; while (j &lt;= r) &#123; ans[dat[j].z] += sum(dat[j].z); j++; &#125; for (i = l; i &lt;= mid; i++)add(dat[i].z, -1); i = l; j = mid + 1; sort(dat + l, dat + mid + 1, cmp3); sort(dat + mid + 1, dat + r + 1, cmp3); while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (dat[i].y &gt; dat[j].y) &#123; ans[dat[i].z] += sum(dat[i].z);// add(dat[i].z, 1); i++; &#125; else &#123;// ans[dat[j].z] += sum(dat[j].z); add(dat[j].z, 1); j++; &#125; &#125; while (j &lt;= r) &#123;// ans[dat[j].z] += sum(dat[j].z); add(dat[j].z, 1); j++; &#125; while (i &lt;= mid) &#123; ans[dat[i].z] += sum(dat[i].z);// add(dat[i].z, 1); i++; &#125; for (j = mid + 1; j &lt;= r; j++)add(dat[j].z, -1);&#125;int main() &#123; f(); int m; read(n); read(m); LL res = 0; for (int i = 1; i &lt;= n; i++) &#123; dat[i].x = i; read(dat[i].y);// res += sum(dat[i].y);// add(dat[i].y, 1); a[i] = 1; &#125;// mem(bit, 0); for (int j = 0; j &lt; m; ++j) &#123; int x; read(x); a[x] = m - j + 1; &#125; for (int i = 1; i &lt;= n; ++i) &#123; dat[i].z = a[dat[i].y]; &#125; sort(dat + 1, dat + n + 1, cmp1); for (int i = 1; i &lt;= n; i++) &#123;// dat[i].x = i;// read(dat[i].y); res += sum(dat[i].y); add(dat[i].y, 1);// a[i] = 1; &#125; mem(bit, 0); cdq(1, n); for (int i = 0; i &lt; m; i++) &#123; printf("%lld\n", res); res -= ans[m + 1 - i]; &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "ËøêË°åÊó∂Èó¥:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; endl;#endif return 0;&#125; Ëß£Ê≥ï2ÂéüÊú¨Êàë‰ª¨Ëøô‰∏™ÂÜôÊ≥ïÊòØÁõ¥Êé•Ê†áËÆ∞‰øÆÊîπÊó∂Èó¥ÔºåËøôÊ¨°Êàë‰ª¨ÂèòÊàêÊ∑ªÂä†‰∏Ä‰∏™Áõ∏ÂèçÁöÑÂÄº„ÄÇÂú®ÂéüÊúâÁöÑËäÇÁÇπ‰∏äÔºåÊàë‰ª¨Ê∑ªÂä†‰∏Ä‰∏™ÂÄºÔºåËÆ∞ÂΩï‰∏™Êï∞ÔºåÂà†Èô§‰πÖÁõ∏ÂΩì‰∫éÊ∑ªÂä†‰∏Ä‰∏™‰∏™Êï∞‰∏∫-1ÁöÑËäÇÁÇπ„ÄÇ‰æãÂ≠êÂ∞±ÂèòÊàê‰∫Ü12341 1 2 2 3 4 4 5 5 1 1 5 5 3 4 4 2 21 3 1 2 inf 1 4 1 5 Âà†Èô§Êó∂Èó¥1 -1 1 -1 1 1 -1 1 -1 ‰∏™Êï∞ ÁÑ∂ÂêéÁÆóË¥°ÁåÆÂ∞±ÂèØ‰ª•Áõ¥Êé•ÁÆóË¥°ÁåÆ‰∫ÜÔºåÂæàÊòæÁÑ∂ËøôÁßçÂÜôÊ≥ïÂ§ö‰∫Ü‰∏Ä‰∏™Â∏∏Êï∞ÔºüÈÇ£‰πà‰∏∫‰ªÄ‰πà‰πüË¶ÅË¥¥Âá∫Êù•Âë¢ÔºüÔºåÂõ†‰∏∫Ëøô‰∏™ÂÜôÊ≥ïÊ∑ªÂä†ÂíåÂà†Èô§ÈÉΩÂèØ‰ª•Áõ¥Êé•Âú®‰∏äÈù¢ÂÅö‰øÆÊîπÔºåÊ∑ªÂä†Â∞±Áõ∏ÂΩì‰∫éÂä†‰∫Ü‰∏Ä‰∏™‰∏™Êï∞‰∏∫1ÁöÑËäÇÁÇπ„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189// luogu-judger-enable-o2#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;//typedef __int128 LLL;template&lt;typename T&gt;void read(T &amp;w) &#123;//ËØªÂÖ• char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125;template&lt;typename T&gt;void output(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125;struct node &#123; int x, y, z, cnt;&#125; dat[maxn];bool cmp1(node &amp;o1, node &amp;o2) &#123; if (o1.x == o2.x)return o1.y == o2.y ? o1.z &gt; o2.z : o1.y &lt; o2.y; return o1.x &lt; o2.x;&#125;bool cmp2(node &amp;o1, node &amp;o2) &#123; return o1.y == o2.y ? o1.z &gt; o2.z : o1.y &gt; o2.y;&#125;bool cmp3(node &amp;o1, node &amp;o2) &#123; return o1.y == o2.y ? o1.z &lt; o2.z : o1.y &lt; o2.y;&#125;int pos[maxn];int bit[maxn];int n, m;LL sum2(int i) &#123; int s = 0; while (i &gt; 0) &#123; s += bit[i]; i -= i &amp; -i; &#125; return s;&#125;void add(int i, int x) &#123; while (i &lt;= m + 1) &#123; bit[i] += x; i += i &amp; -i; &#125;&#125;LL ans[maxn];void cdq(int l, int r) &#123; if (r == l)return; cdq(l, mid); cdq(mid + 1, r); sort(dat + l, dat + mid + 1, cmp2); sort(dat + mid + 1, dat + r + 1, cmp2); int i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (dat[i].y &gt;= dat[j].y) &#123; add(dat[i].z, dat[i].cnt); i++; &#125; else &#123; ans[dat[j].z] += sum2(dat[j].z) * dat[j].cnt; j++; &#125; &#125; while (i &lt;= mid) &#123; add(dat[i].z, dat[i].cnt); i++; &#125; while (j &lt;= r) &#123; ans[dat[j].z] += sum2(dat[j].z) * dat[j].cnt; j++; &#125; for (i = l; i &lt;= mid; i++)add(dat[i].z, -dat[i].cnt); sort(dat + l, dat + mid + 1, cmp3); sort(dat + mid + 1, dat + r + 1, cmp3); i = l; j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (dat[i].y &gt; dat[j].y) &#123; add(dat[j].z, dat[j].cnt); j++; &#125; else &#123;// if (dat[i].z == 2) &#123;// bug;// &#125; ans[dat[i].z] += sum2(dat[i].z) * dat[i].cnt; i++; &#125; &#125; while (i &lt;= mid) &#123;// if (dat[i].z == 2) &#123;// bug;// &#125; ans[dat[i].z] += sum2(dat[i].z) * dat[i].cnt; i++; &#125; while (j &lt;= r) &#123; add(dat[j].z, dat[j].cnt); j++; &#125; for (i = mid + 1; i &lt;= r; i++)add(dat[i].z, -dat[i].cnt);&#125;int main() &#123; f(); read(n); read(m); LL res = 0; for (int i = 1; i &lt;= n; i++) &#123; read(dat[i].y); dat[i].x = i; pos[dat[i].y] = i; dat[i].cnt = 1; dat[i].z = 1; &#125; for (int i = 1; i &lt;= m; i++) &#123; int x; read(x); dat[i + n].x = pos[x]; dat[i + n].y = dat[pos[x]].y; dat[i + n].z = i + 1; dat[i + n].cnt = -1; &#125; sort(dat + 1, dat + n + m + 1, cmp1); cdq(1, n + m); res = ans[1] / 2; for (int i = 2; i &lt;= m + 1; i++) &#123; printf("%lld\n", res); res += ans[i];// debug(ans[i]); &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "ËøêË°åÊó∂Èó¥:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; endl;#endif return 0;&#125; ÊàëÊ†°ÈÇ£È¢òÂÅöÁªÉ‰π†ÔºåÂ¶ÇÊûúÂ§±Êïà‰∫ÜÂ∞±Âà´ÂÅö‰∫ÜÔºåÊÉ≥ËØïËØïÂèØ‰ª•ÁïôË®Ä„ÄÇÂêØÂèëÂºèÂàÜÊ≤ªÊÅïÊàëÁõ¥Ë®ÄÔºå‰∏çËØ¥ËØùÂàÜÊ≤ªÂæàÂÆπÊòìÂá∫Áé∞‰∏ÄÁßçÊÉÖÂÜµÔºå‰Ω†ÈúÄË¶ÅÊâæÁöÑmid‰∏çÊòØÂàöÂ•ΩÂú®‰∏ÄÂçäÁöÑ‰ΩçÁΩÆÔºå„ÄÇ„ÄÇÁÑ∂Âêé‰Ω†Â∞±ÂæÄÁ¶ªËæπÁïåËøëÁöÑÊñπÂêëÊûö‰∏æ„ÄÇÁÑ∂ÂêéÁ°ÆÂÆöÂè¶‰∏ÄÂçäÁöÑ‰∏¥ÁïåÂÄº„ÄÇËøô‰∏™ÈòüÂèãÂëäËØâÊàëÊòØ$O(nlog(n))$‰ΩÜÊòØÊàë‰∏çÁ°ÆÂÆö„ÄÇ‰æãÈ¢òÔºåÂèØ‰ª•ÂéªÊàëÁöÑÂêØÂèëÂºèÂàÜÊ≤ªÈ¢òÊ†áÁ≠æÈáåÈù¢Êâæ]]></content>
      <categories>
        <category>ACM</category>
        <category>ÂàÜÊ≤ª</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 9 1007 Rikka with Travels]]></title>
    <url>%2F2019%2F08%2F19%2F2019-Multi-University-Training-Contest-9-1007%2F</url>
    <content type="text"><![CDATA[HDU 6686 Rikka with TravelsÈ¢òÊÑè: Âú®‰∏ÄÈ¢óÊ†ë‰∏äÈÄâÊã©‰∏§Êù°‰∏çÁõ∏‰∫§ÁöÑË∑ØÂæÑÁöÑÂèØËÉΩÊÄßÊúâÂ§öÂ∞ëÔºåË∑ØÂæÑÈïøÂ∫¶ÂÆö‰πâ‰∏∫Ë∑ØÂæÑÁöÑÈ°∂ÁÇπÊï∞„ÄÇÈ¢òËß£:ÂàùÊ≠•ÊÄùËÄÉÔºåËßÇÂØüÊ†∑‰æãÂèØ‰ª•ÂèëÁé∞ÔºåÊ±ÇÁöÑÊòØ‰∏§Êù°Ë∑ØÂæÑÁöÑÊúâÂ∫èÂØπÔºå[2,1],[1,2]‰∏çÊòØÂêå‰∏ÄÁßç„ÄÇÊàë‰ª¨ÂÅáËÆæÂ∑≤ÁªèÁü•ÈÅì‰Ω†ÈÄâÊã©ÁöÑ‰∏ÄÊù°Ë∑ØÂæÑÈïøÂ∫¶‰∏∫l,Âè™ÈúÄË¶ÅÊâæÂà∞ÊääËøôÊù°Ë∑ØÂæÑÂú®Ê†ë‰∏≠ÁßªÈô§Ôºå‰Ωô‰∏ãÁöÑÊ£ÆÊûóÁöÑÊúÄÈïøË∑ØÂæÑÊòØÂ§öÂ∞ëÔºåÂÅáËÆæÊòØ$r$,ÂØπ‰∫éÈïøÂ∫¶‰∏∫$l$ÁöÑË∑ØÂæÑÊúâÂ§öÊù°ÔºåÁÑ∂ÂêéÂàÜÂà´Ê±ÇÂá∫ÂØπÂ∫îÁöÑ$r$Â∞±ÊòØË¥°ÁåÆÔºåÁÑ∂ÂêéÂ∞ÜÊâÄÊúâÁöÑ$l$ÁöÑË¥°ÁåÆÔºåÊ±ÇÂíåÂ∞±ÊòØÁ≠îÊ°à„ÄÇÂæàÊòæÁÑ∂Ëøô‰πàÊ±ÇÂ∞±ÂØπË∂ÖÊó∂ÔºåËÄå‰∏î‰πüÊó†‰ªé‰∏ãÊâã„ÄÇÈÇ£‰πàÊàë‰ª¨ÁªßÁª≠‰ºòÂåñÔºåÂØπ‰∫é‰∏ÄÈ¢óÊ†ëÔºåÊàë‰ª¨ÊØèÊ¨°ÊãÜ‰∏ÄÊù°Ëæπ„ÄÇÊ±ÇÂá∫Â∑¶ËæπÁöÑÊúÄÈïøÁõ¥ÂæÑ‰∏∫L,Âè≥ËæπÁöÑÊúÄÈïøÁõ¥ÂæÑ‰∏∫R,ÂèØ‰ª•ÂèëÁé∞Â∑¶ËæπËøôÈ¢óÂ≠êÊ†ëÁöÑË∑ØÂæÑÂèØËÉΩÊúâ$1,2,\cdots,L$ÔºåÂè≥ËæπÊúâ$1,2,\cdots,R$, Êàë‰ª¨ÂèØ‰ª•Áü•ÈÅìÔºåÊääÂå∫Èó¥$l=[1,L]$ÁöÑË¥°ÁåÆË∑üÊñ∞‰∏∫$R$,$l=[1,R]$ Êõ¥Êñ∞‰∏∫$L$ÔºåÂÜôÂá∫Êö¥Âäõ‰øÆÊîπÂ∞±ÊòØ f[i]=max(f[i],R),1]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Êù≠ÁîµÂ§öÊ†°</tag>
        <tag>Ê†ëÂΩ¢DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019ÁâõÂÆ¢ÊöëÊúüÂ§öÊ†°ËÆ≠ÁªÉËê•(Á¨¨ÂÖ´Âú∫)Just Jump]]></title>
    <url>%2F2019%2F08%2F14%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5(%E7%AC%AC%E5%85%AB%E5%9C%BA)J.Just-Jump%2F</url>
    <content type="text"><![CDATA[2019ÁâõÂÆ¢ÊöëÊúüÂ§öÊ†°ËÆ≠ÁªÉËê•(Á¨¨ÂÖ´Âú∫)Just JumpÈ¢òÊÑèÔºö ÁªàÁÇπ‰ΩçÁΩÆ‰∏∫$L$Ôºå‰∏≠Èó¥ÁÇπÊòØ$1,2,\cdots,L-1$ ÔºåÂºÄÂßã‰ΩçÁΩÆÂú®$0$ÔºåÊØèÊ¨°ÂøÖÈ°ªËµ∞Ëá≥Â∞ë$d$Ê≠•,Âú®Á¨¨„ÄÇ$t_i$Ê≠•‰∏çËÉΩÂá∫Áé∞Âú® $p_i$ Ëøô‰∏™‰ΩçÁΩÆÔºåÈóÆ‰ªé $0$ Âà∞ $L$ ÔºåÊúâÂ§öÂ∞ëÁßçËµ∞Ê≥ï„ÄÇ È¢òËß£ÔºöËß£Ê≥ïÊå∫ÁÆÄÂçïÁöÑÔºåÂÖàÁÆóÂá∫Ê≤°Êúâ$m$‰∏™Á∫¶ÊùüÁöÑÊÉÖÂÜµ‰∏ãÔºåÊ±Ç‰∏Ä‰∏™ÂÄºÔºåËøô‰∏™ $f[i] =\sum_{j=0}^{i-d}f[i]$ „ÄÇÁÑ∂ÂêéÂÆπÊñ•Êêû‰∏Ä‰∏ãÔºå$m$‰∏™ÈôêÂà∂ÔºåÈÇ£‰πàÈóÆÈ¢òÊù•‰∫ÜÔºåÊÄé‰πàÊ±ÇÂàöÂ•ΩËµ∞ $t_i$ Ê≠•Âà∞ $p_i$ „ÄÇ ËøôÁØáÂçöÂÆ¢ÁöÑÊÑè‰πâÂ∞±Âú®Ëøô‰∫Ü,ÂÖàÊé®Ëçê‰∏™Âü∫Á•ûÂçöÂÆ¢„ÄÇ Ëøô‰∏™Ê±Ç‰∏Ä‰∏™ÊúÄÂêéÂ∫îËØ•Â∞±Á≠â‰∫é$C_{p_i-dt_i+t_i-1}^{t_i-1}$„ÄÇ Êàë‰ª¨Áé∞Âú®Â∫îËØ•ÊòØÂØπÂ∫îËøôÁßçÊÉÖÂÜµ Áî®ÊèíÊùøÊ≥ïÔºåÂ∞±ÊòØ‰ªé$n+m$‰∏™Á©∫ÈöôÈáåÈù¢ÔºåÈÄâÂá∫$m-1$‰∏™‰ΩçÁΩÆÂá∫Êù•ÔºåÁé∞Âú®ËøôÂ∞±ÊòØÂ§ö‰∫Ü‰∏™Ë¶ÅÊ±ÇÔºåÁõ∏ÈÇª‰∏§‰∏™Èó¥Èöô‰∏çËÉΩÂ∞è‰∫é$d$ ‚Ä¶,ÊäΩË±°ÁêÜËß£‰∏ã ‰Ω†ÊääËøô$m$‰∏™$d$ÂÖ®ÈÉ®Êé®ÂâçÈù¢ÂéªÔºå‰∏ç‰πÖÁõ∏ÂΩì‰∫éÁõ¥Êé•Âú®ÂêéÈù¢$n-m * d-(m-1)$ÈÄâ$m-1$‰∏™ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 998244353;const int maxn = (int) 1e7 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;//typedef __int128 LLL;template&lt;typename T&gt;void read(T &amp;w) &#123;//ËØªÂÖ• char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125;template&lt;typename T&gt;void output(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125;LL L, d, m;P p[3005];LL qz[maxn], l[maxn];const int Comb_Maxn = 1e7 + 10;LL Fac_inv[Comb_Maxn];LL Fac[Comb_Maxn];inline void Comb_init() &#123; Fac_inv[0] = Fac[0] = 1; Fac_inv[1] = 1; for (int i = 1; i &lt; Comb_Maxn; i++) Fac[i] = Fac[i - 1] * (LL) i % mod; for (int i = 2; i &lt; Comb_Maxn; i++) Fac_inv[i] = (LL) (mod - mod / i) * Fac_inv[mod % i] % mod; for (int i = 1; i &lt; Comb_Maxn; i++) Fac_inv[i] = (LL) Fac_inv[i - 1] * Fac_inv[i] % mod;&#125;LL Comb(LL n, LL m) &#123; if (n &lt; 0 || m &lt; 0)return 0; if (n &lt; m)return 0; assert(n &lt; Comb_Maxn &amp;&amp; n &gt;= m); assert(m &lt; Comb_Maxn); return Fac[n] * Fac_inv[m] % mod * Fac_inv[n - m] % mod;&#125;LL dp[maxn];int main() &#123; f(); read(L); read(d); read(m); Comb_init(); for (int i = 0; i &lt; m; i++) &#123; read(p[i].first); read(p[i].second); &#125; sort(p, p + m); l[0] = 1; qz[0] = 1; for (int i = 1; i &lt;= L; i++) &#123; if (i &gt;= d) &#123; l[i] = qz[i - d]; &#125; qz[i] = (qz[i - 1] + l[i]) % mod; &#125; for (int i = 0; i &lt; m; i++) &#123; dp[i] = Comb(p[i].second - d * p[i].first + p[i].first - 1, p[i].first - 1); if (dp[i] != 0) &#123; for (int j = 0; j &lt; i; j++) &#123; dp[i] = (dp[i] - Comb(p[i].second - p[j].second - d * (p[i].first - p[j].first) + (p[i].first - p[j].first) - 1, (p[i].first - p[j].first) - 1) * dp[j] % mod + mod) % mod; &#125; &#125; &#125; LL ans = l[L]; for (int i = 0; i &lt; m; i++) &#123; ans = (ans - dp[i] * l[L - p[i].second] % mod + mod) % mod; &#125; printf("%lld\n", ans);#ifndef ONLINE_JUDGE cout &lt;&lt; "ËøêË°åÊó∂Èó¥:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Êï∞ËÆ∫</category>
      </categories>
      <tags>
        <tag>ÁâõÂÆ¢ÊöëÊúüÂ§öÊ†°ËÆ≠ÁªÉËê•</tag>
        <tag>ÂÆπÊñ•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019ÁâõÂÆ¢ÊöëÊúüÂ§öÊ†°ËÆ≠ÁªÉËê•(Á¨¨ÂÖ´Âú∫)Flower Dance(ÊúâÂùë)]]></title>
    <url>%2F2019%2F08%2F13%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5(%E7%AC%AC%E5%85%AB%E5%9C%BA)Flower%20Dance%2F</url>
    <content type="text"><![CDATA[2019ÁâõÂÆ¢ÊöëÊúüÂ§öÊ†°ËÆ≠ÁªÉËê•(Á¨¨ÂÖ´Âú∫)Flower Dance È¢òÊÑè: Áªô$n$‰∏™ÁÇπ $m$Êù°ËæπÔºåÊØèÊù°ËæπÊúâ‰∏Ä‰∏™ÊùÉÂÄºÂå∫Èó¥ÔºåË°®Á§∫ËÉΩÈÄöËøáËøô‰∏™Âå∫Èó¥ÁöÑ ÂÄºÁöÑËåÉÂõ¥ÔºåÈóÆ‰ªé$1$Âà∞$n$ÂèØ‰ª•ÈÄöËøáÁöÑÊùÉÂÄºÊúâÂ§öÂ∞ë‰∏™„ÄÇ È¢òËß£: 1.DFSÁ∫øÊÆµÊ†ë+Á¶ªÊï£Âåñ+Âπ∂Êü•ÈõÜËøô‰∏™Á∫øÊÆµÊ†ëÔºåÂÖ∂ÂÆû‰πü‰∏çËÉΩÁÆóÊòØ‰∏™Ê≠£Â∏∏ÁöÑÁ∫øÊÆµÊ†ëÔºå‰ªñbuild ÁöÑ‰πãÂêéÂ∞±Ê≤°Âï•Áî®‰∫ÜÔºåÊ≤°ÊúâÊõ¥Êñ∞ÂíåÊü•ËØ¢.„ÄÇ„ÄÇÁõ¥Êé•Âú®Á∫øÊÆµÊ†ë‰∏ädfs,È¶ñÂÖàÊääÊùÉÂÄºÁ¶ªÊï£ÂåñÔºåÁÑ∂ÂêéÂ≠òÂÖ•Á∫øÊÆµÊ†ë‰∏≠ÔºåÁ∫øÊÆµÊ†ëÊØè‰∏™ËäÇÁÇπË°®Á§∫ÔºåÂå∫Èó¥[l,r]Ôºå‰∏≠ÊúâÂì™‰∫õËæπÔºåËøôÊ†∑ÊØèÊ¨°Ê∑±Êêú‰∏ãÂéªÔºåÁªèËøáÁöÑËæπÁî®Âπ∂Êü•ÈõÜÁª¥Êä§Ëµ∑Êù•ÔºåË°®Á§∫Âì™‰∫õÁÇπÊòØËÅîÈÄöÁöÑÔºåÁÑ∂ÂêéÂ¶ÇÊûúÔºå1ÂíånËÅîÈÄöÁöÑËØùÂ∞±Êõ¥Êñ∞ÊùÉÂÄº„ÄÇËøôÈ¢òÊúâÂõûÊ∫ØÔºåÂ∞±ÊúâÊãÜËæπÔºåÊâÄ‰ª•Âπ∂Êü•ÈõÜË¶Å‰øùÂ≠òË∑ØÂæÑÔºåËÄå‰∏îË¶ÅÂä†ÊåâÁß©ÂêàÂπ∂ÁöÑ‰ºòÂåñ,‰∏çÁÑ∂‰ºöË∂ÖÊó∂„ÄÇ ÂÜôÁ¶ªÊï£ÂåñÁ∫øÊÆµÊ†ëÂ∞ΩÈáè‰øùÂ≠ò (l,r] Â∑¶ÂºÄÂè≥Èó≠ÁöÑÂå∫Èó¥ÂÄºÔºå‰øùÂ≠ò[l,r] ÁöÑÂå∫Èó¥‰ºöÂá∫ÈóÆÈ¢ò 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;//typedef __int128 LLL;template&lt;typename T&gt;void read(T &amp;w) &#123;//ËØªÂÖ• char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125;template&lt;typename T&gt;void output(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125;struct edge &#123; int u, v, l, r;&#125; eg[maxn];vector&lt;int&gt; v;int get(int x) &#123; return lower_bound(v.begin(), v.end(), x) - v.begin() + 1;&#125;int n, m;vector&lt;int&gt; dat[maxn];void build(int l, int r, int k, int a, int b, int x) &#123; if (l == a &amp;&amp; b == r) &#123; dat[k].emplace_back(x); return; &#125; if (b &lt;= mid) &#123; build(lson, a, b, x); &#125; else if (a &gt;= mid) &#123; build(rson, a, b, x); &#125; else &#123; build(lson, a, mid, x); build(rson, mid, b, x); &#125;&#125;vector&lt;int&gt; d[maxn];int ans = 0;int par[maxn];int find(int x) &#123; return (par[x] == x) ? x : find(par[x]);&#125;int rk[maxn];void unit(int x, int y, int dep) &#123; x = find(x); y = find(y); if (x != y) &#123; if (rk[x] &lt; rk[y])swap(x, y); par[y] = x; d[dep].emplace_back(y); if (rk[x] == rk[y])rk[x]++; &#125;&#125;void dfs(int l, int r, int k, int dep) &#123; d[dep].clear(); for (auto au:dat[k]) &#123; unit(eg[au].u, eg[au].v, dep); &#125; if (find(1) == find(n)) &#123; ans += v[r - 1] - v[l - 1]; &#125; else if (r != l + 1) &#123; dfs(lson, dep + 1); dfs(rson, dep + 1); &#125; for (auto au:d[dep]) &#123; par[au] = au; &#125;&#125;int main() &#123; f(); read(n); read(m); for (int i = 0; i &lt;= n; i++)par[i] = i; for (int i = 0; i &lt; m; i++) &#123; read(eg[i].u); read(eg[i].v); read(eg[i].l); read(eg[i].r); v.emplace_back(eg[i].l); v.emplace_back(eg[i].r + 1); &#125; sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); int mx = v.size(); for (int i = 0; i &lt; m; i++) &#123; build(1, mx, 1, get(eg[i].l), get(eg[i].r + 1), i); &#125; dfs(1, mx, 1, 0); output(ans); puts("");#ifndef ONLINE_JUDGE cout &lt;&lt; "ËøêË°åÊó∂Èó¥:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; endl;#endif return 0;&#125; LCT+ÊúÄÂ∞èÁîüÊàêÊ†ë Êåñ‰∏™ÂùëÔºåÊáíÂæóÂ≠¶splay]]></content>
      <categories>
        <category>ACM</category>
        <category>Êï∞ÊçÆÁªìÊûÑ</category>
      </categories>
      <tags>
        <tag>Á∫øÊÆµÊ†ë</tag>
        <tag>ÁâõÂÆ¢ÊöëÊúüÂ§öÊ†°ËÆ≠ÁªÉËê•</tag>
        <tag>Á¶ªÊï£Âåñ</tag>
        <tag>Âπ∂Êü•ÈõÜ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019ÁâõÂÆ¢ÊöëÊúüÂ§öÊ†°ËÆ≠ÁªÉËê•(Á¨¨ÂÖ´Âú∫) Distance]]></title>
    <url>%2F2019%2F08%2F13%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5(%E7%AC%AC%E5%85%AB%E5%9C%BA)Distance%2F</url>
    <content type="text"><![CDATA[2019ÁâõÂÆ¢ÊöëÊúüÂ§öÊ†°ËÆ≠ÁªÉËê•(Á¨¨ÂÖ´Âú∫) DistanceÈ¢òÊÑè: Áªô‰Ω†‰∏Ä‰∏™ $n* m* h$ ÁöÑÁ©∫Èó¥ÔºåÊØèÊ¨°ÊèíÂÖ•‰∏Ä‰∏™ÁÇπÔºåÊàñËÄÖËØ¢ÈóÆÁ©∫Èó¥‰∏≠ÁÇπÂà∞Ëøô‰∏ÄÁÇπÁöÑÊúÄÂ∞èÊõºÂìàÈ°øË∑ùÁ¶ª„ÄÇÈ¢òËß£: 1.HASH+‰∏âÁª¥BIT‰∏âÁª¥BITÔºåÂØπ‰∫éËøôÁßçÂÜôÊ≥ïÔºåÂ§™Â∑®‰∫ÜÔºå$n * m * h &lt; 1e5$ Áâπ‰πàÁõ¥Êé•Áî®‰∏âÁª¥BIT Â≠ò‰∏Ä‰∏ãÂ∞±ÂèØ‰ª•‰∫ÜÔºåÊûö‰∏æÂÖ´‰∏™ÊñπÂêëÔºåÊääÁªùÂØπÂÄºÂéªÊéâÔºåÁÑ∂ÂêéÊúÄÁâõÁöÑËøòÊòØhashÂ§ÑÁêÜÔºåÊää‰∏âÁª¥ÂéãÁº©Êàê‰∏ÄÁª¥ÔºåÂâäÂ∏∏Êï∞ÔºåÊàëÁâπ‰πàÂç°Â∏∏Âç°ÊàêËøôÊ†∑‰πüÊòØÂ∞ëËßÅ„ÄÇËøôÁßçhashÂ∞ÜÁª¥Â∫¶ÔºåÊûö‰∏æÂÖ´‰∏™ÊñπÂêëÂéªÁªùÂØπÂÄºÔºåÊï∞ÁªÑÊï∞ÁªÑÊ®°ÊãüÁ©∫Èó¥ÔºåËøòÊòØÊå∫6ÁöÑ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;//typedef __int128 LLL;template&lt;typename T&gt;void read(T &amp;w) &#123;//ËØªÂÖ• char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125;template&lt;typename T&gt;void output(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125;typedef vector&lt;int&gt; VI;typedef vector&lt;VI&gt; VVI;typedef vector&lt;VVI&gt; VVVI;struct BIT &#123; int n, m, h; int a[maxn]; void init(int n, int m, int h) &#123; this-&gt;n = n; this-&gt;m = m; this-&gt;h = h; mem(a, -inf); &#125; int get(int x, int y, int z) &#123; return x * h * m + y * h + z; &#125; int lowbit(int &amp;x) &#123; return x &amp; (-x); &#125; void add(int x, int y, int z, int t) &#123; for (int i = x; i &lt;= n; i += lowbit(i)) for (int j = y; j &lt;= m; j += lowbit(j)) for (int k = z; k &lt;= h; k += lowbit(k)) a[get(i, j, k)] = max(a[get(i, j, k)], t); &#125; int sum(int x, int y, int z) &#123; int res = -inf; for (int i = x; i; i -= lowbit(i)) for (int j = y; j; j -= lowbit(j)) for (int k = z; k; k -= lowbit(k)) res = max(a[get(i, j, k)], res); return res; &#125;&#125; b[8];int get_pos(int x, int pos) &#123; return (x &gt;&gt; pos) &amp; 1;&#125;int main() &#123; f(); int n, m, h, q; int op; read(n); read(m); read(h); read(q); for (int i = 0; i &lt; 8; i++) &#123; b[i].init(n, m, h); &#125; int d[] = &#123;n + 1, m + 1, h + 1&#125;; int a[3], c[3]; while (q--) &#123; read(op); read(a[0]); read(a[1]); read(a[2]); if (op == 1) &#123; for (int i = 0; i &lt; 8; i++) &#123; c[0] = get_pos(i, 0) ? d[0] - a[0] : a[0]; c[1] = get_pos(i, 1) ? d[1] - a[1] : a[1]; c[2] = get_pos(i, 2) ? d[2] - a[2] : a[2]; b[i].add(c[0], c[1], c[2], c[1] + c[2] + c[0]); &#125; &#125; else &#123; int ans = inf; for (int i = 0; i &lt; 8; i++) &#123; c[0] = get_pos(i, 0) ? d[0] - a[0] : a[0]; c[1] = get_pos(i, 1) ? d[1] - a[1] : a[1]; c[2] = get_pos(i, 2) ? d[2] - a[2] : a[2]; ans = min(ans, c[0] + c[1] + c[2] - b[i].sum(c[0], c[1], c[2])); &#125; output(ans); puts(""); &#125; &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "ËøêË°åÊó∂Èó¥:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; " s" &lt;&lt; endl;#endif return 0;&#125; 2.ÂàÜÂùó+bfsÁ¨¨‰∫åÁßçÂÜôÊ≥ïÂ∞±Êõ¥È™ö‰∫ÜOrz,ÂØπ‰∫é $1e5$ ÁªÑÊü•ËØ¢ÔºåÂàÜÊàê$\sqrt{(1e5)}$ ÂùóÔºåÊØèÊ¨°ÊèíÂÖ•‰∏Ä‰∏™ÁÇπÔºåÂÖàÂà§Êñ≠ÊúâÊ≤°Êúâ$\sqrt{(1e5)}$‰∏™ÔºåÂ∞ë‰∫éËøô‰∏™Êï∞ÈáèÔºåÁõ¥Êé•Êö¥ÂäõÊâæÔºåÂÅáËÆæÂ∞±ÁÆóÊØèÊ¨°ÈÉΩÊòØÊª°ÁöÑÈÉΩÊòØ $\sqrt{(1e5)} * 1e5$ ÁöÑÂ§çÊùÇÂ∫¶ÔºåÁÑ∂ÂêéÂ¶ÇÊûúÊª°‰∫ÜÔºåÁõ¥Êé•Á©∫Èó¥‰∏≠bfs,ÊØîÂ¶ÇËØ¥‰Ω†ÊèíÂÖ•‰∫Ü‰∏§‰∏™ÁÇπ,0,0,1 0,0,2,Áõ¥Êé•Êö¥Âäõbfs,Êûö‰∏æ6‰∏™ÊñπÂêë,ÊâæÁ¶ªËøô‰∏™ÁÇπÊúÄËøëÁöÑË∑ùÁ¶ªÊòØÂ§öÂ∞ë„ÄÇÊö¥ÂäõÊûö‰∏æÁ©∫Èó¥Â§çÊùÇÂ∫¶ÊòØ$O(n * m * h)$.ÊÄªÂ§çÊùÇÂ∫¶Â∞±ÊòØ $q*\sqrt{q}+\sqrt{n * m * h} * q$. ËøôÁßçÂàÜÂùóÊõ¥Êñ∞ÁöÑÊìç‰ΩúÔºåÂ≠¶‰∏çÊù•ÔºåÂ≠¶‰∏çÊù•ÔºåÊ†πÊú¨Â≠¶‰∏çÊù•„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include "bits/stdc++.h" using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid ((l + r) &gt;&gt; 1)#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define eb(x) emplace_back(x)#define pb(x) emplace_back(x)#define mem(a, b) memset(a, b, sizeof(a)); const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8; #ifndef ONLINE_JUDGEclock_t prostart = clock();#endif void f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125; //typedef __int128 LLL; template&lt;typename T&gt;void read(T &amp;w) &#123;//ËØªÂÖ• char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar())) w = w * 10 + (c &amp; 15);&#125; template&lt;typename T&gt;void output(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; int ss[55], sp = 0; do ss[++sp] = x % 10; while (x /= 10); while (sp) putchar(48 + ss[sp--]);&#125; int a[maxn]; int dir[6][3] = &#123;&#123;1, 0, 0&#125;, &#123;-1, 0, 0&#125;, &#123;0, 1, 0&#125;, &#123;0, -1, 0&#125;, &#123;0, 0, 1&#125;, &#123;0, 0, -1&#125;&#125;;int X[maxn], Y[maxn], Z[maxn];int lx, ly, lz;int n, m, h, q; int get(int x, int y, int z) &#123; return x * h * m + y * h + z;&#125; struct node &#123; int k, x, y, z; node(int x, int y, int z) &#123; this-&gt;x = x; this-&gt;y = y; this-&gt;z = z; this-&gt;k = get(x, y, z); &#125;&#125;; void rebuild() &#123; queue&lt;node&gt; que; for (int i = 0; i &lt; lx; i++) &#123; que.push(node(X[i], Y[i], Z[i])); a[get(X[i], Y[i], Z[i])] = 0; &#125; while (que.size()) &#123; node t = que.front(); que.pop(); for (int i = 0; i &lt; 6; i++) &#123; int tox = t.x + dir[i][0], toy = t.y + dir[i][1], toz = t.z + dir[i][2]; if (tox &lt; 0 || tox &gt;= n || toy &lt; 0 || toy &gt;= m || toz &lt; 0 || toz &gt;= h) continue; int k = get(tox, toy, toz); if (a[k] &gt; a[t.k] + 1) &#123; a[k] = a[t.k] + 1; que.push(node(tox, toy, toz)); &#125; &#125; &#125; lx = 0; ly = 0; lz = 0;&#125; int op, x, y, z; int main() &#123; f(); mem(a, inf); read(n); read(m); read(h); read(q); while (q--) &#123; read(op); read(x); read(y); read(z); --x, --y, --z; if (op == 1) &#123; X[lx++] = x; Y[ly++] = y; Z[lz++] = z; &#125; else &#123; int k = get(x, y, z); int ans = a[k]; for (int i = 0; i &lt; lx; i++) &#123; ans = min(ans, abs(x - X[i]) + abs(z - Z[i]) + abs(y - Y[i])); &#125; output(ans); puts(""); &#125; if (lx == 300) &#123; rebuild(); &#125; &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "ËøêË°åÊó∂Èó¥:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; " s" &lt;&lt; endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Êï∞ÊçÆÁªìÊûÑ</category>
      </categories>
      <tags>
        <tag>ÁâõÂÆ¢ÊöëÊúüÂ§öÊ†°ËÆ≠ÁªÉËê•</tag>
        <tag>Ê†ëÁä∂Êï∞ÁªÑ</tag>
        <tag>ÂàÜÂùó</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019ÁâõÂÆ¢ÊöëÊúüÂ§öÊ†°ËÆ≠ÁªÉËê•(Á¨¨‰∏ÉÂú∫) E Find the median]]></title>
    <url>%2F2019%2F08%2F09%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5(%E7%AC%AC%E4%B8%83%E5%9C%BA)E.Find-the-median%2F</url>
    <content type="text"><![CDATA[2019ÁâõÂÆ¢ÊöëÊúüÂ§öÊ†°ËÆ≠ÁªÉËê•(Á¨¨‰∏ÉÂú∫)Find the median È¢òÊÑè: ÂÖàÊääËæìÂÖ•Â§ÑÁêÜ‰∏Ä‰∏ãÔºåÊ≤°Âï•ÈóÆÈ¢òÂêß„ÄÇÂ§ÑÁêÜÂÆåÂêéÂ∫îËØ•Áõ∏ÂΩì‰∫éÊØèÊ¨°Âú®‰∏Ä‰∏™ÈõÜÂêàÈáåÈù¢Âä†ÂÖ•l,r‰πãÈó¥ÊâÄÊúâÁöÑÊï∞ÔºåÈóÆ‰∏≠‰ΩçÊï∞ÊòØÂ§öÂ∞ë„ÄÇÈ¢òËß£Ôºö ËøôÈ¢òÂæàÊúâÊÑèÊÄùÔºåÁ¶ªÊï£Âåñ+Á∫øÊÆµÊ†ë Â∞±ËÉΩÂÅöÔºåÂ∞±Áõ∏ÂΩì‰∫éÂú®Á∫øÊÆµÊ†ë‰∏äÊ±ÇÁ¨¨sum/2‰∏™Êï∞Âú®Âì™„ÄÇÊØîËæÉÊú¥Á¥†ÁöÑÂ∞±ÊòØÂÖàÊääÊâÄÊúâÁöÑl,r‰øùÂ≠ò‰∏ãÊù•ÔºåÁÑ∂ÂêéÊää‰ªñÁ¶ªÊï£ÂåñÔºåÁÑ∂ÂêéÂØπÁ¶ªÊï£ÂåñÂêéÁöÑÂÄºÂÅöÊèíÂÖ•Âà†Èô§Êìç‰ΩúÔºåÊàëÊ†πÊçÆÁ∫øÊÆµÊ†ëÂä®ÊÄÅÂºÄÁÇπÁöÑÊìç‰ΩúÔºåÂÜô‰∫Ü‰∏™Âú®Á∫øÊÆµÊ†ë‰∏äÁõ¥Êé•Á¶ªÊï£ÂåñÁöÑÊìç‰ΩúÔºåÊúâÁÇπÂÉèÊääÂä®ÊÄÅÂºÄÁÇπÂíåÁ¶ªÊï£ÂåñÁªìÂêàËµ∑Êù•ÁöÑÊÑüËßâ„ÄÇÊÄª‰ΩìÊù•ËØ¥ÔºöÂ∞±ÊòØÈúÄË¶ÅÂì™‰∏™Âå∫Èó¥ÊàëÂ∞±ÊääÁ∫øÊÆµÊ†ëÁöÑ‰∏ã‰∏Ä‰∏™ËäÇÁÇπÂºÄ‰ªÄ‰πàÊ†∑ÁöÑl,rÔºå‰∏ç‰∏ÄÂÆöÊòØÂàöÂ•ΩÂàÜ‰∏ÄÂçä„ÄÇËøôÊ†∑ÂÜôÂæàÂÆπÊòìË¢´Âç°ÊéâÔºåÂõ†‰∏∫ÂèØËÉΩÈÄÄÂåñÂà∞$n^2$ÁöÑÂ§çÊùÇÂ∫¶„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;const LL mod = (LL) 1e9 + 7;const int maxn = (int) 4e7 + 5;const int MX = 4e5 + 10;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;LL n;LL x1, x2, a1, b1, c1, m1, Y1, y2, a2, b2, c2, m2;LL ls[MX], rs[MX], xs[MX], ys[MX];struct node &#123; int l; int r; int num; LL sum; int ls, rs;&#125; dat[maxn];int cnt;int init(int l, int r, int k) &#123; dat[k].l = l; dat[k].r = r; dat[k].sum = 0; dat[k].num = 0; dat[k].ls = -1; dat[k].rs = -1; return k;&#125;void build(int l, int r, int k) &#123; cnt = 0; init(l, r, cnt++);&#125;void add(int k, int num) &#123; dat[k].num += num; dat[k].sum += 1LL * (dat[k].r - dat[k].l + 1) * num;&#125;void pushdown(int k) &#123; add(dat[k].ls, dat[k].num); add(dat[k].rs, dat[k].num); dat[k].num = 0; dat[k].sum = dat[dat[k].ls].sum + dat[dat[k].rs].sum;&#125;void update(int a, int b, int k) &#123; if (b &lt; dat[k].l || a &gt; dat[k].r)return; if (a &lt;= dat[k].l &amp;&amp; dat[k].r &lt;= b) &#123; dat[k].num++; dat[k].sum += dat[k].r - dat[k].l + 1; &#125; else &#123; if (dat[k].ls == -1) &#123; int mid; if (b &lt;= dat[k].r) &#123; mid = b; &#125; else mid = a; if (mid == dat[k].l) &#123; //ÈúÄË¶Å‰ªÄ‰πàÁÇπÔºåÂºÄ‰ªÄ‰πàÁÇπ dat[k].ls = init(dat[k].l, mid, cnt++); dat[k].rs = init(mid + 1, dat[k].r, cnt++); &#125; else &#123; dat[k].ls = init(dat[k].l, mid - 1, cnt++); dat[k].rs = init(mid, dat[k].r, cnt++); &#125; &#125; pushdown(k); update(a, b, dat[k].ls); update(a, b, dat[k].rs); dat[k].sum = dat[dat[k].ls].sum + dat[dat[k].rs].sum; &#125;&#125;int querry(int k, LL x) &#123; if (dat[k].ls == -1) &#123; return dat[k].l + (x + dat[k].num - 1) / dat[k].num - 1; &#125; else &#123; pushdown(k); if (dat[dat[k].ls].sum &gt;= x) &#123; return querry(dat[k].ls, x); &#125; else return querry(dat[k].rs, x - dat[dat[k].ls].sum); &#125;&#125;int main() &#123; f(); scanf("%lld", &amp;n); scanf("%lld%lld%lld%lld%lld%lld", &amp;x1, &amp;x2, &amp;a1, &amp;b1, &amp;c1, &amp;m1); scanf("%lld%lld%lld%lld%lld%lld", &amp;Y1, &amp;y2, &amp;a2, &amp;b2, &amp;c2, &amp;m2); ls[1] = min(x1, Y1) + 1, rs[1] = max(x1, Y1) + 1; ls[2] = min(x2, y2) + 1, rs[2] = max(x2, y2) + 1; xs[1] = x1, ys[1] = Y1; xs[2] = x2, ys[2] = y2; for (int i = 3; i &lt;= n; ++i) &#123; xs[i] = (1LL * a1 * xs[i - 1] + 1LL * b1 * xs[i - 2] + c1) % m1; ys[i] = (1LL * a2 * ys[i - 1] + 1LL * b2 * ys[i - 2] + c2) % m2; ls[i] = min(xs[i], ys[i]) + 1; rs[i] = max(xs[i], ys[i]) + 1; &#125; LL mi = 1e9 + 1, mx = -1; for (int i = 1; i &lt;= n; ++i) &#123; mx = max(mx, rs[i]); mi = min(mi, ls[i]); &#125; LL S = 0; build(mi, mx, 0); for (LL i = 1; i &lt;= n; i++) &#123; S += rs[i] - ls[i] + 1; update(ls[i], rs[i], 0); printf("%d\n", querry(0, (S+1) / 2)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Êï∞ÊçÆÁªìÊûÑ</category>
      </categories>
      <tags>
        <tag>Á∫øÊÆµÊ†ë</tag>
        <tag>ÁâõÂÆ¢ÊöëÊúüÂ§öÊ†°ËÆ≠ÁªÉËê•</tag>
        <tag>Á¶ªÊï£Âåñ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 5 1002 three arrays]]></title>
    <url>%2F2019%2F08%2F09%2F2019-Multi-University-Training-Contest-5-1002-three-arrays%2F</url>
    <content type="text"><![CDATA[HDU 6625 three arraysÈ¢òÊÑèÔºö Áªô‰∏§‰∏™Êï∞ÁªÑÔºåÊ±Ç‰∏§‰∏™Êï∞ÁªÑ‰∏§‰∏§ÂºÇÊàñÂêéÊúÄÂ∞èÂ≠óÂÖ∏Â∫è„ÄÇÈ¢òËß£Ôºö Ê±ÇÂ≠óÂÖ∏Â∫èÊúÄÂ∞èÔºå‰πüÂ∞±ÊòØÊ±ÇÂÄºÊúÄÂ∞èÔºåÂ¶ÇÊûúÊòØÊ±Ç‰∏Ä‰∏™Êï∞ÂíåÂè¶‰∏Ä‰∏™Êï∞ÁªÑÈáåÈù¢ÁöÑ‰∏Ä‰∏™ÂÄºÂºÇÊàñÊúÄÂ∞èÔºåÂæàÊòæÁÑ∂Â∞±ÊòØÂ≠óÂÖ∏Ê†ëÔºåÂ∞±ÊòØÂú®Â≠óÂÖ∏Ê†ë‰∏ä‰ºòÂÖàÂèñÂêå‰ΩçÁõ∏ÂêåÔºåÊ≤°ÊúâÂÜçÂèñÂêå‰ΩçÁõ∏Âèç„ÄÇÊ±Ç‰∏§‰∏™Êï∞ÁªÑÂºÇÊàñ‰πãÂêéÂ≠óÂÖ∏Â∫èÊúÄÂ∞èÔºåÂÖ∂ÂÆû‰πüÂèØ‰ª•ÊåâÁÖßÂêåÊ†∑ÁöÑÊñπÊ≥ïÊ±ÇËß£„ÄÇÂØπ‰∏§‰∏™Êï∞ÁªÑÂàÜÂà´ÂÅöÊàê‰∏ÄÈ¢óÂ≠óÂÖ∏Ê†ëÔºåÊ±Ç‰∏§È¢óÁ∫øÊÆµÊ†ëÂºÇÊàñ‰πãÂêéÂ≠óÂÖ∏Â∫èÊúÄÂ∞èÔºåÂ∞±ÊòØ‰∏§È¢óÊ†ëÂºÇÊàñÂÄºÂ∞ΩÂèØËÉΩÂ∞è„ÄÇ‰∏ÄÂºÄÂßãÊàëÊÉ≥Âà∞Ëøô‰∏™ÂÜôÊ≥ïÁöÑÊó∂ÂÄôÔºåÈòüÂèãËØ¥Â¶ÇÊûú0 0ÔºåÂíå1 1 ÂºÇÊàñÈÉΩÁ≠â‰∫é0 ÂÖàÈÄâÂì™‰∏Ä‰∏™Ôºå‰ªîÁªÜÊÄùËÄÉ‰∏Ä‰∏ãÔºåÂÖ∂ÂÆûÊ≤°Êúâ‰ªÄ‰πàÂΩ±ÂìçÔºåÁªüËÆ°‰∏Ä‰∏ã‰∏§È¢óÊ†ëÂΩìÂâçËäÇÁÇπ‰∏ãÊñπÔºå0 1 ÁöÑ‰∏™Êï∞Ôºå‰ºòÂÖàÊää 0 0 1 1 ÂåπÈÖçÊéâÔºåÁÑ∂ÂêéÂÜçÊää0 1 1 0‰∏§ÁßçÂåπÈÖçÊéâ„ÄÇÊúâÁÇπÂÉèÂú®Â≠óÂÖ∏Ê†ë‰∏äË¥™ÂøÉ.Â§çÊùÇÂ∫¶‰∏§È¢óÊ†ëÊúÄÂ§öÊúân*31‰∏™ËäÇÁÇπÔºåÊúÄÂ∑ÆÂ∞±ÊòØÊØè‰∏™Ê†ëÈÉΩË∑ë‰∏ÄÊ¨°ÔºåÊâÄ‰ª•Â§çÊùÇÂ∫¶ÊòØ$O(nlog(n))$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;int n;inline int getpos(int x, int pos) &#123; return ((x &gt;&gt; pos) &amp; 1);&#125;struct tree &#123; int a[maxn * 10][3]; int num[maxn * 10][3]; int root = 0; int cnt = 1; void init() &#123; cnt = 1; &#125; void insert(int x) &#123; int p = root, dep = 30; while (dep &gt;= 0) &#123; int nx = getpos(x, dep); if (num[p][nx] == 0) &#123; a[p][nx] = cnt++; num[p][nx] = 1; &#125; else &#123; num[p][nx]++; &#125; p = a[p][nx]; dep--; &#125; &#125;&#125; t1, t2;vector&lt;int&gt; v;template&lt;class T&gt;inline T min(T t1, T t2, T t3) &#123; return min(t1, min(t2, t3));&#125;void dfs(int now1, int now2, int num, int val, int dep) &#123; if (dep == -1) &#123; for (int i = 0; i &lt; num; i++) v.emplace_back(val); return; &#125; if (t1.num[now1][0] &gt; 0 &amp;&amp; t2.num[now2][0] &gt; 0 &amp;&amp; num &gt; 0) &#123; int ct = min(t2.num[now2][0], t1.num[now1][0], num); dfs(t1.a[now1][0], t2.a[now2][0], ct, val, dep - 1); t1.num[now1][0] -= ct; t2.num[now2][0] -= ct; num -= ct; &#125; if (t1.num[now1][1] &gt; 0 &amp;&amp; t2.num[now2][1] &gt; 0 &amp;&amp; num &gt; 0) &#123; int ct = min(t1.num[now1][1], t2.num[now2][1], num); dfs(t1.a[now1][1], t2.a[now2][1], ct, val, dep - 1); t1.num[now1][1] -= ct; t2.num[now2][1] -= ct; num -= ct; &#125; if (t1.num[now1][0] &gt; 0 &amp;&amp; t2.num[now2][1] &gt; 0 &amp;&amp; num &gt; 0) &#123; int ct = min(t2.num[now2][1], t1.num[now1][0], num); dfs(t1.a[now1][0], t2.a[now2][1], ct, val | (1 &lt;&lt; dep), dep - 1); t1.num[now1][0] -= ct; t2.num[now2][1] -= ct; num -= ct; &#125; if (t1.num[now1][1] &gt; 0 &amp;&amp; t2.num[now2][0] &gt; 0 &amp;&amp; num &gt; 0) &#123; int ct = min(t1.num[now1][1], t2.num[now2][0], num); dfs(t1.a[now1][1], t2.a[now2][0], ct, val | (1 &lt;&lt; dep), dep - 1); t1.num[now1][1] -= ct; t2.num[now2][0] -= ct; num -= ct; &#125;&#125;int main() &#123; f(); int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); t1.init(); t2.init(); for (int i = 0; i &lt; n; i++) &#123; int a; scanf("%d", &amp;a); t1.insert(a); &#125; for (int j = 0; j &lt; n; j++) &#123; int a; scanf("%d", &amp;a); t2.insert(a); &#125; v.clear();// debug(t2.num[29][1]); dfs(0, 0, n, 0, 30); sort(v.begin(), v.end()); for (int i = 0; i &lt; n; i++) &#123; printf("%d%c", v[i], i == n - 1 ? '\n' : ' '); &#125; &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "ËøêË°åÊó∂Èó¥:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; endl;#endif return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Êï∞ÊçÆÁªìÊûÑ</category>
      </categories>
      <tags>
        <tag>Êù≠ÁîµÂ§öÊ†°</tag>
        <tag>Â≠óÂÖ∏Ê†ë</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÂõûÊñáÊ†ë]]></title>
    <url>%2F2019%2F08%2F07%2F%E5%9B%9E%E6%96%87%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Ëøô‰∏™‰∏úË•øÂ≠¶‰ºö‰∫ÜACËá™Âä®Êú∫ ÁêÜËß£Ëøô‰∏™Â∫îËØ•‰∏çÈöæÔºåACËá™Âä®failÊåáÈíà‰øùÂ≠ò‰∫Ü‰∏Ä‰∏™ÊúÄÈïøÂåπÈÖçÂêéÁºÄÔºåËøô‰∏™‰πüÂ∑Æ‰∏çÂ§ö„ÄÇËøô‰∏™‰øùÂ≠ò‰∫ÜÊúÄÈïøÂåπÈÖçÂêéÁºÄÂõûÊñá‰∏≤„ÄÇ‰∏æ‰∏™‰æãÂ≠êËÄÅÂ≠êÊâæ‰∫ÜÂçäÂ§©Ê≤°ÊâæÂà∞ÂéüÊú¨ÁúãËøáÁöÑÂçöÂÆ¢ÔºåÂè™ÊâæÂà∞‰∫ÜËøôÂº†ÂõæÁâá„ÄÇÈöè‰æøÂÜôÂá†Âè•Ê∑∑‰∏ÄÊ∑∑Â∞±ËøáÂéª‰∫Ü„ÄÇÂõûÊñáÊ†ëÈáåÈù¢ÁöÑnext ÂíåÂ≠óÂÖ∏Ê†ëÂ∑Æ‰∏çÂ§öÁöÑÊÑè‰πâÔºåÂè™‰∏çËøáÂ≠óÂÖ∏Ê†ëÈáåÈù¢ÁöÑ‰∏Ä‰∏™ËäÇÁÇπÊòØË°®Á§∫Âú®‰∏Ä‰∏™ËäÇÁÇπÂêéÈù¢Âä†‰∏ä‰∏Ä‰∏™Â≠óÁ¨¶Ôºå‰ΩÜnextÊòØÂâçÂêéÂêÑÂä†‰∏Ä‰∏™Â≠óÁ¨¶,Â∞±ÊòØtÂèòÊàêtc ÂíåtÂèòÊàêctcÁöÑÂå∫Âà´ÔºåÂâçÂêéÂêÑÂä†‰∏Ä‰∏™Â≠óÁ¨¶ËÇØÂÆöÊòØÂõûÊñá‰∏≤„ÄÇÈÇ£‰πàÈóÆÈ¢òÊù•‰∫ÜÂ•áÊï∞ÁöÑÂõûÊñá‰∏≤ÊÄé‰πàÂäûÔºåÊâÄ‰ª•Âá∫Áé∞Âïä‰∫Ü‰∏§‰∏™Ê†πËäÇÁÇπÔºå‰∏Ä‰∏™0,‰∏Ä‰∏™-1ÔºåËøûÂú®-1ÁöÑË°®Á§∫ÊòØ‰∏™Â•áÊï∞‰∏™Êï∞ÁöÑÂõûÊñá‰∏≤ÔºåÁúã‰ª£Á†ÅÈáåÈù¢ÁöÑx-len[p]+1ÂàöÂ•Ω‰πüÊòØËá™Â∑±ÔºåÊâÄ‰ª•Ëá™Â∑±ÂíåËá™Â∑±‰∏ÄÂÆöÊòØÂõûÊñá‰∏≤Ê≤°Âï•ÊØõÁóÖ„ÄÇÂÜçÁªô‰∏™ÂõæfailÂ∑Æ‰∏çÂ§öÂ∞±ÊòØ‰∏äÂõæÁöÑÊÑèÊÄù.Ëß£Èáä‰∏ã‰æãÂ≠êÊÄé‰πàÊûÑÈÄ†ÁöÑÂºÄÂßãÁöÑÊó∂ÂÄôÂª∫Á´ã‰∏§‰∏™Ê†πËäÇÁÇπ,‰∏§‰∏™Ê†πËäÇÁÇπ‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫0,‰∏Ä‰∏™-1ÔºåÂ∞Üfail[0]=1,0Ë°®Á§∫ÈïøÂ∫¶‰∏∫0,1Âè∑ËäÇÁÇπÈïøÂ∫¶‰∏∫-1,‰∏ÄÂºÄÂßãÂä†ÂÖ•aËÇØÂÆöÊòØÊ≤°Êúâ‰ªª‰ΩïÂêéÁºÄÔºåÁõ¥Êé•Ëøû‰∏ä-1Ê†πËäÇÁÇπÔºåfailËÇØÂÆöÊòØËøû‰∏ä0ÔºåÊ≠§Êó∂ÂΩìÂâçËäÇÁÇπÁöÑÂõûÊñáÂêéÁºÄÊúâaÔºåÁ©∫‰∏≤Âíå-1ÔºåÁÑ∂ÂêéÊ∑ªÂä†b,aËäÇÁÇπÂâçÈù¢ÂæàÊòæÁÑ∂Ê≤°ÊúâbÔºåÊâÄ‰ª•Êó†Ê≥ïÂåπÈÖçÔºåÁÑ∂ÂêéÂåπÈÖçÁ©∫‰∏≤ÔºåÁ©∫‰∏≤ÂâçÈù¢ÊòØaÊâÄ‰ª•ËøòÊòØÊ≤°Ê≥ïÂåπÈÖçÔºåÂèàÂåπÈÖç-1ÔºåÂæàÊòæÁÑ∂Ëøô‰∏™‰∏ÄÂÆöÊòØÂèØ‰ª•ÁöÑÔºåÂõ†‰∏∫ÂíåËá™Â∑±ËÇØÂÆöÊòØÁõ∏ÂêåÁöÑ.‰πüÂ∞±ÊòØÊûÑÂª∫‰∫ÜËøô‰∏ÄÈÉ®ÂàÜ„ÄÇÁÑ∂Âêé‰∏ã‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ËøòÊòØb,Ê≠§Êó∂ÂêéÁºÄÊúâb,Á©∫‰∏≤Âíå-1ÔºåÂåπÈÖçÂêéÁºÄbÂâç‰∏Ä‰∏™ÊòØaÂæàÊòæÁÑ∂‰∏çÂåπÈÖçÔºåÂåπÈÖçÁ©∫‰∏≤,Ââç‰∏Ä‰∏™ÂàöÂ•ΩÊòØbÊâÄ‰ª•Ê≠§Êó∂ÔºåÂ∞ÜbbËøûÂà∞0ËäÇÁÇπ‰∏ãÈù¢ÔºåfailÊåáÂêëÁà∂‰∫≤ËäÇÁÇπÂ§±Èô™ÁöÑÁ¨¨‰∏Ä‰∏™ËÉΩÂ§üÂåπÈÖçbÁöÑ‰ΩçÁΩÆÔºåËøô‰∏™ÊúâÁÇπÈöæÁêÜËß£„ÄÇÂú®‰ª£Á†Å‰∏≠ÊòØËøô‰∏ÄË°å„ÄÇ‰∏ã‰∏Ä‰∏™Â≠óÁ¨¶ÊòØaÔºåÊ≠§Êó∂Â≠óÁ¨¶‰∏≤ÊúÄÈïøÂõûÊñáÂêéÁºÄÊúâbb,b,Á©∫‰∏≤Âíå-1,ÊòæÁÑ∂bbÂ∞±Áõ¥Êé•ÂåπÈÖç‰∫ÜÔºåÁÑ∂ÂêéÂÜçÊõ¥Êñ∞fail,Â∑Æ‰∏çÂ§öÂ∞±ÊòØËøô‰πà‰∏™ËøáÁ®ã„ÄÇÂ§ö‰ΩôÁöÑ‰∏çËß£ÈáäÁúãÂà´‰∫∫ÂçöÂÆ¢ÂéªÂêß„ÄÇÊÉ≥Ê∑±ÂÖ•‰∫ÜËß£ÔºåÂéªÁúãÁúã ÂõΩÂÆ∂ÈõÜËÆ≠Èòü2017Âπ¥ÁöÑËÆ∫Êñá Âêß12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061namespace Palindromic_Tree &#123;const int MAXN = 1000010;const int N = 26;int next[MAXN][N];//nextÊåáÈíàÔºånextÊåáÈíàÂíåÂ≠óÂÖ∏Ê†ëÁ±ª‰ººÔºåÊåáÂêëÁöÑ‰∏≤‰∏∫ÂΩìÂâç‰∏≤‰∏§Á´ØÂä†‰∏äÂêå‰∏Ä‰∏™Â≠óÁ¨¶ÊûÑÊàêint fail[MAXN];//failÊåáÈíàÔºåÂ§±ÈÖçÂêéË∑≥ËΩ¨Âà∞failÊåáÈíàÊåáÂêëÁöÑËäÇÁÇπint cnt[MAXN];int num[MAXN];int len[MAXN];//len[i]Ë°®Á§∫ËäÇÁÇπiË°®Á§∫ÁöÑÂõûÊñá‰∏≤ÁöÑÈïøÂ∫¶int S[MAXN];//Â≠òÊîæÊ∑ªÂä†ÁöÑÂ≠óÁ¨¶int last;//ÊåáÂêë‰∏ä‰∏Ä‰∏™Â≠óÁ¨¶ÊâÄÂú®ÁöÑËäÇÁÇπÔºåÊñπ‰æø‰∏ã‰∏ÄÊ¨°addint n;//Â≠óÁ¨¶Êï∞ÁªÑÊåáÈíàint p;//ËäÇÁÇπÊåáÈíàint newnode(int l) &#123;//Êñ∞Âª∫ËäÇÁÇπ for (int i = 0; i &lt; N; ++i) next[p][i] = 0; cnt[p] = 0; num[p] = 0; len[p] = l; return p++;&#125;void init() &#123;//ÂàùÂßãÂåñ p = 0; newnode(0); newnode(-1); last = 0; n = 0; S[n] = -1;//ÂºÄÂ§¥Êîæ‰∏Ä‰∏™Â≠óÁ¨¶ÈõÜ‰∏≠Ê≤°ÊúâÁöÑÂ≠óÁ¨¶ÔºåÂáèÂ∞ëÁâπÂà§ fail[0] = 1;&#125;int get_fail(int x) &#123;//ÂíåKMP‰∏ÄÊ†∑ÔºåÂ§±ÈÖçÂêéÊâæ‰∏Ä‰∏™Â∞ΩÈáèÊúÄÈïøÁöÑ while (S[n - len[x] - 1] != S[n]) x = fail[x]; return x;&#125;int add(int c) &#123; c -= 'a'; S[++n] = c; int ct = 0; int cur = get_fail(last);//ÈÄöËøá‰∏ä‰∏Ä‰∏™ÂõûÊñá‰∏≤ÊâæËøô‰∏™ÂõûÊñá‰∏≤ÁöÑÂåπÈÖç‰ΩçÁΩÆ if (!next[cur][c]) &#123;//Â¶ÇÊûúËøô‰∏™ÂõûÊñá‰∏≤Ê≤°ÊúâÂá∫Áé∞ËøáÔºåËØ¥ÊòéÂá∫Áé∞‰∫Ü‰∏Ä‰∏™Êñ∞ÁöÑÊú¨Ë¥®‰∏çÂêåÁöÑÂõûÊñá‰∏≤ int now = newnode(len[cur] + 2);//Êñ∞Âª∫ËäÇÁÇπ fail[now] = next[get_fail(fail[cur])][c];//ÂíåACËá™Âä®Êú∫‰∏ÄÊ†∑Âª∫Á´ãfailÊåáÈíàÔºå‰ª•‰æøÂ§±ÈÖçÂêéË∑≥ËΩ¨ next[cur][c] = now; num[now] = num[fail[now]] + 1; ct = num[now]; &#125; last = next[cur][c]; cnt[last]++; return num[last];&#125;void count() &#123; for (int i = p - 1; i &gt;= 0; --i) cnt[fail[i]] += cnt[i]; //Áà∂‰∫≤Á¥ØÂä†ÂÑøÂ≠êÁöÑcntÔºåÂõ†‰∏∫Â¶ÇÊûúfail[v]=uÔºåÂàôu‰∏ÄÂÆöÊòØvÁöÑÂ≠êÂõûÊñá‰∏≤ÔºÅ&#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Â≠óÁ¨¶‰∏≤</category>
      </categories>
      <tags>
        <tag>ÂõûÊñáÊ†ë</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACËá™Âä®Êú∫]]></title>
    <url>%2F2019%2F08%2F07%2FAC%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[ACËá™Âä®Êú∫Áî®ÈÄîÁªôÂ§ö‰∏™Â≠óÁ¨¶‰∏≤tÔºåÂÜçËØ¢ÈóÆ‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤sÔºåÈóÆÊúâÂ§öÂ∞ë‰∏™Â≠óÁ¨¶‰∏≤tÂá∫Áé∞Âú®ËØ¢ÈóÆÁöÑÂ≠óÁ¨¶‰∏≤s‰∏≠„ÄÇ ÂâçÁΩÆÊäÄËÉΩÂ≠¶ACËá™Âä®Êú∫‰πãÂâçÔºåÂÖàÂ≠¶‰ºö‰ªÄ‰πàÊòØÂ≠óÂÖ∏Ê†ëÔºå‰ªÄ‰πàÊòØkmp„ÄÇkmpÊàëÂÜôËøá‰∏ÄÁØáÂçöÂÆ¢ÔºåÂ∞±‰∏çËÆ≤‰∫ÜÔºåÂ∞±ÊòØnext Êï∞ÁªÑ‰øùÂ≠ò‰∏Ä‰∏™ÊúÄÈïøÂåπÈÖçÂâçÁºÄ„ÄÇÂ≠óÂÖ∏Ê†ëÂ∞±Êõ¥ÁÆÄÂçï‰∫ÜÔºåÊØè‰∏™ËäÇÁÇπ‰ªéÊ†πËäÇÁÇπÂºÄÂßãÔºåÂá∫Áé∞‰∏Ä‰∏™Â≠óÁ¨¶Â∞±Âú®Áà∂‰∫≤ËäÇÁÇπ‰∏äËøû‰∏ä‰∏ã‰∏Ä‰∏™ËäÇÁÇπÔºå‰πü‰∏çÂ§öËØ¥„ÄÇÊúâÈúÄË¶ÅÂÜçÂÜô‰∏ÄÁØáÂçöÂÆ¢„ÄÇ ACËá™Âä®Êú∫ÂØπ‰∫éËøô‰∏™Áé©ÊÑèÔºåÈÉΩËØ¥ÊòØÂ≠óÂÖ∏Ê†ë‰∏äË∑ëKMP,Âà∞‰πüÊ≤°Èîô„ÄÇÊú¥Á¥†KMPÊòØÂú®‰∏Ä‰∏™‰∏≤‰∏äÈù¢Ë∑ënext,ËÄåACËá™Âä®Êú∫Âè™ÊòØÂèòÊàê‰∫ÜÂú®Â≠óÂÖ∏Ê†ëËäÇÁÇπ‰∏äË∑ëfailÊåáÈíàÔºåÊØè‰∏™failÊåáÈíà‰øùÂ≠òÊòØÊúÄÈïøÂåπÈÖçÂêéÁºÄ„ÄÇÊé®Ëçê‰∏ÄÂêçÂ§ß‰Ω¨ÂçöÂÆ¢ÔºåËÆ≤ÁöÑÊå∫‰∏çÈîôÁöÑ„ÄÇÊú¥Á¥†ÁöÑÂÜôÊ≥ïÔºåÊØè‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤tÂØπsÂÅö‰∏ÄÊ¨°kmpÁÆóÊ≥ïÊàñËÄÖ ÂØπÊâÄÊúâÁöÑtÂ≠óÁ¨¶‰∏≤Âª∫‰∏ÄÈ¢óÂ≠óÂÖ∏Ê†ëÔºåÁÑ∂ÂêéÊØè‰∏™‰ΩçÁΩÆÂåπÈÖç‰∏Ä‰∏ãÔºåÂæàÊòæÁÑ∂$O(n^2)$ÁöÑÂ§çÊùÇÂ∫¶ÔºåÁªùÂØπË∂ÖÊó∂„ÄÇ‰ªîÁªÜÊÄùËÄÉ‰∏Ä‰∏ãÔºåÂ≠óÂÖ∏Ê†ëÈáåÈù¢ÔºåÊØèÊ¨°ÂåπÈÖçÈÉΩË¶Å‰ªé‰∏ã‰∏Ä‰∏™‰ΩçÁΩÆÂºÄÂßãË∑ë‰∏ÄÊ¨°ÂåπÈÖçÔºåÁ±ªÊØî‰∏Ä‰∏ãÊ≤°ÊúâkmpÁöÑÊú¥Á¥†Â≠óÁ¨¶‰∏≤ÂåπÈÖç„ÄÇÊòØ‰∏çÊòØÊúâÁÇπÁõ∏‰ºº„ÄÇÊôÆÈÄöÂçï‰∏™Â≠óÁ¨¶‰∏≤ÂåπÈÖçÔºåÊòØ‰∏çÊòØÊûö‰∏æÊØè‰∏Ä‰∏™‰ΩçÁΩÆÔºåÁÑ∂ÂêéÂÅö‰∏ÄÊ¨°Êö¥ÂäõÂåπÈÖçÔºüÁÑ∂Âêékmp ÂÅö‰∫Ü‰ªÄ‰πàÔºåÈÄöËøánextÊâæÂà∞ÊúÄÂ§ßÂåπÈÖçÂâçÁºÄ„ÄÇÈÇ£‰πàÊàë‰ª¨ÊòØÂê¶ÂèØ‰ª•Âú®Â≠óÂÖ∏Ê†ëÁî®fail‰øùÂ≠òÊúÄÂ§ßÂåπÈÖçÂêéÁºÄÂë¢ÔºüÊòæÁÑ∂ÊòØÂèØ‰ª•ÁöÑÔºå‰∏çÁÑ∂ACËá™Âä®Êú∫Âπ≤Âï•.‰∏æ‰∏™Ê†óÂ≠êÔºö ÂÅáËÆæÊúâ‰∏â‰∏™t asa aaa aas, ÂåπÈÖçaasabÂ≠óÂÖ∏Ê†ëÂª∫ÊàêËøô‰∏™Ê†∑Â≠êÔºå‰∏ë‰∫ÜÁÇπÔºåÂà´Âú®ÊÑèÔºåÈáçÂú®ÊÄùÊÉ≥„ÄÇÁÑ∂Âêé‰∏ÄÂºÄÂßãÂêßaasÂåπÈÖçÊéâ‰∫ÜÊ≤°Âï•ÊÑèËßÅÂêßÔºåÁÑ∂ÂêéÁªßÁª≠ÂåπÈÖçaasaÔºåÂæàÊòæÁÑ∂Ëøô‰∏™Êó∂ÂÄôÊ≤°ÊúâËøô‰∏™Â≠óÁ¨¶‰∏≤ÔºåÈÇ£‰πàËÇØÂÆöÂ∞±Ë¶ÅËΩ¨ÁßªÔºåËΩ¨ÁßªÂà∞Âì™ÂéªÂë¢ÔºüÊúÄÈïøÂåπÈÖçÂêéÁºÄÂïä„ÄÇÂ¶ÇÂõæÊòØ‰∏çÊòØËøôÊ†∑„ÄÇÁÑ∂ÂêéÂåπÈÖçasa,ÂÜçÁªßÁª≠ÂåπÈÖçb,ÂæàÊòæÁÑ∂Â§±ÈÖç‰∫ÜÂïäÔºåÁÑ∂ÂêéÊâæÊúÄÈïøÂåπÈÖçÂêéÁºÄÔºåÂè™ÊúâÊ†πËäÇÁÇπ‰∫ÜÔºåÁÑ∂ÂêéÊ†πËäÇÁÇπËÉåÂêéÂèàÊ≤°Êúâb„ÄÇÊâÄ‰ª•Âï•ÈÉΩÊ≤°‰∫ÜÔºåÂåπÈÖçÊúÄÈïøÂêéÁºÄ‰∏∫Á©∫‰∏≤„ÄÇÂ•Ω‰∫ÜÔºåÁé∞Âú®Â∑Æ‰∏çÂ§öÁêÜËß£Ëøô‰∏™ÁÆóÊ≥ïÁöÑÊÄùÊÉ≥ÔºåÊé•‰∏ãÊù•Â∞±ÊòØ‰∏Ä‰∫õÁªÜËäÇÔºå‰∏çÁü•ÈÅìÊàëËøòÊúâÊ≤°ÊúâÊ≤°ÊúâËÄÉËôëÂà∞ÁöÑÔºåÂ¶ÇÊûúÊúâËØ∑Âú®ËØÑËÆ∫Âå∫ÊèêÈóÆ„ÄÇ1.‰∏äËØâÊâÄËÆ≤ÁöÑ‰æãÂ≠êÂæàÊòéÊòæÔºåaasÂêëasË∑≥ËΩ¨ÔºåÂ¶ÇÊûúÂêéÁªßÊ≤°ÊúâaËøô‰∏™ËäÇÁÇπÊÄé‰πàÂäû?asa ÊîπÊàêasb,asaË¶ÅÂåπÈÖçË∞ÅÂë¢ÔºüËøô‰∏™Âú®kmpÁÆóÊ≥ïÈáåÈù¢‰πüÊúâËøô‰∏™ÈóÆÈ¢òÔºåÂæàÊòæÁÑ∂ÔºåÁªßÁª≠Êâæ‰∏ãÂéªÂ∞±ËÉΩËß£ÂÜ≥ÈóÆÈ¢òÔºåÂÅáËÆæ ÂÜçÂä†‰∏Ä‰∏™tsbÔºåaasbÈÄÇÈÖçÔºåaasË∞ÉËΩ¨Âà∞asÊ≤°ÊúâÂêéÁªßb,ÂÜçË∑≥ËΩ¨Âà∞ÂåπÈÖçÂêéÁºÄsÔºåÊúâÂêéÁªßbÂ∞±ÂåπÈÖçsbÔºåÁ±ªÊé®ÔºåÂ¶ÇÊûúËøòÊ≤°ÊúâÊâæÂà∞Â∞±ÁªßÁª≠ÊÉ≥‰∏äÊâæ„ÄÇps: Ëøô‰∏™Âú∞ÊñπÂèØ‰ª•‰ºòÂåñÔºåfailÊåáÈíàÊâæÂà∞‰∫ÜÊúÄÈïøÂåπÈÖçÂêéÁºÄÔºåÁÑ∂ÂêéÂ≠óÂÖ∏Ê†ëÁöÑ‰∏ã‰∏Ä‰∏™ËäÇÁÇπÂèØ‰ª•Áõ¥Êé•Ë∑≥Âà∞ÂØπÂ∫î‰ΩçÁΩÆÂ¶Ç‰æãÂ≠ê aasÂêéÁªßaÂèØ‰ª•Áõ¥Êé•Ë∑≥Âà∞‰∏∫asaËøô‰∏™ËäÇÁÇπÔºå‰∏çËøá‰∏ç‰ºòÂåñ‰πüÊ≤°Âï•ÂΩ±ÂìçÔºåÂõ†‰∏∫Â≠óÁ¨¶‰∏≤ÈïøÂ∫¶ÊòØÂõ∫ÂÆöÁöÑÔºåÊúÄÂ§ö‰∏ç‰ºöË∑≥Ë∂ÖËøánÊ¨°Ôºå‰∏ç‰ºòÂåñÂè™ÊòØÂ§ö‰∫Ü‰∏™Â∏∏Êï∞2.Â§ö‰∏™ÂåπÈÖçÊÄé‰πàÂäûÔºüÊ≤°Âà∞‰∏Ä‰∏™ËäÇÁÇπÊää‰ªñÁöÑfailÊâæ‰∏ãÂéªËÆ∞ÂΩï‰∏™Êï∞ÔºåÂ¶ÇÂõæÂ≠óÂÖ∏Ê†ëÂåπÈÖçsa,ÁöÑÊó∂ÂÄô‰ºöÊâæ‰ªñÁöÑfail,ÊâæÂà∞aÁÑ∂ÂêéÊääaËøô‰∏™ËäÇÁÇπËÆ∞ÂΩïÔºåÂêåÁêÜÊâæsab,‰∏ç‰ªÖ‰ªÖÊääËá™Â∑±ÂåπÈÖç‰∫ÜÔºåËøòË¶ÅÊääbÂåπÈÖçÊéâ3.ÊÄé‰πàËÆ∞ÂΩï‰∏™Êï∞ÔºåÂ¶ÇÊûú‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤Â§öÊ¨°Âá∫Áé∞ÊÄé‰πàÂäûÔºåÁúã‰ª£Á†ÅÔºåËÆ∞ÂΩï‰∏Ä‰∏ãÂ∞±Ë°å‰∫Ü„ÄÇ Ëøô‰∏™ACËá™Âä®Êú∫ÁöÑÊÄùÊÉ≥ËøòÊòØË¶ÅÂ≠¶Â•ΩÔºåÂêéÈù¢ÂõûÊñáËá™Âä®Êú∫Ë¶ÅÁî®Âà∞Ëøô‰∏™Áé©ÊÑèÁöÑÊÄùÊÉ≥„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263namespace Aho_Corasick_Automaton &#123;int trie[maxn][27]; //Â≠óÂÖ∏Ê†ëint cntword[maxn]; //ËÆ∞ÂΩïÂçïËØçÂá∫Áé∞Ê¨°Êï∞ÔºåÂèØ‰ª•ÂºÄ‰∏Ä‰∏™vectorËÆ∞ÂΩïÊòØÁ¨¨Âá†‰∏™ÂçïËØçint fail[maxn]; // Â§±Ë¥•ÂõûÊ∫Øint cnt=0; // Ê†ëÁöÑËäÇÁÇπ‰∏™Êï∞void init(int x) &#123; for(int i=0; i&lt;26; i++) &#123; trie[x][i]=0; &#125;&#125;void insertWords(char *s) &#123; int ls=strlen(s); int root=0; for(int i=0; i&lt;ls; i++) &#123; int next=s[i]-'a'; if(!trie[root][next]) &#123; init(++cnt); trie[root][next]=cnt; &#125; root=trie[root][next]; &#125; cntword[root]++;&#125;void getFial() &#123; queue&lt;int&gt; q; for(int i=0; i&lt;26; i++) &#123; if(trie[0][i]) &#123; fail[trie[0][i]]=0; q.push(trie[0][i]); &#125; &#125; while(q.size()) &#123; int now=q.front(); q.pop(); for(int i=0; i&lt;26; i++) &#123; if(trie[now][i]) &#123; fail[trie[now][i]]=trie[fail[now]][i]; q.push(trie[now][i]); &#125; else trie[now][i]=trie[fail[now]][i]; &#125; &#125;&#125;int query(char *s) &#123; int ls=strlen(s); int now =0,ans=0; for(int i=0; i&lt;ls; i++) &#123; now=trie[now][s[i]-'a']; for(int j=now; j&amp;&amp;cntword[j]!=-1; j=fail[j]) &#123; // Â¶ÇÊûúËøôÁßçÁä∂ÊÄÅÂ∑≤ÁªèËÆ°ÁÆóËøá‰∫ÜÂ∞±‰∏çÁî®ÁªßÁª≠Êâæ‰∏ãÂéª‰∫Ü ans+=cntword[j];//ÁªüËÆ°‰∏™Êï∞ÔºåÂèØ‰ª•Âú®ËøôËøõË°åÂêÑÁßçÊìç‰Ωú cntword[j]=-1; &#125; &#125; return ans;&#125;&#125; ÂÜçË¥¥‰∏Ä‰∏™Â§ßÂì•ÊùøÂ≠ê123456789101112131415161718192021222324252627282930313233343536373839queue&lt;int&gt;q;struct Aho_Corasick_Automaton &#123; int c[N][26],val[N],fail[N],cnt; void ins(char *s) &#123; int len=strlen(s); int now=0; for(int i=0; i&lt;len; i++) &#123; int v=s[i]-'a'; if(!c[now][v]) c[now][v]=++cnt; now=c[now][v]; &#125; val[now]++; &#125; void build() &#123; for(int i=0; i&lt;26; i++) if(c[0][i]) fail[c[0][i]]=0,q.push(c[0][i]); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=0; i&lt;26; i++) if(c[u][i]) fail[c[u][i]]=c[fail[u]][i],q.push(c[u][i]); else c[u][i]=c[fail[u]][i]; &#125; &#125; int query(char *s) &#123; int len=strlen(s); int now=0,ans=0; for(int i=0; i&lt;len; i++) &#123; now=c[now][s[i]-'a']; for(int t=now; t&amp;&amp;~val[t]; t=fail[t]) ans+=val[t],val[t]=-1; &#125; return ans; &#125;&#125; AC;]]></content>
      <categories>
        <category>ACM</category>
        <category>Â≠óÁ¨¶‰∏≤</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>ACËá™Âä®Êú∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 4-1003 Divide the Stones]]></title>
    <url>%2F2019%2F07%2F31%2F2019-Multi-University-Training-Contest-4-1003%2F</url>
    <content type="text"><![CDATA[HDU 6616 Divide the StonesÈ¢òÊÑèÔºö Áªô‰∏Ä‰∏™nÂíå‰∏Ä‰∏™kÔºåÂ∞ÜÈáçÈáè‰∏∫[1,n]ÁöÑÁü≥Â≠êÂàÜÊàêkÂ†ÜÔºåÊØèÂ†ÜÈáçÈáè‰∏ÄÊ†∑„ÄÇÈ¢òËß£Ôºö ÂÖàÂ∞ÜÁü≥Â≠êÂàÜÊàên/k‰ªΩÔºåÊØîÂ¶Ç15 3ÔºåÂàÜÊàê1 2 34 5 67 8 910 11 1213 14 15‰∏çÈöæÁúãÂá∫Â¶ÇÊûúÂàöÂ•ΩÂÅ∂Êï∞ÂàÜÔºåÊØè‰∏§‰ªΩÁªÑÊàê‰∏Ä‰∏™ÔºåÂàÜÈÖç‰∏ÄÂÆöÊòØÂàöÂ•ΩÂàÜÈÖçÂêàÁêÜÁöÑÔºåÊØîÂ¶Ç‰∏äËø∞‰æãÂ≠êÊ≤°Êúâ13 14 15,ËÇØÂÆöÊòØÂâç‰∏§ÁªÑÂàÜÊàê 1 6,2 5 3 4 Âêé‰∏§ÁªÑ7 12 8 11 9 10,ËøôÊ†∑‰∏ÄÂÆöÊòØÂπ≥ÂàÜÁöÑ„ÄÇÂ¶ÇÊûúÊòØÂ•áÊï∞Ôºå&gt;3ÁöÑ‰ªΩÊï∞Ôºå‰æùÊóß‰∏ÄÊ†∑ÁöÑÂ§ÑÁêÜÔºå1 2 3Ââç‰∏â‰ªΩÂÜçÂàÜÊàê3Á≠â‰ªΩ„ÄÇËøô‰∏™ÂàÜÊ≥ïÊúâÂæàÂ§öÔºåÊàëÊâæ‰∫Ü‰∏Ä‰∏™ÊØîËæÉËæ£È∏°ÁöÑ„ÄÇ Áîª‰∏™ÂõæÁªô‰Ω†Áúã‰∏ãÂõæÁªô‰Ω†‰∫ÜÔºåÁúã‰∏çÁúãÂæóÊáÇÂ∞±ÊòØ‰Ω†ÁöÑÊÇüÊÄß‰∫ÜÔºåÂëäËæû.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;LL n, k;vector&lt;int&gt; v[maxn];vector&lt;LL&gt; ans[maxn];int main() &#123; int T; f(); scanf("%d", &amp;T); while (T--) &#123; scanf("%lld%lld", &amp;n, &amp;k); LL sum = n * (n + 1) / 2 / k; if (n == 1 &amp;&amp; k == 1) &#123; puts("yes\n1"); continue; &#125; if (n == k || n * (n + 1) / 2 % k != 0) &#123; puts("no"); &#125; else if (k == 1) &#123; puts("yes"); for (int i = 1; i &lt;= n; i++) &#123; printf("%d%c", i, i == n ? '\n' : ' '); &#125; &#125; else &#123; n /= k; int pos = 1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; k; j++) &#123; v[i].push_back(pos++); &#125; &#125; puts("yes"); if (n &amp; 1) &#123; for (int j = 4; j &lt;= n; j += 2) &#123; for (int i = 0; i &lt; k; i++) &#123; ans[i].push_back(v[j][i]); ans[i].push_back(v[j + 1][k - i - 1]); &#125; &#125; int j = k / 2 - 1; for (int i = 0; i &lt; k; i++) &#123; ans[i].push_back(v[3][i]); ans[i].push_back(v[2][(++j) % k]); &#125; for (int i = 0; i &lt; k; i++) &#123; LL temp = 0; for (int j = 0; j &lt; n; j++) &#123; if (j + 1 != n)temp += ans[i][j]; else ans[i].push_back(sum - temp); printf("%lld", ans[i][j]); if (j + 1 == n)printf("\n"); else printf(" "); &#125; ans[i].clear(); &#125; &#125; else &#123; for (int j = 1; j &lt;= n; j += 2) &#123; for (int i = 0; i &lt; k; i++) &#123; ans[i].push_back(v[j][i]); ans[i].push_back(v[j + 1][k - i - 1]); &#125; &#125; for (int i = 0; i &lt; k; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; printf("%lld", ans[i][j]); if (j + 1 == n)printf("\n"); else printf(" "); &#125; ans[i].clear(); &#125; &#125; &#125; for (int i = 0; i &lt;= n; i++) &#123; v[i].clear(); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>ÊûÑÈÄ†</category>
      </categories>
      <tags>
        <tag>Êù≠ÁîµÂ§öÊ†°</tag>
        <tag>ÊûÑÈÄ†</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÂêéÁºÄÊï∞ÁªÑÂíåÈ´òÂ∫¶Êï∞ÁªÑ(LCP)Â≠¶‰π†Á¨îËÆ∞(ÊúâÂùë)]]></title>
    <url>%2F2019%2F07%2F30%2F%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%92%8C%E9%AB%98%E5%BA%A6%E6%95%B0%E7%BB%84(LCP)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ÂêéÁºÄÊï∞ÁªÑÂ≠óÁ¨¶‰∏≤ÂêéÁºÄÔºåÊåá‰ªéÂ≠óÁ¨¶‰∏≤Êüê‰∏™‰ΩçÁΩÆÂºÄÂßãÂà∞Â≠óÁ¨¶‰∏≤Êú´Â∞æÁöÑÂ≠ó‰∏≤ÔºåÂéü‰∏≤ÂíåÁ©∫‰∏≤‰πüÊòØÂêéÁºÄ„ÄÇÂèç‰πãÂâçÁºÄ„ÄÇÁî®sa‰øùÂ≠òÂ≠óÁ¨¶‰∏≤ÂºÄÂßãÁöÑ‰∏ãÊ†á„ÄÇÂ≠óÁ¨¶‰∏≤ÊÄªÂÖ±Êúân+1‰∏™,Â≠óÁ¨¶‰∏≤ÊØîËæÉÂ§ßÂ∞èÊòØ$O(n)$ÁöÑ,ÊâÄ‰ª•Áõ¥Êé•Áî®sortÁõ¥Êé•ÊéíÂ∫èÊòØ$O(n^2log(n))$,ÂæàÊòæÁÑ∂‰∏çÂêàÁêÜ„ÄÇ ‰ºòÂåñ‰∏Ä hash‰ºòÂåñÊääÂ≠óÁ¨¶‰∏≤hashÂ§ÑÁêÜ,‰øÆÊîπsortÊéíÂ∫èÊñπÂºèÔºåÊØîËæÉ‰∏§‰∏™Â≠óÁ¨¶‰∏≤ÔºåÂÖà‰∫åÂàÜÊúÄÈïøÂâçÁºÄÔºåÊØîËæÉ‰∏§‰∏™Â≠óÁ¨¶‰∏≤hashÂ§ÑÁêÜÊòØ$O(1)$ÁöÑÔºåÁÑ∂ÂêéÊØîËæÉÁ¨¨‰∏Ä‰∏™‰ΩçÁΩÆ‰∏çÂêåÁöÑÂú∞ÊñπÂ∞±Ë°å‰∫Ü„ÄÇÂ§çÊùÇÂ∫¶$(O(nlog^2(n)))$,‰ΩÜÊòØhashÂèØËÉΩ‰ºöÊúâÂÜ≤Á™Å. ‰ºòÂåñ‰∫å ÂÄçÂ¢û‰ºòÂåñÂÅáËÆæ‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤abaca12345acaacabacaabaca ÂêéÁºÄÂ¶Ç‰∏ä‰∏ÄÂºÄÂßãÊØîËæÉÂèØ‰ª•ÂæóÂá∫,a&lt;b&lt;cÂæóÂà∞‰∏Ä‰∏™rankÂèØ‰ª•Ë°®Á§∫‰∏∫Â≠óÁ¨¶Â§ßÂ∞è,ÁÑ∂ÂêéÊ†πÊçÆËøô‰∏™ÊéíÂ∫èÂêéÁºÄÊï∞ÁªÑ„ÄÇ123456789a=0b=1c=2//Â≠óÁ¨¶‰∏≤Â∞±ÊòØaaabc ÁÑ∂ÂêéÂºÄÂßãÂÄçÂ¢ûÔºåÊØîËæÉÈïøÂ∫¶2ÔºåÁî±‰∫éÂ∑≤ÁªèÁü•ÈÅì‰∫Üa,b,cÔºåÈïøÂ∫¶‰∏∫1ÁöÑÂ§ßÂ∞èÊâÄ‰ª•ÂèØ‰ª•Áõ¥Êé•ÊØîËæÉÔºåÁ¨¨‰∏Ä‰∏™ÈïøÂ∫¶1ÔºåÁöÑÂ§ßÂ∞èÔºåÂÜçÊØîËæÉÁ¨¨‰∫å‰∏™ÈïøÂ∫¶‰∏∫1ÁöÑÂ§ßÂ∞èÊúÄÁªàÂèØ‰ª•ÂæóÂá∫a&lt;ab&lt;ac&lt;ba&lt;ca1234567891011a=0ab=1ac=2ba=3ca=4//Â≠óÁ¨¶‰∏≤aabacbaca ËØ¶ÁªÜÊé®Êñ≠ËßÅ ÁôΩ‰π¶P378‰æùÊ¨°Á±ªÊé®Â∞±Ë°å‰∫ÜÔºåËØ¶ÊÉÖËßÅ‰ª£Á†ÅËøô‰∏™Âú∞ÊñπÊéíÂ∫èÂèØ‰ª•Áî®Âü∫Êï∞ÊéíÂ∫èÔºåÂ∞ÜÂ§çÊùÇÂ∫¶‰ºòÂåñÂà∞$O(nlog(n))$ ‰ºòÂåñ‰∏â SA-ISÊåñ‰∏ãÂùë‰ª•ÂêéÂ°´ÔºåÂè¶Â§ñËøòÊúâDC3ÁÆóÊ≥ï$O(n)$ÁöÑÂ§çÊùÇÂ∫¶Ôºå‰ΩÜÊòØDC3Â∏∏Êï∞Â§™Â§ß. È´òÂ∫¶Êï∞ÁªÑËøô‰∏™Â§ÑÁêÜ‰πüÈùûÂ∏∏Â∑ßÂ¶ôÔºåÊàëËßâÂæóÂ≠óÁ¨¶‰∏≤Â§ÑÁêÜÈÉΩÂæàÊúâÊÑèÊÄù„ÄÇÂÅáËÆæ‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤abracadabra‰∏ÄÂºÄÂßãÂ§ÑÁêÜÂá∫sa Êï∞ÁªÑ‰Ω†ÂèØ‰ª•ÂèëÁé∞‰∏Ä‰∏™ÂæàÊúâÊÑèÊÄùÁöÑ‰∫ã‰∏ÄÂºÄÂßãÂåπÈÖçÂíåsa[0] ÊúÄÂ§ßÁöÑÈÇ£‰∏Ä‰∏™Ôºå‰πüÂ∞±ÊòØÂéü‰∏≤„ÄÇabracadabra ÂêéÁºÄÊéíÂ∫èÂêéÊØî‰ªñÂ∞èÁöÑÊéíÂ∫èÂêéÊØî‰ªñÂ∞èÁöÑÁ¨¨‰∏Ä‰∏™sa[7]Â∞±ÊòØabra‰∏çÈöæÁúãÂá∫Êù•ÔºåÂâçÁºÄÂ∞±ÊòØ4‰∏™„ÄÇsa[1] bracadabra ÂåπÈÖç sa[8] braÂèëÁé∞‰∫ÜÊ≤°ÊúâÔºåÂàöÂ•ΩÂ∞±ÊòØ ÂâçÈù¢ÁöÑÂáèÂéª‰∏Ä‰∏™ÂàöÂ•Ω3‰∏™„ÄÇÁÑ∂ÂêéÁªßÁª≠ÂåπÈÖçsa[2] racadabra sa[9] raÂàöÂ•Ω2‰∏™,ÁÑ∂ÂêéÁªßÁª≠sa[3] acadabra sa[0] abracadabraÂàöÂ•Ω1‰∏™„ÄÇÊâÄ‰ª•sa[i] ÂåπÈÖçsa[k],ËôΩÁÑ∂‰∏ã‰∏Ä‰∏™sa[i+1] ‰∏ç‰∏ÄÂÆöÂåπÈÖçsa[k+1] ,‰ΩÜÊòØÂåπÈÖç‰∏™Êï∞‰∏ÄÂÆöËá≥Â∞ëÊòØ$h_i-1$‰∏™ÔºåÁÑ∂ÂêéÊàë‰ª¨ÂèØ‰ª•Áõ¥Êé•‰ªé$h_i-1$ÂºÄÂßãÂåπÈÖçÂ∞±Â•Ω‰∫Ü„ÄÇÊúÄÂ§öÂ¢ûÂä†‰∏ç‰ºöË∂ÖËøánÊ¨°ÔºåÊâÄ‰ª•Â§çÊùÇÂ∫¶ÊòØ$O(n)$ÁöÑ„ÄÇËØ¶ÊÉÖËßÅ ÁôΩ‰π¶382 Êé®Ëçê‰π†È¢òPOJ 2217 SecretaryPOJ 3581 Sequencespoj spoj 694 Distinct Substrings Êï¥ÁêÜÊùøÂ≠ê123456789101112131415161718192021222324252627282930313233343536373839404142434445464748namespace My &#123; int Rank[maxn + 1], tmp[maxn + 1]; int k, n; bool compare_sa(const int &amp;i, const int &amp;j) &#123; if (Rank[i] != Rank[j])return Rank[i] &lt; Rank[j]; //Ëøô‰∏™Âú∞ÊñπÂæàÂ∑ßÂ¶ôÔºåÊØîËæÉÂâçk else &#123; int ri = i + k &lt;= n ? Rank[i + k] : -1; //Â¶ÇÊûúÂä†‰∏äÂêéÂçäÈÉ®ÂàÜË∂ÖËøánÔºåÂ∞±Áõ¥Êé•ÁÆóÊúÄÂ∞è„ÄÇ int rj = j + k &lt;= n ? Rank[j + k] : -1; return ri &lt; rj; &#125; &#125; template&lt;class T&gt; void construct_sa(T *S, int _n, int *sa) &#123; n = _n; for (int i = 0; i &lt;= n; i++) &#123; sa[i] = i; Rank[i] = i &lt; n ? S[i] : -1; &#125; for (k = 1; k &lt;= n; k *= 2) &#123; sort(sa, sa + n + 1, compare_sa); tmp[sa[0]] = 0; for (int i = 1; i &lt;= n; i++) &#123; tmp[sa[i]] = tmp[sa[i - 1]] + compare_sa(sa[i - 1], sa[i]); //Â¶ÇÊûú‰∏§‰∏™Áõ∏Á≠âËØ¥ÊòéÂâçkÁõ∏Á≠âÔºåÂ∞±ÂÉèÂú®Âêå‰∏Ä‰∏™Ê°∂Èáå‰∏ÄÊ†∑„ÄÇ &#125; for (int i = 0; i &lt;= n; i++) &#123; Rank[i] = tmp[i]; &#125; &#125; &#125; template&lt;class T&gt; void construct_lcp(T *S, int _n, int *sa, int *lcp) &#123; n = _n; for (int i = 0; i &lt;= n; i++)Rank[sa[i]] = i; int h = 0; lcp[0] = 0; for (int i = 0; i &lt; n; i++) &#123; int j = sa[Rank[i] - 1]; if (h &gt; 0)h--; for (; j + h &lt; n &amp;&amp; i + h &lt; n; h++) &#123; if (S[j + h] != S[i + h])break; &#125; lcp[Rank[i] - 1] = h; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Â≠óÁ¨¶‰∏≤</category>
      </categories>
      <tags>
        <tag>Á¨îËÆ∞</tag>
        <tag>ÂêéÁºÄÊï∞ÁªÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 3 1011 Squrirrel]]></title>
    <url>%2F2019%2F07%2F30%2F2019-Multi-University-Training-Contest-3-1011%2F</url>
    <content type="text"><![CDATA[HDU 6613 SqurirrelÈ¢òÊÑèÔºö ÂèØ‰ª•ÂêàÂπ∂Ê†ë‰∏ä‰∏§‰∏™ÁÇπÔºåÂêàÂπ∂‰∏§‰∏™ÁÇπËÆ©Êüê‰∏Ä‰∏™ÁÇπÂà∞Á¶ª‰ªñÊúÄËøúÁöÑË∑ùÁ¶ªÊúÄÂ∞èÔºåÂ¶ÇÊûúÊúâÂ§ö‰∏™Á≠îÊ°àËæìÂá∫Â≠óÂÖ∏Â∫èÊúÄÂ∞èÁöÑ„ÄÇÈ¢òËß£Ôºö È¶ñÂÖà‰ªéÂè∂Â≠êËäÇÁÇπÂæÄÊ†πËäÇÁÇπË∑ëÔºå‰øùÂ≠òÊØè‰∏™Âà∞Ëøô‰∏™ÁÇπÁöÑÊúÄÂ§ßË∑ùÁ¶ªÔºåÂíåÂÑøÂ≠êËäÇÁÇπÂà†Êéâ‰∏ÄÊù°Ëæπ‰πãÂêéÊúÄÂ§ßË∑ùÁ¶ªÁöÑÊúÄÂ∞èÂÄº„ÄÇÔºàËÇØÂÆöÊòØ‰ªéÊúÄÂ§ßË∑ØÂæÑ‰∏äÂà†‰∏ÄÊù°ËæπÔºâÊàë‰∏∫‰∫Ü‰øùÈô©ÂÖ®Âà§Êñ≠‰∫Ü „ÄÇÁÑ∂ÂêéÂÜç‰ªéÊ†πËäÇÁÇπÂæÄÂÑøÂ≠êËäÇÁÇπË∑ëÔºåÊØèÊ¨°‰øùÂ≠ò‰∏Ä‰∏™ÔºåÊúÄÂ§ßÔºåÊ¨°Â§ßÔºåÁ¨¨‰∏âÂ§ßÔºåÂÖ∑‰Ωì‰∏∫‰ªÄ‰πàÁúã‰ª£Á†ÅÊ≥®Èáä„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 2e5 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;int ans1;vector&lt;int&gt; G[maxn];vector&lt;int&gt; cost[maxn];int dp[maxn];int mi[maxn];int in[maxn];int used[maxn];int ans2 = inf;void dfs(int r, int p, int mx, int cmi, int c) &#123; cmi = min(cmi + c, mx); mx = mx + c; int temp = min(max(mx, mi[r]), max(cmi, dp[r])); if (ans2 &gt; temp) &#123; ans2 = temp; ans1 = r; &#125; if (ans2 == temp) &#123; ans2 = temp; ans1 = min(ans1, r); &#125;// cout &lt;&lt; "r=" &lt;&lt; r &lt;&lt; "mx=" &lt;&lt; mx &lt;&lt; "mi=" &lt;&lt; cmi &lt;&lt; endl;// int temp = min(max(dp[r], cmi), max(mi[r], mx));// if (ans2 &gt; temp) &#123;// ans2 = min(max(dp[r], cmi), max(mi[r], mx));// ans1 = r;// &#125; else if (ans2 == temp)ans1 = min(r, ans1); int mx1 = mx, mx2 = 0, mx3 = 0, mi2 = -1, mi1 = p, mi3 = -1, vmi1 = cmi, vmi2 = 0, vmi3 = 0; //ËÆ∞ÂΩïÊúÄÂ§ßÔºåÊ¨°Â§ßÔºåÁ¨¨‰∏âÂ§ß for (int i = 0; i &lt; G[r].size(); i++) &#123; int au = G[r][i]; int c = dp[au] + cost[r][i]; if (au == p) continue; temp = min(dp[au], mi[au] + cost[r][i]); if (mx1 &lt;= c) &#123; swap(mx1, c); swap(mi1, au); swap(vmi1, temp); &#125; if (mx2 &lt;= c) &#123; swap(mx2, c); swap(mi2, au); swap(vmi2, temp); &#125; if (mx3 &lt;= c) &#123; swap(mx3, c); swap(mi3, au); swap(vmi3, temp); &#125; &#125; for (int i = 0; i &lt; G[r].size(); i++) &#123; int au = G[r][i]; int c = cost[r][i]; if (au == p)continue; if (au == mi1) &#123; if (mi3 == -1)dfs(au, r, mx2, vmi2, c); else dfs(au, r, mx2, max(vmi2, mx3), c); //Â¶ÇÊûúÊòØÂæÄÊúÄÂ§ßÁöÑË∑ØÂæÑËµ∞ÔºåÂ∞±ÊòØÂú®Ê¨°Â§ßÁöÑË∑Ø‰∏äÂà†‰∏ÄÊù°ËæπÂÜçÂíåÁ¨¨‰∏âÂ§ßÊØîËæÉ &#125; else if (au == mi2) &#123; if (mi3 == -1)dfs(au, r, mx1, vmi1, c); else dfs(au, r, mx1, max(vmi1, mx3), c); //Â¶ÇÊûúÊòØÂæÄÁ¨¨‰∫åÂ§ßÁöÑÔºåÂ∞±ÊòØÂú®ÊúÄÂ§ßË∑Ø‰∏äÂà†‰∏ÄÊù°ËæπÂÜçÂíåÁ¨¨‰∏âÂ§ßÊØîËæÉ &#125; else dfs(au, r, mx1, max(vmi1, mx2), c); // ÂÖ∂‰ªñÁöÑËÇØÂÆöÈÉΩÊòØÂà†ÊúÄÂ§ßÁöÑË∑ØÂæÑ‰∏ÄÊù°Ëæπ ÂÜçÂíåÁ¨¨‰∫åÂ§ßÊØîËæÉ &#125;&#125;int main() &#123; f(); int n; int t; scanf("%d", &amp;t); while (t--) &#123; scanf("%d", &amp;n); for (int i = 1; i &lt; n; i++) &#123; int u, v, c; scanf("%d%d%d", &amp;u, &amp;v, &amp;c); G[u].emplace_back(v); cost[u].emplace_back(c); G[v].emplace_back(u); cost[v].emplace_back(c); in[u]++; in[v]++; &#125; queue&lt;int&gt; q; for (int i = 1; i &lt;= n; i++) &#123; dp[i] = 0; if (in[i] == 1) &#123; q.push(i); mi[i] = 0; &#125; else mi[i] = inf; &#125; int r = -1; ans1 = 0; ans2 = inf; while (q.size()) &#123; int v = q.front(); q.pop(); r = v; if (used[v] == 0)used[v] = 1; else continue; int mx1 = 0, mx2 = 0; for (int i = 0; i &lt; G[r].size(); i++) &#123; int au = G[r][i]; int c = dp[au] + cost[r][i]; if (!used[au])continue; if (mx1 &lt; c)swap(mx1, c); if (mx2 &lt; c)swap(mx2, c); &#125; for (int i = 0; i &lt; G[r].size(); i++) &#123; int au = G[r][i]; int c = cost[r][i]; if (!used[au])continue; if (dp[au] + c == mx1) &#123; mi[r] = min(mi[r], max(min(dp[au], mi[au] + c), mx2)); //Ëøô‰∏™ËÇØÂÆöÂ∞±ÊòØÊúÄÂ∞èÁöÑ &#125; else mi[r] = min(mi[r], max(min(dp[au], mi[au] + c), mx1)); //Ëøô‰∏™ÂèØ‰ª•‰∏çË¶Å &#125; for (int i = 0; i &lt; G[v].size(); i++) &#123; int &amp;au = G[v][i], &amp;c = cost[v][i]; in[au]--; if (used[au] == 0) &#123; dp[au] = max(dp[r] + c, dp[au]); if (in[au] == 1)q.push(au); &#125; &#125; &#125;// for (int i = 1; i &lt;= n; i++) &#123;// printf("[%d]= %d %d\n", i, dp[i], mi[i]);// &#125; if (n == 1 || n == 2)printf("%d %d\n", 1, 0); else &#123; dfs(r, -1, 0, 0, 0); printf("%d %d\n", ans1, ans2); for (int i = 1; i &lt;= n; i++) &#123; used[i] = 0; in[i] = 0; G[i].clear(); cost[i].clear(); &#125; &#125; &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "ËøêË°åÊó∂Èó¥:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Âä®ÊÄÅËßÑÂàí</category>
      </categories>
      <tags>
        <tag>Êù≠ÁîµÂ§öÊ†°</tag>
        <tag>Ê†ëÂΩ¢DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 1 1001 Blank]]></title>
    <url>%2F2019%2F07%2F27%2F2019-Multi-University-Training-Contest-1-1001%2F</url>
    <content type="text"><![CDATA[HDU 6578 BlankÈ¢òÊÑèÔºö ÁªôÂÆö1,N ÁöÑ‰ΩçÁΩÆÔºåÊØè‰∏™‰ΩçÁΩÆÂèØ‰ª•Â°´1,2,3,4ÂÖ∂‰∏≠‰∏Ä‰∏™ÔºåÁªôm‰∏™Âå∫Èó¥[l,r] x ÔºåÈôêÂà∂[l,r]Âå∫Èó¥ÂÜÖÂè™ÊúâxÁßç‰∏çÂêåÁöÑÊï∞„ÄÇÈ¢òËß£Ôºö nÈùûÂ∏∏Â∞èÔºåÂè™Êúâ100ÔºåÂèØ‰ª•Áõ¥Êé•Áî®Êï∞ÁªÑÊûö‰∏æ‰∏ä‰∏Ä‰∏™Êï∞Âá∫Áé∞ÁöÑ‰ΩçÁΩÆÔºåÊØè‰∏™‰ΩçÁΩÆÊö¥ÂäõÂ°´Â∞±Ë°å‰∫Ü„ÄÇÁõ¥Êé•$O(n^4)$‰ºöTÔºå„ÄÇÔºåÂøÖÈ°ªË¶ÅÂâäÂ∏∏Êï∞„ÄÇÂèØ‰ª•ÂèëÁé∞Âá∫Áé∞ÊòØ‰ªÄ‰πàÊï∞Êú¨Ë∫´‰∏çÈáçË¶ÅÔºåÂè™Âíå‰ΩçÁΩÆÊúâÂÖ≥„ÄÇÁÑ∂ÂêéÊúÄÂ§ßÁöÑÈÇ£‰∏™‰ΩçÁΩÆÔºå‰∏ÄÂÆöÊòØ‰Ω†Ë¶ÅÂ°´ÁöÑËøô‰∏™pos-1,ÊâÄ‰ª•dpÁ©∫Èó¥ÂèØ‰ª•‰ºòÂåñ‰∏ÄÁª¥Ôºådp[i][j][k],‰ª£Ë°®ÊéíÂ∫èÂêé‰ΩçÁΩÆÂàÜÂà´ÊòØi&lt;j&lt;k&lt;pos-1ÔºåÁÑ∂ÂêéÊûö‰∏æÁöÑÁä∂ÊÄÅ‰πüÊòØi&lt;j&lt;k&lt;pos-1 ÔºåÂØπ‰∫éÈôêÂà∂Êù°‰ª∂ÔºåÂà§Êñ≠‰∏Ä‰∏ãÁä∂ÊÄÅÂêà‰∏çÂêàÊ≥ïÂ∞±Ë°å‰∫Ü„ÄÇÂØπ‰∫éÊüê‰∏™posÂà∞‰∫Ü[l,r] x,rÁöÑ‰ΩçÁΩÆ,Âà§Êñ≠‰∏Ä‰∏ãÂ∞±Ë°å‰∫ÜÔºåËøô‰∏™‰∏çÂΩ±ÂìçÂ§çÊùÇÂ∫¶„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;unordered_map&gt;#include&lt;unordered_set&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;(x)&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a, b) memset(a,b,sizeof(a));const long long mod = 998244353;const int maxn = 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif // ONLIN_JUDGE&#125;LL dp[105][105][105][2];struct node &#123; int l, r, x; bool operator&lt;(node &amp;t) const &#123; if (r == t.r)return l &lt; t.l; return r &lt; t.r; &#125;&#125; dat[maxn];int n, m;void check(LL &amp;x) &#123; x %= mod;&#125;int main() &#123; f(); int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d", &amp;dat[i].l, &amp;dat[i].r, &amp;dat[i].x); dat[i].l += 3; dat[i].r += 3; &#125; dp[0][1][2][1] = 1; sort(dat + 1, dat + m + 1); int l = 1, p = 0; for (int pos = 4; pos &lt;= n + 3; pos++, p = !p) &#123; for (int i = 0; i &lt;= pos - 4; i++) &#123; for (int j = i + 1; j &lt;= pos - 3; j++) &#123; for (int k = j + 1; k &lt;= pos - 2; ++k) &#123; int flag = 0, temp = l; while (temp &lt;= m &amp;&amp; pos - 1 == dat[temp].r) &#123; if (dat[temp].x == 1 &amp;&amp; dat[temp].l &lt;= k) &#123; flag = 1; &#125; if (dat[temp].x == 2 &amp;&amp; (dat[temp].l &lt;= j || dat[temp].l &gt; k)) &#123; flag = 1; &#125; if (dat[temp].x == 3 &amp;&amp; (dat[temp].l &lt;= i || dat[temp].l &gt; j))flag = 1; if (dat[temp].x == 4 &amp;&amp; dat[temp].l &gt; i)flag = 1; temp++; &#125; if (flag) &#123; dp[i][j][k][!p] = 0; continue; &#125; dp[j][k][pos - 1][p] += dp[i][j][k][!p]; check(dp[j][k][pos - 1][p]); dp[i][k][pos - 1][p] += dp[i][j][k][!p]; check(dp[i][j][pos - 1][p]); dp[i][j][pos - 1][p] += dp[i][j][k][!p]; check(dp[i][j][pos - 1][p]); dp[i][j][k][p] += dp[i][j][k][!p]; check(dp[i][j][k][p]); dp[i][j][k][!p] = 0; &#125; &#125; &#125; while (l &lt;= m &amp;&amp; dat[l].r == pos - 1)l++; &#125; LL ans = 0; for (int i = 0; i &lt;= n + 3; i++) &#123; for (int j = i + 1; j &lt;= n + 3; j++) &#123; for (int k = j + 1; k &lt;= n + 3; ++k) &#123; int flag = 0, temp = l; while (temp &lt;= m) &#123; if (dat[temp].x == 1 &amp;&amp; dat[temp].l &lt;= k) &#123; flag = 1; &#125; if (dat[temp].x == 2 &amp;&amp; (dat[temp].l &lt;= j || dat[temp].l &gt; k)) &#123; flag = 1; &#125; if (dat[temp].x == 3 &amp;&amp; (dat[temp].l &lt;= i || dat[temp].l &gt; j))flag = 1; if (dat[temp].x == 4 &amp;&amp; dat[temp].l &gt; i)flag = 1; temp++; &#125; if (flag) &#123; dp[i][j][k][!p] = 0; continue; &#125; ans = (ans + dp[i][j][k][!p] % mod) % mod; dp[i][j][k][!p] = 0; &#125; &#125; &#125; printf("%lld\n", ans); &#125; return 0;&#125;/*61 0410 0104857611 0419430420 044459512330 068215596540 0382013690 */]]></content>
      <categories>
        <category>ACM</category>
        <category>Âä®ÊÄÅËßÑÂàí</category>
      </categories>
      <tags>
        <tag>Êù≠ÁîµÂ§öÊ†°</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÂçïË∞ÉÊ†àÂíåÂçïË∞ÉÈòüÂàó]]></title>
    <url>%2F2019%2F07%2F26%2F%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[ÁêÜËß£ÂçïË∞ÉÊ†àÂíåÂçïÂçïË∞ÉÈòüÂàó‰πãÂâçÔºåË¶ÅÊòéÁôΩ‰∏ÄÁßçÊäÄÂ∑ßÔºåÂè´ÂÅöÂ∞∫ÂèñÊ≥ï„ÄÇ Â∞∫ÂèñÊ≥ïÂ∞∫ÂèñÊ≥ïÔºå‰∏§‰∏™‰ΩçÁΩÆÔºå‰∏Ä‰∏™ÊòØlÔºå‰∏Ä‰∏™r,r‰∏Ä‰Ωç‰ΩçÁöÑÂ∑¶ÁßªÔºålÊ†πÊçÆÊù°‰ª∂Â∑¶Áßª„ÄÇÊØîÂ¶ÇPOJ 3061Ê±ÇÊúÄÂ§ßËøûÁª≠Â≠ó‰∏≤Âíå‰∏çË∂ÖËøásl rÂàùÂßãÂåñ‰∏∫0,rÂ∑¶ÁßªÔºåÊÄªÂíåÂä†‰∏är‰ΩçÁΩÆÁöÑÂÄºÔºåÂ¶ÇÊûúÊÄªÂíå‰∏ÄÊó¶Â§ß‰∫és,lÂºÄÂßãÂ∑¶ÁßªÔºåÁõ¥Âà∞Êª°Ë∂≥[l,r]Âå∫Èó¥ÁöÑÊÄªÂíåÂ∞è‰∫ésÔºåËøôÁßçÈÄöËøál,rÂèçÂ§çÊé®ËøõÁöÑÊñπÊ≥ïÔºåÂ∞±Âè´Â∞∫ÂèñÊ≥ï„ÄÇ ÁªÜÂøÉÁöÑ‰∫∫ÂèØ‰ª•ÂèëÁé∞ÔºåËøôÁßçÊñπÊ≥ïÔºåÊ±ÇÁªìÊûú‰∏ÄÂÆöË¶ÅÊª°Ë∂≥ÔºåÂè≥Ëæπ‰∏Ä‰∏™‰ΩçÁΩÆË∑®ËøárÂà∞l‰∏ÄÂÆöÊòØ‰∏çÂêàÊ≥ïÁöÑÁöÑÊÉÖÂÜµ„ÄÇ ÂçïË∞ÉÊ†àÂÖ∂ÂÆûËøô‰∏™ÂíåÂ∞∫ÂèñÊ≥ïÂÖ≥Á≥ª‰∏çÂ§ß„ÄÇ„ÄÇ„ÄÇ„ÄÇÂçïË∞ÉÊ†à,Áî®‰∫éÊ±ÇÊúÄÂ∑¶ËæπÔºàÂè≥ËæπÔºâÁöÑÁ¨¨‰∏Ä‰∏™Êª°Ë∂≥ÊüêÁßçÂÖ∑ÊúâÂçïË∞ÉÊÄßË¥®Êù°‰ª∂ÔºàÊØîÂ¶ÇÂ§ß‰∫éÔºåÂ∞è‰∫éÔºâÁöÑ‰ΩçÁΩÆ„ÄÇË∑ùÁ¶ªÔºåÊ±ÇÁ¨¨‰∏Ä‰∏™Â§ß‰∫éÁöÑ‰ΩçÁΩÆ„ÄÇÊ±ÇÂ§ß‰∫éÔºåÂ∞Ü‰∏çÂ§ß‰∫éÁöÑÊï∞ÂÖ®ÈÉ®Âä†ÂÖ•ÂçïË∞ÉÊ†àÈáåÈù¢Ôºå‰øùËØÅÊ†àÂçïË∞ÉÈÄíÂáèÔºåÔºà‰∏ãÈù¢Ë∑ùÁ¶ªÊ†à‰∏≠Â≠òÁöÑÊòØÂ∞èÊ†á,Ê≥®ÊÑèÂå∫ÂàÜÂÄºÂíå‰∏ãÊ†áÔºâÂÅáËÆæÊúâ1 3 5 2 1 4 7 6‰∏ÄÂºÄÂßãÊ†à‰∏∫Á©∫ÔºåÂ∞ÜÁ¨¨‰∏Ä‰∏™Êï∞‰ΩçÁΩÆÂä†ËøõÂéªÔºåÊ≠§Êó∂Ê†à‰∏≠Êúâ‰∏ãÊ†á1Âà∞Á¨¨‰∫å‰∏™Êï∞ 3 ÔºåÊ†àÈ°∂ ‰ΩçÁΩÆÁöÑÂÄº Â∞è‰∫é3ÂºπÂá∫ÔºåËµãÂÄº‰ΩçÁΩÆÂè≥ËæπÁ¨¨‰∏Ä‰∏™Â§ß‰∫é‰ªñÁöÑÊï∞‰∏ãÊ†áÊòØ2ÔºåÁÑ∂ÂêéÊ†à‰∏∫Á©∫ÔºåÂ∞Ü2Âè∑‰ΩçÁΩÆÂä†ÂÖ•Ê†àÔºå‰æùÊ¨°Á±ªÊé®.Âà∞5 ÂºπÂá∫‰∏ãÊ†á2 Âä†ÂÖ•‰∏ãÊ†á3,Âà∞ 2 Âõ†‰∏∫Ê†àÈ°∂‰ΩçÁΩÆÁöÑÂÄºÂ§ß‰∫é2‰∏çÂºπÂá∫ÔºåÁõ¥Âà∞4 ÂºπÂá∫ÂÄº2,1Ôºå‰∏çÂºπÂá∫5„ÄÇÂΩìÂâçÂÄºÊØîÊ†àÈ°∂ÁöÑÊï∞Â§ßÔºåÂºπÂá∫Ê†àÈ°∂ÁöÑÂÄºÔºåÂπ∂ËµãÂÄºÔºåÂê¶ÂàôÂä†ÂÖ•Ê†à„ÄÇ ÂçïË∞ÉÈòüÂàóÂçïË∞ÉÈòüÂàóÂíåÂ∞∫ÂèñÊ≥ïÁî®ÁÇπÂÉèÔºåÂíåÂçïË∞ÉÊ†à‰πüÂ∑ÆË∑ù‰∏çÂ§ß„ÄÇÊÄªÁªìÊù•ËØ¥Ôºå‰ΩçÁΩÆÂ∞∫ÂèñÔºåÈòüÂàóÂçïË∞ÉÔºåÂ∞±ÊÉ≥Â∞∫ÂèñÊ≥ïÂíåÂçïË∞ÉÊ†àÁöÑÁªìÂêà‰Ωì„ÄÇ‰æãÂ≠ê HDU 3530ÊåâÈ¢òÁõÆÊù•ËÆ≤Ôºö Êü•ÂØªÂå∫Èó¥ÊúÄÂ§ßÊúÄÂ∞èÂÄº‰πãÂ∑ÆÂú®[m,k]‰πãÈó¥ÁöÑÊúÄÂ§ßÈïøÂ∫¶„ÄÇÁé∞ÊåâÁÖßÂ∞∫ÂèñÁöÑÊñπÊ≥ïÊù•Ôºö‰∏çÊñ≠ÁßªÂä®ÔºålÔºår,ËôΩÁÑ∂‰ªéÂú®rÂè≥ËæπË∑®Ëøár Âà∞l ÊúÄÂ§ßÊúÄÂ∞èÂÄº‰πãÂ∑ÆÁªùÂØπÊòØÂ§ß‰∫éÁ≠â‰∫é[r,l]‰πãÈó¥ÁöÑ,‰ΩÜÊòØÊúÄÂ§ßÊúÄÂ∞è‰∏çÂèØËÉΩ‰∏ÄÁõ¥ÊòØÁ´ØÁÇπÔºåÂèØËÉΩ[r,l]‰πãÈó¥Â≠òÂú®ÊØîr,lÂ§ßÊàñËÄÖÂ∞èÁöÑÂÄº„ÄÇÈÇ£‰πàËØ•Â¶Ç‰ΩïÂ§ÑÁêÜÂë¢ÔºåÂçïË∞ÉÊ†àÂèØ‰ª•‰øùÂ≠ò‰∏Ä‰∏™ÂçïË∞ÉÁöÑÂ≠êÂ∫èÂàóÔºåÊàë‰ª¨ÊòØÂê¶ËÉΩÂíå‰ªñ‰∏ÄÊ†∑‰øùÂ≠ò[l,r],ÁöÑÂçïÂ¢ûÂ≠êÂ∫èÂàóÂë¢ÔºüÂæàÊòæÁÑ∂ÊòØÂèØ‰ª•ÁöÑ„ÄÇÂõ†‰∏∫Êàë‰ª¨ÁöÑ[l,r]Êúâ‰∏§Á´ØÔºåÊâÄ‰ª•Áî®Ê†àÊòØËÇØÂÆö‰∏çË°åÁöÑÔºåÈÇ£‰πàÂ∞±Âè™ËÉΩÁî®ÂèåÁ´ØÈòüÂàó„ÄÇÊàë‰ª¨Âª∫Á´ã‰∏§‰∏™ÂèåÁ´ØÈòüÂàóÔºå‰∏Ä‰∏™‰øùÂ≠ò[l,r]ÈÄíÂ¢ûÁöÑÂ≠êÂ∫èÂàóÔºå‰∏Ä‰∏™‰øùÂ≠ò[l,r]ÈÄíÂáèÁöÑÂ≠êÂ∫èÂàóÔºåÈÇ£‰πàÈÄíÂáèÈòüÂàó‰∏≠Á¨¨‰∏Ä‰∏™ÂÄº‰øùÂ≠òÁöÑÂ∞±ÊòØ[l,r]Âå∫Èó¥ÁöÑÊúÄÂ§ßÂÄºÔºåÈÄíÂ¢ûÁöÑÂ∞±ÊòØÊúÄÂ∞èÂÄº„ÄÇÈÇ£‰πàÂÅáËÆæ[l,r] Âå∫Èó¥ÁöÑÊúÄÂ§ßÂÄºÂíåÊúÄÂ∞èÂÄº‰∏çÊª°Ë∂≥Êù°‰ª∂‰∫ÜÔºåË¶ÅÂ∞∫ÂèñÂ∞±Ë¶ÅÁßªÂä®l,ÊÄé‰πàÁßªÂä®ÔºüÊàë‰ª¨Ë¶ÅÊîπÂèòÊúÄÂ§ßÊúÄÂ∞èÂÄº„ÄÇÊîπÂèòÂì™Èáå‰∏Ä‰∏™ÔºüËÇØÂÆöÊòØÁ¶ªrÊúÄËøúÁöÑÈÇ£‰∏Ä‰∏™ÔºåÊàë‰ª¨ÂçïË∞ÉÈòüÂàó‰øùÂ≠òÁöÑ‰∏ãÊ†áÔºåÁõ¥Êé•ÊäälÁßªÂä®Âà∞‰∏§‰∏™ÈòüÂàóÈòüÈ¶ñÔºåÊúÄÂ∞èÁöÑ‰∏ãÊ†á+1,ÁÑ∂ÂêéÂºπÂá∫ÈòüÈ¶ñÔºåÂ∞±Áõ∏ÂΩì‰∫éÊâæÂà∞‰∫ÜÊñ∞[l,r]ÊúÄÂ§ßÔºàÊúÄÂ∞èÔºâÂÄº (Âõ†‰∏∫Êàë‰ª¨ÈòüÂàóÊòØÂçïË∞ÉÁöÑÔºåÂºπÂá∫‰∫ÜÊúÄÂ§ßÔºàÊúÄÂ∞èÔºâÂÄºÂ∞±Áõ∏ÂΩì‰∫éÊâæÂà∞‰∫ÜÊ¨°Â§ßÔºàÊ¨°Â∞èÔºâÂÄºÔºåÂú®Êñ∞Âå∫Èó¥Â∞±Ê≤°ÊúâÊØî‰ªñÂ∞èÁöÑ‰∫Ü ) ÁÑ∂ÂêéÔºå‰∏ÄÁõ¥Âæ™ÁéØÁõ¥Âà∞Êª°Ë∂≥Êù°‰ª∂‰∏∫Ê≠¢„ÄÇÂçïÂ¢ûÈòüÂàóÂ∞±ÊòØÈòüÂ∞æËøõÔºåÊØèÊ¨°ÂíåÂçïË∞ÉÊ†à‰∏ÄÊ†∑‰øùËØÅÈòüÂàó‰∏≠ÊòØÂçïË∞ÉÁöÑÔºåÈòüÈ¶ñÊ∞∏ËøúÈÉΩÊòØÊúÄÂ∞èÁöÑÊàñËÄÖÊúÄÂ§ßÁöÑ HDU 3530 AC‰ª£Á†Å123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;struct deq &#123; static const int start = maxn * 2; int dat[start * 2]; int l = start; int r = start; void push_front(int x) &#123; dat[l--] = x; &#125; void pop_front() &#123; l++; &#125; int front() &#123; return dat[l + 1]; &#125; void push_back(int x) &#123; dat[++r] = x; &#125; void pop_back() &#123; r--; &#125; int back() &#123; return dat[r]; &#125; int size() &#123; return r - l; &#125; void clear() &#123; r = l = start; &#125; bool empty() &#123; return r == l; &#125;&#125;;deque&lt;int&gt; dq, dq2;int n, m, k;int a[maxn];int main() &#123; f(); while (~scanf("%d%d%d", &amp;n, &amp;m, &amp;k)) &#123; int ans = 0; dq.clear(); dq2.clear(); int pos = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); // Â§ßÁöÑÂºπÂá∫ÊâÄ‰ª•ÊúÄÂâçÈù¢ÊòØÊúÄÂ∞èÁöÑ while (dq.size() &gt; 0 &amp;&amp; a[dq.back()] &gt; a[i]) &#123; dq.pop_back(); &#125; dq.push_back(i); while (dq2.size() &gt; 0 &amp;&amp; a[dq2.back()] &lt; a[i]) &#123; dq2.pop_back(); &#125; dq2.push_back(i); while (a[dq2.front()] - a[dq.front()] &gt; k) &#123; if (dq2.front() &lt; dq.front()) &#123; pos = dq2.front(); dq2.pop_front(); &#125; else &#123; pos = dq.front(); dq.pop_front(); &#125; &#125; if (dq2.size() &amp;&amp; dq.size() &amp;&amp; a[dq2.front()] - a[dq.front()] &gt;= m) &#123; ans = max(ans, i - pos); &#125; &#125; printf("%d\n", ans); &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "ËøêË°åÊó∂Èó¥:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125;/*54 */ ÂèãÊÉÖÊèêÁ§∫ÔºöÊúÄÂ•ΩÂà´Áî® std ÈáåÈù¢ÁöÑÊ†àÂíåÈòüÂàóÔºåÂ§™ÊÖ¢‰∫ÜËøõÈò∂È¢òÔºö2019ÁâõÂÆ¢ÊöëÊúüÂ§öÊ†°ËÆ≠ÁªÉËê•ÔºàÁ¨¨‰∏âÂú∫ÔºâF Planting TreesÈ¢òËß£ Ôºö 2019ÁâõÂÆ¢ÊöëÊúüÂ§öÊ†°ËÆ≠ÁªÉËê•ÔºàÁ¨¨‰∏âÂú∫ÔºâF Planting TreesF/)]]></content>
      <categories>
        <category>ACM</category>
        <category>Êï∞ÊçÆÁªìÊûÑ</category>
      </categories>
      <tags>
        <tag>ÂçïË∞ÉÈòüÂàó</tag>
        <tag>Â∑ßËß£</tag>
        <tag>Á¨îËÆ∞</tag>
        <tag>ÂçïË∞ÉÊ†à</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019ÁâõÂÆ¢ÊöëÊúüÂ§öÊ†°ËÆ≠ÁªÉËê•ÔºàÁ¨¨‰∏âÂú∫ÔºâF Planting Trees]]></title>
    <url>%2F2019%2F07%2F26%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5(%E7%AC%AC%E4%B8%89%E5%9C%BA)F%2F</url>
    <content type="text"><![CDATA[2019ÁâõÂÆ¢ÊöëÊúüÂ§öÊ†°ËÆ≠ÁªÉËê•ÔºàÁ¨¨‰∏âÂú∫ÔºâF Planting TreesÈ¢òÊÑè: ‰∏Ä‰∏™$N \ast N$ ÁöÑÁü©ÈòµÔºåÈóÆÊúÄÂ§ßÂÄºÂíåÊúÄÂ∞èÂÄºÂ§ßÂ∞èÂ∑ÆË∑ù‰∏çË∂ÖËøá$M$ÁöÑÊúÄÂ§ßÂ≠êÁü©ÈòµÂ§öÂ§ß„ÄÇÈ¢òËß£: È¢òÁõÆÊòéÁ§∫‰Ω†Ë¶Å‰ΩøÁî®$O(N^3)$ÁöÑÊùÇÂ∫¶,Êö¥ÂäõÊûö‰∏æÂ≠êÁü©ÈòµÈ´òÂ∫¶$x$ÔºåÂÅö‰∏Ä‰∏™È¢ÑÂ§ÑÁêÜÔºåÊää$a[i][j]$Âà∞$a[i+x][j]$ÁöÑÊúÄÂ§ßÊúÄÂ∞èÂÄºÂ§ÑÁêÜÂá∫Êù•ÔºåÂéãÁº©Êàê‰∏ÄË°åÔºåÁÑ∂ÂêéÂÅö‰∏ÄÊ¨°Ê±ÇÂå∫Èó¥ÊúÄÂ§ßÂÄºÂíåÊúÄÂ∞èÂÄºÂ∑ÆÂÄº‰∏çË∂ÖËøá$M$ÁöÑÂå∫Èó¥ÊúÄÂ§ßÈïøÂ∫¶„ÄÇ‰∏çÊáÇÂçïË∞ÉÈòüÂàóÁöÑÂèØ‰ª•ÁúãÁúã ÂçïË∞ÉÊ†àÂíåÂçïË∞ÉÈòüÂàó123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include "stdio.h"#include "ctype.h" #define max(a, b) a&gt;b?a:b#define min(a, b) a&lt;b?a:bconst int maxn = 5e2 + 5; struct deq &#123; static const int start = maxn * 2; int dat[start * 2]; int l = start; int r = start; void push_front(int x) &#123; dat[l--] = x; &#125; void pop_front() &#123; l++; &#125; int front() &#123; return dat[l + 1]; &#125; void push_back(int x) &#123; dat[++r] = x; &#125; void pop_back() &#123; r--; &#125; int back() &#123; return dat[r]; &#125; int size() &#123; return r - l; &#125; void clear() &#123; r = l = start; &#125; bool empty() &#123; return r == l; &#125;&#125;; deq dqmx, dqmi; template&lt;typename T&gt;void read(T &amp;w) &#123; //ËØªÂÖ• char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar()))w = w * 10 + (c &amp; 15);&#125; int n, k;int a[maxn][maxn];int ans = 0;int mi[maxn][maxn];int mx[maxn][maxn]; int main() &#123; int T; read(T); while (T--) &#123; read(n); read(k); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; read(a[i][j]); &#125; &#125; ans = 0; for (int x = 1; x &lt;= n; x++) &#123; for (int i = n; i &gt;= x; i--) &#123; int pos = 0; dqmx.clear(); dqmi.clear(); for (int j = 1; j &lt;= n; j++) &#123; if (x == 1) &#123; mx[i][j] = a[i][j]; mi[i][j] = a[i][j]; &#125; else &#123; mx[i][j] = max(mx[i - 1][j], a[i][j]); mi[i][j] = min(mi[i - 1][j], a[i][j]); &#125; int tmi = mi[i][j], tmx = mx[i][j]; if (tmx - tmi &gt; k) &#123; dqmi.clear(); dqmx.clear(); pos = j; &#125; else &#123; while (dqmi.size() &amp;&amp; mi[i][dqmi.back()] &gt; tmi) &#123; dqmi.pop_back(); &#125; dqmi.push_back(j); while (dqmx.size() &amp;&amp; mx[i][dqmx.back()] &lt; tmx) &#123; dqmx.pop_back(); &#125; dqmx.push_back(j); while (mx[i][dqmx.front()] - mi[i][dqmi.front()] &gt; k) &#123; if (dqmx.front() &lt; dqmi.front()) &#123; pos = dqmx.front(); dqmx.pop_front(); &#125; else &#123; pos = dqmi.front(); dqmi.pop_front(); &#125; &#125; ans = max(ans, x * (j - pos)); &#125; &#125; &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Êï∞ÊçÆÁªìÊûÑ</category>
      </categories>
      <tags>
        <tag>ÂçïË∞ÉÈòüÂàó</tag>
        <tag>ÁâõÂÆ¢ÊöëÊúüÂ§öÊ†°ËÆ≠ÁªÉËê•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 1 1012 Sequence]]></title>
    <url>%2F2019%2F07%2F25%2F2019-Multi-University-Training-Contest-1-1012%2F</url>
    <content type="text"><![CDATA[2019 Multi-University Training Contest 1HDU 6589 SequenceÊûúÁÑ∂‰∏çÁúãÂ§ß‰Ω¨ÂçöÂÆ¢‰∏ç‰ºöÂÜôÈ¢ò„ÄÇÈ°∫ÊâãÊääÊùøÂ≠ê‰πüÊâí‰∫Ü„ÄÇÈ¢òËß£: x Âè™Êúâ 1 2 3‰∏âÁßçÊÉÖÂÜµ„ÄÇÁõ¥Êé•ËßÇÂØüÂâçÁºÄ.ÂèØ‰ª•ÂèëÁé∞ÂΩì x=1 ÁöÑÊó∂ÂÄô $c_1$Ë°®Á§∫ 1Âá∫Áé∞ÁöÑ‰∏™Êï∞ a[i]=\sum_{j=0}^{i}C_{c_1-1+j}^{j} * a[i-j]È¢ÑÁêÜÂá∫ $C[j]=C_{c_1-1+j}^{j}$‰∏äÂºèÂ∞±ÂèòÊàê‰∫Ü a[i]=\sum_{j=0}^{i}C[j] * a[i-j]ÊòØ‰∏çÊòØÁªùÂØπ‰∏äËø∞Ëøô‰∏™ÂºèÂ≠êÈùûÂ∏∏ÁúºÁÜüÔºåÂ∞±ÊòØÂç∑ÁßØ‰∏≠ÁöÑ‰∏ÄÈ°π„ÄÇ„ÄÇ„ÄÇÂèëÁé∞‰∫ÜËøô‰∏™ÔºåÂ∞±ÊòØ‰∏Ä‰∏™ÁªÑÂêàÊï∞Âä†‰∏™NTTÂΩìx=2ÁöÑÊó∂ÂÄôÂ∞±ÊääÊï∞ÁªÑÂàÜÂ•áÊï∞È°πÂíåÂÅ∂Êï∞È°πÊ±Ç‰∏Ä‰∏™‰∏äÂºèÂΩìx=3ÁöÑÊó∂ÂÄôÂ∞±Ê±Ç3‰∏™ÂÆûÈôÖ‰∏äÔºåÂè™Ë¶ÅÊîπ‰∏Ä‰∏ã$c[j]$ÊääÊåâÁÖßx=1ÁöÑÊ±Ç‰∏Ä‰∏ãx=2c[j]=j%2==0&gt;c[j/2]:0x=3``c[j]=j%3==0?c[j/3]:0123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 998244353;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;const double PI = acos(-1);#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;int t;int n, m;LL a[maxn];int c[maxn];LL b[maxn];const int Comb_Maxn = 1e6 + 10;LL Fac_inv[Comb_Maxn];LL Fac[Comb_Maxn];inline void Comb_init() &#123; Fac_inv[0] = Fac[0] = 1; Fac_inv[1] = 1; for (int i = 1; i &lt; Comb_Maxn; i++) Fac[i] = Fac[i - 1] * (LL) i % mod; for (int i = 2; i &lt; Comb_Maxn; i++) Fac_inv[i] = (LL) (mod - mod / i) * Fac_inv[mod % i] % mod; for (int i = 1; i &lt; Comb_Maxn; i++) Fac_inv[i] = Fac_inv[i - 1] * Fac_inv[i] % mod;&#125;LL Comb(int n, int m) &#123; if (m &gt; n || m &lt; 0 || n &lt; 0)return 0; return Fac[n] * Fac_inv[m] % mod * Fac_inv[n - m] % mod;&#125;typedef LL ll;const int N = maxn;struct NumberTheoreticTransform &#123; int pow2(int x) &#123; int res = 1; while (res &lt; x) res &lt;&lt;= 1; return res; &#125; inline LL pow_mod(ll x, int n) &#123; ll res; for (res = 1; n; n &gt;&gt;= 1, x = x * x % mod) if (n &amp; 1) res = res * x % mod; return res; &#125; inline int add_mod(int x, int y) &#123; x += y; return x &gt;= mod ? x - mod : x; &#125; inline int sub_mod(int x, int y) &#123; x -= y; return x &lt; 0 ? x + mod : x; &#125; void NTT(LL a[], int n, int op) &#123; for (int i = 1, j = n &gt;&gt; 1; i &lt; n - 1; ++i) &#123; if (i &lt; j) swap(a[i], a[j]); int k = n &gt;&gt; 1; while (k &lt;= j) &#123; j -= k; k &gt;&gt;= 1; &#125; j += k; &#125; for (int len = 2; len &lt;= n; len &lt;&lt;= 1) &#123; LL g = pow_mod(3, (mod - 1) / len); for (int i = 0; i &lt; n; i += len) &#123; LL w = 1; for (int j = i; j &lt; i + (len &gt;&gt; 1); ++j) &#123; LL u = a[j], t = 1ll * a[j + (len &gt;&gt; 1)] * w % mod; a[j] = (u + t) % mod, a[j + (len &gt;&gt; 1)] = (u - t + mod) % mod; w = 1ll * w * g % mod; &#125; &#125; &#125; if (op == -1) &#123; reverse(a + 1, a + n); LL inv = pow_mod(n, mod - 2); for (int i = 0; i &lt; n; ++i) a[i] = 1ll * a[i] * inv % mod; &#125; &#125; void mul(LL A[], LL B[], int Asize, int Bsize) &#123; int n = pow2(Asize + Bsize - 1); for (int i = Asize; i &lt; n; ++i) A[i] = 0; for (int i = Bsize; i &lt; n; ++i) B[i] = 0; NTT(A, n, 1); NTT(B, n, 1); for (int i = 0; i &lt; n; ++i) &#123; A[i] = 1ll * A[i] * B[i] % mod; B[i] = 0; &#125; NTT(A, n, -1); return; &#125;&#125; ntt;template&lt;typename T&gt;void read(T &amp;w) &#123; //ËØªÂÖ• char c; while (!isdigit(c = getchar())); w = c &amp; 15; while (isdigit(c = getchar()))w = w * 10 + (c &amp; 15);&#125;int main() &#123; f(); read(t); Comb_init(); while (t--) &#123; read(n); read(m); for (int i = 0; i &lt; n; i++) &#123; read(a[i]); &#125; c[0] = c[1] = c[2] = c[3] = 0; while (m--) &#123; int x; scanf("%d", &amp;x); c[x]++; &#125; if (c[1] &gt; 0) &#123; for (int i = 0; i &lt; n; i++) &#123; b[i] = Comb(c[1] + i - 1, i); &#125; ntt.mul(a, b, n, n); &#125; if (c[2] &gt; 0) &#123; for (int i = 0; i &lt; n; i += 2) &#123; b[i] += Comb(c[2] + i / 2 - 1, i / 2); b[i + 1] = 0; &#125; ntt.mul(a, b, n, n); &#125; if (c[3] &gt; 0) &#123; for (int i = 0; i &lt; n; i += 3) &#123; b[i] = Comb(c[3] + i / 3 - 1, i / 3); &#125; ntt.mul(a, b, n, n); &#125; LL ans = 0; for (int i = 0; i &lt; n; i++) &#123; ans ^= (i + 1LL) * a[i]; &#125; printf("%lld\n", ans); &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "ËøêË°åÊó∂Èó¥:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Êï∞ËÆ∫</category>
      </categories>
      <tags>
        <tag>FFT/NTT/FWT</tag>
        <tag>Êù≠ÁîµÂ§öÊ†°</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 2 1012 Longest Subarray]]></title>
    <url>%2F2019%2F07%2F24%2F2019-Multi-University-Training-Contest-2-1012%2F</url>
    <content type="text"><![CDATA[Longest Subarray HDU 6602È¢òÊÑè: n‰∏™Êï∞ÔºåÊ±ÇÂå∫Èó¥ÂÜÖ Êï∞ÁöÑ‰∏™Êï∞Ë¶Å‰πà‰∏∫0‰∏™Ë¶Å‰πàÂ§ß‰∫éÁ≠â‰∫ék‰∏™ÁöÑÈïøÂ∫¶ÊúÄÈïøÊòØÂ§öÂ∞ë„ÄÇÈ¢òËß£ÔºöËß£Ê≥ï‰∏ÄÔºö ‰∏çÂÆåÁæéÁÆóÊ≥ïÔºåÊØèÊ¨°Êûö‰∏æËÆ°ÁÆóÂå∫Èó¥ÂÜÖÊâÄÊúâÊï∞ÁöÑ‰∏™Êï∞ÊúâÂ§öÂ∞ë‰∏™ÔºåÂ¶ÇÊûúÊ≤°ÊúâÊï∞ÁöÑ‰∏™Êï∞Â∞è‰∫ékÁöÑÂ∞±Êõ¥Êñ∞Á≠îÊ°à,Â¶ÇÊûúÊúâÂ∞±ÊääËøôÂá†‰∏™Êï∞Ê†áËÆ∞ÔºåÁÑ∂ÂêéËøô‰∫õÊï∞‰ºöÊääÂéüÊú¨ÁöÑÊï∞ÁªÑÂàÜÊàêÂá†ÊÆµÔºåÁÑ∂ÂêéÂú®ËøôÂá†ÊÆµ‰∏≠ÁªßÁª≠Ê±Ç„ÄÇÁêÜËÆ∫‰∏äËøôÁßçÂÜôÊ≥ï‰ºöË∂ÖÊó∂ÔºåÂÆûÈôÖ‰∏äÂ∞±ÊòØË∂ÖÊó∂‰∫ÜÔºåÊâÄ‰ª•Êàë‰ª¨ÊääÂàÜÁöÑÊ¨°Êï∞ÈôêÂÆö‰∏Ä‰∏ãÔºåÂ¶ÇÊûúÂàÜ‰∫ÜË∂ÖËøá30Ê¨°Â∞±Áõ¥Êé•Ë∑≥Âá∫„ÄÇËøôÊ†∑ÁêÜËÆ∫‰∏äÊ≤°ÊúâÊääÊâÄÊúâÂèØËÉΩÊÄßË∑ëÂà∞Ôºå‰ΩÜÊòØËøôÁßçÊï∞ÊçÆÂæàÈöæÂæóÔºåÊâÄ‰ª•Âè™Ë¶ÅÊ≤°Êúâ‰∏ìÈó®Âç°ËøôÁßçÊï∞ÊçÆÂ∞±ËÉΩËøá„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;int n, c, k;int a[maxn];int b[maxn];int pos = 0;int v[maxn];int ans = 0;int de[maxn];int dfs(int l, int r, int dep) &#123; if (dep &gt; 30)return 0; if (r &lt; l)return 0; if (r - l + 1 &lt; k)return 0; for (int i = l; i &lt;= r; i++) &#123; b[a[i]] = 0; &#125; pos = 0; for (int i = l; i &lt;= r; i++) &#123; if (b[a[i]] == 0) &#123; v[pos++] = a[i]; &#125; b[a[i]]++; &#125; int flag = 0; for (int i = 0; i &lt; pos; i++) &#123; if (b[v[i]] &gt;= k) &#123; b[v[i]] = 1; &#125; else &#123; b[v[i]] = 0; flag = 1; &#125; &#125; for (int i = l; i &lt;= r; i++) &#123; if (b[a[i]] == 0)de[i] = 0; else de[i] = 1; &#125; if (flag == 0) &#123; ans = max(ans, r - l + 1); return 0; &#125; int L = -1, R = -1; for (int i = l; i &lt;= r; i++) &#123; if (de[i] &amp;&amp; L == -1) &#123; L = i; &#125; if (de[i] == 0 &amp;&amp; L != -1) &#123; R = i - 1; dfs(L, R, dep + 1); L = -1; &#125; &#125; if (L != -1 &amp;&amp; L &lt;= r) &#123; dfs(L, r, dep + 1); &#125;&#125;int main() &#123; f(); while (~scanf("%d%d%d", &amp;n, &amp;c, &amp;k)) &#123; ans = 0; for (int i = 1; i &lt;= n; i++)scanf("%d", &amp;a[i]); dfs(1, n, 0); printf("%d\n", ans); &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "ËøêË°åÊó∂Èó¥:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125; È¢òËß£‰∫åÔºö Êûö‰∏æÂå∫Èó¥r,Á∫øÊÆµÊ†ëÊü•ÊâæÊúÄÂ∞èÁöÑl„ÄÇËÉΩÂ§üÈÄâÁöÑ‰ΩçÁΩÆ‰∏ÄÂÆöÊòØÂàÜÊàê‰∏§ÊÆµ„ÄÇÁÑ∂ÂêéÊää‰ªé rÂà∞l Â∞ë‰∫ék‰∏™Êï∞Â≠ó‰∏çÂêàÊ≥ï Âå∫Èó¥ -1ÔºåÂèòÊàêÂêàÊ≥ïÁöÑÊó∂ÂÄô+1ÔºåÂ§ß‰∫éÁ≠â‰∫é0ÁöÑÂå∫Èó¥‰∏≠ÊúÄÂ∞è‰∏ãÊ†áÂ∞±ÊòØÁ≠îÊ°à„ÄÇÂÅáËÆæÔºåk=3ÊØè‰∏™Êï∞Â≠ó‰∏ÄÂÆöÊòØËøôÊ†∑Ôºå‰∏æ‰∏™‰æãÂ≠êk=21 4 1 4 2 1 1È¶ñÂÖàÂà∞ r=1 a[r]=1 ,Ê≤°ÊúâË∂ÖËøá k‰∏™, Êää ÊúÄÂºÄÂßãÂà∞ r ÂÖ®ÈÉ®Âáè 1 -1Êü•ËØ¢ [1,r] Ê≤°ÊúâÂ§ß‰∫éÁ≠â‰∫é0ÁöÑ‰ΩçÁΩÆÔºå‰∏çÊõ¥Êñ∞Á≠îÊ°àr=2 a[r]=4 ,‰∏™Êï∞Â∞ë‰∫é k,[1,r] -1 -2 -1[1,r] Ê≤°ÊúâÂ§ß‰∫é0 ÁöÑ‰ΩçÁΩÆ ,‰∏çÊõ¥Êñ∞r=3 a[r]=1 ,Â§ß‰∫éÁ≠â‰∫é k ‰∏™ÔºåÊääÂΩìÂâç‰ΩçÁΩÆÂíåÂâçÈù¢a[r]‰ΩçÁΩÆ‰πãÈó¥ -1, ‰πüÂ∞±ÊòØ [2,3] -1 ,ÁÑ∂ÂêéË∂ÖËøák‰∏™ÁöÑ‰ΩçÁΩÆ [1,1] +1-1 -2 -1ËøòÊòØÊ≤°Êúâ0ÁöÑ‰ΩçÁΩÆ ‰∏çÊõ¥Êñ∞r=4 a[r]=4ÔºåÂêå‰∏ä[3,4] -1 Ôºå[1,2] +10 -1 -2 -1ÊúÄÂ∞è0‰ΩçÁΩÆ‰∏∫1 pos=1 Êõ¥Êñ∞Á≠îÊ°à ans=max(ans,r-pos+1)ÂêéÈù¢‰æùÊ¨°Á±ªÊé®123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;int n, c, k;int a[maxn];int ans = 0;int last[maxn];int b[maxn];int dat[maxn &lt;&lt; 2];int lazy[maxn &lt;&lt; 2];int lastk[maxn], pre[maxn], nxt[maxn];void build(int l, int r, int k) &#123; if (r == l) &#123; dat[k] = 0; lazy[k] = 0; &#125; else &#123; build(lson); build(rson); dat[k] = 0; lazy[k] = 0; &#125;&#125;void push_down(int l, int r, int k) &#123; if (r == l)dat[k] += lazy[k]; else &#123; lazy[chl] += lazy[k]; lazy[chr] += lazy[k]; &#125; lazy[k] = 0; if (r != l)dat[k] = max(dat[chl] + lazy[chl], dat[chr] + lazy[chr]);&#125;void update(int A, int B, int l, int r, int k, int x) &#123;// if (k == 0) &#123;// printf("[%d,%d] %d\n", A, B, x);// &#125; push_down(l, r, k); if (A &gt; r || B &lt; l)return; else if (A &lt;= l &amp;&amp; r &lt;= B) &#123; lazy[k] += x; &#125; else &#123; update(A, B, lson, x); update(A, B, rson, x); dat[k] = max(dat[chl] + lazy[chl], dat[chr] + lazy[chr]); &#125;&#125;int query(int A, int B, int l, int r, int k) &#123; push_down(l, r, k); if (A &gt; r || B &lt; l || dat[k] &lt; 0)return inf; else if (r == l &amp;&amp; A &lt;= l &amp;&amp; r &lt;= B) &#123; return l; &#125; else &#123; if (B &lt;= mid || dat[chl] + lazy[chl] &gt;= 0) &#123; return query(A, B, lson); &#125; else return query(A, B, rson); &#125;&#125;int queryval(int A, int B, int l, int r, int k) &#123; push_down(l, r, k); if (A &gt; r || B &lt; l)return -inf; else if (A &lt;= l &amp;&amp; r &lt;= B) &#123; return dat[k]; &#125; else &#123; return max(queryval(A, B, lson), queryval(A, B, rson)); &#125;&#125;int main() &#123; f(); while (~scanf("%d%d%d", &amp;n, &amp;c, &amp;k)) &#123; ans = 0; build(1, n, 0); for (int i = 0; i &lt;= c; i++)b[i] = last[i] = lastk[i] = pre[i] = nxt[i] = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); nxt[last[a[i]]] = i; pre[i] = last[a[i]]; if (b[a[i]] + 1 &gt;= k) &#123; update(pre[i] + 1, i, 1, n, 0, -1); update(pre[lastk[a[i]]] + 1, lastk[a[i]], 1, n, 0, 1); lastk[a[i]] = nxt[lastk[a[i]]]; &#125; else if (b[a[i]] == 0) &#123; update(1, i, 1, n, 0, -1); lastk[a[i]] = i; pre[i] = 0; &#125; else if (b[a[i]] + 1 &lt; k) &#123; update(last[a[i]] + 1, i, 1, n, 0, -1); &#125; last[a[i]] = i; ans = max(ans, i - query(1, i, 1, n, 0) + 1); b[a[i]]++; &#125; if (k == 1)ans = n; else if (k == 0)ans = 0; printf("%d\n", ans); &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "ËøêË°åÊó∂Èó¥:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Êï∞ÊçÆÁªìÊûÑ</category>
      </categories>
      <tags>
        <tag>Êù≠ÁîµÂ§öÊ†°</tag>
        <tag>Á∫øÊÆµÊ†ë</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019ÁâõÂÆ¢ÊöëÊúüÂ§öÊ†°ËÆ≠ÁªÉËê•ÔºàÁ¨¨‰∫åÂú∫ÔºâJ Subarray]]></title>
    <url>%2F2019%2F07%2F23%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5(%E7%AC%AC%E4%BA%8C%E5%9C%BA)J%2F</url>
    <content type="text"><![CDATA[2019ÁâõÂÆ¢ÊöëÊúüÂ§öÊ†°ËÆ≠ÁªÉËê•ÔºàÁ¨¨‰∫åÂú∫ÔºâJ SubarrayÈ¢òÊÑèÔºöÈïøÂ∫¶‰∏∫$1e9$ÁöÑÂå∫Èó¥$A$‰∏ãÊ†á‰∏∫$[0,1e9-1]$,Êï∞ËæìÂÖ•$n$‰∏™Âå∫Èó¥Ôºå$[l_i,r_i]$Âå∫Èó¥Á±ªÁöÑÂÄº‰∏∫1ÔºåÂÖ∂‰Ωô‰∏∫-1ÔºåÈóÆÊúâÂ§öÂ∞ëÂå∫Èó¥ÂíåÂ§ß‰∫é0.È¢òËß£ÔºöÁúã‰∫ÜÊù•Ëá™Â§ß‰Ω¨ÁöÑÂçöÂÆ¢ÔºåËÉΩÂ§ü‰∫ßÁîüË¥°ÁåÆÁöÑÁÇπÊúÄÂ§öÂè™Êúâ$3e7$‰∏™,ÊÑèÊÄùÊòØÂÖàÊ±Ç‰∏Ä‰∏™ÂâçÁºÄÂíåÔºåÁÑ∂ÂêéÁîªÊàêÂõæÂ∫îËØ•ÊòØËøôÊ†∑„ÄÇÊúÄÂ∑ÆÂ∞±ÊòØËøôÊ†∑‰∫ÜÔºåËÉΩÂ§üÊúâÂΩ±ÂìçÁöÑÂ∞±Âè™ÊúâËøô$3e7$‰∏™ÁÇπ (ÂèØËÉΩÊòØÂàÜÊÆµÁöÑ) ÔºåÈÇ£‰πàÈóÆÈ¢òÊù•‰∫ÜÔºåÊÄé‰πàÊ±ÇÂá∫Ëøô$3e7$‰∏™ÁÇπ„ÄÇÊù•Ëá™Â§ß‰Ω¨ÁöÑÂçöÂÆ¢‰∏∫‰ªÄ‰πàÂë¢ÔºüÂú®Â§ß‰Ω¨ÁúºÈáåÂæàÁÆÄÂçïÔºåÊàëÁîª‰∫Ü‰∏™ÂõæÊâçÁêÜËß£„ÄÇÊòæÁÑ∂ÂâçÈù¢‰∏Ä‰∏™ÁöÑ$f[i]$Âä†ÂêéÈù¢$g[i+1]$ÊØî‰∏§‰∏™Âå∫Èó¥‰πãÈó¥ÁöÑÈïøÂ∫¶Â§ßÂ∞±‰∫ãËøûÂú®‰∏ÄËµ∑ÁöÑ„ÄÇ(ÊàëÊûúÁÑ∂Â§™Ëèú‰∫Ü)ÁÑ∂ÂêéÂ§ÑÁêÜÂÆå‰πãÂêéÔºåÂ∞±Áõ∏ÂΩì‰∫éÂ§ÑÁêÜ‰∏Ä‰∏™ËøôÊ†∑ÁöÑÂâçÁºÄÂíåÔºåÊ±ÇÊâÄÊúâ‰ΩçÁΩÆÊúâÂá†‰∏™Âú®‰ªñÂâçÈù¢ÂâçÁºÄÊØî‰ªñÂ∞è„ÄÇÂ¶ÇÊûúËåÉÂõ¥Â∞è‰∏ÄÁÇπÂ∞±Áî®Ê†ëÁä∂Êï∞ÁªÑÊ±Ç‰∏Ä‰∏ãÂ∞±Ê≤°‰∫ÜÔºå$3e7log(3e7)$ÊòæÁÑ∂Ë∂ÖÊó∂‰∫Ü„ÄÇÁúãÂà∞Ëøô‰∏™ÂâçÁºÄÂíåÔºåÂâçÂêéÈ°πÊúÄÂ§ßÂè™Â∑Æ‰∫Ü$1$,‰∏ä‰∏ãÁïåÊúÄÂ§ßÂ∑ÆÂÄº‰∏çË∂ÖËøá$3e7$,ËøôÂÜçÂÅö‰∏™ÂâçÁºÄÂíå sum „ÄÇÁî®‰∏Ä‰∏™Êï∞ÁªÑË°®Á§∫‰∏Ä‰∏™Êï∞Â≠óÂá∫Áé∞ÁöÑÊ¨°Êï∞ÔºåÁÑ∂Âêé$sum[m]=sum[m-1]+b[m]$,Êõ¥Êñ∞ÂâçÁºÄÂíå,Á≠îÊ°àÂ∞±ÊòØ$ans+=sum[m-1]$„ÄÇ‰∏≠Èó¥Êúâ‰∏Ä‰∫õÁªÜËäÇË¶ÅÂ§ÑÁêÜ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;typedef long double ld;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;(x)&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define mem(a, b) memset(a,b,sizeof(a));const long long mod = 1e9 + 7;const int maxn = 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;void fin() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif // ONLINE_JUDGE&#125;#ifndef ONLINE_JUDGEclock_t start = clock();#endif // ONLINE_JUDGEint n;LL l[maxn], r[maxn];LL f[maxn], g[maxn];struct node &#123; LL l, r, x;&#125; dat[maxn * 5];LL sum[maxn * 30 + 20], b[maxn * 30 + 20];int main() &#123; fin(); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%lld%lld", &amp;l[i], &amp;r[i]); &#125; f[1] = r[1] - l[1] + 1; for (int i = 2; i &lt;= n; i++) &#123; f[i] = max(0LL, f[i - 1] - (l[i] - r[i - 1] - 1)) + r[i] - l[i] + 1; &#125; g[n] = r[n] - l[n] + 1; for (int i = n - 1; i &gt;= 1; --i) &#123; g[i] = max(0LL, g[i + 1] - (l[i + 1] - r[i] - 1)) + r[i] - l[i] + 1; &#125; int i = 1; LL ans = 0; while (i &lt;= n) &#123; int j = i + 1; LL mi = 0, mx = 0, pos = 0; //mi ‰∏ãÁïå,mx ‰∏äÁïå while (j &lt;= n &amp;&amp; g[j] + f[j - 1] &gt;= l[j] - r[j - 1] - 1) &#123; j++; &#125; j--; int t = i, num = 1; // [i,j] Âå∫Èó¥ÊòØÁõ∏‰∫íÂΩ±ÂìçÁöÑ for (; t &lt;= j; t++) &#123; // ÊääÊØè‰∏ÄÊÆµÂ§ÑÁêÜÂà∞ datÈáåÈù¢ if (num == 1)dat[num].l = 0; else if (l[t] - r[t - 1] == 1) dat[num].l = pos + 1; else dat[num].l = pos; pos += r[t] - l[t] + 1; dat[num].r = pos; dat[num++].x = 1; mx = max(mx, pos); if (t != j) &#123; dat[num].r = pos - 1; pos -= l[t + 1] - r[t] - 1; dat[num].l = pos + 1; dat[num++].x = 0; // 0 Ë°®Á§∫‰∏ãÈôç ,1 Ë°®Á§∫‰∏äÂçá mi = min(pos, mi); &#125; else &#123; dat[num].r = pos - 1; dat[num].l = max(mi, pos - ((int) 1e9 - 1 - r[t])); dat[num++].x = 0; &#125; &#125; dat[0].r = min(mx, l[i]); dat[0].l = 1; dat[0].x = 0; for (int k = 0; k &lt;= mx - mi + 200; k++)b[k] = sum[k] = 0; assert(mx - mi &lt; maxn * 30); for (int k = 0; k &lt; num; ++k) &#123; dat[k].l += -mi; //ÂÖ®ÈÉ®Âêë‰∏äÁßªÂä®‰∏Ä‰∏™‰∏ãÂ±äÔºå‰øùËØÅÊúÄÂ∞èÂÄºÁ≠â‰∫é0 dat[k].r += -mi; if (dat[k].x == 1) &#123; for (int m = dat[k].l; m &lt;= dat[k].r; ++m) &#123; b[m]++; sum[m] = sum[m - 1] + b[m]; if (m &gt;= 1)ans += sum[m - 1]; &#125; &#125; else &#123; LL tmp = 0; if (dat[k].l &gt; 0)tmp = sum[dat[k].l - 1]; for (int m = dat[k].l; m &lt;= dat[k].r; ++m) &#123; if (m &gt;= 1)ans += tmp; tmp = sum[m]; //Â¶ÇÊûúÊòØ‰∏ãÈôçÁöÑ Ôºå‰ªéÂ∞èÂæÄ‰∏äÂ§ÑÁêÜÊòØ‰∏çËÉΩÊääÂΩìÂâçÊõ¥Êñ∞Âä†ËøõÂéªÂõ†ÂΩìÂâçËøô‰∏™Âú®‰ªñÂêéÈù¢ b[m]++; sum[m] = sum[m - 1] + b[m]; &#125; &#125; &#125; i = j + 1; &#125; printf("%lld\n", ans);#ifndef ONLINE_JUDGE cout &lt;&lt; "RUNTIME:" &lt;&lt; (1.0 * clock() - start) / 1000 &lt;&lt; "ms" &lt;&lt; endl;#endif // ONLINE_JUDGE return 0;&#125; ÁªôÂá†ÁªÑÊï∞ÊçÆ‰Ω†ÂéªËØïËØï 1234567891011121314151625 912 1733 56 67 933 58 89 101999999998 999999999 123456720076494]]></content>
      <categories>
        <category>ACM</category>
        <category>ÊØîËµõ</category>
      </categories>
      <tags>
        <tag>ÁâõÂÆ¢ÊöëÊúüÂ§öÊ†°ËÆ≠ÁªÉËê•</tag>
        <tag>Â∑ßËß£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NTTÂø´ÈÄüÊï∞ËÆ∫ÂèòÊç¢]]></title>
    <url>%2F2019%2F07%2F22%2FNTT%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[NTTÁêÜËß£‰∫ÜFFTÁöÑÂéüÁêÜÔºåNTT‰πüÂ∑Æ‰∏çÂ§ö„ÄÇFTTÊòØÁî®Â§çÊï∞ÂÆûÁé∞ÂèòÊç¢ÔºåËÄåNTTÊòØÁî®ÂèñÊ®°ÊÑè‰πâÂÆûÁé∞„ÄÇÊâæÂá∫‰∏Ä‰∏™g,ÂíåÂºÄ‰∏Ä‰∏™Ê®°Êï∞p,gÊòØpÁöÑÂéüÊ†π„ÄÇ ÂéüÊ†π $0&lt;i&lt;P,0&lt;j&lt;P,1&lt;g&lt;P\ g^i(mod\ p)\ne g^j(mod\ p)$ ËøôÊ†∑Âú®FTTÈáåÈù¢ÁöÑ$w_n^1\equiv g^{\frac{p-1}{n}}$„ÄÇÊòæÁÑ∂:$(g^\frac{p-1}{n})^n=g^{p-1}=1(mod\ p)$$g^\frac{p-1}{n} * g^\frac{p-1}{n} = g^{2\frac{p-1}{n}}$ÂêåÊ†∑ÁöÑ FFT ÈáåÈù¢Áî®Âà∞ÁöÑÂá†‰∏™ÂéüÊ†πÊÄßË¥®Ôºå‰ªñÈÉΩÊúâ„ÄÇ‰Ω†ÂèØ‰ª•ÊäΩË±°‰∏∫ÔºåÊää‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫ P Á∫øÊÆµÔºåÊØèÊ¨°Ëµ∞‰∏ÄÊ†ºÔºåËµ∞‰∫ÜNÊ¨°ÂõûÊù•‰∫Ü„ÄÇ ÊâÄ‰ª•‰∏ÄÂºÄÂßãË¶ÅÊ±ÇÁöÑÂá†‰∏™ÁÇπÂÄºÊòØ$\{A(1),A(g^{\frac{p-1}{n}}),\cdots,A(g^{\frac {p-1}{n}{n-1}})\}$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//ntt#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int N=(1&lt;&lt;18)+5, INF=1e9;const double PI=acos(-1);inline int read()&#123; char c=getchar();int x=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125; ll P=1004535809;ll Pow(ll a, ll b,ll P) &#123; ll ans=1; for(; b; b&gt;&gt;=1, a=a*a%P) if(b&amp;1) ans=ans*a%P; return ans;&#125;struct NumberTheoreticTransform &#123; int pow2(int x) &#123; int res = 1; while (res &lt; x) res &lt;&lt;= 1; return res; &#125; inline LL pow_mod(ll x, int n) &#123; ll res; for (res = 1; n; n &gt;&gt;= 1, x = x * x % mod) if (n &amp; 1) res = res * x % mod; return res; &#125; inline int add_mod(int x, int y) &#123; x += y; return x &gt;= mod ? x - mod : x; &#125; inline int sub_mod(int x, int y) &#123; x -= y; return x &lt; 0 ? x + mod : x; &#125; void NTT(LL a[], int n, int op) &#123; for (int i = 1, j = n &gt;&gt; 1; i &lt; n - 1; ++i) &#123; if (i &lt; j) swap(a[i], a[j]); int k = n &gt;&gt; 1; while (k &lt;= j) &#123; j -= k; k &gt;&gt;= 1; &#125; j += k; &#125; for (int len = 2; len &lt;= n; len &lt;&lt;= 1) &#123; LL g = pow_mod(3, (mod - 1) / len); for (int i = 0; i &lt; n; i += len) &#123; LL w = 1; for (int j = i; j &lt; i + (len &gt;&gt; 1); ++j) &#123; LL u = a[j], t = 1ll * a[j + (len &gt;&gt; 1)] * w % mod; a[j] = (u + t) % mod, a[j + (len &gt;&gt; 1)] = (u - t + mod) % mod; w = 1ll * w * g % mod; &#125; &#125; &#125; if (op == -1) &#123; reverse(a + 1, a + n); LL inv = pow_mod(n, mod - 2); for (int i = 0; i &lt; n; ++i) a[i] = 1ll * a[i] * inv % mod; &#125; &#125; void mul(LL A[], LL B[], int Asize, int Bsize) &#123; int n = pow2(Asize + Bsize - 1); for (int i = Asize; i &lt; n; ++i) A[i] = 0; for (int i = Bsize; i &lt; n; ++i) B[i] = 0; NTT(A, n, 1); NTT(B, n, 1); for (int i = 0; i &lt; n; ++i) &#123; A[i] = 1ll * A[i] * B[i] % mod; B[i] = 0; &#125; NTT(A, n, -1); return; &#125;&#125; f; int n1, n2, m, c[N];ll a[N], b[N];char s1[N], s2[N];int main() &#123; //freopen("in","r",stdin); scanf("%s%s",s1,s2); n1=strlen(s1); n2=strlen(s2); for(int i=0; i&lt;n1; i++) a[i] = s1[n1-i-1]-'0'; for(int i=0; i&lt;n2; i++) b[i] = s2[n2-i-1]-'0'; m=n1+n2-1; f.mul(a, b, m); for(int i=0; i&lt;m; i++) c[i]=a[i]; for(int i=0; i&lt;m; i++) c[i+1]+=c[i]/10, c[i]%=10; if(c[m]) m++; for(int i=m-1; i&gt;=0; i--) printf("%d",c[i]);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Êï∞ËÆ∫</category>
      </categories>
      <tags>
        <tag>FFT/NTT/FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFTÂø´ÈÄüÂÇÖÈáåÂè∂ÂèòÊç¢ÁÆÄËß£]]></title>
    <url>%2F2019%2F07%2F20%2FFFT%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E7%AE%80%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ê¶ÇËø∞FTTÔºö Âø´ÈÄüÂÇÖÈáåÂè∂ÂèòÊç¢„ÄÇÁúãËµ∑Êù•Êå∫ÈöæÁöÑÔºåÂÆûÈôÖ‰∏äÁ°ÆÂÆûÊå∫ÈöæÁöÑ„ÄÇ Áî®ÈÄîA=a_0+a_1x+a_2x\cdots +a_nx^nB=b_0+b_1x+b_2x\cdots +b_nx^nÊ±Ç C_k=\sum_{i+j=k}A_i * B_j‰πüÂ∞±ÊòØ‰∏äÈù¢‰∏§‰∏™Â§öÈ°πÂºèÁõ∏‰πòÁ≠â‰∫é‰∏ãÈù¢Ëøô‰∏™ C=c_0+c_1x+c_2x\cdots +c_{2n}x^{2n}Êú¥Á¥†ÁÆóÊ≥ï‰∏Ä‰∏™‰∏™‰πò $O(n^2)$ Â§çÊùÇÂ∫¶ÔºåFFTËÉΩÂú® $O(nlog(n)$ ÁöÑÂ§çÊùÇÂ∫¶ÂÜÖËß£ÂÜ≥„ÄÇ ÁÇπÂÄºËøô‰∏™ÊòØÂ§öÈ°πÂºè Á≥ªÊï∞Ë°®Ëææ A=a_0+a_1x+a_2x\cdots +a_nx^n‰∏ãÈù¢Ëøô‰∏™ÊòØ ÁÇπÂÄºË°®Á§∫Ê≥ï \{ (x_0,y_0) , (x_1,y_1) , \cdots (x_n,y_n) \}‰∏çÈöæÁúãÂá∫ËÉΩÁî®‰∏ãÈù¢Ëøô‰∏™n+1‰∏™‰∏çÂêåÁöÑÁÇπÂÄºÊé®Âá∫ Á≥ªÊï∞Ë°®ËææÂºè FFTÊ≠•È™§ Âä†ÂÄçÊ¨°Êï∞ÁïåÊ±ÇÂÄº Â∞ÜËΩ¨A BÁ≥ªÊï∞Ë°®ËææÂºèÔºåÊâæÂá∫ 2n+1 ‰∏™ÁÇπÂÄº,(Âè™ÈúÄË¶Ån+1‰∏™ÁÇπÂÄºÂ∞±ËÉΩÊé®Âá∫‰∏Ä‰∏™ÊúÄÈ´òÊ¨°È°π‰∏∫nÁöÑË°®ËææÂºèÔºå‰ΩÜÊòØÔºåA BÁõ∏‰πòÂêéÊúâ2nÔºåÊâÄ‰ª•Ë¶ÅÊâæÂá∫2n+1‰∏™ÂÄº) ÈÄêÁÇπÁõ∏‰πò Â∞Ü‰∏§‰∏™ÁÇπÂÄºÁõ∏‰πòËé∑ÂæóC ÁöÑÁÇπÂÄºC=\{(x_0 ,A(x_0) * B(x_0)),\cdots,(x_{2n},A(x_{2n}) * B(x_{2n})\} ÊèíÂÄº ÂÜçÁî®ÈÄÜÂèòÊç¢Â∞ÜCÁöÑÁÇπÂÄºËΩ¨Êç¢Êàê Á≥ªÊï∞Ë°®ËææÂºè Á¨¨‰∏ÄÊ≠•Âè´Á¶ªÊï£ÂÇÖÈáåÂè∂ÂèòÊç¢ (DFT) Ê≠£ÂºèËÆ≤Ëß£‰∏çÈöæÁúãÂá∫,Â¶ÇÊûúÁõ¥Êé•Áî®Êú¥Á¥†ÁÆóÊ≥ïÔºåÂéªÊ±ÇÂ§öÈ°πÂºè‰πòÁßØÔºåÁ¨¨‰∏ÄÊ≠•Â§çÊùÇÂ∫¶ $O(n^2)$,Á¨¨‰∫åÊ≠•$O(n)$ÔºåÁ¨¨‰∏âÊ≠•$O(n^2)$FFT ‰ΩúÁî®Â∞±ÊòØ‰ºòÂåñÁ¨¨‰∏ÄÊ≠•ÂíåÁ¨¨‰∏âÊ≠•ÔºåÈÉΩÂèòÊàê$O(nlog(n))$ÁöÑÂ§çÊùÇÂ∫¶„ÄÇ Âú®Ëøô‰πãÂâçÈúÄË¶ÅÁü•ÈÅì‰∏Ä‰∏™‰∏úË•øÂè´Âçï‰ΩçÂ§çÊ†π Âçï‰ΩçÂ§çÊ†π‰∏çÂÖ∑‰ΩìËÆ≤‰∫Ü,ËÆ≤‰∫Ü‰Ω†‰πüÁêÜËß£‰∏ç‰∫Ü„ÄÇ (ÂÖ∂ÂÆûÊàëÊ≤°ÁêÜËß£)ÊÉ≥Ë¶ÅÂÖ∑‰Ωì‰∫ÜËß£ËßÅÈªë‰π¶ÁÆóÊ≥ïÂØºËÆ∫P532ÔºåÊàëÂè™ÂÅöÁÆÄ‰ªãnÊ¨°Âçï‰ΩçÂ§çÊ†πÔºå$w^n=1$ÔºåËøô‰∏™Êï∞ÊúâÊÅ∞Â•Ωn‰∏™ÔºåÂÖ∑‰ΩìÊòØÂï•‰∏çÈáçË¶ÅÔºåÊàëËØ¥‰∏™ÁÆÄÂçïÁöÑÁêÜËß£„ÄÇÂ§çÊï∞Â§ßÂÆ∂ÈÉΩÁü•ÈÅìÂêß„ÄÇÂÅáËÆæÊúâ‰∏§‰∏™Â§çÊï∞$z1=a+bi$$z2=c+di$Êää‰ªñ‰ª¨‰∏§‰∏™‰πò‰∏Ä‰∏ã z2z1=(ac-bd)+(ad+bc)iÊ±Ç‰∏Ä‰∏ã$z1 z2$‰ªñ‰ª¨ÁöÑÈïøÂ∫¶ÂíåËßíÔºåÂÖàÊ±ÇÈïøÂ∫¶ [z1]=\sqrt{a^2+b^2}[z2]=\sqrt{b^2+c^2}[z1z2]=\sqrt{(ac-bd)^2+(ad+bc)^2}=\sqrt{a^2c^2+b^2d^2+a^2d^2+b^2c^2}=\sqrt{(a^2+b^2)(b^2+d^2)}ÊòØ‰∏çÊòØÂ∞±Á≠â‰∫é$[z1] * [z2]$ÁÑ∂Âêé‰Ω†‰ª£‰∏Ä‰∏™Êï∞Êîæz1 z2ÈáåÈù¢ z1=cos(\alpha)+sin(\alpha)iz2=cos(\beta)+sin(\beta) i\begin{aligned} z1z2&=(cos(\alpha) cos(\beta)-sin(\alpha)sin(\beta))+(cos(\alpha)sin(\beta)+sin(\alpha)cos(\beta))i\\ &=cos(\alpha+\beta)+sin(\alpha+\beta)i \end{aligned}ÁúãÂà∞ËøôÂ∫îËØ•ÊáÇ‰∫ÜÔºåÂ§çÊï∞ÁöÑ‰πòÊ≥ïÊÄßË¥®„ÄÇ (a_0,\theta_0) * (a_1,\theta_1)=(a_1 * a_0,\theta_0\theta_1)ÂèØËÉΩ‰Ω†Ëøò‰∏çÁü•ÈÅìËøôÊÑèÂë≥ÁùÄÂï•Ôºå‰ΩÜÊòØÈ©¨‰∏ä‰Ω†Â∞±ÊáÇ‰∫ÜÂÅáËÆæ‰∏Ä‰∏™Â§çÊï∞ÔºåÈïøÂ∫¶‰∏∫1ÔºåËßíÂ∫¶‰∏∫\frac{2\pi}{n}Ôºå$w_n^1=cos(\frac{2\pi}{n})+sin(\frac{2\pi}n{})i$Êää‰ªñÁîªÊàêÊàêÂúÜÂ∞±ÊòØÈÇ£‰πàw_n^2=w_n^1 * w_n^1 Â∞±Áõ∏ÂΩì‰∫éÂú®ÂúÜ‰∏äËΩ¨‰∫Ü‰∏Ä‰∏ãÂ¶Ç‰∏ãÂõæÁúãÂà∞ËøôÔºåÂêéÈù¢ÁêÜËß£ÊÄßË¥®Â∞±Ë¥ºÁÆÄÂçïÔºå‰Ω†ÂÖ®ÈÉ®ÊÉ≥Ë±°ÊàêÂú®ÂúÜ‰∏äÈù¢ÊóãËΩ¨„ÄÇ‰ΩÜÊòØËøô‰∫õÈÉΩ‰∏çÈáçË¶ÅÊé•‰∏ãÊù•Áªô‰Ω†ÈÄÄÂÖ¨Âºè‰∫Ü,ÂÅáËÆæ AÊúâÊúÄÈ´òÊ¨°È°π‰∏∫ n-1 \begin{aligned} A&=a_0+a_1x+a_2x^2+\cdots+a_{n-1}x^{n-1}\\ &=(a_0+a_2x^2+\cdots+a_{n-2}x^{n-2})+x(a_1+a_3x^2+\cdots+a_{n-1}x^{n-2}) \end{aligned}ÂèØ‰ª•ÂèëÁé∞ÂâçÈù¢‰∏ÄÂ†ÜÂíåÂêéÈù¢‰∏ÄÂ†ÜÂæàÂÉèÁÑ∂ÂêéËÆæËøô$A0 A1$ A0=a_0+a_2x+a_4x^2+\cdots+a_{n-2}x^{n-1}\\ A1=a_1+a_3x+a_5x^2+\cdots+a_{n-1}x^{n-1}Ëøô‰∏™Âú∞ÊñπÊ≥®ÊÑèÔºåA0,A1 ÈáåÈù¢ÁöÑÊ¨°È°πÊòØÂºÄÊ†πÂè∑ÊâÄ‰ª•ÊòØ A=A0(x^2)+xA1(x^2)ÂÅáËÆæ‰Ω†‰ª£ÂÖ•ÁöÑÊòØ‰∏Ä‰∏™ÊôÆÈÄöÁöÑÊï∞ÔºåÂÅáËÆæÊòØ \{1,x_0,\cdots,x_{n-1}\}Ôºå$A(X)=A0(X^2)+xA1(X^2)$ ‰Ω†ËøòÈúÄË¶ÅÊ±Ç\{A0(1),A0(x_0^2),\cdots,A0(x_{n-1}^2),A1(1),A1(x_0^2),\cdots,A1(x_{n-1}^2)\} ,‰∏ÄÂÖ±ÊòØ2n‰∏™Ôºå‰∏§ËæπÂêåÊó∂Ê±ÇËøòÊòØ$O(n)$.ÂΩì‰Ω†Â∏¶ÂÖ•Â§çÊï∞ \{1,w_n^1,\cdots,w_n^{n-1}\},‰Ω†ÂèØ‰ª•ÂèëÁé∞‰∏Ä‰∏™Á•ûÂ•áÁöÑ‰∫ãÔºåË¶ÅÊ±ÇÁöÑÊï∞ÈáèÂèòÂ∞ë‰∫Ü \begin{aligned} A&=A0((w_n^k)^2)+w_n^kA1((w_n^k)^2)\\ &=A0(w_n^{2k})+w_n^kA1(w_n^{2k})\\ &=A0(w_{\frac{n}{2}}^k)+w_n^kA1(w_{\frac{n}{2}}^k) \end{aligned}‰∏äËø∞ÂÖ¨ÂºèÂåñÁÆÄÁî®‰∏ä‰∫Ü‰∏Ä‰∏™ÂÖ¨Âºè w_n^k=w_{\frac{n}{2}}^{\frac{k}{2}} Ëøô‰∏™‰∫ãÂæàÊòæÁÑ∂ÁöÑ‰∫ãÔºåÂú®Âçï‰ΩçÂúÜÈáåÈù¢ÔºåÊîπÂèòËøô‰∏™ÊØî‰æãÔºåËßíÂ∫¶‰∏çÂèò ‰Ω†ÈúÄË¶ÅÊ±ÇÁöÑÊï∞Â∞±ÂèòÊàê‰∫Ü\{1,w_{\frac{n}{2}}^1,\cdots,w_\frac{n}{2}^{n-1}\}Áúã‰∏äÂéªÊ≤°ÊúâÂáèÂ∞ëÔºåÂÆûÈôÖ‰∏ä‰Ω†ÂèØ‰ª•ÂèëÁé∞ÔºåÂÖ∂‰∏≠Êúâ‰∏ÄÂçäÂÖ∂ÂÆûÊòØÈáçÂ§çÁöÑÔºåËøôÂèàË¶ÅÁ´ãÁî®Âà∞‰∏Ä‰∏™ÂÖ¨Âºè $w_n^k=w_n^{k+n}$ ÂæàÊòæÁÑ∂ÔºåÂúÜËΩ¨‰∫Ü‰∏ÄÂúàÔºåÊàëÂèàÂõûÊù•Âï¶ ÊâÄ‰ª•Â∞±ÂèòÊàê‰∫ÜÊ±Ç\{1,w_{\frac{n}{2}}^1,\cdots,w_\frac{n}{2}^{\frac{n-2}{2}}\}‰∏æ‰∏™Ê†óÂ≠ê Ëß£Èáä‰∏Ä‰∏ãÂÅáËÆæ ‰∏Ä‰∏™ AÈïøÂ∫¶‰∏∫4 ÊúÄÈ´òÊ¨°È°πÂ∞±ÊòØ 3 A=a_0+a_1x+a_2x^2+a_3^3x^3Ê±Ç 4 ‰∏™ ÁÇπÂÄº \{\{1,A(1)\},\{w_4^1,A(w_4^1)\},\{w_4^2,A(w_4^2)\},\{w_4^3,A(w_4^3)\}\}‰∏ÄÂºÄÂßãË¶ÅÊ±ÇÁöÑÊúâ 4 ‰∏™ÁÇπÂÄº \{A(1),A(w_4^1),A(w_4^2),A(w_4^3)\}ÈÄöËøáÂâçÈù¢ÈÇ£‰∏™ËΩ¨Êç¢, Áúã‰∏çÊáÇ‰∏∫Âï•Êúâ‰∏™1ÁöÑ ÔºåÊ≥®ÊÑè $w_n^0=1$ \begin{aligned} A(1)&=A0(1)+1A1(1)\\ A(w_4^1)&=A0(w_2^1)+w_4^1A1(w_2^1)\\ A(w_4^2)&=A0(w_2^2)+w_4^2A1(w_2^2)=A0(1)+w_4^2A1(1)\\ A(w_4^3)&=A0(w_2^3)+w_4^3A1(w_2^3)=A0(w_2^1)+w_4^3A1(w_2^1) \end{aligned}Ë¶ÅÊ±ÇÁöÑÁÇπÂÄºÂ∞±ÂèòÊàê‰∫Ü$\{A0(1),A0(w_2^1),A1(1),A1(w_2^1)\}$ ÂêåÊ†∑ÊòØ4‰∏™Ôºå ‰ΩÜÊòØÈÄíÂΩí‰∏ãÂéªÊâæÊØèÊ¨°ÂàÜÊàê‰∏§ÈÉ®ÂàÜÔºåÂ∞±Áõ∏ÂΩì‰∫éÊäòÂçä‰∫ÜÔºå(ËøòÊòØÊ≤°ÊúâÁêÜËß£Á≠â‰ºöÁîª‰∏™ÂõæÁªô‰Ω†Áúã‰∏ã) Âè¶Â§ñËøòÊ≤°ÂÆåÔºå‰∏äËø∞ËøòÊúâ‰∏Ä‰∏™ÁâπÁÇπ: ÂâçÈù¢‰∏ÄÂçäÂíåÂêéÈù¢‰∏ÄÂçä ÂæàÂÉèÔºåÊ≤°ÈîôÔºåËøòÂèØ‰ª•‰ºòÂåñ„ÄÇËøô‰∏™Âú∞ÊñπÂèàË¶ÅÁî®Âà∞‰∏Ä‰∏™ÊÄßË¥®. $w_n^{k+\frac{n}{2}}=-w_n^{k}$ ÂæàÊòæÁÑ∂,‰Ω†Âú®ÂúÜÈáåÈù¢ËΩ¨‰∫ÜÂçäÂúàÔºå‰∏çÂ∞±ÊòØ‰∏™Áõ∏ÂèçÁöÑ‰∫Ü‰πà„ÄÇ„ÄÇ„ÄÇ„ÄÇ ÊÑüËßâÊàëÁöÑËØÅÊòéÈÉΩÊòØÊòæÁÑ∂ËØÅÊòéÊ≥ï,‰∏çÁî®Âú®ÊÑèËøô‰∫õÁªÜËäÇÁî±Ê≠§ÂèØ‰ª•ÂÜç‰ºòÂåñÂΩì$k&lt;\frac{n}{2}$ A(w_n^k)=A0(w_{\frac{n}{2}}^k)+w_n^kA1(w_{\frac{n}{2}}^k)ÂΩì$k&gt;\frac{n}{2}$ A(w_n^k)=A0(w_{\frac{n}{2}}^k)-w_n^{k-\frac{n}{2}}A1(w_{\frac{n}{2}}^k)ÁΩë‰∏äÂæàÂ§öÂÜôÁöÑÊòØA(w_n^{k+\frac{n}{2}})=A0(w_{\frac{n}{2}}^k)-w_n^{k}A1(w_{\frac{n}{2}}^k)ÔºåÂÖ∂ÂÆûÊòØ‰∏Ä‰∏™ÊÑèÊÄùÔºåÂì™‰∏™Â•ΩÁêÜËß£‰Ω†ÁúãÂì™‰∏™Âêß„ÄÇ‰æãÂ≠êA(w_4^3)=A0(w_2^1)-w_4^1A1(w_2^1)ÂØπÂ∫î‰∏äÈù¢‰∏æÂæóÈÇ£‰∏™ÂÖ∑‰ΩìÁöÑ‰æãÂ≠êÔºå‰Ω†Â∞±ÂèØ‰ª•ÂÜçÊ¨°‰ºòÂåñ‰∫Ü„ÄÇ Ëøô‰∏™Âú∞ÊñπÁúã‰∏çÊáÇÊé®Ëçê‰∏ÄÁØáÁ•ûÁ∫ßÂ§ß‰Ω¨ÁöÑÂçöÂÆ¢ ‰ªéÂ§öÈ°πÂºè‰πòÊ≥ïÂà∞Âø´ÈÄüÂÇÖÈáåÂè∂ÂèòÊç¢ ÊúÄÂêéÂÜçÁîª‰∏™ÂõæÂä©Ëß£‰∏Ä‰∏ã: Ëá≥Ê≠§ÁÆóÊ≥ïÊ†∏ÂøÉÂéüÁêÜÂÖ®ÈÉ®Ëß£ÈáäÂÆåÊØï„ÄÇÈÄÜËøêÁÆó‰ªéÁÇπÂÄº ËΩ¨Êç¢ÊàêÁ≥ªÊï∞Ë°®ËææÂºè Ôºå‰Ω†ÊääÁü©ÈòµÂÜôÂá∫Êù•ÔºåÂ∞±Áõ∏ÂΩì‰∫é‰πò‰∫Ü‰∏Ä‰∏™ÈÄÜÁü©Èòµ„ÄÇÂ∞±Áõ∏ÂΩì‰∫éÂÜçÊ±Ç‰∏ÄÊ¨°DFT ÔºåÂè™‰∏çËøá $w_n^k$ ÂèòÊàê‰ªñÁöÑÈÄÜÔºåw_n^k * w_n^{-k}=1ÔºåÂä†‰∏™Ë¥üÂè∑Â∞±Ë°å‰∫Ü„ÄÇ‰ª£Á†ÅÁΩë‰∏ä‰∏ÄÂ§ßÂ†ÜÊàëËøôÈáåË¥¥‰∏™ÊàëÁöÑÔºåÊµãËØïÈ¢òÁõÆ51Nod Â§ßÊï∞‰πòÊ≥ï2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;const double eps = 0.5;const double pi = acos(-1.0);struct complexx &#123; double x, y; complexx(double xx = 0, double yy = 0) &#123; x = xx, y = yy; &#125; void put() &#123; printf("[x=%f y=%f]\n", x, y); &#125;&#125; a[maxn], b[maxn];complexx operator+(complexx a, complexx b) &#123; return complexx(a.x + b.x, a.y + b.y); &#125;complexx operator-(complexx a, complexx b) &#123; return complexx(a.x - b.x, a.y - b.y); &#125;complexx operator*(complexx a, complexx b) &#123; return complexx(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y); &#125;void fft(int len, complexx *a, int o) &#123; if (len == 1) return; complexx a0[(len &gt;&gt; 1) + 3], a1[(len &gt;&gt; 1) + 3]; for (int i = 0; i &lt;= len; i += 2) a0[i &gt;&gt; 1] = a[i], a1[i &gt;&gt; 1] = a[i + 1]; fft(len &gt;&gt; 1, a0, o); fft(len &gt;&gt; 1, a1, o); complexx wn = complexx(cos(2 * pi / len), o * sin(2 * pi / len)), w0 = complexx(1, 0); for (int i = 0; i &lt; (len &gt;&gt; 1); i++, w0 = w0 * wn) &#123; a[i] = a0[i] + w0 * a1[i];// a[i + (len &gt;&gt; 1)] = a0[i] - w0 * a1[i]; //ÂâçÈù¢ËØ¥ÁöÑ‰∏Ä‰∏™‰ºòÂåñ &#125; //‰∏çÂä†‰ºòÂåñÁªßÁª≠Ë∑ë‰∏ãÂéªÔºåÁõ¥Êé•Êûö‰∏æÊâÄÊúâ for (int i = (len &gt;&gt; 1); i &lt; len; i++, w0 = w0 * wn) &#123; a[i] = a0[i - (len &gt;&gt; 1)] + w0 * a1[i - (len &gt;&gt; 1)]; &#125;&#125;char s[maxn];int ans[maxn];int main() &#123; f(); scanf("%s", s); int la = strlen(s); for (int i = la - 1; i &gt;= 0; i--)a[i].x = s[la - i - 1] - '0'; scanf("%s", s); int lb = strlen(s); for (int i = lb - 1; i &gt;= 0; i--)b[i].x = s[lb - i - 1] - '0'; int m = la + lb - 2; int len = 1; for (; len &lt;= m; len &lt;&lt;= 1); fft(len, a, 1);//DFT fft(len, b, 1);//DFT for (int i = 0; i &lt;= len; i++) a[i] = a[i] * b[i]; fft(len, a, -1);//IDFT for (int i = 0; i &lt;= m; i++) &#123; ans[i] = (int) (a[i].x / len + eps);//ËÆ∞ÂæóÈô§len eps Áî®Êù•Ê∂à ÊµÆÁÇπËØØÂ∑ÆÊàëÁî®ÁöÑ 0.5 &#125; for (int i = 0; i &lt;= m; i++)ans[i + 1] += ans[i] / 10, ans[i] = ans[i] % 10; if (ans[m + 1])printf("%d", ans[m + 1]); for (int i = m; i &gt;= 0; i--) &#123; printf("%d", ans[i]); &#125; puts("");#ifndef ONLINE_JUDGE cout &lt;&lt; "ËøêË°åÊó∂Èó¥:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125; ‰Ω†‰ª•‰∏∫Â§ßÁªìÂ±Ä‰∫ÜÂêó?Ê≤°Êúâ ‰ºòÂåñÈô§‰∫ÜÂâçÈù¢ÈÇ£‰∏™Áõ¥Êé•ÂÜçË°®ËææÂºè‰∏äÁöÑ‰ºòÂåñ,Ôºå‰∏ãÈù¢ËøòÊúâ‰ª£Á†Å‰∏äÁöÑ‰ºòÂåñ„ÄÇÈÄíÂΩíÂ§™ÊÖ¢‰∫ÜÔºåÂèØ‰ª•Êç¢ÊàêËø≠‰ª£„ÄÇÂè¶Â§ñÔºåËøôÁ©∫Èó¥ÂèòÊàê‰∫Ünlog(n) ÔºåÈÇ£‰∏™ËæÖÂä©Êï∞ÁªÑ‰ºòÂåñÊéâ‰πüÂèØ‰ª•‰∏çÂ•Ω.Â∑≤ÁªèÁêÜËß£Ê†∏ÂøÉ‰∫ÜÔºåÂêéÈù¢Ëøô‰∏™Â∞±‰∏çÁî®ÊàëËØ¥‰∫ÜÂêß„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇÊòØÊàëÊáíÂæóÂÜô‰∫ÜÔºåÊàë18Â≤ÅÊàëÂ•ΩÁ¥Ø Áõ¥Êé•Ë¥¥‰∏Ä‰∏™Â§ßÂì•ÁöÑÊùøÂ≠êÊääÔºåÊâæÁöÑÂ§™Â§ö‰∫ÜÈÉΩ‰∏çÁü•ÈÅìÊòØË∞ÅÁöÑ‰∫Ü 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//fft#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int N=(1&lt;&lt;18)+5, INF=1e9;const double PI=acos(-1);inline int read()&#123; char c=getchar();int x=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125; struct meow&#123; double x, y; meow(double a=0, double b=0):x(a), y(b)&#123;&#125;&#125;;meow operator +(meow a, meow b) &#123;return meow(a.x+b.x, a.y+b.y);&#125;meow operator -(meow a, meow b) &#123;return meow(a.x-b.x, a.y-b.y);&#125;meow operator *(meow a, meow b) &#123;return meow(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);&#125;meow conj(meow a) &#123;return meow(a.x, -a.y);&#125;typedef meow cd; struct FastFourierTransform &#123; int n, rev[N]; cd omega[N], omegaInv[N]; void ini(int lim) &#123; n=1; int k=0; while(n&lt;lim) n&lt;&lt;=1, k++; for(int i=0; i&lt;n; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1) | ((i&amp;1)&lt;&lt;(k-1)); for(int k=0; k&lt;n; k++) &#123; omega[k] = cd(cos(2*PI/n*k), sin(2*PI/n*k)); omegaInv[k] = conj(omega[k]); &#125; &#125; void fft(cd *a, cd *w) &#123; for(int i=0; i&lt;n; i++) if(i&lt;rev[i]) swap(a[i], a[rev[i]]); for(int l=2; l&lt;=n; l&lt;&lt;=1) &#123; int m=l&gt;&gt;1; for(cd *p=a; p!=a+n; p+=l) for(int k=0; k&lt;m; k++) &#123; cd t = w[n/l*k] * p[k+m]; p[k+m]=p[k]-t; p[k]=p[k]+t; &#125; &#125; &#125; void dft(cd *a, int flag) &#123; if(flag==1) fft(a, omega); else &#123; fft(a, omegaInv); for(int i=0; i&lt;n; i++) a[i].x/=n; &#125; &#125; void mul(cd *a, cd *b, int m) &#123; ini(m); dft(a, 1); dft(b, 1); for(int i=0; i&lt;n; i++) a[i]=a[i]*b[i]; dft(a, -1); &#125;&#125;f; int n1, n2, m, c[N];cd a[N], b[N];char s1[N], s2[N];int main() &#123; //freopen("in","r",stdin); scanf("%s%s",s1,s2); n1=strlen(s1); n2=strlen(s2); for(int i=0; i&lt;n1; i++) a[i].x = s1[n1-i-1]-'0'; for(int i=0; i&lt;n2; i++) b[i].x = s2[n2-i-1]-'0'; m=n1+n2-1; f.mul(a, b, m); for(int i=0; i&lt;m; i++) c[i]=floor(a[i].x+0.5); for(int i=0; i&lt;m; i++) c[i+1]+=c[i]/10, c[i]%=10; if(c[m]) m++; for(int i=m-1; i&gt;=0; i--) printf("%d",c[i]);&#125; Â¶ÇÊúâÈîôËØØÔºåÊúõÊåáÂá∫„ÄÇ]]></content>
      <categories>
        <category>ACM</category>
        <category>Êï∞ËÆ∫</category>
      </categories>
      <tags>
        <tag>FFT/NTT/FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019ÁâõÂÆ¢ÊöëÊúüÂ§öÊ†°ËÆ≠ÁªÉËê•ÔºàÁ¨¨‰∫åÂú∫ÔºâF MAZE]]></title>
    <url>%2F2019%2F07%2F20%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5(%E7%AC%AC%E4%BA%8C%E5%9C%BA)F%2F</url>
    <content type="text"><![CDATA[2019ÁâõÂÆ¢ÊöëÊúüÂ§öÊ†°ËÆ≠ÁªÉËê•ÔºàÁ¨¨‰∫åÂú∫ÔºâF MAZE‰∏ñÁïå‰∏äÊúâÁßçÁÆóÊ≥ï‰∏çÂè´ÂÅöÁÆóÊ≥ïÔºåÈÇ£Â∞±ÊòØÊö¥Âäõ„ÄÇ„ÄÇ„ÄÇ„ÄÇ C_{2n}^n ÊòØ$4e7$ÔºåÊÄªÁä∂ÊÄÅÊòØ$4e7$ÁßçÔºåÁÑ∂ÂêéËΩ¨Áßª,$O(n)$Áõ¥Êé•ÂêëÁõ∏ÈÇªÁöÑÁä∂ÊÄÅËΩ¨Áßª„ÄÇÊÄªÂ§çÊùÇÂ∫¶$O(C_{2n}^{n} * n)$„ÄÇ1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;(x)&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("dat.in", "r", stdin);#endif // ONLINE_JUDGE&#125;#ifndef ONLINE_JUDGEclock_t start=clock();#endif // ONLINE_JUDGEint n,m;int mp[30][30];LL sum,ans;int ar[15],br[15]; //a b ‰∏™Ë°®Á§∫‰∏Ä‰∏™ÈõÜÂêàint la,lb;void dfs(int num) &#123; //ÈÄân‰Ωç if(la&gt;n||lb&gt;n)return ; if(la==n&amp;&amp;lb==n) &#123; //Â¶ÇÊûúÂêÑÈÄâ‰∫Ü n ‰ΩçÂ∞±Êõ¥Êñ∞Á≠îÊ°à ans=max(sum,ans); return ; &#125; else &#123; if(la&lt;n) &#123; LL tmp=0; for(int i=0; i&lt;lb; i++) &#123; //ÈÄâÂà∞ a ÈõÜÂêà tmp+=mp[num][br[i]]; &#125; sum+=tmp; ar[la++]=num; dfs(num+1); ar[--la]; sum-=tmp; &#125; if(lb&lt;n) &#123; LL tmp=0; for(int i=0; i&lt;la; i++) &#123; //ÈÄâÂà∞ b ÈõÜÂêà tmp+=mp[num][ar[i]]; &#125; sum+=tmp; br[lb++]=num; dfs(num+1); br[lb--]; sum-=tmp; &#125; &#125;&#125;int main() &#123; f(); scanf("%d", &amp;n); m = 2 * n; for(int i = 0; i &lt; m; ++i) &#123; for(int j = 0; j &lt; m; ++j) &#123; scanf("%d", &amp;mp[i][j]); &#125; &#125; dfs(0); printf("%lld\n",ans);#ifndef ONLINE_JUDGE debug((1.0*(clock()-start)/1000));#endif // ONLINE_JUDGE return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>ÊØîËµõ</category>
      </categories>
      <tags>
        <tag>ÁâõÂÆ¢ÊöëÊúüÂ§öÊ†°ËÆ≠ÁªÉËê•</tag>
        <tag>Êö¥Âäõ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019ÁâõÂÆ¢ÊöëÊúüÂ§öÊ†°ËÆ≠ÁªÉËê•(Á¨¨‰∏ÄÂú∫) C Euclidean Distance]]></title>
    <url>%2F2019%2F07%2F19%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%B8%80%E5%9C%BA%EF%BC%89C%2F</url>
    <content type="text"><![CDATA[2019ÁâõÂÆ¢ÊöëÊúüÂ§öÊ†°ËÆ≠ÁªÉËê•ÔºàÁ¨¨‰∏ÄÂú∫ÔºâC Euclidean DistanceÈ¢òËß£: ÊãâÊ†ºÊúóÊó•‰πòÂ≠êÊ≥ïÔºåÈ¶ñÂÖàÂºïÂÖ•ÊãâÊ†ºÊúóÊó•‰πòÂ≠êÂæóÂá∫ÂÖ¨Âºè f(x)=\sum_{i=1}^{n}(p_i-a_i)^2+2*\lambda(\sum_{i=0}^{n}p_i-1)Ëøô‰∏™Â∫îËØ•ÁúãÁöÑÊáÇÔºåÁÑ∂ÂêéÂºïÂÖ•ÂØπÂÅ∂ÂèòÊàêÊàê\max_\lambda f(\lambda)ÂÖ∂‰∏≠ f(\lambda)=\min_{p_i\geq0}\sum_{i=1}^{n}(p_i-a_i)^2+2*\lambda(\sum_{i=0}^{n}p_i-1)ÁÑ∂ÂêéÂåñÊàêÂèâÂßêÁªôÁöÑÈ¢òËß£ÈáåÈù¢ÁöÑÂÖ¨ÂºèÂ∞±Ë°å‰∫Ü f(\lambda)=\min_{p_i\geq0}\sum_{i=1}^{n}(p_i-(a_i-\lambda))^2+\lambda(\sum_{i=0}^{n}(a_i^2-(a_i-\lambda)^2)-2\lambdaÂÜçÁÑ∂ÂêéÔºåÊàëÂ∞±‰∏ç‰ºö‰∫ÜqaqÂêéÊù•Áúã‰∫Ü‰∏Ä‰∏ãÂà´ÁöÑÂ§ß‰Ω¨ÁöÑÂçöÂÆ¢ÔºåÁ™ÅÁÑ∂ÊÑüËßâÂèØ‰ª•Áõ¥Êé•ÁêÜËß£‰∏Ä‰∏ãÔºåÂÅáËÆæÊâÄÊúâÁöÑ$p_i=0$,$f(x)$Â∞±Á≠â‰∫é$a_i^2$ÁöÑÂíå È¢òÁõÆË¶ÅÊ±ÇÁöÑÊòØ Âú® q_i\geq0,\quad \sum_{i=0}^{n}q_i=1Êù°‰ª∂‰∏ãÊ±Ç $f(x)=\sum_{i=1}^{n}(p_i-a_i)^2$ „ÄÇÁõ∏ÂΩì‰∫éÂàÜÈÖç$p_i$ ÁöÑÂÄºÔºåÂéªËÆ© $(p_i-a_i)^2$ ÂèòÂ∞è„ÄÇÊ†πÊçÆ‰∫åÊ¨°ÂáΩÊï∞ÁöÑÊÄßË¥®ÔºåËá™ÂèòÈáè $x$ Ë∂äÂ§ßÂõ†ÂèòÈáè $y$ ÂåñË∂äÂø´„ÄÇÊâÄ‰ª•ÂÖàÂàÜÈÖçÁªôÊúÄÂ§ßËÇØÂÆöÊõ¥‰ºòÂïäÔºåÁõ¥Êé•Ë¥™ÂøÉ‰∏ãÂéªÂïä„ÄÇÊúÄÂêéËÇØÂÆöÊòØÂèòÊàê 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("dat.in", "r", stdin);#endif // ONLIN_JUDGE&#125;LL a[maxn];int n;LL m;int main() &#123; while(~scanf("%d%lld",&amp;n,&amp;m)) &#123; for(int i=1; i&lt;=n; i++) &#123; scanf("%lld",&amp;a[i]); &#125; sort(a+1,a+n+1,greater&lt;int&gt;()); LL r=m; //p[i]ÁöÑÊÄªÂàÜÈÖç‰ª∑ÂÄºÊòØ 1 ‰πüÂ∞±ÊòØ m/m LL pos=1; // pos Ê†áËÆ∞ËÉΩÂ§üÂàÜÈÖçp[i] Âà∞Á¨¨ pos ‰∏™ while(pos&lt;n) &#123; if(r&lt;(a[pos]-a[pos+1])*pos)break; r-=(a[pos]-a[pos+1])*pos; pos++; &#125; // ÊúÄÁªàÂâçpos‰∏™ÁöÑÂÄº ÈÉΩ‰ºöÊòØa[pos]-r/pos,Â∞Ü‰ªñÊâ©Â§ßpos ÂÄç, ÁÑ∂ÂêéÂÜç‰πò‰ª• pos ‰∏™ LL ans=(a[pos]*pos-r)*(a[pos]*pos-r)*pos; //Âõ†‰∏∫ÊúÄÂêéÁöÑÂÄºÂèØËÉΩÊòØ 1/pos,ÊâÄ‰ª•ÊääÂàÜÂ≠êÂàÜÊØçÂêåÊó∂‰πò‰ª•pos‰∏™ LL b=m*m*pos*pos; // Âõ†‰∏∫Ê±ÇÁöÑÊòØË∑ùÁ¶ªÁöÑÂπ≥Êñπ ÂàÜÊØç Â∞±ÊòØ m*m*pos*pos for(int i=pos+1; i&lt;=n; i++) &#123; //ÂàÜÈÖç‰∏çÂà∞ÁöÑ a[i]ÔºåÁõ¥Êé•Âä†‰∏ä ans+=a[i]*a[i]*pos*pos; &#125; LL g=__gcd(ans,b); if(ans%b==0)printf("%lld\n",ans/b); else printf("%lld/%lld\n",ans/g,b/g); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>ÊØîËµõ</category>
      </categories>
      <tags>
        <tag>ÁâõÂÆ¢ÊöëÊúüÂ§öÊ†°ËÆ≠ÁªÉËê•</tag>
        <tag>ÊãâÊ†ºÊúóÊó•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexoNext‰∏ªÈ¢òÊèíÂÖ•Êï∞Â≠¶ÂÖ¨Âºè]]></title>
    <url>%2F2019%2F07%2F17%2FhexoNext%E4%B8%BB%E9%A2%98%E6%8F%92%E5%85%A5%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[ÂºÄÂêØmathjaxÂÖàÊääËøô‰∏™ÊâìÂºÄÔºåÁÑ∂ÂêéÁúãÂà∞mathjax‰∏äÈù¢Ëøô‰∏ÄË°å‰∫ÜÊ≤°ÊúâÔºåË¶ÅÁî®hexo-rendering-pandoc ÊàñËÄÖhexo-renderer-kramedËøô‰∏™Ê∏≤ÊüìÔºåÁ¨¨‰∏Ä‰∏™ÊàëËØïÁöÑÊó∂ÂÄôÂèëÁé∞Âíåhexo-renderer-markedËøô‰∏™ËØ≠Ê≥ïÊúâÁÇπÂá∫ÂÖ• (hexoÈªòËÆ§‰ΩøÁî® hexo-renderer-marked Ê∏≤Êüì) ÔºåÂ¶ÇÊûúÊç¢‰∫ÜÂâçÈù¢ÂÜôÊâÄÊúâmdÊñá‰ª∂ÁöÑÂÖ®ÈÉΩË¶ÅÊîπËØ≠Ê≥ïÔºåÊâÄ‰ª•ÊàëÂ∞±Áî®‰∫ÜÁ¨¨‰∫å‰∏™,ÂÖàÊäähexo-renderer-markedÁöÑÂç∏‰∫ÜÔºåÂÜçË£Öhexo-renderer-kramed„ÄÇ12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save Áî®Êï∞Â≠¶ÂÖ¨ÂºèÁöÑÊó∂ÂÄôËÆ∞ÂæóÊâìÂºÄ ÊµãËØï‰ª£Á†ÅÂ¶Ç‰∏ã12345678$$P = \frac&#123;\sum_&#123;i=1&#125;^n (x_i- x)(y_i- y)&#125;&#123;\displaystyle \left[\sum_&#123;i=1&#125;^n (x_i-x)^2\sum_&#123;i=1&#125;^n (y_i-y)^2\right]^&#123;1/2&#125; &#125;$$ ÊïàÊûúÂ¶Ç‰∏ã: P = \frac {\sum_{i=1}^n (x_i- x)(y_i- y)} {\displaystyle \left[ \sum_{i=1}^n (x_i-x)^2 \sum_{i=1}^n (y_i-y)^2 \right]^{1/2} } HexoEditor Â±ïÁ§∫Êï∞Â≠¶ÂÖ¨ÂºèÂ¶ÇÊûú‰Ω†Áî®Ëøô‰∏™ÁºñËæëÂô®ÔºåÊÉ≥ÂÆûÊó∂Â±ïÁ§∫Ëøô‰∏™ÊïàÊûúÂ∞±ÊâìÂºÄTeXÊï∞Â≠¶Ë°®ËææÂºè„ÄÇÊïàÊûúÂ¶Ç‰∏ãÔºö]]></content>
      <categories>
        <category>ÈÖçÁΩÆ</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HexoNextÊ∑ªÂä†ÁΩëÊòì‰∫ëÈü≥‰πê]]></title>
    <url>%2F2019%2F07%2F17%2FHexoNext%E6%B7%BB%E5%8A%A0%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%2F</url>
    <content type="text"><![CDATA[Ê∑ªÂä†ÁΩëÊòì‰∫ëÈü≥‰πêÁîüÊàêÂ§ñÈìæ ‰øÆÊîπÊ®°ÊùøÊñá‰ª∂Â∞±ÊòØËøô‰∏™themes\next\layout\_macro\sidebar.swigËá™Â∑±Êâæ‰∏™‰ΩçÁΩÆÂ§çÂà∂Á≤òË¥¥ËøõÂéªÊàëÊòØÊîæÂú®ÈÇ£‰∏™ÊúÄ‰∏ãÈù¢]]></content>
      <categories>
        <category>ÈÖçÁΩÆ</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HexoNextÊ∑ªÂä†gitmentËØÑËÆ∫]]></title>
    <url>%2F2019%2F07%2F17%2FHexoNext%E6%B7%BB%E5%8A%A0gitment%E8%AF%84%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[Ê∑ªÂä†gitmentËØÑËÆ∫Âå∫ÂÆâË£Ögitment1npm install gitment --save #ÂÆâË£Ögitment ÂàõÂª∫Â∫îÁî®ÂÜçÂàõÂª∫‰∏Ä‰∏™ OAuth application1234Application name:Èöè‰æøÂÜôHomepage URL:Ëøô‰∏™‰πüÂèØ‰ª•ÈöèÊÑèÂÜô,Â∞±ÂÜô‰Ω†ÁöÑÂçöÂÆ¢Âú∞ÂùÄÂ∞±Ë°åApplication description:ÊèèËø∞,‰πüÂèØ‰ª•ÈöèÊÑèÂÜôAuthorization callback URL:Ëøô‰∏™ÂøÖÈ°ªÂÜô‰Ω†ÁöÑÂçöÂÆ¢Âú∞ÂùÄ Áî≥ËØ∑Â•Ω‰πãÂêéÁÇπÊ≥®ÂÜå,ÁÑ∂ÂêéÂ∞±ÂèØ‰ª•ÁúãÂà∞‰∏§‰∏™‰∏úË•øClientIDÂíåClient Secret,ÂêéÈù¢‰ºöÁî®Âà∞. ÂàõÂª∫ÂÆåÂêéËøô‰∏™Á≠â‰ºöË¶ÅÁî®‰∏ä ÈÖçÁΩÆ123456789101112131415# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/gitment: enable: true mint: false # Â¶ÇÊûúË¶Å‰øÆÊîπgitment.swigÂú∞ÂùÄÂ∞±ÊîπÊàêfalse RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide &apos;Powered by ...&apos; on footer, and more language: # Force language, or auto switch by theme github_user: &#123;you github user id&#125; github_repo: Èöè‰æøÂÜô‰∏Ä‰∏™‰Ω†ÁöÑÂÖ¨ÂºÄÁöÑgit‰ªìÂ∫ìÂ∞±Ë°å,Âà∞Êó∂ÂÄôËØÑËÆ∫‰ºö‰Ωú‰∏∫ÈÇ£‰∏™È°πÁõÆÁöÑissue client_id: &#123;ÂàöÊâçÁî≥ËØ∑ÁöÑClientID&#125; client_secret: &#123;ÂàöÊâçÁî≥ËØ∑ÁöÑClient Secret&#125; proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled ÁÑ∂ÂêéÂú® ‰∏ªÈ¢òÈÖçÁΩÆÊñá‰ª∂next config.yml‰∏≠ÂºÄÂêØgitmentÂõ†‰∏∫Êüê‰∏™ÊúçÂä°Âô®ÊåÇ‰∫ÜÔºåÊâÄ‰ª•mintË¶Å‰∏∫falseÊâç‰ºöÊâßË°å‰Ω†ÊâÄ‰øÆÊîπÁöÑ„ÄÇ ÈîôËØØÔºö object ProgressEventc ÈîôËØØÂ∞±ÊòØ‰∏äÈù¢Ëøô‰∏™ÂéüÂõ†ÔºåÊäämintÊîπÊàêÊ≥ïfalseÂç≥ÂèØ„ÄÇ ÊâæÂà∞themes/next/layout/_third-party/comments/gitment.swigÊñá‰ª∂‰øÆÊîπÂÖ∂‰∏≠ÁöÑcss Âíåjs ,Ê≥®ÈáäÊéâÁöÑÊòØ‰∏ÄÂºÄÂßãÈªòËÆ§ÁöÑÔºåÁé∞Âú®ÊîπÊàê‰∏ãÊñπÊ≤°ÊúâÊ≥®ÈáäÁöÑ„ÄÇ (ÂêéÈù¢Ëøô‰∏™ÊòØÊ±âÂåñÁöÑ)123456789101112&lt;!-- LOCAL: You can save these files to your site and update links --&gt;&#123;% if theme.gitment.mint %&#125; &#123;% set CommentsClass = 'Gitmint' %&#125; &lt;script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitmint.browser.js"&gt;&lt;/script&gt;&#123;% else %&#125; &#123;% set CommentsClass = 'Gitment' %&#125; &lt;!-- &lt;script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js"&gt;&lt;/script&gt; --&gt;&lt;script src="https://billts.site/js/gitment.js"&gt;&lt;/script&gt;&#123;% endif %&#125;&lt;!-- &lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css"/&gt; --&gt;&lt;link rel="stylesheet" href="https://billts.site/extra_css/gitment.css"&gt;&lt;!-- END LOCAL --&gt; ÈúÄË¶ÅÊ≥®ÊÑèÁöÑÊòØÁ°Æ‰øùthemes/next/_config.yml‰∏≠theme.gitment.mintËÆæÁΩÆ‰∏∫false,Êâç‰ºöËµ∞Âà∞Êàë‰ª¨ÊîπÂä®ÁöÑÂàÜÊîØ. ËøòÊúâ‰øÆÊîπ‰∏Ä‰∏ãgitmentÊ®°ÊùøÔºåÂè™ÈúÄË¶Å‰øÆÊîπidËøòÊòØÂú®‰∏äÈù¢ÈÇ£‰∏™Êñá‰ª∂, ÔºàÊàë‰πü‰∏çÁü•ÈÅì‰∏∫Âï•Ë¶ÅÊîπÔºåÂ§ß‰Ω¨Èó®ËØ¥Ë¶ÅÊîπÔºåÂÆûÈôÖ‰∏äÊàëÊ≤°Êîπ‰πüÊ≤°Âá∫Áé∞Âï•ÈîôËØØ1234var gitment = new &#123;&#123;CommentsClass&#125;&#125;(&#123; id: &apos;&#123;&#123; page.date &#125;&#125;&apos;, owner: &apos;&#123;&#123; theme.gitment.github_user &#125;&#125;&apos;, repo: &apos;&#123;&#123; theme.gitment.github_repo &#125;&#125;&apos;,]]></content>
      <categories>
        <category>ÈÖçÁΩÆ</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018CCPCÂêâÊûóÂú∫ÈáçÁé∞Ëµõ]]></title>
    <url>%2F2019%2F07%2F16%2F2018CCPC%E5%90%89%E6%9E%97%E5%9C%BA%E9%87%8D%E7%8E%B0%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[2018CCPCÂêâÊûóËµõÂå∫ÔºàÈáçÁé∞ËµõÔºâ‰º†ÈÄÅÈó® A BËøô‰∏§È¢òÂ¶ÇÊûú‰∏ç‰ºöÂÜôÔºåËøòÊòØÂ§öÂéªÂà∑Âà∑Âü∫Á°ÄÈ¢òÔºå‰πüÊ≤°Âá†‰∏™‰∫∫‰∏∫‰∫ÜËøô‰∏§È¢òÊù•Âêß„ÄÇ C JusticeÈ¢òÊÑèÔºö Áªô‰Ω†NÂ†ÜÁü≥Â≠ê ÔºåÊØèÂ†ÜÁü≥Â≠êÈáçÈáèÊòØ1/(2^ki)ÁöÑÈáçÈáèÔºåÁÑ∂ÂêéÈóÆËÉΩ‰∏çËÉΩÊääÁü≥Â≠êÂàÜÊàêÂ§ß‰∫éÁ≠â‰∫é1/2ÈáçÈáèÁöÑ‰∏§Â†ÜÁü≥Â≠ê„ÄÇÈ¢òËß£Ôºö ‰ªéÂ§ßÂà∞Â∞èÊØèÊ¨°ÂêàÂπ∂‰∏§Â†Ü‰∏ÄÊ†∑ÁöÑÔºåÂ¶ÇÊûúÂè™Ââ©‰∏Ä‰∏™Â∞±Áõ¥Êé•‰∏¢ÊéâÔºåÂõ†‰∏∫Êó†ËÆ∫Â¶Ç‰ΩïËøô‰∏™ÈÉΩÊ≤°Ê≥ïÂêàÂπ∂ÊàêÊõ¥Â§ßÁöÑ‰∏ÄÂ±ÇÁöÑ„ÄÇ‰∏ÄÁõ¥ËøôÊ†∑ÂêàÂπ∂‰∏ãÂéªÂ¶ÇÊûúËÉΩÂàÜÊàê‰∏§Â†Ü‰∏ÄÊ†∑ÁöÑÂêÑÂ§ß‰∫é1/2ÔºåÈÇ£‰πàÊúÄÁªàÂêàÂπ∂ÁöÑÂíå‰∏ÄÂÆöËÉΩÂêàÊàê‰∏Ä‰∏™ 0‰æãÂ≠ê:1 3 3 4 4 5 2ÂÖàÊåâÂ§ßÂ∞èÊéíÂ∫è5 4 4 3 3 2 15Ê≤°Ê≥ïÂêàÂπ∂ÔºåÁõ¥Êé•‰∏¢ÊéâÔºåÂêàÂπ∂‰∏§‰∏™4Ëé∑Âæó‰∏Ä‰∏™33 3 3 2 1ÂêàÂπ∂‰∏§‰∏™3ÊàñÂæó‰∏Ä‰∏™2 ÔºåÂ§öÂá∫Êù•ÁöÑ‰∏Ä‰∏™3Ê≤°Ê≥ïÂêàÊàê2Áõ¥Êé•‰∏¢Êéâ„ÄÇ2 2 1ÂêàÂπ∂‰∏§‰∏™2ÂÜçÂêàÂπ∂‰∏§‰∏™1ÊúÄÁªàËé∑Âæó0.ËÉΩÂ§üËé∑Âæó0ËØ¥ÊòéËÉΩÂàÜÊàê‰∏§Â†Ü‰∏ÄÊ†∑ÁöÑ1/2‰∏ÄÂºÄÂßãÊ≤°ÁúãÂà∞Ë¶ÅËÆ∞ÂΩïÁä∂ÊÄÅÔºåÂêéÊù•Ë°•Êïë‰∫Ü‰∏Ä‰∏ãÔºåÂêàÂπ∂ÁöÑÊó∂ÂÄôÂä†‰∏Ä‰∏™Âπ∂Êü•ÈõÜÂ∞±Ë°å‰∫ÜÔºå‰∏çÂΩ±ÂìçÂ§çÊùÇÂ∫¶„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const long long mod = 1e9 + 7;const int maxn = 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;clock_t prostart;void f() &#123;#ifndef ONLINE_JUDGE prostart = clock(); freopen("../data.in", "r", stdin);#endif return;&#125;vector&lt;P&gt; v;int par[maxn];int find(int x) &#123; return x == par[x] ? x : par[x] = find(par[x]);&#125;priority_queue&lt;P, vector&lt;P&gt;, less&lt;P&gt; &gt; q;int main() &#123; f(); int T; int cas = 1; scanf("%d", &amp;T); while (T--) &#123; int n; scanf("%d", &amp;n); v.clear(); for (int i = 0; i &lt;= n; i++)par[i] = i; for (int i = 0; i &lt; n; i++) &#123; int a; scanf("%d", &amp;a); if (a &lt; n + 1) &#123; v.emplace_back(P(a, i + 1)); &#125; &#125; sort(v.begin(), v.end()); int flag = 0, ans = -1; for (int i = (int) v.size() - 1; i &gt;= 0; i--) &#123; while (q.size() &amp;&amp; v[i].first &lt; q.top().first)q.pop(); if (q.empty()) &#123; q.push(P(v[i].first, v[i].second)); if (v[i].first == 1)ans = v[i].second; &#125; else &#123; int l = v[i].first, y = v[i].second; while (q.size() &amp;&amp; q.top().first == l) &#123; if (l - 1 &gt;= 1) &#123; int x = find(q.top().second); par[x] = y; if (l - 1 == 1)ans = y; &#125; q.pop(); l = l - 1; &#125; if (l &lt;= 0)flag = y; q.push(P(l, y)); &#125; &#125; while (q.size()) &#123; int l = q.top().first, y = q.top().second; if (l == 1)ans = y; q.pop(); while (q.size() &amp;&amp; q.top().first == l) &#123; if (l - 1 &gt;= 1) &#123; int x = find(q.top().second); par[x] = y; if (l - 1 == 1)ans = y; &#125; q.pop(); l = l - 1;// if (l == 1)ans = y; &#125; if (l &lt;= 0)flag = 1; &#125; printf("Case %d: %s\n", cas++, flag ? "YES" : "NO"); if (flag) &#123;// debug(find(2)); for (int i = 1; i &lt;= n; i++) &#123; if (find(i) == ans)printf("1"); else printf("0"); &#125; puts(""); &#125; &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "ËøêË°åÊó∂Èó¥:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125; D The MoonÈ¢òÊÑèÔºö pÁöÑÊ¶ÇÁéáËµ¢ÔºåÂàùÂßãËé∑ÂæóÂåÖÊ¶ÇÁéáq‰∏∫ 2% ÊØèÊ¨°ËøõË°å‰∏ÄÊ¨°Ê∏∏ÊàèÔºåÂ¶ÇÊûúËµ¢‰∫ÜqÁöÑÊ¶ÇÁéáËé∑ÂæóÂåÖÔºåÂ¶ÇÊûúÊ≤°Ëé∑ÂæóÊ¶ÇÁéáqÂèòÊàêmin(100%Ôºåp),Â¶ÇÊûúËæì‰∫ÜqÂèòÊàêmin(100%Ôºåp),ËæìÂÖ•pÈóÆÊúüÊúõËÆ∫Êï∞ÊòØÂ§öÂ∞ë.È¢òËß£: pÊòØ‰∏Ä‰∏™Êï¥Êï∞ÔºåÊÄªÂÖ±Âè™Êúâ100‰∏™ÂÄºÔºåqÊúÄÂ§öÂè™‰ºöÂá∫Áé∞0.5%ÔºåÁúãÂà∞Ëøô‰∫õÊàëÊúâ‰∏Ä‰∏™Â§ßËÉÜÁöÑÊÉ≥Ê≥ï„ÄÇÊúüÊúõÁ≠â‰∫é ËΩÆÊï∞*Ê¶ÇÁéáÊâÄ‰ª•ÊàëÊö¥ÂäõÊûö‰∏æ1e6ËΩÆÔºåÁî®dp[i]Ë°®Á§∫q=i/2%ÁöÑÊ¶ÇÁéáÔºåÁÑ∂ÂêéÁõ¥Êé•Êää1e6ËΩÆÁöÑÂÄºÂä†Ëµ∑Êù•ÔºåÂõ†‰∏∫Âà∞ÂêéÈù¢Ê¶ÇÁéáÁªùÂØπË∂äÊù•Ë∂äÂ∞è1e6ËΩÆËØØÂ∑ÆÂ∑≤ÁªèÂæàÂ∞èÔºåÁÑ∂ÂêéÊö¥ÂäõÊûö‰∏æpÁöÑ1-100,ÊääÁ≠îÊ°àÊâìÂç∞‰∏ãÊù•„ÄÇ„ÄÇ„ÄÇ„ÄÇÁÑ∂Âêé‰Ω†ÊáÇÁöÑ(Ê≥®ÈáäÊéâÁöÑÊòØÊö¥ÂäõË∑ëÁöÑ‰ª£Á†Å)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const long long mod = 1e9 + 7;const int maxn = 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;clock_t prostart;void f() &#123;#ifndef ONLINE_JUDGE prostart = clock(); freopen("../data.in", "r", stdin);#endif return;&#125;bool cmp(double o1, double o2) &#123; return abs(o1 - o2) &lt; eps;&#125;struct point3 &#123; double x, y, z;&#125; s, t;double dp[maxn];double a[1000] = &#123;130.7530454000, 79.2053644503, 61.1640496589, 51.6033688156, 45.5020175987, 41.1756105103, 37.8950632978, 35.2908241865, 33.1540346125, 31.3568193706, 29.8159317728, 28.4744883082, 27.2920701057, 26.2390206161, 25.2929905666, 24.4367537696, 23.6567754479, 22.9422440770, 22.2843986720, 21.6760501176, 21.1112333591, 20.5849499398, 20.0929742362, 19.6317054554, 19.1980530697, 18.7893470611, 18.4032668302, 18.0377843270, 17.6911181415, 17.3616961332, 17.0481247749, 16.7491638265, 16.4637052733, 16.1907557033, 15.9294214771, 15.6788961816, 15.4384499618, 15.2074204071, 14.9852047313, 14.7712530335, 14.5650624685, 14.3661721843, 14.1741589106, 13.9886331012, 13.8092355497, 13.6356344123, 13.4675225797, 13.3046153516, 13.1466483734, 12.9933758002, 12.8445686601, 12.7000133904, 12.5595105271, 12.4228735274, 12.2899277111, 12.1605093052, 12.0344645825, 11.9116490803, 11.7919268935, 11.6751700320, 11.5612578361, 11.4500764445, 11.3415183077, 11.2354817448, 11.1318705365, 11.0305935527, 10.9315644109, 10.8347011617, 10.7399260000, 10.6471649983, 10.5563478614, 10.4674076992, 10.3802808172, 10.2949065219, 10.2112269412, 10.1291868575, 10.0487335524, 9.9698166630, 9.8923880479, 9.8164016621, 9.7418134409, 9.6685811914, 9.5966644912, 9.5260245936, 9.4566243391, 9.3884280725, 9.3214015652, 9.2555119427, 9.1907276158, 9.1270182166, 9.0643545388, 9.0027084802, 8.9420529899, 8.8823620181, 8.8236104686, 8.7657741544, 8.7088297556, 8.6527547795, 8.5975275235, 8.5431270393&#125;;int main() &#123;// f(); int T; int cas = 1;// T=100; scanf("%d", &amp;T); // int t=1; while (T--) &#123; int p;// p = t++; scanf("%d", &amp;p); printf("Case %d: %.10f\n", cas++, a[p - 1]);// p = p / 100;// double ans = 0;// memset(dp, 0, sizeof(dp + 300));// dp[4] = 1;// for (int i = 1; i &lt; maxn; i++) &#123;// for (int j = 200; j &gt;= 0; j--) &#123;//// debug(dp[j]);// if (dp[j] == 0)continue;// ans += i * dp[j] * j / 200.0 * p;// double t = dp[j];// dp[j] = 0;// dp[min(j + 4, 200)] += p * t * (1 - j / 200.0);// dp[min(200, j + 3)] += (1 - p) * t;// &#125;// &#125;// printf("%.10f\n", ans);// a[t - 1] = ans; &#125;// for (int i = 1; i &lt;= 100; i++)printf("%.10f\n", a[i]);#ifndef ONLINE_JUDGE cout &lt;&lt; "ËøêË°åÊó∂Èó¥:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125; E The TowerÈ¢òÊÑèÔºö Áªô‰∏Ä‰∏™ÂúÜÈî•ÁöÑr,h Âíå‰∏Ä‰∏™ÁÇπ(x,y,z)ÔºåÁÇπÁöÑÁßªÂä®ÈÄüÂ∫¶(vx,vy,vz)ÈóÆËøô‰∏™ÁÇπ‰ªÄ‰πàÊó∂ÂÄôÊíû‰∏äÂéªÔºå‰øùËØÅÁõ¥Êé•‰ªéÂ§ñÈù¢Êíû‰∏äÂéª„ÄÇÈ¢òËß£Ôºö Á∫øÁöÑÊñπÁ®ã:x=x0+vx*ty=y0+vy*tz=z0+vz*tÂúÜÈî•ÊñπÁ®ã: x^2 + y^2 = (h-z)^2 * r^2 / h^2Ëß£ÊñπÁ®ãÈ´ò‰∏≠Áü•ËØÜ1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const long long mod = 1e9 + 7;const int maxn = 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif return;&#125;bool cmp(double o1, double o2) &#123; return abs(o1 - o2) &lt; eps;&#125;struct point3 &#123; double x, y, z;&#125; s, t;int main() &#123; f(); int T; double r, h; int cas = 0; scanf("%d", &amp;T); while (T--) &#123; scanf("%lf%lf%lf%lf%lf%lf%lf%lf", &amp;r, &amp;h, &amp;s.x, &amp;s.y, &amp;s.z, &amp;t.x, &amp;t.y, &amp;t.z); double tx, ty, tz; tx = t.x; ty = t.y; tz = t.z; double a, b, c; a = (tx * tx + ty * ty - tz * tz * r * r / h / h); b = 2 * (tx * s.x + ty * s.y + tz * (h - s.z) * r * r / h / h); c = s.x * s.x + s.y * s.y - (h - s.z) * (h - s.z) * r * r / h / h; double high = max((h - s.z) / tz, -s.z / tz), low = min((h - s.z) / tz, -s.z / tz); double a1 = (-b + sqrt(b * b - 4 * a * c)) / 2 / a, a2 = (-b - sqrt(b * b - 4 * a * c)) / 2 / a, ans; ans = inf; if (a1 &gt;= low &amp;&amp; a1 &lt;= high)ans = min(a1, ans); if (a2 &gt;= low &amp;&amp; a2 &lt;= high)ans = min(a2, ans); else ans = a2; cout &lt;&lt; "Case " &lt;&lt; ++cas &lt;&lt; ": " &lt;&lt; fixed &lt;&lt; setprecision(10) &lt;&lt; ans &lt;&lt; "\n"; &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125; F The HermitÈ¢òÊÑè: Â§™Èïø‰∫ÜËá™Â∑±ËØªÂêß.È¢òËß£: ËØªÈ¢òËØªÊáÇ‰∫ÜÂèØ‰ª•ÂèëÁé∞‰∏Ä‰∏™ÊúâË∂£ÁöÑ‰∫ãÔºåÊØè‰∏™iÂØπÂ∫îÁöÑkÈÉΩÊòØËøûÁª≠ÁöÑÂá†‰∏™„ÄÇ‰∏∫‰ªÄ‰πà‰ºöËøôÊ†∑Âë¢Ôºü‰ªîÁªÜÂàÜÊûêÊØè‰∏™Á´ôÁÇπÁöÑÂå∫ÂüüÂèëÁé∞ÔºåÂêéÈù¢ÁöÑÁªìÊùü‰∏ÄÂÆöÊØîÂâçÈù¢ÁöÑÊôöÔºåÂâçÈù¢ÁöÑÂºÄÂßãÁöÑ‰∏ÄÂÆöÊØîÂêéÈù¢ÊôöÔºåÊâÄ‰ª•ÂØºËá¥‰∫ÜkÊòØËøûÁª≠ÁöÑÔºåÊûö‰∏æiÁî®set‰øùÂ≠òË¶ÜÁõñÂà∞iÁöÑj Áî®setÁöÑ‰∫åÂàÜÊâæÂà∞‰∏Ä‰∏™‰∏éiÊúâkÁöÑËµ∑Âßã‰ΩçÁΩÆÔºåÂà∞setÊúÄÂêé‰∏Ä‰∏™jÁöÑÊúÄÂêé‰∏Ä‰∏™kÁöÑ‰ΩçÁΩÆÔºåËøô‰∏§‰∏™‰ΩçÁΩÆ‰πãÈó¥ÁöÑÁ´ôÁÇπÈÉΩÊòØiÁöÑkÔºåÁÑ∂ÂêéÂºÇÊàñÂ∞±Ë°å‰∫Ü„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;int n;set&lt;P&gt; s;int main() &#123; f(); int T, cas = 1; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int a; scanf("%d", &amp;a); int last = a + i - 1; if (s.size()) &#123; set&lt;P&gt;::iterator ite = s.lower_bound(P(i - (a - 1) / 2, 0)); if (ite != s.end()) &#123; int stat = max(i - a + 1, 2 * ite-&gt;first - ite-&gt;second); int end = 2 * (--s.end())-&gt;first - i; ans ^= end - stat + 1; &#125; &#125; s.insert(P(i, last)); while (s.size() &amp;&amp; s.begin()-&gt;second &lt;= i) &#123; s.erase(s.begin()); &#125; &#125; s.clear(); printf("Case %d: %d\n", cas++, ans); &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "ËøêË°åÊó∂Èó¥:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125; H LoversÈ¢òÊÑèÔºö n ‰∏™Â≠óÁ¨¶‰∏≤Ôºåm‰∏™Êìç‰ΩúÔºåwrapÊìç‰ΩúÂú®Âå∫Èó¥[l,r]ÁöÑÂ≠óÁ¨¶‰∏≤ÂâçÂêéÂêÑÂä†‰∏Ä‰∏™Êï∞Â≠ó,Â¶Ç3Âä†ÂÖ•2112ÂèòÊàê321123Ôºå‰∏ÄÂºÄÂßãÊòØ‰∏™Á©∫Â≠óÁ¨¶‰∏≤ÔºåÂÄº‰∏∫0„ÄÇquery Êü•ËØ¢[l,r]‰πãÈó¥ÊâÄÊúâÂ≠óÁ¨¶‰∏≤ÁöÑÂÄºÁöÑÂíåÊ®°1e9+7„ÄÇÈ¢òËß£Ôºö ÊääÂ≠óÁ¨¶‰∏≤ÂàÜÊàê‰∏âÊÆµ ÂâçÁºÄ+ÂéüÊú¨ÁöÑÂÄº+ÂêéÁºÄÔºåÂâçÁºÄÂíåÂêéÁºÄÂ∞±ÊòØ‰∏Ä‰∏™Áõ∏ÂèçÁöÑÔºåÊàëÁõ¥Êé•Êää‰ªñÂ§ÑÁêÜÊàêÊï∞Â≠óÔºåÁÑ∂ÂêéËÆ∞ÂΩïÈïøÂ∫¶ÔºåÂéüÊú¨ÁöÑÂÄº‰πüÊòØ‰∏ÄÊ†∑Ôºå‰øùÂ≠òÂÄºÂíåÈïøÂ∫¶„ÄÇÁÑ∂ÂêéÁ∫øÊÆµÊ†ëÈöè‰æøÊêûÔºålazyÊï∞ÁªÑ‰øùÂ≠òÂ≠óÁ¨¶‰∏≤Âä†Âú®ÂâçÈù¢ÁöÑË¥°ÁåÆÔºålazy2 ÂêéÁºÄË¥°ÁåÆ,datÂå∫Èó¥ÂÜÖÊ∑ªÂä†‰∏Ä‰∏™Êï∞ÂΩ±ÂìçÁöÑÊÄªË¥°ÁåÆÔºåvalÂå∫Èó¥Âíå.ÊØèÊ¨°Êõ¥Êñ∞ÂÄºÔºöval[k] =lazy[k]*dat[k] + val[k] * lenth(lazy[k]) + lazy2[k]dat[k] = dat[k] * lenth(lazy[k]) ÂÖ∑‰ΩìËßÅ‰ª£Á†Åadd() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;LL dat[maxn &lt;&lt; 2], lazy[maxn &lt;&lt; 2], val[maxn &lt;&lt; 2], lazy2[maxn &lt;&lt; 2];LL p10[maxn];int len[maxn &lt;&lt; 2];void up(int l, int r, int k) &#123; val[k] = (val[chl] + val[chr]) % mod; dat[k] = (dat[chl] + dat[chr]) % mod; len[k] = 0; lazy2[k] = lazy[k] = 0;&#125;void build(int l, int r, int k) &#123; if (r == l) &#123; dat[k] = 1; lazy2[k] = lazy[k] = 0; len[k] = 0; val[k] = 0; &#125; else &#123; build(lson); build(rson); up(l, r, k); &#125;&#125;LL re(LL x) &#123; LL res = 0; while (x &gt; 0) &#123; res = res * 10 + x % 10 % mod; x /= 10; &#125; return res;&#125;void add(int l, int r, int k, LL x, LL y, int lenx) &#123; if (r == l) &#123; lazy2[k] = lazy[k] = 0; val[k] = (1LL * y % mod + val[k] * p10[lenx] % mod + dat[k] * p10[lenx] % mod * x % mod) % mod; dat[k] = dat[k] * p10[2 * lenx] % mod; return; &#125; lazy[k] = (lazy[k] + x * p10[len[k]] % mod) % mod; lazy2[k] = (lazy2[k] * p10[lenx] % mod + y) % mod; len[k] += lenx; val[k] = (1LL * y * (r - l + 1) % mod + val[k] * p10[lenx] % mod + dat[k] * p10[lenx] % mod * x % mod) % mod; dat[k] = dat[k] * p10[2 * lenx] % mod;&#125;void pushdown(int l, int r, int k) &#123; if (len[k] == 0) &#123; return; &#125; else &#123; add(lson, lazy[k], lazy2[k], len[k]); add(rson, lazy[k], lazy2[k], len[k]); up(l, r, k); &#125;&#125;int t;int n, m;void update(int a, int b, int l, int r, int k, int x) &#123; pushdown(l, r, k); if (r &lt; a || l &gt; b)return; else if (a &lt;= l &amp;&amp; r &lt;= b) &#123; add(l, r, k, x, x, 1LL); &#125; else &#123; update(a, b, lson, x); update(a, b, rson, x); up(l, r, k); &#125;&#125;LL querry(int a, int b, int l, int r, int k) &#123; pushdown(l, r, k); if (r &lt; a || l &gt; b)return 0; else if (a &lt;= l &amp;&amp; r &lt;= b) &#123;// debug(val[k]); return val[k]; &#125; else &#123; return (querry(a, b, lson) + querry(a, b, rson)) % mod; &#125;&#125;int main() &#123; f(); p10[0] = 1; for (int i = 1; i &lt;= 400000; i++) &#123; p10[i] = p10[i - 1] * 10 % mod; &#125; int cas = 1; scanf("%d", &amp;t); while (t--) &#123; scanf("%d%d", &amp;n, &amp;m); build(1, n, 0); printf("Case %d:\n", cas++); while (m--) &#123; char s[10]; int l, r; scanf("%s%d%d", s, &amp;l, &amp;r); if (s[0] == 'q') &#123; LL ans = querry(l, r, 1, n, 0); printf("%lld\n", ans % mod); &#125; else &#123; int x; scanf("%d", &amp;x); update(l, r, 1, n, 0, x);// for (int i = 1; i &lt;= n; i++) &#123;// printf("%lld ", querry(i, i, 1, n, 0));// &#125;// puts(""); &#125; &#125; &#125; return 0;&#125; I StrengthÈ¢òÊÑè: Ê∏∏ÊàèÁéãÔºåÊàëÊúân‰∏™ÊÄ™ ÂÖ®ÈÉΩÊòØÊàòÊñóË°®Á§∫ ,ÂØπÈù¢Êúâm‰∏™ÊÄ™Ôºå0Ë°®Á§∫ÊàòÊñóË°®Á§∫Ôºå1Èò≤ÂÆàË°®Á§∫,ÈóÆÊàëÁ¨¨‰∏ÄÂõûÂêàËÉΩÈÄ†ÊàêÂ§öÂ∞ëÁÇπ‰º§ÂÆ≥„ÄÇÈ¢òËß£: ‰∏Ä‰∏™Ê∞¥È¢òÔºåÂÖ∂ÂÆûÂíåA BÈöæÂ∫¶Â∑ÆË∑ù‰∏çÂ§ß„ÄÇÊûö‰∏æ‰∏§ÁßçÊÉÖÂÜµÔºå‰∏ÄÁßçÊòØËÉΩÊääÂØπÈù¢ÊÄ™ÂÖ®ÈÉ®Á†ç‰∫ÜÔºå‰∏ÄÁßçÊòØ‰∏çËÉΩ„ÄÇ‰∏çËÉΩÂÖ®Á†çÊ≠ªÔºåÁõ¥Êé•Áî®ÊúÄÂ§ßÁöÑÁ†çÂØπÈù¢ÊîªÂáªË°®Á§∫ÊúÄÂ∞èÁöÑÔºåÁ†ç‰∏çËøáÂ∞±ÁÆó‰∫Ü‰∏çÊâì‰∫Ü„ÄÇËÉΩÂÖ®Á†çÊ≠ªÔºåÊú¨Êù•ËøôËøòÊúâ‰∏§ÁßçÊÉÖÂÜµÔºåÂ∞±ÁÆóÊàëËÉΩÂÖ®Á†çÊ≠ªÂØπÈù¢ÁöÑÊÄ™Ôºå‰ΩÜÊòØÊàëÂÖ®Á†çÊ≠ªÔºåÂíåÁ¨¨‰∏ÄÁßçÊÉÖÂÜµ‰∏ÄÊ†∑ÔºåÁõ¥Êé•Áî®ÊúÄÂ§ßÁöÑÁ†ç‰Ω†ÊúÄÂ∞èÁöÑÔºåÂè¶‰∏ÄÁßçÂ∞±ÊòØÂÖ®Á†çÊ≠ª (‰∫ãÂÆû‰∏äÊï∞ÊçÆÂ∞±Âè™ÊúâËøô‰∏ÄÁßçÊÉÖÂÜµÔºåÂèØËÉΩÂá∫È¢ò‰∫∫ÊúâÁâπÊÆäÁôñÂ•ΩÔºåË¶ÅÁ†çÂ∞±ÂÖ®Á†çÊ≠ª) ÔºåÂÖàÊääÈò≤Âæ°Áä∂ÊÄÅÁöÑÁî®Â∞ΩÂèØËÉΩÂ∞èÁöÑ‰ª£‰ª∑Á†çÊ≠ªÔºåÁÑ∂Âêé‰Ω†ÊÉ≥ÊÄé‰πàÁ†çÂ∞±ÊÄé‰πàÁ†çÔºåÂèçÊ≠£ÊúÄÂêé‰ª£‰ª∑ÈÉΩÊòØ‰Ω†ÊÄ™ÊîªÂáªÂäõÊÄªÂíåÂáèÂØπÈù¢ÊàòÊñóÂäõÊÄªÂíå„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const LL mod = (LL) 1e9 + 7;const int maxn = (int) 1e6 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;#ifndef ONLINE_JUDGEclock_t prostart = clock();#endifvoid f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif&#125;struct node &#123; int x, op; bool operator&lt;(const node &amp;o) const &#123; if (op == o.op)return x &lt; o.x; return op &lt; o.op; &#125;&#125; k[maxn], d[maxn];bool cmp(node &amp;o1, node &amp;o2) &#123; return o1.x &gt; o2.x;&#125;int main() &#123; f(); int T, cas = 1; scanf("%d", &amp;T); while (T--) &#123; int n, m; multiset&lt;int&gt; s; priority_queue&lt;int&gt; q; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;k[i].x); s.insert(k[i].x); q.push(k[i].x); &#125; for (int i = 0; i &lt; m; i++) &#123; scanf("%d", &amp;d[i].x); &#125; for (int i = 0; i &lt; m; i++) &#123; scanf("%d", &amp;d[i].op); &#125; sort(k, k + n, cmp); sort(d, d + m, cmp); int flag = 0; if (n &lt; m)flag = 1; else &#123; for (int i = 0; i &lt; m; i++) &#123; if (k[i].x &lt; d[i].x) &#123; flag = 1; break; &#125; &#125; &#125; LL ans = 0; if (flag == 1) &#123; sort(d, d + m); for (int i = 0; i &lt; m; i++) &#123; if (d[i].op == 1)break; else &#123; if (q.top() &gt; d[i].x) &#123; ans += q.top() - d[i].x; q.pop(); &#125; &#125; &#125; &#125; else &#123; sort(d, d + m); for (int i = 0; i &lt; m; i++) &#123; if (d[i].op == 1)break; else &#123; if (k[i].x &gt; d[i].x) &#123; ans += k[i].x - d[i].x; &#125; else &#123; break; &#125; &#125; &#125; LL res = 0; for (int i = 0; i &lt; m; i++) &#123; if (d[i].op == 1) &#123; s.erase(s.lower_bound(d[i].x)); &#125; else &#123; res -= d[i].x; &#125; &#125; for (auto au:s) &#123; res += au; &#125; ans = max(res, ans); &#125; printf("Case %d: %lld\n", cas++, ans); &#125;#ifndef ONLINE_JUDGE cout &lt;&lt; "ËøêË°åÊó∂Èó¥:" &lt;&lt; 1.0 * (clock() - prostart) / CLOCKS_PER_SEC &lt;&lt; "s\n";#endif // ONLIN_JUDGE return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>ÊØîËµõ</category>
      </categories>
      <tags>
        <tag>CCPC</tag>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 573 Div 2]]></title>
    <url>%2F2019%2F07%2F13%2FCodeforces-Round-573-Div-2%2F</url>
    <content type="text"><![CDATA[A - Tokitsukaze and EnhancementÁÆÄÂçïÈ¢ò‰∏ç‰∏éËØ¥Êòé12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt; using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P; #define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a)); const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("dat.in", "r", stdin);#endif // ONLIN_JUDGE&#125; int main() &#123; f(); int x; cin&gt;&gt;x; x=x%4; if(x==0) &#123; printf("1 A\n"); &#125; else if(x==1) &#123; printf("0 A\n"); &#125; else if(x==2) &#123; printf("1 B\n"); &#125; else printf("2 A\n"); return 0;&#125; B - Tokitsukaze and Mahjong1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt; using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P; #define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a)); const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("dat.in", "r", stdin);#endif // ONLIN_JUDGE&#125;char s[20];vector&lt;int &gt;v[3],v2,v3; int f(int x) &#123; sort(v[x].begin(),v[x].end()); if(v[x].size()==0)return 3; if(v[x].size()==1)return 2; else if(v[x].size()==2) &#123; if(v[x][1]==v[x][0])return 1; if(v[x][1]==v[x][0]+1)return 1; if(v[x][1]==v[x][0]+2)return 1; return 2; &#125; else &#123; if(v[x][1]==v[x][0]&amp;&amp;v[x][1]==v[x][2])return 0; if(v[x][1]==v[x][0]+1&amp;&amp;v[x][1]==v[x][2]-1)return 0; if(v[x][1]==v[x][0]||v[x][1]==v[x][2])return 1; if(v[x][1]==v[x][0]+1||v[x][1]==v[x][0]+2||v[x][1]==v[x][2]-1||v[x][1]==v[x][2]-2)return 1; return 2; &#125;&#125;int main() &#123; int ans=2; for(int i=0; i&lt;3; i++) &#123; scanf("%s",s); if(s[1]=='s') &#123; v[0].push_back(s[0]); &#125; else if(s[1]=='p') &#123; v[1].push_back(s[0]); &#125; else v[2].push_back(s[0]); &#125; for(int i=0; i&lt;3; i++) &#123;// debug(i); ans=min(ans,f(i)); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; C - Tokitsukaze and Discard Items12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt; using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P; #define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a)); const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("dat.in", "r", stdin);#endif // ONLIN_JUDGE&#125; LL n,m,k;LL a[maxn];int main() &#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=0; i&lt;m; i++) &#123; scanf("%lld",&amp;a[i]); &#125; sort(a,a+m); LL sum=0,ans=0,num=0; LL page=1; for(int i=0; i&lt;m; i++) &#123; if(a[i]&lt;=page*k+sum) &#123; num++; &#125; else &#123; if(num==0) &#123; page=(a[i]-sum+k-1)/k; num++; &#125; else &#123; ans++; sum+=num; page=(a[i]-sum+k-1)/k; num=1; &#125; &#125; &#125; if(num!=0)ans++; printf("%lld\n",ans); return 0;&#125; D - Tokitsukaze, CSL and Stone GameÈ¶ñÂÖàËøôÈ¢òÊòØÁÆÄÂçïÁ≤óÊö¥ÔºåÂõ†‰∏∫ÈÄâÊã©Âà∞‰∏§‰∏™Áõ∏ÂêåÁöÑÂ∞±Ëæì‰∫ÜÔºåËØ¥ÊòéÊØè‰∏Ä‰∏™ÈÉΩ‰∏çÁõ∏ÂêåÔºåÊúÄÁªàÁä∂ÊÄÅËÇØÂÆöÊòØ 0 1 2 3 ‚Ä¶. n-1ËøôÁßçÁä∂ÊÄÅËÇØÂÆöÊòØÂøÖËæìÔºåÊó†Ê≥ïÂä®Âºπ„ÄÇÊâÄ‰ª•ÊúÄÁªàÈÉΩ‰ºöÂèòÊàêËøô‰∏™Áä∂ÊÄÅÔºåÂà§Êñ≠‰∏Ä‰∏ãÂà∞Ëøô‰∏™Áä∂ÊÄÅÁöÑÂ•áÂÅ∂Â∞±ÊòØÁ≠îÊ°à„ÄÇÂè¶Â§ñËøòÊúâ‰∏ÄÂºÄÂßãÂ∞±Ëæì‰∫ÜÁöÑÁä∂ÊÄÅÔºåÊØîÂ¶Ç 3 4 4 ‰∏§‰∏™‰∏ÄÊ†∑ÁöÑÔºåÂè™ËÉΩÈÄâ‰∏ÄÊ†∑ÁöÑÔºå‰ΩÜÊòØÈÄâ‰∫ÜÊúâ‰∏Ä‰∏™Âíå‰ªñÁõ∏ÂêåÔºåËøòÊúâ 0 0 ‰∏ÄÂºÄÂßãÂ∞±Êúâ‰∏§‰∏™0 ËøòÊúâÂ∞±ÊòØ 5 5 5 ‰∏â‰∏™‰∏ÄÊ†∑ÁöÑÊàñËÄÖ‰∏§ÂØπ‰∏§‰∏™‰∏ÄÊ†∑ÁöÑÔºåËøôÂõõÁßçÁä∂ÊÄÅÁªùÂØπÊòØÁõ¥Êé•Ëæì‰∫Ü„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374By ET_BUBBLE, contest:Codeforces Round #573 (Div. 2), problem: (D) Tokitsukaze, CSL and Stone Game, Accepted, ##include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("dat.in", "r", stdin);#endif // ONLIN_JUDGE&#125;LL n;LL a[maxn];int flag=1,num;map&lt;LL,LL&gt; mp;LL sum=0;int main() &#123; cin&gt;&gt;n; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;a[i]; &#125; sort(a,a+n); for(int i=0; i&lt;n; i++) &#123; if(mp.find(a[i])!=mp.end()) &#123; num++; if(mp.find(a[i]-1)!=mp.end())flag=0; &#125; mp[a[i]]++; &#125; if(num&gt;1||mp[0]&gt;=2||flag==0) &#123; puts("cslnb"); return 0; &#125; if(n==1) &#123; puts((a[0]&amp;1)?"sjfnb":"cslnb"); &#125; else &#123; int flag=1; sum=0; for(int i=0; i&lt;n; i++) &#123; if(a[i]&lt;i) &#123; flag=0; &#125; else &#123; sum+=a[i]-i; &#125; &#125; if(flag==0) &#123; puts("cslnb"); return 0; &#125; puts(sum%2==1?"sjfnb":"cslnb"); &#125; return 0;&#125; F - Tokitsukaze and Strange RectangleÈ¢òÊÑèÔºöËá™Â∑±ËØªÂéªÈ¢òËß£ÔºöÂÖàÊåâÁÖß,y‰ªéÂ§ßÂà∞Â∞èÊéíÂ∫èÂú®ÊåâÁÖßx‰ªéÂ∞èÂà∞Â§ßÊéíÂ∫èÔºåÁÑ∂ÂêéÊØèÊ¨°Âà§Êñ≠‰∏ÄÂ±Çy„ÄÇÂÖàÂà§Êñ≠Á¨¨‰∏ÄÂ±Ç 1 2 6 7 10 ÔºàÂÅáËÆæÔºây=10ÁÑ∂ÂêéÂà§Êñ≠Á¨¨‰∫åÂ±Ç 4 8 (ÂÅáËÆæ) y = 9Á¨¨‰∏ÄÂ±ÇËÉΩÂ§üÂá∫Áé∞ÁöÑ‰∏çÂêåÁöÑÈÄâÊ≥ïÊòØ 5*(5-1)/2;Á¨¨‰∫åÂ±Ç‰ºöÂèóÂà∞Á¨¨‰∏ÄÂ±ÇÁöÑÂΩ±Âìç 1 2 Âú® 4 ÂâçÈù¢ÔºåÊâÄ‰ª•Ë¶ÅÈÄâ 4 ÁöÑÁü©ÂΩ¢ÊÉÖÂÜµ ÊòØÁ∫¢Ëâ≤lÂà∞Âè≥ËæπËìùËâ≤rÁöÑÊâÄÊúâÁü©ÂΩ¢Ôºå‰ºöÈÄâ‰∏ä4,ÂêåÁêÜÈÄâ‰∏ä8Âèà‰∏çÂíåÂâçÈù¢ÁöÑÈáçÂ§çÂ∞±Âè™ËÉΩÊòØËøôÊ†∑‰∫Ü„ÄÇÁÑ∂ÂêéÂèàÂèØ‰ª•ÂèëÁé∞ÔºåÂ¶ÇÊûúÊúâÁ¨¨3Â±Ç ÔºåÂâçÈù¢‰∏§Â±ÇÂØπÁ¨¨3Â±ÇÁöÑÂΩ±ÂìçÂè™‰∏éxÁöÑÂá∫Áé∞ÊúâÂÖ≥ÔºåÊØèÊ¨°Âà§Êñ≠‰∏ÄÂ±ÇÂè™ÈúÄË¶ÅËÄÉËôë‰∏äÈù¢Âá∫Áé∞ÁöÑ xÁöÑÂΩ±Âìç„ÄÇÂÖàÁ¶ªÊï£Âåñ‰∏Ä‰∏ãÔºåÁÑ∂ÂêéÁî®Ê†ëÁä∂Êï∞ÁªÑÊ±Ç‰∏Ä‰∏ãËøô‰∏™ÁÇπÂâçÈù¢ÊúâÂ§ö‰∏™ÁÇπÔºåÂêéÈù¢ÊúâÂ§öÂ∞ë‰∏™ÁÇπÔºåÁÑ∂Âêé‰πò‰∏Ä‰∏ãÂ∞±ÂèØ‰ª•‰∫Ü„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define VNAME(value) (#value)#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;VNAME(x)&lt;&lt;" = "&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid+1,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("dat.in", "r", stdin);#endif // ONLIN_JUDGE&#125;int bit[maxn+1],pos;int sum(int i) &#123; int s=0; while(i&gt;0) &#123; s +=bit[i]; i-=i&amp;-i; &#125; return s;&#125;void add(int i,int x) &#123; while(i&lt;=pos) &#123; bit[i]+=x; i+=i&amp;-i; &#125;&#125;int n;struct node &#123; int x,y;&#125; p[maxn];bool cmp(node &amp;o1,node &amp;o2) &#123; if(o1.y==o2.y)return o1.x&lt;o2.x; return o1.y&gt;o2.y;&#125;LL ans=0;unordered_map&lt;int,int&gt;mp;int a[maxn];int main() &#123; f(); scanf("%d",&amp;n); for(int i=0; i&lt;n; i++) &#123; scanf("%d%d",&amp;p[i].x,&amp;p[i].y); a[i]=(p[i].x); &#125; pos=1; sort(a,a+n); for(int i=0; i&lt;n; i++) &#123; if(i==0) &#123; mp[a[0]]=pos++; &#125; else if(a[i]!=a[i-1]) &#123; mp[a[i]]=pos++; &#125; &#125; for(int i=0; i&lt;n; i++) &#123; p[i].x=mp[p[i].x]; &#125; sort(p,p+n,cmp); int len=0; a[len++]=p[0].x; add(p[0].x,1); int mx=pos; for(int i=1; i&lt;n; i++) &#123; if(p[i].y==p[i-1].y) &#123; a[len++]=p[i].x; if(sum(p[i].x)-sum(p[i].x-1)==0)add(p[i].x,1); &#125; else &#123; int la=0; // sort(a,a+len); for(int j=0; j&lt;len; j++) &#123; int i=a[j]; ans+=1LL*(sum(i)-sum(la))*(sum(mx)-sum(i-1)); la=i; &#125; len=0; a[len++]=(p[i].x); if(sum(p[i].x)-sum(p[i].x-1)==0)add(p[i].x,1); &#125; &#125; int la=0; // sort(a,a+len); for(int j=0; j&lt;len; j++) &#123; int i=a[j]; ans+=1LL*(sum(i)-sum(la))*(sum(mx)-sum(i-1)); la=i; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>ÊØîËµõ</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÊãâÊ†ºÊúóÊó•ÊèíÂÄºÂíåÊ±ÇÂ§öÈ°πÂºèÁ≥ªÊï∞]]></title>
    <url>%2F2019%2F07%2F12%2F%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E5%92%8C%E6%B1%82%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%B3%BB%E6%95%B0%2F</url>
    <content type="text"><![CDATA[ÊãâÊ†ºÊúóÊó•‰ªãÁªçÂÖàËØ¥ËØ¥ÊãâÊ†ºÊúóÊó•ÊòØÂï•ÂêßÈ¶ñÂÖà ÊãâÊ†ºÊúóÊó•ÊèíÂÄºÊòØÁªô‰Ω† n+1 ‰∏™ÁÇπ $(x,y)$ ÁÑ∂ÂêéÊ†πÊçÆËøôn‰∏™ÁÇπÂèØ‰ª•$O(n^2)$ÁöÑÊ±ÇÂá∫Â§öÈ°πÂºèÁöÑÁ≥ªÊï∞„ÄÇ‰πüÂ∞±ÊòØËß£Âá∫Ëøô‰∏™Â§öÈ°πÂºèÁöÑÁ≠îÊ°à„ÄÇ ÂÅáËÆæÁªô‰Ω†‰∏Ä‰∏™Â§öÈ°πÂºè$y=a_0+a_1x+a_2x^2$ÁÑ∂ÂêéÁªô‰Ω†3‰∏™Ëß£$(x1,y1)(x2,y2)(x3,y3)$‰Ω†Á¨¨‰∏Ä‰∏™ÊÉ≥Ê≥ïÊòØÊÄé‰πàËß£ÔºüËß£ÊñπÁ®ãÂïäÊòØ‰∏çÊòØ‰ª£ËøõÂéªÊòØ‰∏çÊòØËøôÊ†∑ \begin{cases} y_1=a_0+a_1x_1+a_2x_1^2\\ y_2=a_0+a_1x_2+a_2x_2^2\\ y_3=a_0+a_1x_3+a_2x_3^2 \end{cases}ÁÑ∂Âπ¥ÂêéËß£Ëøô‰∏™ÊñπÁ®ãÔºüËß£Ëøô‰∏™ÊñπÁ®ãÂ§çÊùÇÂ∫¶Â§öÂ∞ë,È´òÊñØÊ∂àÂÖÉO(n^3)ÂæàÊòæÁÑ∂Â§çÊùÇÂ∫¶È´ò‰∫Ü„ÄÇÊãâÊ†ºÊúóÊó•Â∞±ÊØîËæÉÂéâÂÆ≥‰∫Ü‰ªñËÉΩO(n^2)Ëß£ÂÜ≥È¶ñÂÖà ÂÅáËÆæ‰∏Ä‰∏™Â§öÈ°πÂºè$f_1(x)= b_0 + b_1x+b_2x^2$ÂΩì‰ªñ$x=x_1$Ëß£ÊòØ1,$x_2$ $x_3$ Ëß£ÊòØ 0ÂêåÁêÜÂÜçÂÅáËÆæ $f_2(x)$ $f_3(x)$ÁÑ∂Âêé$L(x)=y_1f_1(x)+y_2f_2(x)+y_3f_3(x)$,Ëøô‰∏™Â∞±ÊòØÊúÄÂºÄÂßãÈÇ£‰∏™ÊñπÁ®ãÔºå‰∏ç‰ø°?‰Ω†ÂàÜÂà´Êää$x_1,x_2,x_3$ Â∏¶ËøõÂéªËß£ÁªùÂØπÊòØ $y_1,y_2,y_3$„ÄÇÈÇ£‰πàÈóÆÈ¢òÊù•‰∫ÜÂêéÈù¢$f_1(x)$Ëøô‰∏™Â§öÈ°πÂºèÊÄé‰πàÊ±ÇÂá∫Êù•ÔºüÔºüÔºüÔºüËøôÂ∞±ÊòØÊãâÊ†ºÊúóÊó•Âü∫Êú¨ÂÖ¨Âºè ÂÜçÊù•‰∏ÄÈÅçÔºåËøôÂ∞±ÊòØÊãâÊ†ºÊúóÊó•Âü∫Êú¨ÂÖ¨Âºè f_j(x)=l_j(x)=\prod_{j=0,j\neq i}^{n-1}\frac{x-x_j}{x_j-x_i}ÊääËøô‰∏™Â§öÈ°πÂºèÂ±ïÂºÄ‰ºöÂèëÁé∞ÈùûÂ∏∏Á•ûÂ•áÁöÑ‰∫ãÔºåÂΩì$x=x_j$ÁöÑÊó∂ÂÄôÂàöÂ•ΩÁ≠â‰∫é1Âê¶ÂàôÁ≠â‰∫é0,ÂàöÂ•ΩÊª°Ë∂≥‰∫ÜÂéüÊù•ÊâÄÈúÄË¶ÅÁöÑÊñπÁ®ãÂºè„ÄÇÂ∞±ÊòØ‰∏ãÈù¢ËøôÊ†∑Ôºö f_j(x)=l_j(x)=\prod_{j=0,j\neq i}^{k}\frac{x-x_j}{x_i-x_j}=\frac{x-x_0}{x_0-x_j}\cdots\frac{x-x_0}{x_j-x_{j-1}}\frac{x-x_{j+1}}{x_j-x_{j+1}}\cdots\frac{x-x_k}{x_j-x_k}ÊúÄÁªàË°®ËææÂºèL(x)=\sum_{i=0}^{n-1}y_i\prod_{j=0,j\neq i}^{n-1}\frac{x-x_j}{x_j-x_i}ÊÄï‰Ω†ËøòÊòØÁúã‰∏çÊáÇÔºå‰∏æ‰∏™‰æãÂ≠êÁªô‰Ω†Áúã $f(4)=10\ f(5)=5.25\ f(6)=1$ Ê±Ç $f(18)$ È¶ñÂÖàÂÜôÂá∫ÊãâÊ†ºÊúóÊó•Âü∫Êú¨Â§öÈ°πÂºè l_0=\frac{(x-5)(x-6)}{(4-5)(5-6)}l_1=\frac{(x-4)(x-6)}{(5-4)(5-6)}l_2=\frac{(x-4)(x-5)}{(6-4)(6-5)}\begin{cases} p(x)&=f(4)l_0(x)+f(5)l_1(x)+f(6)l_2(x)\\ &=10\frac{(x-5)(x-6)}{(4-5)(5-6)}+5.25\frac{(x-4)(x-6)}{(5-4)(5-6)}+1*\frac{(x-4)(x-5)}{(6-4)(6-5)}\\ &=\frac{1}{4}(x^2-28x+136) \end{cases}Ê≠§Êó∂‰ª£ÂÖ•18:$f(18)=p(18)=-11$ËøòÊúâ‰∏Ä‰∏™ÈóÆÈ¢ò‰Ω†‰ª¨ËÇØÂÆöÂæàÊÉ≥ÈóÆ„ÄÇ„ÄÇ„ÄÇÁü•ÈÅìÂÖ¨Âºè‰πãÂêéÊÄé‰πàËß£„ÄÇ„ÄÇ„ÄÇÂØπ‰∫éËøô‰∏™ÈóÆÈ¢òÂàÜÊØç ÊòØ‰∏çÊòØÊØèÊ¨°ÁÆó‰∏Ä‰∏ãÂ∞±Ë°å‰∫ÜÔºåÁ≠îÊ°àÊòØÂõ∫ÂÆöÁöÑÂàÜÂ≠êÊòØ‰∏çÊòØ‰∏Ä‰∏™Â§ßÁöÑÂ§öÈ°πÂºèÈáåÈù¢Â∞ë‰∫Ü‰∏Ä‰∏™ÔºåÂ∞±È¢ÑÂ§ÑÁêÜÂá∫ÊÄªÁöÑÂ§öÈ°πÂºèÁÑ∂ÂêéÔºåÊ®°ÊãüÈô§‰∏Ä‰∏ã$(x+c)$ÁöÑÂ§öÈ°πÂºè ÁêÜËÆ∫Áü•ËØÜÂÖ®ÈÉ®ÊêûÂÆöÔºå‰∏ãÈù¢Â∞±Áªô‰Ω†Ë¥¥Ê®°Êùø‰∫Ü ÊùøÂ≠ê123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//Ëøô‰∏™ÊòØÊùúÊïôÁöÑÊùøÂ≠ê ÊàëÊâì‰∫ÜÁÇπÊ≥®Èáä/// Ê≥®ÊÑèmodÔºå‰ΩøÁî®ÂâçÈ°ªË∞ÉÁî®‰∏ÄÊ¨° polysum::init(int M);/// Ê≥®ÊÑèmodÔºå‰ΩøÁî®ÂâçÈ°ªË∞ÉÁî®‰∏ÄÊ¨° polysum::init(int M);namespace polysum &#123;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)typedef long long ll;const ll mod = 1e9 + 7; /// ÂèñÊ®°ÂÄºll powmod(ll a, ll b) &#123; ll res = 1; a %= mod; assert(b &gt;= 0); for (; b; b &gt;&gt;= 1) &#123; if (b &amp; 1)res = res*a%mod; a = a*a%mod; &#125; return res;&#125;const int D = 1010000; /// ÊúÄÈ´òÊ¨°ÈôêÂà∂ll a[D], f[D], g[D], p[D], p1[D], p2[D], b[D], h[D][2], C[D];ll calcn(int d, ll *a, ll n) &#123; //Ê†πÊçÆÂâç d È°π Ê±Ç Á¨¨nÈ°π if (n &lt;= d) return a[n]; p1[0] = p2[0] = 1; rep(i, 0, d + 1) &#123; ll t = (n - i + mod) % mod; p1[i + 1] = p1[i] * t%mod; &#125; rep(i, 0, d + 1) &#123; ll t = (n - d + i + mod) % mod; p2[i + 1] = p2[i] * t%mod; &#125; ll ans = 0; rep(i, 0, d + 1) &#123; ll t = g[i] * g[d - i] % mod*p1[i] % mod*p2[d - i] % mod*a[i] % mod; if ((d - i) &amp; 1) ans = (ans - t + mod) % mod; else ans = (ans + t) % mod; &#125; return ans;&#125;void init(int M) &#123; /// MÔºöÊúÄÈ´òÊ¨° f[0] = f[1] = g[0] = g[1] = 1; rep(i, 2, M + 5) f[i] = f[i - 1] * i%mod; g[M + 4] = powmod(f[M + 4], mod - 2); per(i, 1, M + 4) g[i] = g[i + 1] * (i + 1) % mod; //ÈÄÜÂÖÉ&#125;ll polysum(ll n, ll *arr, ll m) &#123; /// a[0].. a[m] \sum_&#123;i=0&#125;^&#123;n-1&#125; a[i] for (int i = 0; i &lt;= m; i++) a[i] = arr[i]; a[m + 1] = calcn(m, a, m + 1); rep(i, 1, m + 2) a[i] = (a[i - 1] + a[i]) % mod; return calcn(m + 1, a, n - 1);&#125;ll qpolysum(ll R, ll n, ll *a, ll m) &#123; /// a[0].. a[m] \sum_&#123;i=0&#125;^&#123;n-1&#125; a[i]*R^i if (R == 1) return polysum(n, a, m); a[m + 1] = calcn(m, a, m + 1); ll r = powmod(R, mod - 2), p3 = 0, p4 = 0, c, ans; h[0][0] = 0; h[0][1] = 1; rep(i, 1, m + 2) &#123; h[i][0] = (h[i - 1][0] + a[i - 1])*r%mod; h[i][1] = h[i - 1][1] * r%mod; &#125; rep(i, 0, m + 2) &#123; ll t = g[i] * g[m + 1 - i] % mod; if (i &amp; 1) p3 = ((p3 - h[i][0] * t) % mod + mod) % mod, p4 = ((p4 - h[i][1] * t) % mod + mod) % mod; else p3 = (p3 + h[i][0] * t) % mod, p4 = (p4 + h[i][1] * t) % mod; &#125; c = powmod(p4, mod - 2)*(mod - p3) % mod; rep(i, 0, m + 2) h[i][0] = (h[i][0] + h[i][1] * c) % mod; rep(i, 0, m + 2) C[i] = h[i][0]; ans = (calcn(m, C, n)*powmod(R, n) - c) % mod; if (ans&lt;0) ans += mod; return ans;&#125;&#125; ÁÑ∂Âêé‰∏ãÈù¢Ëøô‰∏™ÊòØÊ±ÇÂ§öÈ°πÂºèÁöÑ12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758LL temp[maxn];void mul(LL *f, int len, LL t) &#123; //len‰∏∫Â§öÈ°πÂºèÁöÑÊ¨°Êï∞+1ÔºåÂáΩÊï∞ËÆ©Â§öÈ°πÂºèfÂèòÊàêf*(x+t) for (int i = len; i &gt; 0; --i) &#123; temp[i] = f[i]; f[i] = f[i - 1]; &#125; temp[0] = f[0], f[0] = 0; for (int i = 0; i &lt;= len; ++i) &#123; f[i] = (f[i] + t * temp[i]) % mod; &#125;&#125;void dev(LL *f, LL *r, LL t, int len) &#123; //fÊòØË¢´Èô§Â§öÈ°πÂºèÁöÑÁ≥ªÊï∞Ôºår‰øùÂ≠òfÈô§‰ª•x+tÁöÑÁªìÊûú lenÊòØÊúÄÈ´òÊ¨°È°π for (int i = 0; i &lt;= len; ++i) &#123; temp[i] = f[i]; &#125; for (int i = len; i &gt; 0; --i) &#123; r[i - 1] = temp[i]; temp[i - 1] = (temp[i - 1] - t * temp[i]) % mod; &#125; return;&#125;LL a[maxn], b[maxn], c[maxn];LL x[maxn], y[maxn]; //x,yËæìÂÖ•‰ªé 1ÂºÄÂßãÂà∞nint n;void lglr() &#123; memset(a, 0, sizeof a); b[1] = 1, b[0] = -x[1]; for (int i = 2; i &lt;= n; ++i) &#123; mul(b, i, -x[i]); &#125;//È¢ÑÂ§ÑÁêÜ(x-x1)*(x-x2)...*(x-xn) for (int i = 1; i &lt;= n; ++i) &#123; LL fz = 1; for (int j = 1; j &lt;= n; ++j) &#123; if (j == i) continue; fz = fz * (x[i] - x[j]) % mod; &#125; fz = qm(fz, mod - 2); fz = fz * y[i] % mod;//ÂæóÂà∞Â§öÈ°πÂºèÁ≥ªÊï∞ dev(b, c, -x[i], n);//ÂæóÂà∞Â§öÈ°πÂºèÔºå‰øùÂ≠òÂú®bÊï∞ÁªÑ for (int j = 0; j &lt; n; ++j) a[j] = (a[j] + fz * c[j]) % mod; &#125;&#125;LL cal(LL k) &#123; //ËÆ°ÁÆóÁ¨¨x=kÂÄº LL ans = 0; LL res = 1; for (int i = 0; i &lt; n; ++i) &#123; ans = (ans + res * a[i]) % mod; res = res * k % mod; &#125; ans = (ans + mod) % mod; return ans;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Êï∞ËÆ∫</category>
      </categories>
      <tags>
        <tag>Êï∞ËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Â§ßÊï∞Á¥†Êï∞Âà§Êñ≠ÂèäË¥®Âõ†Â≠êÂàÜËß£]]></title>
    <url>%2F2019%2F07%2F11%2F%E5%A4%A7%E6%95%B0%E7%B4%A0%E6%95%B0%E5%88%A4%E6%96%AD%E5%8F%8A%E8%B4%A8%E5%9B%A0%E5%AD%90%E5%88%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Âà§Êñ≠ÊòØÂê¶ÊòØÁ¥†Êï∞Âá†‰∏™Â∏∏Áî®ÁöÑsqrt(n)Â§çÊùÇÂ∫¶ÁöÑÂ∞±‰∏çËØ¥‰∫Ü„ÄÇÂØπ‰∫é‰∏Ä‰∏™ longlong ËåÉÂõ¥ÊàñËÄÖÊõ¥Â§ßÁöÑÊï∞ÔºåÊÄé‰πàÂø´ÈÄüÂà§Êñ≠‰∏Ä‰∏™Êï∞ÊòØ‰∏çÊòØÁ¥†Êï∞ÔºåÂ∞±Ë¶ÅÁî®Âà∞Miller_RabinÁÆóÊ≥ï.Á´ãÁî®a^(n-1)=1(mod n) ÊÄé‰πàÊù•ÁöÑÂ∞±‰∏çËß£Èáä‰∫ÜÔºåÊúâÂÖ¥Ë∂£ÁöÑÂêåÂ≠¶ÂèØ‰ª•ÁúãÁúãÁÆóÊ≥ïÂØºËÆ∫P566ÊúâËØ¶ÁªÜÊé®ÂØº„ÄÇÂú®Ëøô‰∏™ÁöÑÂü∫Á°Ä‰∏äÁî® ÈöèÊú∫Êï∞ËøõË°åÊµãËØïÔºàÁõ¥Êé•Áî®ÁöÑËØù‰ºöÊúâ‰∏Ä‰∫õ‰º™Á¥†Êï∞Ôºâ„ÄÇÈáåÈù¢ aÁî®ÈöèÊú∫Êï∞ÈöèÊú∫Ôºå (n-1) ÂÜôÊàê 2^r*s ‰∏∫Âï•Ëøô‰πàÂÜôÊàë‰πü‰∏çÁü•ÈÅìÔºåÂèçÊ≠£Â§ßÂÆ∂ÈÉΩÊòØËøô‰πàÂÜôÁöÑ qaqÁÑ∂ÂêéÂ∞±Ê†πÊçÆ‰∏äÈù¢ÈÇ£‰∏™Âà§Êñ≠Â∞±Ë°å‰∫ÜËøô‰∏™ÁÆóÊ≥ïÊúâÊó∂ÂÄô‰ºöÂá∫ÈîôÔºåÂá∫ÈîôÁöÑÊ¶ÇÁéáÂ∑Æ‰∏çÂ§öÊòØ 2^-Âæ™ÁéØÊ¨°Êï∞12345678910111213141516171819202122232425262728293031323334353637inline LL ksc(LL x,LL n,LL mod) &#123; LL res=0; while(n&gt;0) &#123; if(n&amp;1)res=(res+x)%mod; x=(x+x)%mod; n&gt;&gt;=1; &#125; return res%mod;&#125;inline LL ksm(LL x,LL n,LL mod) &#123; LL res=1; while(n&gt;0) &#123; if(n&amp;1)res=ksc(res,x,mod); x=ksc(x,x,mod); n&gt;&gt;=1; &#125; return res%mod;&#125;bool check(LL x) &#123; //Miller_RabinÁÆóÊ≥ïÔºåÂà§Êñ≠nÊòØÂê¶‰∏∫Á¥†Êï∞ for(int i=0; i&lt;50; i++) &#123; int a=rand()%(x-1)+1,k=0; LL t=x-1; if(ksm(a,x-1,x)!=1)return 0; while(t&amp;1==0) &#123; ++k; t&gt;&gt;=1; &#125; LL u=ksm(a,t,x),l=u; for(int i=1; i&lt;=k; i++) &#123; u=ksc(u,u,x); if(u==1&amp;&amp;l!=1&amp;&amp;l!=x-1)return 0; l=u; &#125; &#125; return 1;&#125; Ë¥®Âõ†Â≠êÂàÜËß£pollard_rhoÁÆóÊ≥ï,Ëøô‰∏™ÁÆóÊ≥ïÂçÅÂàÜÁéÑÂ≠¶ÔºåÊâæÂà∞‰∏Ä‰∏™Êï∞x0 ÔºåÁÑ∂ÂêéÁî®‰∏Ä‰∏™ÁéÑÂ≠¶ÈÄíÊé®ÂæóÂà∞ x1=x0*x0 + ‰∏Ä‰∏™ÈöèÊú∫Êï∞ ÁÑ∂ÂêéÁî®‰∏§‰∏™ÁöÑÂ∑ÆÂÄºÂéªÂíå nÂÅö gcd ÁÑ∂ÂêéÂæóÂá∫Êù•Â¶ÇÊûúÊòØ1Â∞±ÁªßÁª≠ÊâæÔºåÂ¶ÇÊûú‰∏çÊòØ1 ‰∏çÂ∞±ÊòØ‰∏™Âõ†Â≠êÂêóÔºü Ôºà‰∏™‰∫∫ÁêÜËß£ÊúâÁÇπÂÉèÁõ¥Êé•ÈöèÊú∫‰∏Ä‰∏™Êï∞Âíå‰ªñÂÅöGCDÊúâÊ≤°ÊúâÂÖ¨Á∫¶Êï∞„ÄÇ„ÄÇ„ÄÇ„ÄÇÔºâ Ë°•ÂÖÖËØ¥Êòé‰∏Ä‰∏ã x=(x*x +c)%n ÊòØ‰∏Ä‰∏™ÊªöÂæ™ÁéØ ÂÉèœÅÊâÄ‰ª•Áß∞‰∏∫pollard_rhoÁÆóÊ≥ïÔºåÊâÄ‰ª•Ë¶ÅÂà§Êñ≠Âæ™ÁéØÁªì Áî® floyd Âà§Êñ≠„ÄÇ1234567891011121314151617181920212223242526272829303132333435363738LL pollard_rho(LL n, LL c) &#123; LL i = 1, k = 2; LL x = rand() % (n - 1) + 1; LL y = x; while (1) &#123; i++; x = (ksc(x, x, n) + c) % n; //ÁéÑÂ≠¶ÈÄíÊé® LL d = __gcd((y - x + n) % n, n); if (1LL &lt; d &amp;&amp; d &lt; n) &#123; //Â¶ÇÊûúÊúâÂõ†Â≠êÂ∞±Áõ¥Êé•ËøîÂõû return d; &#125; if (y == x) &#123; //Â¶ÇÊûúÊâæÂà∞‰∫ÜÂæ™ÁéØËäÇÂ∞±Ë∑≥Âá∫ return n; &#125; if (i == k) &#123; //Á©∫Èó¥ o1 Âà§Êñ≠Âæ™ÁéØËäÇÁî®ÁöÑ ÔºåÁúã‰∏çÊáÇ‰Ω†Ê≤°Êïë‰∫Ü y = x; k &lt;&lt;= 1; &#125; &#125;&#125;LL fac[100],ct;void find(LL n, int c) &#123; if (n == 1) &#123; return; &#125; if (check(n)) &#123; fac[ct++] = n; //ÊòØ‰∏™Ë¥®Âõ†Â≠ê return; &#125; LL p = n; LL k = c; while (p &gt;= n) &#123; p = pollard_rho(p, c--); //Â¶ÇÊûúÊòØÂêàÊï∞ÊÄª‰ºöÊâæÂà∞‰∏Ä‰∏™Âõ†Â≠ê &#125; find(p, k); //ÁªßÁª≠Êâæ find(n / p, k);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Êï∞ËÆ∫</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Êï∞ËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Â¶Ç‰ΩïÂ∞ÜÊú¨Âú∞È°πÁõÆ‰º†ÂÖ•github]]></title>
    <url>%2F2019%2F06%2F24%2F%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%BC%A0%E5%85%A5github%2F</url>
    <content type="text"><![CDATA[ÂàùÂßãÂåñÊñá‰ª∂Â§πÂú®Êú¨Âú∞ÊâßË°ågit initÂëΩ‰ª§1git init Ê∑ªÂä†ÈúÄË¶Å‰∏ä‰º†Âà∞githubÁöÑ‰ª£Á†ÅÂà∞Êú¨Âú∞‰ªìÂ∫ìgit statusÊü•ÁúãÂì™‰∫õÊñá‰ª∂ÊòØÊ≤°ÊúâÂä†ÂÖ•Âà∞Êú¨Âú∞‰ªìÂ∫ìÁöÑÔºåÁ∫¢Ëâ≤ÁöÑÊ≤°ÊúâÔºåÁªøËâ≤ÊòØÂ∑≤ÁªèÊ∑ªÂä†‰∫ÜÁöÑ„ÄÇ 1git add ÂèØ‰ª•ÊääÈúÄË¶ÅÁöÑÊñá‰ª∂Âä†ÂÖ•Êú¨Âú∞‰ªìÂ∫ì Â∞ÜaddÁöÑÊñá‰ª∂commitÂà∞‰ªìÂ∫ì1git commit -m &quot;Á¨¨‰∏ÄÊ¨°Êèê‰∫§&quot; Âéªgithub‰∏äÂàõÂª∫Ëá™Â∑±ÁöÑRepositoryËøô‰∏™‰∏çÁî®Êïô‰∫ÜÂêß Â∞ÜÊú¨Âú∞ÁöÑ‰ªìÂ∫ìÂÖ≥ËÅîÂà∞github‰∏ä1git remote add origin +ÈìæÊé• ‰∏ä‰º†‰ª£Á†ÅÂà∞githubËøúÁ®ã‰ªìÂ∫ì12git push #‰º†‰∏äÂéªgit pull #ÊãâÂõûÊù• 123git pull --rebase origin mastergit push -u origin master]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEAËøûÊé•myqslÊï∞ÊçÆÂ∫ì]]></title>
    <url>%2F2019%2F05%2F24%2FIDEA%E8%BF%9E%E6%8E%A5myqsl%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Á¨¨‰∏ÄÊ≠•ÁÑ∂ÂêéÂè≥ËæπÂ∞±‰ºöÂá∫Áé∞‰∏Ä‰∏™database Ëøô‰∏™Âú∞ÊñπÂèØËÉΩË¶ÅÊõ¥Êñ∞‰∏Ä‰∏ãÈ©±Âä®Ôºåidea ÊúâËá™Â∏¶Êõ¥Êñ∞ÔºåÁÇπ‰∏Ä‰∏ã‰∏ãÈù¢ÈÇ£‰∏™ MySQL Â∞±Ë°åÊ∑ªÂä†ËøûÊé•Êï∞ÊçÆÂ∫ìÁöÑJavaÂåÖÈÄâÊã©ÊâæÂà∞ÁöÑÂåÖÊ∑ªÂä†Â•ΩÂêéÂ∫îËØ•‰ºöÂú®‰∏ãÈù¢Â§ö‰∏Ä‰∏™ËøôÊ†∑ÁöÑÂåÖËøûÊé•Êï∞ÊçÆÂ∫ìÂ∞±ÊàêÂäü‰∫ÜÊµãËØï‰∏Ä‰∏ãÔºåÂÖ∑‰ΩìÊµãËØïÊ†πÊçÆ‰Ω†Ëá™Â∑±Êï∞ÊçÆÂ∫ìÊù•ÔºåÂêéÈù¢ÊàëÊâìÊúâÊ≥®Èáä1234567891011121314151617181920212223242526272829303132package longpf;import java.sql.*;public class My &#123; public static void main(String[] args) &#123; Connection conn = null; //Âª∫Á´ã‰∏Ä‰∏™Êï∞ÊçÆÂ∫ìËøûÊé• try &#123; Class.forName( "com.mysql.jdbc.Driver"); //Âä†ËΩΩÈ©±Âä® System.out.println("Êï∞ÊçÆÂ∫ìÈ©±Âä®Âä†ËΩΩÊàêÂäü"); long start=System.currentTimeMillis(); //ËÆ∞ÂΩïÂºÄÂßãÊó∂Èó¥ conn=DriverManager.getConnection("jdbc:mysql://localhost:3306/mygamedb","root","root"); //ËøûÊé•Êï∞ÊçÆÂ∫ìÔºåÂèÇÊï∞Êï∞ÊçÆÂ∫ì‰ΩçÁΩÆÔºåÁî®Êà∑Âêç ÂØÜÁ†Å long end=System.currentTimeMillis(); // ËÆ∞ÂΩïÁªìÊùüÊó∂Èó¥ System.out.println(conn); // ÊâìÂç∞ËøûÊé• System.out.println("Âª∫Á´ãÁî®Êó∂Ôºö"+(end-start)+"ms"); // ÂàõÂª∫StatementÂØπË±° Statement stmt = conn.createStatement(); // ÊâßË°åSQLËØ≠Âè• ResultSet rs = stmt.executeQuery("select * from users"); System.out.println("id\tusername\tpwd\t\tregTime"); while (rs.next()) &#123; System.out.println(rs.getInt(1) + "\t" + rs.getString(2) + "\t\t" + rs.getString(3)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return; &#125;&#125;]]></content>
      <categories>
        <category>ÈÖçÁΩÆ</category>
      </categories>
      <tags>
        <tag>ÈÖçÁΩÆ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EC-FINAL I Misunderstood Missing]]></title>
    <url>%2F2019%2F04%2F25%2FEC-FINAL-I%2F</url>
    <content type="text"><![CDATA[ÂÜôÊ≠§ÁØáËÆ∞ÂΩïEC-FINAL ÈìÅÁâå„ÄÇI Misunderstood ‚Ä¶ MissingÊ≠§È¢òÔºåÊòØECÊâìÈìÅÁöÑ‰∏ªË¶ÅÂéüÂõ†„ÄÇÂú®ÁâõÂÆ¢ÁöÑÈÇ£‰∏™ÁΩëÁ´ô‰∏äÊ≠§È¢òÂá∫ÁöÑÊØîFÈ¢òËøòË¶ÅÂ§öÔºåÁÑ∂ËÄåÊàëÂú®ÊØîËµõ‰∏≠Âç¥Ê≤°ÊúâÂÜôÂá∫Êù•ÔºåÂ¶ÇÊûúËøôÈ¢òÂÜôÂá∫Êù•‰∫ÜÔºåÂèØËÉΩËøòÊúâÊïë„ÄÇÂØπ‰∫éËøôÈ¢òDPÊ≤°ÂÜôÂá∫Êù•ÔºåÊÑüËßâÊòØÁúüÁöÑÂÇªÈÄº„ÄÇ‰ª•ÂêéÊâìÊØîËµõÂàáËÆ∞‰∏çÂèØ‰ª•ÊÖåÂº†ÔºåÊÖåÂº†Âπ∂‰∏çËÉΩËß£ÂÜ≥ÈóÆÈ¢òÔºåËøôÈ¢òÂ¶ÇÊûúÈùô‰∏ãÂøÉÊù•ÊÄùËÄÉÂ∫îËØ•‰∏çÈöæÊÉ≥Âá∫Êù•„ÄÇÈ¢òÊÑèÔºöt ÁªÑÊï∞ÊçÆ n ‰∏™ÂõûÂêàÂàùÂßãÊàòÂäõ A ‰∏∫ 0 ÂêéÈù¢Êúân ‰∏™ÂõûÂêàÔºåÊØè‰∏™ÂõûÂêàÂèØ‰ª•ËøõË°å‰∏Ä‰∏™Êìç‰Ωú1ÂèØ‰ª•ÈÄ†ÊàêA+aÁÇπ‰º§ÂÆ≥2ÊØè‰∏™ÂõûÂêàÊàòÂäõÂä†b3Áõ¥Êé•ÊèêÂçá c ÁÇπÊàòÊñóÂäõÈóÆÊúÄÂ§öËÉΩÈÄ†ÊàêÂ§öÂ∞ëÁÇπ‰º§ÂÆ≥È¢òËß£ÔºöDPÊ±ÇËß£ dp[i][j]‰∏∫j ‰∏™ÂõûÂêàËøõË°å‰∫ÜÁ¨¨‰∏ÄÁßçÊìç‰ΩúÔºåÊìç‰ΩúÁöÑ‰∏ãÊ†áÂíå‰∏∫j„ÄÇÂ¶ÇÊûúÊää1 2 3 ‰∏âÁßçÊìç‰ΩúÁöÑ‰º§ÂÆ≥Âå∫ÂàÜÂºÄÊù•Ôºå1 Êìç‰ΩúÂ∞±ÊòØÁõ¥Êé•ÈÄ†Êàê a ÁÇπ‰º§ÂÆ≥„ÄÇ 2 Êìç‰Ωú‰ºöÂØπÂêéÈù¢ÁöÑAÈÄ†ÊàêÂΩ±ÂìçÔºå‰ªîÁªÜÊÄùËÄÉ‰∏Ä‰∏ãÂä†ÂÖ• 2 Êìç‰ΩúÊòØ Á¨¨ i ‰∏™ ÂêéÈù¢ËøõË°å‰∫Ü j Ê¨°ÊîªÂáª ,ËÉΩÂ§üÂèëÁé∞ 2 Êìç‰Ωú ÊúÄÁªàÈÄ†ÊàêÁöÑ‰º§ÂÆ≥ÂíåÊòØ Ôºà‰∏ãÊ†áÂíå - i * j Ôºâ b ÁÇπ‰º§ÂÆ≥„ÄÇ‰∏æ‰∏™‰æãÂ≠êÔºöÂ¶ÇÊûú ‰Ω†Âú® 2 3 ËøõË°å‰∫ÜÊîªÂáª,‰Ω†Âú®Á¨¨1‰∏™ÂõûÂêàËøõË°å‰∫Ü2Êìç‰Ωú ÈÇ£‰πàË¥°ÁåÆÂ∞± ÊòØ (2+3 - 1 * 2)*b„ÄÇÁêÜËß£‰∫ÜËøô‰∏™ 3 Êìç‰ΩúÂ∞±Êõ¥ÁÆÄÂçï‰∫ÜÔºåÁõ¥Êé•Â∞±ÊòØj*cÁöÑ‰º§ÂÆ≥„ÄÇÁúãÂà∞ËøôÈáå‰πüÂ∑Æ‰∏çÂ§öÊòéÁôΩÔºåËøô‰∏™DPÊòØ‰ªéÂêéÂæÄÂâçDPÁöÑ„ÄÇÂêéÈù¢ÁöÑÁä∂ÊÄÅÊ∞∏ËøúÈÉΩ‰∏ç‰ºöÂΩ±ÂìçÂà∞ÂâçÈù¢„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &quot;bits/stdc++.h&quot;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout &lt;&lt; &quot;[&quot; &lt;&lt; x &lt;&lt; &quot;]&quot; &lt;&lt; endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const long long mod = 1e9 + 7;const int maxn = 6e3 + 5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen(&quot;../data.in&quot;, &quot;r&quot;, stdin);#endif return;&#125;LL dp[maxn][105];LL a[105], b[105], c[105];int main() &#123; f(); int t, n; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%lld%lld%lld&quot;, &amp;a[i], &amp;b[i], &amp;c[i]); &#125; memset(dp, -1, sizeof(dp)); dp[n][1]=a[n]; for (int i = n - 1; i &gt;= 1; i--) &#123; for (int j = maxn-1; j&gt;=0; j--) &#123; for (int l = 0; l &lt;= n; l++) &#123; if(dp[j][l]==-1)continue; if(j+i&lt;maxn)dp[j+i][l+1]=max(dp[j+i][l+1],dp[j][l]+a[i]); dp[j][l]=max(dp[j][l]+c[i]*l,max(dp[j][l],dp[j][l]+b[i]*(j-l*i))); &#125; &#125; &#125; LL ans=0; for(int i=0; i&lt;=n; i++) &#123; for(int j=0; j&lt;maxn; j++) &#123; ans=max(dp[j][i],ans); &#125; &#125; printf(&quot;%lld\n&quot;,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Âä®ÊÄÅËßÑÂàí</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ sockÁºñÁ®ãÂ≠¶‰π†Á¨îËÆ∞]]></title>
    <url>%2F2019%2F04%2F19%2FC%2B%2B-sock%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[‰∏ªÊú∫Â≠óËäÇÂ∫èÂíåÁΩëÁªúÂ≠óËäÇÂ∫èCPUÁ¥ØÂä†Âô®‰∏ÄÊ¨°ËÉΩË£ÖËΩΩËá≥Â∞ë4‰∏™Â≠óËäÇÔºåÂç≥‰∏Ä‰∏™Êï¥Êï∞„ÄÇÂ≠óËäÇÂ∫èÂàÜ‰∏∫Â§ßÁ´ØÂ≠óËäÇÂ∫èÂíåÂ∞èÁ´ØÂ≠óËäÇÂ∫è„ÄÇÂ§ßÁ´ØÂ≠óËäÇÂ∫èÈ´ò‰ΩçÂ≠óËäÇÔºà23-31bitÔºâÂÇ®Â≠òÂú®ÂÜÖÂ≠òÁöÑ‰ΩéÂ§ÑÔºå‰Ωé‰ΩçÂ≠óËäÇÂÇ®Â≠òÂú®È´òÂú∞ÂùÄÂàù„ÄÇÂ∞èÁ´ØÂ≠óËäÇÂ∫èÊÅ∞ÊÅ∞Áõ∏Âèç„ÄÇÂ§ßÈÉ®ÂàÜPCÁîµËÑëÁîµËÑë‰ΩøÁî®Â∞èÁ´ØÂ≠óËäÇÂ∫èÔºåÊâÄ‰ª•ÂèàË¢´Áß∞‰∏∫‰∏ªÊú∫Â≠óËäÇÂ∫è„ÄÇÂ§ßÁ´ØÂ≠óËäÇÂ∫èË¢´Áß∞‰∏∫ÁΩëÁªúÂ≠óËäÇÂ∫è„ÄÇJAVAËôöÊãüÊú∫‰ΩøÁî®ÁöÑÊòØÂ§ßÁ´ØÂ≠óËäÇÂ∫è4‰∏™ÂáΩÊï∞ÂáΩÊï∞Áî®Êù•ÂÆåÊàêÂ≠óËäÇÂ∫èËΩ¨Êç¢„ÄÇ123456// #include&lt;netinet/in.h&gt; //linux ‰∏ãÂ§¥Êñá‰ª∂#include&lt;winsock2.h&gt; //window ‰∏ãÂ§¥Êñá‰ª∂unsigned long htonl(unsigned long); //host to net ËΩ¨Êç¢IPunsigned long ntohl(unsigned long); //net to host ËΩ¨Êç¢IPunsigned short htons(unsigned short); //host to net ËΩ¨Êç¢Á´ØÂè£unsigned short ntohs(unsigned short); //net to host ËΩ¨Êç¢Á´ØÂè£]]></content>
      <categories>
        <category>ËÆ°ÁÆóÊú∫ÁΩëÁªú</category>
      </categories>
      <tags>
        <tag>ËÆ°ÁÆóÊú∫ÁΩëÁªú</tag>
        <tag>Á¨îËÆ∞</tag>
        <tag>sock ÁºñÁ®ã</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÈÄâÊãîËµõTulip FestivalÂèäÂÖ∂ËøõÈò∂]]></title>
    <url>%2F2019%2F04%2F16%2F%E9%80%89%E6%8B%94%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[Á∫øÊÆµÊ†ëÂä®ÊÄÅÂºÄÁÇπÔºåÂØπ‰∫éËøôÈ¢òÈ°∫‰æøÊåÇ‰∏™Ëá™Â∑±Â≠¶Ê†°OJ Tulip Festival‰ª•ÂèäÂêéÈù¢Ë∑üÁùÄÁöÑÂá†‰∏™ÁâàÊú¨ÔºåÁî®Á∫øÊÆµÊ†ëÂä®ÊÄÅÂºÄÁÇπÈÉΩËÉΩËøá„ÄÇÈ¢òÊÑèÔºöÁªô n ‰∏™Êï∞Â≠ó,m‰∏™Êìç‰ΩúÊìç‰Ωú‰∏§Áßç:1 Êääp‰øÆÊîπÊàêx2 Êü•ËØ¢ [l,r]Âå∫‰ª∂Á±ª‰∏é [l,r]Âå∫Èó¥ÂºÇÊàñÂíå‰∏çÁõ∏Á≠âÁöÑÊï∞Â≠ó‰∏™Êï∞„ÄÇ È¢òËß£ÔºöÊääÊØè‰∏™Êï∞Â≠óÁöÑ‰∏ãÊ†áÊîæÂà∞‰∏Ä‰∏™Êï∞ÁªÑÔºåÂå∫Èó¥ÂºÇÊàñÂíåÁõ¥Êé•Áî®Ê†ëÁä∂Êï∞ÁªÑÊ±ÇÂá∫Êù•(ÂØπ‰∫é‰∏ç‰ºöÁî®Ê†ëÁä∂Êï∞ÁªÑÊ±ÇÂå∫Èó¥ÂºÇÊàñÂíåÁöÑÂ§öÂéªÂÅöÂÅöÊ†ëÁä∂Êï∞ÁªÑÂü∫Á°ÄÈ¢ò)ÁÑ∂ÂêéÊØèÊ¨°Êü•ËØ¢Âå∫Èó¥ÈáåÈù¢ÁöÑÊúâ‰∏™Êï∞Â≠óÂíåÂºÇÊàñÂÄºÁõ∏Á≠âÂç≥ÂèØ„ÄÇÊúâ‰∏Ä‰∏™ÁâàÊú¨Âè™Êúâ200‰∏™Áõ∏ÂêåÂÄºÔºåËøô‰∏™Áõ¥Êé•Áî®vectorÂ≠òÔºåÁÑ∂ÂêéÊö¥ÂäõÊü•ÊâæÂ∞±Ë°å‰∫Ü„ÄÇ‰ΩÜÊòØÂêéÈù¢Âá∫Áé∞‰∫ÜÂ§ßÈáèÁõ∏ÂêåÁöÑÊï∞Â≠óÔºåÂ∞±‰∏çËÉΩÊö¥Âäõ‰∫Ü„ÄÇÊü•ËØ¢Âå∫Èó¥Á±ªÊúâÂ§öÂ∞ë‰∏™ÂÄºÔºåÂèØ‰ª•Áî®Ê†ëÁä∂Êï∞ÁªÑÊúÄÁÆÄÊ¥ÅÔºå‰ΩÜÊòØÊòéÊòæ1e6‰∏™Êï∞ÔºåÊØè‰∏™Êï∞ÂºÄ‰∏Ä‰∏™Ê†ëÁä∂Êï∞ÁªÑÔºåÈïøÂ∫¶‰∏∫1e6ÊòéÊòæÁÇ∏‰∫Ü„ÄÇÁî®Á∫øÊÆµÊ†ëÔºåÂ¶ÇÊûúÁõ¥Êé•ÂºÄÁ©∫Èó¥ÊØè‰∏™ÈÉΩË¶ÅÂºÄnlogn‰∏™ÁÇπÔºåÊòéÊòæ‰πü‰ºöÁÇ∏„ÄÇ‰ΩÜÊòØËá™‰ø°‰∏ÄÊÉ≥ÔºåÂÖ∂‰∏≠ÊúâÂæàÂ§öÁÇπÈÉΩÊòØÊó†Áî®ÁöÑÔºåÊâÄÊúâÊï∞Âä†Ëµ∑Êù•‰∏™Êï∞ÊúÄÂ§ö‰∏çÂà∞1e6‰∏™ÁÇπÔºåÊâÄ‰ª•Áî®Á∫øÊÆµÊ†ëÂä®ÊÄÅÂºÄÁÇπÔºåÊúÄÂ§ö‰∏ç‰ºöË∂ÖËøánlogn‰∏™ÁÇπ„ÄÇÁ∫øÊÆµÊ†ëÂä®ÊÄÅÂºÄÁÇπÂÖ∂ÂÆûÂíåÊôÆÈÄöÁöÑÁ∫øÊÆµÊ†ëÂÖ∂ÂÆûÂ∑ÆË∑ù‰∏çÂ§ß„ÄÇÂä®ÊÄÅÂºÄÁÇπÔºåÂ∞±ÊòØÊääÊ≤°ÊúâÁî®ÁöÑËäÇÁÇπÂ∞±‰∏çÁªô‰ªñÂàÜÈÖçÂÜÖÂ≠òÔºåÂ≠óËäÇÂΩì‰ΩúÁ©∫ÔºåËøôÊ†∑ÊØè‰∏™Êï∞Â≠óÊúÄÂ§öÊúÄÂ§öÂºÄlogn‰∏™ÁÇπ„ÄÇÂä®ÊÄÅÂºÄÁÇπÂª∫ËÆÆÁî®ÁªìÊûÑ‰ΩìÂÜôÔºåËøôÊ†∑ÂèØ‰ª•Êñπ‰æø‰∏ÄÁÇπ„ÄÇÁªìÊûÑ‰ΩìËÆæÁΩÆ3‰∏™ÂÄº‰∏Ä‰∏™ÊòØÂΩìÂâçËäÇÁÇπ‰øùÂ≠òÁöÑÂÄºÔºåÂ∑¶Âè≥ÂÑøÂ≠ê‰∏ãÊ†á‰∏æ‰∏™‰æãÂ≠êÔºåÂä†ÂÖ•Á∫øÊÆµÊ†ëÊÄªÈïøÂ∫¶ÊòØ 1 - 8,‰Ω†Âú® 1 1 ÊèíÂÖ•‰∏Ä‰∏™ÂÄº„ÄÇÈÇ£‰πà‰Ω†Â∞±ÈúÄË¶Å 1-8 1-4 1-2 1-1ËøôÂá†‰∏™ÁÇπÂºÄÁ©∫Èó¥ÔºåÂÖ∂‰ªñÁÇπÁõ¥Êé•‰∏çÁî®ÁÆ°ÔºåÊü•ËØ¢ÁöÑÊó∂ÂÄôÁõ¥Êé•ËøîÂõû0123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;#define bug printf("*********\n");#define debug(x) cout &lt;&lt; "[" &lt;&lt; x &lt;&lt; "]" &lt;&lt; endl;#define mid (l + r) / 2#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const long long mod = 1e9 + 7;const int maxn = 1e6 + 5 + 1e5;const int INF = 0x7fffffff;const LL inf = 0x3f3f3f3f;const double eps = 1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("../1.in", "r", stdin); freopen("../data.out", "w", stdout);#endif return;&#125;int tot, n, m;int a[maxn], bit[maxn];unordered_map&lt;int, int&gt; mp;int sum(int i) &#123; int ans = 0; while (i &gt; 0) &#123; ans ^= bit[i]; // debug(i); i -= i &amp; -i; &#125; return ans;&#125;void add(int i, int x) &#123; while (i &lt;= n) &#123; bit[i] ^= x; // debug(i); i += i &amp; -i; &#125;&#125;struct node &#123; int x; int chl, chr;&#125; tree[maxn * 50];int tt;void update(int a, int b, int l, int r, int k, int bol) &#123; if (b &lt; l || a &gt; r)return; else if (a &lt;= l &amp;&amp; r &lt;= b) &#123; if (bol)tree[k].x = 1; else tree[k].x = 0; &#125; else &#123; if (b &lt;= mid) &#123; if (tree[k].chl == 0) &#123; tree[k].chl = tt++; &#125; update(a, b, l, mid, tree[k].chl, bol); &#125; else &#123; if (tree[k].chr == 0) &#123; tree[k].chr = tt++; &#125; update(a, b, mid + 1, r, tree[k].chr, bol); &#125; int sum = 0; if (tree[k].chl != 0) &#123; sum += tree[tree[k].chl].x; &#125; if (tree[k].chr != 0) &#123; sum += tree[tree[k].chr].x; &#125; tree[k].x = sum; return; &#125;&#125;int querry(int a, int b, int l, int r, int k) &#123; if (b &lt; l || a &gt; r) &#123; return 0; &#125; else if (a &lt;= l &amp;&amp; r &lt;= b) &#123; return tree[k].x; &#125; else &#123; int sum = 0; if (tree[k].chl != 0) &#123; sum += querry(a, b, l, mid, tree[k].chl); &#125; if (tree[k].chr != 0) &#123; sum += querry(a, b, mid + 1, r, tree[k].chr); &#125; return sum; &#125;&#125;int main() &#123; f(); scanf("%d%d", &amp;n, &amp;m); tt = n + m + 1; for (int i = 0; i &lt; n; i++) &#123; int t; scanf("%d", &amp;t); add(i + 1, t); if (mp[t] == 0) &#123; mp[t] = ++tot; update(i + 1, i + 1, 1, n, tot, 1); &#125; else &#123; update(i + 1, i + 1, 1, n, mp[t], 1); &#125; &#125; // debug(sum(1)); while (m--) &#123; int op; scanf("%d", &amp;op); if (op == 1) &#123; int p, x; scanf("%d%d", &amp;p, &amp;x); int t = sum(p) ^sum(p - 1); update(p, p, 1, n, mp[t], 0); add(p, t ^ x); if (mp[x] == 0)mp[x] = ++tot; update(p, p, 1, n, mp[x], 1); assert(tt &lt; 5e7); &#125; else &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); int t = sum(r) ^sum(l - 1); //debug(t); if (mp[t] == 0)printf("%d\n", r - l + 1); else printf("%d\n", r - l + 1 - querry(l, r, 1, n, mp[t])); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Êï∞ÊçÆÁªìÊûÑ</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Êï∞ÊçÆÁªìÊûÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3DËß¶ÂèëÂô®ÂíåÁ¢∞ÊíûÂô®]]></title>
    <url>%2F2019%2F03%2F26%2FUnity3D%E8%A7%A6%E7%A2%B0%E5%99%A8%E5%92%8C%E7%A2%B0%E6%92%9E%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Unity3dÁ¢∞ÊíûÊ£ÄÊµã‰∏≠Á¢∞ÊíûÂô®‰∏éËß¶ÂèëÂô®ÁöÑÂå∫Âà´Ë¶Å‰∫ßÁîüÁ¢∞ÊíûÂøÖÈ°ª‰∏∫Ê∏∏ÊàèÂØπË±°Ê∑ªÂä†Âàö‰ΩìÔºàRigidbodyÔºâÂíåÁ¢∞ÊíûÂô®ÔºåÂàö‰ΩìÂèØ‰ª•ËÆ©Áâ©‰ΩìÂú®Áâ©ÁêÜÂΩ±Âìç‰∏ãËøêÂä®„ÄÇÁ¢∞Êíû‰ΩìÊòØÁâ©ÁêÜÁªÑ‰ª∂ÁöÑ‰∏ÄÁ±ªÔºåÂÆÉË¶Å‰∏éÂàö‰Ωì‰∏ÄËµ∑Ê∑ªÂä†Âà∞Ê∏∏ÊàèÂØπË±°‰∏äÊâçËÉΩËß¶ÂèëÁ¢∞Êíû„ÄÇÂ¶ÇÊûú‰∏§‰∏™Âàö‰ΩìÁõ∏‰∫íÊíûÂú®‰∏ÄËµ∑ÔºåÈô§Èùû‰∏§‰∏™ÂØπË±°ÊúâÁ¢∞Êíû‰ΩìÊó∂Áâ©ÁêÜÂºïÊìéÊâç‰ºöËÆ°ÁÆóÁ¢∞ÊíûÔºåÂú®Áâ©ÁêÜÊ®°Êãü‰∏≠ÔºåÊ≤°ÊúâÁ¢∞Êíû‰ΩìÁöÑÂàö‰Ωì‰ºöÂΩºÊ≠§Áõ∏‰∫íÁ©øËøá„ÄÇ Áâ©‰ΩìÂèëÁîüÁ¢∞ÊíûÁöÑÂøÖË¶ÅÊù°‰ª∂ ‰∏§‰∏™Áâ©‰ΩìÈÉΩÂøÖÈ°ªÂ∏¶ÊúâÁ¢∞ÊíûÂô®(Collider)ÔºåÂÖ∂‰∏≠‰∏Ä‰∏™Áâ©‰ΩìËøòÂøÖÈ°ªÂ∏¶ÊúâRigidbodyÂàö‰Ωì„ÄÇ Âú®unity3d‰∏≠ÔºåËÉΩÊ£ÄÊµãÁ¢∞ÊíûÂèëÁîüÁöÑÊñπÂºèÊúâ‰∏§ÁßçÔºå‰∏ÄÁßçÊòØÂà©Áî®Á¢∞ÊíûÂô®ÔºåÂè¶‰∏ÄÁßçÂàôÊòØÂà©Áî®Ëß¶ÂèëÂô®„ÄÇ Á¢∞ÊíûÂô®Ôºö‰∏ÄÁæ§ÁªÑ‰ª∂ÔºåÂÆÉÂåÖÂê´‰∫ÜÂæàÂ§öÁßçÁ±ªÔºåÊØîÂ¶ÇÔºöBox ColliderÔºàÁõíÁ¢∞Êíû‰ΩìÔºâÔºåMesh ColliderÔºàÁΩëÊ†ºÁ¢∞Êíû‰ΩìÔºâÁ≠âÔºåËøô‰∫õÁ¢∞ÊíûÂô®Â∫îÁî®ÁöÑÂú∫Âêà‰∏çÂêåÔºå‰ΩÜÈÉΩÂøÖÈ°ªÂä†Âà∞GameObjecetË∫´‰∏ä„ÄÇ Ëß¶ÂèëÂô®ÔºåÂè™ÈúÄË¶ÅÂú®Ê£ÄËßÜÈù¢Êùø‰∏≠ÁöÑÁ¢∞ÊíûÂô®ÁªÑ‰ª∂‰∏≠ÂãæÈÄâIsTriggerÂ±ûÊÄßÈÄâÊã©Ê°Ü„ÄÇÂãæÈÄâIs Trigger Âêé‰∏ç‰ºöÊúâÁ¢∞ÊíûÁâ©ÁêÜÁé∞Ë±°Ëß¶Âèë‰ø°ÊÅØÊ£ÄÊµãÔºö 1.MonoBehaviour.OnTriggerEnter(Collider collider)ÂΩìËøõÂÖ•Ëß¶ÂèëÂô® 2.MonoBehaviour.OnTriggerExit(Collider collider)ÂΩìÈÄÄÂá∫Ëß¶ÂèëÂô® 3.MonoBehaviour.OnTriggerStay(Collider collider)ÂΩìÈÄóÁïôËß¶ÂèëÂô® Á¢∞Êíû‰ø°ÊÅØÊ£ÄÊµãÔºö 1.MonoBehaviour.OnCollisionEnter(Collision collision) ÂΩìËøõÂÖ•Á¢∞ÊíûÂô® 2.MonoBehaviour.OnCollisionExit(Collision collision) ÂΩìÈÄÄÂá∫Á¢∞ÊíûÂô® 3.MonoBehaviour.OnCollisionStay(Collision collision) ÂΩìÈÄóÁïôÁ¢∞ÊíûÂô® 12345678void OnTriggerEnter(Collider collider)&#123; //ËøõÂÖ•Ëß¶ÂèëÂô®ÊâßË°åÁöÑ‰ª£Á†Å&#125;void OnCollisionEnter(Collision collision) &#123; //ËøõÂÖ•Á¢∞ÊíûÂô®ÊâßË°åÁöÑ‰ª£Á†Å&#125;]]></content>
      <categories>
        <category>Ê∏∏Êàè</category>
        <category>U3D</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[‰∏≠ÂçóÂ§öÊ†°Á¨¨‰∏ÄÂú∫]]></title>
    <url>%2F2019%2F03%2F18%2F%E4%B8%AD%E5%8D%97%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%80%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[Ê∫êÈ¢òÁõÆ 2018-2019 ACM-ICPC Nordic Collegiate Programming Contest (NCPC 2018)&lt;/br&gt; ÂÜô‰∏ÄÁØáÂçöÂÆ¢Ë°®Á§∫Ëá™Â∑±ÊääÈ¢òË°•‰∫Ü. &lt;/br&gt; A.Altruistic AmphibiansÁÆÄÂçïDPÔºåÊØè‰∏™ÈùíËõôÁöÑÈáçÈáèÊÄªÂíå‰∏ç‰ºöË∂ÖËøá 1e8ÔºåÊØè‰∏ÄÊ¨°ÂΩ±ÂìçÁöÑÁä∂ÊÄÅÊúÄÂ§öÂè™Êúâ 1e8Â§çÊùÇÂ∫¶ÊúÄÈ´òÂè™Êúâ1e8dp[j]Ë°®Á§∫ËÉΩÊîØÊíëÈáçÈáèjÊúÄÂ§ßÈ´òÂ∫¶ÊòØÂ§öÂ∞ë„ÄÇdp[j-w[i]]=max(dp[j-w[i]],dp[j]);1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;x&lt;&lt;"]" &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e8+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;int a[maxn/10];struct node &#123; int l,w,h; bool operator&lt;(const node &amp; t) &#123; return w&gt;t.w; &#125;&#125; dat[maxn/10];int dp[maxn*2];int main() &#123; int n,d; scanf("%d%d",&amp;n,&amp;d); int mx=0; for(int i=0; i&lt;n; i++) &#123; scanf("%d%d%d",&amp;dat[i].l,&amp;dat[i].w,&amp;dat[i].h); mx=max(mx,dat[i].w); &#125; sort(dat,dat+n); int ans=0; for(int i=0; i&lt;n; i++) &#123; if(dp[dat[i].w]+dat[i].l&gt;d)ans++; for(int j=dat[i].w+1; j&lt;min(2*dat[i].w,maxn); j++) &#123; dp[j-dat[i].w]=max(dp[j-dat[i].w],dp[j]+dat[i].h); &#125; &#125; printf("%d\n",ans); return 0;&#125; B. Baby BitesÊ∞¥È¢òÈÉΩ‰∏çËß£Èáä12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#define fi first#define se second#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1#define pb push_back#define MP make_pair#define LL long long#define FIN freopen("in.txt","r",stdin)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt;pii;int n;string s;int main()&#123;#ifndef ONLINE_JUDGE FIN;#endif // ONLINE_JUDGE while(cin&gt;&gt;n) &#123; int falg= 1; for(int i = 1; i&lt;=n; i++) &#123; cin&gt;&gt;s; if(s=="mumble") continue; else &#123; int tmp = stoi(s); if(tmp!=i) &#123; falg = 0; &#125; &#125; &#125; if(falg)&#123; cout&lt;&lt;"makes sense"&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;"something is fishy"&lt;&lt;endl; &#125; &#125; return 0;&#125; C. Code Cleanups12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#define fi first#define se second#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1#define pb push_back#define MP make_pair#define LL long long#define FIN freopen("in.txt","r",stdin)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt;pii;const int mod = 1e9+7;const int MX = 3e3+5;int n;int vis[MX];int main()&#123;#ifndef ONLINE_JUDGE FIN;#endif // ONLINE_JUDGE while(~scanf("%d",&amp;n))&#123; memset(vis,0,sizeof(vis)); for(int i = 1,x;i &lt;= n;i++) &#123; scanf("%d",&amp;x); vis[x] = 1; &#125; int ans = 0; int sum = 0,cnt = 0; for(int i = 1;i &lt;= 365;i++) &#123; sum += cnt; if(sum &gt;= 20) &#123; ans++; sum = 0; cnt = 0; i--; continue; &#125; if(vis[i]) cnt++; &#125; if(cnt) ans++; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; D. Delivery DelaysËøôÈ¢ò‰πüÊå∫ÁÆÄÂçïÁöÑÔºå‰∏çËøáÂá∫‰∫Ü‰∏çÂ∞ëbugËÆ∞ÂΩï‰∏Ä‰∏ã„ÄÇÈ¶ñÂÖàÈ¢ÑÂ§ÑÁêÜÂá∫ÊâÄÊúâÁÇπÁõ¥Êé•ÁöÑÊúÄËøëË∑ùÁ¶ªÔºåÁÑ∂ÂêéÂÜçÈ¢ÑÂ§ÑÁêÜÂá∫ÈÄÅÂÆåÁ¨¨j‰∏™ÂõûÂà∞1ÁÇπÁÑ∂Âêé‰∏ÄÁõ¥Á≠âÂà∞ i Á¨¨i‰∏™ËÆ¢ÂçïÁöÑÈúÄË¶ÅÁöÑÊó∂Èó¥ÔºåÂíåÁî®Êà∑ÊúÄÂ§ßÁ≠âÂæÖÊó∂Èó¥„ÄÇÁÑ∂Âêédp[i]‰øùÂ≠òÈÄÅÂÆåÁ¨¨ i ‰∏™ËÆ¢ÂçïÂõûÂà∞ 1 ÁöÑÊúÄÂ∞èÊó∂Èó¥ÔºåÁÑ∂ÂêéÂÜç‰∫åÂàÜÊúÄÂ§ßÁ≠âÂæÖÊó∂Èó¥„ÄÇÊúÄÂêéÂÜô‰∫åÂàÜÂá∫‰∫ÜÁÇπÈóÆÈ¢òÔºå‰∫åÂàÜÁöÑËåÉÂõ¥ Ôºål ÂàùÂÄºÂ∫îËØ•ÊòØ-1ËÄå‰∏çÊòØ0;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include "bits/stdc++.h"using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;LL, int&gt; P;#define bug printf("*********\n");#define debug(x) cout &lt;&lt; "[" &lt;&lt; x &lt;&lt; "]" &lt;&lt; endl;#define mid (l + r) / 2#define chl 2 * k + 1#define chr 2 * k + 2#define lson l, mid, chl#define rson mid + 1, r, chr#define pb push_back#define mem(a, b) memset(a, b, sizeof(a));const long long mod = 1e9 + 7;const int maxn = 1e3 + 5;const LL INF = 0x7fffffff;const LL inf = 0x3f3f3f3f3f3f3f3f;const double eps = 1e-8;void f() &#123;#ifndef ONLINE_JUDGE freopen("../data.in", "r", stdin);#endif return;&#125;int n, m;struct edge &#123; int to, next; LL w;&#125; eg[maxn * 10];int head[maxn], tot;LL cost[maxn];void init() &#123; memset(head, -1, sizeof(head)); tot = 0;&#125;void add(int u, int v, LL w) &#123; eg[tot].to = v; eg[tot].w = w; eg[tot].next = head[u]; head[u] = tot++;&#125;LL dis[maxn][maxn];void dij(int u) &#123; memset(cost, inf, sizeof(cost)); priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; q; cost[u] = 0; q.push(P(cost[u], u)); while (q.size()) &#123; int v = q.top().second; LL w = q.top().first; q.pop(); if (cost[v] &lt; w)continue; else &#123; for (int i = head[v]; i != -1; i = eg[i].next) &#123; edge &amp;e = eg[i]; if (cost[e.to] &gt; w + e.w) &#123; cost[e.to] = w + e.w; q.push(P(cost[e.to], e.to)); &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; dis[u][i] = cost[i]; &#125;&#125;int q;LL s[maxn], to[maxn], t[maxn];LL dp[maxn];LL k[maxn][maxn];LL mx[maxn][maxn];int solve(LL m) &#123; memset(dp, inf, sizeof(dp)); dp[0] = 0; for (int i = 1; i &lt;= q; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; LL ti = dp[j], flag = 1; ti = max(ti, t[i]); if(mx[j][i]+ti&gt;m)flag=0; ti+=k[j][i]; if (flag == 0)continue; else &#123; dp[i] = min(dp[i], ti + dis[to[i]][1]); &#125; &#125; &#125; for(int i=1;i&lt;=q;i++)&#123; if(dp[i]==dp[maxn-1])return 0; &#125; return 1;&#125;int main() &#123; f(); scanf("%d%d", &amp;n, &amp;m); init(); for (int i = 0; i &lt; m; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, w); &#125; for (int i = 1; i &lt;= n; i++) &#123; dij(i); &#125; scanf("%d", &amp;q); to[0] = 1; for (int i = 1; i &lt;= q; i++) &#123; scanf("%lld%lld%lld", &amp;s[i], &amp;to[i], &amp;t[i]); &#125; for (int i = 1; i &lt;= q; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; LL ti,m=-inf; ti=0; int pos = j + 1, lat = 1; while (pos &lt;= i) &#123; ti += dis[lat][to[pos]]; if (ti - s[pos] &gt; m ) &#123; m=ti - s[pos]; &#125; lat = to[pos]; pos++; &#125; k[j][i]=ti; mx[j][i]=m; &#125; &#125; LL l = -1, r =inf; while (r &gt; l + 1) &#123; if (solve(mid))r = mid; else l = mid; &#125; printf("%lld\n", r); return 0;&#125; E. Explosion ExploitËøôÈ¢òÁ´üÁÑ∂Ê≤°ÊÉ≥Âà∞Áî® Á±ª‰ººÁä∂ÂéãDP‰∫ÜÔºåËøò‰∏ÄÁõ¥ÊÉ≥ÊÄé‰πàÂçÅÁª¥Êï∞ÁªÑ‰∫ÜÔºåÂîâ„ÄÇÁõ¥Êé•Áî®‰∏Ä‰∏™long long Êï¥Êï∞ÔºåÂâç5‰Ωç‰øùÂ≠òËá™Â∑±Â∞èÂÖµÁöÑÂÄºÔºåÂêé5‰Ωç‰øùÂ≠òÂØπÈù¢Â∞èÂÖµÁöÑÂÄº„ÄÇÂêéÊù•ÂèëÁé∞ËøôÊ†∑ÂÜôÂ§çÊùÇÂ∫¶Ëøá‰∏çÂéª„ÄÇÂ∞±ÁÆóÊòØËÆ∞ÂøÜÂåñÊêúÁ¥¢ËøòÊòØÈîôÁöÑ„ÄÇÂ∫îËØ•Áî®6‰ΩçÊù•‰øùÂ≠òËøòÂâ©Â§öÂ∞ëÁÇπË°ÄÁöÑÂ∞èÂÖµÁöÑ‰∏™Êï∞„ÄÇÂõ†‰∏∫ ÂâçÈù¢‰∏ÄÁßçÊêúÁ¥¢Ôºå31300Âíå 13300‰∏çÊòØÂêå‰∏ÄÁßçÁä∂ÊÄÅÔºåÈô§ÈùûÊéí‰∏Ä‰∏ãÂ∫è„ÄÇËÄåÂêéÈù¢Ëøô‰∏ÄÁßç‰øùÂ≠òÊñπÂºèÔºåÂÖ®ÈÉ®ÈÉΩÊòØ102„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf("*********\n");#define debug(x) cout&lt;&lt;"["&lt;&lt;x&lt;&lt;"]" &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;map&lt;LL,double&gt;mp;int n,m,k;double dfs(LL a,int u) &#123; if(mp.count(a)) &#123; return mp[a]; &#125; LL b=a; LL ans=0,a1=0,a2=0; for(int i=0; i&lt;12; i++) &#123; if(i&gt;=6) &#123; if(b%10!=0)a2+=b%10; b/=10; continue; &#125; ans+=(b%10)*(6-i); if(b%10!=0)a1+=b%10; b/=10; &#125;// debug(ans&lt;&lt;"a="&lt;&lt;a2); if(ans==0) &#123; mp[a]=1; return 1; &#125; if(ans&gt;u) &#123; mp[a]=0; return 0; &#125; double tp=0; if(a2==0) &#123; mp[a]=1; return 1; &#125; else &#123; LL tk=1; b=a; for(int i=0; i&lt;12; i++) &#123; if(b%10!=0) &#123; if(i==11||i==5)&#123; tp+=dfs(a-tk,u-1)*(b%10)*1.0/(a1+a2); &#125; else if(i&lt;6)&#123; tp+=dfs(a-tk+tk*10,u-1)*(b%10)*1.0/(a1+a2); &#125; else tp+=dfs(a-tk+tk*10,u-1)*(b%10)*1.0/(a1+a2); &#125; b/=10; tk*=10; &#125; &#125; mp[a]=tp; return tp;&#125;LL a;int b[2][10];int main() &#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=0 ; i&lt;n; i++) &#123; int p; scanf("%d",&amp;p); b[0][p]++; &#125; for(int i=0; i&lt;m; i++) &#123; int p; scanf("%d",&amp;p); b[1][p]++; &#125; for(int i=1; i&lt;=6; i++) &#123; a=a*10+b[0][i]; &#125; for(int i=1; i&lt;=6; i++) &#123; a=a*10+b[1][i]; &#125; printf("%.10f\n",dfs(a,k)); return 0;&#125;/*2 2 31 11 2*/ F * G Ëøô‰∏§È¢òÊúâÁÇπÈöæÔºåÊ≤°ÂÜôÂá∫Êù•„ÄÇ„ÄÇ„ÄÇÁ©∫ÁùÄ„ÄÇ„ÄÇ H. House LawnÈòüÂèãÂÜôÁöÑ„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;typedef long long LL;typedef long double lb;typedef pair&lt;int, int&gt; P;#define debug(x) cout&lt;&lt;"["&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define bug cout&lt;&lt;"*******************"&lt;&lt;endl;#define mem(a,b) memset(a,b,sizeof(a));#define fi first#define se second#define pb(x) push_back(x)const LL mod = 1e9+7;const int inf=0x3f3f3f3f;const int INF=0x7fffffff;const double eps = 1e-7;const double pi = acos(-1);const int maxn=1e6+5;int n, sum;string s, name[106];int stak[106], top = 0;int minp;struct node &#123; int id; LL p, c, t, r;&#125; lawn[107];LL solve(LL tm, LL tp, LL c, LL t, LL r) &#123; return (c*t*(tp/(t+r)))/sum;&#125;int main() &#123; //scanf("%d%d", &amp;sum, &amp;n); cin &gt;&gt; sum &gt;&gt; n; int ans = inf; int p, c, t, r; minp = INF; getchar(); for(int i = 1, len; i &lt;= n; ++i) &#123; getline(cin, s); len = s.length(); int tmp = 0; for(; s[tmp] != ',';++tmp) ; name[i] = s.substr(0, tmp); //cout &lt;&lt; name[i] &lt;&lt; endl; p = c = t = r = 0; for(++tmp; s[tmp] != ',';++tmp) p = p*10+s[tmp]-'0'; for(++tmp; s[tmp] != ',';++tmp) c = c*10+s[tmp]-'0'; for(++tmp; s[tmp] != ',';++tmp) t = t*10+s[tmp]-'0'; for(++tmp; tmp &lt; len;++tmp) r = r*10+s[tmp]-'0'; //cout &lt;&lt; p &lt;&lt;" "&lt;&lt; c &lt;&lt;" "&lt;&lt; t &lt;&lt;" "&lt;&lt; r &lt;&lt; endl; //cin &gt;&gt; p &gt;&gt; c &gt;&gt; t &gt;&gt; r; //scanf("%d%d%d%d", &amp;p, &amp;c, &amp;t, &amp;r); lawn[i].id = i; lawn[i].p = p; lawn[i].c = c; lawn[i].t = t; lawn[i].r = r; &#125; for(int i = 1; i &lt;= n; ++i) &#123; LL tp = 10080LL * (lawn[i].t+lawn[i].r) / __gcd(10080LL , 1LL*(lawn[i].t+lawn[i].r)); LL T = tp / 10080; LL tot = sum * T; LL tt = solve(tot, tp, lawn[i].c, lawn[i].t, lawn[i].r); //printf("i: %d, T: %lld, tp: %lld, tt: %lld\n", i, T, tp, tt); if(tt &gt;= T) &#123; //printf("OK\n"); if(minp &gt; lawn[i].p) &#123; minp = lawn[i].p; top = 1; stak[top] = lawn[i].id; &#125; else if(minp == lawn[i].p) &#123; top ++; stak[top] = lawn[i].id; &#125; &#125; &#125; for(int i = 1; i &lt;= top; ++i) &#123; cout &lt;&lt; name[stak[i]] &lt;&lt; "\n"; &#125; if(top == 0) cout &lt;&lt; "no such mower\n"; //printf("%d\n", ans); return 0;&#125;/*7000 49999 10 120 120999 1 120 2405499 2 25 355499 3 25 3510000 3aaa,1,1,1,1bbb,1,10000,10080,1ccc,1,10000,10079,1*/ I. Intergalactic BiddingÂ§ßÊï∞ÔºåÊéíÂ∫è,Ê≤°‰∫Ü„ÄÇ„ÄÇÂõ†‰∏∫‰øùËØÅ ‰∏Ä‰∏™ÂÄºÁ≠â‰∫éÂè¶‰∏Ä‰∏™ÂÄºÁöÑ2ÂÄç‰ª•‰∏ä„ÄÇÊâÄ‰ª•Êúâ‰∏îÂè™Êúâ‰∏ÄÁßçÊÉÖÂÜµ„ÄÇËÉΩÈÄâÂ∞±‰∏ÄÂÆöË¶ÅÈÄâ‰∏ä123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;typedef long long LL;typedef long double lb;typedef pair&lt;int, int&gt; P;#define debug(x) cout&lt;&lt;"["&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define bug cout&lt;&lt;"*******************"&lt;&lt;endl;#define mem(a,b) memset(a,b,sizeof(a));#define fi first#define se second#define pb(x) push_back(x)const LL mod = 1e9+7;const int inf=0x3f3f3f3f;const int INF=0x7fffffff;const double eps = 1e-7;const double pi = acos(-1);const int maxn=1e6+5;const int MAXL = 6e3+5;const int MAXN = 9999;const int DLEN = 4 ;class big &#123;public: int a[MAXN],len; big (const char *s) &#123; int t,k,index=0,L=strlen(s); memset(a,0,sizeof(a)); len=L/DLEN; if(L%DLEN) len++; for(int i = L-1; i&gt;=0; i-=DLEN) &#123; t=0; k=i-DLEN + 1; if(k&lt;0) k=0; for(int j = k; j &lt;=i ; j++) t=t*10+s[j]-'0'; a[index++]=t; &#125; &#125; bool operator&lt;(const big &amp;t) const &#123; int ln; if(len&gt;t.len) return false; else if(len==t.len) &#123; ln=len-1; while(a[ln]==t.a[ln]&amp;&amp;ln&gt;=0) ln--; if(ln&gt;=0&amp;&amp;a[ln]&gt;t.a[ln]) return false; else return true; &#125; else return true; &#125; big operator-(const big &amp;T)const &#123; bool flag; big t1=*this,t2=T; flag=0; int b=t1.len; for(int i=0,j; i&lt;b; i++) &#123; if(t1.a[i]&lt;t2.a[i]) &#123; if(j=i+1); while(t1.a[j]==0) j++; t1.a[j--]--; while(j&gt;i) t1.a[j--]+=MAXN; t1.a[i]+=MAXN+1-t2.a[i]; &#125; else t1.a[i]-=t2.a[i]; &#125; t1.len=b; while(t1.a[t1.len-1]==0&amp;&amp;t1.len&gt;1) t1.len--,b--; return t1; &#125; void print() &#123; printf("%d",a[len-1]); for(int i=len-2; i&gt;=0; i--) &#123; printf("%04d",a[i]); &#125; &#125;&#125;;typedef pair&lt;big,string&gt; PS;vector&lt;PS&gt; v;int main() &#123; int n; char s[1005]; scanf("%d%s",&amp;n,s); big mx(s);// debug((mx&lt;big("0")&amp;&amp;big("0")&lt;mx));// mx.print(); char nam[100]; for(int i=0; i&lt;n; i++) &#123; scanf("%s%s",nam,s); v.push_back(PS(s,nam)); &#125; sort(v.begin(),v.end()); int l=v.size(); vector&lt;string&gt; ans; while(l--&gt;0) &#123; big b=v[l].first; if(b&lt;mx) &#123; ans.pb(v[l].se); mx=mx-b; &#125; &#125; big temp("0"); if(!(temp&lt;mx&amp;&amp;mx&lt;temp)) &#123; printf("0\n"); return 0; &#125; printf("%d\n",ans.size()); for(auto i:ans) &#123; cout&lt;&lt;i&lt;&lt;"\n"; &#125; return 0;&#125; J. Jumbled StringÈ¶ñÂÖàÊõ¥ÂÖ∑a,dÁÆóÂá∫ÊúâÂ§öÂ∞ë‰∏™0 Âíå 1 ÁâπÂà§‰∏Ä‰∏ãÂè™Êúâ‰∏Ä‰∏™1ÁöÑÊÉÖÂÜµ„ÄÇÊõ¥ÂÖ∑Ëøô‰∏™ÂèØ‰ª•Âà§Êñ≠Âá∫ 01 10 Ëøô‰∏§ÁßçÂ≠óÁ¨¶‰∏≤Â∞±ÊòØ 0 Âú®1ÂâçÈù¢Âíå1Âú®0ÂâçÈù¢ÂèàÂ§öÂ∞ë‰∏™ÔºåËøòÂèØ‰ª•ÂèëÁé∞0Âú®1ÂâçÈù¢Âíå1Âú®0ÂâçÈù¢ÁöÑÊÄªÂíåÊòØ‰∏ÄÊ†∑ÁöÑÔºåÊõ¥ÂÖ∑Ëøô‰∏™ÂèØ‰ª•Âà§Êñ≠ÊúâÊ≤°ÊúâËøôÊ†∑ÁöÑÂ≠óÁ¨¶‰∏≤„ÄÇÁÑ∂ÂêéÂú®Èöè‰æøÊûÑÈÄ†‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤Â∞±Ë°å‰∫Ü„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;typedef long long LL;typedef long double lb;typedef pair&lt;int, int&gt; P;#define debug(x) cout&lt;&lt;"["&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define bug cout&lt;&lt;"*******************"&lt;&lt;endl;#define mem(a,b) memset(a,b,sizeof(a));#define fi first#define se second#define pb(x) push_back(x)const LL mod = 1e9+7;const int inf=0x3f3f3f3f;const int INF=0x7fffffff;const double eps = 1e-7;const double pi = acos(-1);const int maxn=1e6+5;LL a,b,c,d;LL zn=-1,on=-1;int main() &#123; while(~scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;d)) &#123; for(LL i=0; i&lt;1e5; i++) &#123; if(i*(i-1)&gt;2*a) &#123; break; &#125; else if(i*(i-1)==2*a) &#123; zn=i; &#125; &#125; for(LL i=0; i&lt;1e5; i++) &#123; if(i*(i-1)&gt;2*d) &#123; break; &#125; else if(i*(i-1)==2*d) &#123; on=i; &#125; &#125; if(a==0) &#123; if(b!=0||c!=0) &#123; zn=1; &#125; else zn=0; &#125; if(d==0) &#123; if(b!=0||c!=0) &#123; on=1; &#125; else on=0; &#125;// debug(zn);// debug(on); if(((b+c)!=on*zn)||zn==-1||on==-1) &#123; puts("impossible"); &#125; else &#123; LL k=(on==0)?0:((on*zn)-b)/on,num=(on==0)?0:((on*zn)-b)%on;// debug(k);// debug(num); for(int i=0; i&lt;zn+on; i++) &#123; if(i&lt;zn-k-1) &#123; printf("0"); &#125; else if(i&gt;zn+on-k-1) &#123; printf("0"); &#125; else if(i==zn-k+num-1) &#123; printf("0"); &#125; else printf("1"); &#125; puts(""); &#125; &#125; return 0;&#125; K. King‚Äôs ColorsÈòüÂèãÂÜôÁöÑ„ÄÇ„ÄÇ„ÄÇ‰∏çËøáËøôÈ¢òÂ∞±ÊòØ‰∏Ä‰∏™ÂÆπÊñ•ÔºåÊòØ‰∏ÄÈ¢óÊ†ëÔºåÊâÄ‰ª•ËÉΩÂ§ü‰øùËØÅ‰∏Ä‰∏™ËäÇÁÇπÁöÑÊüìËâ≤Âè™Âêà‰∏Ä‰∏™ËäÇÁÇπÊúâÂÖ≥„ÄÇ12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;typedef long long LL;typedef long double lb;typedef pair&lt;int, int&gt; P;#define debug(x) cout&lt;&lt;"["&lt;&lt;x&lt;&lt;"]"&lt;&lt;endl;#define bug cout&lt;&lt;"*******************"&lt;&lt;endl;#define mem(a,b) memset(a,b,sizeof(a));#define fi first#define se second#define pb(x) push_back(x)const LL mod = 1e9+7;const int inf=0x3f3f3f3f;const int INF=0x7fffffff;const double eps = 1e-7;const double pi = acos(-1);const int maxn=1e6+5;char s[10];int rint(char* t) &#123; int l=strlen(t); if(t[0]&lt;'0'||t[0]&gt;'9') &#123; return -1; &#125; else &#123; int i=0,ans=0; while(i&lt;l)&#123; ans=ans*10+t[i]-'0'; i++; &#125; return ans; &#125;&#125;//int a[maxn];LL ksm(LL a, int b) &#123; LL res = 1; for(;b;b&gt;&gt;=1,a=a*a%mod) &#123; if(b&amp;1) res = res*a%mod; &#125; return res;&#125;LL C[3005][3005];int main() &#123; C[1][1] = 1; for(int i = 2; i &lt; 3000; ++i) &#123; for(int j = 1; j &lt;= i; ++j) &#123; C[i][j] = (C[i-1][j]+C[i-1][j-1])%mod; &#125; &#125; LL n, k; scanf("%lld%lld",&amp;n, &amp;k); for(int i = 1, x; i &lt; n; ++i) &#123; scanf("%d", &amp;x); &#125; LL ans = 0, tmp; for(LL i = k, j = 0; i &gt;= 2; --i, j = !j) &#123; tmp = C[k+1][i+1] * i % mod * ksm(i-1, n-1) % mod; if(j == 0) ans = (ans+tmp)%mod; else ans = (ans - tmp)%mod; &#125; printf("%lld\n", (ans+mod)%mod); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>ÊØîËµõ</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HexoNext‰∏Ä‰∫õÊìç‰Ωú]]></title>
    <url>%2F2019%2F03%2F16%2FHexoNext%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Êõ¥ÊîπÂ§¥ÂÉè1.Âú®‰∏ªÈ¢òÈÖçÁΩÆÊñá‰ª∂‰∏≠ÊêúÁ¥¢ avatar2.3.ÊâæÂà∞Ëøô‰∏™Ë∑ØÂæÑ‰øÆÊîπÂ∞±Ë°å‰∫Ü„ÄÇ4. Ê∑ªÂä†‰∏™‰∫∫cssthemes\next\source\css\_custom‰øÆÊîπËøô‰∏™Êñá‰ª∂ 12345678910111213141516171819202122232425262728293031323334353637// Custom styles.@media screen and (min-width:1200px) &#123; body &#123; background:url(https://i.loli.net/2019/03/01/5c7942720fc39.png); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%; background-size: cover; &#125; #footer a &#123; color:#eee; &#125; .main-inner &#123; margin-top: 10px; opacity: 0.8; &#125; .header-inner &#123; margin-top: 10px; position: absolute; top: auto; overflow: hidden; padding: 0; width: 240px; background: #fff; box-shadow: initial; border-radius: initial; opacity: 1; &#125; .post &#123; margin-bottom: 30px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125;&#125;]]></content>
      <categories>
        <category>ÈÖçÁΩÆ</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>ÈÖçÁΩÆ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[‰ΩøÁî®VScode Ë∞ÉËØïÁöÑÊó∂ÂÄôÊèêÁ§∫Unable to start debugging]]></title>
    <url>%2F2019%2F03%2F02%2F%E4%BD%BF%E7%94%A8VScode%20%E8%B0%83%E8%AF%95%E7%9A%84%E6%97%B6%E5%80%99%E6%8F%90%E7%A4%BAUnable%20to%20start%20debugging%2F</url>
    <content type="text"><![CDATA[‰ΩøÁî®VScode Ë∞ÉËØïÁöÑÊó∂ÂÄôÊèêÁ§∫Unable to start debugging. Launch options string provided by the project system is invalid. Unable to determine path to debugger. Please specify the ‚ÄúMIDebuggerPath‚Äù option. ÊèêÁ§∫Ëøô‰∏™ÈîôËØØ„ÄÇ ÁøªËØëËøáÊù•Â∞±ÊòØ miDebuggerPath‰ªñÂá∫Èîô‰∫Ü„ÄÇ Â¶ÇÊûú‰Ω†ÊòØÂú®linux ‰∏ãÊåâÁÖßÂÆòÁΩëÁöÑÈô™Â∫îËØ•Â∞±ÊòØ Ëøô‰∏™Âú∞ÊñπÈô™Èîô‰∫ÜÔºåË¶ÅÂÖà‰∏ãËΩΩgdb Âú®ÁªàÁ´ØËæìÂÖ• apt-get install gdb ÁÑ∂ÂêéÊäägdbÁöÑË∑ØÂæÑ‰∏¢ËøõÂéªÂ∞±Ë°å‰∫Ü„ÄÇ]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Deepin VSCODEÂÆâË£ÖC++ÁéØÂ¢É]]></title>
    <url>%2F2019%2F03%2F02%2FDeepin-VSCODE%E5%AE%89%E8%A3%85C%2B%2B%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[È¶ñÂÖà]]></content>
      <categories>
        <category>ÈÖçÁΩÆ</category>
      </categories>
      <tags>
        <tag>ÈÖçÁΩÆ</tag>
        <tag>VScode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublimeÂø´Êç∑ÈîÆÈõÜÂêà]]></title>
    <url>%2F2019%2F03%2F02%2Fsublime%E5%BF%AB%E6%8D%B7%E9%94%AE%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Sublime Text 3 Âø´Êç∑ÈîÆÂàóË°®ÔºöÁ≤æÂçéÁâà Ctrl+Shift+PÔºöÊâìÂºÄÂëΩ‰ª§Èù¢Êùø Ctrl+PÔºöÊêúÁ¥¢È°πÁõÆ‰∏≠ÁöÑÊñá‰ª∂ Ctrl+GÔºöË∑≥ËΩ¨Âà∞Á¨¨Âá†Ë°å Ctrl+WÔºöÂÖ≥Èó≠ÂΩìÂâçÊâìÂºÄÊñá‰ª∂ Ctrl+Shift+WÔºöÂÖ≥Èó≠ÊâÄÊúâÊâìÂºÄÊñá‰ª∂ Ctrl+Shift+VÔºöÁ≤òË¥¥Âπ∂Ê†ºÂºèÂåñ Ctrl+DÔºöÈÄâÊã©ÂçïËØçÔºåÈáçÂ§çÂèØÂ¢ûÂä†ÈÄâÊã©‰∏ã‰∏Ä‰∏™Áõ∏ÂêåÁöÑÂçïËØç Ctrl+LÔºöÈÄâÊã©Ë°åÔºåÈáçÂ§çÂèØ‰æùÊ¨°Â¢ûÂä†ÈÄâÊã©‰∏ã‰∏ÄË°å Ctrl+Shift+LÔºöÈÄâÊã©Â§öË°å Ctrl+Shift+EnterÔºöÂú®ÂΩìÂâçË°åÂâçÊèíÂÖ•Êñ∞Ë°å Ctrl+XÔºöÂà†Èô§ÂΩìÂâçË°å Ctrl+MÔºöË∑≥ËΩ¨Âà∞ÂØπÂ∫îÊã¨Âè∑ Ctrl+UÔºöËΩØÊí§ÈîÄÔºåÊí§ÈîÄÂÖâÊ†á‰ΩçÁΩÆ Ctrl+JÔºöÈÄâÊã©Ê†áÁ≠æÂÜÖÂÆπ Ctrl+FÔºöÊü•ÊâæÂÜÖÂÆπ Ctrl+Shift+FÔºöÊü•ÊâæÂπ∂ÊõøÊç¢ Ctrl+HÔºöÊõøÊç¢ Ctrl+RÔºöÂâçÂæÄ method Ctrl+NÔºöÊñ∞Âª∫Á™óÂè£ Ctrl+K+BÔºöÂºÄÂÖ≥‰æßÊ†è Ctrl+Shift+MÔºöÈÄâ‰∏≠ÂΩìÂâçÊã¨Âè∑ÂÜÖÂÆπÔºåÈáçÂ§çÂèØÈÄâÁùÄÊã¨Âè∑Êú¨Ë∫´ Ctrl+F2ÔºöËÆæÁΩÆ/Âà†Èô§Ê†áËÆ∞ Ctrl+/ÔºöÊ≥®ÈáäÂΩìÂâçË°å Ctrl+Shift+/ÔºöÂΩìÂâç‰ΩçÁΩÆÊèíÂÖ•Ê≥®Èáä Ctrl+Alt+/ÔºöÂùóÊ≥®ÈáäÔºåÂπ∂FocusÂà∞È¶ñË°åÔºåÂÜôÊ≥®ÈáäËØ¥ÊòéÁî®ÁöÑ Ctrl+Shift+AÔºöÈÄâÊã©ÂΩìÂâçÊ†áÁ≠æÂâçÂêéÔºå‰øÆÊîπÊ†áÁ≠æÁî®ÁöÑ F11ÔºöÂÖ®Â±è Shift+F11ÔºöÂÖ®Â±èÂÖçÊâìÊâ∞Ê®°ÂºèÔºåÂè™ÁºñËæëÂΩìÂâçÊñá‰ª∂ Alt+F3ÔºöÈÄâÊã©ÊâÄÊúâÁõ∏ÂêåÁöÑËØç Alt+.ÔºöÈó≠ÂêàÊ†áÁ≠æ Alt+Shift+Êï∞Â≠óÔºöÂàÜÂ±èÊòæÁ§∫ Alt+Êï∞Â≠óÔºöÂàáÊç¢ÊâìÂºÄÁ¨¨N‰∏™Êñá‰ª∂ Shift+Âè≥ÈîÆÊãñÂä®ÔºöÂÖâÊ†áÂ§ö‰∏çÔºåÁî®Êù•Êõ¥ÊîπÊàñÊèíÂÖ•ÂàóÂÜÖÂÆπ Èº†Ê†áÁöÑÂâçËøõÂêéÈÄÄÈîÆÂèØÂàáÊç¢TabÊñá‰ª∂ ÊåâCtrlÔºå‰æùÊ¨°ÁÇπÂáªÊàñÈÄâÂèñÔºåÂèØÈúÄË¶ÅÁºñËæëÁöÑÂ§ö‰∏™‰ΩçÁΩÆ ÊåâCtrl+Shift+‰∏ä‰∏ãÈîÆÔºåÂèØÊõøÊç¢Ë°å ÈÄâÊã©Á±ª Ctrl+D ÈÄâ‰∏≠ÂÖâÊ†áÊâÄÂç†ÁöÑÊñáÊú¨ÔºåÁªßÁª≠Êìç‰ΩúÂàô‰ºöÈÄâ‰∏≠‰∏ã‰∏Ä‰∏™Áõ∏ÂêåÁöÑÊñáÊú¨„ÄÇ Alt+F3 ÈÄâ‰∏≠ÊñáÊú¨Êåâ‰∏ãÂø´Êç∑ÈîÆÔºåÂç≥ÂèØ‰∏ÄÊ¨°ÊÄßÈÄâÊã©ÂÖ®ÈÉ®ÁöÑÁõ∏ÂêåÊñáÊú¨ËøõË°åÂêåÊó∂ÁºñËæë„ÄÇ‰∏æ‰∏™Ê†óÂ≠êÔºöÂø´ÈÄüÈÄâ‰∏≠Âπ∂Êõ¥ÊîπÊâÄÊúâÁõ∏ÂêåÁöÑÂèòÈáèÂêç„ÄÅÂáΩÊï∞ÂêçÁ≠â„ÄÇ Ctrl+L ÈÄâ‰∏≠Êï¥Ë°åÔºåÁªßÁª≠Êìç‰ΩúÂàôÁªßÁª≠ÈÄâÊã©‰∏ã‰∏ÄË°åÔºåÊïàÊûúÂíå Shift+‚Üì ÊïàÊûú‰∏ÄÊ†∑„ÄÇ Ctrl+Shift+L ÂÖàÈÄâ‰∏≠Â§öË°åÔºåÂÜçÊåâ‰∏ãÂø´Êç∑ÈîÆÔºå‰ºöÂú®ÊØèË°åË°åÂ∞æÊèíÂÖ•ÂÖâÊ†áÔºåÂç≥ÂèØÂêåÊó∂ÁºñËæëËøô‰∫õË°å„ÄÇ Ctrl+Shift+M ÈÄâÊã©Êã¨Âè∑ÂÜÖÁöÑÂÜÖÂÆπÔºàÁªßÁª≠ÈÄâÊã©Áà∂Êã¨Âè∑Ôºâ„ÄÇ‰∏æ‰∏™Ê†óÂ≠êÔºöÂø´ÈÄüÈÄâ‰∏≠Âà†Èô§ÂáΩÊï∞‰∏≠ÁöÑ‰ª£Á†ÅÔºåÈáçÂÜôÂáΩÊï∞‰Ωì‰ª£Á†ÅÊàñÈáçÂÜôÊã¨Âè∑ÂÜÖÈáåÁöÑÂÜÖÂÆπ„ÄÇ Ctrl+M ÂÖâÊ†áÁßªÂä®Ëá≥Êã¨Âè∑ÂÜÖÁªìÊùüÊàñÂºÄÂßãÁöÑ‰ΩçÁΩÆ„ÄÇ Ctrl+Enter Âú®‰∏ã‰∏ÄË°åÊèíÂÖ•Êñ∞Ë°å„ÄÇ‰∏æ‰∏™Ê†óÂ≠êÔºöÂç≥‰ΩøÂÖâÊ†á‰∏çÂú®Ë°åÂ∞æÔºå‰πüËÉΩÂø´ÈÄüÂêë‰∏ãÊèíÂÖ•‰∏ÄË°å„ÄÇ Ctrl+Shift+Enter Âú®‰∏ä‰∏ÄË°åÊèíÂÖ•Êñ∞Ë°å„ÄÇ‰∏æ‰∏™Ê†óÂ≠êÔºöÂç≥‰ΩøÂÖâÊ†á‰∏çÂú®Ë°åÈ¶ñÔºå‰πüËÉΩÂø´ÈÄüÂêë‰∏äÊèíÂÖ•‰∏ÄË°å„ÄÇ Ctrl+Shift+[ ÈÄâ‰∏≠‰ª£Á†ÅÔºåÊåâ‰∏ãÂø´Êç∑ÈîÆÔºåÊäòÂè†‰ª£Á†Å„ÄÇ Ctrl+Shift+] ÈÄâ‰∏≠‰ª£Á†ÅÔºåÊåâ‰∏ãÂø´Êç∑ÈîÆÔºåÂ±ïÂºÄ‰ª£Á†Å„ÄÇ Ctrl+K+0 Â±ïÂºÄÊâÄÊúâÊäòÂè†‰ª£Á†Å„ÄÇ Ctrl+‚Üê ÂêëÂ∑¶Âçï‰ΩçÊÄßÂú∞ÁßªÂä®ÂÖâÊ†áÔºåÂø´ÈÄüÁßªÂä®ÂÖâÊ†á„ÄÇ Ctrl+‚Üí ÂêëÂè≥Âçï‰ΩçÊÄßÂú∞ÁßªÂä®ÂÖâÊ†áÔºåÂø´ÈÄüÁßªÂä®ÂÖâÊ†á„ÄÇ shift+‚Üë Âêë‰∏äÈÄâ‰∏≠Â§öË°å„ÄÇ shift+‚Üì Âêë‰∏ãÈÄâ‰∏≠Â§öË°å„ÄÇ Shift+‚Üê ÂêëÂ∑¶ÈÄâ‰∏≠ÊñáÊú¨„ÄÇ Shift+‚Üí ÂêëÂè≥ÈÄâ‰∏≠ÊñáÊú¨„ÄÇ Ctrl+Shift+‚Üê ÂêëÂ∑¶Âçï‰ΩçÊÄßÂú∞ÈÄâ‰∏≠ÊñáÊú¨„ÄÇ Ctrl+Shift+‚Üí ÂêëÂè≥Âçï‰ΩçÊÄßÂú∞ÈÄâ‰∏≠ÊñáÊú¨„ÄÇ Ctrl+Shift+‚Üë Â∞ÜÂÖâÊ†áÊâÄÂú®Ë°åÂíå‰∏ä‰∏ÄË°å‰ª£Á†Å‰∫íÊç¢ÔºàÂ∞ÜÂÖâÊ†áÊâÄÂú®Ë°åÊèíÂÖ•Âà∞‰∏ä‰∏ÄË°å‰πãÂâçÔºâ„ÄÇ Ctrl+Shift+‚Üì Â∞ÜÂÖâÊ†áÊâÄÂú®Ë°åÂíå‰∏ã‰∏ÄË°å‰ª£Á†Å‰∫íÊç¢ÔºàÂ∞ÜÂÖâÊ†áÊâÄÂú®Ë°åÊèíÂÖ•Âà∞‰∏ã‰∏ÄË°å‰πãÂêéÔºâ„ÄÇ Ctrl+Alt+‚Üë Âêë‰∏äÊ∑ªÂä†Â§öË°åÂÖâÊ†áÔºåÂèØÂêåÊó∂ÁºñËæëÂ§öË°å„ÄÇ Ctrl+Alt+‚Üì Âêë‰∏ãÊ∑ªÂä†Â§öË°åÂÖâÊ†áÔºåÂèØÂêåÊó∂ÁºñËæëÂ§öË°å„ÄÇ ÁºñËæëÁ±ª Ctrl+J ÂêàÂπ∂ÈÄâ‰∏≠ÁöÑÂ§öË°å‰ª£Á†Å‰∏∫‰∏ÄË°å„ÄÇ‰∏æ‰∏™Ê†óÂ≠êÔºöÂ∞ÜÂ§öË°åÊ†ºÂºèÁöÑCSSÂ±ûÊÄßÂêàÂπ∂‰∏∫‰∏ÄË°å„ÄÇ Ctrl+Shift+D Â§çÂà∂ÂÖâÊ†áÊâÄÂú®Êï¥Ë°åÔºåÊèíÂÖ•Âà∞‰∏ã‰∏ÄË°å„ÄÇ Tab ÂêëÂè≥Áº©Ëøõ„ÄÇ Shift+Tab ÂêëÂ∑¶Áº©Ëøõ„ÄÇ Ctrl+K+K ‰ªéÂÖâÊ†áÂ§ÑÂºÄÂßãÂà†Èô§‰ª£Á†ÅËá≥Ë°åÂ∞æ„ÄÇ Ctrl+Shift+K Âà†Èô§Êï¥Ë°å„ÄÇ Ctrl+/ Ê≥®ÈáäÂçïË°å„ÄÇ Ctrl+Shift+/ Ê≥®ÈáäÂ§öË°å„ÄÇ Ctrl+K+U ËΩ¨Êç¢Â§ßÂÜô„ÄÇ Ctrl+K+L ËΩ¨Êç¢Â∞èÂÜô„ÄÇ Ctrl+Z Êí§ÈîÄ„ÄÇ Ctrl+Y ÊÅ¢Â§çÊí§ÈîÄ„ÄÇ Ctrl+U ËΩØÊí§ÈîÄÔºåÊÑüËßâÂíå Gtrl+Z ‰∏ÄÊ†∑„ÄÇ Ctrl+F2 ËÆæÁΩÆ‰π¶Á≠æ Ctrl+T Â∑¶Âè≥Â≠óÊØç‰∫íÊç¢„ÄÇ F6 ÂçïËØçÊ£ÄÊµãÊãºÂÜô ÊêúÁ¥¢Á±ª Ctrl+F ÊâìÂºÄÂ∫ïÈÉ®ÊêúÁ¥¢Ê°ÜÔºåÊü•ÊâæÂÖ≥ÈîÆÂ≠ó„ÄÇ Ctrl+shift+F Âú®Êñá‰ª∂Â§πÂÜÖÊü•ÊâæÔºå‰∏éÊôÆÈÄöÁºñËæëÂô®‰∏çÂêåÁöÑÂú∞ÊñπÊòØsublimeÂÖÅËÆ∏Ê∑ªÂä†Â§ö‰∏™Êñá‰ª∂Â§πËøõË°åÊü•ÊâæÔºåÁï•È´òÁ´ØÔºåÊú™Á†îÁ©∂„ÄÇ Ctrl+P ÊâìÂºÄÊêúÁ¥¢Ê°Ü„ÄÇ‰∏æ‰∏™Ê†óÂ≠êÔºö1„ÄÅËæìÂÖ•ÂΩìÂâçÈ°πÁõÆ‰∏≠ÁöÑÊñá‰ª∂ÂêçÔºåÂø´ÈÄüÊêúÁ¥¢Êñá‰ª∂Ôºå2„ÄÅËæìÂÖ•@ÂíåÂÖ≥ÈîÆÂ≠óÔºåÊü•ÊâæÊñá‰ª∂‰∏≠ÂáΩÊï∞ÂêçÔºå3„ÄÅËæìÂÖ•ÔºöÂíåÊï∞Â≠óÔºåË∑≥ËΩ¨Âà∞Êñá‰ª∂‰∏≠ËØ•Ë°å‰ª£Á†ÅÔºå4„ÄÅËæìÂÖ•#ÂíåÂÖ≥ÈîÆÂ≠óÔºåÊü•ÊâæÂèòÈáèÂêç„ÄÇ Ctrl+G ÊâìÂºÄÊêúÁ¥¢Ê°ÜÔºåËá™Âä®Â∏¶ÔºöÔºåËæìÂÖ•Êï∞Â≠óË∑≥ËΩ¨Âà∞ËØ•Ë°å‰ª£Á†Å„ÄÇ‰∏æ‰∏™Ê†óÂ≠êÔºöÂú®È°µÈù¢‰ª£Á†ÅÊØîËæÉÈïøÁöÑÊñá‰ª∂‰∏≠Âø´ÈÄüÂÆö‰Ωç„ÄÇ Ctrl+R ÊâìÂºÄÊêúÁ¥¢Ê°ÜÔºåËá™Âä®Â∏¶@ÔºåËæìÂÖ•ÂÖ≥ÈîÆÂ≠óÔºåÊü•ÊâæÊñá‰ª∂‰∏≠ÁöÑÂáΩÊï∞Âêç„ÄÇ‰∏æ‰∏™Ê†óÂ≠êÔºöÂú®ÂáΩÊï∞ËæÉÂ§öÁöÑÈ°µÈù¢Âø´ÈÄüÊü•ÊâæÊüê‰∏™ÂáΩÊï∞„ÄÇ Ctrl+Ôºö ÊâìÂºÄÊêúÁ¥¢Ê°ÜÔºåËá™Âä®Â∏¶#ÔºåËæìÂÖ•ÂÖ≥ÈîÆÂ≠óÔºåÊü•ÊâæÊñá‰ª∂‰∏≠ÁöÑÂèòÈáèÂêç„ÄÅÂ±ûÊÄßÂêçÁ≠â„ÄÇ Ctrl+Shift+P ÊâìÂºÄÂëΩ‰ª§Ê°Ü„ÄÇÂú∫ÊôØÊ†óÂ≠êÔºöÊâìÂºÄÂëΩÂêçÊ°ÜÔºåËæìÂÖ•ÂÖ≥ÈîÆÂ≠óÔºåË∞ÉÁî®sublime textÊàñÊèí‰ª∂ÁöÑÂäüËÉΩÔºå‰æãÂ¶Ç‰ΩøÁî®packageÂÆâË£ÖÊèí‰ª∂„ÄÇ Esc ÈÄÄÂá∫ÂÖâÊ†áÂ§öË°åÈÄâÊã©ÔºåÈÄÄÂá∫ÊêúÁ¥¢Ê°ÜÔºåÂëΩ‰ª§Ê°ÜÁ≠â„ÄÇ ÊòæÁ§∫Á±ª Ctrl+Tab ÊåâÊñá‰ª∂ÊµèËßàËøáÁöÑÈ°∫Â∫èÔºåÂàáÊç¢ÂΩìÂâçÁ™óÂè£ÁöÑÊ†áÁ≠æÈ°µ„ÄÇ Ctrl+PageDown ÂêëÂ∑¶ÂàáÊç¢ÂΩìÂâçÁ™óÂè£ÁöÑÊ†áÁ≠æÈ°µ„ÄÇ Ctrl+PageUp ÂêëÂè≥ÂàáÊç¢ÂΩìÂâçÁ™óÂè£ÁöÑÊ†áÁ≠æÈ°µ„ÄÇ Alt+Shift+1 Á™óÂè£ÂàÜÂ±èÔºåÊÅ¢Â§çÈªòËÆ§1Â±èÔºàÈùûÂ∞èÈîÆÁõòÁöÑÊï∞Â≠óÔºâ Alt+Shift+2 Â∑¶Âè≥ÂàÜÂ±è-2Âàó Alt+Shift+3 Â∑¶Âè≥ÂàÜÂ±è-3Âàó Alt+Shift+4 Â∑¶Âè≥ÂàÜÂ±è-4Âàó Alt+Shift+5 Á≠âÂàÜ4Â±è Alt+Shift+8 ÂûÇÁõ¥ÂàÜÂ±è-2Â±è Alt+Shift+9 ÂûÇÁõ¥ÂàÜÂ±è-3Â±è Ctrl+K+B ÂºÄÂêØ/ÂÖ≥Èó≠‰æßËæπÊ†è„ÄÇ F11 ÂÖ®Â±èÊ®°Âºè Shift+F11 ÂÖçÊâìÊâ∞Ê®°Âºè]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkdownËØ≠Ê≥ï]]></title>
    <url>%2F2019%2F02%2F27%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Ê≠§ÁâáÊñáÁ´†‰∏ªË¶ÅÁî®‰∫éËÆ∞ÂΩï‰∏Ä‰∫õÁÆÄÂçïÁöÑMarkdownËØ≠Ê≥ï&lt;/br&gt;&lt;/br&gt;&lt;/br&gt; Ê†áÈ¢ò123# Ê†áÈ¢ò1Á∫ß## Ê†áÈ¢ò2Á∫ß### Ê†áÈ¢ò3Á∫ß Ê†áÈ¢ò1Á∫ßÊ†áÈ¢ò2Á∫ßÊ†áÈ¢ò3Á∫ßÊñáÊú¨12345Ê≠£Â∏∏ÊñáÊú¨**Âä†Á≤óÊñáÊú¨***Êñú‰ΩìÊñáÊú¨ ****Êñú‰ΩìÂä†Á≤óÊñáÊú¨***~~‰∏≠Èó¥Âä†Á∫øÊñáÊú¨~~ Ê≠£Â∏∏ÊñáÊú¨Âä†Á≤óÊñáÊú¨Êñú‰ΩìÊñáÊú¨ Êñú‰ΩìÂä†Á≤óÊñáÊú¨‰∏≠Èó¥Âä†Á∫øÊñáÊú¨ ÂºïÁî®123456&gt;ÂºïÁî®&gt;&gt;‰∫åÁ∫ßÂºïÁî®&gt;&gt;&gt;‰ª•Ê≠§ÂÜÖÊé®&gt;ËøôÊòØÂºïÁî®ÁöÑÂÜÖÂÆπ&gt;&gt;ËøôÊòØÂºïÁî®ÁöÑÂÜÖÂÆπ&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;ËøôÊòØÂºïÁî®ÁöÑ ÂºïÁî® ‰∫åÁ∫ßÂºïÁî® ‰ª•Ê≠§ÂÜÖÊé®ËøôÊòØÂºïÁî®ÁöÑÂÜÖÂÆπËøôÊòØÂºïÁî®ÁöÑÂÜÖÂÆπ ËøôÊòØÂºïÁî®ÁöÑ ÂàÜÂâ≤Á∫ø1234---ÂàÜÂâ≤Á∫ø----- ÂàÜÂâ≤Á∫ø 1![ÂõæÁâá](https://i.loli.net/2019/02/27/5c767c74660a3.png) ÂõæÊèíÂÖ•1![ÂõæÁâáÂêç](images/MarkdownËØ≠Ê≥ï/20190301060640743.png) Ë∂ÖÈìæÊé•1[Ë∂ÖÈìæÊé•](http://baidu.com) Ë∂ÖÈìæÊé• ÂàóË°®Êó†Â∫èÂàóË°®12345- Êó†Â∫èÂàóË°®- 1- 1* 1* 2 Êó†Â∫èÂàóË°® 1 1 1 2ÊúâÂ∫èÂàóË°® 1231.ÂàóË°®12.ÂàóË°®23.ÊúâÂ∫èÂàóË°® 1.ÂàóË°®12.ÂàóË°®23.ÊúâÂ∫èÂàóË°® ÂàóË°®ÂµåÂ•ó123456- ÂàóË°®1 1.ÂàóË°®ÂµåÂ•ó 3.ÂàóË°®2 4.ÂàóË°®3- ÂàóË°®2 1.ÂàóË°® ‰∏ã‰∏ÄÁ∫ßÂâç3‰∏™Á©∫Ê†º ÂàóË°®1 1.ÂàóË°®ÂµåÂ•ó 3.ÂàóË°®2 4.ÂàóË°®3 ÂàóË°®2 1.ÂàóË°® Ë°®Ê†º1234Ë°®Â§¥|Ë°®Â§¥|Ë°®Â§¥---|:--:|---:ÂÜÖÂÆπ|ÂÜÖÂÆπ|ÂÜÖÂÆπÂÜÖÂÆπ|ÂÜÖÂÆπ|ÂÜÖÂÆπ Á¨¨‰∫åË°åÂàÜÂâ≤Ë°®Â§¥ÂíåÂÜÖÂÆπ„ÄÇ-Êúâ‰∏Ä‰∏™Â∞±Ë°åÔºå‰∏∫‰∫ÜÂØπÈΩêÔºåÂ§öÂä†‰∫ÜÂá†‰∏™ ÊñáÂ≠óÈªòËÆ§Â±ÖÂ∑¶-‰∏§ËæπÂä†ÔºöË°®Á§∫ÊñáÂ≠óÂ±Ö‰∏≠-Âè≥ËæπÂä†ÔºöË°®Á§∫ÊñáÂ≠óÂ±ÖÂè≥ Ë°®Â§¥ Ë°®Â§¥ Ë°®Â§¥ ÂÜÖÂÆπ ÂÜÖÂÆπ ÂÜÖÂÆπ ÂÜÖÂÆπ ÂÜÖÂÆπ ÂÜÖÂÆπ ‰ª£Á†ÅÂùó12345var num = 0;for (var i = 0; i &lt; 5; i++) &#123; num+=i;&#125;console.log(num); ``` (Ê≠§Â§ÑÂÜô‰ª£Á†ÅËØ≠Ë®Ä)‰∏≠Èó¥ÂèØÂÜôÂÖ•‰ª£Á†Å ``` ` ‰∏Ä‰∏™ÁÇπÂ∞èÂûãÂàÜÂùó]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVAÁéØÂ¢ÉÈÖçÁΩÆ]]></title>
    <url>%2F2019%2F02%2F27%2FJAVA%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Êú¨ÁØáÊñáÁ´†Áî®‰∫éËÆ∞ÂΩïJAVAÈÖçÁΩÆ„ÄÇ JAVAÂÆâË£ÖÔºåÁôæÂ∫¶ÊêúÁ¥¢JAVAÂÆòÁΩëÔºå‰∏ãËΩΩÂØπÂ∫îÁ≥ªÁªüÁâàÊú¨Ôºå‰∏ãËΩΩÂÆâË£ÖÂ•ΩÂêéÂ∫îËØ•Êúâ JDK ÂíåJDR ‰∏§‰∏™Êñá‰ª∂Â§π ÈÖçÁΩÆÁ≥ªÁªüÁéØÂ¢É(1)Êñ∞Âª∫-&gt;ÂèòÈáèÂêç‚ÄùJAVA_HOME‚ÄùÔºåÂèòÈáèÂÄº C:\Java\jdk1.8.0_05(‰Ω†ÁöÑJDKË∑ØÂæÑ)(2)Êñ∞Âª∫-&gt;ÂèòÈáèÂêç‚ÄúCLASSPATH‚Äù,ÂèòÈáèÂÄº .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;Á¨¨‰∏â‰∏™ÂèòÈáèÔºåÂ¶ÇÊûúÂ∑≤ÁªèÊúâ‰∫ÜPathÂèòÈáèÂ∫îËØ•Áõ¥Êé•ÁºñËæëÔºåÁÑ∂ÂêéÂÜçÂú®ËÉåÂêéÊ∑ªÂä†ÂèòÈáè(3)ÁºñËæë-&gt;ÂèòÈáèÂêç‚ÄùPath‚ÄùÔºåÂú®ÂéüÂèòÈáèÂÄºÁöÑÊúÄÂêéÈù¢Âä†‰∏ä ;%JAVA_HOME%\bin;%JAVA_HOME%\jre\binËøô‰∏™ÂèòÈáèÊ≤°ÈÖçÁΩÆÂ•Ω‰ºöÂá∫Áé∞Ê≤°ÊúâjavacËøô‰∏™Êåá‰ª§ ÂèòÈáèÂÄºÊòØ‰ª• Ôºõ Âå∫ÂàÜÂá†‰∏™ÂèòÈáèÂÄº„ÄÇÂú®win10ÊÉÖÂÜµ‰∏ãÔºåÁÇπÂáªÁºñËæëPathË∑ØÂæÑËÉΩÂ§üÁúãËßÅ‰∏Ä‰∏™ÂõæË°® ÈáåÈù¢Â≠òÊúâÂêÑ‰∏™ÂèòÈáèÂÄºÔºåÁÇπÂáªÁºñËæëÊñáÊú¨ÂèØ‰ª•ÁúãËßÅÂèòÈáèÂÄºÊñáÊú¨ÂΩ¢ÂºèÔºå‰∏§ËÄÖÂØπÁÖßÁúãÂ∫îËØ•Â∞±ËÉΩÊòéÁôΩÊÄé‰πàÁªôPathÊ∑ªÂä†‰∏Ä‰∏™Êñ∞ÁöÑÂèòÈáè„ÄÇ window Âú®ÊéßÂà∂Âè∞ËæìÂÖ•‰∏â‰∏™Êåá‰ª§ javaÔºåjavacÔºåjava -version Â¶ÇÊûúÊòæÁ§∫Ê≤°ÊúâËøô‰∏™Êåá‰ª§ËØ¥ÊòéÈÖçÁΩÆÈîôËØØ„ÄÇ]]></content>
      <categories>
        <category>ËÆ°ÁÆóÊú∫ËØ≠Ë®Ä</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>ÈÖçÁΩÆ</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next 6.0 ‰ª•‰∏äÁâàÊú¨ËÉåÊôØÂä®ÁîªCanvas_nestËÆæÁΩÆÊó†Êïà]]></title>
    <url>%2F2019%2F02%2F25%2FNext%206.0%20%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC%E8%83%8C%E6%99%AF%E5%8A%A8%E7%94%BBCanvas_nest%E8%AE%BE%E7%BD%AE%E6%97%A0%E6%95%88%2F</url>
    <content type="text"><![CDATA[ÊääËøô‰∏™‰∏ãËΩΩ‰∏Ä‰∏ã ËßÅÂÆòÊñπÊñáÊ°£ https://github.com/theme-next/theme-next-canvas-nest Âú®‰Ω†ÁöÑÂçöÂÆ¢ÁõÆÂΩï‰∏ã 1git clone https://github.com/theme-next/theme-next-canvas-nest themes/next/source/lib/canvas-nest Â∞±ÂèØ‰ª•‰∫Ü]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UnityÂÆâË£ÖÂ•ΩSDK JDK ËøòÊòØÊó†Ê≥ïÊâìÂåÖapp 2019ÁâàÊú¨ÈóÆÈ¢ò]]></title>
    <url>%2F2019%2F02%2F22%2FUnity%E5%AE%89%E8%A3%85%E5%A5%BDSDK%20JDK%20%E8%BF%98%E6%98%AF%E6%97%A0%E6%B3%95%E6%89%93%E5%8C%85app%20%20%202019%E7%89%88%E6%9C%AC%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[ÂÆâË£ÖÂ•ΩSDKÔºåJDKÔºåÊâìÁàÜÂÆâÂçìËΩØ‰ª∂ËøòÊòØÂá∫Èîô„ÄÇÂá∫Áé∞ÁâàÊú¨Â∞è‰∫Ü ÂºπÂá∫ÈîôËØØ CommandInvokationFailure: Failed to create a raw.ap_ package 1234567891011121314151617181920212223242526272829303132333435363738 CommandInvokationFailure: Failed to create a raw.ap_ packageH:\Program Files\Unity\Editor\Data\PlaybackEngines\AndroidPlayer/Tools\OpenJDK\Windows\bin\java.exe -Xmx4096M -Dcom.android.sdkmanager.toolsdir=&quot;H:/Program Files/android-sdk-windows\tools&quot; -Dfile.encoding=UTF8 -jar &quot;H:\Program Files\Unity\Editor\Data\PlaybackEngines\AndroidPlayer/Tools\sdktools.jar&quot; -stderr[Exception in thread &quot;main&quot; java.lang.reflect.InvocationTargetException at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at SDKMain.main(SDKMain.java:136)Caused by: java.lang.NoSuchMethodError: com.google.common.util.concurrent.MoreExecutors.directExecutor()Ljava/util/concurrent/Executor; at com.android.apkzlib.zip.ZFile.createSources(ZFile.java:1586) at com.android.apkzlib.zip.ZFile.makeStoredEntry(ZFile.java:1546) at com.android.apkzlib.zip.ZFile.add(ZFile.java:1625) at com.android.apkzlib.zip.ZFile.add(ZFile.java:1499) at com.android.apkzlib.sign.ManifestGenerationExtension.updateManifest(ManifestGenerationExtension.java:241) at com.android.apkzlib.sign.ManifestGenerationExtension.access$000(ManifestGenerationExtension.java:52) at com.android.apkzlib.sign.ManifestGenerationExtension$1.lambda$beforeUpdate$0(ManifestGenerationExtension.java:168) at com.android.apkzlib.zip.ZFile.notify(ZFile.java:2099) at com.android.apkzlib.zip.ZFile.update(ZFile.java:871) at com.android.apkzlib.zip.ZFile.close(ZFile.java:1161) at com.android.apkzlib.zfile.ApkZFileCreator.close(ApkZFileCreator.java:189) at UnityPackageBuilder.CreatePackage(UnityPackageBuilder.java:136) at UnityPackageBuilder.&lt;init&gt;(UnityPackageBuilder.java:70) at UnityPackageBuilder.main(UnityPackageBuilder.java:27) ... 5 more]stdout[]exit code: 1UnityEditor.Android.AndroidSDKTools.RunCommand (System.String javaExe, System.String sdkToolsDir, System.String[] sdkToolCommand, System.String workingdir, System.String errorMsg, System.Int32 memoryMB) (at &lt;7cbc688ae1af4105929402a46c6a4414&gt;:0)UnityEditor.Android.AndroidSDKTools.RunSDKToolWithReadLock (System.String[] command, System.String workingdir, System.String errorMsg) (at &lt;7cbc688ae1af4105929402a46c6a4414&gt;:0)UnityEditor.Android.PostProcessor.Tasks.AAPTPackage.CreatePackage (UnityEditor.Android.PostProcessor.PostProcessorContext context, System.String package, System.String directory, System.Boolean compress) (at &lt;7cbc688ae1af4105929402a46c6a4414&gt;:0)UnityEditor.Android.PostProcessor.Tasks.AAPTPackage.Pack (UnityEditor.Android.PostProcessor.PostProcessorContext context, System.String package, System.String directory, System.Boolean compress, System.Boolean useAAPT) (at &lt;7cbc688ae1af4105929402a46c6a4414&gt;:0)UnityEditor.Android.PostProcessor.Tasks.AAPTPackage.Execute (UnityEditor.Android.PostProcessor.PostProcessorContext context) (at &lt;7cbc688ae1af4105929402a46c6a4414&gt;:0)UnityEditor.Android.PostProcessor.PostProcessRunner.RunAllTasks (UnityEditor.Android.PostProcessor.PostProcessorContext context) (at &lt;7cbc688ae1af4105929402a46c6a4414&gt;:0)UnityEngine.GUIUtility:ProcessEvent(Int32, IntPtr) Ëøô‰∏™ÊòØÁâàÊú¨Ë∑ü‰∏ç‰∏äÁªìÊûúÔºåË¶Å‰πàÊõ¥Êñ∞SDK ÔºåË¶Å‰πàÂ∞±ÊòØunityÊúâ‰∏Ä‰∏™use legecy SDK tool ÈÄâ‰∏äÂ∞±ÂèØ‰ª•‰∫Ü]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÂÆâË£ÖJAVAÁéØÂ¢É javaËÉΩÁî®javac‰∏çËÉΩÁî®]]></title>
    <url>%2F2019%2F02%2F22%2F%E5%AE%89%E8%A3%85JAVA%E7%8E%AF%E5%A2%83%20java%E8%83%BD%E7%94%A8javac%E4%B8%8D%E8%83%BD%E7%94%A8%2F</url>
    <content type="text"><![CDATA[ÂÆâË£ÖjavaÁéØÂ¢ÉÂ∞±‰∏çËØ¥‰∫ÜÔºåÁôæÂ∫¶‰∏Ä‰∏ã‰∏ÄÂ§ßÁâá„ÄÇÈáçÁÇπÊòØÂÆâË£ÖÈÇ£‰∏™ÂÆâË£ÖÂ•ΩÂêéjavac‰∏çËÉΩÁî®„ÄÇ Ëøô‰∏™Â§ßÈÉ®ÂàÜÈÉΩÊòØÂõ†‰∏∫Ê≤°Êúâ‰∏ª‰πâ‰∏Ä‰∏ãÁéØÂ¢ÉËÆæÁΩÆÁªÜËäÇ„ÄÇ ÊàëÊääËøôÂá†‰∏™ÊâìÊàê‰ª£Á†ÅÂÖçÂæó‰∏çÁü•ÈÅìÂºïÂè∑ÂíåÁ©∫Ê†ºÊòØ‰∏çÊòØË¶ÅËæìÂÖ•ÁöÑ„ÄÇ„ÄÇ„ÄÇ Êñ∞Âª∫ÁéØÂ¢ÉÂèòÈáè ÂèòÈáèÂêç 1CLASSPATH ÂèòÈáèÂÄº 1.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; Êñ∞Âª∫ÁéØÂ¢ÉÂèòÈáè ÂèòÈáèÂêç 1JAVA_HOME ÂèòÈáèÂÄº //ÊòØ‰Ω†ÂÆâË£ÖJDKÁöÑË∑ØÂæÑÂà´Áõ¥Êé•Â§çÂà∂Á≤òË¥¥ 1H:\Program Files\Java\jdk ÂâçÈù¢‰∏§‰∏™ÊòØÊñ∞Âª∫Ë∑ØÂæÑÔºå‰∏ÄËà¨‰∏ç‰ºöÊúâÂï•ÈóÆÈ¢ò„ÄÇÂêéÈù¢Ëøô‰∏™‰∏ÄËà¨ÊòØÁºñËæëÔºåÂõ†‰∏∫Á≥ªÁªüËá™Â∏¶‰∏ÄÈÉ®ÂàÜË∑ØÂæÑ„ÄÇÁºñËæëÂ∞±ÊØîËæÉÂÆπÊòìÂá∫Èîô„ÄÇ ÁºñËæëÁéØÂ¢ÉÂèòÈáè ÂèòÈáèÂêç 1Path ÂèòÈáèÂÄº 1C:\ProgramData\Oracle\Java\javapath;%java_home%\bin;%java_home%\jre\bin; ÁºñËæë‰πãÂêéÂ∫îËØ•ÊòØËøô‰∏™Ê†∑Â≠êÔºå‰∏ÄÂºÄÂßãÊúâ‰∏ÄÈÉ®ÂàÜ„ÄÇ ‰∏ÄËà¨Â∞±ÊòØÂá∫ÈîôÂú®ËøôÔºåÂ§ßÈÉ®ÂàÜ‰∫∫Áúã‰∏çÊáÇÈÇ£‰∏™Ë∑ØÂæÑÂ∞±Áõ¥Êé•Â§çÂà∂Á≤òË¥¥‰∏äÂéª„ÄÇÂ∞±‰ºöÂá∫Áé∞ËøôÁßçÊÉÖÂÜµ Ëß£ÂÜ≥ÂäûÊ≥ïÔºåÁÇπÂáªÂè≥‰∏ãËßíÁöÑÁºñËæëÊñáÊú¨,Êää‰∏ãÈù¢‰∏§‰∏™ÂºïÂè∑Âà†Èô§Â∞±ÂèØ‰ª•‰∫Ü ÁÑ∂Âêé‰Ω†ÈáçÊñ∞ÁÇπÂáªÁºñËæëÂèòÈáèÂÄºÔºåÂ∫îËØ•ÊòØ‰∏ãÈù¢Ëøô‰∏™Ê†∑Â≠ê„ÄÇ Âá∫Áé∞ËøôÁßçÊÉÖÂÜµÊòØÂõ†Ôºå‰Ω†Áõ¥Êé•Â§çÂà∂Á≤òË¥¥ÁöÑËøô‰∏ÄÊÆµÈáåÈù¢ÊúâÂàÜÂè∑ÔºåÂàÜÂè∑ÊòØÁéØÂ¢ÉÂèòÈáèÁöÑÂàÜÂâ≤Á¨¶Ôºå‰Ω†ËæìÂÖ•ÁöÑÊñáÊú¨ÈáåÈù¢ÊúâÂàÜÂè∑ÔºåÁªìÊûúÁ≥ªÁªüËá™Âä®Áªô‰Ω†Âä†‰∫ÜÂºïÂè∑„ÄÇ ÊääÂàÜÂè∑ÂéªÊéâ‰∏ÄÊÆµ‰∏ÄÊÆµÁöÑËæìÂÖ•‰πüÊòØÂèØ‰ª•ÁöÑ„ÄÇ]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity ÁÇπÂáªUI‰∏éÁÇπÂáªÂ±èÂπïÂÜ≤Á™Å]]></title>
    <url>%2F2019%2F02%2F20%2FUnity%20%E7%82%B9%E5%87%BBUI%E4%B8%8E%E7%82%B9%E5%87%BB%E5%B1%8F%E5%B9%95%E5%86%B2%E7%AA%81%2F</url>
    <content type="text"><![CDATA[Unity ÊúâÁÇπÂáªÂ±èÂπïËøõË°åÁßªÂä®Êìç‰ΩúÔºåÈÄöËøáInput.GetMouseButtonDown(0)„ÄÇÂ¶ÇÊûúÁÇπÂáªÂà∞‰∫Ü‰∏Ä‰∫õUI‰∏äÈù¢‰ºöËß¶ÂèëÁÇπÂáªÂ±èÂπï‰∫ã‰ª∂„ÄÇ ÂºïÂÖ•UnityEngine.EventSystemsÔºåÁî®ÂáΩÊï∞Âà§Êñ≠‰∏Ä‰∏ãÂç≥ÂèØ 12345678910111213141516 using System.Collections;using System.Collections.Generic;using UnityEngine;using DG.Tweening;using UnityEngine.EventSystems;public class PlayerController : MonoBehaviour&#123; private void Update() &#123; if (EventSystem.current.IsPointerOverGameObject()) return; if (Input.GetMouseButtonDown(0)) &#123; Debug.Log(&quot;ÁÇπÂáªÂ±èÂπï&quot;); &#125; &#125;&#125; Ëøô‰∏™ÊñπÊ≥ï‰ºöÂ∞ÜÁÇπÂáªTextÁöÑÊó∂ÂÄô‰πü‰ºöÂΩì‰ΩúÁÇπÂáªUI Â∞Üraycast target ÂèñÊ∂àÂãæÈÄâÂèØ‰ª•ÈÅøÂÖç„ÄÇ]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Áî®ËôöÊãüÊú∫CentOS7 ÂÅöÊúçÂä°Âô® Êê≠Âª∫‰∏™‰∫∫ÂçöÂÆ¢ ËØ¶ÁªÜÊïôÁ®ã 2019.02]]></title>
    <url>%2F2019%2F02%2F11%2F%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BACentOS7%20%E5%81%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%20%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%202019.02%2F</url>
    <content type="text"><![CDATA[ÊúçÂä°Âô®Áî®ÁöÑÊòØCentOS7 , ÊàëÂª∫Âú®ËôöÊãüÊú∫‰∏äÔºåÂÉèËÖæËÆØ‰∫ë‰ªÄ‰πàÁöÑÂÖ∂ÂÆû‰πüÊòØ‰∏ÄÊ†∑ÁöÑ„ÄÇ ËôöÊãüÊú∫ÁöÑÂÆâË£ÖÂ∞±‰∏çËØ¥‰∫ÜÔºå‰∏çÊáÇÁöÑËá™Â∑±ÂéªÁôæÂ∫¶‰∏ãÔºå‰∏ÄÁôæÂ∫¶‰∏ÄÂ§ßÂ†Ü„ÄÇ ÂáÜÂ§áÂ∑•‰Ωú Ê≤°ÊúâÁªôÂá∫‰∏ãËΩΩËøûÊé•ÔºåÈÉΩÊòØ‰∫õÂ∏∏ËßÅÁöÑ‰∏úË•øÔºåÂ¶ÇÊûúÂÆûÂú®Êâæ‰∏çÂà∞ÊàñËÄÖÊúâÁñëÈóÆÁïô‰∏ãËØÑËÆ∫„ÄÇ ÂÆâË£Ö ÊúâCentOS ËôöÊãüÊú∫ÁöÑ VMware (ÂÆâË£ÖCentOS7 ÁöÑÊó∂ÂÄôËÆ∞ÂæóÊâìÂºÄÁΩëÂç°Ôºå‰∏çÁÑ∂ÂêéÈù¢Ë¶ÅÁî®ÂëΩ‰ª§Ë°åÊâìÂºÄÊå∫È∫ªÁÉ¶ÁöÑÔºåËøô‰∏™Ëá™Â∑±ÂéªÁôæÂ∫¶ÊÄé‰πàÊâìÂºÄ„ÄÇ) Xshell 6 ÂêåÁ±ªÂûãÁöÑËøûÊé•ÊúçÂä°Âô®ËΩØ‰ª∂‰πüÂèØ‰ª•ÔºåËÖæËÆØ‰∫ëÊàñËá™Â∑±ÁöÑËøûÊé•‰πüË°å„ÄÇ start ÔºàÂÖàÁôªÂΩï„ÄÇ„ÄÇ„ÄÇ„ÄÇÔºâ Êü•ÁúãËá™Â∑±ËôöÊãüÊú∫ IP Êåá‰ª§Ôºöip add 1ip add Â¶Ç‰∏äÂõæ Â∞±ÊòØIP4 ÁöÑÂú∞ÂùÄÔºåÁÑ∂ÂêéÈÄöËøáXshell6 ËøûÊé• (‰∏∫‰∫ÜÊ®°ÊãüÊúçÂä°Âô®ËøûÊé•ÔºåÊâÄ‰ª•ËôöÊãüÊú∫Áõ¥Êé•ÂêéÂè∞ËøêË°åÔºåÂÆûÈôÖ‰∏äÁõ¥Êé•Âú®ËôöÊãüÊú∫Â§ÑÁêÜ‰πüÊòØ‰∏ÄÊ†∑ÔºåËøôÈáåËØ¥‰∏Ä‰∏ãËøûÊé•ÊúçÂä°Âô®ÁöÑÊñπÊ≥ï) Êñ∞Âª∫‰∏Ä‰∏™ËøûÊé• ÁÑ∂ÂêéËøûÊé•Â∞±ÂèØ‰ª•‰∫Ü ÂÖ≥Èó≠Èò≤ÁÅ´Â¢ôÔºå‰πüÂèØ‰ª•ÂºÄ‰∏Ä‰∏™Á´ØÂè£„ÄÇ ‰∏∫‰∫ÜÊñπ‰æøÊàëÁõ¥Êé•ÂÖ≥Èó≠Èò≤ÁÅ´Â¢ô„ÄÇ 12 systemctl stop firewalld.service #ÂÅúÊ≠¢firewallsystemctl disable firewalld.service #Á¶ÅÊ≠¢firewallÂºÄÊú∫ÂêØÂä® ÁÑ∂ÂêéÁõ¥Êé•ÂÆâË£ÖÔºåhttpdÂç≥ÂèØ‰πüÂ∞±ÊòØApache Êåá‰ª§Ôºöyum install httpd 1yum install httpd ÁÑ∂ÂêéÂêØÂä®ÊúçÂä° Êåá‰ª§:systemctl start httpd.service 1systemctl start httpd.service ËæìÂÖ•IPÂ∫îËØ•Â∞±ËÉΩÁúãËßÅËøô‰∏™Áé©ÊÑè‰∫Ü„ÄÇ ËØ¥ÊòéÂ∑≤ÁªèÂÆâË£ÖÂ•Ω‰∫Ü ÁÑ∂ÂêéÂ∞±ÊòØÂÆâË£Ömysql Âõ†‰∏∫Ê≤°Êúâmysql Ê∫ê ÊâÄ‰ª•ÂÖàË£Ö‰∏Ä‰∏™„ÄÇ Êåá‰ª§Ôºösudo rpm -Uvh http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm yum install mysql mysql-server mysql-libs mysql-server 12 sudo rpm -Uvh http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpmyum install mysql mysql-server mysql-libs mysql-server ÁÑ∂ÂêéÂêØÂä®‰∏Ä‰∏ãËøô‰∏™mysqlÊúçÂä° systemctl restart mysql.service 123 systemctl restart mysql.service #ÈáçÂêØmysqlÊúçÂä°systemctl start mysql.service #ÂêØÂä®mysqlÊúçÂä°systemctl stop mysql.service #ÂÅúÊ≠¢mysqlÊúçÂä° ‰∏∫mysqlËÆæÁΩÆÁôªÈôÜÂØÜÁ†ÅÔºåÁÑ∂ÂêéÁôªÈôÜÔºåÂú®ÂàõÂª∫‰∏Ä‰∏™wordpress ÁöÑÊï∞ÊçÆÂ∫ì„ÄÇ 1234 /usr/bin/mysqladmin -u root password &apos;123456&apos; #ÂêéÈù¢Ëøô‰∏§‰∏™ÂºïÂè∑ÈáåÈù¢ÁöÑÊòØÂØÜÁ†Åmysql -uroot --password=&apos;123456&apos; #ËæìÂÖ•ÁôªÈôÜÂØÜÁ†ÅCREATE DATABASE wordpress; #ÂàõÂª∫wordpressÊï∞ÊçÆÂ∫ìexit #ÈÄÄÂá∫mysql ÁÑ∂ÂêéÂÜçÂÆâË£ÖPHP Êåá‰ª§Ôºöyum install php-fpm php-mysql -y 123 yum install php-fpm php-mysql -yyum install phpyum install php-gd php-imap php-ldap php-odbc php-pear php-xml php-xmlrpc ÂêØÂä®PHPÊúçÂä° ÂÜçÊääÂÆÉËÆæÁΩÆ‰∏∫ÂºÄÊú∫ÂêØÂä®„ÄÇ 12 service php-fpm startchkconfig php-fpm on ÁÑ∂ÂêéÂÜçÊääÔºåApache Âíå mysql ËÆæÁΩÆÊàêÂºÄÊú∫Ëá™Âä®ÂêØÂä®ÂÜçÈáçÂêØ‰∏Ä‰∏ãÊúçÂä° 1234 systemctl enable httpd.servicesystemctl enable mysqld.servicesystemctl restart httpd.servicesystemctl restart mysqld.service ÁÑ∂ÂêéÂàõÂª∫‰∏Ä‰∏™ phpÊñá‰ª∂ËØïËØïÊòØ‰∏çÊòØÊàêÂäüË£ÖÂ•Ω‰∫ÜPHP Êåá‰ª§Ôºövi /var/www/html/info.php (Â¶ÇÊûúÁõ¥Êé•‰øÆÊîπ‰∏ç‰∫ÜÂ∞±ËøõÂÖ•Ëøô‰∏™Êñá‰ª∂Â§πÈáåÈù¢ÂÖàÂàõÂª∫ÂÜç‰øÆÊîπ) 1vi /var/www/html/info.php ÁÑ∂ÂêéÊåâ i ËøõÂÖ•ËæìÂÖ•Ê®°ÂºèÔºåÂÜçËæìÂÖ• 123 &lt;?phpphpinfo();?&gt; ÁÑ∂ÂêéÊåâESC Êåâ : ËæìÂÖ• wq Á°ÆÂÆö Ôºå‰øùÂ≠òÈÄÄÂá∫„ÄÇ ÁÑ∂ÂêéÂÜçÂéªÊµèËßàÂô®ËæìÂÖ• ÁΩëÂùÄ ‰Ω†ÂéüÊú¨ÁöÑip/info.php Â∫îËØ•Â∞±ÊòØËøô‰∏™Ê†∑Â≠êÔºåÁÑ∂ÂêéÔºåÂ∞±ÂéªËá™Â∑±ÁîµËÑë‰∏äÊâæwordpress ÁöÑÊñá‰ª∂ ÁÑ∂ÂêéËé∑ÂæóËøô‰∏™ÂÆâË£ÖÂåÖ wget ÂàöÊâçÈÇ£‰∏™ËøûÊé• Â¶ÇÊûúÊòæÁ§∫ Ê≤°Êúâwget ÂÖà ËæìÂÖ• yum install wegt ÂÖàÂÆâË£Ö 1wget https://wordpress.org/latest.zip ÁÑ∂ÂêéÂú® Ëß£Âéã unzip latest.zip Â¶ÇÊûúÊòæÁ§∫Ê≤°Êúâunzip ‰∏ÄÊ†∑ÁöÑÂÖàËæìÂÖ• yum insatll unzip 1unzip latest.zip #ÊòØ‰ªÄ‰πàÊñá‰ª∂ÂêçÂ∞±ÊòØËß£Âéã‰ªÄ‰πàÊñá‰ª∂ ÁÑ∂ÂêéÂÜçÂ§çÂà∂Âà∞html Êñá‰ª∂ÈáåÈù¢Âéª 1cp -rf wordpress/* /var/www/html/ ÂÜç‰øÆÊîπ‰∏Ä‰∏ãÊñá‰ª∂ÊùÉÈôê„ÄÇ 1chmod -R 777 html/ ÁÑ∂ÂêéËæìÂÖ•IPÂ∫îËØ•Â∞±ÂèØ‰ª•ËøõÂÖ•ÂÆâË£ÖÁïåÈù¢‰∫Ü„ÄÇ ÁÑ∂Âêé‰∏ÄË∑ØÁÇπ‰∏ãÂéªÂ∞±Ë°å‰∫ÜÔºåËæìÂÖ•Êï∞ÊçÆÂ∫ìÂêçÔºåËøòÊúâÊï∞ÊçÆÂ∫ìÁôªÈôÜË¥¶Êà∑ÂíåÂØÜÁ†ÅÔºåÂ∞±ÊòØÁôªÈôÜmysqlÁöÑ„ÄÇÁî®Êà∑Âêç‰∏ÄËà¨Â∞±ÊòØroot„ÄÇ Â¶ÇÊûúÂá∫Áé∞Ëøô‰∏™ÔºåÊääÈáåÈù¢ÂÜÖÂÆπÂ§çÂà∂‰∏ÄÈÅçÔºåÂàõÂª∫‰∏Ä‰∏™wp-config.phpÊñá‰ª∂ÁÑ∂ÂêéÂ§çÂà∂Á≤òË¥¥ËøõÂéªÂ∞±Ë°å‰∫Ü„ÄÇ ÁÑ∂ÂêéÊåâÊèêÁ§∫‰∏ÄË∑Ø‰∏ãÂéªÂ∞±Ë°å‰∫ÜÔºåÂ¶ÇÊûúÂêéÈù¢Ë£ÖÊèí‰ª∂Âá∫‰∫ÜÁÇπÈóÆÈ¢òÔºåË¶ÅFTPÂçèËÆÆÁöÑËØùÂ∞±ÂéªË£Ö‰∏Ä‰∏ã yum install vsftpd useradd admin passwd 123456systemctl enable vsftpd.service systemctl restart vsftpd.service 123456789 yum install vsftpduseradd adminpasswd 123456systemctl enable vsftpd.service systemctl restart vsftpd.service]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wordpress Error establishing a database connection Mysql80Âª∫Á´ãÊï∞ÊçÆÂ∫ìËøûÊé•Êó∂Âá∫Èîô]]></title>
    <url>%2F2019%2F02%2F07%2FWordpress%20Error%20establishing%20a%20database%20connection%20Mysql80%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%97%B6%E5%87%BA%E9%94%99%2F</url>
    <content type="text"><![CDATA[Âª∫Á´ãÊï∞ÊçÆÂ∫ìËøûÊé•Êó∂Âá∫Èîô ËøôÊàñËÄÖÊÑèÂë≥ÁùÄÊñá‰ª∂‰∏≠ÁöÑÁî®Êà∑ÂêçÂíåÂØÜÁ†Å‰ø°ÊÅØ wp-config.php ‰∏çÊ≠£Á°ÆÔºåÊàñËÄÖÊàë‰ª¨Êó†Ê≥ïËÅîÁ≥ªÊï∞ÊçÆÂ∫ìÊúçÂä°Âô® localhost „ÄÇËøôÂèØËÉΩÊÑèÂë≥ÁùÄ‰∏ªÊú∫ÁöÑÊï∞ÊçÆÂ∫ìÊúçÂä°Âô®Â∑≤ÂÖ≥Èó≠„ÄÇ ÊÇ®Á°ÆÂÆöÊã•ÊúâÊ≠£Á°ÆÁöÑÁî®Êà∑ÂêçÂíåÂØÜÁ†ÅÂêóÔºü ÊÇ®Á°ÆÂÆöÂ∑≤ÈîÆÂÖ•Ê≠£Á°ÆÁöÑ‰∏ªÊú∫ÂêçÂêóÔºü ÊÇ®Á°ÆÂÆöÊï∞ÊçÆÂ∫ìÊúçÂä°Âô®Ê≠£Âú®ËøêË°åÂêóÔºü Â¶ÇÊûúÊÇ®‰∏çÁ°ÆÂÆöËøô‰∫õÊúØËØ≠ÁöÑÂê´‰πâÔºåÊÇ®Â∫îËØ•ËÅîÁ≥ªÊÇ®ÁöÑ‰∏ª‰∫∫„ÄÇÂ¶ÇÊûúÊÇ®‰ªçÈúÄË¶ÅÂ∏ÆÂä©ÔºåÂèØ‰ª•ÈöèÊó∂ËÆøÈóÆWordPressÊîØÊåÅËÆ∫Âùõ„ÄÇ Âá∫Áé∞Ëøô‰∏™ÈóÆÈ¢òÊúâÂá†ÁßçÂèØËÉΩÔºåÊúÄÂ∏∏ËßÅÂá†ÁßçÂ∞±ÊòØÁî®Êà∑ÂêçÂØÜÁ†ÅÊàñËÄÖÊï∞ÊçÆÂ∫ìÂêçÊâìÈîô‰∫Ü„ÄÇ ËøòÊúâ‰∏ÄÁßçÂèØËÉΩÂ∞±ÊòØ‰Ω†ÁöÑmysqlÂä†ÂØÜÊñπÂºè‰∏ç‰∏ÄÊ†∑„ÄÇ ÂÖàËæìÂÖ• use mysql ; ÂÜçËæìÂÖ• select host,user,plugin from user; 12 use mysql;select host,user,plugin from user; Êü•ÁúãÂä†ÂØÜÊñπÂºèÔºåÂ∞±ÊòØ plugin Ëøô‰∏™‰∏ãÈù¢ÊòæÁ§∫„ÄÇ caching_sha2_password ÊòØ‰∏ÄÁßçÊñ∞ÁöÑÂä†ÂØÜÊñπÂºèÔºåwpÂíådiscuz Êúâ‰∫õÁâàÊú¨ ÊòØ‰∏çÊîØÊåÅÁöÑ„ÄÇ ÊâÄ‰ª•Ëøô‰∏™Êó∂ÂÄôË¶Å‰øÆÊîπ‰∏Ä‰∏ã ËæìÂÖ•Êåá‰ª§ update user set plugin=‚Äômysql_native_password‚Äô where user=‚Äôroot‚Äô; 1update user set plugin=&apos;mysql_native_password&apos; where user=&apos;root&apos;; ËæìÂÖ•Êåá‰ª§‰πãÂêéÂ∞±ÊòØ‰∏ãÈù¢Ëøô‰∏™Ê†∑Â≠ê„ÄÇËæìÂÖ•Ëøô‰∏™Êåá‰ª§‰πãÂêé ‰Ω†ÂéüÊú¨ÁöÑÂØÜÁ†ÅÂä†ÂØÜÊñπÂºèÂèò‰∫ÜÔºåÊâÄ‰ª•‰Ω†ÁöÑÂØÜÁ†Å‰πüÂèò‰∫ÜÔºåÂ¶ÇÊûú‰Ω†ÊäÄÊúØÂ•ΩÔºåÂèØ‰ª•Á†îÁ©∂‰∏Ä‰∏ã‰Ω†ÁöÑÂØÜÁ†ÅÂèòÊàê‰∫ÜÂ§öÂ∞ëÔºåÂ¶ÇÊûúÁÆó‰∏çÂá∫Êù•Â∞±ËÄÅËÄÅÂÆûÂÆûÊîπÂØÜÁ†Å„ÄÇÊ≥®ÊÑèÔºöÊîπÂØÜÁ†ÅÂøÖÈ°ªÊåáÊòéÂä†ÂØÜÊñπÂºèÔºå‰∏çÁÑ∂Âèà‰ºöÂèòÂõûÂéª„ÄÇ ËæìÂÖ•Êåá‰ª§ÔºöALTER USER ‚Äòroot‚Äô@‚Äôlocalhost‚Äô IDENTIFIED WITH mysql_native_password BY ‚Äò‰Ω†ÁöÑÂØÜÁ†Å‚Äô; 1ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;; ÁÑ∂ÂêéÂú®ËæìÂÖ•ÂâçÈù¢ÈÇ£‰∏™Êåá‰ª§Áúã‰∏Ä‰∏ã select host,user,plugin from user; ÊúÄÂêéËæìÂÖ•ÊúÄÂêé‰∏Ä‰∏™Êõ¥Êñ∞ÊùÉÈôêÊåá‰ª§Ôºö flush privileges; 1flush privileges; ÁÑ∂ÂêéÈÄÄÂá∫ÈáçÂêØÂ∞±Ë°å‰∫Ü„ÄÇ]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+githubÊê≠Âª∫‰∏™‰∫∫ÂçöÂÆ¢ 2019.2 ËØ¶ÁªÜÊïôÁ®ã]]></title>
    <url>%2F2019%2F02%2F04%2Fhexo%2Bgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%202019.2%20%20%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Â§ßËøáÂπ¥ÁöÑÔºåÂ∞±ÂéªËØïËØïÊê≠‰∏Ä‰∏™Ëá™Â∑±ÁöÑÂçöÂÆ¢ÔºåÁúã‰∫ÜÂà´‰∫∫ÁöÑÂçöÂÆ¢ÔºåÁÖßÁùÄÊê≠‰∫Ü‰∏Ä‰∏™Ôºå‰∏≠Èó¥Âõ†‰∏∫ÂêÑÁßçbugÔºåËØï‰∫ÜÂçäÂ§©Âìé„ÄÇ‰∏çËøá‰πüÊòØ‰∏™ÂæàÂ•ΩÁêÜËß£github,hexoÁöÑÊ≥ïÂ≠êÔºåÊØïÁ´ü‰∏çÂá∫ÈîôÔºåÊÄé‰πà‰ºöÁêÜËß£„ÄÇ‰∏≠Èó¥ËøòÊúâ‰∫õ‰∏úË•øËøòÊ≤°ÊêûÊòéÁôΩÔºåÂ∏åÊúõÂ§ß‰Ω¨ÂâçÊù•Ëß£Á≠î‰∏Ä‰∏ã„ÄÇ ‰∏ãÈù¢Â∞±ÂºÄÂßãÊê≠Âª∫‰∫Ü„ÄÇ ÂáÜÂ§áÂ∑•‰Ωú node.js https://nodejs.org/en/ ÈìæÊé•Ôºöhttps://pan.baidu.com/s/1-I1ROA_2rq4MDG1BFe0BqA ÊèêÂèñÁ†ÅÔºöcnsz GIT https://git-scm.com/downloads ÁôæÂ∫¶‰∫ëÈìæÊé•Ôºöhttps://pan.baidu.com/s/1-I1ROA_2rq4MDG1BFe0BqA ÊèêÂèñÁ†ÅÔºöcnsz (‰∏çË¶ÅÈóÆ‰∏∫Âï•Áªô‰Ω†‰ª¨Êîæ‰∏™ÁôæÂ∫¶‰∫ëÈìæÊé• ÔºåÊàëÁâπ‰πàÂÆòÁΩë‰∏ã‰∏ç‰∫ÜÔºåËøòÊâæ‰∫ÜÂçäÂ§©) ÂÆâË£ÖÂ•ΩÂêéÁ°ÆËÆ§‰∏Ä‰∏ãÔºö Ë£ÖÂ•ΩÂêéÔºåÂú®cmd ÊàñËÄÖ power shell ÈáåÈù¢ÊâìÂá∫ËøôÂá†‰∏™Êåá‰ª§ÔºåÂ∞±ÂèØ‰ª•ÊòæÁ§∫ÁâàÊú¨Ôºå‰πüÂ∞±ÊòØÊúâËøôÂá†‰∏™ËΩØ‰ª∂„ÄÇ first Ê≥®ÂÜå‰∏™github,Ëøô‰∏™Â∞èÂ≠©Â≠êÁé©ÊÑèÊàëÂ∞±‰∏çÂíå‰Ω†‰ª¨BBÔºåËá™Â∑±ÂéªÊ≥®ÂÜå„ÄÇ Ê≥®ÂÜåÂ•ΩÂêéÂ∫îËØ•ÊòØ‰∏™ËøôÊ†∑ÁöÑÁûéJ BÊ†∑Â≠êÔºåÁÑ∂ÂêéÂàõÂª∫‰∏Ä‰∏™‰ªìÂ∫ì ‰ªìÂ∫ìÂêç: _yourname_._github.oi_ ËøõÂÖ•setting Ëøô‰∏™ÊòØ‰Ω†ÁöÑ‰ªìÂ∫ìÂêçÔºåÁÑ∂ÂêéÂêë‰∏ãÊªëÂä®„ÄÇ ‰∏äÈù¢ÈÇ£‰∏™ÁΩëÂùÄÔºåÂ∞±ÊòØ‰Ω†ÂèØ‰ª•Â§ñÁΩëËÆøÈóÆÁöÑÔºå‰Ω†ÁöÑÊúçÂä°Âô®Â∞±ÊòØËøô‰∏™‰∫Ü„ÄÇÊàë‰ª¨Áé∞Âú®Â∞±ÊòØË¶ÅÊääÂçöÂÆ¢Êîæ‰∏äÂéª„ÄÇ Âú®Ëøô‰∏™Âú∞ÊñπÈÅáÂà∞‰∫ÜÂá†‰∏™ÈîôËØØ 1cd ~/.ssh Ëøô‰∏™Êåá‰ª§ËøõÂÖ•ssh,Â¶ÇÊûúÊòæÁ§∫Ê≤°ÊúâËøô‰∏™Êñá‰ª∂Â§πÔºåÈÇ£Â∞±Áõ¥Êé•ÂàõÂª∫Êñá‰ª∂Â§πBLOG ÂêéÈù¢Â∞±ÊòØÁî®Êù•ÊîæÂçöÂÆ¢Êñá‰ª∂ÁöÑ ËøõÂÖ•Êñá‰ª∂Â§πÔºåÂè≥ÂáªÔºågit bashÔºå(ÈÄöËøácmd,power shell ÂëΩ‰ª§Ë°åËøõÂÖ•‰πüÊòØ‰∏ÄÊ†∑ÁöÑ) Âú®ÂëΩ‰ª§Ë°å‰∏≠ËæìÂÖ•Êåá‰ª§ hexo init ÂàùÂßãÂåñ„ÄÇ 1hexo init ËæìÂÖ•npm installÔºåÂÆâË£ÖÊâÄÈúÄË¶ÅÁöÑÁªÑ‰ª∂ 1npm install ÁÑ∂ÂêéËæìÂÖ• hexo -g ÈùôÊÄÅÈÉ®ÁΩ≤ 1hexo g Â∑Æ‰∏çÂ§öÂ∞±ÊòØËøô‰∏™Ê†∑Â≠êÔºåËøô‰∏™Êó∂ÂÄô ÂçöÂÆ¢Â∑≤ÁªèÂèØ‰ª•ËÆøÈóÆ‰∫Ü„ÄÇ Ë¶ÅÁúã‰∏Ä‰∏ãÁöÑËØùËæìÂÖ• hexo s ÊúçÂä°Âô®ÂêØÂä® 1hexo s ÁÑ∂Âêé‰Ω†ËæìÂÖ•‰∏Ä‰∏ã http://localhost:4000/ Â∞±ÂèØ‰ª•Áúã‰∏Ä‰∏ã localhost ÊòØÊú¨Êú∫ÁöÑÂú∞ÂùÄ ÔºåÁ´ØÂè£ÊòØ 4000 Â¶ÇÊûú 4000 Á´ØÂè£Ë¢´Áî®‰∫ÜÁöÑËØùÂèØ‰ª•Êç¢‰∏Ä‰∏™Á´ØÂè£„ÄÇ hexo server -p Á´ØÂè£Âè∑ Êåá‰ª§ÊòØËøô‰∏™ÔºåÂèëÁîü‰ªÄ‰πàÊàëÂ∞±‰∏çÊà™Âõæ‰∫Ü„ÄÇ Â∫îËØ•ÊòØËøô‰∏™Ê†∑Â≠ê„ÄÇ ÁúãÂÆå‰πãÂêéctrl +c ÂÅúÊ≠¢ËøêË°åÊúçÂä°Âô®„ÄÇ „ÄÇ ‰∏ã‰∏ÄÊ≠•Â∞±ÊòØÊääËøô‰∏™ÁΩëÈ°µ‰º†Âà∞github ‰∏äÂéª„ÄÇ ‰∏∫‰∫ÜÊñπ‰æøÊàë‰ª¨Âª∫‰∏Ä‰∏™ ssh git‰ΩøÁî®httpsÂçèËÆÆÔºåÊØèÊ¨°pull,pushÈÉΩË¶ÅËæìÂÖ•ÂØÜÁ†ÅÔºå‰ΩøÁî®gitÂçèËÆÆÔºå‰ΩøÁî®sshÁßòÈí•ÔºåÂèØ‰ª•ÁúÅÂéªÊØèÊ¨°ËæìÂØÜÁ†Å ‰∏Ä„ÄÅÊú¨Âú∞ÁîüÊàêÂØÜÈí•ÂØπÔºõ ‰∫å„ÄÅËÆæÁΩÆgithub‰∏äÁöÑÂÖ¨Èí•Ôºõ cd ~/.ssh ssh-keygen -t rsa -C ‚Äú‰Ω†ÂàõÂª∫ÈÇ£‰∏™githubÁöÑÈÇÆÁÆ±‚Äù 12 cd ~/.sshssh-keygen -t rsa -C &quot;3035536707@qq.com&quot; ËøûÁª≠‰∏â‰∏™ÂõûËΩ¶ÔºåÁîüÊàêÂØÜÈí•ÔºåÊúÄÂêéÂæóÂà∞‰∫Ü‰∏§‰∏™Êñá‰ª∂Ôºöid_rsaÂíåid_rsa.pubÔºàÈªòËÆ§Â≠òÂÇ®Ë∑ØÂæÑÊòØÔºöC:\Users\Administrator.ssh ÔºâÊâæ‰∏çÂà∞Â∞±Áî®ÊêúÁ¥¢„ÄÇ Â¶ÇÊûúÊòæÁ§∫Ê≤°ÊúâËøô‰∏™Êñá‰ª∂Â§πÔºåÂ∞±ÂÖàÂàõÂª∫ÔºåÂÜçËøõÂÖ•ÔºåÂ∞±ÊòØÊää‰∏§‰∏™Êåá‰ª§Êç¢‰∏Ä‰∏ãËæìÂÖ•„ÄÇ Áî®ËÆ∞‰∫ãÊú¨ÊâìÂºÄËøô‰∏™ ÁÑ∂ÂêéÊääÈáåÈù¢ÁöÑ‰∏úË•øÂ§çÂà∂‰∏Ä‰∏ãÔºåÂ∫îËØ•ÊòØ‰∏ÄÂ§ßÂ†ÜÁúã‰∏çÊáÇÁöÑ‰∏úË•ø„ÄÇ ÁÑ∂ÂêéÂ∞±ÊîæÂà∞github‰∏ä„ÄÇ ÊµãËØïÔºö Âú®ÁªàÁ´Ø ssh -T git@github.com Ê∑ªÂä†Â•ΩÂêé ÈáçÊñ∞ÂõûÂà∞‰Ω†ÂàõÂª∫ÁöÑÊñá‰ª∂Â§π„ÄÇ ÊñáÊú¨ÁºñËæë‰∏Ä‰∏ãËøô‰∏™Êñá‰ª∂ 1234deploy: type: git repository: git@github.com:ETBUBBLE/ETBUBBLE.github.io.git branch: master ‰Ω†ÁöÑ‰ªìÂ∫ìÂú∞ÂùÄÂ∞±ÊòØÊòØËøô‰∏™ Ëøô‰∏™ÊòØ‰Ω†ÂâçÈù¢ÁúãËøáÁöÑÈÇ£‰∏™Áé©ÊÑèÔºåÂ¶ÇÊûúÊ≤°ÊúâËÆæÁΩÆ‰ºöÂá∫Âï•ÈóÆÈ¢òËá™Â∑±ÂéªËØïËØï„ÄÇ ÁÑ∂ÂêéÈáçÊñ∞ÂõûÂà∞ÂëΩ‰ª§Ë°åÔºåËøõÂÖ• BLOG Êñá‰ª∂Â§π Âú®ÁîüÊàê‰ª•ÂèäÈÉ®ÁΩ≤ÊñáÁ´†‰πãÂâçÔºåÈúÄË¶ÅÂÆâË£Ö‰∏Ä‰∏™Êâ©Â±ï ÁÑ∂ÂêéËæìÂÖ• hexo clean hexo d -g 12 hexo cleanhexo d -g ‰º†Âà∞‰ªìÂ∫ìÂéªÂ∞±ÂèØ‰ª•‰∫Ü„ÄÇ ÁÑ∂ÂêéÂ∞±ÂÜç‰πüÊ≤°ÊúâÁÑ∂Âêé‰∫Ü„ÄÇ hexo new post ‚Äú‰Ω†ÁöÑÂçöÂÆ¢ÂÜÖÂÆπ‚Äù Â∞±ÂèØ‰ª•ÂèëÈÄÅÂá∫Âéª‰∫Ü„ÄÇ ‰∏Ä‰∏™ÂçöÂÆ¢Â∞±Êê≠Â•Ω‰∫ÜÔºåÊòØ‰∏çÊòØÁâπÂà´ÁÆÄÂçï„ÄÇ Ë°•ÂÖÖÁªëÂÆöÂüüÂêç ÂéªÂüüÂêçËß£Êûê‰∏äÈù¢Ê∑ªÂä†Ëß£Êûê„ÄÇ ÁÑ∂ÂêéÂÜçÂú®Ëá™Â∑±ÁöÑgithub‰ªìÂ∫ìÈáåÈù¢Êñ∞Âª∫‰∏Ä‰∏™CNAMEÊñá‰ª∂ÔºåÊ≤°ÊúâÂêéÁºÄ ÈáåÈù¢ÂÜô‰∏ä‰Ω†ÁöÑÂüüÂêç„ÄÇ 1www.etbubble.xyz ÂÜçÂéªsourceÂàõÂª∫‰∏Ä‰∏™CNAMEÊñá‰ª∂Âíå‰∏äÈù¢‰∏ÄÊ†∑]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeCraft-19 and Codeforces Round 537 (Div. 2)]]></title>
    <url>%2F2019%2F02%2F04%2FCodeCraft-19%20and%20Codeforces%20Round%20537%20(Div.%202)%2F</url>
    <content type="text"><![CDATA[ÂØπ‰∫éËøô‰∏ÄÂú∫ÊàëÊòØÂÜÖÂøÉÂ¥©Ê∫ÉÁöÑ0.0 A. Superhero Transformation ÊàëÁâπ‰πàÈÜâ‰∫ÜÔºåÊ≤°‰ªª‰ΩïÈöæÂ∫¶Ôºå‰ΩÜÊòØÊàëÊï∞ÁªÑÂºÄÂ∞è‰∫ÜÔºåÂ∞ëÊâì‰∫Ü‰∏Ä‰∏™0.„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇË¢´fst. 123456789101112131415161718192021222324252627 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;const int maxn=1e7+5;int k[1000];int main() &#123; k[&apos;a&apos;]=1; k[&apos;e&apos;]=1; k[&apos;i&apos;]=1; k[&apos;o&apos;]=1; k[&apos;u&apos;]=1; char s[2000],t[2000]; cin&gt;&gt;s&gt;&gt;t; int l=strlen(s),l2=strlen(t),flag=1; if(l==l2) &#123; for(int i=0; i&lt;l; i++) &#123; if(k[s[i]]!=k[t[i]])flag=0; &#125; &#125; else flag=0; puts(flag?&quot;YES&quot;:&quot;NO&quot;); return 0;&#125; B. Average Superhero Gang Power Áõ¥Êé•ÁÆóÂ∞±Ë°å‰∫ÜÔºåÁÑ∂ËÄåÊàëËøòÊòØÈîô‰∫Ü„ÄÇÁõ¥Êé•Êûö‰∏æÂà†Èô§ÊúÄÂ∞èÁöÑ m‰∏™„ÄÇ 12345678910111213141516171819202122232425 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;const int maxn=1e5+5;int kk[maxn];int main() &#123; LL n,k,m; LL ans=0; cin&gt;&gt;n&gt;&gt;k&gt;&gt;m; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d&quot;,&amp;kk[i]); ans+=kk[i]; &#125; sort(kk,kk+n); double res=0; for(int i=0; i&lt;=min(m,n-1); i++) &#123; res=max(res,(double)(min((n-i)*k,m-i)+ans)/(n-i)); ans-=kk[i]; &#125; printf(&quot;%.10f\n&quot;,res); return 0;&#125; C. Creative Snap ËøôÈ¢òÂ•Ω‰∫ÜÔºåÁªà‰∫éÊ≤°Êúâfst‰∫ÜÔºåÁÑ∂ËÄåËøôÈ¢òÊâçÊòØÊúÄÂ¥©Ê∫ÉÁöÑÔºå‰∏ÄÂºÄÂßãÂ∞±ÊÉ≥Âà∞‰∫Üdfs,ÊÉ≥‰∫Ü‰∏Ä‰∏ãÂ§çÊùÇÂ∫¶‰∏çË°åÔºå‰∏çË°å‰Ω†Â¶πÂïäÔºåÁÑ∂ÂêéÂèëÁé∞ÂèØ‰ª•ÔºåÁÑ∂ÂêéËÆ°ÁÆóÂú®Âå∫Èó¥ [l,r]‰πãÈó¥ÊúâÂ§öÂ∞ë‰∏™Êï∞ÔºåÊàëÁ¨¨‰∏Ä‰∏™ÊÉ≥Âà∞‰∫ÜÊö¥ÂäõÔºåÊàëÁâπ‰πàÊÉ≥ÊääËá™Â∑±ÁªôÊãçÊ≠ªÔºå‰∫åÂàÜ‰∏çË°åÂêóÔºå‰∫åÂàÜ‰∏çË°åÂêóÔºüÔºüÔºüÔºüÔºüÊàëÂæóÂõûÂà∞‰ªäÂ§©ÂáåÊô®ÂéªÊääËá™Â∑±ÊãçÊ≠ª„ÄÇ 1234567891011121314151617181920212223242526272829303132 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; p;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;const int maxn=1e5+5;int n,k,a,b;LL d[maxn];LL dfs(LL l, LL r,LL i,LL j,LL cnt) &#123; if(cnt&lt;=0) &#123; return a; &#125; else &#123; LL mid=(l+r)/2; LL a1=cnt*(r-l+1)*b; LL pos=upper_bound(d+i,d+j+1,mid)-d; if(r-l==0)return a1; return min(a1,dfs(l,mid,i,pos-1,pos-i)+dfs(mid+1,r,pos,j,j-pos+1)); &#125;&#125;int main() &#123; scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;k,&amp;a,&amp;b); for(int i=0; i&lt;k; i++) &#123; scanf(&quot;%d&quot;,&amp;d[i]); &#125; sort(d,d+k); LL ans=0; ans=dfs(1LL,1&lt;&lt;n,0LL,k-1,k); printf(&quot;%lld\n&quot;,ans); return 0;&#125; ÊúÄÁªàÊéâÂàÜ„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇÂéüË∞ÖÊàëÁöÑËèú„ÄÇ]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCPC-Wannafly Winter Camp Day2 E]]></title>
    <url>%2F2019%2F02%2F01%2FCCPC-Wannafly%20Winter%20Camp%20Day2%20E%2F</url>
    <content type="text"><![CDATA[Power of Function Ëøô‰∏™È¢òÈáçÁÇπÊòØËØªÈ¢ò„ÄÇÁúãÊáÇÂáΩÊï∞ÔºåÂáΩÊï∞ÊúÄÁªàË°®Á§∫ÁöÑÊòØ n ÂÜôÊàêKËøõÂà∂ÔºåKËøõÂà∂ÁöÑÂÄºÁöÑÂíåÂä†‰∏äÈïøÂ∫¶ -2 Â∞±ÊòØm„ÄÇ Áªô‰Ω†‰∏Ä‰∏™ Ôºåk,l,r,Ê±ÇKËøõÂà∂‰∏ãÔºå[l,r]Âå∫Èó¥ÂÜÖmÁöÑÊúÄÂ§ßÂÄº„ÄÇÁÑ∂ÂêéËæìÂá∫ÂΩìmÊúÄÂ§ßÊó∂[l,r]Âå∫Èó¥ÊúÄÂ§ßÂÄºÂíåÊúÄÂ∞èÂÄº„ÄÇ È¢òËß£ÔºöÊääl,rËΩ¨Êç¢ÊàêKËøõÂà∂Ôºå r&gt;lÔºåÂ¶ÇÊûúr,l,È´ò‰ΩçÁõ∏ÂêåÔºåÈÇ£‰πàÊ±ÇÂæóÂà∞ÊúÄÂ§ßÂÄºMÈ´ò‰ΩçËÇØÂÆö‰πüÊòØÂíåËøô‰∏™ÂÄº‰∏ÄÊ†∑„ÄÇÁÑ∂Âêé‰ªéÁ¨¨‰∏Ä‰∏™‰Ωç‰∏çÂêåÂºÄÂßãÔºåÊÉ≥ËÆ©MÂÄºÊúÄÂ§ßÔºåÂè™Êúâ‰∏§ÁßçÂèØËÉΩÔºå‰∏ÄÁßçÊòØÂèñrËøô‰∏™ÂÄº‰∫åËøõÂà∂‰∏ã‰ΩçÂáè‰∏ÄÔºåÁÑ∂ÂêéÂêéÈù¢‰ΩçÁöÑÂÖ®ÈÉ®Âèñ k-1,ÊàñËÄÖËøô‰∏™‰ΩçÂèñÊúÄÂ§ßÂÄºÂÜçÁªßÁª≠ËÆ®ËÆ∫‰∏ã‰∏Ä‰∏™‰Ωç„ÄÇÂÜô‰∏™DFSÂ∞±ÂèØ‰ª•ÔºåÂíåÊï∞‰ΩçDPÊúâÁÇπÂÉè„ÄÇ ‰∏æ‰∏™‰æãÂ≠ê Ôºök=10 ,l=1001,r=1179. 10ËøõÂà∂‰∏ã l = 1 0 0 1 r = 1 1 7 9 ÊúÄÂâçÈù¢ 1 Âíå 1 ÊòØÁõ∏ÂêåÁöÑÊâÄ‰ª•Ë¶Å mÊúÄÂ§ß ËÇØÂÆö ÊúÄÈ´ò‰Ωç‰πüÊòØ 1 b=1 0 0 0 ÁÑ∂Âêé‰ªéÁ¨¨3‰ΩçÂºÄÂßãdfs(3) Ë¶Å‰πàËøô‰∏™‰ΩçÂèñ 1Ôºå Ë¶Å‰πà Âèñ 0 ÂêéÊÖ¢ÊÖ¢ÂÖ®Âèñ 9Ôºå Â¶ÇÊûúËøô‰∏™‰Ωç Âèñ 1 Â∞±‰ºöÂΩ±Âìç‰∏ã‰∏Ä‰∏™‰ΩçÔºåÊâÄ‰ª•ÂÜçDFSÔºà2Ôºâ ÁÑ∂ÂêéÂèëÁé∞ Ë¶Å‰πàÂèñ7 ÔºåÔºàË¶Å‰πà Âèñ 6 ÂêéÈù¢ÂÖ®‰∏∫9Ôºâ ‰ª•Ê≠§Á±ªÊé®ÔºåÊúÄÂêéÂèëÁé∞ ÂêéÈù¢3‰∏∫ 179 099 ÂèñÂæó ÂêéÈù¢ÊØîËæÉÂ§ßÔºåÈÇ£‰πàmÂèñÊúÄÂ§ßÂ∞±ÊòØ 1099Ôºõ ËøòÊúâ‰∏Ä‰∫õÁªÜËäÇË¶ÅÊ≥®ÊÑèÔºåÊØîÂ¶Ç 179 Ôºå99ÊòØ‰∏ÄÊ†∑ÊâìÁöÑÔºåÂõ†‰∏∫99Âè™Êúâ‰∏§‰ΩçÊï∞„ÄÇËøòÊúâ 0 ÊòØÊ≤°Êúâ ÊØî‰ªñÂ∞è1Ëøô‰∏™Êï∞ÔºåÂ¶ÇÊûúË¶ÅÂ∞è1Â∞±Ë¶ÅÂêëÈ´ò‰ΩçÂÄüÔºåÊâÄ‰ª•ËøôÊÉÖÂÜµË¶ÅÊéíÈô§„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;int t;LL k,l,r;vector&lt;LL&gt; v1,v2,mi,mx;LL p[2000];LL dfs(LL pos,bool limit) &#123; if(pos==-1)return 0; if(limit) &#123; LL m1,m2; m1=dfs(pos-1,1); m2=dfs(pos-1,0); m1+=v2[pos]; m2+=v2[pos]-1; if(v2[pos]==0)m2=-1; //ÊéíÈô§ ‰∏∫ r pos‰Ωç ‰∏∫0ÊÉÖÂÜµ if(pos==v2.size()-1&amp;&amp;v2[pos]==1)m2--; // ÊúÄÈ´ò‰Ωç‰∏∫ 0 m2Ë¶ÅÂáè‰∏Ä if(m1&gt;m2) &#123; mx[pos]=mi[pos]=v2[pos]; return m1; &#125; else if(m1==m2) &#123; mx[pos]=v2[pos]; mi[pos]=v2[pos]-1; for(int i=0; i&lt;pos; i++) &#123; mi[i]=k-1; &#125; return m2; &#125; else &#123; mx[pos]=mi[pos]=v2[pos]-1; for(int i=0; i&lt;pos; i++) &#123; mi[i]=mx[i]=k-1; &#125; return m2; &#125; &#125; else &#123; return (k-1)*(pos+1); &#125;&#125;int cas=1;int main() &#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%lld%lld%lld&quot;,&amp;k,&amp;l,&amp;r); v1.clear(); v2.clear(); LL x=r; while(x&gt;0) &#123; v2.push_back(x%k); x/=k; &#125; x=l; while(x&gt;0) &#123; v1.push_back(x%k); x/=k; &#125; while(v1.size()&lt;v2.size()) &#123; v1.push_back(0); &#125; p[0]=1; for(int i=1; i&lt;v2.size(); i++) &#123; p[i]=p[i-1]*k; &#125; int pos=v2.size()-1; mi.resize(v2.size()); mx.resize(v2.size()); while(pos&gt;=0) &#123; if(v1[pos]==v2[pos]) &#123; mi[pos]=mx[pos]=v2[pos]; &#125; else break; pos--; &#125; if(pos!=-1)dfs(pos,1); LL a=0,b=0,m=0,flag=1; for(int i=mx.size()-1; i&gt;=0; i--) &#123; m+=mx[i]; if(mx[i]!=0)flag=0; if(flag)m--; b+=mx[i]*p[i]; a+=mi[i]*p[i]; &#125; m=m+mx.size()-2; printf(&quot;Case #%d: %lld %lld %lld\n&quot;,cas++,m,a,b); &#125; return 0; //Áúã‰∏çÊáÇÁïôË®Ä0.0ÔºåÊàñËÄÖÂä†Q3035536707&#125;]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 CCPC-Wannafly Winter Camp Day2ÔºàDiv2Ôºâ]]></title>
    <url>%2F2019%2F01%2F28%2F2019%20CCPC-Wannafly%20Winter%20Camp%20Day2%EF%BC%88Div2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Camp ÁöÑÈ¢òÊòØÁúüÁöÑÈöæÔºåËøòÂ•ΩÊ≤°ÂéªÔºå‰∏çÁÑ∂Ë¶ÅË¢´Ë°ÄËôê„ÄÇ ÂÅö‰∫ÜDay2ÁöÑÂá†ÈÅìÈ¢ò„ÄÇ AÈ¢òÔºåErase Numbers II Ëøô‰∏™Êå∫ÁÆÄÂçïÁöÑÔºåÂ∞±ÊòØËåÉÂõ¥ÁÇ∏‰∫Ülong long ,Êö¥ÂäõÊûö‰∏æ‰∏§‰∏™Êï∞Â∞±Ë°å‰∫Ü„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;//typedef long long LL;typedef unsigned long long LL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=6e3+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;int t,n;LL a[maxn],m1=0,ans1,ans2;LL k(LL x,LL y)&#123; LL k=x; while(k&gt;0)&#123; k/=10; y*=10; &#125; return y+x;&#125;int main() &#123; scanf(&quot;%d&quot;,&amp;t); int cas=1; while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); m1=0; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;a[i]; &#125; ans1=ans2=0; for(int i=0;i&lt;n;i++)&#123; for(int j=i+1;j&lt;n;j++)ans1=max(ans1,k(a[j],a[i])); &#125; printf(&quot;Case #%d: &quot;,cas++); cout&lt;&lt;ans1&lt;&lt;endl; &#125; return 0;&#125; BÈ¢òÔºöErase Numbers I È¢òÊÑèÔºöÂà†Èô§‰∏§‰∏™Êï∞ÔºåÊúÄÂêéËøûËµ∑Êù•ÁöÑÊï∞Â≠óÁªìÊûúÊúÄÂ§ß„ÄÇ ËøôÈ¢òÊö¥ÂäõËøá‰∫ÜÔºåÂÆûÈôÖ‰∏äÊö¥ÂäõÊòØËøá‰∏ç‰∫ÜÔºåÊú¨Êù•Ë¶ÅÈ¢ÑÂ§ÑÁêÜ‰∏Ä‰∏ãÔºåÂà†Èô§‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫ LÁöÑÊï∞Â≠ó‰∏≤ÔºåÁ¨¨‰∏Ä‰∏™‰∏çÂêåÁöÑÊï∞Â≠óÁöÑ‰ΩçÁΩÆÔºå ÊØîÂ¶ÇÔºö12 55 58 Âà†Èô§Á¨¨‰∫å‰∏™ Â≠óÁ¨¶‰∏≤ÁöÑÊó∂ÂÄôÔºå ‰ºöÂèòÊàê 1258ÔºåÂíåÂéüÂ≠óÁ¨¶‰∏≤ 125558 Â≠óÁ¨¶ÊòØ 5 Âíå8 ‰∏çÂêåÔºàËøô‰∏™Âú∞ÊñπÂè™ÊòØ‰∏æ‰æãËØ¥ÊòéÂà†‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤Ôºâ ‰ΩÜÊòØÂá∫È¢ò‰∫∫Â•ΩÂÉèÊ≤°ÊúâÁâπÊÑèÂç°ÔºåÂ∞±Áõ¥Êé•Êö¥ÂäõËøá‰∫Ü 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;//#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot;&lt;&lt;endl;const int maxn=6e3+5;int a[maxn],b[maxn],t,n,mi,a1,a2;char s[maxn*10];char c[maxn][15];bool pd(int pos) &#123; int pos2=pos+1,i=0,j=0; // Â∞±ÊòØËøô‰∏™Âú∞ÊñπË¶ÅÊú¨Êù•ÊòØË¶ÅÈ¢ÑÂ§ÑÁêÜÁöÑÔºå‰ΩÜÊòØÊö¥ÂäõÊØèÊ¨°ÊØîËæÉ‰πüÂèØ‰ª•Ëøá while(1) &#123; if(c[pos][i]&lt;c[pos2][j]) &#123; return 1; &#125; else if(c[pos][i]&gt;c[pos2][j]) &#123; return 0; &#125; i++; j++; if(i==b[pos]) &#123; pos++; i=0; &#125; if(j==b[pos2]) &#123; pos2++; j=0; &#125; if(pos2==n)return 1; &#125;&#125;bool pd2(int pos) &#123; int pos2=pos+1,i=0,j=0; while(1) &#123; if(pos==a1)pos++; if(pos2==a1)pos2++; if(c[pos][i]&lt;c[pos2][j]) &#123; return 1; &#125; else if(c[pos][i]&gt;c[pos2][j]) &#123; return 0; &#125; i++; j++; if(i==b[pos]) &#123; pos++; i=0; &#125; if(j==b[pos2]) &#123; pos2++; j=0; &#125; if(pos2==n)return 1; &#125;&#125;int main() &#123; scanf(&quot;%d&quot;,&amp;t); int cas=1; while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); mi=100; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%s&quot;,c[i]); b[i]=strlen(c[i]); a[i]=0; for(int j=0; j&lt;b[i]; j++) &#123; a[i]=a[i]*10+c[i][j]-&apos;0&apos;; &#125; mi=min(mi,b[i]); &#125; a1=-1; for(int i=0; i&lt;n; i++) &#123; if(b[i]==mi) &#123; if(pd(i)) &#123; a1=i; break; &#125; &#125; &#125; if(a1==-1) &#123; for(int i=n-1; i&gt;=0; i--) &#123; if(b[i]==mi) &#123; a1=i; break; &#125; &#125; &#125; mi=100; a2=-1; for(int i=0; i&lt;n; i++) &#123; if(i==a1)continue; mi=min(b[i],mi); &#125; for(int i=0; i&lt;n; i++) &#123; if(i==a1)continue;; if(b[i]==mi) &#123; if(pd2(i)) &#123; a2=i; break; &#125; &#125; &#125; if(a2==-1) &#123; for(int i=n-1; i&gt;=0; i--) &#123; if(i==a1)continue; if(b[i]==mi) &#123; a2=i; break; &#125; &#125; &#125; printf(&quot;Case #%d: &quot;,cas++); for(int i=0; i&lt;n; i++) &#123; if(i==a1||a2==i)continue; printf(&quot;%d&quot;,a[i]); &#125; puts(&quot;&quot;); &#125; return 0;&#125; HÈ¢òÔºöCosmic Cleaner È¢òÊÑèÔºöÈóÆÂà†Èô§ÁöÑÁêÉÂíåÂéüÊù•ÁªôÁöÑËøô‰∫õÁêÉÁõ∏‰∫§ÁöÑ‰ΩìÁßØÊúâÂ§öÂ∞ë„ÄÇ Ë¥¥‰∏™Ê±ÇÁêÉÁõ∏‰∫§ÁöÑ‰ΩìÁßØÊùøÂ≠êÂ∞±Ë°å‰∫Ü0.0. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889 #include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#define CLR(a,b) memset(a,b,sizeof(a));using namespace std;const double PI = acos(-1);const int maxn= 105;typedef struct point &#123; double x,y,z; point() &#123; &#125; point(double a, double b,double c) &#123; x = a; y = b; z = c; &#125; point operator -(const point &amp;b)const &#123; //ËøîÂõûÂáèÂéªÂêéÁöÑÊñ∞ÁÇπ return point(x - b.x, y - b.y,z-b.z); &#125; point operator +(const point &amp;b)const &#123; //ËøîÂõûÂä†‰∏äÂêéÁöÑÊñ∞ÁÇπ return point(x + b.x, y + b.y,z+b.z); &#125; //Êï∞‰πòËÆ°ÁÆó point operator *(const double &amp;k)const &#123; //ËøîÂõûÁõ∏‰πòÂêéÁöÑÊñ∞ÁÇπ return point(x * k, y * k,z*k); &#125; point operator /(const double &amp;k)const &#123; //ËøîÂõûÁõ∏Èô§ÂêéÁöÑÊñ∞ÁÇπ return point(x / k, y / k,z/k); &#125; double operator *(const point &amp;b)const &#123; //ÁÇπ‰πò return x*b.x + y*b.y+z*b.z; &#125;&#125; point;double dist(point p1, point p2) &#123; //ËøîÂõûÂπ≥Èù¢‰∏ä‰∏§ÁÇπË∑ùÁ¶ª return sqrt((p1 - p2)*(p1 - p2));&#125;typedef struct sphere &#123;//ÁêÉ double r; point centre;&#125; sphere;sphere s,a[maxn];void SphereInterVS(sphere a, sphere b,double &amp;v,double &amp;s) &#123; double d = dist(a.centre, b.centre);//ÁêÉÂøÉË∑ù double t = (d*d + a.r*a.r - b.r*b.r) / (2.0 * d);// double h = sqrt((a.r*a.r) - (t*t)) * 2;//h1=h2ÔºåÁêÉÂÜ†ÁöÑÈ´ò double angle_a = 2 * acos((a.r*a.r + d*d - b.r*b.r) / (2.0 * a.r*d)); //‰ΩôÂº¶ÂÖ¨ÂºèËÆ°ÁÆór1ÂØπÂ∫îÂúÜÂøÉËßíÔºåÂºßÂ∫¶ double angle_b = 2 * acos((b.r*b.r + d*d - a.r*a.r) / (2.0 * b.r*d)); //‰ΩôÂº¶ÂÖ¨ÂºèËÆ°ÁÆór2ÂØπÂ∫îÂúÜÂøÉËßíÔºåÂºßÂ∫¶ double l1 = ((a.r*a.r - b.r*b.r) / d + d) / 2; double l2 = d - l1; double x1 = a.r - l1, x2 = b.r - l2;//ÂàÜÂà´‰∏∫‰∏§‰∏™ÁêÉÁº∫ÁöÑÈ´òÂ∫¶ double v1 = PI*x1*x1*(a.r - x1 / 3);//Áõ∏‰∫§ÈÉ®ÂàÜr1ÂúÜÊâÄÂØπÂ∫îÁöÑÁêÉÁº∫ÈÉ®ÂàÜ‰ΩìÁßØ double v2 = PI*x2*x2*(b.r - x2 / 3);//Áõ∏‰∫§ÈÉ®ÂàÜr2ÂúÜÊâÄÂØπÂ∫îÁöÑÁêÉÁº∫ÈÉ®ÂàÜ‰ΩìÁßØ v = v1 + v2;//Áõ∏‰∫§ÈÉ®ÂàÜ‰ΩìÁßØ double s1 = PI*a.r*x1; //r1ÂØπÂ∫îÁêÉÂÜ†Ë°®Èù¢ÁßØ double s2 = PI*a.r*x2; //r2ÂØπÂ∫îÁêÉÂÜ†Ë°®Èù¢ÁßØ s = 4 * PI*(a.r*a.r + b.r*b.r) - s1 - s2;//Ââ©‰ΩôÈÉ®ÂàÜË°®Èù¢ÁßØ&#125;int t, n;double x, y, z, r;int cas = 1;int main() &#123; cin &gt;&gt; t; while(t--) &#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%lf%lf%lf%lf&quot;,&amp;x,&amp;y,&amp;z,&amp;a[i].r); //ÂÖ∂‰ªñÁêÉ a[i].centre = &#123;x,y,z&#125;; &#125; scanf(&quot;%lf%lf%lf%lf&quot;,&amp;x,&amp;y,&amp;z,&amp;r); s.r = r; s.centre = &#123;x,y,z&#125;; //‰∏≠ÂøÉÁêÉ double ans = 0, v = 0; for(int i = 1; i &lt;= n; i++) &#123; double ss, dis = dist(s.centre, a[i].centre); if(dis &gt;= s.r + a[i].r)continue; //Âú®Â§ñÈÉ® if(dis + min(s.r, a[i].r) &lt;= max(s.r, a[i].r)) &#123; //Âú®ÂÜÖÈÉ® ans += 4.0 / 3.0 * PI * min(s.r,a[i].r) * min(s.r,a[i].r) * min(s.r,a[i].r); continue; &#125; SphereInterVS(s, a[i], v, ss); //Áõ∏‰∫§ÈÉ®ÂàÜ ans += v; &#125; printf(&quot;Case #%d: %.14f\n&quot;,cas++,ans); &#125;&#125;//ÊêúÁ¥¢ÊùøÂ≠êÔºåÊêúÂà∞ÁöÑ‰∏ÄÂêçÂ§ß‰Ω¨ÁöÑÔºåÊàëÊîπÈÉΩÊ≤°ÊîπÂ∞±Áõ¥Êé•Ëøá‰∫Ü0.0 KÈ¢òÔºöSticks È¢ÑÂ§ÑÁêÜÂá∫ÊâÄÊúâÂàÜÁªÑÊÉÖÂÜµÔºå‰∏ÄÂÖ±ÊòØ C(3,12)C(3,9)C(3,6) /24Áßç„ÄÇ 15400Áßç ËÆ©ÂêéÊö¥ÂäõÊ±ÇËß£ 15400*6000Á´üÁÑ∂Âà§Êñ≠Ëøá‰∫Ü0.0 È¢òÁõÆÊ≤°ËØ¥Ë¶ÅÊÄé‰πàËæìÂá∫Á≠îÊ°àÔºåÁÑ∂ÂêéÊàëÁî®SET Èîô‰∫ÜÔºåÁî®vector Ëøá‰∫Ü„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot;&lt;&lt;endl;const int maxn=369605;int a[20];struct th &#123; short x[4][3]; bool operator&lt;(const th&amp; t) const &#123; &#125;&#125; dat,pa[maxn];int u[20],k=0;void dfs(int p) &#123; if(p==4) &#123; pa[k]=dat; k++; return ; &#125; for(int i=0; i&lt;12; i++) &#123; if(u[i])continue; if(dat.x[p-1][0]&gt;i)continue; //Ëøô‰∏™ÊòØÂéªÈáçÁöÑÔºå‰ºöÊúâÈáçÂ§çÁöÑÊÉÖÂÜµ for(int i2=i+1; i2&lt;12; i2++) &#123; if(u[i2])continue; for(int i3=i2+1; i3&lt;12; i3++) &#123; if(u[i3])continue; dat.x[p][0]=i; dat.x[p][1]=i2; dat.x[p][2]=i3; u[i]=u[i2]=u[i3]=1; dfs(p+1); u[i]=u[i2]=u[i3]=0; &#125; &#125; &#125;&#125;int t,cas=1;int main() &#123; dfs(0); debug(k); scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; for(int i=0; i&lt;12; i++) scanf(&quot;%d&quot;,&amp;a[i]); int num=0,ans; for(int i=0;i&lt;k;i++) &#123; int tnum=0; for(int j=0; j&lt;4; j++) &#123; int m1=a[pa[i].x[j][0]],m2=a[pa[i].x[j][1]],m3=a[pa[i].x[j][2]]; if(m1+m2&gt;m3&amp;&amp;m2+m3&gt;m1&amp;&amp;m3+m1&gt;m2)tnum++; &#125; if(tnum&gt;num) &#123; num=tnum; ans=i; &#125; if(num==4)break; &#125; printf(&quot;Case #%d: %d\n&quot;,cas++,num); if(num==0)continue; for(int j=0; j&lt;4; j++) &#123; int m1=a[pa[ans].x[j][0]],m2=a[pa[ans].x[j][1]],m3=a[pa[ans].x[j][2]]; if(m1+m2&gt;m3&amp;&amp;m2+m3&gt;m1&amp;&amp;m3+m1&gt;m2)&#123; printf(&quot;%d %d %d\n&quot;,m1,m2,m3); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-2019 ACM-ICPC, Asia Nanjing Regional Contest M]]></title>
    <url>%2F2019%2F01%2F23%2F2018-2019%20ACM-ICPC%2C%20Asia%20Nanjing%20Regional%20Contest%20M%2F</url>
    <content type="text"><![CDATA[2018-2019 ACM-ICPC, Asia Nanjing Regional Contest M Êâ©Â±ïKMP+È©¨ÊãâËΩ¶ÂõûÊñá‰∏≤ s:ababa t:aba È¢òÊÑèÔºöÂ∞ÜÁ¨¨‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ÁöÑ‰∏Ä‰∏™Â≠ó‰∏≤Ôºå‰∏éÁ¨¨‰∫å‰∏™Â≠óÁ¨¶‰∏≤‰ªé (0-k)ÁöÑÂ≠óÁ¨¶ËøûÂú®‰∏ÄËµ∑ÂèØ‰ª•Êàê‰∏∫ÂõûÊñáÂ≠óÁ¨¶‰∏≤Ôºå‰∏îÁ¨¨‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤Â≠ó‰∏≤ÁöÑÈïøÂ∫¶ÊØîÁ¨¨‰∫å‰∏™Â≠óÁ¨¶‰∏≤ÁöÑÈïøÂ∫¶Ë¶ÅÂ§ß„ÄÇ Ë¶ÅÊûÑÊàêÁöÑÁöÑÂõûÊñáÂ≠óÁ¨¶‰∏≤ ‰∏§ÈÉ®ÂàÜÊûÑÊàê s‚Äô Á¨¨‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ÁöÑÂ≠ó‰∏≤ÔºåÂíåÁ¨¨‰∫å‰∏™Â≠óÁ¨¶‰∏≤ÁöÑÂâçÁºÄt‚ÄôÔºåÊûÑÊàê‰∏Ä‰∏™ÂõûÊñáÂ≠óÁ¨¶‰∏≤„ÄÇ ÈÇ£‰πàÂ¶ÇÊûúÊääÁ¨¨‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ÂÄíËøáÊù•Ôºå ÈÇ£Â∞±Áõ∏ÂΩì‰∫éÔºås‚Äô ÁöÑ‰∏ÄÈÉ®ÂàÜÊòØÂíå t‚ÄôÊòØÁõ∏ÂêåÁöÑÔºås‚ÄôËøòÊúâ‰∏ÄÈÉ®ÂàÜÊòØÂõûÊñáÂ≠óÁ¨¶‰∏≤„ÄÇ ÈÇ£‰πàs‚Äô‰∏ét‚ÄôÁõ∏ÂêåÁöÑÈïøÂ∫¶ * ‰ªéÂΩìÂâç‰ΩçÁΩÆËÉΩÂ§ü‰∫ßÁîüÁöÑÂõûÊñá‰∏≤Êï∞ÈáèÔºåÂ∞±Áõ∏ÂΩìËÉΩÂ§üÊûÑÊàêÁöÑÂõûÊñá‰∏≤‰∏™Êï∞„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot;&lt;&lt;endl;const int maxn=1e6+5;int nxt[maxn*2],ex[maxn*2];void getnext(char * str) &#123; int i=0,j,po,len=strlen(str); nxt[0]=len; while(i+1&lt;len&amp;&amp;str[i]==str[i+1])i++; nxt[1]=i; po=1,j=0; for(i=2; i&lt;len; i++) &#123; int p=nxt[po]+po; if(nxt[i-po]+i&lt;p) &#123; nxt[i]=nxt[i-po]; &#125; else &#123; j=p-i; if(j&lt;0)j=0; while(i+j&lt;len&amp;&amp;str[j]==str[j+i]) j++; nxt[i]=j; po=i; &#125; &#125;&#125;void exkmp(char *s1,char *s2) &#123; int i=0,j,po,len=strlen(s1),l2=strlen(s2); getnext(s2); while(s1[i]==s2[i]&amp;&amp;i&lt;l2&amp;&amp;i&lt;len)i++; ex[0]=i; po=0; for(i=1; i&lt;len; i++) &#123; int p=ex[po]+po; if(nxt[i-po]+i&lt;p) &#123; ex[i]=nxt[i-po]; &#125; else &#123; j=max(0,p-i); while(i+j&lt;len&amp;&amp;j&lt;l2&amp;&amp;s1[i+j]==s2[j]) &#123; j++; &#125; ex[i]=j; po=i; &#125; &#125;&#125;char Ma[maxn*2];int Mp[maxn*2],pos[maxn*2];int dp[maxn*2],cnt[maxn];void Manacher(char s[],int len) &#123; //‰∏ÄÂêçÂ§ß‰Ω¨ÁöÑÂÜôÊ≥ï0.0 memset(pos,-1,sizeof(pos)); int l=0; Ma[l++]=&apos;$&apos;; Ma[l++]=&apos;#&apos;; for(int i=0; i&lt;len; i++) &#123; pos[l]=i; Ma[l++]=s[i]; Ma[l++]=&apos;#&apos;; &#125; Ma[l]=0; int mx=0,id=0; for(int i=0; i&lt;l; i++) &#123; Mp[i]=mx&gt;i?std::min(Mp[2*id-i],mx-i):1; while(i-Mp[i]&gt;=0&amp;&amp;Ma[i+Mp[i]]==Ma[i-Mp[i]]) Mp[i]++; if(i+Mp[i]&gt;mx) &#123; mx=i+Mp[i]; id=i; &#125; &#125; for(int i=0; i&lt;l; i++) &#123; dp[i+Mp[i]-1]++; if(i&gt;0) dp[i-1]--; &#125; for(int i=l-1; i&gt;=0; i--) &#123; dp[i]+=dp[i+1]; &#125; for(int i=0; i&lt;l; i++) &#123; if(pos[i]==-1) continue; cnt[pos[i]]=dp[i]; &#125;&#125;char s[maxn],c[maxn];int main() &#123; scanf(&quot;%s%s&quot;,s,c); int len=strlen(s); reverse(s,s+len); Manacher(s,len); exkmp(s,c); LL ans=0; for(int i=1; i&lt;len; i++) &#123; ans+=1LL*cnt[i-1]*ex[i]; &#125; printf(&quot;%lld\n&quot;,ans); return 0;&#125;]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF201812 JAVA]]></title>
    <url>%2F2019%2F01%2F16%2FCCF201812%20JAVA%2F</url>
    <content type="text"><![CDATA[ÂèëÁé∞JAVAÊØîC++ÊÖ¢‰∫Ü‰∏çÊ≠¢‰∏ÄÊòüÂçäÁÇπ C++ËÉΩÁõ¥Êé•ËøáÔºåËøô‰∏™JAVAÂç°ÊûÅÈôêËøá‰∫Ü Á¨¨‰∏Ä‰∫åÈ¢òÔºåÈöè‰æøÂÜô‰∏Ä‰∏ãÊ≤°Âï•ÈöæÂ∫¶ÔºåÁõ¥Êé•ÂÜôÁ¨¨4È¢òÁöÑ‰ª£Á†Å CCF201812-4123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner input=new Scanner(System.in); int n,m,r; n=input.nextInt(); m=input.nextInt(); r=input.nextInt(); Point arr[]=new Point[m]; for(int i=0;i&lt;m;i++) arr[i]=new Point(); for(int i=0;i&lt;m;i++)&#123; arr[i].x=input.nextInt(); arr[i].y=input.nextInt(); arr[i].c=input.nextInt(); &#125; Arrays.sort(arr, new MyComprator()); int ans=0; int k=0; int []par=new int[m+1]; for(int i=1;i&lt;=m;i++)par[i]=i; for(int i=0;i&lt;m;i++)&#123; int x=find(arr[i].x,par),y=find(arr[i].y,par); if(x!=y) &#123; par[x] = y; ans = arr[i].c; k++; &#125; if(k==n-1)break; &#125; System.out.println(ans); &#125; static int find(int x,int[] par)&#123; return x==par[x] ? x : (par[x]=find(par[x],par)); &#125;&#125;class Point&#123; int x,y,c;&#125;class MyComprator implements Comparator &#123; public int compare(Object arg0, Object arg1) &#123; Point t1=(Point)arg0; Point t2=(Point)arg1; return t1.c&gt;t2.c? 1:-1; &#125;&#125;]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 528 (Div. 2, based on Technocup 2019 Elimination Round 4)]]></title>
    <url>%2F2018%2F12%2F24%2FCodeforces%20Round%20528%20(Div.%202%2C%20based%20on%20Technocup%202019%20Elimination%20Round%204)%2F</url>
    <content type="text"><![CDATA[ÈöèÊâãÂÜô‰∏ÄÁØáÂçöÂÆ¢Âêß0.0 A. Right-Left Cipher Áõ¥Êé•Ê®°ÊãüÔºåÂÅ∂Êï∞Âú®Â∑¶ËæπÔºåÂ•áÊï∞Âú®Âè≥Ëæπ„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;char s[maxn],t[maxn];int main() &#123; cin&gt;&gt;t; int l=strlen(t); int k=l-1; if(l&amp;1)k++; for(int i=0; i&lt;(l+1)/2; i++) &#123; s[k]=t[i]; k-=2; &#125; k=2; for(int i=(l+1)/2; i&lt;l; i++) &#123; s[k]=t[i]; k+=2; &#125; for(int i=1; i&lt;=l; i++)printf(&quot;%c&quot;,s[i]); return 0;&#125; B. Div Times Mod Áõ¥Êé•Êö¥ÂäõÊûö‰∏æÂïäÔºå‰∏çÂ∞±ÊòØ a*k+b=x b=n/a,Áõ¥Êé•Êö¥ÂäõÊûö‰∏ænÁöÑÂõ†Â≠ê„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;LL n,k;int main() &#123; cin&gt;&gt;n&gt;&gt;k; LL ans=inf*inf; for(LL i=1; i&lt;=n; i++) &#123; if(n%i==0&amp;&amp;n/i&lt;k) &#123; ans=min(ans,k*i+n/i); &#125; &#125; cout&lt;&lt;ans&lt;&lt;&quot;\n&quot;; return 0;&#125; C. Connect Three Áõ¥Êé•ÊÉ≥Ë±°ÊÄé‰πàËµ∞ÊúÄËøëÔºåÈöè‰æøÁûéÂá†ÊääÂÜôÔºåÊï∞ÊçÆÊúâÁÇπÊ∞¥ÔºåÊàëÊï∞ÁªÑÂºÄÂ∞è‰∫ÜÈÉΩËøá‰∫ÜÔºåÁªìÊûúË¢´fst‰∫Ü„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e3+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;int a[3],b[3];pair&lt;int,int&gt;p[3];int x[maxn*100],y[maxn*1000];int mp[maxn][maxn];int main() &#123; for(int i=0; i&lt;3; i++) &#123; scanf(&quot;%d%d&quot;,&amp;a[i],&amp;b[i]); p[i].first=a[i]; p[i].second=b[i]; &#125; sort(a,a+3); sort(b,b+3); sort(p,p+3); printf(&quot;%d\n&quot;,a[2]-a[0]+b[2]-b[0]+1); int x1=p[0].first,y1=p[0].second,x2=p[1].first,x3=a[2];// debug(x1);// debug(x2);// debug(x3); int k=0; for(int i=0;i&lt;=x2-x1;k++,i++)&#123; x[k]=x1+i; y[k]=y1; mp[x[k]][y[k]]=1; &#125; for(int i=0;i&lt;=b[2]-b[0];i++)&#123; if(mp[x2][b[0]+i])continue; x[k]=x2; y[k]=b[0]+i; mp[x[k]][y[k]]=1; k++; &#125; for(int i=1;i&lt;=x3-x2;i++)&#123; if(mp[x2+i][p[2].second])continue;// debug(y[0]); x[k]=x2+i; y[k]=p[2].second; k++;// debug(k); &#125; k=a[2]-a[0]+b[2]-b[0]+1; for(int i=0;i&lt;k;i++) printf(&quot;%d %d\n&quot;,x[i],y[i]); return 0;&#125; D. Minimum Diameter Tree Áõ¥ÂæÑÊòØÈÄöËøáÊùÉÂÄºÂàÜÈÖçÊù•ÊêûÂÆöÁöÑÔºåË¶ÅÁõ¥ÂæÑÊúÄÂ§ßÂÄºÊúÄÂ∞è„ÄÇÁõ¥ÂæÑÊúÄÂ§ßÂÄºËÇØÂÆöÊòØ‰ªéÊØè‰∏Ä‰∏™Âè∂Â≠êËµ∞Âà∞Âè¶‰∏Ä‰∏™Âè∂Â≠êÔºåÊâÄ‰ª•Áõ¥Êé•ÁÆóÊúâÂ§öÂ∞ë‰∏™Âè∂Â≠êÔºåÁ≠îÊ°àÂ∞±ÊòØs*2.0/(Âè∂Â≠êÊï∞Èáè)„ÄÇ‰ªªÊÑè‰∏§‰∏™Âè∂Â≠ê‰πãÈó¥ÁöÑË∑ùÁ¶ªÁõ∏ÂêåÔºåÂ∞±ÊòØÊúÄÂ∞è„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const LL inf=0x3f3f3f3f;const double eps=1e-8;vector&lt;int&gt; G[maxn];int pre[maxn],in[maxn];int k[maxn],u[maxn];int main() &#123; int n; double s; scanf(&quot;%d%lf&quot;,&amp;n,&amp;s); for(int i=0; i&lt;n-1; i++) &#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); in[a]++; in[b]++; G[a].push_back(b); G[b].push_back(a); &#125; double ans=0; for(int i=1; i&lt;=n; i++) &#123; if(in[i]==1) &#123; ans+=1; &#125; &#125; printf(&quot;%.10f&quot;,s*2.0/ans); return 0;&#125;]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 526 (Div. 2)]]></title>
    <url>%2F2018%2F12%2F13%2FCodeforces%20Round%20526%20(Div.%202)%2F</url>
    <content type="text"><![CDATA[Âæà‰πÖÊ≤°ÂÜô‰ª£Á†Å‰∫Ü„ÄÇÈöè‰æøÂà∑‰∫Ü‰∏Ä‰∏ãCF C. The Fair Nut and String ÂÖàÁªüËÆ°‰∏Ä‰∏ãË¢´‚Äôb‚ÄôÂàÜÈöîÁöÑ‚Äòa‚ÄôÊúâÂ§öÂ∞ë‰∏™ÔºåÊîæÂà∞‰∏Ä‰∏™Êï∞ÁªÑÈáåÈù¢ÔºåÊØîÂ¶ÇËØ¥Ôºåababaaba a[0]=1,a[1]=1,a[2]=2,a[3]=1; ÁÑ∂ÂêéÁÆó‰∏Ä‰∏ãÊÄªÊñπÊ°àÊï∞ÔºåËøô‰∏™ÊúâÁÇπÈöæËß£ÈáäÔºåÂ∞±ÊòØÂèñËøô‰∏™‰πãÂâçÊâÄÊúâÁöÑÊñπÊ°àÊï∞*Ëøô‰∏™ÈáåÈù¢ÁöÑ‰∏™Êï∞ÔºåÂÜçÂä†‰∏äÂè™ÂèñËøô‰∏™ÈáåÈù¢ÁöÑ‰∏™Êï∞„ÄÇ Â∑Æ‰∏çÂ§öÂ∞±ÊòØËøô‰πàÁÆóÁöÑ:sum[i]=sum[i-1]*a[i]+a[i]; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;char s[maxn];LL ans[maxn];long long n,k,num,sum,ct;int main() &#123; scanf(&quot;%s&quot;,s); int l = strlen(s); k=0; ct=1; for(int i = 0 ; i &lt; l ; i ++) &#123; if(s[i]==&apos;a&apos;)&#123; n++; ct=0; &#125; if(s[i]==&apos;b&apos;)&#123; if(ct==0)ans[k++]=n; ct=1; n=0; &#125; &#125; if(!ct)ans[k++]=n; for(int i = 0 ; i &lt; k ; i++)&#123; sum+=sum*ans[i]; sum%=mod; sum+=ans[i]; sum%=mod; &#125; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125; D. The Fair Nut and the Best Path ËøôÈ¢òÊòØ‰∏™Ê†ëÂΩ¢DPÔºåÊØèÊ¨°ÈÄâÊúÄËæπ‰∏äÁöÑËäÇÁÇπÔºåÂ¶ÇÊûú‰∏Ä‰∏™ËäÇÁÇπÂë®Âõ¥ÁöÑËäÇÁÇπÂè™Êúâ‰∏Ä‰∏™Ê≤°Ëµ∞Ëøá‰∫ÜÂ∞±ÊääËøô‰∏™ËäÇÁÇπÂä†Âà∞ÈòüÂàóÈáåÈù¢ÂèñÂà§Êñ≠„ÄÇ Â¶ÇÊûú‰Ω†ÈÄâÁöÑËäÇÁÇπÊòØÊúÄÂ§ßÁöÑÊ≤πÈáè‰∏≠ÁöÑ‰∏Ä‰∏™ÔºåÈÇ£‰πàÔºå‰∏ÄÂÆöÁ≠â‰∫éÂë®Âõ¥‰∏§‰∏™ÊúÄÂ§ß‰∏îÂ§ß‰∫éÈõ∂ÁöÑËäÇÁÇπÊÉ≥Âä†Ôºå‰∏îÂä†‰∏äËá™Â∑±ÁöÑÊ≤πÈáè„ÄÇÂÖ∑‰ΩìÁúã‰ª£Á†ÅÂêßÔºåÁÑ∂ÂêédpÊØèÊ¨°‰øùÂ≠òÂà∞Ëøô‰∏™ËäÇÁÇπÊúÄÂ§ßÊ≤πÈáè„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,in[maxn];LL w[maxn],ans,dp[maxn];int used[maxn];struct two &#123; LL to,c;&#125;;int k;vector&lt;two&gt; G[maxn];int main() &#123; scanf(&quot;%d&quot;,&amp;n); for(int i = 1 ; i &lt;= n ; i ++) &#123; scanf(&quot;%lld&quot;,&amp;w[i]); &#125; two t; for(int i = 0 ; i &lt; n-1; i++) &#123; int u,v,c; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;c); t.c=c; t.to=v; G[u].push_back(t); t.to=u; G[v].push_back(t); in[u]++; in[v]++; &#125; queue&lt;int&gt;q; for(int i = 1 ; i &lt;= n ; i++) &#123; if(in[i]&lt;=1) &#123; q.push(i); &#125; &#125; LL max1=0,max2=0; LL ans=0; while(q.size()) &#123; int node=q.front(); q.pop(); max1=max2=0; for(auto i:G[node]) &#123; if(used[i.to]==1) &#123; LL temp=dp[i.to]-i.c; if(temp&gt;max1) &#123; swap(max1,temp); &#125; if(temp&gt;max2) &#123; swap(max2,temp); &#125; &#125; else &#123; in[i.to]--; if(in[i.to]&lt;=1)&#123; q.push(i.to); &#125; &#125; &#125; used[node]=1; LL temp=max1+max2+w[node]; ans=max(ans,temp); dp[node]=temp-max2; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[camera.ScreenToWorldPoint‰ΩøÁî®Âá∫Áé∞ÂºïÁî®ÈîôËØØ]]></title>
    <url>%2F2018%2F12%2F06%2Fcamera.ScreenToWorldPoint%E4%BD%BF%E7%94%A8%E5%87%BA%E7%8E%B0%E5%BC%95%E7%94%A8%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[‰ΩøÁî®camera.ScreenToWorldPointÂá∫Áé∞Â¶Ç‰∏ãÈîôËØØ NullReferenceException: Object reference not set to an instance of an object PlayerController.FixedUpdate () (at Assets/Scenes/PlayerController.cs:37) Ê≤°ÊúâËÆæÁΩÆ‰∏ªÁõ∏Êú∫]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity 3D Á≤íÂ≠êÊí≠Êîæ]]></title>
    <url>%2F2018%2F12%2F03%2FUnity%203D%20%E7%B2%92%E5%AD%90%E6%92%AD%E6%94%BE%2F</url>
    <content type="text"><![CDATA[gameObject.GetCompoment().Play();Êí≠Êîæ gameObject.GetCompoment().Pause();ÊöÇÂÅú gameObject.GetCompoment().Stop();ÂÅúÊ≠¢]]></content>
      <categories>
        <category>Ê∏∏Êàè</category>
        <category>U3D</category>
      </categories>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity3dÂºÄÂèë‰∏≠ÔºåÁî®VSÊâìÂºÄËÑöÊú¨Êñá‰ª∂‰∏çËá™Âä®Ë°•ÂÖ®]]></title>
    <url>%2F2018%2F12%2F03%2Funity3d%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8C%E7%94%A8VS%E6%89%93%E5%BC%80%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6%E4%B8%8D%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%2F</url>
    <content type="text"><![CDATA[ËÆæÁΩÆ‰∏Ä‰∏ãÈªòËÆ§‰ª£Á†ÅËΩØ‰ª∂ÔºåËøô‰∏™ÊòØÂõ†‰∏∫Êñá‰ª∂‰∏çÊòØÈªòËÆ§Áî®VSÊâìÂºÄÁöÑ„ÄÇ ËøõÂÖ•Edit-&gt;Preferences External Tools ÊääVSËÆæÊàêÁºñËæëÂô®Â∞±ÂèØ‰ª•‰∫Ü„ÄÇ]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ê±áÁºñËØ≠Ë®ÄÂÆûÈ™åÂçÅËøõÂà∂2ËøõÂà∂16ËøõÂà∂ËΩ¨Êç¢ËæìÂá∫]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E8%BF%9B%E5%88%B62%E8%BF%9B%E5%88%B616%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[‰ªéÈîÆÁõòËæìÂÖ•‰∏Ä‰∏™0‚Äì255‰πãÈó¥ÁöÑÊï¥Êï∞ÔºåÂú®Â±èÂπï‰∏äÊòæÁ§∫Âá∫ËØ•Êï¥Êï∞ÂØπÂ∫îÁöÑ‰∫åËøõÂà∂ÂíåÂçÅÂÖ≠ËøõÂà∂Êï∞„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178 DATA SEGMENTMEG DB &apos;Please input a number(0~255):&apos;,0DH,0AH,&apos;$&apos;ME2 DB 0DH,0AH,&apos;Input a invalid number,exit!&apos;,0DH,0AH,&apos;$&apos;X DB ?Y DB 0AHBUF DB 10 DB ? DB 10 DUP(?)BU2 DB &apos;0&apos;,&apos;$&apos; DB 8 DUP(?) DATA ENDSCODE SEGMENT ASSUME DS:DATA,CS:CODESTART: MOV AX,DATA MOV DS,AX MOV AH,09H MOV DX,OFFSET MEG INT 21H MOV AH,0AH MOV DX,OFFSET BUF INT 21H MOV DL,BUF[1] CMP DL,3 JA ER MOV DL,BUF[2] CMP DL,0DH JZ PD CMP DL,&apos;0&apos; JB ER CMP DL,&apos;9&apos; JA ER SUB DL,&apos;0&apos; MOV X,DL MOV DL,BUF[3] CMP DL,0DH JZ PD CMP DL,&apos;0&apos; JB ER CMP DL,&apos;9&apos; JA ER MOV AL,X MUL Y SUB DL,&apos;0&apos; ADD AL,DL MOV X,AL MOV DL,BUF[4] CMP DL,0DH JZ PD CMP DL,&apos;0&apos; JB ER CMP DL,&apos;9&apos; JA ER SUB DL,&apos;0&apos; MOV AL,X CMP AL,19H JA ER MUL Y MOV BL,0FFH SUB BL,DL CMP AL,BL JA ER ADD AL,DL MOV X,ALPD: CMP X,0 JB ER CMP X,255 JA ER MOV AL,X MOV Y,AL CMP AL,0 JE XS MOV BL,BUF[1] MOV DI,BX MOV BU2[DI],&apos;$&apos; MOV BL,0AH AND AX,00FFH DIV BL DEC DI ADD AH,&apos;0&apos; MOV BU2[DI],AH MOV BL,AL CMP BL,0 JE XS MOV AL,BL MOV BL,0AH AND AX,00FFH DIV BL ADD AH,&apos;0&apos; DEC DI MOV BU2[DI],AH MOV BL,AL CMP BL,0 JE XS DEC DI MOV AL,BL MOV BL,0AH AND AX,00FFH DIV BL ADD AH,&apos;0&apos; MOV BU2[DI],AHXS: MOV AH,09H MOV DX,OFFSET BU2 INT 21H MOV AH,02H MOV DL,&apos;=&apos; INT 21H MOV CX,8 MOV AL,X SEC: MOV AL,Y MOV DI,CX MOV CL,1 ROL AL,CL MOV Y,AL AND AL,01H MOV DL,AL MOV AH,02H ADD DL,&apos;0&apos; INT 21H MOV CX,DI LOOP SEC MOV AH,02H MOV DL,&apos;B&apos; INT 21H MOV AH,02H MOV DL,&apos;=&apos; INT 21H MOV DL,X MOV CL,4 SHR DL,CL OR DL,30H CMP DL,39H JBE AD1 ADD DL,7AD1: MOV AH,2 INT 21H MOV DL,X AND DL,0FH OR DL,30H CMP DL,39H JBE AD2 ADD DL,7AD2: MOV AH,2 INT 21H MOV AH,02H MOV DL,&apos;H&apos; INT 21H MOV AH,4CH INT 21HER: MOV AH,09H MOV DX,OFFSET ME2 INT 21H MOV AH,4CH INT 21HCODE ENDS END START]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ê±áÁºñËØ≠Ë®ÄÂÆûÁé∞ÊòæÁ§∫16ËøõÂà∂Êï∞]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E6%98%BE%E7%A4%BA16%E8%BF%9B%E5%88%B6%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Â∞ÜÂÜÖÂ≠òÂçïÂÖÉÂ≠òÂÇ®ÁöÑ8‰∏™‰∏§‰Ωç16ËøõÂà∂Êï∞Ôºö01H, 25H, 38H, 62H, 8DH, 9AH, BAH, CEH‰æùÊ¨°ÊòæÁ§∫Âú®Â±èÂπï‰∏ä„ÄÇ Áõ¥Êé•ËΩ¨Êç¢„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 DATA SEGMENTBUF DB 01H,25H,38H,62H,8DH,9AH,0BAH,0CEHN DW $-BUFX DW 0DATA ENDSCODE SEGMENT ASSUME CS:CODE,DS:DATASTART: MOV AX,DATA MOV DS,AX MOV CX,NBE: MOV N,CX MOV BX,X MOV DL,BUF[BX] INC BX MOV X,BX CALL DELY MOV CX,N CMP CX,1 JE FINISH MOV DL,&apos;,&apos; MOV AH,2 INT 21H LOOP BEFINISH:MOV AX,4C00H INT 21HDELY PROC NEAR MOV BL,DL MOV CL,4 SHR DL,CL OR DL,30H CMP DL,39H JBE AD1 ADD DL,7AD1: MOV AH,2 INT 21H MOV DL,BL AND DL,0FH OR DL,30H CMP DL,39H JBE AD2 ADD DL,7AD2: MOV AH,2 INT 21H MOV DL,&apos;H&apos; MOV AH,2 INT 21H RETDELY ENDPCODE ENDS END START ÊâìË°®Ê≥ïÔºö 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 DATA SEGMENTBUF DB 01H,25H,38H,62H,8DH,9AH,0BAH,0CEHN DW $-BUFASCII DB 30H,31H,32H,33H,34H,35H,36H,37H,38H,39H DB 41H,42H,43H,44H,45H,46HX DW 0Y DB 0DATA ENDSCODE SEGMENT ASSUME CS:CODE,DS:DATASTART: MOV AX,DATA MOV DS,AX MOV CX,NBE: MOV N,CX MOV BX,X MOV DL,BUF[BX] INC BX MOV X,BX MOV CX,N CMP CX,1 JE FINISH MOV DL,&apos;,&apos; MOV AH,2 INT 21H LOOP BEFINISH:MOV AX,4C00H INT 21HDELY PROC NEAR MOV Y,DL MOV CL,4 SHR DL,CL MOV BX,OFFSET ASCII MOV AL,DL AND AL,0FH XLAT MOV DL,AL MOV AH,2 INT 21H MOV AL,Y AND AL,0FH XLAT MOV DL,AL MOV AH,2 INT 21H MOV DL,&apos;H&apos; MOV AH,2 INT 21H RETDELY ENDPCODE ENDS END START]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ê±áÁºñËØ≠Ë®ÄÂÆûÁé∞ÂÜíÊ≥°Ê≥ïÊéíÂ∫è]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%86%92%E6%B3%A1%E6%B3%95%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[Âà©Áî®ÂÜíÊ≥°Ê≥ïÊéíÂ∫èÁÆóÊ≥ïÔºåÂ∞ÜÂÜÖÂ≠òÂçïÂÖÉÂ≠òÂÇ®ÁöÑÊï∞35HÔºå78HÔºå25HÔºå13HÔºå8HÔºåD2HÁî±Â§ßÂà∞Â∞èËøõË°åÊéíÂ∫è„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041 DATA SEGMENTDAT DB 35H,78H,25H,13H,8H,0D2HDATA ENDSCODE SEGMENT ASSUME CS:CODE,DS:DATASTART: MOV AX,DATA MOV DS,AX MOV CX,5A1: MOV DI,CX MOV BX,0A2: MOV AL,DAT[BX] CMP AL,DAT[BX+1] JGE A3 XCHG AL,DAT[BX+1] MOV DAT[BX],ALA3: ADD BX,1 LOOP A2 MOV CX,DI LOOP A1 MOV DL,DAT[0] MOV CL,4 SHR DL,CL OR DL,30H CMP DL,39H JBE AD1 ADD DL,7AD1: MOV AH,2 INT 21H MOV DL,DAT[0] AND DL,0FH OR DL,30H CMP DL,39H JBE AD2 ADD DL,7AD2: MOV AH,2 INT 21H MOV AH,4CH INT 21HCODE ENDS END START]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ê±áÁºñËØ≠Ë®ÄÂÆûÁé∞ÊñáÊú¨ÊµèËßàÂô®]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E6%B5%8F%E8%A7%88%E5%99%A8%2F</url>
    <content type="text"><![CDATA[ËøêË°åÁ®ãÂ∫èÂêéÔºåÂ±èÂπïÊòæÁ§∫‚Äúinput number (1-3)Ôºö‚Äù ÈîÆÂÖ•‚Äú1‚ÄùÂêéÔºåÊòæÁ§∫‚Äúchapter1: introduction‚Äù ÈîÆÂÖ•‚Äú2‚ÄùÂêéÔºåÊòæÁ§∫‚Äúchapter2: designing method‚Äù ÈîÆÂÖ•‚Äú3‚ÄùÂêéÔºåÊòæÁ§∫‚Äúchapter3: experiment‚Äù ÈîÆÂÖ•ÂÖ∂‰ªñÊï∞Â≠óÂêéÔºåËøîÂõûÂ±èÂπïÊèêÁ§∫Áä∂ÊÄÅ „ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 data segmentstr db &apos;please input number(1-3):&apos;,&apos;$&apos;str1 db &apos;chapter1: introduction&apos;,&apos;$&apos;str2 db &apos;chapter2: designing method&apos;,&apos;$&apos;str3 db &apos;chapter3:experimenr&apos;,&apos;$&apos;table dw A1,A2,A3 data endscode segment assume cs:code,ds:datastart: mov ax,data mov ds,ax begin:mov dx,offset str mov ah,9 int 21h mov ah,01h int 21h cmp al,&apos;1&apos; jb finish cmp al,&apos;3&apos; ja finish and ax,000FH dec ax shl ax,1 mov bx,ax jmp table[bx] A1: mov dx,offset str1 mov ah,9 int 21h jmp enter A2: mov dx,offset str2 mov ah,9 int 21h jmp enter A3: mov dx,offset str3 mov ah,9 int 21h jmp enter finish: mov dl,0dh mov ah,2 int 21h mov dl,0ah int 21h jmp begin enter: mov ax,4c00h int 21hcode ends end start]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ê±áÁºñËØ≠Ë®ÄÂÆûÈ™åÂ∞ÜÂÜÖÂ≠òÂçïÂÖÉÂ≠òÂÇ®ÁöÑÂ≠óËäÇÊï∞ÊçÆÁöÑ16ËøõÂà∂Êï∞ÁöÑ‰Ωé‰ΩçËæìÂá∫Âà∞ÊòæÁ§∫Âô®Âπ∂ÊòæÁ§∫„ÄÇ]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%B0%86%E5%86%85%E5%AD%98%E5%8D%95%E5%85%83%E5%AD%98%E5%82%A8%E7%9A%84%E5%AD%97%E8%8A%82%E6%95%B0%E6%8D%AE%E7%9A%8416%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E4%BD%8E%E4%BD%8D%E8%BE%93%E5%87%BA%E5%88%B0%E6%98%BE%E7%A4%BA%E5%99%A8%E5%B9%B6%E6%98%BE%E7%A4%BA%E3%80%82%2F</url>
    <content type="text"><![CDATA[ÊâìË°®Ê≥ïÔºö 1234567891011121314151617181920 DATA SEGMENTASCII DB 30H,31H,32H,33H,34H,35H,36H,37H,38H,39H DB 41H,42H,43H,44H,45H,46HHEX DB 0BHDATA ENDSCODE SEGMENT ASSUME CS:CODE,DS:DATASTART: MOV AX,DATA MOV DS,AX MOV BX,OFFSET ASCII MOV AL,HEX AND AL,0FH XLAT MOV DL,AL MOV AH,2 INT 21H MOV AX,4C00H INT 21HCODE ENDS END START Áõ¥Êé•ËΩ¨Êç¢Ôºö 12345678910111213141516171819 DATA SEGMENTHEX DB 0BHDATA ENDSCODE SEGMENT ASSUME CS:CODE,DS:DATASTART: MOV AX,DATA MOV DS,AX MOV DL,HEX AND DL,0FH OR DL,30H CMP DL,39H JBE AD1 ADD DL,7AD1: MOV AH,2 INT 21H MOV AX,4C00H INT 21HCODE ENDS END START]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ê±áÁºñÂÆûÁé∞Â§ßÂ∞èÂ≠óÊØçËΩ¨Êç¢]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B1%87%E7%BC%96%E5%AE%9E%E7%8E%B0%E5%A4%A7%E5%B0%8F%E5%AD%97%E6%AF%8D%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[‰ªéÈîÆÁõòÈîÆÂÖ•‰∏Ä‰∏™Â§ßÂÜôËã±ÊñáÂ≠óÊØçÔºåÂ≠òÊîæÂà∞ÂÜÖÂ≠òÂçïÂÖÉBUF1‰∏≠ÔºåÂÜçËΩ¨Âåñ‰∏∫ÂØπÂ∫îÁöÑÂ∞èÂÜôÂ≠óÊØçÔºåÂ≠òÊîæÂà∞ÂÜÖÂ≠òÂçïÂÖÉBUF2‰∏≠„ÄÇ 1234567891011121314151617181920 data segmentbuf1 db ?buf2 db ?data endscode segmentassume ds:data,cs:codebegin:mov ax,datamov ds,axmov ah,01int 21hmov buf1,aladd al,20hmov buf2,almov dl,almov ah,02int 21hmov ah,4chint 21hcode endsend begin]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ê±áÁºñÂÆûÁé∞‰∏Ä‰∏™ÁÆÄÂçïÂä†Ê≥ïÁ®ãÂ∫è„ÄÇ]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B1%87%E7%BC%96%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E5%8A%A0%E6%B3%95%E7%A8%8B%E5%BA%8F%E3%80%82%2F</url>
    <content type="text"><![CDATA[Ê±áÁºñËØ≠Ë®ÄÔºåÂÜô‰∏Ä‰∏™ÁÆÄÂçïÂä†Ê≥ïÁ®ãÂ∫è‚Äú3+5=8‚ÄùÔºåÂä†Êï∞ÂíåÁªìÊûúÂàÜÂà´Â≠òÂú®ÂÜÖÂ≠òÂçïÂÖÉNUM1„ÄÅNUM2„ÄÅNUM3‰∏≠„ÄÇ 12345678910111213141516 data segment num1 db 3 num2 db 5 num3 db ?data endscode segmentassume cs:code,ds:data start:mov ax,data mov ds,ax mov al,num1 add al,num2 mov num3,al mov ax,4c00h int 21hcode endsend start]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-CCSPÊù≠Â∑û]]></title>
    <url>%2F2018%2F10%2F30%2F2018-CCSP%E6%9D%AD%E5%B7%9E%2F</url>
    <content type="text"><![CDATA[‰Ωú‰∏∫‰∏Ä‰∏™Âè™Â≠¶‰∫Ü‰∏ÄÂπ¥ÁöÑËèúÈ∏°ÔºåÊ≤°ÊÉ≥Âà∞Á´üÁÑ∂Âú®CCSP‰∏äÊãø‰∫Ü‰∏ÄÂùóÈáë„ÄÇÂè™ËÉΩËØ¥ËøêÊ∞î‰∏çÈîô„ÄÇ https://git.thusaac.org/publish/CCSP2018]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF 2018-09 È¢òËß£]]></title>
    <url>%2F2018%2F09%2F17%2FCCF%202018-09%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[CCF 201809 1.Â∞±ÊòØÊ±ÇÂπ≥ÂùáÂÄºÔºåÁ¨¨‰∏Ä‰∏™ÂíåÊúÄÂêé‰∏Ä‰∏™ÁâπÂà§‰∏Ä‰∏ã„ÄÇ 2.ËøôÈ¢ò‰∏§ÁßçÊÄùË∑ØÔºöÁ¨¨‰∏ÄÁßçÔºåÁõ¥Êé•n*nÁöÑÂà§Êñ≠ÊúâÊ≤°Êúâ‰∫§ÂèâÁöÑÂå∫Èó¥ÔºåÊúâÂ∞±Áõ¥Êé•Âä†‰∏äÂéª„ÄÇÁ¨¨‰∫åÁßçÁõ¥Êé•Ê®°ÊãüÊó∂Èó¥ËΩ¥ÔºåÊó∂Èó¥ËΩ¥ÊúÄÂ§ßÂè™Êúâ1e6ÔºåÈÇ£‰∏™Âå∫Èó¥Â¶ÇÊûúÊúâË¶ÜÁõñÂ∞±Áõ¥Êé•+1ÔºåÁÑ∂Âêé‰∏§‰∏™‰∫∫ÁöÑÂå∫Èó¥Ë¶ÜÁõñÔºåÂ¶ÇÊûú‰∏§‰∏™‰∫∫ÈÉΩÊúâËøô‰∏™Âå∫Èó¥Â∞±ÊòØ2ÔºåÊï∞ÁªÑ‰∏∫2ÁöÑ‰∏™Êï∞Âä†Ëµ∑Êù•Â∞±Ë°å‰∫Ü„ÄÇÁî±‰∫éÂå∫Èó¥ÈïøÂ∫¶ÊòØS-TÔºåÂÖ∂ÂÆûËøô‰∏™Áõ∏ÂΩì‰∫é[s,t),Êúâ‰∏Ä‰∏™ÊòØÂºÄÂå∫Èó¥„ÄÇ 3.ËØ∑ËßÅ ÊîøÂ§ß‰Ω¨ 4.ËÆ∞ÂøÜÂåñDFSÔºåÂºÄ‰∏Ä‰∏™vis[400][400][400]ÁöÑÊï∞ÁªÑÔºåvis[pos][i][j],posË°®Á§∫‰ΩçÁΩÆÔºåiÔºåË°®Á§∫ÂΩìÂâç‰ΩçÁΩÆÁöÑÂÄºÔºåj,Ë°®Á§∫Ââç‰∏Ä‰∏™‰ΩçÁΩÆÁöÑÂÄº„ÄÇÁÑ∂ÂêéÂ∞±Êö¥ÂäõÊûö‰∏æÊâÄÊúâÁöÑÂÄºÔºåÂ¶ÇÊûúÈÇ£‰∏™ÂÄºÂíåÂâçÈù¢‰∏Ä‰∏™ÁöÑÂÄºÂ∑≤ÁªèËÆøÈóÆËøá‰∫ÜÂ∞±Áõ¥Êé•ËøîÂõû0„ÄÇ‰ªéÂ∞èÂæÄÂ§ßÊêúÁ¥¢ÔºåËøôÊ†∑Â∞±ÂèØ‰ª•‰øùËØÅÂ≠óÂÖ∏Â∫èÊúÄÂ∞è„ÄÇ ËøôÈ¢òÂèØ‰ª•Áî®Á¨¨‰∏ÄÈ¢òÂØπÊãç‰∏Ä‰∏ãÂìàÂìà ‰∏ªË¶ÅËÄÉÁÇπ: 1.Âπ≥ÂùáÂÄºÔºåÁü•ÈÅìa[pos],b[pos-1],b[pos]ÂèØ‰ª•Êé®Âá∫b[pos+1]Âè™Êúâ3ÁßçÂèñÂÄº(Êª°Ë∂≥(b[pos-1]+b[pos]+b[pos+1])/3==a[pos])Ôºõ 2 ËÆ∞ÂøÜÂåñÊêúÁ¥¢ÔºåÂõ†‰∏∫ÊØèÁßçÁä∂ÊÄÅÂêéÈù¢ÈÉΩÊúâ3ÁßçÂèñÂÄºÊâÄ‰ª•Êö¥ÂäõÊòØÔºå3^100Â§çÊùÇÂ∫¶ÔºåÊòéÊòæË∂ÖÊó∂„ÄÇÊâÄ‰ª•Ë¶ÅÂâ™ÊûùÔºåÂ∞±ÊòØÂâçÈù¢ËØ¥ÁöÑvisÊï∞ÁªÑ„ÄÇËøôÊ†∑ÊâÄÊúâÁä∂ÊÄÅÊúÄÂ§öË∑ë‰∏ÄÊ¨°ÔºåÊÄªÂ§çÊùÇÂ∫¶300^3,ÔºàÂÆûÈôÖ‰∏äÊ≤°ÊúâËøô‰πàÂ§ßÔºâÂèØ‰ª•Ëøá„ÄÇ 5.‰Ω†ËÉΩÂºÄËøô‰∏ÄÈ¢òÔºåÂèØ‰ª•Áõ¥Êé•Ë∑≥ËøáÊàëÂçöÂÆ¢‰∫Ü„ÄÇ]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÈïøÊ≤ôÁêÜÂ∑•ÈõÜËÆ≠Èòü-9.11Êó•ÁªÑÈòüËµõ]]></title>
    <url>%2F2018%2F09%2F15%2F%E9%95%BF%E6%B2%99%E7%90%86%E5%B7%A5%E9%9B%86%E8%AE%AD%E9%98%9F-9.11%E6%97%A5%E7%BB%84%E9%98%9F%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[Â•Ω‰πÖÊ≤°ÂÜôÂçöÂÆ¢‰∫ÜÔºåÂÜôÁØáÂçöÂÆ¢ÊîæÊùæ‰∏Ä‰∏ã„ÄÇ Â§ñÁΩëOJÔºöhttp://csustacm.com:4803/ 1È¢òÊàëÂ∞±‰∏çÂÜô‰∫ÜËøôÈ¢òÂÜô‰∫Ü‰πüÊ≤°Âï•ÊÑè‰πâ„ÄÇ 2.ÈªÑÈáëÁüøÂ∑• Description Ê∏∏Êàè‰∏≠Êúân‰∏™ÂÆùÁü≥ÔºåÊØè‰∏™ÂÆùÁü≥Êúâ‰∏Ä‰∏™‰ª∑ÂÄºviÔºåÊØèÊ¨°ÊåñÂá∫Ëøô‰∏™ÂÆùÁü≥ÈúÄË¶ÅÊó∂Èó¥ti„ÄÇÂõ†‰∏∫Êúâ‰∫õÂÆùÁü≥Ë¢´Âè¶Â§ñ‰∏Ä‰∏™ÂÆùÁü≥Êå°‰Ωè‰∫ÜÔºà‰∏§‰∏™ÂÆùÁü≥Âú®Âêå‰∏ÄÁõ¥Á∫ø‰∏äÔºâÔºå‰∏Ä‰∏™ÂÆùÁü≥ÊúÄÂ§öÊå°‰Ωè‰∏Ä‰∏™ÂÆùÁü≥Ôºå‰∏Ä‰∏™ÂÆùÁü≥ÊúÄÂ§öË¢´‰∏Ä‰∏™ÂÆùÁü≥Êå°‰Ωè„ÄÇË¶ÅÂÖàÊç°Ëµ∑Êå°Ë∑ØÁöÑÂÆùÁü≥ÔºåÊâçËÉΩÊç°Ëµ∑ËØ•ÂÆùÁü≥„ÄÇÊØè‰∏™ÂÆùÁü≥ÁöÑÊå°Ë∑ØÂÆùÁü≥‰∏∫fiÔºåÂ¶ÇÊûúÊ≤°ÊúâÊå°Ë∑ØÂÆùÁü≥fi = 0ÔºåÂç≥ÂÆÉËá™Â∑±(È¢òÁõÆ‰øùËØÅÊ≤°ÊúâÁéØÔºå‰∏î‰∏çÂ≠òÂú®)„ÄÇ Ê∏∏ÊàèÁöÑÊó∂Èó¥ÈôêÂà∂ÊòØtÁßíÔºåÂú®tÁßíÂÜÖ‰Ω†Ëé∑ÂæóÊúÄÂ§ß‰ª∑ÂÄºÂíåÊòØÂ§öÂ∞ëÔºü Input Á¨¨‰∏ÄË°å‰∏Ä‰∏™Êï¥Êï∞TÔºåË°®Á§∫Êé•‰∏ãÊù•ÊúâTÁªÑÊï∞ÊçÆ„ÄÇÔºàT &lt;= 50Ôºâ ÊØèÁªÑÊï∞ÊçÆÊ†ºÂºèÂ¶Ç‰∏ãÔºö Á¨¨‰∏ÄË°å‰∏§‰∏™Êï¥Êï∞nÔºà1&lt;=n&lt;=200ÔºâÔºåtÔºà1&lt;=t&lt;=100,000,000Ôºâ Êé•‰∏ãÊù•nË°åÔºåÊØèË°å‰∏â‰∏™Êï¥Êï∞viÔºà1&lt;=vi&lt;=50ÔºâÔºåtiÔºà1&lt;=ti&lt;=1000,000ÔºâÔºåÔºà0&lt;=fi&lt;=nÔºâ Output ËæìÂá∫Ëé∑ÂæóÁöÑÊúÄÂ§ß‰ª∑ÂÄºÂíå Sample Input 1 11 5 10 2 1 0 5 3 1 3 2 0 1 4 3 4 6 4 Sample Output 1 111 È¢òÊÑèÔºöÊåñÂÆùÁü≥ÔºåÊåñÊüê‰∏™ÂÆùÁü≥ÂâçÂèØËÉΩÊúâ‰∏Ä‰∏™ÂÆùÁü≥Ôºå‰∏Ä‰∏™ÂÆùÁü≥‰πüÂè™ËÉΩÈòªÈöæ‰∏Ä‰∏™ÂÆùÁü≥ÔºåÊåñÊüê‰∏™ÂÆùÁü≥Ë¶ÅÊ∂àËÄóÊó∂Èó¥tiËé∑Âæó‰ª∑ÂÄºviÔºåÈóÆT=tÁßíÊúÄÂ§öÂèØ‰ª•ÊåñÂÆùÁü≥ÁöÑÊúÄÂ§ß‰ª∑ÂÄº„ÄÇ È¢òËß£ÔºöÁúã‰∫Ü‰∏ãÊï∞ÊçÆËåÉÂõ¥ÔºåËÇØÂÆöÊòØ‰ª•‰ª∑ÂÄºDPÔºåÊ±Ç‰ª∑ÂÄºÁöÑÊúÄÂ∞èÊó∂Èó¥ÔºåÂ¶ÇÊûúÊó∂Èó¥Â∞è‰∫éÊâÄÁªôÂÆöÁöÑÊó∂Èó¥Â∞±ÂèØ‰ª•ÊåñÂà∞Áõ∏Â∫î‰ª∑ÂÄº„ÄÇ È¶ñÂÖàÂ§ÑÁêÜ‰∏ãÔºåÊØè‰∏™ÂÆùÁü≥ÂâçÂêéÊúÄÂ§öÂè™Êúâ‰∏Ä‰∏™ÔºåËÇØÂÆöÊòØ‰∏ÄÊù°ÈìæÔºåÊääÊØèÊù°ÈìæÂ§ÑÁêÜ‰∏Ä‰∏ãÔºàÂÅáÂ¶Ç‰∏ÄÊù°ÈìæÊòØ1-&gt;2-&gt;3,ÈÇ£‰πàËøôÊù°Èìæ‰∏äÂ∞±Êúâ3‰∏™ËäÇÁÇπÂàÜÂà´‰øùÂ≠ò2‰∏™ÂÄºÔºåÊåñÂà∞1Ôºå(v1,t1ÔºâÊåñÂà∞2ÔºåÔºàv1+v2,t1+t2ÔºâÊåñÂà∞3,(v1+v2+v3,t1+t2+t3))„ÄÇÊúÄÂ§öÂè™Êúâ200Êù°ÈìæÔºåÊâÄ‰ª•‰∏çÁî®ÊãÖÂøÉË∂ÖÊó∂„ÄÇ ÊØèÊù°Èìæ‰øùÂ≠ò ‰∏§‰∏™ÂÄºÔºå‰ª∑ÂÄºÂíåÊâÄÈúÄË¶ÅÁöÑÊó∂Èó¥„ÄÇÁÑ∂ÂêéÂú®DPÂ∞±Ë°å‰∫Ü„ÄÇÂõ†‰∏∫ÊØèÊù°Èìæ‰∏äÂè™ËÉΩÈÄâ‰∏Ä‰∏™ÂÄºÊâÄ‰ª•DPËÇØÂÆöË¶ÅÂºÄ‰∫åÁª¥„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 #include&lt;bits/stdc++.h&gt;#define fi first#define se secondusing namespace std;#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot;&lt;&lt;endl;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;const int maxn=1e3+7;const int inf=0x3f3f3f3f;int n, m, tot;int son[maxn];int in[maxn], v[maxn], t[maxn], vis[maxn];vector&lt;P&gt; ar[maxn];int dp[205][10005];void dfs(int u,int val,int tim) &#123; //Áî®DFSÔºå‰∏ÄÊù°Èìæ vis[u] = 1; ar[tot].push_back(make_pair(val+v[u],tim+t[u])); if(son[u] == 0)return; dfs(son[u],val+v[u],tim+t[u]);&#125;int main() &#123; int tim; scanf(&quot;%d&quot;, &amp;tim); while(tim--) &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int sum = 0; for(int i = 0; i &lt;= n; ++i) &#123; son[i]=vis[i]=0; ar[i].clear(); &#125; for(int i = 1, u; i &lt;= n; ++i) &#123; scanf(&quot;%d%d%d&quot;, &amp;v[i], &amp;t[i], &amp;u); sum += v[i]; //if(u == 0)continue; son[u] = i; &#125; tot = 0; for(int i = 1; i &lt;= n; ++i) &#123; if(vis[i] == 0) &#123;//Â¶ÇÊûúËøô‰∏™ËäÇÁÇπÊ≤°ÊúâÁà∂‰∫≤ÔºåÂ∞±ËØ¥ÊòéËøôÊúâ‰∏ÄÊù°Èìæ„ÄÇ dfs(i, 0, 0); tot++; &#125; &#125; memset(dp, 0x3f, sizeof(dp)); for(int i = 0; i &lt; tot; ++i) &#123; „ÄÇ ar[i].push_back(make_pair(0, 0));//ÊØè‰∏™ÈìæËÇØÂÆöÂèØ‰ª•‰∏Ä‰∏™ÈÉΩ‰∏çÊåñÔºåÊâÄ‰ª•0 Ôºå0Ë¶ÅÂä†ËøõÂéª„ÄÇ sort(ar[i].begin(),ar[i].end()); &#125; int sz = ar[0].size(); for(int i = 0; i &lt; sz; ++i) &#123;//dpÂàùÂßãÂåñ dp[0][ar[0][i].fi] = ar[0][i].se; &#125; for(int i = 1; i &lt; tot; ++i) &#123; sz = ar[i].size(); for(int j = 0; j &lt; sz; ++j) &#123; for(int k = sum; k &gt;= ar[i][j].fi; --k) &#123; dp[i][k] = min(dp[i-1][k-ar[i][j].fi]+ar[i][j].se,dp[i][k]); &#125; &#125; &#125; int ans = 0; for(int i = sum; i &gt;= 0; --i) &#123; if(dp[tot-1][i]&lt;=m) &#123; //ÊâæÁ¨¨‰∏Ä‰∏™Â∞è‰∫éÁ≠â‰∫éÁªôÂÆöÊó∂Èó¥ÁöÑ‰ª∑ÂÄº ans = i; break; &#125; &#125; printf(&quot;%d\n&quot;, ans); &#125; return 0;&#125; 3.Á≤æÁÅµÁéãÂõΩ Description Â∞èJÁ¶ªÂºÄ‰∫ÜÁ•ûÁßòÁæ§Â≤õ‰πãÂêéÔºåÊù•Âà∞‰∫ÜÁπÅÂçéÁöÑÁ≤æÁÅµÁéãÂõΩ„ÄÇ Á≤æÁÅµÁéãÂõΩ‰∏≠Êúân‰∏™ÂüéÂ∏ÇÔºåÁé∞Âú®Â∑≤Áü•Á¨¨ i ‰∏™ÂüéÂ∏ÇÂíåÁ¨¨ i + 1‰∏™ÂüéÂ∏Ç‰πãÈó¥Êúâ‰∏ÄÊù°ÈïøÂ∫¶‰∏∫d[i]ÁöÑÂèåÂêëÈÅìË∑Ø„ÄÇÔºàÁâπÂà´ÁöÑÔºåÁ¨¨n‰∏™ÂüéÂ∏ÇÂíåÁ¨¨1‰∏™ÂüéÂ∏Ç‰πãÈó¥Êúâ‰∏ÄÊù°ÈïøÂ∫¶‰∏∫d[n]ÁöÑÂèåÂêëÈÅìË∑ØÔºâ„ÄÇ ÈöèÁùÄÁªèÊµéÁöÑÂèëÂ±ïÔºåÁ≤æÁÅµÁéãÂõΩÁöÑÂüéÂ∏Ç‰πãÈó¥Âª∫Á´ã‰∫ÜmÊù°Âú∞ÈìÅÔºåÁ¨¨iÊù°Âú∞ÈìÅÂèØ‰ª•‰ªéÂüéÂ∏Çu[i]ÂâçÂæÄv[i]Ôºå‰πüÂèØ‰ª•‰ªév[i]ÂâçÂæÄu[i]ÔºåÂêåÊó∂Âú∞ÈìÅÁöÑÈïøÂ∫¶‰∏∫w[i]„ÄÇ Áé∞Âú®Â∞èJÂú®ÂêÑ‰∏™ÂüéÂ∏Ç‰πãÈó¥ÊóÖÊ∏∏ÔºåÂ∞èJÊÉ≥Áü•ÈÅì‰ªéÂüéÂ∏ÇxÂâçÂæÄÂüéÂ∏ÇyÊóÖÊ∏∏ÈúÄË¶ÅËä±Ë¥πÂ§öÈïøÁöÑÊó∂Èó¥Ôºü Input Á¨¨‰∏ÄË°å‰∏∫2‰∏™Êï¥Êï∞n„ÄÅm„ÄÇ Á¨¨‰∫åË°å‰∏∫n‰∏™Ê≠£Êï¥Êï∞d[i]„ÄÇ Êé•‰∏ãÊù•mË°åÊØèË°å‰∏â‰∏™Ê≠£Êï¥Êï∞u[i]„ÄÅv[i]„ÄÅw[i]„ÄÇ Á¨¨m+3Ë°å‰∏∫‰∏Ä‰∏™Ê≠£Êï¥Êï∞QÔºåË°®Á§∫ËØ¢ÈóÆÊ¨°Êï∞„ÄÇ Êé•‰∏ãÊù•QË°åÊØèË°å‰∏§‰∏™Ê≠£Êï¥Êï∞x„ÄÅyÔºåË°®Á§∫‰∏ÄÊ¨°‰ªéÂüéÂ∏ÇxÂà∞ÂüéÂ∏ÇyÁöÑÊóÖË°å„ÄÇ Êï∞ÊçÆËåÉÂõ¥Ôºö1&lt;=n,q&lt;=1e5,1&lt;=m&lt;=30,1&lt;=u[i],v[i],x,y&lt;=n,1&lt;=d[i],w[i]&lt;=1e9; Output ËæìÂá∫QË°åÊØèË°å‰∏Ä‰∏™Ê≠£Êï¥Êï∞Ë°®Á§∫ËØ•Ê¨°ÊóÖË°åÁöÑÊúÄÁü≠Êó∂Èó¥„ÄÇ Sample Input 1 14 1 1 2 3 6 1 3 2 5 1 2 1 4 1 3 2 3 4 3 Sample Output 1 11 5 2 2 3 ÁúãËµ∑Êù•Êå∫ÈöæÁöÑÔºåÂÖ∂ÂÆûÊòØÂà∞ÂéüÈ¢ò„ÄÇ„ÄÇÔºåÊääÊï∞ÊçÆËåÉÂõ¥Êîπ‰∫Ü‰∏Ä‰∏ãÔºåËßÅÁâõÂÆ¢Á¨¨‰∫åÂú∫ÊåëÊàòËµõ„ÄÇ ÁúãËµ∑Êù•ÂæàÈöæÔºåÂÆûÈôÖ‰∏äÁÆÄÂçïÁöÑ‰∏ÄÂåπÔºåÂè™Êúâ30Êù°ÈìÅË∑ØÔºåÁõ¥Êé•ÊääÊúâÈìÅË∑ØÁöÑ60‰∏™ÁÇπÁõ¥Êé•ÂÖ®ÈÉ®Ë∑ë‰∏ÄÊ¨°ÊúÄÁü≠Ë∑ØÔºåÁÑ∂ÂêéÈóÆ‰∏§‰∏™ÁÇπ‰πãÈó¥ÁöÑÊúÄÁü≠Ë∑ùÁ¶ªÔºåË¶Å‰πàÂùê‰∫ÜÂú∞ÈìÅÔºåÈÇ£‰πàÂ∞±ÊòØÂà∞60‰∏™ÁÇπ‰∏≠ÁöÑ‰∏Ä‰∏™ÊúÄÁü≠Ë∑ØÂä†‰∏ä‰ªéËøô‰∏™ÊúâÈìÅË∑ØÁöÑÁÇπÂà∞Âè¶‰∏Ä‰∏™ÁÇπÁöÑÊúÄÁü≠Ë∑ØÔºåË¶Å‰πàÂ∞±ÊòØ‰∏çÂÅöÂú∞ÈìÅÔºå‰∏çÂÅöÂú∞ÈìÅ‰∏Ä‰∏™ÂâçÁºÄÂíåÂ∞±Ë°å‰∫Ü„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e5+5;const int inf=0x3f3f3f3f;int n,m;int d[maxn];LL dp[maxn];vector&lt;int&gt; v;bool u[maxn];struct edge &#123; int to,next; LL w;&#125; eg[maxn*3];int tot,head[maxn];void add(int u,int v,int w) &#123; eg[tot].to=v; eg[tot].w=w; eg[tot].next=head[u]; head[u]=tot++;&#125;LL dis[65][maxn];int main() &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); mem(head,-1); for(int i = 1; i &lt;= n ; i ++) &#123; scanf(&quot;%d&quot;,&amp;d[i]); dp[i]=dp[i-1]+d[i]; if(i==n) &#123; add(1,n,d[i]); add(n,1,d[i]); &#125; else &#123; add(i,i+1,d[i]); add(i+1,i,d[i]); &#125; &#125; while(m--) &#123; int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); if(u[a]==0) &#123; v.push_back(a); u[a]=1; &#125; if(u[b]==0) &#123; v.push_back(b); u[b]=1; &#125; add(a,b,c); add(b,a,c); &#125; mem(dis,inf); priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; q; for(int i = 0 ; i &lt; v.size(); i ++) &#123; dis[i][v[i]]=0; q.push(P(0,v[i])); while(q.size()) &#123; int u = q.top().second; q.pop(); for(int j = head[u]; j!=-1; j=eg[j].next) &#123; edge &amp;e=eg[j]; if(dis[i][e.to]&gt;dis[i][u]+e.w) &#123; dis[i][e.to]=dis[i][u]+e.w; q.push(P(dis[i][e.to],e.to)); &#125; &#125; &#125; &#125; int Q; scanf(&quot;%d&quot;,&amp;Q); while(Q--) &#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); if(a&gt;b)swap(a,b); LL ans=min(dp[b-1]-dp[a-1],dp[n]-(dp[b-1]-dp[a-1])); for(int i =0 ; i &lt;v.size(); i++) &#123;// debug(dis[i][a]+dis[i][b]); ans=min(ans,dis[i][a]+dis[i][b]); &#125; printf(&quot;%lld\n&quot;,ans); &#125; return 0;&#125; 5.zzqÁöÑÊï∞Â≠¶ÊïôÂÆ§2 Description zzqÊÉ≥‰øùÁ†îÔºå‰ªñÁöÑÊàêÁª©Âçï‰∏äÊúâ‰∏ÄÊéíÈùûÈÄíÂáèÈ°∫Â∫èÁöÑÊàêÁª©ÔºåÈù¢ËØïÊó∂ËÄÅÂ∏àÊÉ≥Áü•ÈÅì‰ªñÊï∞Â≠¶ÊàêÁª©ÁöÑ‰ΩçÁΩÆÔºåzzqÁü•ÈÅì‰ªñÁöÑÊï∞Â≠¶ÊàêÁª©ÊòØxÂàÜÔºå‰ªñË¶ÅÊâæÂà∞Á¨¨‰∏Ä‰∏™Âá∫Áé∞xÁöÑ‰ΩçÁΩÆ„ÄÇ ‰ªñÊÉ≥ËøêÁî®‰∫åÂàÜÊü•ÊâæÁÆóÊ≥ïÔºå ‰ª£Á†ÅÂ¶Ç‰∏ãÔºö ÊòæÁÑ∂LÂ∞±ÊòØÊúÄÁªàÁöÑ‰ΩçÁΩÆ„ÄÇ ÂèØÊòØÁé∞Âú®‰ªñÁöÑÊàêÁª©ÂÖ®Ë¢´lcyÂ≠¶ÂßêÊâì‰π±‰∫ÜÔºàÈöèÊú∫ÊääÊï∞Â≠ó‰π±ÊîæÔºâ„ÄÇ ‰ªñÊÉ≥Áü•ÈÅìÊúÄÂêéÊâæÂà∞ÁöÑ‰ΩçÁΩÆ‰ªçÁÑ∂ÊòØÂéüÊù•ÁöÑ‰ΩçÁΩÆÁöÑÊ¶ÇÁéáÔºå ËØ∑‰Ω†Â∏ÆÂ∏Æ‰ªñ„ÄÇ Ê¶ÇÁéáÊòØÂú®Ê®°1e9 + 7ÊÑè‰πâ‰∏ãÁöÑÔºå Âç≥ p / q = p * inv(q) „ÄÇinv(q)ÊòØqÂú®Ê®°1e9 + 7 ÊÑè‰πâ‰∏ãÁöÑÈÄÜÂÖÉ„ÄÇ Input ËæìÂÖ•Á¨¨‰∏ÄË°å‰∏Ä‰∏™Ê≠£Êï¥Êï∞N„ÄÇ Á¨¨‰∫åË°åN‰∏™Ê≠£Êï¥Êï∞a[i]Ôºå‰ª£Ë°®ÁöÑÊòØÂéüÊù•ÁöÑÊàêÁª©ÂçïÔºåÂëàÈùûÈÄíÂáèÈ°∫Â∫è„ÄÇ Á¨¨‰∏âË°å‰∏Ä‰∏™Êï∞Â≠óxÔºå‰ª£Ë°®‰ªñÁöÑÊï∞Â≠¶ÊàêÁª©„ÄÇ 1 &lt;= N &lt;= 1e5 1 &lt;= a[i] &lt;= 1e9 x‰øùËØÅÊòØÊüê‰∏Ä‰∏™a[i]„ÄÇ Output ËæìÂá∫‰∏Ä‰∏™Êï¥Êï∞‰ª£Ë°®Ê¶ÇÁéá„ÄÇ Sample Input 1 18 1 1 1 3 7 9 9 10 1 Sample Output 1 11 Sample Input 2 13 1 2 2 2 Sample Output 2 1333333336 Hint ÂØπ‰∫éÁ¨¨‰∫å‰∏™Ê†∑‰æãÔºålcyÂ≠¶ÂßêÂèØËÉΩÊâì‰π±ÊàêËøô3ÁßçÁ≠âÊ¶ÇÁéáÁöÑÊÉÖÂÜµÔºö 1 2 2 2 1 2 2 2 1 ÂÖ∂‰∏≠Âè™ÊúâÁ¨¨‰∏ÄÁßç‰ºöÁªìÊûúÊ≠£Á°Æ„ÄÇ Ê¶ÇÁéáÊòØ1 / 3„ÄÇ È¢òËß£ÔºöÊ∞¥È¢òÔºåÁõ¥Êé•ÊääÂ∞è‰∫éxÁöÑ‰∏™Êï∞ÔºåaÔºåÂíåÂ§ß‰∫éxÁöÑ‰∏™Êï∞ÁÆóÂá∫Êù•bÔºåÁÑ∂ÂêéÁÖßËøô‰∏™‰∫åÂàÜÂÜôÊ≥ï‰∏ÄË∑ØÊääÁ≠îÊ°àÁÆó‰∏ãÂéªÂ∞±Ë°å‰∫ÜÔºõÂÖ∑‰ΩìÁúã‰ª£Á†Å„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e5+5;const int inf=0x3f3f3f3f;int l,r;LL pow(LL x,LL n) &#123; LL ans=1; while(n) &#123; if(n&amp;1)ans=ans*x%mod; x=x*x%mod; n&gt;&gt;=1; &#125; return ans;&#125;int n,x;int a[maxn];int main() &#123; scanf(&quot;%d&quot;,&amp;n); for(int i = 1 ; i &lt;= n ; i ++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; scanf(&quot;%d&quot;,&amp;x); LL mx=0,mi=0; for(int i = 1; i&lt;=n; i++) &#123; if(a[i]&gt;=x) &#123; mx++;//Â§ß‰∫éÁ≠â‰∫éxÁöÑ‰∏™Êï∞ &#125; else &#123; mi++;//Â∞è‰∫éÁ≠â‰∫éxÁöÑ‰∏™Êï∞ &#125; &#125; int l=1,r=n; LL ans=1; while(l&lt;=r) &#123; int mid=(l+r)/2; if(a[mid]&gt;=x) &#123; ans=ans*mx%mod*pow(mi+mx,mod-2)%mod;//ÈúÄË¶Å‰∏Ä‰∏™ÈÄâ‰∏Ä‰∏™Â§ß‰∫éÁ≠â‰∫éxÁöÑÊï∞ÔºåÈÄâÂà∞ÁöÑÊ¶ÇÁéáÊòØ(mx/(mi+mx)); mx--; r=mid-1; &#125; else &#123; ans=ans*mi%mod*pow(mi+mx,mod-2)%mod;//Âêå‰∏ä„ÄÇ mi--; l=mid+1; &#125; &#125; printf(&quot;%lld\n&quot;,ans); return 0;&#125; 6.zzqÁöÑÊï∞Â≠¶ÊïôÂÆ§ Description ‰ºóÊâÄÂë®Áü•ÔºåÊë∏È±ºÊòØqwbÁöÑ‰∏ÄÂ§ßÁà±Â•Ω„ÄÇÂç≥‰ΩøÊòØÂú®zzqÁöÑÊï∞Â≠¶ËØæ‰∏äÔºåqwb‰πüÊòØÂú®ÁñØÁãÇÊë∏È±º„ÄÇËøôË¢´ÁúºÂ∞ñÁöÑzzqÂèëÁé∞‰∫ÜÔºåÊâÄ‰ª•zzqÂÜ≥ÂÆöËÄÉËÄÉÊë∏È±ºÁöÑqwbÔºåÂ¶ÇÊûúqwbÁ≠î‰∏çÂá∫Êù•Ôºå‰ªñÁöÑÂπ≥Êó∂ÂàÜËá™ÁÑ∂Â∞±ÂΩíÈõ∂‰∫Ü„ÄÇ Áé∞Âú®zzqÊääÊï∞Â≠ó1~n‰ªéÂ∑¶Ëá≥Âè≥ÊéíÊàê‰∏ÄÊéíÔºàÁ¨¨i‰∏™Êï∞ÁöÑÂÄº‰∏∫iÔºâÔºåÊé•‰∏ãÊù•ËøõË°åmËΩÆÊìç‰ΩúÔºåÊØèÊ¨°Êìç‰ΩúÊèèËø∞Â¶Ç‰∏ãÔºöÂ∞ÜÂ•áÊï∞‰ΩçÁΩÆÁöÑÊï∞Â≠óÂèñÂá∫ÂΩ¢ÊàêÂ∫èÂàóAÔºåÂ∞ÜÂÅ∂Êï∞‰ΩçÁΩÆÁöÑÊï∞Â≠óÂèñÂá∫ÂΩ¢ÊàêÂ∫èÂàóBÔºåÂ∞ÜAÂ∫èÂàóÊãºÊé•Âú®BÂ∫èÂàó‰πãÂêéÔºåÊûÑÊàêÊñ∞ÁöÑÂ∫èÂàó„ÄÇ Áé∞Âú®ÈóÆÈ¢òÊù•‰∫ÜÔºöËøõË°åmÊ¨°Êìç‰ΩúÂêéÔºåÁ¨¨k‰∏™‰ΩçÁΩÆÁöÑÊï∞Â≠óÊòØÂ§öÂ∞ëÂë¢Ôºü Input Á¨¨‰∏ÄË°åÔºåËæìÂÖ•2‰∏™Ê≠£Êï¥Êï∞n,q Êé•‰∏ãÊù•qË°åÔºåÊØèË°å2‰∏™Êï¥Êï∞mÂíåkÔºåË°®Á§∫zzqÊÉ≥Áü•ÈÅìÂú®mÊ¨°Êìç‰Ωú‰πãÂêéÁ¨¨k‰∏™‰ΩçÁΩÆ‰∏äÁöÑÊï∞ÊòØÂ§öÂ∞ë„ÄÇ Êï∞ÊçÆËåÉÂõ¥Ôºö n&lt;=5000 q&lt;=1e6 m&lt;=1e6 k&lt;=n; Output ËæìÂá∫qË°åÔºåÊØèË°åËæìÂá∫Á¨¨k‰∏™‰ΩçÁΩÆÁöÑÊï∞Â≠ó„ÄÇ Sample Input 1 15 2 1 2 2 3 Sample Output 1 14 2 Ê∞¥È¢ò 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 #include&lt;bits/stdc++.h&gt;using namespace std;#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot;&lt;&lt;endl;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;const int maxn=5e3+7;const int inf=0x3f3f3f3f;int n,q;int ar[maxn], br[maxn];int ans[maxn][maxn];int main()&#123; while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;q))&#123; for(int i = 1; i &lt;= n; ++i)&#123; ar[i] = ans[0][i] = i; &#125; int tot, tim = 1; do&#123; tot = 1; for(int i = 2; i &lt;= n; i += 2)&#123; ans[tim][tot] = ans[tim-1][i]; //printf(&quot;%d &quot;, ans[tim][tot]); tot++; &#125; for(int i = 1; i &lt;= n; i += 2)&#123; ans[tim][tot] = ans[tim-1][i]; //printf(&quot;%d &quot;, ans[tim][tot]); tot++; &#125; int flag = 0; for(int i = 1; i &lt;= n; ++i)&#123; if(ans[tim][i] != ar[i])flag = 1; &#125; if(flag == 0)break; tim ++; &#125;while(1); //printf(&quot;*%d\n&quot;,tim); int m, k; while(q--)&#123; scanf(&quot;%d%d&quot;, &amp;m, &amp;k); m %= tim; if(m == 0)m = tim; printf(&quot;%d\n&quot;, ans[m][k]); &#125; &#125; return 0;&#125; 7.Áé©Ê∏∏Êàè Description drÂñúÊ¨¢Áé©Ê∏∏ÊàèÔºåÁé∞Âú®Êúân‰∏™Ê∏∏ÊàèÔºåÊØè‰∏™Ê∏∏ÊàèÊó∂Èó¥‰∏∫[Li,Ri)ÔºåÁé∞Âú®ÈóÆÈ¢òÊòØÔºåÊâæÂá∫ÊúÄÈïøÁöÑ‰∏ÄÊÆµÊ∏∏ÊàèÊó∂Èó¥Ôºå‰ΩøÂæóËØ•Êó∂Èó¥ÊÆµË¢´Ëá≥Â∞ëk‰∏™Ê∏∏ÊàèÂÆåÂÖ®Ë¶ÜÁõñ(Ëøôk‰∏™Âå∫Èó¥Ë¶ÅÊØè‰∏Ä‰∏™ÈÉΩË¶ÅÂÆåÂÖ®Ë¶ÜÁõñ‰Ω†ÈÄâÂá∫Êù•ÁöÑËøô‰∏™Âå∫Èó¥Ôºâ„ÄÇ Input Â§öÁªÑËæìÂÖ• Á¨¨‰∏ÄË°ån,k(1&lt;=n,k&lt;1e6) Êé•‰∏ãÊù•nË°åÔºåÊØèË°å‰∏§‰∏™Êï∞l,r(1&lt;=l&lt;r&lt;=1e9) Output ËæìÂá∫Ëøô‰∏™Âå∫Èó¥ÁöÑÈïøÂ∫¶ Sample Input 1 13 2 1 5 1 4 1 3 Sample Output 1 13 Ë¥™ÂøÉÂ∞±Â•ΩÔºåÊØèÊ¨°‰ªéÊúÄÂÖàÁªìÊùüÁöÑ‰∏Ä‰∏™Á∫øÊÆµÂºÄÂßãÈÄâÔºåÁÑ∂ÂêéÊâæÊúÄÂ∞èÁöÑkÂ∞è‰∫éÂΩìÂâçÁ∫øÊÆµÁªìÊùüÁÇπÁöÑËµ∑ÁÇπÔºåÁÑ∂ÂêéÊª°Ë∂≥Êù°‰ª∂ÁöÑÂå∫Èó¥Â∞±ÊòØÂΩìÂâçÂå∫Èó¥ÁöÑÁªàÁÇπÂáèÂéªk‰∏™Ëµ∑ÂßãÁÇπ‰∏≠ÊúÄÂ§ßÂÄº„ÄÇÊâæÂÆåËøô‰∏™Á∫øÊÆµÁöÑÁªàÁÇπÂêéÊääËøô‰∏™Âå∫Èó¥Âà†ÊéâÔºåÁÑ∂Âêé‰æùÊ¨°Á±ªÊé®‰∏ãÂéªÁü•ÈÅìÊâæÂÆåÊâÄÊúâÁöÑÁ∫øÊÆµ„ÄÇÊú¨Êù•ÊØèÊ¨°Êâæk‰∏™Â∞è‰∫éÂΩìÂâçÁ∫øÊÆµÁöÑÁªìÊùüÁÇπËµ∑ÂßãÁÇπÈúÄË¶Å‰∏Ä‰∏™Êìç‰ΩúÔºå‰ΩÜÊòØÂõ†‰∏∫Êï∞ÊçÆÊúâÁÇπÊ∞¥ÔºåË¢´ÊàëÊ∞¥ËøáÂéª‰∫Ü„ÄÇ„ÄÇ„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 #include&lt;bits/stdc++.h&gt;using namespace std;#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot;&lt;&lt;endl;typedef long long LL;typedef unsigned long long uLL;typedef pair&lt;int, int&gt; P;const int maxn=1e6+7;const int inf=0x3f3f3f3f;struct th &#123; int st,en,id; bool operator &lt;(const th a)const &#123; if(en==a.en) &#123; return st&lt;a.st; &#125; else return en&lt;a.en; &#125;&#125; a[maxn];bool u[maxn];priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt;q;int main() &#123; int n,m; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)) &#123; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d%d&quot;,&amp;a[i].st,&amp;a[i].en); a[i].id=i; q.push(P(a[i].st,i)); &#125; sort(a,a+n); int cnt=0,ans=0,L=0; memset(u,0,sizeof(u)); for(int i =0; i&lt;n; i++) &#123; if(!u[a[i].id])cnt++; u[a[i].id]=1; L=a[i].st; //Êú¨Êù•ËøôÊòØË¶ÅÊâæÊúÄÂ§ßÂÄºÁöÑÔºå‰ΩÜÊòØÊï∞ÊçÆÊúâÁÇπÊ∞¥ÔºåÁõ¥Êé•Â∞±ËøáÂéª‰∫Ü„ÄÇ„ÄÇ„ÄÇ while(cnt&lt;m&amp;&amp;q.size()) &#123; if(u[q.top().second]==1) &#123; q.pop(); continue; &#125; else if(q.top().first&gt;=a[i].en) &#123; break; &#125; else &#123; cnt++; u[q.top().second]=1; L=max(L,q.top().first); q.pop(); &#125; &#125; if(cnt==m) &#123; ans=max(ans,a[i].en-L); &#125; cnt--; &#125; while(q.size())q.pop(); printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125; 9.Á≠æÂà∞È¢ò Description ‚ÄúÁ¥†Êï∞Â∞±ÊòØÂõ†Â≠êÂè™ÂåÖÂê´1ÂíåÂÆÉÊú¨Ë∫´ÁöÑÊï∞‚ÄùzzqÂ¶ÇÊòØËØ¥ÈÅì„ÄÇ Áé∞Âú®zzqÁöÑÊï∞Â≠¶ËØæ‰∏ãËØæ‰∫ÜÔºå‰ªñÂèëÁé∞qwbÂú®‰ªñÁöÑËØæÊë∏È±ºÔºå‰∫éÊòØË¶ÅÂá∫‰∏Ä‰∏™È¢òËÄÉqwbÔºöNÔºÅÁöÑÁ¥†Âõ†Â≠êÊúâÂ§öÂ∞ë‰∏™Ôºü Â¶ÇÊûúqwbÂÅö‰∏çÂá∫Êù•Â∞±Ë¶ÅË¢´py‰∫§ÊòìÔºÅ‰ΩÜÊòØqwbÂÆåÂÖ®‰∏çÁü•ÈÅìzzq‰∏äËØæËÆ≤‰∫Ü‰ªÄ‰πàÔºå‰∫éÊòØÂêë‰ªéÊù•‰∏çÊë∏È±ºÁöÑ‰Ω†Ê±ÇÂä©‰∫ÜÔºàÂàíÈáçÁÇπÔºöËøôÊòØÁÆÄÂçïÈ¢òÔºâ„ÄÇ Input Á¨¨‰∏ÄË°åËæìÂÖ•‰∏Ä‰∏™Êï¥Êï∞TÔºàT \leq 10T‚â§10ÔºâÔºåË°®Á§∫ÊúâTÁªÑÊï∞ÊçÆ„ÄÇ ÊØèÁªÑÊï∞ÊçÆËæìÂÖ•Á´ô‰∏ÄË°åÔºåËæìÂÖ•‰∏Ä‰∏™Êï¥Êï∞NÔºàN \leq 10^5N‚â§105Ôºâ Output ÂØπ‰∫éÊØèÁªÑÊï∞ÊçÆÔºåËæìÂá∫N!ÊúâÂ§öÂ∞ë‰∏™Á¥†Âõ†Â≠ê Sample Input 1 12 1 4 Sample Output 1 10 4 Â¶ÇÈ¢òÁõÆ„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;const int maxn=1e5+7;const int inf=0x3f3f3f3f;int prim[maxn], p[maxn], pcnt;int sum[maxn];int main() &#123; int t; prim[0]=1; prim[1]=1; pcnt = 0; for(int i =2; i &lt; maxn; i++) &#123; if(!prim[i]) p[pcnt++] = i; for(int j = 0; j &lt; pcnt&amp;&amp;i*p[j]&lt;maxn; ++j) &#123; prim[i*p[j]] = 1; if(i%p[j] == 0)break; &#125; &#125; sum[0] = 0; sum[1] = 0; sum[2] = 1; for(int i = 3; i &lt; maxn; ++i) &#123; int tmp = i,cnt = 0; if(prim[i] == 0) &#123; sum[i]=sum[i-1]+1; continue; &#125; for(int j = 0; j &lt; pcnt; ++j) &#123; while(tmp % p[j] == 0) &#123; tmp /= p[j]; cnt++; &#125; if(tmp == 1)break; &#125; if(tmp!=1)cnt++; sum[i] = sum[i-1] + cnt; &#125; int n; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;, &amp;n); printf(&quot;%d\n&quot;, sum[n]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCFÂÇªÈÄºÈ¢òÔºå201709-5-Èô§Ê≥ï---Êö¥ÂäõÂèØ‰ª•ËøáÔºüÔºüÔºüÔºüÔºü]]></title>
    <url>%2F2018%2F09%2F06%2FCCF%E5%82%BB%E9%80%BC%E9%A2%98%EF%BC%8C201709-5-%E9%99%A4%E6%B3%95---%E6%9A%B4%E5%8A%9B%E5%8F%AF%E4%BB%A5%E8%BF%87%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[ËøôÈ¢òÁâπ‰πàÊó†ËØ≠ÔºåÂè≤‰∏äÊúÄÊó†ËØ≠Ê≤°Êúâ‰πã‰∏ÄÔºåC++Á∫ØÊö¥ÂäõËøá 90ÔºüÔºüÔºüÔºüÔºåJAVAÁ∫ØÊö¥ÂäõËøá‰∫ÜÔºüÔºüÔºüÔºüÔºüÔºüÔºüÔºüÔºüÔºüÔºüÔºüÔºåtell me ÔºåÂèëÁîü‰∫Ü‰ªÄ‰πàÔºåËøôÈ¢ò‰∏∫‰ªÄ‰πàËÉΩÊö¥Âäõ„ÄÇ CCFÂ¶ÇÊûúJAVAÁÜüÁªÉÔºåÂª∫ËÆÆÂ§ßÂÆ∂Áî®JAVA„ÄÇ http://118.190.20.162/view.page?gpid=T59 JAVAÁ∫ØÊö¥ÂäõAC‰ª£Á†Å„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 //import java.lang.reflect.Array;import java.math.*;import java.util.Arrays;import java.util.Scanner;//import om.sun.swing.internal.plaf.basic.resources.basic;public class Main &#123; static int[] a= new int[100005]; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int n = input.nextInt(),m = input.nextInt(); for(int i= 1 ; i &lt;= n ; i ++) &#123; a[i] = input.nextInt(); &#125; int op,l,r,v; for(int j=0;j&lt;m;j++) &#123;// op = input.nextInt(); l = input.nextInt(); r = input.nextInt(); if(op==1) &#123; v = input.nextInt(); if(v == 1)continue; for(int i = l ; i &lt;= r; i ++) &#123; if(a[i] &gt;= v &amp;&amp; a[i] % v == 0) &#123; a[i] /= v; &#125; &#125; &#125; else &#123;// l=input.nextInt();// r=input.nextInt(); long ans=0; for(int i=l;i&lt;=r;i++) &#123; ans += a[i]; &#125; System.out.println(ans); &#125; &#125;// System.out.println(ans); &#125;&#125; C++Á∫ØÊö¥ÂäõÔºåËøá 90%ÔºåËøô‰∏™ÂèØ‰ª•ÁêÜËß£„ÄÇ„ÄÇ„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;const long long mod=1e9+7;const int maxn=1e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int A[maxn];int n,m;int main() &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;A[i]); &#125; while(m--) &#123; int op,l,r,v; scanf(&quot;%d%d%d&quot;,&amp;op,&amp;l,&amp;r); if(op==1) &#123; scanf(&quot;%d&quot;,&amp;v); if(v==1)continue; while(l&lt;=r) &#123; if(A[l]&gt;=v&amp;&amp;A[l]%v==0) &#123; A[l]/=v; &#125; l++; &#125; &#125; else &#123; long long ans=0; while(l&lt;=r) &#123; ans+=A[l++]; &#125; printf(&quot;%lld\n&quot;,ans); &#125; &#125; return 0;&#125; C++ÔºåAC‰ª£Á†Å„ÄÇ‰πüÊòØÂçä‰∏™Êö¥Âäõ„ÄÇÂõ†‰∏∫ÊØè‰∏™Êï∞ÂéªÈô§ÊúÄÂ§öÂè™ËÉΩÈô§ 32Ê¨°ÔºåÔºàÂõ†‰∏∫Êï∞ÁöÑÊúÄÂ§ßÂÄºÂè™Êúâ1e6,ÊØèÊ¨°Â∞±ÁÆóÂè™Èô§2Ôºå‰πü‰∏çËÉΩÈô§Â§öÂ∞ëÊ¨°ÔºåÊâÄ‰ª•Ëøô‰∏™Êõ¥Êñ∞ÂèØ‰ª•Êö¥ÂäõÔºåÂπ∂‰∏ç‰ºöË∂ÖÊó∂„ÄÇÂ§çÊùÇÂ∫¶ÊúÄÈ´ò‰πüÂè™Êúâ 32 N logN,ÈáçÁÇπÂú®‰∫éÂ§ÑÁêÜÂâçÁºÄÂíåÔºâÔºå‰∏ç‰ºöÂÜçÂ§öÔºåÊâÄ‰ª•Âè™ÈúÄË¶ÅÁî®‰∏Ä‰∏™Ê†ëÁä∂Êï∞ÁªÑÁª¥Êä§ÂâçÁºÄÂíåÂç≥ÂèØÔºåÊØèÊ¨°Êõ¥Êñ∞ÂÄºÔºåÁõ¥Êé•Êö¥ÂäõËÉΩ‰∏çËÉΩÈô§ÔºåÁÑ∂ÂêéÂÜçÊõ¥Êñ∞ÂÄºÂç≥ÂèØ„ÄÇ ËÄÉÂØü‰∏§ÁÇπÔºö1.Êö¥ÂäõÊõ¥Êñ∞ÂÄºÔºàÊ≥®ÊÑèÁâπÂà§Èô§1ÔºâÔºå2.Ê†ëÁä∂Êï∞ÁªÑÊ±ÇÂâçÁºÄÂíå„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;const long long mod=1e9+7;const int maxn=1e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int A[maxn];long long bit[maxn];int n,m;long long sum(int i) &#123; long long ans=0; while(i&gt;0) &#123; ans+=bit[i]; i-=i&amp;-i; &#125; return ans;&#125;void add( int i, int x) &#123; while(i&lt;=n) &#123; bit[i]+=x; i += i&amp;-i; &#125;&#125;int main() &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;A[i]); add(i,A[i]); &#125; while(m--) &#123; int op,l,r,v; scanf(&quot;%d%d%d&quot;,&amp;op,&amp;l,&amp;r); if(op==1) &#123; scanf(&quot;%d&quot;,&amp;v); if(v==1)continue; while(l&lt;=r) &#123; if(A[l]&gt;=v&amp;&amp;A[l]%v==0) &#123; add(l,0-A[l]+A[l]/v); A[l]/=v; &#125; l++; &#125; &#125; else &#123; printf(&quot;%lld\n&quot;,sum(r)-sum(l-1)); &#125; &#125; return 0;&#125; ÁªÜÂøÉÁöÑÂ≠©Â≠êÔºåËÇØÂÆö‰∏ÄÂÆöÂèëÁé∞‰∫Ü„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇÔºåJAVAÊö¥ÂäõÔºå6s „ÄÇC++Ê†ëÁä∂Êï∞ÁªÑ7sÔºåÊàëÁ´üÊó†Ë®Ä‰ª•ÂØπ„ÄÇÊö¥ÂäõÊØîÊ†ëÁä∂Êï∞ÁªÑÂø´ÔºåËøôÊï∞ÊçÆÂá∫ÁöÑÊå∫Â•ΩÁöÑ„ÄÇ„ÄÇ„ÄÇ]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2013-2014 Summer Petrozavodsk Camp, Andrew Stankevich Contest 44 (ASC 44)]]></title>
    <url>%2F2018%2F08%2F31%2F2013-2014%20Summer%20Petrozavodsk%20Camp%2C%20Andrew%20Stankevich%20Contest%2044%20(ASC%2044)%2F</url>
    <content type="text"><![CDATA[ÊöëËÆ≠ÊúÄÂêé‰∏ÄÂú∫ÁªÑÈòüËÆ≠ÁªÉËµõÔºåÁâπ‰πàÊïÖÊÑèÁöÑÔºåÊääÂà´‰∫∫ÁöÑWFÁªÉ‰π†È¢òÁªôÊàë‰ª¨ÂÜôÔºåÂÜô‰∫ÜÂçäÂ§©ÊâçÁ≠æÂà∞‰∏§È¢ò„ÄÇÈù†ÔºÅ B - Braess‚Äôs Paradox Gym - 100518B È¢òÊÑèÔºöÊúâÂá†‰∏™ÁÇπÔºåÊØè‰∏™ÁÇπÂà∞‰∏ã‰∏Ä‰∏™ÁÇπ‰πãÈó¥Êúâ‰∏§Êù°Ë∑Ø„ÄÇ‰∏äÈù¢‰∏ÄÊù°Ë∑ØÁöÑÈÄöËøáÊó∂Èó¥ÊòØ AK1+B,‰∏ãÈù¢‰∏ÄÊù°ÈÄöËøáÊó∂Èó¥ÊòØCK2+DÔºåË¶Å‰∏§Êù°Ë∑ØÈÄöËøáÁöÑÊó∂Èó¥Êï∞Â∞ΩÈáèÁõ∏ÂêåÔºåK1+K2=1(K1,K2ÊòØÁªèËøáÁöÑ‰∫∫ÊµÅÈáèÂç†ÊÄª‰∫∫Êï∞ÁöÑÊØî‰æã)„ÄÇÁÑ∂Âêé‰∏≠Èó¥ÁöÑÁÇπÂèØ‰ª•Âª∫È©øÁ´ôÔºåÂ¶ÇÊûú‰∏≠Èó¥ÁöÑÁÇπ‰∏çÂª∫È©øÁ´ôÔºåÂ∞±Áõ∏ÂΩì‰∫éÁõ¥Êé•‰ªéËµ∑ÁÇπÂà∞ÁªàÁÇπÔºåÂè™Êúâ‰∏§Êù°Ë∑ØÔºåÂ¶ÇÊûúÂª∫‰∫ÜÈ©øÁ´ôÔºåÂ∞±Áõ∏ÂΩì‰∫é‰ªéËµ∑ÁÇπÂà∞È©øÁ´ôÔºåÂÜç‰ªéÈ©øÁ´ôÂà∞ÁªàÁÇπ„ÄÇ È¢òËß£ÔºöÂâç‰∏§‰∏™Áõ¥Êé•ÁÆóÂá∫Êù•Â∞±Ë°åÔºå‰∏Ä‰∏™È©øÁ´ôÈÉΩ‰∏çÂª∫ÔºåÂ∞±Áõ∏ÂΩì‰∫é‰∏§Êù°Ë∑ØÔºåÊääÊâÄÊúâÁÇπ‰∏äÈù¢ÈÇ£Êù°Ë∑ØÔºåai.bi,Âä†Ëµ∑Êù•Â∞±ÊòØ‰∏äÈù¢ÈÇ£‰∏ÄÊù°Ë∑ØÁöÑA,BÔºåÂêåÁêÜÔºå‰∏ãÈù¢‰∏ÄÊù°Ë∑ØÂ∞±ÊòØÊâÄÊúâÁöÑ,ci,diÂä†Ëµ∑Êù•„ÄÇÊØè‰∏™ÈÉΩÂª∫Â∞±ÊòØÁõ∏ÂΩì‰∫é‰∏Ä‰∏™‰∏™ÁÇπËµ∞ËøáÂéªÔºåÊö¥ÂäõÂïäÔºå‰∏Ä‰∏™ÁÇπÂà∞Âè¶‰∏Ä‰∏™ÁÇπÁöÑÊó∂Èó¥ÔºåÁÑ∂ÂêéÂÖ®Âä†Ëµ∑Êù•Â∞±Ë°å‰∫Ü„ÄÇÂêéÈù¢‰∏§‰∏™Â∞±ÊòØÊ±ÇÊúÄÂ∞èÈÄöËøáÊó∂Èó¥ÁöÑÂíåÊúÄÂ§ßÈÄöËøáÊó∂Èó¥ÔºåÁúã‰ººÂæàÈöæÔºåÂÖ∂ÂÆûÂ∞±ÊòØ‰∏Ä‰∏™ÂæàÁÆÄÂçïÁöÑDPÔºåN^2ÁöÑÂ§çÊùÇÂ∫¶‰∏ç‰ºöË∂ÖÊó∂„ÄÇÈ¶ñÂÖàÈ¢ÑÂ§ÑÁêÜ‰ªéËµ∑ÁÇπÂà∞ÂΩìÂâçÁÇπÁöÑA,B,C,D„ÄÇÁÑ∂ÂêéÊØè‰∏™ÁÇπÁöÑÊó∂Èó¥Â∞±ÊòØ‰ªéÂâçÈù¢Êüê‰∏Ä‰∏™ÁÇπÂª∫È©øÁ´ôÁöÑÊúÄÂ∞èÂÄºÔºåÊúÄÂ§ßÂÄºËΩ¨ÁßªËøáÊù•„ÄÇÁõ¥Êé•ËøáÊù•‰∏äÈù¢Ë∑ØÁöÑAÔºåBÂ∞±Áî®‰∏§‰∏™ÂâçÁºÄÁõ∏Âáè„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;ll,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e3+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;int a[maxn],b[maxn],c[maxn],d[maxn];double qza[maxn],qzb[maxn],qzc[maxn],qzd[maxn];double dp1[maxn],dp2[maxn];double ans1,ans2,ans3,ans4;int main() &#123; freopen(&quot;braess.in&quot;,&quot;r&quot;,stdin); freopen(&quot;braess.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d%d%d%d&quot;,&amp;a[i],&amp;b[i],&amp;c[i],&amp;d[i]); &#125; double A=0,B=0,C=0,D=0; for(int i=1; i&lt;=n; i++) &#123; //Á¨¨‰∏ÄÁßçÁªìÊûúÈÉΩ‰∏çÂª∫ÔºåAÁõ∏ÂΩì‰∫éÊâÄÊúâÁÇπ‰πãÈó¥ÁöÑa[i]Áõ∏Âä† A+=a[i]; B+=b[i]; C+=c[i]; D+=d[i]; &#125; double k; if(A+C!=0) &#123; k=min(1.0,(D+C-B)/(A+C));//k1ÊúÄÂ§ßÂÄº‰∏çËÉΩË∂ÖËøá1 ans1=k*A+B; if(k&lt;=0) &#123; //k1ÊúÄÂ∞èÂÄº‰∏çËÉΩÂ∞è‰∫é0ÔºåÂ¶ÇÊûúÂ∞è‰∫éÁ≠â‰∫é0ËØ¥ÊòéÊâÄÊúâ‰∫∫ÈÉΩËµ∞‰∏ãÈù¢‰∏ÄÊù°Ë∑Ø ans1=C+D; &#125; &#125; else &#123; ans1=min(B,D); //Â¶ÇÊûúACÈÉΩÁ≠â‰∫éÈõ∂ÔºåÈÇ£Â∞±Áõ¥Êé•Âà§Êñ≠BÔºåDÂ§ßÂ∞è &#125; ans2=0; for(int i=1; i&lt;=n; i++) &#123; A=a[i]; //ÊâÄÊúâÁöÑÁÇπ‰∏Ä‰∏™‰∏™ÁÆó B=b[i]; C=c[i]; D=d[i]; double temp; if(A+C!=0) &#123; k=min(1.0,(D+C-B)/(A+C)); temp=k*A+B; if(k&lt;=0) &#123; temp=C+D; &#125; &#125; else &#123; temp=min(B,D); &#125; ans2+=temp; &#125; for(int i=1; i&lt;=n; i++) &#123; //Ê±ÇÂâçÁºÄ qza[i]=qza[i-1]+a[i]; qzb[i]=qzb[i-1]+b[i]; qzc[i]=qzc[i-1]+c[i]; qzd[i]=qzd[i-1]+d[i]; dp1[i]=inf; &#125; dp1[0]=0; for(int i=1; i&lt;=n; i++) &#123; for(int j=0; j&lt;i; j++) &#123; A=qza[i]-qza[j]; B=qzb[i]-qzb[j]; //ABCDÁ≠â‰∫é‰∏ä‰∏Ä‰∏™Áä∂ÊÄÅÂíåÂΩìÂâçÁä∂ÊÄÅÁöÑÂ∑ÆÂÄºÔºå C=qzc[i]-qzc[j]; D=qzd[i]-qzd[j]; double temp; if(A+C!=0) &#123; k=min(1.0,(D+C-B)/(A+C)); temp=k*A+B; if(k&lt;=0) &#123; temp=C+D; &#125; &#125; else &#123; temp=min(B,D); &#125; dp1[i]=min(dp1[i],dp1[j]+temp); //dp1‰øùÁïôÊúÄÂ∞èÂÄºÔºå‰ªéjÈ©øÁ´ôËΩ¨ÁßªÂà∞iÈ©øÁ´ôÁöÑÊúÄÂ∞èÂÄº dp2[i]=max(dp2[i],dp2[j]+temp); //ÊúÄÂ§ßÂÄº &#125; &#125; ans3=dp1[n]; ans4=dp2[n]; printf(&quot;%.10f\n%.10f\n%.10f\n%.10f\n&quot;,ans1,ans2,ans3,ans4); return 0;&#125; I - Intelligent Tourist Gym - 100518I È¢òÊÑèÔºöÊúâNÂú∫ËÄÉËØïÔºåÁ¨¨iËÄÉËØïÈúÄË¶ÅÂ§ç‰π†piÂ§©ÔºåËÄÉËØïÊó∂Èó¥ÊòØdiÔºåËÄÉËØïÁöÑÊó∂Èó¥Ê≤°Ê≥ïÂ§ç‰π†ÔºåÂ¶ÇÊûúÊ≤°ÊúâÂ§ç‰π†Â§öÂ§©ÈÇ£Âú∫ËÄÉËØïÂ∞±‰∏ç‰ºöÂéªÔºåÂ∞±‰ºöÂéªÂ§ç‰π†ÂÖ∂‰ªñËÄÉËØïÔºå‰∏≠Èó¥Êúâ‰∫õÂ§©ÊúâÊ¥ªÂä®ÔºåÊ¥ªÂä®Êó∂Èó¥ÊòØs-tÊ¥ªÂä®Êó∂Èó¥‰∏ç‰ºöÂéªÂ§ç‰π†ÔºåÈóÆÊúÄÂ§öËÉΩÈÄöËøáÊú∫Âú∫ËÄÉËØï„ÄÇ È¢òËß£ÔºöË¥™ÂøÉÔºåËøôÈ¢òË¥º‰ªñÂ¶àÂÇªÈÄºÔºåÊºèÁúã‰∫Ü‰∏Ä‰∏™Êù°‰ª∂ÔºåDEBUG‰∏Ä‰∏™Â∞èÊó∂„ÄÇ„ÄÇ„ÄÇÔºå‰ªéÂêéÈù¢ÂæÄÂâçÈù¢Êâ´ÔºåÊØèÊ¨°ÈÄâÈúÄË¶ÅÂ§ç‰π†Êó∂Èó¥ÊúÄÂ∞ëÁöÑ‰∏ÄÂú∫ËÄÉËØïÔºåÂõ†‰∏∫Ëøô‰∏™Êó∂Èó¥Âè™ËÉΩÁªôÂêéÈù¢ÁöÑÊâÄ‰ª•‰∏çÁî®ÊãÖÂøÉÈÄâÁöÑËÄÉËØïÊó∂Èó¥Â∑≤ÁªèËøá‰∫ÜÔºåËá≥‰∫éËÄÉËØïÊó∂Èó¥‰∏çËÉΩÂ§ç‰π†Ôºå‰Ω†Áõ¥Êé•ÊääËÄÉËØï‰πüÂΩì‰ΩúÂ§ç‰π†ÁöÑÊó∂Èó¥Ôºå‰∏çÂéªËÄÉËØïÂ∞±Áõ∏ÂΩì‰∫éÂ∞ëÂ§ç‰π†ËøôÁßçÁßëÁõÆ‰∏ÄÂ§©ÔºåÂéª‰∫ÜÂ∞±Áõ∏ÂΩì‰∫éÂ§öÂ§ç‰π†‰∏ÄÂ§©„ÄÇ„ÄÇ„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;ll,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,m;struct one &#123; ll d,p; int id; bool operator&lt;(const one a)const &#123; return d&lt;a.d; &#125;&#125; X;struct two &#123; ll st,en; bool operator&lt;(const two a)const &#123; return st&lt;a.st; &#125;&#125; H;priority_queue&lt;one&gt; q1;priority_queue&lt;two&gt; q2;priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt;q;int main() &#123; freopen(&quot;intelligent.in&quot;,&quot;r&quot;,stdin); freopen(&quot;intelligent.out&quot;,&quot;w&quot;,stdout); while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n) &#123; vector&lt;int&gt; v; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%I64d%I64d&quot;,&amp;X.d,&amp;X.p); X.p++; X.id=i+1; q1.push(X); &#125; scanf(&quot;%d&quot;,&amp;m); for(int i=0; i&lt;m; i++) &#123; scanf(&quot;%I64d%I64d&quot;,&amp;H.st,&amp;H.en); q2.push(H); &#125; while(q2.size()) &#123; if(q2.top().st&gt;q1.top().d) &#123; q2.pop(); &#125; else break; &#125; while(q1.size()) &#123; X=q1.top(); q1.pop(); ll temp; if(q1.size()==0)temp=0; else temp=q1.top().d; ll tim=0; tim=X.d-temp; while(q2.size()) &#123; H=q2.top(); if(H.st&gt;temp) &#123; q2.pop(); tim-=H.en-H.st+1; &#125; else break; &#125; if(X.p==0) &#123; v.push_back(X.id); &#125; else q.push(P(X.p,X.id)); while(tim&gt;0&amp;&amp;q.size()) &#123; P temp2=q.top(); q.pop(); if(tim&gt;=temp2.first) &#123; tim-=temp2.first; v.push_back(temp2.second); &#125; else &#123; temp2.first-=tim; tim=0; q.push(temp2); &#125; &#125; &#125; while(q1.size())q1.pop(); while(q2.size())q2.pop(); while(q.size())q.pop(); sort(v.begin(),v.end()); int ans=v.size(); printf(&quot;%d\n&quot;,ans); for(int i=0; i&lt;ans; i++) &#123; printf(&quot;%d&quot;,v[i]); if(ans==i+1)printf(&quot;\n&quot;); else printf(&quot; &quot;); &#125; if(ans==0)puts(&quot;&quot;); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÂÇªÁìúÁ∫ßgitÂëΩ‰ª§ÁêÜËß£]]></title>
    <url>%2F2018%2F08%2F27%2F%E5%82%BB%E7%93%9C%E7%BA%A7git%E5%91%BD%E4%BB%A4%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[git clone wangzhi.com ‚ÄîÂÖãÈöÜÂØπÂ∫îÁΩëÂùÄ‰ªìÂ∫ì git pull ‚ÄìÊõ¥Êñ∞‰ªìÂ∫ì git add -A Ê∑ªÂä†Âà∞ÁºìÂÜ≤Âå∫Ôºå git commit -m‚Äúyour name‚Äù Êõ¥Êñ∞Êú¨Âú∞‰ªì git push Êèê‰∫§‰∏äÁΩëÁªú‰ªìÂ∫ì ‰∏äÈù¢3‰∏™ËøûÁùÄÁî®Â∞±Ë°å‰∫Ü„ÄÇ git config ‚Äîglobal user.name ‚ÄúËæìÂÖ•‰Ω†ÁöÑÁî®Êà∑Âêç‚Äù git config ‚Äîglobal user.email ‚ÄúËæìÂÖ•‰Ω†ÁöÑÈÇÆÁÆ±‚Äù ÂàùÂßãÂåñ‰∏ãË∫´‰ªΩÁÖßÁùÄÊâìÂ∞±Ë°å‰∫Ü]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The 17th Zhejiang University Programming Contest Sponsored by TuSimple(ÊµôÊ±üÁúÅËµõ)]]></title>
    <url>%2F2018%2F08%2F27%2FThe%2017th%20Zhejiang%20University%20Programming%20Contest%20Sponsored%20by%20TuSimple(%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9B)%2F</url>
    <content type="text"><![CDATA[A - Marjar Cola ZOJ - 3948 Á≠æÂà∞È¢òÔºåx,y,a,b,ÈÉΩÂæàÂ∞èÁõ¥Êé•Êö¥Âäõ„ÄÇÂà§Êñ≠INFÔºåÂè™Ë¶ÅÂà§Êñ≠Ê¨°Êï∞ÊúâÊ≤°ÊúâËøáÂ§öÂ∞±Ë°å„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int main() &#123; int x,y,a,b; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; int ans=0; scanf(&quot;%d%d%d%d&quot;,&amp;x,&amp;y,&amp;a,&amp;b); if(x==1||y==1)puts(&quot;INF&quot;); else &#123; while(a&gt;=x||y&lt;=b) &#123; if(a&gt;=x) &#123; a-=x; a++; b++; ans++; &#125; else &#123; b-=y; b++; a++; ans++; &#125;// debug(a);// debug(b); if(ans&gt;3e5)&#123; break; &#125; &#125; if(ans&gt;3e5)&#123; puts(&quot;INF&quot;); &#125; else printf(&quot;%d\n&quot;,ans); &#125; &#125; return 0;&#125; C - How Many Nines ZOJ - 3950 Êâì‰∏™Ë°®ÔºåÊØîËæÉËÄÉËôëÁªÜËäÇÔºåÁúüÁöÑÈöæÂ§ÑÁêÜ„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e4+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int Year[maxn], Mon[35], pre1[maxn], pre2[35];int hh[13], mon[13];bool leap(int y)&#123; if(y%400==0)return 1; if(y%100==0)return 0; if(y%4==0)return 1; return 0;&#125;int nine(int y)&#123; int cnt = 0; while(y)&#123; if(y%10==9)cnt++; y/=10; &#125; return cnt;&#125;void init()&#123; Mon[1]=Mon[3]=Mon[5]=Mon[7]=Mon[8]=Mon[10]=Mon[12]=3;///31 Mon[2]=2; Mon[4]=Mon[6]=Mon[9]=Mon[11] = 3;///30 Mon[9] += 30; hh[1]=hh[3]=hh[5]=hh[7]=hh[8]=hh[10]=hh[12]=31; hh[2] = 28; hh[4]=hh[6]=hh[9]=hh[11]=30; mon[0] = 0; for(int i = 1; i &lt;= 12; ++i)&#123; mon[i] = hh[i]+mon[i-1]; &#125; int sum = 0;pre1[1999]=pre2[0] = 0; for(int i = 1; i &lt;= 12; ++i)&#123; sum += Mon[i]; pre2[i] = pre2[i-1]+Mon[i]; &#125; for(int i = 2000; i &lt;= 9999; ++i)&#123; int tmp = nine(i); if(tmp)&#123; Year[i] = sum + tmp*365; if(leap(i))Year[i] += tmp + 1; &#125;else&#123; Year[i] = sum; if(leap(i))++Year[i]; &#125; pre1[i] = pre1[i-1]+Year[i]; &#125;&#125;int get(int d)&#123; if(d&lt;=9)return 3; if(d&lt;=19)return 2; if(d&lt;=29)return 1; return 0;&#125;int main()&#123;#ifndef ONLINE_JUDGE //freopen(&quot;E://ADpan//in.in&quot;, &quot;r&quot;, stdin); //freopen(&quot;E://ADpan//out.out&quot;, &quot;w&quot;, stdout); #endif init(); int tim;scanf(&quot;%d&quot;,&amp;tim); while(tim--)&#123; int y1,m1,d1,y2,m2,d2; scanf(&quot;%d%d%d%d%d%d&quot;,&amp;y1,&amp;m1,&amp;d1,&amp;y2,&amp;m2,&amp;d2); if(y1==y2)&#123; if(m1==m2)&#123; int ans = get(d1)-get(d2+1); if(m1==9)ans += d2-d1+1; int tmp = nine(y1); ans += tmp*(d2-d1+1); printf(&quot;%d\n&quot;, ans); continue; &#125; int ans = pre2[m2-1]-pre2[m1]; if(leap(y1)&amp;&amp;2&gt;m1&amp;&amp;2&lt;m2)ans++; ans += get(d1) + 3 - get(d2+1); if(m1==2&amp;&amp;leap(y1)==false)ans--; if(m1==9)&#123; ans+=30-d1+1; &#125; if(m2==9)&#123; ans += d2; &#125; int tmp = nine(y1); if(tmp)&#123; int day = mon[m2-1]-mon[m1] + (hh[m1] - d1 + 1) + d2; if(leap(y1)&amp;&amp;2&gt;m1&amp;&amp;2&lt;m2)day++; if(leap(y1)&amp;&amp;m1==2)day++; ans += day*tmp; &#125; printf(&quot;%d\n&quot;, ans); &#125;else&#123; int ans = pre1[y2-1]-pre1[y1]; int a = 0, b = 0, tmp = nine(y1),day; a = pre2[12]-pre2[m1]; a += get(d1); if(leap(y1)==0&amp;&amp;m1==2)a--; if(leap(y1)&amp;&amp;m1==1)a++; if(m1==9)a += 30-d1+1; b = pre2[m2-1]; b += 3-get(d2+1); if(leap(y2)&amp;&amp;m2&gt;2)b++; if(m2==9)b+=d2; if(tmp)&#123; day = mon[12]-mon[m1] + (hh[m1] - d1 + 1); if(leap(y1)&amp;&amp;m1&lt;=2)day++; a += tmp * day; &#125; tmp = nine(y2); if(tmp)&#123; day = mon[m2-1] + d2; if(leap(y2)&amp;&amp;m2&gt;2)day++; b += tmp * day; &#125; ans += a+b; printf(&quot;%d\n&quot;, ans); &#125; &#125; return 0;&#125; F - Knuth-Morris-Pratt Algorithm ZOJ - 3957 Á≠æÂà∞È¢òÔºåKMPÔºåÂà§Êñ≠‰∏Ä‰∏ãÊ¨°Êï∞Â∞±Ë°å„ÄÇÊö¥ÂäõÂà§Êñ≠‰πüÊ≤°‰∫ã 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;char ch1[]=&quot;dog&quot;,ch2[]=&quot;cat&quot;;int nex[2000];void get_next(char *t,int lent)&#123; nex[0] = -1; for(int i = 0,k = -1;i &lt; lent;)&#123; if(k==-1||t[i] == t[k])&#123; ++k;++i; nex[i]=k; &#125;else k = nex[k]; &#125;&#125;int kmp(char *s,int lens,char *t,int lent)&#123; if(lens&lt;lent)return 0; get_next(t,lent); int i = 0, j = 0; int cnt = 0; while(i &lt; lens&amp;&amp;j&lt;lent) &#123; if(j==-1||s[i] == t[j])&#123; i++;j++; if(j==lent)&#123; cnt++; j = nex[j]; &#125; &#125;else j=nex[j]; &#125; return cnt;&#125;int main() &#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; char s[2000]; scanf(&quot;%s&quot;,s); int l=strlen(s); int ans=0; ans+=kmp(s,l,ch1,3); ans+=kmp(s,l,ch2,3); printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125; G - Intervals ZOJ - 3953 Ë¥™ÂøÉÔºåÁúüÁöÑË¥™ÁöÑÂÜÖÂøÉÂ¥©Ê∫É„ÄÇË¥™ÂøÉÁ≠ñÁï•ÔºåÊåâLÊéíÂ∫èÔºåÊØèÊ¨°Âà§Êñ≠3‰∏™Âå∫Èó¥ÔºåÂ¶ÇÊûúÂá∫Áé∞3‰∏™ÈáçÂêàÔºå‰∏¢Âéª RÊúÄÂ§ßÁöÑÔºåÂõ†‰∏∫ÂΩ±ÂìçÊúÄÂ§ß„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;struct seg &#123; int st,en,id; bool operator &lt; (const seg a )const &#123; return en&lt;a.en; &#125;&#125; sg[maxn];bool cmp(seg a,seg b) &#123; if(a.st==b.st) &#123; return a.en&lt;b.en; &#125; return a.st&lt;b.st;&#125;int res[maxn];int main() &#123; int n,t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d%d&quot;,&amp;sg[i].st,&amp;sg[i].en); sg[i].id=i+1; &#125; sort(sg,sg+n,cmp); priority_queue&lt;seg&gt;q; int ans=0; for(int i=0; i&lt;n; i++) &#123; if(q.size()&lt;2) &#123; q.push(sg[i]); &#125; else &#123; q.push(sg[i]); seg s[3]; for(int i=0; i&lt;3; i++) &#123; s[i]=q.top(); q.pop(); &#125; if(s[0].st&lt;=s[2].en&amp;&amp;s[1].st&lt;=s[2].en) &#123; res[ans++]=s[0].id; q.push(s[1]); q.push(s[2]); &#125; else &#123; q.push(s[0]); q.push(s[1]); &#125; &#125; &#125; sort(res,res+ans); printf(&quot;%d\n&quot;,ans); for(int i=0; i&lt;ans; i++) &#123; printf(&quot;%d&quot;,res[i]); if(i+1==ans)printf(&quot;\n&quot;); else printf(&quot; &quot;); &#125; if(ans==0)puts(&quot;&quot;); &#125; return 0;&#125; H - Seven-Segment Display ZOJ - 3954 È¢òÊÑè Ôºö1-9‰πù‰∏™Êï∞ÔºåÂàÜÂà´ÂèØ‰ª•Áî®ÂêéÈù¢7‰∏™0 1Ë°®Á§∫Ôºå‰∏ãÈù¢Áªô‰Ω†n‰∏™Êï∞ÔºåÊØè‰∏™Êï∞ÂêéÈù¢Ë∑üÊúâ7‰∏™01‰∏≤Ôºå‰Ω†ÂèØ‰ª•‰∫§Êç¢n‰∏™Êï∞‰ªªÊÑè‰∏§Âàó„ÄÇÂ¶ÇÊûúÂèØ‰ª•ÈÄöËøá‰∫§Êç¢Ë°®Á§∫Âá∫Êù•ËæìÂá∫YES Âê¶ÂàôNO„ÄÇ ‰æãÂ≠ê : 17 0101011 1 1101011 ÊääÁ¨¨2ÂàóÂíåÁ¨¨5Âàó‰∫§Êç¢ÔºåÂèòÊàê 11 1001111 7 0001111 ‰∏é1 7 ÁöÑË°®Á§∫ÂåπÈÖçÔºåÊâÄ‰ª•ËæìÂá∫YES È¢òËß£ÔºöËøôÈ¢òÂè™Êúâ9‰∏™Êï∞ÔºåÊö¥ÂäõÂïäÂåπÈÖçÔºån^2ÈÉΩ‰∏ç‰ºöË∂ÖÊó∂„ÄÇ„ÄÇ„ÄÇÔºõÊàëÊòØÊääÊØè‰∏ÄÂàóÁöÑÁä∂ÊÄÅÁî®‰∏Ä‰∏™10ËøõÂà∂Êï∞‰øùÂ≠òÔºåÊØèÊ¨°ËÉΩÂ§ü‰ªéÂéüÊù•ÁöÑÊï∞ÈáåÈù¢Êâæ‰∏é‰πãÂåπÈÖçÁöÑÁä∂ÊÄÅÔºåÂ¶ÇÊûúÊâæ‰∏çÂà∞ÔºåÂ∞±ËæìÂá∫NOÔºõ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int mp[10];int n;int k[10],v[10];int p[10];map&lt;int,int&gt; m;int main() &#123; mp[1]=1001111; mp[2]=10010; mp[3]=110; mp[4]=1001100; mp[5]=100100; mp[6]=100000; mp[7]=1111; mp[8]=0; mp[9]=100; int t; p[0]=1; for(int i=1; i&lt;10; i++) &#123; p[i]=p[i-1]*10; &#125; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d%d&quot;,&amp;k[i],&amp;v[i]); &#125; m.clear(); for(int i=0; i&lt;7; i++) &#123; int sum=0; for(int j=0; j&lt;n; j++) &#123; sum+=mp[k[j]]/p[i]%10*p[j]; &#125; m[sum]++; &#125; int flag=1; for(int i=0; i&lt;7; i++) &#123; int sum=0; for(int j=0; j&lt;n; j++) &#123; sum+=v[j]/p[i]%10*p[j]; &#125; m[sum]--; if(m[sum]&lt;0) &#123; flag=0; break; &#125; &#125; puts(flag?&quot;YES&quot;:&quot;NO&quot;); &#125; return 0;&#125; J - Course Selection System ZOJ - 3956 ÂÇªÈÄºÈ¢ò,‰∏ÄÂºÄÂßãËøòÂú®ÊÉ≥ÊÄé‰πàÊé®ÂÖ¨ÂºèÔºåÁªìÊûúÂèëÁé∞ÔºåCIÁöÑÂíåÂè™Êúâ5e4ÔºåÊûö‰∏æÊâÄÁî®ËÉΩÂ§üÂà∞ÁöÑÁä∂ÊÄÅH ÁöÑÂíåÊúÄÂ§ß‰∏ç‰πÖË°å‰∫ÜÔºåÁõ¥Êé•ËΩ¨Êç¢Êàê‰∫Ü 0 1 ËÉåÂåÖ„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e4+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;int a[maxn];int x[maxn],y[maxn];int main() &#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]); &#125; mem(a,-1); a[0]=0; for(int i=0; i&lt;n; i++) &#123; for(int j=5e4-y[i]; j&gt;=0; j--) &#123; if(a[j]!=-1) &#123; a[j+y[i]]=max(a[j+y[i]],a[j]+x[i]); &#125; &#125; &#125; ll ans=0; for(ll i=1;i&lt;=5e4;i++)&#123; if(a[i]!=-1) ans=max(ans,1LL*a[i]*a[i]-i*a[i]-i*i); &#125; printf(&quot;%lld\n&quot;,ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCPC2018‰∏≠ÂõΩÂ§ßÂ≠¶ÁîüÁ®ãÂ∫èËÆæËÆ°Á´ûËµõ - ÁΩëÁªúÈÄâÊãîËµõ]]></title>
    <url>%2F2018%2F08%2F27%2FCCPC2018%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%20-%20%E7%BD%91%E7%BB%9C%E9%80%89%E6%8B%94%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[HDU 6438 1001 Buy and Resell Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Total Submission(s): 2282 Accepted Submission(s): 359 Problem Description The Power Cube is used as a stash of Exotic Power. There are n cities numbered 1,2,‚Ä¶,n where allowed to trade it. The trading price of the Power Cube in the i-th city is ai dollars per cube. Noswal is a foxy businessman and wants to quietly make a fortune by buying and reselling Power Cubes. To avoid being discovered by the police, Noswal will go to the i-th city and choose exactly one of the following three options on the i-th day: spend ai dollars to buy a Power Cube resell a Power Cube and get ai dollars if he has at least one Power Cube do nothing Obviously, Noswal can own more than one Power Cubes at the same time. After going to the n cities, he will go back home and stay away from the cops. He wants to know the maximum profit he can earn. In the meanwhile, to lower the risks, he wants to minimize the times of trading (include buy and sell) to get the maximum profit. Noswal is a foxy and successful businessman so you can assume that he has infinity money at the beginning. Input There are multiple test cases. The first line of input contains a positive integer T (T‚â§250), indicating the number of test cases. For each test case: The first line has an integer n. (1‚â§n‚â§105) The second line has n integers a1,a2,‚Ä¶,an where ai means the trading price (buy or sell) of the Power Cube in the i-th city. (1‚â§ai‚â§109) It is guaranteed that the sum of all n is no more than 5√ó105. Output For each case, print one line with two integers ‚Äî‚Äî the maximum profit and the minimum times of trading to get the maximum profit. Sample Input 1 3 4 1 2 10 9 5 9 5 9 10 5 2 2 1 Sample Output 1 16 4 5 2 0 0 _Hint_ In the first case, he will buy in 1, 2 and resell in 3, 4. _profit = - 1 - 2 + 10 + 9 = 16_ In the second case, he will buy in 2 and resell in 4. _profit = - 5 + 10 = 5_ In the third case, he will do nothing and earn nothing. _profit = 0_ Ë¥™ÂøÉÔºåÊØèÊ¨°‰øùÁïô‰π∞ÔºåÂíåÂçñ‰∏§ÁßçÁä∂ÊÄÅÔºåÂ¶ÇÊûú‰∏ÄÁßç‰π∞‰∫ÜÔºåËØ¥ÊòéÂêéÈù¢Êúâ‰∏ÄÂÆöÊúâÂèØ‰ª•ÂçñÁöÑÔºå‰ªéÂâçÂæÄÂêéÊâ´ÊØèÊ¨°ÂèñÂâçÈù¢ÊúÄÂ∞èÁöÑÔºåÂ¶ÇÊûúÈÅáËßÅËÉΩ‰ªéÂçñ‰∫ÜÁöÑÈáåÈù¢ÂèñÔºåÊÄªÊ¨°Êï∞‰∏çÁî®+2ÔºåÂ¶ÇÊûúÊòØ‰ªé‰π∞‰∫ÜÁöÑÈáåÈù¢ÂèñÔºåÊÄª‰∫§ÊòìÊ¨°Êï∞+2Ôºõ Áî®Ôºå0Ôºå1ÂàÜÂà´‰ª£Ë°®‰π∞ÂíåÂçñ„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int a[maxn];int n;priority_queue&lt;P&gt;q;ll sum=0,ans=0;int main() &#123; int t; cin&gt;&gt;t; while(t--) &#123; sum=0; ans=0; scanf(&quot;%d&quot;,&amp;n); while(q.size())q.pop(); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); q.push(P(-a[i],0)); q.push(P(-a[i],1)); int temp=a[i]+q.top().first; if(q.top().second==0) &#123; ans+=2; &#125; q.pop(); sum+=temp; &#125; printf(&quot;%lld %lld\n&quot;,sum,ans); &#125; return 0;&#125; HDU 6441 1004 Find Integer Êõ¥ÂÖ∑Ë¥πÈ©¨Â§ßÂÆöÁêÜÔºån&gt;2 ÂíåÁ≠â‰∫é 0ËØØËß£Ôºån=1ÔºåÁõ¥Êé•ËæìÂá∫ 1 a+1; n=2 ÁöÑÊó∂ÂÄôÔºåÂ∞±ÊòØ‰∏Ä‰∏™ÂãæËÇ°ÂÆöÁêÜÔºåa^2=cc-bb = (c-b)(c+b) Â¶ÇÊûúA‰∏∫ÂÅ∂Êï∞ c-b=2 c+b=aa/2 ,Â¶ÇÊûúa‰∏∫Â•áÊï∞ c-b=1 c+b=a*a Ëß£‰∏™ÊñπÁ®ãÂ∞±Ë°å‰∫Ü„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int main() &#123; int t; cin&gt;&gt;t; while(t--) &#123; ll n,k; scanf(&quot;%lld%lld&quot;,&amp;k,&amp;n); if(k==0||k&gt;2)puts(&quot;-1 -1&quot;); else if(k==1) &#123; if(n==1e9)puts(&quot;-1 -1&quot;); else printf(&quot;%lld %lld\n&quot;,1,n+1); &#125; else &#123; ll temp=n; if(n==1||n==2)puts(&quot;-1 -1&quot;); else if(n&amp;1) &#123; ll c=(temp*temp+1)/2; ll b=c-1; if(c&gt;1e9)puts(&quot;-1 -1&quot;); else &#123; printf(&quot;%lld %lld\n&quot;,b,c); &#125; &#125; else &#123; ll c=n*n/4+1,b=c-2; if(c&gt;1e9)puts(&quot;-1 -1&quot;); else printf(&quot;%lld %lld\n&quot;,b,c); &#125; &#125; &#125; return 0;&#125; HDU 6446 1009 Tree and Permutation Áõ¥Êé•ÁÆó‰∏ÄÊù°ËæπÂ∑¶Âè≥‰∏§ËæπÁÇπÁöÑ‰∏™Êï∞ÔºåÂÖ®ÊéíÂàóÁßçÔºåÊØèÊù°ËæπÁªèËøáÁöÑÊ¨°Êï∞Á≠â‰∫é Ôºå2C,(n-m)(m)*(n-1)ÔºÅÊ¨°Ôºå‰∏Ä‰∏™DFSÊ±ÇÂá∫‰ªñÊ†πËäÇÁÇπÁöÑÊï∞Èáè‰∏∫mÔºåÂâç‰∏ÄÊù°Ëæπ ÊùÉÂÄº‰∏∫C,Ê±Ç‰∏Ä‰∏ãÊâÄÊúâÊï∞ÁöÑÂíåÔºåÈ¢ÑÂ§ÑÁêÜÈò∂‰πò„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;struct edge &#123; int to,cost,next;&#125; eg[maxn];int head[maxn],tot;void init() &#123; mem(head,-1); tot=0;&#125;void add(int u,int v,int c) &#123; eg[tot].to=v; eg[tot].cost=c; eg[tot].next=head[u]; head[u]=tot++;&#125;ll k[maxn];ll c[maxn],num[maxn];int dfs(int r,int p,int v) &#123; c[r]=v%mod; int ans=1; for(int i=head[r]; i!=-1; i=eg[i].next) &#123; if(eg[i].to!=p) &#123; ans+=dfs(eg[i].to,r,eg[i].cost); &#125; &#125; num[r]=ans%mod; return ans;&#125;int main() &#123; k[1]=1; for(int i=2; i&lt;=1e5; i++) &#123; k[i]=k[i-1]*i%mod; &#125; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; init(); for(int i=1; i&lt;n; i++) &#123; int u,v,c; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;c); add(u,v,c); add(v,u,c); &#125; dfs(1,-1,0); ll sum=0; for(int i=2; i&lt;=n; i++) &#123; sum+=2*c[i]*num[i]%mod*(n-num[i])%mod*k[n-1]%mod; sum%=mod; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Á¨¨‰πùÂ±äÁ¶èÂª∫ÁúÅÂ§ßÂ≠¶ÁîüÁ®ãÂ∫èËÆæËÆ°Á´ûËµõ-ÈáçÁé∞ËµõÔºàÊÑüË∞¢ÊâøÂäûÊ≥âÂ∑ûÂ∏àËåÉÂ≠¶Èô¢Ôºâ]]></title>
    <url>%2F2018%2F08%2F26%2F%E7%AC%AC%E4%B9%9D%E5%B1%8A%E7%A6%8F%E5%BB%BA%E7%9C%81%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-%E9%87%8D%E7%8E%B0%E8%B5%9B%EF%BC%88%E6%84%9F%E8%B0%A2%E6%89%BF%E5%8A%9E%E6%B3%89%E5%B7%9E%E5%B8%88%E8%8C%83%E5%AD%A6%E9%99%A2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[A - Uint47 calculator FZU - 2294 Ê∞¥È¢òÔºåÁî®unsigned long long,Ëá™Â∏¶Ëá™Âä®Ê∫¢Âá∫ÔºåÁÑ∂ÂêéÂ∞±ÂèØ‰ª•Èöè‰æøÂÜô‰∫Ü„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));ull mod=1;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;string s;map&lt;string,ull&gt; mp;int main() &#123; char op[100]; string tx,ty; ull x,y; for(int i=1;i&lt;48;i++)&#123; mod*=2; &#125; while(~scanf(&quot;%s&quot;,op)) &#123; if(op[0]==&apos;d&apos;&amp;&amp;op[1]==&apos;e&apos;) &#123; //def cin&gt;&gt;s&gt;&gt;x; mp[s]=x; cout&lt;&lt;s&lt;&lt;&quot; = &quot;&lt;&lt;x&lt;&lt;&apos;\n&apos;; &#125; else if(op[0]==&apos;s&apos;) &#123; //sub cin&gt;&gt;tx&gt;&gt;ty; x=mp[tx]; y=mp[ty]; mp[tx]=x=(x-y+mod)%mod; cout&lt;&lt;tx&lt;&lt;&quot; = &quot;&lt;&lt;x&lt;&lt;&apos;\n&apos;; &#125; else if(op[0]==&apos;a&apos;) &#123; cin&gt;&gt;tx&gt;&gt;ty; x=mp[tx]; y=mp[ty]; mp[tx]=x=(x+y)%mod; cout&lt;&lt;tx&lt;&lt;&quot; = &quot;&lt;&lt;x&lt;&lt;&apos;\n&apos;; &#125; else if(op[0]==&apos;m&apos;&amp;&amp;op[1]==&apos;u&apos;) &#123; cin&gt;&gt;tx&gt;&gt;ty; x=mp[tx]; y=mp[ty]; mp[tx]=x=(x*y)%mod; cout&lt;&lt;tx&lt;&lt;&quot; = &quot;&lt;&lt;x&lt;&lt;&apos;\n&apos;; &#125; else if(op[0]==&apos;d&apos;) &#123; cin&gt;&gt;tx&gt;&gt;ty; x=mp[tx]; y=mp[ty]; mp[tx]=x=(x/y)%mod; cout&lt;&lt;tx&lt;&lt;&quot; = &quot;&lt;&lt;x&lt;&lt;&apos;\n&apos;; &#125; else &#123; cin&gt;&gt;tx&gt;&gt;ty; x=mp[tx]; y=mp[ty]; mp[tx]=x=x%y; cout&lt;&lt;tx&lt;&lt;&quot; = &quot;&lt;&lt;x&lt;&lt;&apos;\n&apos;; &#125; &#125; return 0;&#125; B - Human life FZU - 2295 ÊúÄÂ§ßÊùÉÈó≠ÂêàÂ≠êÂõæÔºåkÂè™Êúâ5Êö¥ÂäõÊûö‰∏æÊâÄÊúâÁä∂ÊÄÅ„ÄÇÁÑ∂ÂêéÂ∞±ÊòØ‰∏Ä‰∏™Ë£∏È¢ò‰∫Ü„ÄÇ Á≠îÊ°à ÊòØÊúÄÂ§ßÊ≠£ÊùÉÂÄº-ÂéªÊúÄÂ§ßÊµÅ„ÄÇÂ¶ÇÊûúÊúâ‰∫∫ÊÉ≥‰∫ÜËß£‰∏∫Âï•ÔºåËá™Ë°åÁôæÂ∫¶Âêß„ÄÇ„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e3+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int v[maxn];int pre[maxn][maxn];int u[maxn];int n,m,K;int a[2][5];int ku[maxn];vector&lt;int&gt; tv[maxn];struct edge &#123; int to,cap,rev;&#125;;vector &lt;edge&gt; G[maxn];int level[maxn];int iter[maxn];void init(int _n) &#123; for(int i=0; i&lt;=_n; i++) &#123; G[i].clear(); tv[i].clear(); &#125; mem(pre,0); mem(u,0);&#125;void init()&#123; for(int i=0;i&lt;=n+m+1;i++)G[i].clear();&#125;void bfs(int s) &#123; memset(level,-1,sizeof(level)); queue&lt;int&gt; que; level[s]=0; que.push(s); while(!que.empty()) &#123; int v= que.front(); que.pop(); for(int i=0; i&lt;G[v].size(); i++) &#123; edge &amp; e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0) &#123; level[e.to]=level[v] + 1; que.push(e.to); &#125; &#125; &#125;&#125;void add(int from,int to,int cap) &#123; edge eg; eg.to=to; eg.cap=cap; eg.rev=G[to].size(); G[from].push_back(eg); eg.to=from; eg.cap=0; eg.rev=G[from].size()-1; G[to].push_back(eg);&#125;int dfs(int v,int t,int f) &#123; if(v == t)return f; for(int &amp;i = iter[v]; i &lt; G[v].size(); i++) &#123; edge &amp;e=G[v][i]; if(e.cap&gt;0 &amp;&amp; level[v]&lt;level[e.to]) &#123; int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0) &#123; e.cap-=d; G[e.to][e.rev].cap+=d; return d; &#125; &#125; &#125; return 0;&#125;int maxflow(int s,int t) &#123; int flow=0; for(;;) &#123; bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while((f = dfs(s,t,INF))&gt;0) &#123; flow +=f; &#125; &#125;&#125;void dfs(int r) &#123; u[r]=1; for(int i=1; i&lt;=n; i++) &#123; if(pre[r][i]) &#123; if(u[i]==0) &#123; dfs(i); &#125; for(int j=1; j&lt;=n; j++) &#123; pre[r][j]|=pre[i][j]; &#125; &#125; &#125;&#125;int main() &#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;K); init(n+m+1); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;v[i]); int k; scanf(&quot;%d&quot;,&amp;k); if(k==0)u[i]=1; for(int j=0; j&lt;k; j++) &#123; int x; scanf(&quot;%d&quot;,&amp;x); pre[i][x]=1; &#125; &#125; for(int i=1; i&lt;=n; i++) &#123; if(u[i]==0) &#123; dfs(i); &#125; &#125; for(int i=n+1; i&lt;=n+m; i++) &#123; scanf(&quot;%d&quot;,&amp;v[i]); int k; bool tu[maxn]= &#123;0&#125;; scanf(&quot;%d&quot;,&amp;k); for(int j=0; j&lt;k; j++) &#123; int x; scanf(&quot;%d&quot;,&amp;x); if(tu[x])continue; tu[x]=1; for(int l=1; l&lt;=n; l++) &#123; tu[l]|=pre[x][l]; &#125; &#125; for(int j=1; j&lt;=n; j++) &#123; if(tu[j]) &#123; tv[i].push_back(j); &#125; &#125; &#125; for(int i=0; i&lt;K; i++) &#123; scanf(&quot;%d%d&quot;,&amp;a[0][i],&amp;a[1][i]); &#125; int mx=0; for(int i=0; i&lt;1&lt;&lt;K; i++) &#123; mem(ku,0); init(); for(int j=0; j&lt;K; j++) &#123; ku[a[(i&gt;&gt;j)&amp;1][j]+n]=1;// debug(a[(i&gt;&gt;j)&amp;1][j]+n); &#125; int sum=0; for(int i=n+1; i&lt;=n+m; i++) &#123; if(ku[i]==1)continue;// debug(i); add(0,i,v[i]); for(int j=0; j&lt;tv[i].size(); j++) &#123; add(i,tv[i][j],inf); &#125; sum+=v[i]; &#125; for(int i=1; i&lt;=n; i++)add(i,n+m+1,v[i]); mx=max(sum-maxflow(0,n+m+1),mx); &#125; printf(&quot;%d\n&quot;,mx); &#125; return 0;&#125; D - Number theory FZU - 2297 ‰∏ÄÂºÄÂßãËøò‰ª•‰∏∫ÊòØÂ§ßÊï∞Ôºåjava ‰∫Ü‰∏ÄÂèëÔºåÂ§ßÊï∞‰∫Ü‰∏ÄÂèëÔºåÂÖ®ÈÉΩTLEÔºåÊ≠£Ëß£Â∞±ÊòØ‰∏Ä‰∏™Á∫øÊÆµÊ†ë„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e3+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int c[maxn][maxn];int q[maxn][maxn];int b2[maxn];long long pow(long long x,long long n,long long mod=1e9+7) &#123; long long res=1; while(n&gt;0) &#123; if(n&amp;1)res=res*x%mod; x=x*x%mod; n&gt;&gt;=1; &#125; return res%mod;&#125;int main() &#123; c[1][1]=1; c[1][0]=1; for(int i=1; i&lt;1e3+1; i++) &#123; c[i+1][0]=1;// printf(&quot;%d &quot;,c[i+1][0]); for(int j=1; j&lt;=i+1; j++) &#123; c[i+1][j]=(c[i][j-1]+c[i][j])%mod;// printf(&quot;%d &quot;,c[i+1][j]); &#125; &#125; for(int i=1; i&lt;1e3+1; i++) &#123; for(int j=0; j&lt;=i; j++) &#123; q[i][j+1]=(q[i][j]+c[i][j])%mod; &#125; &#125; b2[0]=1; for(int i=1; i&lt;1e3+1; i++) &#123; b2[i]=(b2[i-1]*2)%mod; &#125; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); if(m&gt;n) &#123; puts(&quot;0&quot;); &#125; else &#123; cout&lt;&lt;(q[n][n+1]-q[n][m]+mod)%mod*pow(b2[n],mod-2,mod)%mod&lt;&lt;endl; &#125; &#125; return 0;&#125; E - Traffic jamFZU - 2298 ÊúÄÁü≠Ë∑ØÔºåÂ§ÑÁêÜ‰∏ãÂà∞Êüê‰∏™ÁÇπÁöÑÊÉÖÂÜµÔºåÂ¶ÇÊûúÊòØÁ∫¢ÁÅØÔºåÊó∂Èó¥Âèò‰∏∫Âà∞ÁªøÁÅØÂºÄÂßã„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int a[maxn];int cost[maxn];int n,m;struct edge &#123; int to,c,next;&#125; eg[maxn*2];int head[maxn],tot,vis[maxn];void init() &#123; mem(head,-1); tot=0;&#125;void add(int u,int v,int c) &#123; eg[tot].to=v; eg[tot].c=c; eg[tot].next=head[u]; head[u]=tot++;&#125;int main() &#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; init(); for(int i=0; i&lt;m; i++) &#123; int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); add(a,b,c); add(b,a,c); &#125; int st,en; scanf(&quot;%d%d&quot;,&amp;st,&amp;en); queue&lt;int&gt; q; q.push(st); mem(cost,inf); mem(vis,0); cost[st]=0; while(q.size()) &#123; int v=q.front(); q.pop(); vis[v]=0; for(int i=head[v]; i!=-1; i=eg[i].next) &#123; int d=cost[v]+eg[i].c,to=eg[i].to; if(to!=en&amp;&amp;(d/a[to])&amp;1)d=(d/a[to]+1)*a[to]; if(d&lt;cost[to]) &#123; cost[to]=d; if(vis[to]==0) &#123; vis[to]=1; q.push(to); &#125; &#125; &#125; &#125; printf(&quot;%d\n&quot;,cost[en]); &#125; return 0;&#125; G - IoU FZU - 2300 Á≠æÂà∞È¢ò 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));ull mod=1;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;string s;map&lt;string,ull&gt; mp;int T;struct node &#123; ll x,y,w,h;&#125;a[3];int main() &#123; scanf(&quot;%d&quot;, &amp;T); while (T --) &#123; scanf(&quot;%lld %lld %lld %lld&quot;, &amp;a[0].x,&amp;a[0].y,&amp;a[0].w,&amp;a[0].h); scanf(&quot;%lld %lld %lld %lld&quot;, &amp;a[1].x,&amp;a[1].y,&amp;a[1].w,&amp;a[1].h); ll wi = (min(a[0].x+a[0].w, a[1].x+a[1].w)-max(a[0].x, a[1].x)); ll hi = (min(a[0].y+a[0].h, a[1].y+a[1].h)-max(a[0].y, a[1].y)); ll un; if(wi &gt; 0 &amp;&amp; hi &gt; 0) un = wi*hi; else un = 0; //debug(un); ll sum = a[0].w*a[0].h+a[1].w*a[1].h-un; //debug(sum); printf(&quot;%.2f\n&quot;, 1.0*un/sum); &#125; return 0;&#125;/*61 1 1 11 1 2 21 1 2 11 1 1 21 1 2 22 0 1 10 3 3 32 2 2 10 3 3 32 4 5 51 1 1 1-100 -100 1 1*/ H - Chosen by god FZU - 2301 È¢òÊÑèÔºönÁÇπ‰º§ÂÆ≥ÈöèÊú∫ÂàÜÈÖçÔºåÊ±ÇÂàÜÈÖçÂà∞Êïå‰∫∫Ë∫´‰∏äÂ§ß‰∫éÁ≠â‰∫émÔºåÁöÑÊúüÊúõÔºåÂ∞±ÊòØÊ±ÇC(M,N)+‚Ä¶+C(M,N); È¢òËß£ÔºöÊâì‰∏™ÁªÑÂêàÊï∞ÁöÑË°®ÔºåÁÑ∂ÂêéÂâçÁºÄÂ§ÑÁêÜ‰∏Ä‰∏ã„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e3+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int c[maxn][maxn];int q[maxn][maxn];int b2[maxn];long long pow(long long x,long long n,long long mod=1e9+7) &#123; long long res=1; while(n&gt;0) &#123; if(n&amp;1)res=res*x%mod; x=x*x%mod; n&gt;&gt;=1; &#125; return res%mod;&#125;int main() &#123; c[1][1]=1; c[1][0]=1; for(int i=1; i&lt;1e3+1; i++) &#123; c[i+1][0]=1;// printf(&quot;%d &quot;,c[i+1][0]); for(int j=1; j&lt;=i+1; j++) &#123; c[i+1][j]=(c[i][j-1]+c[i][j])%mod;// printf(&quot;%d &quot;,c[i+1][j]); &#125; &#125; for(int i=1; i&lt;1e3+1; i++) &#123; for(int j=0; j&lt;=i; j++) &#123; q[i][j+1]=(q[i][j]+c[i][j])%mod; &#125; &#125; b2[0]=1; for(int i=1; i&lt;1e3+1; i++) &#123; b2[i]=(b2[i-1]*2)%mod; &#125; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); if(m&gt;n) &#123; puts(&quot;0&quot;); &#125; else &#123; cout&lt;&lt;(q[n][n+1]-q[n][m]+mod)%mod*pow(b2[n],mod-2,mod)%mod&lt;&lt;endl; &#125; &#125; return 0;&#125; J - Mind control FZU - 2303 È¢òÊÑèÔºön‰∏™‰∫∫Ôºåm‰∏™ËõãÁ≥ïÔºå‰Ω†ÊääËõãÁ≥ïÁªô‰∏Ä‰∏™‰∫∫Ôºå‰ªñÂêéÈù¢ÁöÑ‰∫∫‰πü‰ºöË¢´ÈÄâ‰∏äÔºå‰æãÂ¶ÇÈÄâ1 Ôºå2 3 4 5 ‚Ä¶.Á≠âÈÉΩ‰ºöË¢´ÈÄâ‰∏äÔºåÈÄâ 3 4 5 ‚Ä¶ÈÉΩ‰ºöË¢´ÈÄâ‰∏äÔºåÊ±ÇÈÄâ‰∏ä‰∫∫Êï∞ÁöÑÊúüÊúõ„ÄÇ È¢òËß£ÔºöÁªôËõãÁ≥ïÁöÑÊÄªËÇØËÉΩÊòØCÔºàM,NÔºâÔºåÈÄâÁöÑ‰∫∫ÊúÄÈ´ò‰∏∫1 ÁöÑÈÄâÊã©ÁßçÊï∞ÊòØÔºåCÔºàM-1,N-1ÔºâÔºåÈÄâ‰∏Ä‰∏™ËõãÁ≥ïÁªô1ÔºåÁÑ∂ÂêéÂÖ∂‰ªñËõãÁ≥ïÁªô‰ªñÂêéÈù¢ÁöÑ‰∫∫Ôºå‰ª•Ê≠§Á±ªÊé®ÔºåÊúÄÈ´ò‰∏∫2 ÈÄâÊã©ÁßçÊï∞ÊòØ ,C(M-1,N-2)ÔºåÊúÄÈ´ò‰∏∫3 ÂèØËÉΩÊòØ CÔºàm-1,N-3Ôºâ; ÁÑ∂ÂêéÊùÉÂÄº‰πò‰ª•Ê¶ÇÁéáÂ∞±ÊòØÊúüÊúõ ÔºåNC(M-1,N-1)+(N-1)C(M-1,N-2)+‚Ä¶.+M*C(M-1,M-1)/C(M,N)Ôºõ ÁúãÂà∞ÊùÉÂÄºÊòØ N,N-1ËÇØÂÆöË¶ÅÂåñËøõÁªÑÂêàÊï∞ ÔºåÂ§ßÁ≠îÊ°àm/m, Â∞±ÂèØ‰ª•ÂåñÊàêMC(M,N)+M(M,N-1)+‚Ä¶..+MC(M,M)/C(M,N)Ôºõ Âú®ÂåñÁÆÄ MC(M+1,N+1)/C(M,N)ÊúÄÂêéÂåñ‰∏∫M(N+1)/(M+1)Ôºõ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;long long pow(long long x,long long n,long long mod=1e9+7) &#123; long long res=1; while(n&gt;0) &#123; if(n&amp;1)res=res*x%mod; x=x*x%mod; n&gt;&gt;=1; &#125; return res%mod;&#125;void read(ll &amp;sum) &#123; sum=0; int flag=0; char ch=getchar(); while(!(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)) &#123; if (ch == &apos;-&apos;) &#123; flag = 1; &#125; ch=getchar(); &#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)sum=sum*10+ch-48,ch=getchar(); if(flag)sum*=-1;&#125;int main() &#123; ll t; read(t); while(t--) &#123; ll n,m; read(n); read(m); cout&lt;&lt;m*(n+1)%mod*pow(m+1,mod-2,mod)%mod&lt;&lt;&quot;\n&quot;; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016CCPC‰∏úÂåóÂú∞Âå∫Â§ßÂ≠¶ÁîüÁ®ãÂ∫èËÆæËÆ°Á´ûËµõ - ÈáçÁé∞Ëµõ]]></title>
    <url>%2F2018%2F08%2F23%2F2016CCPC%E4%B8%9C%E5%8C%97%E5%9C%B0%E5%8C%BA%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%20-%20%E9%87%8D%E7%8E%B0%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[A È¢òÁõÆËøûÊé•ÔºöHDU 5922 Minimum‚Äôs Revenge Ê∞¥È¢òÔºåÊØèÊ¨°ËøûÊé•‰∏ä1Â∞±Ë°åÔºåÂ∞±ÊòØ‰∏Ä‰∏™Á≠âÂ∑ÆÊï∞Âàó„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int main() &#123; int n,t,cas=1; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d&quot;,&amp;n); ll res=n; printf(&quot;Case #%d: %lld\n&quot;,cas++,(res+2)*(res-1)/2); &#125; return 0;&#125; B È¢òÁõÆÈìæÊé•ÔºöHDU 5923 Prediction È¢òÊÑèÔºö‰∏ÄÊ£µÊ†ëÔºåÊØè‰∏™ÁÇπ‰ª£Ë°®‰∏ÄÊù°ËæπÔºåÊØèÊ¨°ÈÄâÊã©Âá†‰∏™ÁÇπÔºåÈúÄË¶ÅÊää‰ªñÁöÑÁ•ñÂÖà‰πüÈÄâ‰∏äÔºåÁÑ∂ÂêéÊääÂõæÈáåÈù¢Áõ∏Â∫îÁöÑËæπËøûÊé•‰∏äÔºåÈóÆËøûÊé•ÂêéÁöÑÂõæÊúâÂ§öÂ∞ë‰∏™ËÅîÈÄöÂùó„ÄÇ È¢òËß£ÔºöÂèØÊåÅÁª≠ÂåñÂπ∂Êü•ÈõÜÔºåÊØè‰∏™È°∂ÁÇπÂºÄ‰∏Ä‰∏™Âπ∂Êü•ÈõÜÔºåÁª¥Êä§‰ªéÊ†πËäÇÁÇπÂà∞ÂΩìÂâçËäÇÁÇπÂ∑≤ÁªèËøûÊé•ÁöÑÂõæÔºåÂÜçÊääËá™Â∑±ËøôÊù°ËæπËøû‰∏ä„ÄÇ Êü•ËØ¢ÔºåÊääÊâÄÊúâÁÇπÁöÑÂπ∂Êü•ÈõÜÂêàÂπ∂‰∏Ä‰∏ãÂ∞±ÂèØ‰ª•ÔºåÁÑ∂ÂêéËæìÂá∫ÂêàÂπ∂ÂêéÂπ∂Êü•ÈõÜÂùóÁöÑ‰∏™Êï∞„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 #include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=5e2+2;const int maxm=1e4+5;bool u[maxm];int par[maxm][maxn];struct node &#123; int x,y; int fa;&#125; tree[maxm];int n,m;int find(int y,int x) &#123; return par[y][x]==x?x:par[y][x]=find(y,par[y][x]);&#125;void dfs(int x) &#123; int fa=tree[x].fa; u[x]=1; if(u[fa]==0) &#123; dfs(fa); &#125; else &#123; if(x==1) &#123;// cout&lt;&lt;&quot;1asd&quot;&lt;&lt;endl; for(int i=0; i&lt;=n; i++)par[1][i]=i; par[1][tree[x].x]=tree[x].y; &#125; else &#123; for(int i=0; i&lt;=n; i++)par[x][i]=par[fa][i]; int X=find(x,tree[x].x),Y=find(x,tree[x].y); if(X!=Y) &#123; par[x][X]=par[x][Y]; &#125; &#125; &#125;&#125;int main() &#123; int t,cas=1; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=m; i++) &#123; if(i==1)tree[i].fa=1; else &#123; int x; scanf(&quot;%d&quot;,&amp;x); tree[i].fa=x; &#125; &#125; for(int i=1; i&lt;=m; i++) &#123; u[i]=0; scanf(&quot;%d%d&quot;,&amp;tree[i].x,&amp;tree[i].y); &#125; for(int i=1; i&lt;=m; i++) &#123; if(!u[i]) &#123; dfs(i); &#125; &#125; int q; scanf(&quot;%d&quot;,&amp;q); printf(&quot;Case #%d:\n&quot;,cas++); while(q--) &#123; int k,s; scanf(&quot;%d&quot;,&amp;k); int res=0; for(int i=0; i&lt;=n; i++)par[0][i]=i; while(k--) &#123; scanf(&quot;%d&quot;,&amp;s);// for(int i=1; i&lt;=n; i++)printf(&quot;%d &quot;,par[s][i]); for(int i=1; i&lt;=n; i++) &#123; int t1=find(0,i),t2=find(s,i); if(t1!=t2) &#123; int t3=find(0,t2); if(t3!=t1) &#123; res++; par[0][t1]=par[0][t3]; &#125; &#125; &#125; &#125; printf(&quot;%d\n&quot;,n-res); &#125; &#125; return 0;&#125; C È¢òÁõÆËøûÊé•ÔºöHUD 5924 Mr. Frog‚Äôs Problem A/B+ B/A Âè™ÊúâÂú®‰∏§‰∏™Êï∞ÊúÄÊé•ËøëÁöÑÊó∂ÂÄôÊúÄÂ∞èÔºåÊâÄ‰ª•Â¶ÇÊûúA&lt;=C&lt;D&lt;=B,C /D+D/CÂøÖÂÆöÂ∞è‰∫é‰∫éÁ≠â A/B+B/AÊâÄ‰ª•Âè™ÊúâÂíåA BÁõ∏ÂêåÁöÑÊó∂ÂÄôÊâç‰ºöÊª°Ë∂≥Êù°‰ª∂„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;ll a,b,t,n;int main() &#123; int cas=1; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;a&gt;&gt;b; printf(&quot;Case #%d:\n&quot;,cas++); if(a==b) &#123; puts(&quot;1&quot;); cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl; &#125; else &#123; puts(&quot;2&quot;); cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl; cout&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;a&lt;&lt;endl; &#125; &#125; return 0;&#125; D È¢òÁõÆËøûÊé•:HDU 5925 Coconuts È¢òÊÑèÔºöÁªô‰Ω†‰∏Ä‰∏™R*CÁöÑÁü©Èòµ‰∏≠Èó¥ÊúâÂá†‰∏™n‰∏™ÁÇπÔºåÈóÆÂàÜÊàê‰∫ÜÂá†‰∏™ËÅîÈÄöÂùóÔºåËÅîÈÄöÂùóÁöÑÂ§ßÂ∞èÊòØÂ§öÂ∞ë„ÄÇ È¢òËß£ÔºöRÔºåCËåÉÂõ¥ÊòØ1e9ËÇØÂÆöÊòØË¶ÅÁ¶ªÊï£ÔºåÁ¶ªÊï£‰πãÂêéÂèòÊàê‰∫Ü‰∏Ä‰∏™‰∏çÂà∞ 2000*2000ÁöÑÁü©ÈòµÔºåÊ±ÇËÅîÈÄöÂùóÊï∞ÈáèÁõ¥Êé•DFS‰∏ÄÈÅçÂ∞±ÂèØ‰ª•‰∫Ü„ÄÇ ÈóÆÈ¢òÊù•‰∫Ü‰∫ÜÔºåÁ¶ªÊï£‰πãÂêéÊÄé‰πàÊ±ÇÊØè‰∏™ÂùóÁöÑÂ§ßÂ∞èÂë¢„ÄÇ È¶ñÂÖà‰Ω†ÊòØÊ†πÊçÆË°åÂíåÂàóÂàÜÂà´Á¶ªÊï£ÔºåËÆ°ÁÆó‰∏ªË¶ÅÊòØÊääÁ¶ªÊï£ÊéâÁöÑÈáçÊñ∞ÁÆóÂõûÊù•„ÄÇ Â¶Ç‰∏ãÂõæÂä†ÂÖ•ÈªÑËâ≤ÊòØ‰Ω†Ë¢´Ë¶ÜÁõñÁöÑÊ†ºÂ≠êÔºå‰Ω†‰ºöÊääÊ®™ÁùÄÁ¶ªÊï£ÈªëËâ≤ÁöÑÊ†ºÂ≠ê‰∏∫‰∏Ä‰∏™Ê†ºÂ≠êÔºåÁ∫¢Ëâ≤ÁöÑÁ´ñÁùÄÁ¶ªÊï£Êàê‰∏Ä‰∏™Ê†ºÂ≠ê„ÄÇÂõ†Ê≠§Ôºå‰Ω†Âè™Ë¶ÅÊääËøô‰∫õÁ¶ªÊï£ÁöÑÊ†ºÂ≠ê‰ªéÊñ∞Âä†ÂõûÊù•Â∞±Ë°å‰∫ÜÔºåÂè¶Â§ñËøòË¶ÅÂä†‰∏ä‰∏≠Èó¥ÈÇ£‰∏ÄÂùóË¢´Á¶ªÊï£ÊéâÁöÑ„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=205;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;map&lt;int,int&gt; mpx,mpy;int x[maxn],y[maxn];int lx[maxn],ly[maxn];ll vx[maxn*10],vy[maxn*10];int mp[maxn*10][maxn*10],mx,my;int dx[]= &#123;-1,0,1,0&#125;,dy[]= &#123;0,-1,0,1&#125;;ll ans[maxn*10];void dfs(int tx,int ty,int pos) &#123; if(mp[tx][ty]!=0)return ; mp[tx][ty]=pos; ++ans[pos]; for(int i=0; i&lt;4; i++) &#123; int ttx=tx+dx[i],tty=ty+dy[i]; if(ttx&gt;0&amp;&amp;ttx&lt;=mx&amp;&amp;tty&gt;0&amp;&amp;tty&lt;=my) &#123; dfs(ttx,tty,pos); &#125; &#125;&#125;int main() &#123; int cas=1,t;// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); scanf(&quot;%d&quot;, &amp;t); while(t--) &#123; mpx.clear(); mpy.clear(); mem(ans,0); int r,c; scanf(&quot;%d%d&quot;,&amp;r,&amp;c); scanf(&quot;%d&quot;,&amp;n); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]); lx[i]=x[i]; ly[i]=y[i]; &#125; lx[n]=r; sort(lx,lx+n+1); int d=0; vx[d]=0; for(int i=0; i&lt;=n; i++) &#123; if(lx[i]==vx[d])continue; else if(lx[i]==vx[d]+1) &#123; vx[d+1]=vx[d]+1; mpx[lx[i]]=d+1; d+=1; &#125; else if(lx[i]-d==2) &#123; vx[d+1]=vx[d]+1; vx[d+2]=vx[d]+2; mpx[lx[i]]=d+2; d+=2; &#125; else &#123; vx[d+1]=vx[d]+1; vx[d+2]=lx[i]; mpx[lx[i]]=d+2; d+=2; &#125; &#125; ly[n]=c; sort(ly,ly+n+1); mx=d; d=0; vy[d]=0; for(int i=0; i&lt;=n; i++) &#123; if(ly[i]==vy[d])continue; else if(ly[i]==vy[d]+1) &#123; vy[d+1]=vy[d]+1; mpy[ly[i]]=d+1; d+=1; &#125; else if(ly[i]-d&gt;=2) &#123; vy[d+1]=vy[d]+1; vy[d+2]=ly[i]; mpy[ly[i]]=d+2; d+=2; &#125; &#125; my=d; mem(mp,0); for(int i=0; i&lt;n; i++) &#123; mp[mpx[x[i]]][mpy[y[i]]]=-1; &#125; int num=1; for(int i=1; i&lt;=mx; i++) &#123; for(int j=1; j&lt;=my; j++) &#123; if(mp[i][j]==0) &#123; dfs(i,j,num++); &#125; &#125; &#125; for(int j=1; j&lt;=my; j++) &#123; //ÊääÁ¶ªÊï£Á´ñÁùÄÁöÑÂä†Ëµ∑Êù• for(int i=1; i&lt;=mx; i++) &#123; if(mp[i][j]!=-1) &#123; ans[mp[i][j]]+=vx[i]-vx[i-1]-1; &#125; else if(mp[i-1][j]!=-1) &#123; ans[mp[i-1][j]]+=vx[i]-vx[i-1]-1; &#125; &#125; &#125; for(int i=1; i&lt;=mx; i++) &#123; //ÊääÊ®™ÁùÄÁ¶ªÊï£ÊéâÁöÑÂä†Ëµ∑Êù• for(int j=1; j&lt;=my; j++) &#123; if(mp[i][j]!=-1) &#123; ans[mp[i][j]]+=vy[j]-vy[j-1]-1; &#125; else if(mp[i][j-1]!=-1) &#123; ans[mp[i][j-1]]+=vy[j]-vy[j-1]-1; &#125; &#125; &#125; for(int i=1; i&lt;=mx; i++) &#123; //Êää‰∏≠Èó¥ÈÇ£ÂùóÁ¶ªÊï£ÊéâÁöÑÂä†Ëµ∑Êù• for(int j=1; j&lt;=my; j++) &#123; if(mp[i][j]!=-1) &#123; ans[mp[i][j]]+=(vy[j]-vy[j-1]-1)*(vx[i]-vx[i-1]-1); &#125; else if(mp[i-1][j-1]!=-1) &#123; ans[mp[i-1][j-1]]+=(vy[j]-vy[j-1]-1)*(vx[i]-vx[i-1]-1); &#125; &#125; &#125; printf(&quot;Case #%d:\n%d\n&quot;,cas++,num-1); sort(ans+1,ans+num); for(int i=1; i&lt;num; i++) &#123; printf(&quot;%lld&quot;,ans[i]); if(i+1==num)printf(&quot;\n&quot;); else printf(&quot; &quot;); &#125; &#125; return 0;&#125;‰∏ãÈù¢ÊòØ2ÁªÑÊï∞ÊçÆÔºåÊ≠£Á°ÆÁ≠îÊ°àËÉΩÊâãÁÆóÂá∫Êù•/*2100 100201 501 511 551 602 502 542 562 603 503 513 553 604 514 524 534 544 564 574 584 59100 10081 22 1100 9999 10099 1100 21 992 100*/ E:È¢òÁõÆÈìæÊé• HDU 5926 Mr. Frog‚Äôs Game Ê∞¥È¢ò‰∏çËß£Èáä‰∫Ü„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int ar[35][35];int n,m;int dir[4][2]=&#123;1,0,0,1,-1,0,0,-1&#125;;int main() &#123; int cas=1,t; scanf(&quot;%d&quot;, &amp;t); while(t--) &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=0;i&lt;n;++i)&#123; for(int j = 0; j &lt; m; ++j)&#123; scanf(&quot;%d&quot;, &amp;ar[i][j]); &#125; &#125; int flag = 0; for(int i=0;i&lt;n;++i)&#123; for(int j=0;j&lt;m;++j)&#123; for(int k=0;k&lt;4;++k)&#123; int px = i + dir[k][0],py = j + dir[k][1]; if(px&lt;0||py&lt;0||px&gt;=n||py&gt;=m)continue; if(ar[px][py]==ar[i][j])&#123; flag=1;break; &#125; &#125; if(flag)break; &#125; if(flag)break; &#125; for(int i=0;i&lt;n;++i)&#123; for(int j=i+1;j&lt;n;++j)&#123; if(ar[i][0]==ar[j][0]||ar[i][m-1]==ar[j][m-1])&#123; flag=1;break; &#125; &#125; if(flag)break; &#125; for(int i=0;i&lt;m;++i)&#123; for(int j=i+1;j&lt;m;++j)&#123; if(ar[0][i]==ar[0][j]||ar[n-1][i]==ar[n-1][j])&#123; flag=1;break; &#125; &#125; if(flag)break; &#125; printf(&quot;Case #%d: &quot;,cas++); if(flag)printf(&quot;Yes\n&quot;); else printf(&quot;No\n&quot;); &#125; return 0;&#125; F È¢òÁõÆÈìæÊé•ÔºöHDU 5927 Auxiliary Set È¢òÊÑèÔºöÈöè‰æøÈÄâÂá†‰∏™ÁÇπ‰Ωú‰∏∫‰∏çÈáçË¶ÅÁöÑÁÇπÔºåÂÖ∂‰ªñÁöÑÂÖ®ÊòØÈáçË¶ÅÁöÑÁÇπÔºåÁÑ∂ÂêéÊää‰∏çÈáçË¶ÅÁöÑÁÇπ‰∏≠Â¶ÇÊûúÊòØ‰∏§‰∏™‰∏çÂêåËäÇÁÇπÁöÑÊúÄËøëÂÖ¨ÂÖ±Á•ñÂÖàÂ∞±Êää‰ªñÂèò‰∏∫ÈáçË¶ÅÁöÑÁÇπÔºåÈóÆÔºåÈÄâ‰∫ÜÂá†‰∏™‰∏çÈáçË¶ÅÁöÑÁÇπÔºåÊúÄÂêéÈáçË¶ÅÁöÑÁÇπÊÄªÂÖ±ÊúâÂ§öÂ∞ë‰∏™„ÄÇ È¢òËß£ÔºöÊï∞ÊçÆÁúãÁöÑÊå∫Âêì‰∫∫ÁöÑ 1e3 ÁªÑ 1e5ÁöÑÊï∞ÊçÆÈÇ£ÂëΩÂéªÂÜôÂïäÔºåÂÆûÈôÖ‰∏äÊ≤°Â§öÂ∞ë„ÄÇ„ÄÇ„ÄÇ„ÄÇ„ÄÇÁõ¥Êé•Êåâ‰∏çÈáçË¶ÅÁöÑÁÇπÊ∑±Â∫¶Êéí‰∏™Â∫èÔºåÂ¶ÇÊûúÊòØÂè¶Â§ñ‰∏§‰∏™ÈáçË¶ÅÁöÑÁÇπÁöÑLCAÂ∞±ÂèòÊàêÈáçË¶ÅÁöÑÁÇπ„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,m;struct edge &#123; int to,next;&#125; eg[maxn*2];int head[maxn],tot;void init() &#123; mem(head,-1); tot=0;&#125;void add(int u,int v) &#123; eg[tot].to=v; eg[tot].next=head[u]; head[u]=tot++;&#125;int dep[maxn],pre[maxn];int u[maxn];int res[maxn];int num[maxn];int dfs(int r,int p,int d) &#123; dep[r]=d; pre[r]=p; int ans=0; for(int i=head[r]; i!=-1; i=eg[i].next) &#123; if(eg[i].to!=p) &#123; ans+=dfs(eg[i].to,r,d+1); &#125; &#125; num[r]=ans; return ans;&#125;void read(int &amp;sum) &#123; scanf(&quot;%d&quot;,&amp;sum); return ; sum=0; int flag=0; char ch=getchar(); while(!(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)) &#123; if (ch == &apos;-&apos;) &#123; flag = 1; &#125; ch=getchar(); &#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)sum=sum*10+ch-48,ch=getchar(); if(flag)sum*=-1;&#125;bool cmp(int &amp;a,int &amp;b) &#123; return dep[a]&gt;dep[b];&#125;int main() &#123; int t,cas=1; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; read(n); read(m); init(); for(int i=0; i&lt;n-1; i++) &#123; int a,b; read(a); read(b); add(a,b); add(b,a); &#125; dfs(1,-1,1); printf(&quot;Case #%d:\n&quot;,cas++); while(m--) &#123; int k,d,ans=0; read(k); ans=n-k; for(int i=0; i&lt;k; i++) &#123; read(res[i]); u[res[i]]=-1; &#125; sort(res,res+k,cmp); for(int i=0; i&lt;k; i++) &#123; d=0; for(int j=head[res[i]]; j!=-1; j=eg[j].next) &#123; int to=eg[j].to; if(to==pre[res[i]]) &#123; continue; &#125; else &#123; if(u[to]&lt;0) &#123; continue; &#125; if(u[res[i]]==-1) &#123; u[res[i]]=1; &#125; else u[res[i]]++; if(u[res[i]]==2) &#123; ans++; break; &#125; &#125; &#125; &#125; for(int i=0; i&lt;k; i++)u[res[i]]=0; printf(&quot;%d\n&quot;,ans); &#125; &#125; return 0;&#125; H È¢òÁõÆËøûÊé•ÔºöHDU 5929 Basic Data Structure ÁÆÄÂçïÊ®°Êãü‰∏Ä‰∏ãÂ∞±ÂèØ‰ª•‰∫ÜÔºåËÆ∞ÂΩï‰∏ã‰∏ÄÊúÄÂêé‰∏Ä‰∏™Èõ∂ÁöÑ‰ΩçÁΩÆÔºåÂõ†‰∏∫Âà∞Èõ∂Èô§‰∫ÜÊòØÁ¨¨‰∏Ä‰∏™‰ΩçÁΩÆ‰πãÂ§ñÂÖ®ÈÉΩÂøÖÂÆöÊòØ1. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int a[maxn];int l,r;int t,cas=1;int Q;char s[100];deque&lt;int&gt; q;int main() &#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;,&amp;Q); int x; bool b=1; l=r=2e5+5; printf(&quot;Case #%d:\n&quot;,cas++); q.clear(); while(Q--) &#123; scanf(&quot;%s&quot;,s); if(b) &#123; if(s[0]==&apos;P&apos;&amp;&amp;s[1]==&apos;U&apos;) &#123; scanf(&quot;%d&quot;,&amp;x); a[++r]=x; if(x==0)q.push_back(r); &#125; else if(s[0]==&apos;Q&apos;) &#123; if(r==l)printf(&quot;Invalid.\n&quot;); else if(r-l==1)printf(&quot;%d\n&quot;,a[r]); else &#123; if(q.size()==0) &#123; printf(&quot;%d\n&quot;,(r-l)&amp;1); &#125; else &#123; int k=q.front(); if(r==k)printf(&quot;%d\n&quot;,(k-l+1)&amp;1); else printf(&quot;%d\n&quot;,(k-l)&amp;1); &#125; &#125; &#125; else if(s[0]==&apos;R&apos;) &#123; b=0; &#125; else &#123; if(a[r]==0)q.pop_back(); --r; &#125; &#125; else &#123; if(s[0]==&apos;P&apos;&amp;&amp;s[1]==&apos;U&apos;) &#123; scanf(&quot;%d&quot;,&amp;x); a[l--]=x; if(x==0)q.push_front(l+1); &#125; else if(s[0]==&apos;Q&apos;) &#123; if(r==l)printf(&quot;Invalid.\n&quot;); else if(r-l==1)printf(&quot;%d\n&quot;,a[r]); else &#123; if(q.size()==0)printf(&quot;%d\n&quot;,(r-l)&amp;1); else &#123; int k=q.back(); if(k==l+1)printf(&quot;%d\n&quot;,(r-k)&amp;1); else printf(&quot;%d\n&quot;,(r-k+1)&amp;1); &#125; &#125; &#125; else if(s[0]==&apos;R&apos;) &#123; b=1; &#125; else &#123; if(a[l+1]==0)q.pop_front(); ++l; &#125; &#125; &#125; &#125; return 0;&#125; I -È¢òÁõÆÈìæÊé•ÔºöHDU - 5930 GCD ËøôÈ¢òÊòØÁúüÁöÑÈöæÁêÜËß£.ËøôÈ¢òË¶ÅÊòØ‰∏çÁî®Á∫øÊÆµÊ†ëÂ§ßÂÆ∂ÈÉΩ‰ºöÂÜôÂêßÔºåÈ¶ñÂÖàÊö¥Âäõ‰ªéÂâçÈù¢ÁöÑÊØè‰∏™‰ΩçÁΩÆÂà∞ÂΩìÂâç‰ΩçÁΩÆÁöÑGCD ÔºåÁÑ∂ÂêéËÆ∞ÂΩïÊØè‰∏™GCDÁöÑ‰∏™Êï∞ÔºåÊõ¥Êñ∞‰∏Ä‰∏™ÁÇπÂ∞±ÊòØÂà†Èô§‰∏Ä‰∏™ÁÇπÔºåÁÑ∂ÂêéÂÜçÂä†‰∏Ä‰∏™ÁÇπÔºåÂ∞±ÊòØÊö¥Âäõ‰ªéÂâçÈù¢ÊâÄÊúâ‰ΩçÁΩÆÂà∞ÂêéÈù¢ÊâÄÊúâ‰ΩçÁΩÆÁöÑGCDÔºåÂáèÂéªËøô‰∏™ÂÄº„ÄÇÊääÂÄºÊõ¥Êñ∞ÂÜç‰∏ÄÊ¨°ÁÆó‰ªéÂâçÈù¢ÊâÄÊúâ‰ΩçÁΩÆÂà∞ÂêéÈù¢ÊâÄÊúâ‰ΩçÁΩÆÁöÑGCDÔºåÁÑ∂ÂêéÂä†‰∏äÂéª„ÄÇ Á´üÁÑ∂‰ºöËøô‰∏™Ëøô‰∏™ÔºåËøôÈ¢òÂ∞±ÊòØÁî®Á∫øÊÆµÊ†ëÁª¥Êä§‰∏Ä‰∏ãGCDÁöÑÂÄºÔºåÔºåÔºåÂ∞±ÂÉè‰∫åÂàÜ‰∏ÄÊ†∑ÔºåÂõ†‰∏∫‰ºöÊúâÂæàÈïø‰∏ÄÊÆµÁöÑGCDÂÄºÊòØ‰∏ÄÊ†∑ÁöÑÔºåÊØèÊ¨°‰∏çÁî®‰∏Ä‰∏™‰∏™ÂéªÊâæÔºåÁõ¥Êé•ÊâæÂà∞ÂâçÈù¢GCDÊîπÂèòÁöÑ‰ΩçÁΩÆÔºåÁÑ∂ÂêéÂáèÂéª‰∏ä‰∏ÄÊ¨°GCDÊîπÂèòÁöÑ‰ΩçÁΩÆ„ÄÇ‰πüÊòØ‰∏ÄÁßçÊö¥Âäõ„ÄÇ„ÄÇ„ÄÇ‰øÆÊîπÂÖ∂ÂÆû‰πüÊòØ‰∏ÄÊ†∑ÁöÑÂ∞±ÊòØÊääÂâçÈù¢GCDÂíåÂêéÈù¢GCDÊ±Ç‰∏Ä‰∏™GCDÔºåÁÑ∂ÂêéÂâçÂêéGCD ÁöÑÊï∞ÈáèÁõ∏‰πò ÊØîÂ¶Ç 1 1 1 2 4 4 4 ÂâçÈù¢3‰∏™Êï∞ÁöÑGCDÊòØ3 ‰∏™ 1 ÂíåÂêéÈù¢3‰∏™Êï∞ ÊòØ 2 ÈÇ£‰πàGCD‰∏∫ gcd(1,2) Êï∞ÈáèÂ∞±ÊòØ 3 * 3; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int g[maxn&lt;&lt;4],c[maxn];int f[maxn&lt;&lt;4],a[maxn],aa[maxn],b[maxn],bb[maxn];int A,B,n,m;long long gcd(long long a,long long b) &#123; return b==0?a:gcd(b,a%b);&#125;void build(int l,int r,int k) &#123; if(r-l==1) &#123; g[k]=c[r]; &#125; else &#123; build(lson); build(rson); g[k]=gcd(g[chl],g[chr]); &#125;&#125;int findleft(int l,int r,int k,int u,int v) &#123; if(r&lt;=u) &#123; if(gcd(g[k],v)==v)return 0; if(l+1==r)return r; int x=findleft(rson,u,v); if(x)return x; else return findleft(lson,u,v); &#125; if(u&gt;mid) &#123; int x=findleft(rson,u,v); if(x)return x; &#125; return findleft(lson,u,v);&#125;void getleft(int x) &#123; A=0; for(int i=c[x],j=x,k; j!=0; j=k) &#123; k=findleft(0,n,0,j,i); a[A]=j-k; aa[A++]=i; if(k==0)return ; i=gcd(c[k],i); &#125; return ;&#125;int findright(int l,int r,int k,int u,int v) &#123; //Ëøô‰∏™ÊòØÁî®Á∫øÊÆµÊ†ëÂæÄÂ∑¶ÊâæGCD if(l+1&gt;=u) &#123; if(gcd(g[k],v)==v)return n+1; if(l+1==r)return r; int x = findright(lson,u,v); if(x&lt;=n)return x; else return findright(rson,u,v); &#125; if(u&lt;=mid) &#123; int x=findright(lson,u,v); if(x&lt;=n)return x; &#125; return findright(rson,u,v);&#125;void getright(int x) &#123; B=0; for(int i= c[x],j=x,k; j&lt;=n; j=k) &#123; //Ëøô‰∏™ÊòØÊö¥ÂäõXÊâÄÊúâÂ∑¶ËæπÁöÑGCD k=findright(0,n,0,j,i); b[B]=k-j; bb[B++]=i; i=gcd(c[k],i); &#125; return ;&#125;void change(int l,int r,int k,int u,int v) &#123; if (l+1==r) &#123; g[k] = v; return; &#125; if (u&lt;=mid) change(lson,u,v); else change(rson,u,v); g[k]=gcd(g[chl],g[chr]);&#125;int main() &#123; int t,cas=1; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; printf(&quot;Case #%d:\n&quot;,cas++); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; ++i)scanf(&quot;%d&quot;,&amp;c[i]); build(0,n,0); //ÂàùÂßãÂåñÁ∫øÊÆµÊ†ë memset(f,0,sizeof(f)); int ans=0; for(int i=1; i&lt;=n; i++) &#123; getleft(i); //ÂàùÂßãÂåñÂè™Ë¶ÅÊâæÊâÄÊúâiÂ∑¶ËæπÁöÑGCDÊàñËÄÖÂè≥Ëæπ‰πüÂèØ‰ª•Ôºå‰ΩÜÊòØÂè™ËÉΩÊâæ‰∏ÄËæπ‰∏çÁÑ∂‰ºöÈáçÂ§ç„ÄÇ for(int j=0; j&lt;A; j++) &#123; if(!f[aa[j]])ans++; f[aa[j]]+=a[j]; &#125; &#125; while(m--) &#123; int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); getleft(x); //ÊâæÂà∞ÊâÄÊúâÂ∑¶ËæπÁöÑGCD getright(x); //ÊâæÂà∞ÊâÄÊúâÂè≥ËæπÁöÑGCD for(int j=0; j&lt;A; j++) &#123;//Êö¥ÂäõÊâÄÊúâÂ∑¶Âè≥‰∏§ËæπGCDÊâÄÊúâÂèØËÉΩ for(int k=0; k&lt;B; k++) &#123; int t=gcd(aa[j],bb[k]); //Â∑¶Âè≥‰∏§ËæπÁöÑGCDÁöÑGCD f[t]-=1LL *a[j]*b[k]; // Êö¥ÂäõÂà†Èô§ if(!f[t])ans--; &#125; &#125; c[x]=y; change(0,n,0,x,y); getleft(x); getright(x); for(int j=0; j&lt;A; j++) &#123; for(int k=0; k&lt;B; k++) &#123; int t=gcd(aa[j],bb[k]);//Êö¥ÂäõÊ∑ªÂä† if(!f[t])ans++; f[t]+=1LL*a[j]*b[k]; &#125; &#125; printf(&quot;%d\n&quot;,ans); // ÂæóÂá∫ÁªìËÆ∫ &#125; &#125; return 0;&#125; J È¢òÁõÆÈìæÊé•ÔºöHDU5931 - Mission Possible Êö¥ÂäõÊâÄÊúâÈÄüÂ∫¶ÔºåÊé®‰∏Ä‰∏ãÂÖ¨ÂºèÔºåÂèëÁé∞Ë¶Å‰πàÊòØÁî®ÂàùÂßãË°ÄÈáèÂéªÊéâ‰∏çÂä†Ë°ÄÔºåË¶Å‰πàÊòØÂä†Ë°ÄÁ≠â‰∫éÊéâË°ÄÊï∞ÈáèÁöÑÊó∂ÂÄôÊòØÊúÄ‰ºòËß£„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=5e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;ll D,A,GA,GB,GC;int main() &#123; int t,cas=1; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%lld%lld%lld%lld%lld&quot;,&amp;D,&amp;A,&amp;GA,&amp;GB,&amp;GC); ll v,r,h; ll ans=1e18,temp; for(v=1; v&lt;=D; v++) &#123; double t=1.0*D/v; temp=v*GB+A*GC+A*GA; ans=min(ans,temp); double tem2=t*A; temp=v*GB+floor(t*A-eps+1)*GA;// debug(temp-v*GB); ans=min(ans,temp); &#125; printf(&quot;Case #%d: %lld\n&quot;,cas++,ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Á¨¨ÂÖ´Â±äÁ¶èÂª∫ÁúÅÂ§ßÂ≠¶ÁîüÁ®ãÂ∫èËÆæËÆ°Á´ûËµõ-FZU 2280 HASHÂ§ÑÁêÜ+Êö¥ÂäõÊêúÁ¥¢]]></title>
    <url>%2F2018%2F08%2F21%2F%E7%AC%AC%E5%85%AB%E5%B1%8A%E7%A6%8F%E5%BB%BA%E7%9C%81%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-FZU%202280%20HASH%E5%A4%84%E7%90%86%2B%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÔºöProblem 2280 Magic Problem Description Kim is a magician, he can use n kinds of magic, number from 1 to n. We use string Si to describe magic i. Magic Si will make Wi points of damage. Note that Wi may change over time. Kim obey the following rules to use magic: Each turn, he picks out one magic, suppose that is magic Sk, then Kim will use all the magic i satisfying the following condition: Wi&lt;=Wk Sk is a suffix of Si. Now Kim wondering how many magic will he use each turn. Note that all the strings are considered as a suffix of itself. Input First line the number of test case T. (T&lt;=6) For each case, first line an integer n (1&lt;=n&lt;=1000) stand for the number of magic. Next n lines, each line a string Si (Length of Si&lt;=1000) and an integer Wi (1&lt;=Wi&lt;=1000), stand for magic i and it‚Äôs damage Wi. Next line an integer Q (1&lt;=Q&lt;=80000), stand for there are Q operations. There are two kinds of operation. ‚Äú1 x y‚Äù means Wx is changed to y. ‚Äú2 x‚Äù means Kim has picked out magic x, and you should tell him how many magic he will use in this turn. Note that different Si can be the same. Output For each query, output the answer. Sample Input 1 5 abracadabra 2 adbra 1 bra 3 abr 3 br 2 5 2 3 2 5 1 2 5 2 3 2 2 Sample Output 3 1 2 1 Source Á¨¨ÂÖ´Â±äÁ¶èÂª∫ÁúÅÂ§ßÂ≠¶ÁîüÁ®ãÂ∫èËÆæËÆ°Á´ûËµõ-ÈáçÁé∞ËµõÔºàÊÑüË∞¢ÊâøÂäûÊñπÂé¶Èó®ÁêÜÂ∑•Â≠¶Èô¢Ôºâ È¢òÁõÆÔºöÁªô‰Ω†n‰∏™Â≠óÁ¨¶‰∏≤‰ª•ÂèäÊùÉÂÄºÔºå‰∏§ÁßçÊìç‰Ωú ‰∏ÄÁßç Êõ¥Êñ∞Â≠óÁ¨¶‰∏≤ÂØπÂ∫îÁöÑÊùÉÂÄº ÔºåÊü•ËØ¢ ËæìÂá∫ÊâÄÊúâ‰ª•ÂΩìÂâçÂ≠óÁ¨¶‰∏≤‰∏∫ÂêéÁºÄ‰∏îÂØπÂ∫îÊùÉÂÄºÂ∞è‰∫éÂΩìÂâçÂ≠óÁ¨¶‰∏≤ÊùÉÂÄºÁöÑ‰∏™Êï∞„ÄÇ È¢òËß£ÔºöÈ¶ñÂÖàhash È¢ÑÂ§ÑÁêÜÊâÄÊúâËÉΩ‰æõ‰ª•ÂΩìÂâçÂ≠óÁ¨¶‰∏≤‰∏∫ÂêéÁºÄÁöÑÂ≠óÁ¨¶‰∏≤ÔºåÁõ¥Êé•n^2Êö¥ÂäõÂ∞±Ë°å„ÄÇ„ÄÇ„ÄÇ ÁÑ∂ÂêéÊü•ËØ¢Áõ¥Êé•Êö¥ÂäõÊêúÁ¥¢Â∞è‰∫éÂΩìÂâçÂ≠óÁ¨¶‰∏≤ÊùÉÂÄºÁöÑ„ÄÇ Êï∞ÊçÆÂè™Êúâ1000 ÁöÑËåÉÂõ¥Èöè‰æøÊö¥ÂäõÂïä„ÄÇ„ÄÇ„ÄÇ„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e3+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;const int seed=131;ull Hash[maxn][maxn];ull po[maxn];char ch[maxn][maxn];int t,n;int len[maxn];bool mp[maxn][maxn];int val[maxn];void init() &#123; mem(mp,0); po[0]=1; for(int i=1; i&lt;1002; i++) &#123; po[i]=po[i-1]*seed; &#125; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=len[i]; j++) &#123; Hash[i][j]=Hash[i][j-1]*seed+ch[i][j]; &#125; &#125; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=n; j++) &#123; if(len[j]&lt;len[i])continue; else &#123; int l=len[j]-len[i]; if(Hash[j][len[j]]-Hash[j][l]*po[len[i]]==Hash[i][len[i]]) &#123; mp[i][j]=1; &#125; &#125; &#125; &#125;&#125;void read(int &amp;sum) &#123; sum=0; int flag=0; char ch=getchar(); while(!(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)) &#123; if (ch == &apos;-&apos;) &#123; flag = 1; &#125; ch=getchar(); &#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)sum=sum*10+ch-48,ch=getchar(); if(flag)sum*=-1;&#125;int main() &#123; read(t); while(t--) &#123; read(n); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%s%d&quot;,ch[i]+1,&amp;val[i]); len[i]=strlen(ch[i]+1); &#125; init(); int q; read(q); while(q--) &#123; int op; read(op); int x,y; if(op==1) &#123; read(x); read(y); val[x]=y; &#125; else &#123; read(x); int ans=0; for(int i=1;i&lt;=n;i++)if(mp[x][i]&amp;&amp;val[x]&gt;=val[i])ans++; printf(&quot;%d\n&quot;,ans); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Á∫øÊÄßÊéíÂ∫èÁÆóÊ≥ï --- ËÆ°Êï∞ÊéíÂ∫èÔºåÂü∫Êï∞ÊéíÂ∫èÔºåÊ°∂ÊéíÂ∫è]]></title>
    <url>%2F2018%2F08%2F21%2F%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%20---%20%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%8C%E6%A1%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[ËÆ°Êï∞ÊéíÂ∫èÂ∫îÁî®: J - Jeronimo‚Äôs List Gym - 101466J http://codeforces.com/gym/101466/problem/J Á∫øÊÄßÊéíÂ∫èÁÆóÊ≥ïËÆ°Êï∞ÊéíÂ∫èÂ∫îËØ•Êå∫Â•ΩÁêÜËß£ÁöÑÔºåÊØèÊ¨°ÊääÊï∞Â≠óÂá∫Áé∞ÁöÑÊ¨°Êï∞ËÆ∞ÂΩï‰∏ãÊù•ÔºåÁÑ∂ÂêéÂÅöÊàêÂâçÁºÄÔºåÂâçÁºÄÂ∞±ÊòØÂ∞è‰∫éÁ≠â‰∫éÂΩìÂâçÊï∞ÁöÑ‰∏™Êï∞„ÄÇ ÊØîÂ¶Ç 2,3,0,3,6,2,3,5ÔºåÈ¶ñÂÖàËÆ∞ÂΩïÂá∫Áé∞Ê¨°Êï∞ 0 1 2 3 4 5 6 1 0 2 3 0 1 1 ÁÑ∂ÂêéÂØπËøô‰∏™Êï∞ÁªÑÂÅö‰∏Ä‰∏™ÂâçÁºÄ c[0] c[1] c[2] c[3] c[4] c[5] c[6] 1 1 3 6 6 7 8 Â∞±ÊòØËøôÊ†∑ ÔºåÁÑ∂ÂêéÊéíÂ∫èÁöÑÊó∂ÂÄôÂ∞± ËæìÂá∫Êï∞Â≠óÂØπÂ∫îÁöÑÂú∞Êñπ Â¶Ç a[i]= 5 ÈÇ£‰πà b[c[a[i]]]=a[i]; Êääb Êï∞ÁªÑÈáåÈù¢ 7ÁöÑ‰ΩçÁΩÆËµãÂÄº‰∏∫5.ÁÑ∂ÂêéÂ∞è‰∫éÁ≠â‰∫é5ÁöÑÊï∞Èáè-1Ôºõ 1234567891011121314151617181920212223242526272829303132 #include&lt;bits/stdc++.h&gt;using namespace std;int a[8]= &#123;2,3,0,3,6,2,3,5&#125;;int b[8];int c[7];int main() &#123; for(int i=0; i&lt;8; i++) &#123; c[a[i]]++; &#125; for(int i=1; i&lt;7; i++) &#123; //ÊääËøô‰∏™forÂÄíËøáÊù•Â∞±ÊòØ‰ªéÂ§ßÂà∞Â∞è c[i]=c[i-1]+c[i]; &#125; printf(&quot;CÊï∞ÁªÑ:\n&quot;); for(int i=0; i&lt;7; i++) &#123; printf(&quot;c[%d]\t&quot;,i); &#125; printf(&quot;\n&quot;); for(int i=0; i&lt;7; i++) &#123; printf(&quot; %d\t&quot;,c[i]); &#125; printf(&quot;\n&quot;); printf(&quot;ÊéíÂ∫èËøáÁ®ã\n&quot;); for(int i=7; i&gt;=0; i--) &#123; b[--c[a[i]]]=a[i]; for(int i=0; i&lt;7; i++) &#123; printf(&quot;%d &quot;,b[i]); &#125; printf(&quot;\n&quot;); &#125; return 0;&#125; Âü∫Êï∞ÊéíÂ∫èÔºö ÂÆûÈôÖ‰∏äÂíåËÆ°Êï∞ÊéíÂ∫èÊ≤°Âï•Â§™Â§ßÁöÑÂå∫Âà´ ÔºåËÆ°Êï∞ÊéíÂ∫èÂ¶ÇÊûúÊï∞Â§™Â§ßÔºå‰Ω† CÊï∞ÁªÑÁöÑÂ∞±Ë¶ÅÊµ™Ë¥πÈùûÂ∏∏Â§ßÁöÑÂÜÖÂ≠òÔºåÊàñËÄÖÊ†πÊú¨ÂºÄ‰∏ç‰∫ÜËøô‰πàÂ§ßÁöÑÂÜÖÂ≠ò„ÄÇ Âü∫Êï∞ÊéíÂ∫èÔºåÂ∞±ÊòØÊääÊØè‰∏™ ‰ΩçÊãÜÂàÜÂá∫Êù•ÔºåÂÆûÈôÖ‰∏äÂíåËÆ°Êï∞ÊéíÂ∫èÂ∑ÆË∑ù‰∏çÂ§ß„ÄÇ 12,13,120,33,46,52,3,25 120 12 52 13 33 3 25 46 ‰ª•ÊúÄÂêé‰∏Ä‰ΩçÈÄíÂ¢û 3 12 13 120 25 33 46 52 Âú®ÊúÄÂêé‰∏Ä‰Ωç‰∏∫ÈÄíÂ¢ûÂü∫Á°Ä‰∏äÂÄíÊï∞Á¨¨2‰ΩçÈÄíÂ¢û 3 12 13 25 33 46 52 120 ÊúÄÂêé‰ª• Á¨¨‰∏Ä‰Ωç ÈÄíÂ¢ûÔºåÂ∞±ÊòØÊéíÂ∫èÂ•ΩÁöÑ 12345678910111213141516171819202122232425262728293031323334353637383940414243 #include&lt;bits/stdc++.h&gt;using namespace std;int a[8]= &#123;12,13,120,33,46,52,3,25&#125;;int b[8];int c[10];int main() &#123; int mx=0,pos=0,cot=1; for(int i=0; i&lt;8; i++) &#123; mx=max(mx,a[i]); &#125; while(mx/cot&gt;0) &#123; memset(c,0,sizeof(c)); for(int i=0; i&lt;8; i++) &#123; c[a[i]/cot%10]++; &#125; for(int i=1; i&lt;10; i++) &#123; //ÊääËøô‰∏™forÂÄíËøáÊù•Â∞±ÊòØ‰ªéÂ§ßÂà∞Â∞è c[i]=c[i-1]+c[i]; &#125; printf(&quot;ËÆ°Êï∞Êï∞ÁªÑ:\n&quot;); for(int i=0; i&lt;10; i++) &#123; printf(&quot;c[%d]\t&quot;,i); &#125; printf(&quot;\n&quot;); for(int i=0; i&lt;10; i++) &#123; printf(&quot; %d\t&quot;,c[i]); &#125; printf(&quot;\n&quot;); printf(&quot;ÊéíÂ∫èÁ¨¨%d‰ΩçÁªìÊûú:\n&quot;,pos); for(int i=7; i&gt;=0; i--) &#123; b[--c[a[i]/cot%10]]=a[i]; &#125; for(int i=0; i&lt;8; i++) &#123; a[i]=b[i]; &#125; for(int i=0;i&lt;8;i++)&#123; printf(&quot;%d &quot;,a[i]); &#125; puts(&quot;&quot;); cot*=10; pos++; &#125; return 0;&#125; Ê°∂ÊéíÂ∫èÔºåÂÆûÈôÖ‰∏äÂíåËÆ°Êï∞ÊéíÂ∫è‰πüÂ∑Æ‰∏çÂ§öÔºå‰ΩÜÊòØÂà∞ÁõÆÂâç‰ΩçÁΩÆÊàëËøòÊ≤°Áî®Ëøá„ÄÇ ËÆ°Êï∞ÊéíÂ∫èÂ∞±Áõ∏ÂΩì‰∫é Ê°∂ÁöÑÂ§ßÂ∞è‰∏∫ 1 ÁöÑÊéíÂ∫è „ÄÇÔºàÂü∫Êï∞ÊéíÂ∫èÂÆûÈôÖ‰∏äÊúâÁÇπÁ±ª‰ºº‰∫é‰ª•10 ÁöÑÊ°∂ÈáåÈù¢Â•óÁùÄ‰∏Ä‰∏™10 ÁöÑÊ°∂Ôºâ‰∏™‰∫∫ÁêÜËß£ ÂºÄ‰∏Ä‰∏™Ê°∂ÁöÑÂ§ßÂ∞è b ÁÑ∂ÂêéÊää‰ªñ‰∏Ä‰∏™Êï∞x‰∏¢Âà∞ x/b ÈÇ£‰∏™Ê°∂ÈáåÈù¢ÂéªÔºåÁÑ∂ÂêéÊääÊØè‰∏™Ê°∂ÈáåÈù¢ÊéíÂ∫è„ÄÇÊääÊ°∂ÂàÜÊàê1‰∏çÂ∞±ÊòØËÆ°Êï∞ÊéíÂ∫è„ÄÇ„ÄÇ‰∏™‰∫∫ÁêÜËß£ ÁêÜËÆ∫‰∏äÊù•ËØ¥ÔºöÂú®ÂàÜÂ∏ÉÊ°∂ÂùáÂåÄÁöÑÊÉÖÂÜµ‰∏ãÔºåÊòØO(n+n*(2-1/n)); Êúâ‰∫õÊÉÖÂÜµ‰∏ãÂèØËÉΩÈÄÄÂåñÊàê ÊôÆÈÄöÊéíÂ∫è‰∏ÄÊ†∑ÁöÑÂ§çÊùÇÂ∫¶„ÄÇ ‰ª£Á†ÅÂ∞±‰∏çÊï≤‰∫ÜÔºåËøòÊ≤°Áî®Ëøá„ÄÇ„ÄÇ„ÄÇ„ÄÇ]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Á¨¨ÂÖ´Â±äÁ¶èÂª∫ÁúÅÂ§ßÂ≠¶ÁîüÁ®ãÂ∫èËÆæËÆ°Á´ûËµõ-FZU 2277 DFS +Á∫øÊÆµÊ†ë+ËØªÂÖ•ÊåÇ]]></title>
    <url>%2F2018%2F08%2F20%2F%E7%AC%AC%E5%85%AB%E5%B1%8A%E7%A6%8F%E5%BB%BA%E7%9C%81%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-FZU%202277%20%20DFS%20%2B%E7%BA%BF%E6%AE%B5%E6%A0%91%2B%E8%AF%BB%E5%85%A5%E6%8C%82%2F</url>
    <content type="text"><![CDATA[FZU 2277 Problem 2277 Change Accept: 245 Submit: 1186 Time Limit: 2000 mSec Memory Limit : 262144 KB Problem Description There is a rooted tree with n nodes, number from 1-n. Root‚Äôs number is 1.Each node has a value ai. Initially all the node‚Äôs value is 0. We have q operations. There are two kinds of operations. 1 v x k : a[v]+=x , a[v‚Äô]+=x-k (v‚Äô is child of v) , a[v‚Äô‚Äô]+=x-2*k (v‚Äô‚Äô is child of v‚Äô) and so on. 2 v : Output a[v] mod 1000000007(10^9 + 7). Input First line contains an integer T (1 ‚â§ T ‚â§ 3), represents there are T test cases. In each test case: The first line contains a number n. The second line contains n-1 number, p2,p3,‚Ä¶,pn . pi is the father of i. The third line contains a number q. Next q lines, each line contains an operation. (‚Äú1 v x k‚Äù or ‚Äú2 v‚Äù) 1 ‚â§ n ‚â§ 3*10^5 1 ‚â§ pi &lt; i 1 ‚â§ q ‚â§ 3*10^5 1 ‚â§ v ‚â§ n; 0 ‚â§ x &lt; 10^9 + 7; 0 ‚â§ k &lt; 10^9 + 7 Output For each operation 2, outputs the answer. Sample Input 1 3 1 1 3 1 1 2 1 2 1 2 2 Sample Output 2 1 Source È¢òÊÑèÔºöÁªô‰Ω†‰∏ÄÊ£µÊ†ë Êúâ‰∏§ÁßçÊìç‰ΩúÔºöÊü•ËØ¢ËäÇÁÇπÁöÑÂÄºÔºåÂíåÂ∞ÜÊâÄÊúâÊ†ëËäÇÁÇπÂèä‰ª•‰∏ã‰∏ãÊâÄÊúâÁöÑËäÇÁÇπ + x - (Â≠êËäÇÁÇπÊ∑±Â∫¶-ÂΩìÂâçÊ∑±Â∫¶)*k ÁöÑÂÄº È¢òËß£ÔºöÈ¶ñÂÖàËÇØÂÆöÊòØDFSÂª∫Â∫èÔºåÁÑ∂ÂêéÊ†πÊçÆdfs Â∫èÂª∫‰∏ÄÈ¢óÁ∫øÊÆµÊ†ëÔºåËøôÈ¢òÊõ¥Êñ∞Êìç‰ΩúÊòØÊõ¥Êñ∞‰∏Ä‰∏™Âå∫Èó¥ÔºåÊü•ËØ¢ÊòØÂçïÁÇπ„ÄÇ ËøôÈ¢òÂè™Ë¶ÅÁî®‰∏Ä‰∏™depÊï∞ÁªÑ‰øùÂ≠òÊØè‰∏™ËäÇÁÇπÊâÄÂåÖÂê´Âå∫Èó¥ÈáåÈù¢ÁöÑÊúÄÂ∞èÊ∑±Â∫¶ÔºåÁÑ∂ÂêéÂêë‰∏ãÊõ¥Êñ∞ÁöÑÊó∂ÂÄôÊØèÊ¨°ÊääÔºåxÔºåÂíåkÔºåÊõ¥Êñ∞‰∏ãÂéªÔºõ Êõ¥Êñ∞ÁöÑÊó∂ÂÄôÁõ¥Êé•ÊääÔºå(Â≠êËäÇÁÇπÊ∑±Â∫¶-ÂΩìÂâçÊ∑±Â∫¶)*kÁöÑÂÄºÊõ¥Êñ∞Âà∞ Ôºåx,ÈáåÈù¢„ÄÇ Êü•ËØ¢Áõ¥Êé•ËøîÂõûÂçïÁÇπÁöÑx. ËøôÈ¢ò‰∏ªË¶ÅÊòØÂç°ÂèñÊ®°ÂíåËØªÂÖ•„ÄÇ„ÄÇ„ÄÇËØªÂÖ•Áâπ‰πàÂ∞±Âø´Ë∂ÖÊó∂‰∫ÜÔºåÊúÄËÆ©ÊàëÊó†ËØ≠ÁöÑËøòÊòØË∂ÖÊó∂ÁªôÊàëËøîÂõû‰∏Ä‰∏™WAÂä†‰∏™ËØªÂÖ•ÊåÇÂ∞±Ëøá‰∫Ü„ÄÇ„ÄÇ„ÄÇ„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef ll LL;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=3e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int e[maxn],s[maxn],tdep[maxn];int cnt=0;struct node &#123; ll x,k;&#125; lazy[maxn&lt;&lt;4];int dep[maxn&lt;&lt;4];struct edge &#123; int to,next;&#125; eg[maxn];int head[maxn],tot;void add(int u,int v) &#123; eg[tot].to=v; eg[tot].next=head[u]; head[u]=tot++;&#125;void init() &#123; tot=0; cnt=0; mem(head,-1);&#125;int dfs(int r,int dp) &#123; cnt++; s[r]=cnt; tdep[cnt]=dp; for(int i=head[r]; i!=-1; i=eg[i].next) &#123; int to=eg[i].to; dfs(to,dp+1); &#125; e[r]=cnt;&#125;void build(int l,int r,int k) &#123; if(r-l==1) &#123; dep[k]=tdep[r]; lazy[k].k=0; lazy[k].x=0; &#125; else &#123; build(lson); build(rson); dep[k]=min(dep[chl],dep[chr]); lazy[k].k=0; lazy[k].x=0; &#125;&#125;void pushdown(int l,int r,int k) &#123; if(lazy[k].k==0&amp;&amp;lazy[k].x==0) return ; lazy[chl].k+=lazy[k].k; lazy[chl].k%=mod; lazy[chr].k+=lazy[k].k; lazy[chr].k%=mod; lazy[chl].x+=(lazy[k].x-lazy[k].k%mod*(dep[chl]-dep[k])+mod)%mod; lazy[chl].x=(lazy[chl].x+mod)%mod; lazy[chr].x+=(lazy[k].x-lazy[k].k%mod*(dep[chr]-dep[k])+mod)%mod; lazy[chr].x=(lazy[chr].x+mod)%mod; lazy[k].x=0; lazy[k].k=0;&#125;void update(int a,int b,int l,int r,int k,ll x,ll y,ll dp) &#123; if(b&lt;=l||a&gt;=r) &#123; return ; &#125; else if(a&lt;=l&amp;&amp;r&lt;=b) &#123; lazy[k].x+=(x-y*(dep[k]-dp)%mod+mod)%mod; lazy[k].x%=mod; lazy[k].k+=y; lazy[k].k%=mod; return ; &#125; else &#123; pushdown(l,r,k); update(a,b,lson,x,y,dp); update(a,b,rson,x,y,dp); &#125;&#125;ll res=0;void query(int a,int b,int l,int r,int k) &#123; if(b&lt;=l||a&gt;=r) &#123; return ; &#125; else if(a&lt;=l&amp;&amp;r&lt;=b) &#123; res=lazy[k].x%mod; return ; &#125; else &#123; pushdown(l,r,k); query(a,b,lson); query(a,b,rson); &#125;&#125;void read(LL &amp;sum) &#123; sum=0; char ch=getchar(); while(!(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;))ch=getchar(); while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)sum=sum*10+ch-48,ch=getchar();&#125;void read(int &amp;sum) &#123; sum=0; char ch=getchar(); while(!(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;))ch=getchar(); while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)sum=sum*10+ch-48,ch=getchar();&#125;int main() &#123; int n,t; read(t); while(t--) &#123; init(); scanf(&quot;%d&quot;,&amp;n); for(int i=2; i&lt;=n; i++) &#123; int x; read(x); add(x,i); &#125; dfs(1,1); build(0,n,0); int q; read(q); while(q--) &#123; int op; read(op); ll a,b,c; if(op==1) &#123; read(a); read(b); read(c); update(s[a]-1,e[a],0,n,0,b,c,tdep[s[a]]); &#125; else &#123; scan_d&lt;LL&gt;(a); query(s[a]-1,s[a],0,n,0); printf(&quot;%lld\n&quot;,(res+mod)%mod); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A - Gaby And Addition Gym - 101466A --Â≠óÂÖ∏Ê†ë ÔºåÊö¥Âäõ+Ë¥™ÂøÉ]]></title>
    <url>%2F2018%2F08%2F19%2FA%20-%20Gaby%20And%20Addition%20Gym%20-%20101466A%20--%E5%AD%97%E5%85%B8%E6%A0%91%20%EF%BC%8C%E6%9A%B4%E5%8A%9B%2B%E8%B4%AA%E5%BF%83%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• Ôºöhttp://codeforces.com/gym/101466/problem/A A. Gaby And Addition time limit per test 6.0 s memory limit per test 1024 MB input standard input output standard output Gaby is a little baby who loves playing with numbers. Recently she has learned how to add 2 numbers using the standard addition algorithm which we summarize in 3 steps: Line up the numbers vertically matching digits places. Add together the numbers that share the same place value from right to left. Carry if necessary. it means when adding two numbers we will get something like this: Unfortunately as Gaby is too young she doesn‚Äôt know what the third step means so she just omitted this step using her own standard algorithm (Gaby‚Äôs addition algorithm). When adding two numbers without carrying when necessary she gets something like the following: Gaby loves playing with numbers so she wants to practice the algorithm she has just learned (in the way she learned it) with a list of numbers adding every possible pair looking for the pair which generates the largest value and the smallest one. She needs to check if she is doing it correctly so she asks for your help to find the largest and the smallest value generated from the list of numbers using Gaby‚Äôs addition algorithm. Input The input starts with an integer _n_ (2 ‚â§ _n_ ‚â§ 106) indicating the number of integers Gaby will be playing with. The next line contains _n_numbers _ni_ (0 ‚â§ _ni_ ‚â§ 1018) separated by a single space. Output Output the smallest and the largest number you can get from adding two numbers from the list using Gaby‚Äôs addition algorithm. Examples input Copy 12 617 5 11 0 42 99 output Copy 10 99 input Copy 12 7506823119072235413 991096248449924896 204242310783332529 778958050378192979 384042493592684633 942496553147499866 410043616343857825 output Copy 152990443860776502 972190360051424498 Note In the first sample input this is how you get the minimum and the maximum value È¢òÊÑèÔºöÁªô n‰∏™Êï∞Ê±Ç‰∏çËøõ‰ΩçÂä†Ê≥ïÔºå‰∏§‰∏™Êï∞ÂíåÁöÑÊúÄÂ§ßÂÄºÔºåÊúÄÂ∞èÂÄº„ÄÇ È¢òËß£ÔºöÂàÜÂà´ÂØπÊØè‰∏™Êï∞Â≠óÊãÜÂàÜÊàê 18‰∏™‰ΩçÔºåÊØè‰∏™‰ΩçÊòØ 0-9 ÁöÑÊï∞Â≠óÔºåÁÑ∂ÂêéÁî®ÊØè‰∏™‰ΩçÂª∫‰∏Ä‰∏™Â≠óÂÖ∏Ê†ë„ÄÇ Â∞±ÂΩ¢Êàê‰∫Ü‰∏ÄÊ£µ‰ª•0ÁªìÁÇπ‰∏∫Ê†πËäÇÁÇπÔºåÁÑ∂ÂêéÊØèÂ±ÇÂàÜÈÖç0-9 ÂÑøÂ≠êËäÇÁÇπÁöÑÂ≠óÂÖ∏Ê†ëÔºåÁÑ∂ÂêéÊØèÊ¨°Êü•ËØ¢ÂíåÂΩìÂâçÂÄºÁõ∏Âä†ÊúÄÂ§ßÂÄºÂíåÊúÄÂ∞èÂÄºÔºåÂàÜÂà´ÊØèÊ¨°‰ªéÂèñÊ®°10ÊúÄÂ§ßÁöÑÂíåÊúÄÂ∞èÁöÑËäÇÁÇπÂåπÈÖç„ÄÇ ‰æãÂ¶Ç ÂΩìÂâç‰ΩçÊòØ 5 ÊúÄÂ§ßÂÄºÁõ¥Êé•‰ªéÂΩìÂâç‰ΩçÂÑøÂ≠êËäÇÁÇπ 4ÂºÄÂßãÊâæ Â¶ÇÊûúÂ≠òÂú®Áõ¥Êé•Ê±Ç‰∏§‰∏™Êï∞ÁöÑÂíåÔºåÂê¶ÂàôÁªßÁª≠3 2 1.„ÄÇ„ÄÇ„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=1e6+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;int cnt=1;struct Trie &#123; int son[10]; void init() &#123; for(int i=0; i&lt;10; i++) &#123; son[i]=-1; &#125; &#125;&#125; tree[maxn*20];ll p[20];void insert(int r,int pos,ll val) &#123; if(pos==-1)return ; ll v=val/p[pos]%10; if(tree[r].son[v]==-1) &#123;// printf(&quot;%d&quot;,v); tree[cnt].init(); tree[r].son[v]=cnt++; &#125; insert(tree[r].son[v],pos-1,val);&#125;ll findmx(int r,int pos,ll val) &#123; if(pos==-1)return 0; ll v=val/p[pos]%10; for(int i=9-v; i&gt;=0; i--) &#123; if(tree[r].son[i]!=-1) &#123; return (p[pos]*((v+i)%10))+findmx(tree[r].son[i],pos-1,val); &#125; &#125; for(int i=9; i&gt;9-v; i--) if(tree[r].son[i]!=-1) return (p[pos]*((v+i)%10))+findmx(tree[r].son[i],pos-1,val);&#125;ll findmi(int r,int pos,ll val) &#123; if(pos==-1)return 0; int v=val/p[pos]%10; for(int i=10-v; i&lt;=9; i++) if(tree[r].son[i]!=-1) &#123; return (p[pos]*((v+i)%10))+findmi(tree[r].son[i],pos-1,val); &#125; for(int i=0; i&lt;10-v; i++) if(tree[r].son[i]!=-1) return (p[pos]*((v+i)%10))+findmi(tree[r].son[i],pos-1,val);&#125;int main() &#123; scanf(&quot;%d&quot;,&amp;n); p[0]=1; for(int i=1; i&lt;=18; i++) &#123; p[i]=p[i-1]*10; &#125; tree[0].init(); ll mx=-1e18,mi=1e18; for(int i=0; i&lt;n; i++) &#123; ll x; scanf(&quot;%lld&quot;,&amp;x); if(i!=0) &#123; mi=min(mi,findmi(0,18,x)); mx=max(mx,findmx(0,18,x)); &#125; insert(0,18,x);// puts(&quot;&quot;); &#125; printf(&quot;%lld %lld\n&quot;,mi,mx); return 0;&#125;]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K - Random Numbers Gym - 101466K ------Á∫øÊÆµÊ†ë+DFSÂ∫è]]></title>
    <url>%2F2018%2F08%2F19%2FK%20-%20Random%20Numbers%20Gym%20-%20101466K%20%20------%E7%BA%BF%E6%AE%B5%E6%A0%91%2BDFS%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[K. Random Numbers time limit per test 2.0 s memory limit per test 256 MB input standard input output standard output Tamref love random numbers, but he hates recurrent relations, Tamref thinks that mainstream random generators like the linear congruent generator suck. That‚Äôs why he decided to invent his own random generator. As any reasonable competitive programmer, he loves trees. His generator starts with a tree with numbers on each node. To compute a new random number, he picks a rooted subtree and multiply the values of each node on the subtree. He also needs to compute the number of divisors of the generated number (because of cryptographical applications). In order to modify the tree (and hence create different numbers on the future), Tamref decided to perform another query: pick a node, and multiply its value by a given number. Given a initial tree _T_, where _T__u_ corresponds to the value on the node _u_, the operations can be summarized as follows: RAND: Given a node _u_ compute and count its divisors, where _T_(_u_) is the set of nodes that belong to the subtree rooted at _u_. SEED: Given a node _u_ and a number _x_, multiply _T__u_ by _x_. Tamref is quite busy trying to prove that his method indeed gives integers uniformly distributed, in the meantime, he wants to test his method with a set of queries, and check which numbers are generated. He wants you to write a program that given the tree, and some queries, prints the generated numbers and count its divisors. Tamref has told you that the largest prime factor of both _T__u_ and _x_ is at most the Tamref‚Äôs favourite prime: 13. He also told you that the root of _T_ is always node 0. The figure shows the sample test case. The numbers inside the squares are the values on each node of the tree. The subtree rooted at node 1 is colored. The RAND query for the subtree rooted at node 1 would generate 14400, which has 63 divisors. Input The first line is an integer _n_ (1 ‚â§ _n_ ‚â§ 105), the number of nodes in the tree _T_. Then there are _n_ - 1 lines, each line contains two integers _u_and _v_ (0 ‚â§ _u_, _v_ &lt; _n_) separated by a single space, it represents that _u_ is a parent of _v_ in _T_. The next line contains _n_ integers, where the _i_ - _th_ integer corresponds to _Ti_ (1 ‚â§ _Ti_ ‚â§ 109). The next line contains a number _Q_ (1 ‚â§ _Q_ ‚â§ 105), the number of queries. The final _Q_ lines contain a query per line, in the form ‚Äú_RAND_ _u_‚Äù or ‚ÄúSEED _u_ _x_‚Äù (0 ‚â§ _u_ &lt; _n_, 1 ‚â§ _x_ ‚â§ 109). Output For each _RAND_ query, print one line with the generated number and its number of divisors separated by a space. As this number can be very long, the generated number and its divisors must be printed modulo 109 + 7. Example input Copy 12345678910111213 80 10 21 32 42 53 63 77 3 10 8 12 14 40 153RAND 1SEED 1 13RAND 1 output Copy 12 14400 63187200 126 È¢òÊÑèÔºöÂª∫‰∏ÄÈ¢óÊ†ëÔºåÊü•ËØ¢ ÊâÄÊúâ‰ª•ÂΩìÂâçËäÇÁÇπÂíåÊâÄÊúâÂÑøÂ≠êËäÇÁÇπÂõ†Â≠ê‰∏™Êï∞ÔºåÊõ¥Êñ∞ÔºåÂçïÁÇπÊõ¥Êñ∞ÂÄçÊï∞„ÄÇ È¢òËß£ÔºöÈ¶ñÂÖàdfsÊääÊâÄÊúâ‰ΩçÁΩÆÂá∫Áé∞ÁöÑÂ∫è ÊéíÂ•Ω„ÄÇÈ¢òÁõÆÊ†∑‰æã dfs,ËøõÂÖ•ÁöÑÂÖàÂêéÈ°∫Â∫è ÊòØ s[0]=1,s[1]=2,s[3]=2,s[6]=4,s[7]=5,s[2]=6,s[4]=7,s[5]=8; ÁÑ∂Âêé‰øùÁïôÊØè‰∏™ËäÇÁÇπÊúÄÂêé‰∏Ä‰∏™ÊâÄË¶ÜÁõñÁöÑÊúÄÂ§ßËåÉÂõ¥Â¶ÇÔºö e[0]=8, Âõ†‰∏∫ 0ËäÇÁÇπË¶ÜÁõñ‰∫ÜÊâÄÊúâËäÇÁÇπ‰πüÂ∞±ÊòØ 1-8 Ôºåe[1]=5,1ËäÇÁÇπ Ë¶ÜÁõñ‰∫ÜÊâÄÊúâÂ∫è‰ªé s[1]-e[1]Ôºà2 - 5ÔºâÁöÑËäÇÁÇπ„ÄÇ ÁÑ∂Âêé‰ª•Â∫èÂª∫‰∏ÄÈ¢óÁ∫øÊÆµÊ†ëÔºö Êü•ËØ¢Ôºö x ÊØèÊ¨°Êü•ËØ¢ [s[x],e[x]]; Êõ¥Êñ∞Ôºö x ÊØèÊ¨°Êõ¥Êñ∞ [ s[x] ,s[x] ]; ÊàëÁöÑÁ∫øÊÆµÊ†ëÊØèÊ¨°‰øùÂ≠òÁöÑÊòØ (l,r] ,ÊâÄ‰ª• l ÊØèÊ¨°Ë¶Å-1„ÄÇ ËøôÈ¢òÊï∞ÊçÆÂ§ÑÁêÜÔºåÊØè‰∏™ËäÇÁÇπ‰øùÁïôÊâÄÊúâÁ¥†Êï∞Âõ†Â≠ê‰∏™Êï∞ÔºåÁÑ∂ÂêéÊ±ÇÁöÑÂÄºÂ∞±ÊòØÊâÄÊúâÁ¥†Êï∞ÁöÑ‰πòÁßØÔºåÂõ†Â≠ê‰∏™Êï∞Â∞±ÊòØÁõ∏Â∫îÁ¥†Êï∞‰∏™Êï∞+1ÁöÑ‰πòÁßØÔºå ÂÅáÂ¶Ç Á¥†Âõ†Â≠ê2Êúâ6‰∏™ÔºåÁ¥†Âõ†Â≠ê3Êúâ 2‰∏™ ÔºåÁ¥†Âõ†Â≠ê5Êúâ2‰∏™ÔºåËæìÂá∫Â∞±ÊòØ 2^63^25^2, 733 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_back#define mem(a,b) memset(a,b,sizeof(a));const long long mod=1e9+7;const int maxn=2e5+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;vector&lt;int&gt; G[maxn];int e[maxn],s[maxn];int val[maxn],val2[maxn];int cnt=0;int dfs(int r,int p) &#123; cnt++;// debug(r); val[cnt]=val2[r]; s[r]=cnt; for(int i=0; i&lt;G[r].size(); i++) &#123; int to=G[r][i]; if(to!=p) &#123; dfs(to,r); &#125; &#125; e[r]=cnt;&#125;int dat[maxn&lt;&lt;4][6];int prim[]= &#123;2,3,5,7,11,13&#125;;void init(int l,int r,int k) &#123; if(r-l==1) &#123; for(int i=0; i&lt;6; i++) &#123; while(val[r]%prim[i]==0) &#123; val[r]/=prim[i]; dat[k][i]++; &#125; &#125; &#125; else &#123; init(lson); init(rson); for(int i=0; i&lt;6; i++) &#123; dat[k][i]=dat[chl][i]+dat[chr][i]; &#125; &#125;&#125;void update(int a,int b,int l,int r,int k,ll x) &#123; if(b&lt;=l||a&gt;=r) &#123; return ; &#125; else if(a&lt;=l&amp;&amp;r&lt;=b) &#123; for(int i=0; i&lt;6; i++) &#123; while(x%prim[i]==0) &#123; x/=prim[i]; dat[k][i]++; &#125; &#125; return ; &#125; else &#123; update(a,b,lson,x); update(a,b,rson,x); for(int i=0; i&lt;6; i++) &#123; dat[k][i]=dat[chl][i]+dat[chr][i]; &#125; &#125;&#125;int res[6];void query(int a,int b,int l,int r,int k) &#123; if(b&lt;=l||a&gt;=r) &#123; return ; &#125; else if(a&lt;=l&amp;&amp;r&lt;=b) &#123; for(int i=0; i&lt;6; i++) &#123; res[i]+=dat[k][i]; &#125; &#125; else &#123; query(a,b,lson); query(a,b,rson); &#125;&#125;long long pow(long long x,long long n,long long mod=1e9+7) &#123; long long res=1; while(n&gt;0) &#123; if(n&amp;1)res=res*x%mod; x=x*x%mod; n&gt;&gt;=1; &#125; return res%mod;&#125;int main() &#123; int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;n; i++) &#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); G[a].push_back(b); G[b].push_back(a); &#125; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d&quot;,&amp;val2[i]); &#125; dfs(0,-1); init(0,n,0); int q; scanf(&quot;%d&quot;,&amp;q); while(q--) &#123; char ch[100]; scanf(&quot;%s&quot;,ch); if(ch[0]==&apos;R&apos;) &#123; int a; scanf(&quot;%d&quot;,&amp;a); mem(res,0); query(s[a]-1,e[a],0,n,0); ll ans=1,num=1; for(int i=0; i&lt;6; i++) &#123; ans*=pow(prim[i],res[i],mod); ans%=mod; num*=res[i]+1; num%=mod; &#125; printf(&quot;%lld %lld\n&quot;,ans%mod,num%mod); &#125; else &#123; int a; ll b; scanf(&quot;%d%lld&quot;,&amp;a,&amp;b); update(s[a]-1,s[a],0,n,0,b); &#125; &#125; return 0;&#125; 0]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÁúÅËµõÈÄâÊãî-ÂçïË∞ÉÈòüÂàó]]></title>
    <url>%2F2018%2F08%2F12%2F%E7%9C%81%E8%B5%9B%E9%80%89%E6%8B%94-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[ÂçïË∞ÉÈòüÂàóÂÜôÊ≥ï„ÄÇ Py&amp;hyhÊÉ≥ËÑ±Âçï Description ÊÄªÊâÄÂë®Áü•,ÔºåpyÂíåhyhÊúâÂçÅÂàÜÊµìÁÉàÁöÑËÑ±ÂçïÊÑèÊÑøÔºå‰ΩÜÊòØÈùûÂ∏∏‰∏çÂπ∏ÔºåÂú®‰∏Ä‰∏™È£éÂíåÊó•‰∏ΩÁöÑ‰∏ãÂçàÔºå‰ªñ‰ª¨Á©øË∂äÂà∞‰∏Ä‰∏™Ê≤°ÊúâÂ¶πÂ≠êÁöÑ‰∏ñÁïåÔºå‰ªñÂøÖÈ°ªÂõûÁ≠î‰∏Ä‰∏™ÈóÆÈ¢òÊâçËÉΩÂõûÂà∞Êú¨Êù•ÁöÑ‰∏ñÁïåÔºåËøô‰∏™ÈóÆÈ¢òÊòØÁªôÂá∫‰∏Ä‰∏™nmÁöÑÁü©ÈòµÔºåÁÑ∂ÂêéÊúâqÊ¨°Êìç‰ΩúÔºåÊØè‰∏Ä‰∏™Êìç‰ΩúÔºåÁªôÂá∫xi,yi,ti,Ë°®Á§∫Âú®tiÊó∂ÂàªÊëßÊØÅ(xi,yi)Ëøô‰∏™Ê†ºÂ≠êÔºåÁÑ∂Âêé‰ªñ‰ª¨Ë¶ÅÊ±ÇÂá∫‰∏Ä‰∏™ÊúÄÊó©Êó∂ÂàªÔºåÂá∫Áé∞Ëá≥Â∞ë‰∏Ä‰∏™kkÁöÑÁü©ÈòµË¢´ÊØÅÂùèÔºåÊ≥®ÊÑèÔºö‰∏Ä‰∏™kkÁü©ÈòµË¢´ÊØÅÂùèÁöÑÊÑèÊÄùÊòØÊüê‰∏Ä‰∏™kkÁöÑÁü©Èòµ‰∏≠ÁöÑÊØè‰∏Ä‰∏™Ê†ºÂ≠êÈÉΩË¢´ÊëßÊØÅËøá‰∏ÄÊ¨°Êàñ‰∏ÄÊ¨°‰ª•‰∏ä„ÄÇËÅ™ÊòéÁöÑacmerËÉΩÂ∏Æ‰ªñ‰ª¨ÂõûÁ≠îËøô‰∏™ÈóÆÈ¢òÂêóÔºàÂ¶ÇÊûúÊ≤°‰∫∫ËÉΩacËøô‰∏™È¢òÔºåÂ∞±‰ª£Ë°®‰ªñ‰ª¨‰∏§‰∏™Ê≤°ÊúâËÑ±ÂçïÁöÑÂèØËÉΩ‰∫ÜÂì¶Ôºâ Input InputÔºöÈááÁî®Â§öÁªÑËæìÂÖ•Á¨¨‰∏ÄË°åËæìÂÖ•n,m,k,q,(1 ‚â§ n, m ‚â§ 500, 1 ‚â§ k ‚â§ min(n, m), 1 ‚â§ q ‚â§ n¬∑m)ÂàÜÂà´‰ª£Ë°®nmÁöÑÁü©ÈòµÔºåkkÁöÑÁü©ÈòµÔºåÂíåqÊ¨°Êìç‰ΩúÊé•‰∏ãÊù•qË°åÊØè‰∏ÄË°åËæìÂÖ•xi,yi,ti(1 ‚â§ xi ‚â§ n, 1 ‚â§ yi ‚â§ m, 0 ‚â§ t ‚â§ 1e6)Ôºå‰ª£Ë°®ÔºåÂú®tiËøô‰∏™Êó∂ÂàªÔºåxiÔºåyiËøô‰∏™‰ΩçÁΩÆ‰ºöË¢´ÊëßÊØÅ Output OutÔºöËæìÂá∫‰∏ÄË°åÔºå‰ª£Ë°®ÊúÄÊó©Êó∂ÂàªÂá∫Áé∞Ëá≥Â∞ë‰∏Ä‰∏™k*kÁöÑÁü©ÈòµË¢´ÊØÅÂùèÂ¶ÇÊûúÊ∞∏Ëøú‰∏çÂ≠òÂú®Ëøô‰∏Ä‰∏™Êó∂ÂàªÔºåËæìÂá∫-1 Sample Input 1 2 3 2 5 2 1 8 2 2 8 1 2 1 1 3 4 2 3 2 Sample Output 1 8 Sample Input 2 3 3 2 5 1 2 2 2 2 1 2 3 5 3 2 10 2 1 100 Sample Output 2 -1 È¢òÊÑèÔºöËá™Â∑±Áúã„ÄÇ Ëß£Ê≥ïÔºöÊ†áÁ®ãÊòØ‰∫åÂàÜ+‰∫åÁª¥ÂâçÁºÄÂíåÔºåÊàë‰∏™‰∫∫ËßâÂæóÂèåÂêëÈòüÂàóÂÜôÊ≥ïÊõ¥‰ºò„ÄÇ È¶ñÂÖàÊØèË°å ËÆ∞ÂΩï mp[i][ j-k , j ]Âå∫Èó¥ÁöÑÊúÄÂ§ßÂÄºÔºåÂÜçÂú®ÂæóÂà∞ÊØèË°åÊØè‰∏™Âå∫Èó¥ÊúÄÂ§ßÂÄºÁöÑÊù°‰ª∂‰∏ãÂÜçÊ¨°ËÆ∞ÂΩï ÊØèÂàóÁöÑÊúÄÂ§ßÂÄº mp[i-k,i][j]; Ëøô‰∏≠ÂÜôÊ≥ïÂè™Ë¶Å‰ºöÁî®ÂèåÂêëÈòüÂàóÊù•Áª¥Êä§ÂçïË∞ÉÈòüÂàóÔºåÂ∞±ÂæàÂ•Ω‰∫õ„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;#define bug printf(&quot;*********\n&quot;);#define debug(x) cout&lt;&lt;&quot;[&quot;&lt;&lt;x&lt;&lt;&quot;]&quot; &lt;&lt;endl;#define mid (l+r)/2#define chl 2*k+1#define chr 2*k+2#define lson l,mid,chl#define rson mid,r,chr#define pb push_backconst long long mod=998244353;const int maxn=5e3+5;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,m,k,q;deque&lt;int&gt; dq;int mp[maxn][maxn];int mp2[maxn][maxn]; //ÂºÄ‰∏™mp2ËÆ∞ÂΩï‰∏ãÊØèË°å‰∏Ä‰∏™Âå∫Èó¥ÁöÑÊúÄÂ§ßÂÄºint main() &#123; while(~scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;k,&amp;q)) &#123; memset(mp,inf,sizeof(mp)); while(q--) &#123; int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); mp[a][b]=min(mp[a][b],c); &#125; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=m; j++) &#123; if(j&gt;k&amp;&amp;dq.back()==mp[i][j-k]) &#123; dq.pop_back(); &#125; while(dq.size()&gt;0&amp;&amp;dq.front()&lt;mp[i][j]) &#123; dq.pop_front(); &#125; if(dq.size()==0||dq.front()&gt;=mp[i][j]) &#123; dq.push_front(mp[i][j]); &#125; mp2[i][j]=dq.back(); &#125; dq.clear(); &#125; for(int i=k; i&lt;=m; i++) &#123; for(int j=1; j&lt;=n; j++) &#123; if(j&gt;k&amp;&amp;dq.back()==mp2[j-k][i]) &#123; dq.pop_back(); &#125; while(dq.size()&gt;0&amp;&amp;dq.front()&lt;mp2[j][i]) &#123; dq.pop_front(); &#125; if(dq.size()==0||dq.front()&gt;=mp2[j][i]) &#123; dq.push_front(mp2[j][i]); &#125; mp[j][i]=dq.back(); &#125; dq.clear(); &#125; int res=inf; for(int i=k; i&lt;=n; i++) &#123; for(int j=k; j&lt;=m; j++) &#123; res=min(res,mp[i][j]); &#125; &#125; if(res&gt;1e6+1)res=-1; printf(&quot;%d\n&quot;,res); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 2532 Internship(ÁΩëÁªúÊµÅÊ±ÇÂâ≤Ëæπ)]]></title>
    <url>%2F2018%2F08%2F02%2FZOJ%202532%20Internship(%E7%BD%91%E7%BB%9C%E6%B5%81%E6%B1%82%E5%89%B2%E8%BE%B9)%2F</url>
    <content type="text"><![CDATA[ZOJ2532 Internship Time Limit: 5 Seconds Memory Limit: 32768 KB CIA headquarter collects data from across the country through its classified network. They have been using optical fibres long before it‚Äôs been deployed on any civilian projects. However they are still under a lot pressure recently because the data are growing rapidly. As a result they are considering upgrading the network with new technologies that provide a few times wider bandwidth. In the experiemental stage, they would like to upgrade one segment of their original network in order to see how it performs. And as a CIA intern it‚Äôs your responsibility to investigate which segment could actually help increase the total bandwidth the headquarter receives, suppose that all the cities have infinite data to send and the routing algorithm is optimized. As they have prepared the data for you in a few minutes, you are told that they need the result immediately. Well, practically immediately. Input Input contains multiple test cases. First line of each test case contains three integers n, m and l, they represent the number of cities, the number of relay stations and the number of segments. Cities will be referred to as integers from 1 to n, while relay stations use integers from n+1 to n+m. You can saves assume that n + m &lt;= 100, l &lt;= 1000 (all of them are positive). The headquarter is identified by the integer 0. The next l lines hold a segment on each line in the form of a b c, where a is the source node and b is the target node, while c is its bandwidth. They are all integers where a and b are valid identifiers (from 0 to n+m). c is positive. For some reason the data links are all directional. The input is terminated by a test case with n = 0. You can safely assume that your calculation can be housed within 32-bit integers. Output For each test print the segment id‚Äôs that meets the criteria. The result is printed in a single line and sorted in ascending order, with a single space as the separator. If none of the segment meets the criteria, just print an empty line. The segment id is 1 based not 0 based. Sample Input 12 1 3 1 3 2 3 0 1 2 0 1 2 1 3 1 3 1 2 3 1 3 0 2 0 0 0 Sample Output 12 3 &lt;hey here is an invisible empty line&gt; È¢òÊÑèÔºöÂ∞±ÊòØÁªô‰Ω†Âá†‰∏™ÁÇπ ÁÑ∂ÂêéÂÖ®ÈÉ®Ë¶ÅÊ±áÂà∞ ÁªàÁÇπ 0 ÈóÆÂì™Âá†Êù°ËæπÊµÅÈáè‰∏äÂçáÂèØ‰ª•Áõ¥Êé•Â¢ûÂ§ßÊµÅÈáè„ÄÇ È¢òËß£Ôºö È¶ñÂÖàÁî®ÁΩëÁªúÊµÅË∑ë‰∏ÄËæπÔºåÁÑ∂Âêé‰∏Ä‰∏™ÊòØËµ∑ÁÇπÁöÑÊÆã‰ΩôÁΩëÁªúÔºå‰∏Ä‰∏™ÊòØÁªàÁÇπÁöÑÊÆã‰ΩôÁΩëÁªúÔºåÂ¶ÇÊûúÊúâ‰∏ÄÊù°ÂèòËÉΩ‰ªéËµ∑ÁÇπÊÆã‰ΩôÁΩëÁªúË∑ëÂà∞ÁªàÁÇπÁöÑÊÆã‰ΩôÁΩëÁªúËÇØÂÆö Â∞±ÊòØÂõ†‰∏∫‰ªñÈôêÂà∂‰∫ÜÊµÅÈáèÔºåÊâÄ‰ª•ËøôÈ¢òÂ∞±ÊòØÊâæËÉΩËøûÊé•‰∏§‰∏™ÊÆã‰ΩôÁΩëÁªúÁöÑÁöÑËæπ„ÄÇ Ëµ∑ÁÇπÊÆã‰ΩôÁΩëÁªúÔºåÂ∞±È°∫ÁùÄ‰Ω†ËøûÁöÑËæπÊµÅ‰∏ÄÊ¨°Â∞±Ë°å‰∫Ü„ÄÇ ÁªàÁÇπÊÆã‰ΩôÁΩëÁªúÊòØÈÄÜÁùÄÊµÅ‰∏ÄÈÅçÔºåÊòØÁî®ÂèçÂêëËæπË∑ëÔºåËøô‰∏ÄÁÇπÈúÄË¶ÅÊ≥®ÊÑè‰∏ãÔºåÂõ†‰∏∫Ëøô‰∏™ÊÆã‰ΩôÁΩëÁªúÊòØ‰ªéÂà´ÁöÑÁÇπÊ±áËÅöÂà∞ÁªàÁÇπÔºå‰∏çÊòØ‰ªéÈáçÁÇπÊµÅÂá∫Âéª„ÄÇÊääÊâÄÊúâËÉΩËøûÊé•‰∏§ËæπÁÇπÁöÑ‰∏îËæπÁöÑÊµÅÈáèÊòØ0ÁöÑËæπÂä†ÂÖ•Á≠îÊ°àÂ∞±Ë°åÔºåÊúÄÂêéÊéí‰∏™Â∫è„ÄÇ ÊÄïÁêÜËß£‰∏ç‰∫ÜÊèí‰∏™Âõæ AC‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#define mem(a,b) memset(a,b,sizeof(a))using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; P;const long long mod=1e9+7;const int maxn=400+25;const int maxm=1e5+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,m,l,tot;struct edge &#123; int num,to,cap,rev;&#125;;vector &lt;edge&gt; G[maxn];int level[maxn];int iter[maxn];void init(int _n) &#123; for(int i=0; i&lt;=_n; i++) &#123; G[i].clear(); &#125;&#125;void bfs(int s) &#123; memset(level,-1,sizeof(level)); queue&lt;int&gt; que; level[s]=0; que.push(s); while(!que.empty()) &#123; int v= que.front(); que.pop(); for(int i=0; i&lt;G[v].size(); i++) &#123; edge &amp; e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0) &#123; level[e.to]=level[v] + 1; que.push(e.to); &#125; &#125; &#125;&#125;void add(int from,int to,int cap) &#123; edge eg; eg.to=to; eg.num=tot; eg.cap=cap; eg.rev=G[to].size(); G[from].push_back(eg); eg.num=2*n+m+1+l+tot++; eg.to=from; eg.cap=0; eg.rev=G[from].size()-1; G[to].push_back(eg);&#125;int dfs(int v,int t,int f) &#123; if(v == t)return f; for(int &amp;i = iter[v]; i &lt; G[v].size(); i++) &#123; edge &amp;e=G[v][i]; if(e.cap&gt;0 &amp;&amp; level[v]&lt;level[e.to]) &#123; int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0) &#123; e.cap-=d; G[e.to][e.rev].cap+=d; return d; &#125; &#125; &#125; return 0;&#125;int maxflow(int s,int t) &#123; int flow=0; for(;;) &#123; bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while((f = dfs(s,t,inf))&gt;0) &#123; flow +=f; &#125; &#125;&#125;int dis[maxn],dis2[maxn];void dfs1(int x) &#123; dis[x]=1; for(int i=0; i&lt;G[x].size(); i++) &#123; if(dis[G[x][i].to]==-1&amp;&amp;G[x][i].cap!=0) &#123; dfs1(G[x][i].to); &#125; &#125;&#125;void dfs2(int x) &#123; dis2[x]=1; for(int i=0; i&lt;G[x].size(); i++) &#123; if(dis2[G[x][i].to]==-1&amp;&amp;G[G[x][i].to][G[x][i].rev].cap!=0) &#123; dfs2(G[x][i].to); &#125; &#125;&#125;int main() &#123; while(~scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;l)&amp;&amp;(m+n+l)) &#123; init(n+m+1); tot=1; for(int i=0; i&lt;l; i++) &#123; int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); add(a,b,c); &#125; for(int i=1; i&lt;=n; i++) &#123; add(n+m+1,i,inf); &#125; maxflow(n+m+1,0); mem(dis,-1); mem(dis2,-1); dfs1(n+m+1); dfs2(0); vector&lt;int&gt; v; v.clear(); for(int i=1; i&lt;=n+m; i++) &#123; if(dis[i]==1) &#123; for(int j=0; j&lt;G[i].size(); j++) &#123; if(G[i][j].num&lt;=l&amp;&amp;dis2[G[i][j].to]==1&amp;&amp;G[i][j].cap==0) &#123; v.push_back(G[i][j].num); &#125; &#125; &#125; &#125; if(v.size()==0) &#123; puts(&quot;&quot;); &#125; else &#123; sort(v.begin(),v.end()); for(int i=0; i&lt;v.size(); i++) &#123; printf(&quot;%d%c&quot;,v[i],i+1==v.size()?&apos;\n&apos;:&apos; &apos;); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Multi-University Training Contest 2]]></title>
    <url>%2F2018%2F07%2F29%2F2018%20Multi-University%20Training%20Contest%202%201007%20Naive%20Operations%2F</url>
    <content type="text"><![CDATA[HDU 6135 Naive Operations Time Limit: 6000/3000 MS (Java/Others) Memory Limit: 502768/502768 K (Java/Others) Total Submission(s): 2438 Accepted Submission(s): 1074 Problem Description In a galaxy far, far away, there are two integer sequence a and b of length n. b is a static permutation of 1 to n. Initially a is filled with zeroes. There are two kind of operations: add l r: add one for al,al+1‚Ä¶ar query l r: query ‚àëri=l‚åäai/bi‚åã Input There are multiple test cases, please read till the end of input file. For each test case, in the first line, two integers n,q, representing the length of a,b and the number of queries. In the second line, n integers separated by spaces, representing permutation b. In the following q lines, each line is either in the form ‚Äòadd l r‚Äô or ‚Äòquery l r‚Äô, representing an operation.1‚â§n,q‚â§100000, 1‚â§l‚â§r‚â§n, there‚Äôre no more than 5 test cases. Output Output the answer for each ‚Äòquery‚Äô, each one line. Sample Input 5 12 1 5 2 4 3 add 1 4 query 1 4 add 2 5 query 2 5 add 3 5 query 1 5 add 2 4 query 1 4 add 2 5 query 2 5 add 2 2 query 1 5 Sample Output 1 1 2 4 4 6 Source 2018 Multi-University Training Contest 2 ÊØîËµõÁöÑÊó∂ÂÄôÂÜô‰∫ÜÂçäÂ§©Ê≤°ÂÜôÂá∫Êù•ÔºåÁªìÊûúÂèëÁé∞ÊòØÁ∫øÊÆµÊ†ëÊùøÂ≠êÊï≤Èîô‰∫Ü-_-||| Áªô‰∏ÄÊÆµÂå∫Èó¥ÔºåÂå∫Èó¥ÁöÑÂÄºÂÖ®ÈÉ®Âä†+1 Êü•ËØ¢ Âå∫Èó¥ a[i]/b[i]Âêë‰∏ãÂèñÊï¥ÁöÑÂíå„ÄÇ Âõ†‰∏∫Êü•ËØ¢a[i]/b[i]Âêë‰∏ãÂèñÊï¥ÔºåÁõ¥Êé•Ê±ÇÊúâÁÇπÈöæ„ÄÇ ÊâÄ‰ª•Êàë‰ª¨Êç¢‰∏™Êìç‰ΩúÔºåÊàë‰ª¨ÊØèÊ¨°Âå∫Èó¥Âä†‰∏ÄÔºåÂèòÊàêÊääÊØè‰∏™ÂÄºÂáè‰∏ÄÔºåÊØèÊ¨°ÂáèÂà∞0ÁöÑÊó∂ÂÄôai/biÁöÑÂÄºÂ∞±‰ºö+1ÔºåÊàë‰ª¨ËÆ∞ÂΩïËøô‰∏™+1ÔºåÂÜçÊääÂÄºÈáçÊñ∞Êõ¥Êñ∞‰∏∫biÔºåÊü•ËØ¢ÁöÑÊó∂ÂÄôÊü•ËØ¢+1 ÁöÑÊÄªÂíå„ÄÇ Áî®Á∫øÊÆµÊ†ë‰øùÁïôÊúÄÂ∞èÂÄºÔºåÂΩìÂá∫Áé∞ÊúÄÂ∞èÂÄº‰∏∫0ÁöÑÊó∂ÂÄôÊääcnt++ÔºåÂÄºÊõ¥Êñ∞‰∏∫b[r]ÔºåÂõ†‰∏∫ÊØèÊ¨°Âè™‰ºöÂä†+1ÊâÄ‰ª•ÊÄªÊï∞‰∏ç‰ºöÂ§™Â§ß Â¶ÇÔºö 1 2 3 4 5 add 1 4 Âå∫Èó¥ÂÄº 0 1 2 3 5 ,Âá∫Áé∞ÊúÄÂ∞èÂÄº 0 ÊâÄ‰ª•Âå∫Èó¥ cnt++ ÊääÈõ∂Âèò‰∏∫ b[i] 1 1 2 3 5 ÁÑ∂Âêé‰∏ÄÁõ¥‰∏ãÂéªÔºåÊü•ËØ¢Áõ¥Êé•Êü•ËØ¢cnt ÊÄªÂíåÂ∞±Ë°å„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxn=1e5+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int b[4*maxn]; int n,q;int dat[4*maxn],lazy[4*maxn];//lazy‰øùÂ≠òÂå∫Èó¥ÊâÄÂä†ÁöÑÂÄº dat ‰∏∫ÊúÄÂ∞èÂÄº„ÄÇint res;int cnt[maxn*4]; // ‰øùÂ≠òÊØè‰∏™Âå∫Èó¥ÈáåÈù¢ÁöÑÊÄª‰∏™Êï∞void init(int l,int r,int k) &#123; //ÂàùÂßãÂåñ int chl=2*k+1,chr=2*k+2,mid=(l+r)&gt;&gt;1; if(r-l==1) &#123; lazy[k]=cnt[k]=0; dat[k]=b[r]; return ; &#125; else &#123; lazy[k]=cnt[k]=0; init(l,mid,chl); init(mid,r,chr); dat[k]=min(dat[chl],dat[chr]); &#125;&#125;int sum(int a,int c,int l,int r,int k) &#123;//Êü•ËØ¢ÊÄª‰∏™Êï∞ int chl=2*k+1,chr=2*k+2,m=(l+r)/2; if(c&lt;=l||a&gt;=r) &#123; //‰∏çÂú®Âå∫Èó¥ÂÜÖ return 0; &#125; else if(a&lt;=l&amp;&amp;r&lt;=c) &#123; //Ë¶ÜÁõñËøô‰∏™Âå∫Èó¥ return cnt[k]; &#125; else &#123; lazy[chl]+=lazy[k]; //Êäälazy Êõ¥Êñ∞‰∏ãÂéª lazy[chr]+=lazy[k]; lazy[k]=0; dat[k]=min(dat[chl]+lazy[chl],dat[chr]+lazy[chr]); return sum(a,c,l,(l+r)/2,k*2+1)+sum(a,c,(l+r)/2,r,k*2+2); &#125;&#125;void update(int a,int c,int l,int r,int k) &#123; int chl=2*k+1,chr=2*k+2,mid=(l+r)/2; if(c&lt;=l||a&gt;=r) &#123; return ; &#125; else if(a&lt;=l&amp;&amp;r&lt;=c) &#123; if(lazy[k]+dat[k]-1&lt;=0) &#123; //Â¶ÇÊûúÊâÄË¶ÜÁõñÁöÑÂå∫Èó¥Âáè‰∏ÄÂá∫Áé∞ÂÄºÂ∞è‰∫éÁ≠â‰∫é0 Â∞±ÂéªÊâæÈÇ£‰∏™ÂÄº if(r-l==1) &#123; cnt[k]++; //ÊâæÂà∞Âêé cnt ++ dat[k]=b[r]; lazy[k]=0; //ÊääÂΩìÂâçÁªìÁÇπÁöÑÂÄºÈáçÊñ∞Êõ¥Êñ∞‰∏∫b[r] return ; &#125; lazy[chl]+=lazy[k]; //Âêë‰∏ãÊõ¥Êñ∞lazy lazy[chr]+=lazy[k]; lazy[k]=0; update(a,c,l,mid,chl); //ÂêëÂ∑¶Âè≥ÂÑøÂ≠êÁªìÁÇπÊâæ update(a,c,mid,r,chr); if(r-l!=1) &#123; cnt[k]=cnt[chl]+cnt[chr]; dat[k]=min(dat[chl]+lazy[chl],dat[chr]+lazy[chr]); //Êõ¥Êñ∞ÂÄº &#125; return; &#125; lazy[k]--; //Â¶ÇÊûúÊ≤°ÊúâÂ∞±Áõ¥Êé•ÊäälazyÂáè‰∏Ä &#125; else &#123; // Â§ßÂå∫Èó¥Êúâ‰∏ÄÈÉ®ÂàÜÂú®Â∞èÂå∫Èó¥ÂÜÖ lazy[chl]+=lazy[k]; lazy[chr]+=lazy[k]; update(a,c,l,mid,chl); update(a,c,mid,r,chr); lazy[k]=0; dat[k]=min(dat[chl]+lazy[chl],dat[chr]+lazy[chr]); //Êõ¥Êñ∞ if(r-l!=1)cnt[k]=cnt[chl]+cnt[chr]; &#125;&#125;char ch[10];int l,r;int main() &#123; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;q)!=EOF) &#123; for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;b[i]); &#125; init(0,n,0); while(q--) &#123; scanf(&quot;%s%d%d&quot;,ch,&amp;l,&amp;r); if(ch[0]==&apos;a&apos;) &#123; update(l-1,r,0,n,0); //ÊàëÂÜôÁöÑÁ∫øÊÆµÊòØÊòØ(l,r] ÊâÄ‰ª•Ë¶ÅËÆ∞Âæó-1 &#125; else &#123; printf(&quot;%d\n&quot;,sum(l-1,r,0,n,0)); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-4389 X mod f(x) Êï∞‰ΩçDP]]></title>
    <url>%2F2018%2F07%2F29%2FHDU-4389%20X%20mod%20f(x)%20%20%E6%95%B0%E4%BD%8DDP%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÈìæÊé• ÔºöHDU - 4389 X mod f(x) Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 3619 Accepted Submission(s): 1409 Problem Description Here is a function f(x): int f ( int x ) { if ( x == 0 ) return 0; return f ( x / 10 ) + x % 10; } Now, you want to know, in a given interval [A, B] (1 &lt;= A &lt;= B &lt;= 109), how many integer x that mod f(x) equal to 0. Input The first line has an integer T (1 &lt;= T &lt;= 50), indicate the number of test cases. Each test case has two integers A, B. Output For each test case, output only one line containing the case number and an integer indicated the number of x. Sample Input 2 1 10 11 20 Sample Output Case 1: 10 Case 2: 3 Author WHU Source 2012 Multi-University Training Contest 9 Recommend zhuyuanchen520 Êï∞‰ΩçDP ÊâÄÊúâÊï∞ÁöÑÂíåÊúÄÂ§ß‰∏çË∂ÖËøá82 dp[pos][sum][mod][res] Ôºåpos Á¨¨Âá†‰ΩçÔºåsum Âà∞Á¨¨Âá†‰ΩçÊØè‰∏™‰ΩçÊï∞Âä†Ëµ∑Êù•ÁöÑÂíåÔºåmodÔºå ÂèñÊ®°Â§öÂ∞ë „ÄÇ‰ΩôÊï∞ÊòØres ,Áä∂ÊÄÅ‰∏ãÊúâÂ§öÂ∞ë‰∏™Êï∞„ÄÇ ÁÑ∂ÂêéÁõ¥Êé•Áî®forÊö¥ÂäõÂèñÊ®°ÁöÑÊï∞ÁöÑÊâÄÊúâÊÉÖÂÜµ„ÄÇ Â•ó‰∏™Êï∞‰ΩçDPÁöÑÊùøÂ≠êÂ∞±Ë°å 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 #include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;typedef int ll;int dp[10][82][82][82];// ÊâÄÊúâÊï∞ÁöÑÂíåÊúÄÂ§ß‰∏çË∂ÖËøá82 dp[pos][sum][mod][res] Ôºåpos Á¨¨Âá†‰ΩçÔºåsum Âà∞Á¨¨Âá†‰ΩçÊØè‰∏™‰ΩçÊï∞Âä†Ëµ∑Êù•ÁöÑÂíåÔºåmodÔºå ÂèñÊ®°Â§öÂ∞ë „ÄÇ‰ΩôÊï∞ÊòØres ,Áä∂ÊÄÅ‰∏ãÊúâÂ§öÂ∞ë‰∏™Êï∞„ÄÇint a[25];ll dfs(int pos,ll sum,ll mod,ll res,bool limit) &#123; //Áä∂ÊÄÅ pos sum,mod,res, ‰∏äÁ∫øÊÉÖÂÜµlimit if(sum&gt;mod)return 0; if(pos==-1) &#123; //ÂΩìÊûö‰∏æÂÆåÊúÄÂêé‰∏Ä‰ΩçËøîÂõû if(sum==mod&amp;&amp;res==0)return 1; //Êª°Ë∂≥Êù°‰ª∂ËøîÂõû1 else return 0; //‰∏çÊª°Ë∂≥ËøîÂõû0 &#125; if(limit==0&amp;&amp;dp[pos][sum][mod][res]!=-1)return dp[pos][sum][mod][res];//Â¶ÇÊûúÂΩìÂâçÁä∂ÊÄÅÊòØÂ∑≤ÁªèÊúâËøáËÆ∞ÂΩï‰∏îÂΩìÂâçÊ≤°ÊúâÈôêÂà∂Â∞±Áõ¥Êé•ËøîÂõûÂ∑≤ÁªèËÆ∞ÂΩïÁöÑÂÄº ll up=limit?a[pos]:9,cnt=0;//ÊúÄÂ§ßÂèØ‰ª•Êûö‰∏æÂà∞up,Â¶ÇÊûúÂΩìÂâçÊ≤°Êúâ‰∏äÈôêÂ∞±ÂèØ‰ª• 0-9,Âê¶ÂàôÂè™ËÉΩÂà∞ÂΩìÂâç‰ΩçÁöÑÊúÄÂ§ßÂÄºÔºåcnt ËÆ∞ÂΩïÊÄªÂÖ±Â§öÂ∞ë for(int i=0; i&lt;=up; i++) &#123; //Ë∑≥ËΩ¨Áä∂ÊÄÅÔºåÂâç‰∏Ä‰ΩçÔºåÊÄªÂíåÂä†‰∏äÂÄºÔºåÂèñÊ®°Êï∞‰∏çÂèòÔºåÊõ¥Êñ∞‰ΩôÊï∞ÔºåÂ¶ÇÊûúÂΩìÂâçÊúâ‰∏äÈôêÔºåÂàáÂä†ÂÖ•ÁöÑÂÄºÂ∑≤ÁªèÂà∞ËææÂΩìÂâç‰∏äÈôê ‰∏ã‰∏ÄÁßçÊÉÖÂÜµÊâçÊúâ‰∏äÁ∫ø cnt+=dfs(pos-1,sum+i,mod,(res*10+i)%mod,limit&amp;&amp;i==a[pos]); &#125; if(limit==0)dp[pos][sum][mod][res]=cnt; //ÂΩìÂâçÁä∂ÊÄÅÊòØÊ≤°Êúâ‰∏äÈôêÁöÑÊÉÖÂÜµ‰∏ãÊ±ÇÁöÑÂíåÔºåÂ∞±ÂèØ‰ª•ËÆ∞ÂΩïÂΩìÂâçÁä∂ÊÄÅ return cnt; &#125;ll n,m;ll solve(ll x) &#123; int pos=0; while(x&gt;0) &#123; a[pos++]=x%10; x/=10; &#125; ll ans=0; for(int i=1; i&lt;82; i++) &#123; ans+=dfs(pos-1,0,i,0,true); //Áõ¥Êé•Áî®forÊö¥ÂäõÂèñÊ®°ÁöÑÊï∞ÁöÑÊâÄÊúâÊÉÖÂÜµ„ÄÇ &#125; return ans;&#125;int main() &#123; ios_base::sync_with_stdio(0); int t; memset(dp,-1,sizeof(dp)); cin&gt;&gt;t; int l=0; while(t--) &#123; l++; cin&gt;&gt;n&gt;&gt;m; cout&lt;&lt;&quot;Case &quot;&lt;&lt;l&lt;&lt;&quot;: &quot;; cout&lt;&lt;solve(m)-solve(n-1)&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÁâõÂÆ¢ÁªÉ‰π†23]]></title>
    <url>%2F2018%2F07%2F28%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A023%2F</url>
    <content type="text"><![CDATA[ÁâõÂÆ¢ÁªÉ‰π†Ëµõ23 ËøôÊ¨°ÁâõÂÆ¢ÁªÉ‰π†ËµõÔºåÈÉΩËÄÉ‰∫Ü‰∏ÄÁÇπÂ∞èÊäÄÂ∑ß„ÄÇ A Èöè‰æøÊ®°Êãü‰∏Ä‰∏ã ÈìæÊé•Ôºöhttps://www.nowcoder.com/acm/contest/156/A Êù•Ê∫êÔºöÁâõÂÆ¢ÁΩë Êó∂Èó¥ÈôêÂà∂ÔºöC/C++ 1ÁßíÔºåÂÖ∂‰ªñËØ≠Ë®Ä2Áßí Á©∫Èó¥ÈôêÂà∂ÔºöC/C++ 262144KÔºåÂÖ∂‰ªñËØ≠Ë®Ä524288K 64bit IO Format: %lld È¢òÁõÆÊèèËø∞ Á¥ßÂº†Âà∫ÊøÄÁöÑ‰∏ñÁïåÊùØÊ≠£Âú®ËøõË°å‰∏≠(Âú®ÊâòÁ±≥ÁöÑ‰∏ñÁïåÁ∫øÈáå)ÔºåÊ¨ßÊ¥≤‰∫∫ÊâòÁ±≥Ê≤âËø∑‰∫éËµåÁêÉÊó†Ê≥ïËá™Êãî„ÄÇ ÊâòÁ±≥ÁöÑÂè£Ë¢ãÈáåÊúâ 100 ÂÖÉÔºå50ÂÖÉÔºå20ÂÖÉÔºå10ÂÖÉÔºå5ÂÖÉÔºå2ÂÖÉÔºå1ÂÖÉÁöÑÁ∫∏Â∏ÅÔºå50ÂàÜÔºå20ÂàÜÔºå10ÂàÜÔºå5ÂàÜÔºå2ÂàÜÔºå1ÂàÜÁöÑÁ°¨Â∏ÅÂêÑÊó†Èôê‰∏™„ÄÇ ÊâòÁ±≥ËÆ°Âàí‰π∞‰∏ãÂá†Ê≥® a ÂÖÉ b ÂàÜÁöÑÂΩ©Á•®Ôºå‰ªñÂ∏åÊúõËÉΩÊîØÂá∫ÁöÑÁ∫∏Á•®Êï∞ÈáèÂíåÁ°¨Â∏ÅÊï∞Èáè‰πãÂíåÊúÄÂ∞èÔºå‰ªñÂ∏åÊúõ‰Ω†Â∏ÆÂä©‰ªñÂÆåÊàêËøô‰∏™‰ªªÂä°„ÄÇÂêåÊó∂Áî±‰∫éÂΩ©Á•®‰∫≠‰∏çÊîØÊåÅÊâæÈõ∂ÔºåÊâòÁ±≥Â∏åÊúõ‰ªñÁöÑÊîØÂá∫ÊÅ∞Â•ΩÁ≠â‰∫é a ÂÖÉ b ÂàÜ ËæìÂÖ•ÊèèËø∞:1Á¨¨‰∏ÄË°åËæìÂÖ•‰∏Ä‰∏™Ê≠£Êï¥Êï∞ T‰∏ãÈù¢ T Ë°åÊØèË°å‰∏§‰∏™Êï¥Êï∞ a,b ËæìÂá∫ÊèèËø∞:1ÊØèË°åËæìÂá∫ 13 ‰∏™Ê≠£Êï¥Êï∞ n1 ...n13, ÂØπÂ∫îÈ¢òÈù¢È°∫Â∫èÁªôÂá∫ÊúÄÂ∞èÂåñÊîØÂá∫Á∫∏Á•®Êï∞ÈáèÂíåÁ°¨Â∏ÅÊï∞Èáè‰πãÂíåÁöÑÊÉÖÂÜµ‰∏ãÔºåÊØèÁßçË¥ßÂ∏ÅÁöÑ‰ΩøÁî®Ê¨°Êï∞ÔºåÂ¶ÇÊûúÊúâÂ§öÁßçÊñπÊ°àÔºåËæìÂá∫Â≠óÂÖ∏Â∫èÊúÄÂ§ßÁöÑ‰∏ÄÁßçÔºåÊ≥®ÊÑèËøôÈáåÂ≠óÂÖ∏Â∫èÊòØ‰æùÊ¨°ÊØîËæÉn1Âà∞n13ÔºåËÄå‰∏çÊòØÁÆÄÂçïÁöÑÊää 13 ‰∏™Ê≠£Êï¥Êï∞ÊãºÊé•Âú®‰∏ÄËµ∑ Á§∫‰æã1 ËæìÂÖ• Â§çÂà∂ 123 21 52 4 ËæìÂá∫ Â§çÂà∂ 12 0 0 0 0 0 0 1 0 0 0 1 0 00 0 0 0 0 1 0 0 0 0 0 2 0 Â§áÊ≥®:1T=100,0‚â§ a‚â§ 109, 0‚â§ b&lt;100 12345678910111213141516171819202122232425262728 #include&lt;bits/stdc++.h&gt;using namespace std;int a[7]= &#123;100,50,20,10,5,2,1&#125;;int b[6]= &#123;50,20,10,5,2,1&#125;;int a1[7],b1[6];int main() &#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; int x,y; cin&gt;&gt;x&gt;&gt;y; for(int i=0; i&lt;7; i++) &#123; a1[i]=x/a[i]; x=x%a[i]; &#125; for(int i=0; i&lt;6; i++) &#123; b1[i]=y/b[i]; y%=b[i]; &#125; for(int i=0; i&lt;7; i++) &#123; printf(&quot;%d%c&quot;,a1[i],&apos; &apos;); &#125; for(int i=0; i&lt;6; i++) &#123; printf(&quot;%d%c&quot;,b1[i],i==5?&apos;\n&apos;:&apos; &apos;); &#125; &#125; return 0;&#125; B ÈìæÊé•Ôºöhttps://www.nowcoder.com/acm/contest/156/B Êù•Ê∫êÔºöÁâõÂÆ¢ÁΩë Êó∂Èó¥ÈôêÂà∂ÔºöC/C++ 1ÁßíÔºåÂÖ∂‰ªñËØ≠Ë®Ä2Áßí Á©∫Èó¥ÈôêÂà∂ÔºöC/C++ 262144KÔºåÂÖ∂‰ªñËØ≠Ë®Ä524288K 64bit IO Format: %lld È¢òÁõÆÊèèËø∞ Ê¨ßÊ¥≤‰∫∫ÊâòÁ±≥ÈùûÂ∏∏ÂñúÊ¨¢Êï∞Â≠óÔºå‰ªñÁªèÂ∏∏Âú®Á©∫Èó≤Êó∂Áé©‰∏ãÈù¢ÁöÑÊ∏∏Êàè ÂØπ‰∫é‰∏Ä‰∏™Êï∞Â≠ó n, ÊâòÁ±≥‰ºöÈöèÊÄßÈÄâ‰∏≠‰∏Ä‰∏™Êï∞ p, (1 Ôºú p &lt;= n), Â∞Ü n ÊãÜÂàÜÊàê ,v=n-u,Âπ∂ÂØπ u,v ÈáçÂ§çËøô‰∏™ËøáÁ®ãÔºåÁõ¥Âà∞‰ªñÊúâ‰∫Ü n ‰∏™ 1 1317 ‰∏∫‰∫ÜÊåëÊàòÊâòÁ±≥ÔºåÂú®ÊØèÊ¨°ÊâòÁ±≥ËøõË°åÂàíÂàÜÊó∂Ôºå‰ºöÁªôÊâòÁ±≥Â•ñÂä± u * v ÁöÑÂàÜÊï∞ÔºåÊâòÁ±≥Â∏åÊúõ‰Ω†ËÉΩÂ∏Æ‰ªñÊúÄÂ§ßÂåñ‰ªñÁöÑÂæóÂàÜ„ÄÇ ËæìÂÖ•ÊèèËø∞:1Á¨¨‰∏ÄË°å‰∏Ä‰∏™Ê≠£Êï¥Êï∞ T‰∏ãÈù¢ T Ë°åÊØèË°å‰∏Ä‰∏™Ê≠£Êï¥Êï∞ n ËæìÂá∫ÊèèËø∞:1ÂØπ‰∫éÊØèÁªÑÊï∞ÊçÆÔºåËæìÂá∫ÊâòÁ±≥ÁöÑÊúÄÂ§ßÂæóÂàÜ Á§∫‰æã1 ËæìÂÖ• Â§çÂà∂ 11 5 ËæìÂá∫ Â§çÂà∂ 110 Â§áÊ≥®:1T‚â§ 104, n‚â§ 109 Êé®ÂÖ¨Âºè 2 = 1*1 3 =12 +11; 4=13 +12+1*1; ËßÑÂæãÂ∞±ÊòØ Sn = (n*(n-1))/2; 12345678910111213 #include&lt;bits/stdc++.h&gt;using namespace std;long long n;int main() &#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%lld&quot;,&amp;n); printf(&quot;%lld\n&quot;,(n*(n-1))/2); &#125; return 0;&#125; C ÈìæÊé•Ôºöhttps://www.nowcoder.com/acm/contest/156/C Êù•Ê∫êÔºöÁâõÂÆ¢ÁΩë Êó∂Èó¥ÈôêÂà∂ÔºöC/C++ 1ÁßíÔºåÂÖ∂‰ªñËØ≠Ë®Ä2Áßí Á©∫Èó¥ÈôêÂà∂ÔºöC/C++ 262144KÔºåÂÖ∂‰ªñËØ≠Ë®Ä524288K 64bit IO Format: %lld È¢òÁõÆÊèèËø∞ ÊâòÁ±≥ÂÆåÊàê‰∫Ü1317ÁöÑ‰∏ä‰∏Ä‰∏™‰ªªÂä°ÔºåÂçÅÂàÜÈ´òÂÖ¥ÔºåÂèØÊòØËÄÉÈ™åËøòÊ≤°ÊúâÁªìÊùü ËØ¥ËØùÈó¥1317Áªô‰∫ÜÊâòÁ±≥ n ‰∏™Ëá™ÁÑ∂Êï∞ a1‚Ä¶ an, ÊâòÁ±≥ÂèØ‰ª•ÈÄâÂá∫‰∏Ä‰∫õÂ∏¶ÂõûÂÆ∂Ôºå‰ΩÜÊòØ‰ªñÈÄâÂá∫ÁöÑÊï∞ÈúÄË¶ÅÊª°Ë∂≥‰∏Ä‰∫õÊù°‰ª∂ ËÆæÊâòÁ±≥ÈÄâÂá∫Êù•‰∫Ük ‰∏™Êï∞ b1,b2‚Ä¶ bk, ËÆæËøô‰∏™Êï∞Âàó b ÁöÑÁªôÂÄº‰∏∫ b ‰∏≠ÊâÄÊúâÊï∞Êåâ‰Ωç‰∏éÁöÑÁªìÊûúÔºåÂ¶ÇÊûú‰Ω†ËÉΩÊâæÂà∞‰∏Ä‰∏™Êï¥Èô§ b ÁöÑÊúÄÂ§ßÁöÑ 2v,(v‚â• 0)Ôºå ÂàôËÆæÂÆö v ‰∏∫Ëøô‰∏™Êï∞ÂàóÁöÑÁªô‰ª∑ÔºåÂ¶ÇÊûú‰∏çÂ≠òÂú®ËøôÊ†∑ÁöÑ vÔºåÂàôÁªô‰ª∑ÂÄº‰∏∫ -1, 1317 Â∏åÊúõÊâòÁ±≥Âú®ÊúÄÂ§ßÂåñÁªô‰ª∑ÁöÑÊÉÖÂÜµ‰∏ãÔºåÊúÄÂ§ßÂåñ k ËæìÂÖ•ÊèèËø∞:1Á¨¨‰∏ÄË°åËæìÂÖ•‰∏Ä‰∏™Êï¥Êï∞ n, Á¨¨‰∫åË°åËæìÂÖ• a1...an ËæìÂá∫ÊèèËø∞:1Á¨¨‰∏ÄË°åËæìÂá∫ÊúÄÂ§ßÁöÑÊï¥Êï∞ k, Á¨¨‰∫åË°åËæìÂá∫ k ‰∏™Êï¥Êï∞ b1... bk, ÊåâÂéüÊï∞ÂàóÁöÑÁõ∏ÂØπÈ°∫Â∫èËæìÂá∫ (Â¶ÇÊûúË°åÊú´ÊúâÈ¢ùÂ§ñÁ©∫Ê†ºÂèØËÉΩ‰ºöÊ†ºÂºèÈîôËØØ) Á§∫‰æã1 ËæìÂÖ• Â§çÂà∂ 12 51 2 3 4 5 ËæìÂá∫ Â§çÂà∂ 12 24 5 Â§áÊ≥®:1n‚â§ 105, a1... an &lt; 231 È¢òÁõÆÊØíÁò§ËØª‰∫ÜÂçäÂ§© Áªô‰Ω†‰∏Ä‰∏™ n ‰∏™Êï∞ a1 ‚Ä¶an,ÈÄâÂá†‰∏™Êï∞ b1‚Ä¶bk ÁÑ∂ÂêéÂÖ®ÈÉ®&amp;Âêé b=b1&amp;b2‚Ä¶&amp;bk, b&amp;2^v==0, vÊúÄÂ§ßÂ∞±ÊòØÂΩìÂâçÈÄâÁöÑËøô‰∏™bÂ∫èÂàóÁöÑÂÄºÔºõ Ê±Ç VÊúÄÂ§ßÁöÑÊÉÖÂÜµ‰∏ãKÊúÄÂ§ß„ÄÇ È¢òËß£ Ôºö‰ªéÊúÄÈ´ò‰Ωç‰∏∫1 &amp;Âà∞ÊúÄ‰Ωé‰ΩçÊòØ1 ‰∏ÄË∑Ø‰∏ãÊù•Â∞±Ë°å„ÄÇv ÁöÑÂÄºÊòØÊåâ‰Ωç‰∫é‰πãÂêéÊúÄÂêé‰∏Ä‰Ωç‰∏∫ 1ÁöÑ‰ΩçÁΩÆ„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 #include&lt;bits/stdc++.h&gt;using namespace std;long long n;typedef long long ll;const int maxn=1e5+5;ll a[maxn],x[maxn];int main() &#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%lld&quot;,&amp;a[i]); &#125; for(int i=0; i&lt;=31; i++) &#123; //È¢ÑÂ§ÑÁêÜ‰∏ãÊúÄÈ´ò‰Ωç‰ΩçÁΩÆÁöÑÂÄº x[i]=1&lt;&lt;i; &#125; int k=0,flag=0,bi=0; ll v=0,m=-1; for(int i=31; i&gt;=0; i--) &#123;//‰ªéÊúÄÈ´ò‰∏∫Â§ÑÁêÜÂà∞ÊúÄ‰Ωé‰Ωç int t=0; flag=0; for(int j=0; j&lt;n; j++) &#123; if((a[j]&amp;x[i])==x[i]) &#123; //ÊääÈ´ò‰∫éÊúÄÈ´ò‰ΩçÁöÑÂÄºÂÖ®ÈÉ®ÈÄâ‰∏ä if(t==0) &#123; flag=a[j]; &#125; else &#123; flag&amp;=a[j]; &#125; t++; &#125; &#125; int pos=0; while(flag&gt;0&amp;&amp;(flag&amp;1)==0) &#123; //Âà§Êñ≠v ÁöÑ‰ΩçÁΩÆ pos++; flag&gt;&gt;=1; &#125; if(pos&gt;m||(pos==m&amp;&amp;t&gt;k)) &#123; //Êõ¥Êñ∞ÂÄº m=pos; v=flag&lt;&lt;pos; k=t; &#125; &#125; printf(&quot;%d\n&quot;,k); for(int i=0; i&lt;n; i++) &#123; if((a[i]&amp;v)==v) &#123; //ÊääÊâÄÊúâËÉΩÊåâ‰Ωç‰∫éÊàê v ÁöÑÂÖ®ÈÉ®ËæìÂá∫„ÄÇ k--; printf(&quot;%lld%c&quot;,a[i],k==0?&apos;\n&apos;:&apos; &apos;); &#125; &#125; return 0;&#125; ÊúâÁÇπÈöæÊáÇÔºåÁúã‰∏çÊáÇÁïôË®Ä„ÄÇ D ÈìæÊé•Ôºöhttps://www.nowcoder.com/acm/contest/156/D Êù•Ê∫êÔºöÁâõÂÆ¢ÁΩë Êó∂Èó¥ÈôêÂà∂ÔºöC/C++ 1ÁßíÔºåÂÖ∂‰ªñËØ≠Ë®Ä2Áßí Á©∫Èó¥ÈôêÂà∂ÔºöC/C++ 262144KÔºåÂÖ∂‰ªñËØ≠Ë®Ä524288K 64bit IO Format: %lld È¢òÁõÆÊèèËø∞ ÊâòÁ±≥Ê≤°ÊúâÂÆåÊàê‰∏ä‰∏Ä‰∏™‰ªªÂä°ÔºåÂáÜÂ§áÊñΩÂ±ïÈªëÈ≠îÊ≥ïÊé®ÂÄí 1317 ÈªëÈ≠îÊ≥ïÂííËØ≠Ë¢´ÊèèËø∞‰∏∫‰∏Ä‰∏™ Èïø‰∏∫ n ÁöÑÔºå‰ªÖÂåÖÂê´Â∞èÂÜôËã±ÊñáÂ≠óÊØç ‚Äòa‚Äô‚Ä¶‚Äôi‚Äô ÁöÑÂ≠óÁ¨¶‰∏≤ÔºåÂú®ÊâòÁ±≥ÊâÄÂú®ÁöÑÊòüÁêÉÔºåÈ≠îÊ≥ïÈÄ†ÊàêÁöÑÊØèÊ¨°ÊúâÊïà‰º§ÂÆ≥ÈÉΩÊòØÊù•Ëá™‰ªñÁöÑ‰∏Ä‰∏™Â≠êÂ∫èÂàóÔºåÂØπ‰∫éÊØè‰∏Ä‰∏™ ‚Äòa‚Äô‚Ä¶ ‚Äòi‚Äô ÁöÑÊéíÂàó(ÂÖ± 9! Áßç)ÔºåËã•‰Ωú‰∏∫ÂííËØ≠ÁöÑÂ≠êÂ∫èÂàóÂá∫Áé∞, Â∞±‰ºöÈÄ†Êàê 1 ÁöÑ‰º§ÂÆ≥ ËÄåÂííËØ≠ÁöÑÊÄª‰º§ÂÆ≥‰∏∫ÊâÄÊúâ ‚Äòa‚Äô‚Ä¶ ‚Äòi‚Äô ÁöÑÊéíÂàóÈÄ†ÊàêÁöÑ‰º§ÂÆ≥ÂÄº‰πãÂíåÔºåÊâòÁ±≥ËÉΩÊâìÂá∫Â§öÂ∞ëÁÇπÁöÑ‰º§ÂÆ≥ÔºåÊòØÂê¶ËÉΩÂáªË¥• 1317 Âë¢Ôºü ËæìÂÖ•ÊèèËø∞:1‰∏ÄË°åËæìÂÖ•‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ s ËæìÂá∫ÊèèËø∞:1‰∏ÄË°åËæìÂá∫‰∏Ä‰∏™Êï∞ÔºåË°®Á§∫‰º§ÂÆ≥ÂÄº Á§∫‰æã1 ËæìÂÖ• Â§çÂà∂ 1aabcdefghi ËæìÂá∫ Â§çÂà∂ 11 Â§áÊ≥®:1|s| ‚â§ 3000 ‰ºòÈõÖÁöÑÊö¥Âäõ„ÄÇ ÂÖ®ÊéíÂàóÊâÄÊúâÊÉÖÂÜµÔºå‰∫åÂàÜÊü•ÊâæËøôÁßçÊÉÖÂÜµÂú®Â≠óÁ¨¶‰∏≤ÈáåÈù¢ÂèØ‰∏çÂèØË°åÔºåÁÑ∂Âêé‰∏Ä‰∏™‰∏™Âä†‰∏ä„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=4e5+5;char ch[maxn];int n[maxn];vector&lt;int&gt; v[10];int dp[maxn][9];int main() &#123; int ans[9]= &#123;0,1,2,3,4,5,6,7,8&#125;; int k=0; do &#123; for(int i=0; i&lt;9; i++) &#123; dp[k][i]=ans[i]; &#125; k++; &#125; while(next_permutation(ans,ans+9)); cin&gt;&gt;ch; int l=strlen(ch); for(int i=0; i&lt;l; i++) &#123; n[i]=ch[i]-&apos;a&apos;; v[n[i]].push_back(i); &#125; int res=0; for(int i=0; i&lt;k; i++) &#123; int p=-1; for(int j=0; j&lt;9; j++) &#123; int num=dp[i][j]; if(upper_bound(v[num].begin(),v[num].end(),p)==v[num].end()) &#123; break; &#125; int t=upper_bound(v[num].begin(),v[num].end(),p)-v[num].begin(); p=v[num][t]; if(j==8) &#123; res++; &#125; &#125; &#125; cout&lt;&lt;res&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[‰∏Ä‰∫õÂáΩÊï∞Ë¶ÅËÆ∞ÁöÑÂáΩÊï∞Á¨îËÆ∞]]></title>
    <url>%2F2018%2F07%2F25%2F%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%E8%A6%81%E8%AE%B0%E7%9A%84%E5%87%BD%E6%95%B0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[__builtin_popcount() Ê±Ç‰∫åËøõÂà∂ 1ÁöÑ‰∏™Êï∞„ÄÇ double add(double a,double b) { if(abs(a+b)&lt;eps *(abs(a)+abs(b))) return 0; return a+b; } ‰∏Ä‰∏™ ÂêëÈáèÊìç‰ΩúÁªìÊûÑ‰Ωì„ÄÇ const double eps =1e-8; struct P { double x,y; P() {} P(double x,double y):x(x),y(y) {} P operator + (P p) { return P(add(x,p.x),add(y,p.y)); } P operator - (P p) { return P(add(x,-p.x),add(y,-p.y)); } P operator (double d) { return P(xd,yd); } double dot (P p) { //ÂêëÈáèÁßØ return add(xp.x,yp.y); } double det(P p) { //Êï∞ÈáèÁßØ return add(xp.y,-y*p.x); } }; double Distance(P a,P b) { return sqrt((a.x-b.x)(a.x-b.x)+(a.y-b.y)(a.y-b.y)); } double InterArea(P a,double R,P b,double r) { if(R=R+r) //‰∏§ÂúÜÁõ∏Á¶ªÔºåÁõ∏‰∫§Èù¢ÁßØ‰∏∫0 return 0; if(dis&lt;=R-r) //‰∏§ÂúÜÂÜÖÂê´ÔºåÁõ∏‰∫§Èù¢ÁßØ‰∏∫Â∞èÂúÜÁöÑÈù¢ÁßØ return PIrr; //‰∏§ÂúÜÁõ∏‰∫§Êó∂ double angle1=acos((RR+disdis-rr)/(2.0Rdis)); //Â§ßÂúÜÁöÑÈÇ£‰∏™Ëßí double angle2=acos((rr+disdis-RR)/(2.0rdis)); //Â∞èÂúÜÁöÑÈÇ£‰∏™Ëßí double s=Rangle1R+rangle2r; s-=Rdissin(angle1); return s; } ÂÖ®ÊéíÂàó ‰∏ÄÂÆöË¶ÅÊéíÂ∫è #includeusing namespace std;typedef long long ll;const int maxn=4e5+5;int n[maxn];int dp[maxn][9];int main() {int ans[9]= {0,1,2,3,4,5,6,7,8};int k=0;do {for(int i=0; i&lt;9; i++) {dp[k][i]=ans[i];}k++;} while(next_permutation(ans,ans+9));return 0;} hypot() Ê±Ç‰∏âËßíÊñúËæπ]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018Êù≠ÁîµÂ§öÊ†°Á¨¨‰∏ÄÂú∫-2018 Multi-University Training Contest 1]]></title>
    <url>%2F2018%2F07%2F23%2F2018%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%80%E5%9C%BA-2018%20Multi-University%20Training%20Contest%201%2F</url>
    <content type="text"><![CDATA[Âõ†‰∏∫Âéª‰∫ÜË∫∫‰∏äÊµ∑ÔºåÂØºËá¥‰∏§Âú∫ÁâõÂÆ¢Â§öÊ†°Ê≤°ÊúâÊâì„ÄÇËøôÂú∫Êù≠ÁîµÂ§öÊ†°Âú®Âä™Âäõ‰πüÂè™ËÉΩÂÜô5È¢òÔºåÊúâ‰∫ÜÂ§ß‰Ω¨ËÆ≤È¢òËß£ÊàëÂ∞±Ëøá‰∏Ä‰∏ã„ÄÇ Maximum Multiple Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 0 Accepted Submission(s): 0 Problem Description Given an integer n, Chiaki would like to find three positive integers x, y and z such that: n=x+y+z, x‚à£n, y‚à£n, z‚à£n and xyz is maximum. Input There are multiple test cases. The first line of input contains an integer T (1‚â§T‚â§106), indicating the number of test cases. For each test case: The first line contains an integer n (1‚â§n‚â§106). Output For each test case, output an integer denoting the maximum xyz. If there no such integers, output ‚àí1 instead. Sample Input 1 3 1 2 3 Sample Output 1 -1 -1 1 n/s+n/t+n/k=n; Ê±ÇÂæó s=3 t=3 k=3 /s=2 t=1 k=1;Ëøô‰∏§ÁßçÊÉÖÂÜµÊúÄÂ∞èÔºåÁÑ∂ÂêéÊö¥ÂäõÂ∞±Ë°å‰∫Ü ÊàëÁöÑÂÜôÊ≥ïÊòØÊâì‰∫Ü‰∏™Ë°®ÔºåÊï∞ÊçÆËåÉÂõ¥‰∏çÂ§ß„ÄÇ 100112345678910111213141516171819202122232425262728293031323334353637383940 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxn=1e6+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int t,n;long long a[maxn];int main() &#123; memset(a,-1,sizeof(a)); for(long long i=1;i*4&lt;=maxn;i++)&#123; a[i*4]=i*i*i*2; &#125; for(long long i=1;i*3&lt;=maxn;i++)&#123; a[i*3]=i*i*i; &#125; cin&gt;&gt;t; while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); printf(&quot;%lld\n&quot;,a[n]); &#125; return 0;&#125; 1002Balanced Sequence Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 0 Accepted Submission(s): 0 Problem Description Chiaki has n strings s1,s2,‚Ä¶,sn consisting of ‚Äò(‚Äò and ‚Äò)‚Äô. A string of this type is said to be balanced: if it is the empty string if A and B are balanced, AB is balanced, if A is balanced, (A) is balanced. Chiaki can reorder the strings and then concatenate them get a new string t. Let f(t) be the length of the longest balanced subsequence (not necessary continuous) of t. Chiaki would like to know the maximum value of f(t) for all possible t. Input There are multiple test cases. The first line of input contains an integer T, indicating the number of test cases. For each test case: The first line contains an integer n (1‚â§n‚â§105) ‚Äî the number of strings. Each of the next n lines contains a string si (1‚â§|si|‚â§105) consisting of (&#39; and)‚Äô. It is guaranteed that the sum of all |si| does not exceeds 5√ó106. Output For each test case, output an integer denoting the answer. Sample Input 1 2 1 )()(()( 2 ) )( Sample Output 1 4 2 ÂÖàÂ§ÑÁêÜÂ≠óÁ¨¶‰∏≤ Êää‰ªñÁÆÄÂåñÊúÄÂêéÊâÄÊúâÂ≠óÁ¨¶‰∏≤ÈÉΩ‰ºöÂèòÊàê )))((( ÂÉèËøôÊ†∑ÁöÑÂΩ¢Âºè„ÄÇ ÁÑ∂ÂêéË¥™ÂøÉ‰∏Ä‰∏ãÊØèÊ¨°ÈÄâÂ∑¶ËæπÊúÄÈïøÊàñËÄÖÂè≥ËæπÊúÄÈïøÔºåÈÉΩÊ≤°ÊúâÂΩ±ÂìçÔºåÂèçÊ≠£ÊòØÂæÄ‰∏§ËæπÊ∑ªÂä†ÔºåÂè™Ë¶Å‰øùËØÅÈÄâÁöÑËøô‰∏™ÊòØ‰∏ÄÁßçÁöÑÊúÄÂ§ßÁöÑÂ∞±Ë°å„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const int maxn=1e5+25;int t,n;stack&lt;char&gt; s;char ch[maxn];int dp1[maxn],dp2[maxn],ans;struct three &#123; int d1,d2,n;&#125; d[maxn];bool cmp(three &amp;a,three &amp;b)&#123; if(a.d1==b.d1)&#123; return a.d2&gt;b.d2; &#125; return a.d1&gt;b.d1;&#125;int main() &#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; ans=0; scanf(&quot;%d&quot;,&amp;n); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%s&quot;,ch); int pos=0; while(ch[pos]!=&apos;\0&apos;) &#123; if(ch[pos]==&apos;)&apos;) &#123; if(s.size()==0||s.top()==&apos;)&apos;) &#123; s.push(&apos;)&apos;); &#125; else &#123; ans+=2; s.pop(); &#125; &#125; else if(ch[pos]==&apos;(&apos;) &#123; s.push(&apos;(&apos;); &#125; pos++; &#125; int a1=0,a2=0; if(s.size()==0) &#123; i--; n--; &#125; else &#123; while(s.size()&gt;0) &#123; if(s.top()==&apos;)&apos;)a2++; else a1++; s.pop(); &#125; d[i].d1=a1; d[i].d2=a2; d[i].n=i; &#125; &#125; sort(d,d+n,cmp); int k1=d[0].d1,k2=d[0].d2; for(int i=1; i&lt;n; i++) &#123; int k=max(min(k1,d[i].d2),min(k2,d[i].d1)); ans+=2*k; k1=k1-k+d[i].d1; k2=k2-k+d[i].d2; &#125; printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125; 1003Triangle Partition Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 132768/132768 K (Java/Others) Total Submission(s): 0 Accepted Submission(s): 0Special Judge Problem Description Chiaki has 3n points p1,p2,‚Ä¶,p3n. It is guaranteed that no three points are collinear. Chiaki would like to construct n disjoint triangles where each vertex comes from the 3n points. Input There are multiple test cases. The first line of input contains an integer T, indicating the number of test cases. For each test case: The first line contains an integer n (1‚â§n‚â§1000) ‚Äî the number of triangle to construct. Each of the next 3n lines contains two integers xi and yi (‚àí109‚â§xi,yi‚â§109). It is guaranteed that the sum of all n does not exceed 10000. Output For each test case, output n lines contain three integers ai,bi,ci (1‚â§ai,bi,ci‚â§3n) each denoting the indices of points the i-th triangle use. If there are multiple solutions, you can output any of them. Sample Input 1 1 1 1 2 2 3 3 5 Sample Output 11 2 3 Ê≤°Âï•Â•ΩËÆ≤ÁöÑÔºåÊéí‰∏™Â∫è‰ªéÂ∑¶Âà∞Âè≥ÂèçÊ≠£‰∏ç‰ºö‰∫§Âèâ„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344 #include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;typedef pair&lt;char, int &gt; PCI;typedef pair&lt;int, int&gt; PII;typedef pair&lt;LL, LL&gt; PLL;const int MAX = 1e4+7;const int INF = 0x3f3f3f3f;const int mod=1e9+7;int N, M, K, T;struct node &#123; int x, y, id; bool operator&lt;(const node&amp; b) const &#123; return x &lt; b.x; &#125;&#125;;node a[MAX];vector&lt;int&gt; v[MAX];int main() &#123; scanf(&quot;%d&quot;,&amp;T); while(T--) &#123; scanf(&quot;%d&quot;,&amp;N); for(int i = 1; i &lt;= 3*N; i++) &#123; scanf(&quot;%d %d&quot;, &amp;a[i].x, &amp;a[i].y); a[i].id = i; &#125; sort(a+1, a+N*3+1); for(int i = 1; i &lt;= 3*N; i+=3) &#123; printf(&quot;%d %d %d\n&quot;,a[i].id, a[i+1].id, a[i+2].id); &#125; &#125; return 0;&#125; 1004 hiaki has an array of n positive integers. You are told some facts about the array: for every two elements ai and aj in the subarray al..r (l‚â§i&lt;j‚â§r), ai‚â†ajholds. Chiaki would like to find a lexicographically minimal array which meets the facts. Input There are multiple test cases. The first line of input contains an integer T, indicating the number of test cases. For each test case: The first line contains two integers n and m (1‚â§n,m‚â§105) ‚Äî the length of the array and the number of facts. Each of the next m lines contains two integers li and ri (1‚â§li‚â§ri‚â§n). It is guaranteed that neither the sum of all n nor the sum of all m exceeds 106. Output For each test case, output n integers denoting the lexicographically minimal array. Integers should be separated by a single space, and no extra spaces are allowed at the end of lines. Sample Input 1 3 2 1 1 2 4 2 1 2 3 4 5 2 1 3 2 4 Sample Output 1 1 2 1 2 1 2 1 2 3 1 1 ÈòüÂèãÂÜôÁöÑÔºåÁúã‰∫Ü‰∏Ä‰∏ãÔºåË¥™ÂøÉÔºåÊØèÊ¨°ÊîæÊúÄÂ∞èÁöÑÂ∞±Ë°å„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 #include &lt;bits/stdc++.h&gt;#define fi first#define se second#define lson l,m,rt&lt;&lt;1#define rson m+1,r,rt&lt;&lt;1|1#define lowbit(x) x&amp;-x#define MP make_pair#define debug(x) cout&lt;&lt;x&lt;&lt;&quot;= &quot;&lt;&lt;x&lt;&lt;endl;#define FIN freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt;pii;typedef pair&lt;ll,ll&gt;pll;const int mod=1e9+7;const int inf=0x3f3f3f3f;const ll infll=0x3f3f3f3f3f3f3f3f;const int MX=1e5+7;int n,m;struct node &#123; int l,r; bool operator&lt;(const node&amp;A)const &#123; if(l==A.l) return r&lt;A.r; return l&lt;A.l; &#125;&#125; a[MX];int ans[MX];bool vis[MX];int main() &#123; int T; cin&gt;&gt;T; while(T--) &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=m; i++) &#123; scanf(&quot;%d%d&quot;,&amp;a[i].l,&amp;a[i].r); &#125; sort(a+1,a+m+1); priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q; for(int i=1; i&lt;=n; i++)&#123; ans[i]=1;vis[i]=0; q.push(i); &#125; int l=a[1].l,r=a[1].l; for(int i=1;i&lt;=m;i++)&#123; for(;l&lt;a[i].l;l++)&#123; if(vis[l]) q.push(ans[l]); &#125; for(;r&lt;=a[i].r;r++)&#123; if(r&gt;=a[i].l)&#123; ans[r]=q.top();q.pop(); vis[r]=1; &#125; &#125; &#125; for(int i=1; i&lt;=n; i++) &#123; printf(&quot;%d&quot;,ans[i]); if(i==n) printf(&quot;\n&quot;); else printf(&quot; &quot;); &#125; &#125; return 0;&#125; 1007Chiaki Sequence Revisited Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 428 Accepted Submission(s): 69 Problem Description Chiaki is interested in an infinite sequence a1,a2,a3,‚Ä¶, which is defined as follows: an={1an‚àían‚àí1+an‚àí1‚àían‚àí2n=1,2n‚â•3 Chiaki would like to know the sum of the first n terms of the sequence, i.e. ‚àëi=1nai. As this number may be very large, Chiaki is only interested in its remainder modulo (109+7). Input There are multiple test cases. The first line of input contains an integer T (1‚â§T‚â§105), indicating the number of test cases. For each test case: The first line contains an integer n (1‚â§n‚â§1018). Output For each test case, output an integer denoting the answer. Sample Input 1 10 1 2 3 4 5 6 7 8 9 10 Sample Output 1 1 2 4 6 9 13 17 21 26 32 Êâì‰∏™Ë°®ÊâæËßÑÂæãÔºå 1 2 3 4 5 6 7 8 9 10 2 2 1 3 1 2 1 4 1 2 ÂêÑ‰∏™Êï∞Âá∫Áé∞ÁöÑÊ¨°Êï∞Â∞±ÊòØËøôÊ†∑ÔºåÁÑ∂ÂêéÂ∞±ÊòØlowbitÔºàiÔºâÊ¨°ÔºåÁÑ∂Âêé‰∫åÂàÜÊâæ Âà∞Âì™‰∏™Êï∞Âá∫Áé∞ÁöÑÊï∞Ê¨°Êï∞ÊÄªÂíå‰∏∫n ÁÑ∂ÂêéÂÜçÁúã‰∏Ä‰∏ã ÊØèÊ¨°ÊâæÁöÑÁöÑÊï∞Ôºåx,‰Ω†‰ºöÂèëÁé∞ÔºåxÊÄªÊòØÂú®n/2ÈôÑËøë„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include &lt;complex&gt;#include &lt;functional&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxn=1e7+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;long long m,n;long long sum(ll x) &#123; ll ans=1,k=1; while(x&gt;0) &#123;// cout&lt;&lt;x&lt;&lt;endl; if(x%2==1)ans+=x/2*k+1*k; else &#123; ans+=x/2*k; &#125; k++; x/=2; &#125; return ans;&#125;long long js(ll x) &#123; ll res=0,k=1,ans,p=1; while(x&gt;0) &#123; if(x%2==1) &#123; ans=x/2+1; &#125; else &#123; ans=x/2; &#125; ans%=mod; res+=ans*ans%mod*p%mod*k%mod; res%=mod; k++; p=p*2%mod; x/=2; &#125; return res%mod;&#125;int main() &#123; int t; cin&gt;&gt;t; while(t--) &#123; scanf(&quot;%lld&quot;,&amp;n); ll l=0,r=n; if(n&gt;200)&#123; l=n/2-100; r=n/2+100; &#125; while(l&lt;r-1) &#123; ll mid=(l+r)/2; if(sum(mid)&gt;n) &#123; r=mid; &#125; else l=mid; &#125;// cout&lt;&lt;l&lt;&lt;endl; printf(&quot;%lld\n&quot;,(js(l)+(n-sum(l))*(l+1)%mod+1)%mod); &#125; return 0;&#125; 1011Time Zone Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 1646 Accepted Submission(s): 289 Problem Description Chiaki often participates in international competitive programming contests. The time zone becomes a big problem. Given a time in Beijing time (UTC +8), Chiaki would like to know the time in another time zone s. Input There are multiple test cases. The first line of input contains an integer T (1‚â§T‚â§106), indicating the number of test cases. For each test case: The first line contains two integers a, b (0‚â§a‚â§23,0‚â§b‚â§59) and a string s in the format of ‚ÄúUTC+X‚Äô‚Äô, ‚ÄúUTC-X‚Äô‚Äô, ‚ÄúUTC+X.Y‚Äô‚Äô, or ‚ÄúUTC-X.Y‚Äô‚Äô (0‚â§X,X.Y‚â§14,0‚â§Y‚â§9). Output For each test, output the time in the format of hh:mm (24-hour clock). Sample Input 1 3 11 11 UTC+8 11 12 UTC+9 11 23 UTC+0 Sample Output 1 11:11 12:12 03:23 Ê≥®ÊÑèÁ≤æÂ∫¶ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxn=1e7+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int t;int main() &#123; cin&gt;&gt;t; int h,m; double ut; while(t--) &#123; scanf(&quot;%d%d UTC%lf&quot;,&amp;h,&amp;m,&amp;ut); int u=ut*100; int k=abs(u); if(k%10&gt;5)k=k/10+1; else k=k/10; if(u&gt;0)u=k; else u=-k;// cout&lt;&lt;u&lt;&lt;endl; m+=u%10*6; if(m&lt;0) &#123; m+=60; h--; &#125; h+=m/60; m=m%60;// cout&lt;&lt;h&lt;&lt;endl; m=m%60; u=u/10-8; h+=u; if(h&lt;0)h+=24; h=h%24; printf(&quot;%02d:%02d\n&quot;,h,m); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 496 (Div. 3) E2 - Median on Segments (General Case Edition)ÔºàÊÄùÁª¥+Áî®bit ‰ΩçÊ±ÇÂâçÁºÄÂêàÔºâ]]></title>
    <url>%2F2018%2F07%2F16%2FCodeforces%20Round%20496%20(Div.%203)%20E2%20-%20Median%20on%20Segments%20(General%20Case%20Edition)%EF%BC%88%E6%80%9D%E7%BB%B4%2B%E7%94%A8bit%20%E4%BD%8D%E6%B1%82%E5%89%8D%E7%BC%80%E5%90%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[ËøôÈ¢òÁúã‰∫ÜÂà´‰∫∫ÁöÑÂçöÂÆ¢ÔºåÁúãÁöÑÊàë‰∏ÄËÑ∏ÊáµÈÄº„ÄÇ ÊÄùË∑ØÔºöÂæàÂ∑ßÁßíÁöÑËΩ¨Êç¢ÔºåÊàë‰ª¨Êää&lt;= m Êï∞ËÆ∞‰∏∫-1, &gt;mÁöÑÊï∞ ËÆ∞‰∏∫1Ôºå Ê±ÇÂÖ∂ÂâçÁºÄÂíå, Êàë‰ª¨Â∞ÜÈóÆÈ¢òËΩ¨ÂèòÊàêÊ±Ç‰ª•&gt; m ÁöÑÊï∞‰Ωú‰∏∫‰∏≠‰ΩçÊï∞ÁöÑÂå∫Èó¥‰∏™Êï∞Ôºå Á≠îÊ°àÂ∞±Âèò‰∏∫ans(m-1) - ans(m )ÔºåÊàë‰ª¨ÂèØ‰ª•Áî®‰∏äÈù¢Ê±ÇÂæóÁöÑÂâçÁºÄÁî®bitÂ∞±ËÉΩÊ±ÇÂá∫Á≠îÊ°à„ÄÇ ÊàëÁâπ‰πàËøò‰∏çÁü•ÈÅìÊòØËøôÊ†∑ÂÜôÁöÑ‰πàÔºåÊàëÊòØ‰∏çÁü•ÈÅìÊÄé‰πàÁî®ÂâçÁºÄ„ÄÇÁÑ∂ÂêéÁ∫†Áªì‰∫ÜÂçäÂ§©ÔºåÊòØÂí±ÁöÑÂü∫Á°Ä‰∏çÂ•Ω„ÄÇ ÊâÄ‰ª•ÈáçÁÇπÊòØÊÄé‰πàÁî®bit‰ΩçÊù•Â§ÑÁêÜÂâçÁºÄÂíåÂë¢Ôºü Âè™ÂèØÊÑè‰ºö‰∏çÂèØË®Ä‰º† 12 5 41 4 5 60 4 È¶ñÂÖà‰º†‰∏™ ÂΩì k =4 Êó∂ Â∞±ÊòØ -1 -2 -1 0 -1 È¶ñÂÖà Áü•ÈÅì ÂâçÁºÄÂíå‰∏∫Ë¥üÊï∞ÁöÑ‰∏≠Âç´ËÇØÂÆöÊòØ&lt;=4‰∏∫Ê≠£Êï∞ÁöÑ‰∏ÄÂÆöÊòØ&gt;4 ÁªìÁÇπÂõæÂ¶Ç‰∏ãÔºåËá≥‰∫é8‰ª•‰∏äÁöÑÁªìÁÇπÂ∞±‰∏çÁîª‰∫ÜÔºåÁîª‰∫Ü‰πüÊ≤°Áî®ÂâçÁºÄÂêàÊúÄÂ§ßÂÄº‰∏ç‰ºöË∂ÖËøá8Ôºõ È¶ñÂÖà 0 +n+1=5 ÔºàÂàùÂßãÂÄºÈÉΩ‰∏∫-1Ôºâ ÂíåËøô‰∏™‰ª•ÂêéÁöÑÁªìÁÇπÂÄº ++Ôºõ ‰πüÂ∞±ÊòØ 6 8ÁªìÁÇπ ÈÉΩÂä†1Ôºõ ‰∏ã‰∏Ä‰∏™ÂÄº -1 ÊääÊâÄÊúâ -1+n=4 ‰∏Ä‰∏ãÁöÑÁªìÁÇπ ÁöÑÂÄºÈÉΩÂä†Ëµ∑Êù•„ÄÇ ÁÑ∂Âêé Êää Â∞è‰∫é -1+n ÁöÑÁªìÁÇπÂíåÈÉΩÂä†‰∏ÄÔºå‰πüÂ∞±ÊòØ 4 8ÈÉΩÂä†1Ôºõ ÂêéÈù¢ÁöÑÈÉΩÊòØÂêåÊ†∑ÁöÑÈÅìÁêÜ 1234567891011121314151617181920212223242526272829303132333435363738394041424344 #include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+5;const int N=2*maxn;int n,m,a[maxn];int v[N];void jl(int x) &#123; for(int i=x; i&lt;N; i+=i&amp;-i) &#123; //Ëøô‰∏™ÊòØÊù•‰øùÁïôÁöÑÂâçÁºÄÂíåÔºåÂÅáÂ¶Ç ÂΩìÂâç‰ΩçÁΩÆÁöÑÂâçÁºÄÂêà ÊòØ -1 ÔºåÂõ†‰∏∫ÂèØËÉΩÂá∫Áé∞Ë¥üÊï∞ÁöÑÊÉÖÂÜµÊâÄ‰ª•Âä†‰∏ä n // ÁÑ∂ÂêéÊØî -1 + n Âêë‰∏äË∑≥ËΩ¨ÁöÑÁªìÁÇπ ÈÉΩÂä†‰∏ä1 v[i]++; &#125;&#125;long long s(int x) &#123; long long sum=0; for(int i=x; i&gt;0; i-=i&amp;-i) &#123; sum+=v[i]; // ËÆ°ÁÆóÂâçÁºÄÂíåÔºå‰ªé‰∏äÂæÄ‰∏ãÂä†ÔºåËøôÊ†∑‰ºöÊääÂ∞è‰∫éÂΩìÂâçÁªìÁÇπÁöÑÂÄºÈÉΩÂä†Ëµ∑Êù•„ÄÇ &#125; return sum;&#125;long long cal(int k)&#123; memset(v,0,sizeof(v)); jl(n+1); int dp=0; long long sum=0; for(int i=0;i&lt;n;i++)&#123; if(a[i]&lt;=k)dp-=1; else dp+=1; sum+=s(dp+n); jl(dp+n+1); &#125; return sum;&#125;int main() &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0; i&lt;n; i++)scanf(&quot;%d&quot;,&amp;a[i]); cout&lt;&lt;cal(m-1)-cal(m)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 45 (Rated for Div. 2)]]></title>
    <url>%2F2018%2F06%2F10%2FEducational%20Codeforces%20Round%2045%20(Rated%20for%20Div.%202)%2F</url>
    <content type="text"><![CDATA[A ,B ‰∏§È¢òÂ∞±Áõ¥Êé•Áªô‰ª£Á†Å‰∫ÜÔºåÊ≤°Âï•ËÆ≤ÁöÑ A: 123456789101112131415161718 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;using LL = long long;ll n,m,a,b;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;a&gt;&gt;b; ll k=n/m; if(n%m==0) &#123; cout&lt;&lt;0&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;min((n-k*m)*b,((k+1)*m-n)*a)&lt;&lt;endl; &#125; return 0;&#125; B: 1234567891011121314151617181920212223 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;using LL = long long;const int maxn=2e5+25;int n,a[maxn],k;int main() &#123; cin&gt;&gt;n&gt;&gt;k; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; sort(a, a+n); int mx=1e7+25,ans=0;; for(int i=n-2;i&gt;=0;i--) &#123; int *temp=upper_bound(a,a+n,a[i]); if(temp==a+n)ans++; else if(a[i]+k&lt;*temp||a[i]==*temp)ans++; &#125; cout&lt;&lt;ans+1&lt;&lt;endl;; return 0;&#125; http://codeforces.com/contest/990/problem/C Êã¨Âè∑ÂåπÈÖç„ÄÇÊØè‰∏™Â≠óÁ¨¶‰∏≤‰øùÁïôÂâçÁºÄÂíå ‰æãÂ¶Ç ((() ÂâçÁºÄÂíå 2 ())) ÂâçÁºÄÂíå -2Ôºõ ÊØèÊ¨°Âè™Ë¶ÅÊää‰∏§‰∏™Êï∞ÂâçÁºÄÂíåÂä†Ëµ∑Êù•Á≠â‰∫é0ÁöÑÊï∞ÈáèÊÉ≥ÊàêÂ∞±ÊòØÂèØ‰ª•ÂåπÈÖçÁöÑÊï∞Èáè„ÄÇ ‰øùÁïôË¥üÊï∞ÂâçÁºÄÂíåÁöÑÊó∂ÂÄô‰∏ÄÂÆöË¶ÅÊòØËøô‰∏™ÂâçÁºÄÂíåÁöÑÊó∂ÂÄô‰∏ÄÂÆöÊòØÊúÄÂ∞èÁöÑÈÇ£‰∏™Ôºå‰∏çÁÑ∂Êú¨Ë∫´Â∞±ÊòØÈîôÁöÑ„ÄÇ ‰æãÂ¶Ç )))(( ())( 123456789101112131415161718192021222324252627282930 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;using LL = long long;const int maxn=3e5+25;ll n,mx=0;char ch[maxn];map&lt;ll,ll&gt; mp;int main() &#123; cin&gt;&gt;n; for(ll j=0; j&lt;n; j++) &#123; scanf(&quot;%s&quot;,ch); ll flag=0,k=0,l=strlen(ch); for(ll i=0; i&lt;l; i++) &#123; if(ch[i]==&apos;(&apos;)k++; else k--; if(k&lt;0)flag=min(k,flag); &#125; if(flag&lt;0&amp;&amp;k&gt;flag)continue; else &#123; mp[k]++; mx=max(k,mx); &#125; &#125; ll sum=0; for(int i=0; i&lt;=mx; i++) sum+=mp[i]*mp[-i]; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125; D:http://codeforces.com/contest/990/problem/D È¢òÁõÆÊÑèÊÄùÊòØÔºåÁªô‰Ω†N‰∏™È°∂ÁÇπÔºåÁÑ∂ÂêéÊÄé‰πàËøûËÆ©‰ªñÂèØ‰ª•ÊúâÔºåa,‰∏™ËÅîÈÄöÂø´ÔºåÁÑ∂ÂêéËøûÁöÑÁöÑÁü©ÈòµÁöÑÂèçÁü©Èòµ ÂàöÂ•ΩÊúâb‰∏™ËÅîÈÄöÂø´„ÄÇ ‰æãÂ¶Ç 3 1 2 Áü©Èòµ ÊòØ 001 001 110 ‰ªñÂ∞±ÊòØ Ëøô‰∏™Ê†∑Â≠ê ÂèçÁü©ÈòµÂ∞±ÊòØ 010 100 000 ÂõæÂ∞±ÊòØ Ëøô‰∏™Ê†∑Â≠êÊâÄ‰ª•Êª°Ë∂≥Êù°‰ª∂„ÄÇ ÁúãËµ∑Êù•Êå∫ÈöæÁöÑÔºåÂÆûÈôÖ‰∏äÂ∞±ÊòØ‰∏™ÂÇªÈÄºÈ¢òÔºåÂ∞±ÊòØÊ≤°ËøûÁöÑËæπ‰∏ÄÂÆöÂèØ‰ª•Ëøû‰∏äÔºåÊâÄ‰ª•Êó†ËÆ∫‰Ω†‰∏ÄÁßçËøûÊàêÂï•Ê†∑Âè¶‰∏ÄÁßçÂøÖÁÑ∂ÊòØÂÖ®ÈÉ®ËÅîÈÄö ÊâÄ‰ª•Ôºåa,bÂøÖÈ°ªÊúâ‰∏Ä‰∏™ÊòØ 1 ÔºåÂ¶ÇÊûúÊ≤°ÊúâÂ∞±‰∏çÂèØË°åÔºåÁÑ∂ÂêéÁâπÂà§‰∏Ä‰∏ã 2 3 ‰∏§‰∏™ ÈÉΩÊòØ 1ÁöÑÊÉÖÂÜµÔºå‰∏∫‰ªÄ‰πàË¶ÅÁâπÂà§Âë¢ÔºåËá™Â∑±Áîª‰∏™ÂõæËØïËØïÂ∞±Áü•ÈÅì‰∫Ü„ÄÇ ÁÑ∂ÂêéÂ∞±ÁÆÄÂçï‰∫ÜÔºåÁü©ÈòµÂÖ∂ÂÆûÂè™Ë¶ÅÂêß ‰∏çÊòØ 1 ÁöÑÁöÑÈÇ£‰∏™ËÅîÈÄöÂø´Êï∞ÈáèÂàÜÊàê 1 1 1 1 n-a ËøôÊ†∑ÁöÑÂá†‰∏™ËÅîÈÄöÂùóÂ∞±Ë°å‰∫Ü„ÄÇ ÊâÄ‰ª•Âè™Ë¶ÅËøû n-aÊù°Ëæπ„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738 #include &lt;bits/stdc++.h&gt;using namespace std;const int Maxn = 1005;int n, a, b;char B[Maxn][Maxn];int main() &#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;a, &amp;b); if(a!=1&amp;&amp;b!=1)printf(&quot;NO\n&quot;); else if((n==2||n==3)&amp;&amp;a==1&amp;&amp;b==1)printf(&quot;NO\n&quot;); else &#123; char ca=&apos;1&apos;,cb=&apos;0&apos;; if(a&lt;b) &#123; swap(a,b); swap(ca,cb); &#125; int k=n-a; for(int i=0; i&lt;n; i++) &#123; for(int j=0; j&lt;n; j++) &#123; if(i==j)B[i][j]=&apos;0&apos;; else B[i][j]=cb; &#125; &#125; for(int i=0; i&lt;k; i++) &#123; B[i][i+1]=B[i+1][i]=ca; &#125; printf(&quot;YES\n&quot;); for(int i=0; i&lt;n; i++) &#123; for(int j=0; j&lt;n; j++) printf(&quot;%c&quot;,B[i][j]); printf(&quot;\n&quot;); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[‰∏≠ÂçóÂ§öÊ†°ËµõÂÖ´]]></title>
    <url>%2F2018%2F06%2F06%2F%E4%B8%AD%E5%8D%97%E5%A4%9A%E6%A0%A1%E8%B5%9B%E5%85%AB%2F</url>
    <content type="text"><![CDATA[CSU2128 2130 2135 2136 AÈ¢ò CSU2128 2128: Wells‚Äôs Travel PlanSubmit Page Summary Time Limit: 3 Sec Memory Limit: 128 Mb Submitted: 39 Solved: 3 DescriptionWellsÊù•Âà∞‰∫Ü‰∏Ä‰∏™Êú™Áü•ÁöÑÊ¢¶ÂπªÂõΩÂ∫¶ÔºåËøô‰∏™ÂõΩÂ∫¶Êúâ 2N ‰∏™ÂüéÂ∏ÇÔºåÂàÜÂ∏É‰∏∫‰∏Ä‰∏™ 2*N ÁöÑÁü©Èòµ„ÄÇÊúâ‰∫õÂüéÂ∏ÇÊòØÊó†Ê≥ïÂà∞ËææÁöÑ„ÄÇ‰∏Ä‰∏™ÂüéÂ∏ÇÂèØ‰ª•Âà∞Ëææ‰∏é‰πãÊõºÂìàÈ°øË∑ùÁ¶ª‰∏∫ 1 ÁöÑÂüéÂ∏Ç„ÄÇ Â§ßÂÆ∂ÈÉΩÁü•ÈÅìÊâìacmÊ≤°ÊúâÂ§™Â§öÁöÑËá™Áî±Êó∂Èó¥Âá∫ÂéªÁé©Ôºå‰ΩÜWells‰ªçÁÑ∂ÊÉ≥Áü•ÈÅìÔºåÂ¶ÇÊûúÂú®‰ªéÁ¨¨ l ‰∏™ÂüéÂ∏ÇÂá∫ÂèëÂà∞Á¨¨ r ‰∏™ÂüéÂ∏ÇÁöÑÊúÄÂ∞ëÈúÄË¶ÅÁªèËøáÂ§öÂ∞ëÂüéÂ∏Ç„ÄÇ ÂüéÂ∏ÇÁöÑÂàÜÂ∏ÉÂ¶Ç‰∏ãÂõæ: 1, 2, 3, ‚Ä¶.N N+1,N+2,N+3‚Ä¶.N*2 InputÁ¨¨‰∏ÄË°å‰∏§‰∏™Ê≠£Êï¥Êï∞ nÔºåmÔºåm ‰∏∫ËØ¢ÈóÆÊï∞ Êé•‰∏ãÊù•‰∏§Ë°åÔºåÊØèË°åÊòØ‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫ N ÁöÑÂ≠óÁ¨¶‰∏≤ÔºåË°®Á§∫ÂüéÂ∏ÇËÉΩÂê¶ÁªèËøá„ÄÇ Ëã•‰∏∫ XÔºåË°®Á§∫‰∏çËÉΩÁªèËøáÔºåËã•‰∏∫ PÔºåË°®Á§∫ÂèØ‰ª•ÁªèËøá„ÄÇ Êé•‰∏ãÊù• m Ë°åÔºåÊØèË°å‰∏§‰∏™Êï¥Êï∞ l,rÔºåÊèèËø∞‰∏Ä‰∏™ËØ¢ÈóÆ„ÄÇ OutputÂØπ‰∫éÊØè‰∏™ËØ¢ÈóÆËæìÂá∫‰∏ÄË°åÔºål Âà∞ r ÁöÑÈúÄË¶ÅÁªèËøáÁöÑÊúÄÂ∞ëÂüéÂ∏Ç‰∏™Êï∞(‰∏çÂåÖÊã¨Ëµ∑ÁÇπÔºå‰ΩÜÂåÖÊã¨ÁªàÁÇπ)ÔºåËã•Êó†Ê≥ïÂà∞ËææËæìÂá∫-1„ÄÇ Sample Input13 4 XPX PPP 1 4 4 2 6 5 6 4 Sample Output1-1 2 1 2 HintÂØπ‰∫éÊâÄÊúâÊï∞ÊçÆ,_n_, _m_ &lt; =2 * 105. AÈ¢ò Êú¨Êù•Â∫îËØ•ÊòØÁî®ÂÄçÂ¢ûÔºå‰ΩÜÊòØÊö¥ÂäõËøòÊòØËÉΩÂç°ÊûÅÈôêËøá„ÄÇ„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define pi acos(-1.0)#define e 2.718#define lowbit(x) (x&amp;(-x))using namespace std;typedef unsigned long long ull;typedef long long ll;const int N=4e5+9;const long long mod=1e9+7;const int maxn=2e5+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,m;int mp[3][maxn];char ch[maxn];set&lt;int&gt; s[3];int main() &#123; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)&amp;&amp;n&amp;&amp;m) &#123; scanf(&quot;%s&quot;,ch); s[0].clear(); s[1].clear(); for(int i=0; i&lt;n; i++) &#123; if(ch[i]==&apos;X&apos;) &#123; s[0].insert(i); mp[0][i]=-1; &#125; else mp[0][i]=0; &#125; scanf(&quot;%s&quot;,ch); for(int i=0; i&lt;n; i++) &#123; if(ch[i]==&apos;X&apos;) &#123; s[1].insert(i); mp[1][i]=-1; &#125; else mp[1][i]=0; &#125; for(int i=0; i&lt;m; i++) &#123; int a,b; int p=0,sum=0; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); a--; b--; if(a%n&gt;b%n)swap(a,b); int ka=a/n,va=a%n,kb=b/n,vb=b%n; if(mp[ka][va]==-1||mp[kb][vb]==-1)sum=-1; else &#123; set&lt;int&gt;::iterator ite; ite=s[ka].upper_bound(va); if(ite!=s[ka].end())p=*ite; else p=INF; while(p&lt;=vb) &#123; sum+=p-va; ka=!ka; va=p-1; if(mp[ka][va]==-1) &#123; sum=-1; break; &#125; ite=s[ka].lower_bound(p); if(ite!=s[ka].end())p=*ite; else p=INF; if(p-1==va) &#123; sum=-1; break; &#125; &#125; if(sum!=-1) &#123; sum+=vb-va; if(kb!=ka)sum+=1; &#125; &#125; printf(&quot;%d\n&quot;,sum); &#125; &#125; return 0;&#125; C È¢ò CSU 2130 C(2130):Permutations Submit Page Summary Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 57 Solved: 20 Description ÁªôÂÆö‰∏§‰∏™1~nÁöÑÊéíÂàóA, B„ÄÇÊØèÊ¨°ÂèØ‰ª•ÊääAÁöÑÊúÄÂêé‰∏Ä‰∏™Êï∞ÂèñÂá∫ÔºåÊèíÂÖ•Âà∞AÁöÑ‰ªª‰Ωï‰∏Ä‰∏™‰ΩçÁΩÆÔºàÊúÄÂâçÈù¢ÊàñËÄÖ‰ªª‰Ωï‰∏§‰∏™Êï∞‰∏≠Èó¥Ôºâ„ÄÇÈóÆÊúÄÂ∞ëÂá†Ê¨°ÂèØ‰ª•ÊääAËΩ¨Âåñ‰∏∫B„ÄÇ Input Á¨¨‰∏ÄË°å‰∏∫‰∏Ä‰∏™Êï¥Êï∞n„ÄÇÁ¨¨‰∫åË°å‰∏∫1~nÁöÑ‰∏Ä‰∏™ÊéíÂàóÔºåË°®Á§∫A„ÄÇÁ¨¨‰∏âË°å‰∏∫1~nÁöÑ‰∏Ä‰∏™ÊéíÂàóÔºåË°®Á§∫B„ÄÇ Output ‰∏Ä‰∏™Êï¥Êï∞Âç≥ÊúÄÂ∞ëÊìç‰ΩúÊ¨°Êï∞„ÄÇ Sample Input 5 1 5 2 3 4 1 2 3 4 5 Sample Output 3 Hint 30%Ôºön &lt;=100 50%Ôºön &lt;=1000 100%: n &lt;= 200000 ÊúÄÂâçÈù¢È°∫Â∫èÊ≠£Á°ÆÁöÑÂ∞±ÊòØ‰∏çÁî®ÂèòÊç¢ÁöÑÔºåÊâÄ‰ª•Áõ¥Êé•ÂáèÂéªÂ∞±Ë°å‰∫Ü„ÄÇ„ÄÇ„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define pi acos(-1.0)#define e 2.718#define lowbit(x) (x&amp;(-x))using namespace std;typedef unsigned long long ull;typedef long long ll;const int N=4e5+9;const long long mod=1e9+7;const int maxn=1e7+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;int a[maxn],b[maxn];map&lt;int,int &gt; m;int main() &#123; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; for(int i=0; i&lt;n; i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d&quot;,&amp;b[i]); m[b[i]]=i; &#125; int k=m[a[0]],ans=1; for(int i=1; i&lt;n; i++) &#123; if(m[a[i]]&gt;k) &#123; ans++; k=m[a[i]]; &#125; else break; &#125; cout&lt;&lt;n-ans&lt;&lt;endl; &#125; return 0;&#125; H È¢ò H(2135):Appositive BodySubmitPage Summary Time Limit: 10 Sec Memory Limit: 512 Mb Submitted: 29 Solved: 7 DescriptionYuki Nagato is an aliencreated by the Data Overmind, and possesses supernatural powers as a result.Two of her abilities are to observe the universe and to transcend time and space. As we know, it is unstable ofthe universe if there are more than one active bodies which are actually thesame individual at the same time. Nagato defines them as _appositivebodies_. Of course, Nagato can tell whether there are any appositivebodies of one as soon as she observes. Now, you become able totravel through time and space by some special chance. But before taking action,you have to make sure you won‚Äôt destabilize the universe, so you can ask Nagatofor some help, including whether there is an appositive body of you at yourdestination. However, it is inconvenient to make a request every time, so youdecide to study this method. At this time, you are able todescribe the universe abstractly, with several points in a 4-dimension vector,which are the space rectangular coordinates _x_, _y_ and _z_,and the time _t_. After filtered, these points seem to bein alignment. What you need to do now is to check whether these points arecentrosymmetric in four dimensional space. If they are, it means there is yourappositive body at your destination. InputInput consists of severaltest cases, for each test case: First line: a integer _n_ (1 ‚â§ _n_ ‚â§ 107), the count ofpoints. Next _n_ lines:each line has four integers _x_, _y_, _z_, _t_ (‚àí108 ‚â§ _x_, _y_, _z_, _t_ ‚â§ 108), the coordinate of apoint. OutputFor each test case, output aline: if these points are centrosymmetric in four dimensional space, output‚Äùexist‚Äù. Otherwise, output ‚Äúnot exist‚Äù. Sample Input14 10 0 0 0 1-1 0 3 4 14 8 2 2 15 8 -1 -2 13 10 0 0 0 11 1 1 1 11 1 1 1 14 10 0 0 0 11 1 1 1 11 1 1 1 10 0 0 0 Sample Output1exist 1not exist 1exist Êéí‰∏™Â∫èÔºåÁÑ∂Âêé Âà§Êñ≠ Á¨¨ I ‰∏™ Âä†‰∏ä N-I-1‰∏™ÁöÑxyzt,ÊòØ‰∏çÊòØÂÖ®ÈÉ®Á≠â‰∫é2ËÉåÂπ≥ÂùáÊï∞Â∞±Ë°å Êö¥Âäõ„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define pi acos(-1.0)#define e 2.718#define lowbit(x) (x&amp;(-x))using namespace std;typedef unsigned long long ull;typedef long long ll;const int N=4e5+9;const long long mod=1e9+7;const int maxn=1e7+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;struct four &#123; double x,y,z,t;&#125; f[maxn];bool cmp(const four &amp;a,const four &amp;b) &#123; if(a.t==b.t) &#123; if(a.x==b.x) &#123; if(a.y==b.y) &#123; return a.z&lt;b.z; &#125; else return a.y&lt;b.y; &#125; else return a.x&lt;b.x; &#125; else return a.t&lt;b.t;&#125;long double cl(long double t)&#123; return t*2/n;&#125;int main() &#123; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; long double x,y,z,t; x=y=z=t=0; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%lf%lf%lf%lf&quot;,&amp;f[i].x,&amp;f[i].y,&amp;f[i].z,&amp;f[i].t); x+=f[i].x; y+=f[i].y; z+=f[i].z; t+=f[i].t; &#125; x=cl(x); y=cl(y); z=cl(z); t=cl(t);// cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;t&lt;&lt;endl; int flag=1; sort(f,f+n,cmp); for(int i=0; i&lt;=(n-1)/2; i++) &#123; if(abs(f[i].x+f[n-i-1].x-x)&gt;eps|| abs(f[i].y+f[n-i-1].y-y)&gt;eps|| abs(f[i].z+f[n-i-1].z-z)&gt;eps|| abs(f[i].t+f[n-i-1].t-t)&gt;eps)&#123; flag=0; &#125; &#125; puts(flag?&quot;exist&quot;:&quot;not exist&quot;); &#125; return 0;&#125; IÈ¢ò I(2136):ÁªüÂ∏Ö‰∏âÂÜõ! Submit Page Summary Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 7 Solved: 1 Description WellsÊúÄËøëËø∑‰∏ä‰∫Ü‰∏ÄÊ¨æÊîªÂüéÁöÑÁ≠ñÁï•Ê∏∏ÊàèÔºåÁÇπÂ∞±ÂéªÂ∞±ËÉΩÂΩìÂ§ßÂÖÉÂ∏ÖÁªüÂ∏Ö‰∏âÂÜõÔºÅ Ê∏∏ÊàèÁïåÈù¢‰∏ªË¶ÅÊòØ‰∏Ä‰∏™Âπ≥Èù¢(ÂùêÊ†áÂèØ‰ª•‰∏∫ÊµÆÁÇπÊï∞)ÔºåÁÑ∂ËÄåWellsÂèëÁé∞ËøôÊ∏∏ÊàèÊòØ‰∏™È™óÂ±ÄÔºåÂÖ∂ÂÆûÂè™Áªô‰∫Ü‰∏Ä‰∏™ÂÜõÈòü„ÄÇ WellsÂàùÂßãÊúâ‰∏Ä‰∏™ÂÜõÈòüÔºå‰ªÖÂåÖÂê´n‰∏™Â£´ÂÖµÔºåÊØè‰∏™Â£´ÂÖµÊúâ‰∏Ä‰∏™ÂàùÂßã‰ΩçÁΩÆÔºàx,yÔºâÂíå‰∏Ä‰∏™Âä≥Á¥ØÊåáÊï∞WiÔºåÊØè‰∏™ÈòüÂëòÂèØ‰ª•ÁßªÂä®ÔºåÊòæÁÑ∂ÂØπ‰∫éÊØè‰∏™ÈòüÂëòÁöÑÁßªÂä®ÊòØÈúÄË¶ÅÊ∂àËÄó‰∏Ä‰∫õ‰ΩìÂäõÁöÑÔºåËã•Á¨¨i‰∏™ÈòüÂëò‰ªé‰ΩçÁΩÆÔºàx1,y1ÔºâÁßªÂä®Âà∞Ôºàx2,y2ÔºâÁöÑ‰ΩìÂäõÊ∂àËÄó‰∏∫Wi*(|x2-x1|+|y2-y1|)„ÄÇ WellsÂ∏åÊúõÂÖàÂ∞ÜÈòü‰ºçÈõÜÂêàËµ∑Êù•Ôºå‰∏îÂ∏åÊúõÊï¥‰∏™Èòü‰ºç‰∏ÄÊ¨°ÈõÜÂêàÁöÑ‰ΩìÂäõÊ∂àËÄóË∂äÂ∞ëË∂äÂ•Ω„ÄÇÊòæÁÑ∂ËÉΩÈáèÊ∂àËÄóÁöÑÂ§öÂ∞ëÁõ¥Êé•ÂèñÂÜ≥‰∏éWellsÂØπ‰∫é‰ºöÂíåÁÇπÔºàx,yÔºâÁöÑÈÄâÊã©ÔºåÁÑ∂ËÄåWellsÂ§™Êáí‰∫ÜÔºåÂ∏åÊúõ‰Ω†Â∏Æ‰ªñÊâæÂá∫Êüê‰∏™Êó∂ÂàªÁöÑÊúÄ‰Ω≥‰ºöÂíåÁÇπ„ÄÇ Input ÂØπ‰∫éÊØèÁªÑÊï∞ÊçÆÔºö Á¨¨‰∏ÄË°åÔºö‰∏Ä‰∏™Êï¥Êï∞NÔºåË°®Á§∫Â£´ÂÖµÊï∞ÁõÆ„ÄÇ Á¨¨‰∫åË°åÔºö‰∏ÄÂÖ±N‰∏™Êï¥Êï∞ÔºåÂÖ∂‰∏≠ÁöÑÁ¨¨i‰∏™Êï∞WiË°®Á§∫Á¨¨i‰∏™ÈòüÂëòÁöÑÂä≥Á¥ØÊåáÊï∞„ÄÇ(N&lt;=106)(N&lt;=106) Êé•‰∏ãÊù•NË°åÔºöÊØè‰∏ÄË°å‰∏§‰∏™Êï¥Êï∞XÂíåYÔºåË°®Á§∫Á¨¨i‰∏™Â£´ÂÖµÁöÑÂΩìÂâçÁöÑÊ®™ÂùêÊ†áÂíåÁ∫µÂùêÊ†á„ÄÇ(‚àí109&lt;=X,Y&lt;=109)(‚àí109&lt;=X,Y&lt;=109) Output ‰∏Ä‰∏™ÂÆûÊï∞„ÄÇË°®Á§∫ÊâÄÊúâÈòüÂëòÈõÜÂêàÂà∞ÊúÄ‰Ω≥ÊîªÂáª‰ΩçÁΩÆÁöÑ‰ΩìÂäõÊ∂àËÄóÊÄªÂíåÔºåÁ≠îÊ°à‰øùÁïô‰∏§‰ΩçÂ∞èÊï∞„ÄÇ Sample Input 1 1 0 0 Sample Output 0.00 I ËøôÈ¢òÊØîËæÉÊØíÁò§ÔºåÂÜô‰∫ÜÂçäÂ§©‰∏âÂàÜÂèëÁé∞Á≤æÂ∫¶ÊúâÈóÆÈ¢òÔºåÂêéÊù•‰ªîÁªÜÊÉ≥‰∫Ü‰∏ãÔºåÊ†πÊú¨‰∏çÂèØËÉΩÊòØÂ∞èÊï∞Ôºå ‰ªñÊ±ÇÁöÑÊòØÊõºÂìàÈ°øË∑ùÁ¶ªÔºåÂèØ‰ª•ÊääXÔºåYÂàÜÂºÄÁÆó„ÄÇ ‰ªéÂ∑¶ÂæÄÂè≥Ëµ∞Âà∞Êüê‰∏™ÁÇπ Â∑¶ËæπÁöÑW &gt; Âè≥ËæπWÁöÑÂíåÂ∞±ÂèØ‰ª•‰∫ÜÔºåÈÇ£‰∏™Êó∂ÂÄôÁªùÂØπÂ∞±ÊòØ‰∏¥ÁïåÂÄº Âõ†‰∏∫ÂÜçÂæÄÂ∑¶Ëµ∞‰∏ÄÂÆöÊòØÂ¢ûÁöÑÊØîÂáèÁöÑÂ∞ë YËΩ¥‰πüÊòØÂêåÁêÜ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define pi acos(-1.0)#define e 2.718#define lowbit(x) (x&amp;(-x))using namespace std;typedef unsigned long long ull;typedef long long ll;const int N=4e5+9;const long long mod=1e9+7;const int maxn=1e7+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n;struct P&#123; int x,w,y;&#125;p[maxn];bool cmp(const P &amp; a,const P &amp; b)&#123; return a.x&lt;b.x;&#125;bool cmp2(const P &amp;a,const P &amp; b)&#123; return a.y&lt;b.y;&#125;long long jsx(int l)&#123; long long s1=0,s2=0; for(int i=0;i&lt;n;i++) &#123; s1+=abs(p[i].w*(p[i].x-p[l].x)); &#125; for(int i=0;i&lt;n;i++) &#123; s2+=abs(p[i].w*(p[i].x-p[l-1].x)); &#125; return min(s1,s2);&#125;long long jsy(int l)&#123; long long s1=0,s2=0; for(int i=0;i&lt;n;i++) &#123; s1+=abs(p[i].w*(p[i].y-p[l].y)); &#125; for(int i=0;i&lt;n;i++) &#123; s2+=abs(p[i].w*(p[i].y-p[l-1].y)); &#125; return min(s1,s2);&#125;int main() &#123; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;p[i].w); long long aw=0; for(int i=0;i&lt;n;i++) &#123; scanf(&quot;%d%d&quot;,&amp;p[i].x,&amp;p[i].y); aw+=p[i].w; &#125; sort(p,p+n,cmp); long long l=0,r=aw-p[0].w,sum=0; for(int i=1;i&lt;n;i++) &#123; l+=p[i-1].w; r-=p[i].w; if(r&lt;=l) &#123; sum+=jsx(i); break; &#125; &#125; sort(p,p+n,cmp2); l=0;r=aw-p[0].w; for(int i=1;i&lt;n;i++) &#123; l+=p[i-1].w; r-=p[i].w; if(r&lt;=l) &#123; sum+=jsy(i); break; &#125; &#125; printf(&quot;%lld.00\n&quot;,sum); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÊúÄÂ∞èÁîüÊàêÊ†ëPrim&&Kruskal ÁÆóÊ≥ï ËØ¶ÁªÜÁ¨îËÆ∞]]></title>
    <url>%2F2018%2F06%2F06%2F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91Prim%26%26Kruskal%20%E7%AE%97%E6%B3%95%20%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[POJ 1258 Agri-Net http://poj.org/problem?id=1258Ôºõ ‰∏§ÁßçÁÆóÊ≥ï Prim Kruskal. ÂÖàËØ¥Prim ÂàùÂßãÂåñ ÊùÉÂÄºÔºåÈöè‰æø‰∏Ä‰∏™È°∂ÁÇπÂÅöËµ∑ÁÇπÔºå‰∏∫0 ÂÖ∂ÂÆÉÁöÑ‰∏∫ÊúÄÂ§ßÂÄº„ÄÇ ÊâæÂà∞ÊùÉÂÄºÊúÄÂ∞èÁöÑÈ°∂ÁÇπÔºå‰∏îÊ≤°ÊúâÂä†ÂÖ•ÈõÜÂêà„ÄÇ ÊääÈ°∂ÁÇπÊùÉÂÄºÂä†Âà∞ÁªìÊûúÔºåÊääÂÆöÁÇπÂä†ÂÖ•ÈõÜÂêà„ÄÇ Êö¥ÂäõÊûö‰∏æ È°∂ÁÇπËøûÊé•ÁöÑÊâÄÊúâÁöÑËæπÔºåÊõ¥Êñ∞ÊâÄÊúâËÉΩÂ§üËøûÊé•‰∏äÈ°∂ÁÇπÁöÑÊùÉÂÄº„ÄÇ ÈáçÂ§çÂâç3Ê≠•ÔºåÁõ¥Âà∞ÊâÄÊúâÁÇπÂÖ®ÈÉ®Âä†ÂÖ•ÈõÜÂêà„ÄÇ ‰ª•‰∏äÂõæÂ∞±ÊòØ È¶ñÂÖàÊâæÂà∞ÁöÑÊòØ 0ËäÇÁÇπ ‰∏ÄÂºÄÂßãÊùÉÂÄºÊòØ0ÔºåÊâÄ‰ª•res +=0ÔºõÁÑ∂ÂêéÊö¥ÂäõÊâÄÊúâËÉΩÂ§üËøûÊé•ÁöÑÁÇπÂ∞±ÊòØ 1ÔºåÂíå2Ôºå ÁÑ∂ÂêéÊõ¥Êñ∞ mincost[2]=min(INF,2)ÔºåÁªìÊûúÁ≠â‰∫é2ÔºõÂêåÁêÜ mincost[1]=10; ÂÖ∂ÂÆÉÁÇπÁöÑÊùÉÂÄº‰∏çÂèò„ÄÇ ÁÑ∂ÂêéÂèàÂºÄÂßãÊâæÊâæÂà∞ 2 È°∂ÁÇπÔºåÁÑ∂ÂêéÊö¥ÂäõÊâÄÊúâÁÇπÔºåËøôÊ¨°Êõ¥Êñ∞ÁöÑÂ∞±ÊòØ3 4 5È°∂ÁÇπ„ÄÇÁÑ∂Âêé‰∏çÊñ≠ÈáçÂ§çÂ∞±Ë°å‰∫Ü ÊúÄÂêéËøûÊé•Ëµ∑Êù•ÁöÑÊ†ëÊòØËøô‰∏™Ê†∑Â≠êÁöÑ„ÄÇ ‰∏ãÈù¢ÊòØ‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxv=1e3+25; //ÊúÄÂ§ßÈ°∂ÁÇπÊï∞const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int cost[maxv][maxv]; // cost[u][v] Ë°®Á§∫ u Âà∞ v ÁöÑÊùÉÂÄºÂ¶ÇÊûúÊ≤°ÊúâËæπÊùÉÂÄº‰∏∫Êó†Á©∑Â§ßÔºàINFÔºâ;int mincost[maxv]; //ÊØè‰∏™ÁÇπÁöÑÊúÄÂ∞èÊùÉÂÄºÔºåËµ∑ÁÇπËá™Â∑±‰∏∫0ÔºåÂÖ∂ÂÆÉ‰∏∫Ëá™Â∑±ËøûÊé•Âà∞ÈõÜÂêàÊúÄÂ∞èÊùÉÂÄºÔºõbool used[maxv]; //Ë°®Á§∫È°∂ÁÇπ ÊòØÂê¶Â∑≤ÁªèËøûÊé•‰∏äÔºõint V; //È°∂ÁÇπÊï∞ÁõÆÔºõint prim() &#123; for(int i=0; i&lt;V; i++) &#123; mincost[i]=INF; //ÂºÄÂßãÁöÑÊó∂ÂÄôÂÖ®ÈÉ®ÂàùÂßãÂåñ‰∏∫Êó†Á©∑Â§ß„ÄÇ used[i]=false; //ÂàùÂßãÂåñ ÔºåÂÖ®ÈÉ®Ê≤°ÊúâËøûÊé•„ÄÇ &#125; mincost[0]=0; //‰ª• 0 ËäÇÁÇπ‰∏∫Ëµ∑ÁÇπÂºÄÂßãËøûÊé•„ÄÇ int res = 0; //ÊùÉÂÄºÂíå while(1) &#123; int v=-1; //ÈÄâÊã©ÁöÑËäÇÁÇπÔºåÂºÄÂßã‰∏∫-1ÔºåÁÑ∂ÂêéÂºÄÂßãÊâæÂ∑≤ÁªèÁ°ÆÂÆöÊòØÊúÄÂ∞èÁöÑË∑ùÁ¶ª for(int u=0; u&lt;V; u++) &#123; if(!used[u]&amp;&amp; (v == -1 || mincost[u]&lt;mincost[v]))v=u; //Â¶ÇÊûú v==-1ÊàñËÄÖ‰∏çÊòØÊúÄÂ∞èË∑ùÁ¶ªÁöÑÊó∂ÂÄôÊõ¥Êñ∞v„ÄÇ &#125; if(v==-1)break; //Âè™ÊúâÂú®ÊâÄÊúâÁöÑÁÇπÈÉΩÂ∑≤ÁªèÂä†ÂÖ•ÈõÜÂêà v==-1„ÄÇË∑≥Âá∫Âæ™ÁéØ„ÄÇ used[v]=true; //ÊääÈ°∂ÁÇπÂä†ÂÖ•ÈõÜÂêà„ÄÇ res+=mincost[v]; //ÊääËæπÁöÑÈïøÂ∫¶Âä†Âà∞ÁªìÊûúÈáå for(int u=0; u&lt;V; u++) &#123; mincost[u]=min(mincost[u],cost[v][u]); //‰ªéÂΩìÂâçÁÇπÂà∞ÂÖ∂ÂÆÉÁÇπÁöÑË∑ùÁ¶ªÂ¶ÇÊûúÊØîÂÖ∂‰ªñË∑ØÁü≠Â∞±Êõ¥Êñ∞„ÄÇ &#125; &#125; return res;&#125;int main() &#123; int m; scanf(&quot;%d%d&quot;,&amp;V,&amp;m); //ËæìÂÖ•È°∂ÁÇπÊï∞ÂíåËæπÊï∞„ÄÇ Ê≥®ÊÑèÂÆöÁÇπÊòØ‰ªé 0 Âà∞V-1„ÄÇ for(int i=0; i&lt;m; i++) &#123; int u,v,w; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); cost[u][v]=cost[v][u]=w; &#125; printf(&quot;%d\n&quot;,prim());//‰∏ãÈù¢ÊòØPOJ 1258 ‰∏ªÁ®ãÂ∫è‰ª£Á†Å„ÄÇ /* while(cin&gt;&gt;V) &#123; for(int i=0; i&lt;V; i++) &#123; for(int j=0; j&lt;V; j++) &#123; cin&gt;&gt;cost[i][j]; &#125; &#125; printf(&quot;%d\n&quot;,prim()); &#125; */ return 0;&#125; Êé•‰∏ãÊù•ÊòØKruskal ‰ª£Á†Å Ëøô‰∏™ÁÆóÊ≥ïÂÖ∂ÂÆûÂíåPrim ÁÆóÊ≥ïÂ∑ÆË∑ù‰∏çÂ§ßÔºåËøô‰∏™ÊòØÁõ¥Êé•ÊääËæπÊéíÂ∫è ÊâæÂà∞ÊúÄÂ∞èÁöÑËæπ Âà§Êñ≠ËæπÁöÑ‰∏§‰∏™ËäÇÁÇπÊòØ‰∏çÊòØËøûÊé•Âà∞Âêå‰∏ÄÈ¢óÊ†ë‰∏äÔºåÊòØË∑≥ËøáÔºå‰∏çÊòØËøûÊé•‰∏§‰∏™È°∂ÁÇπÁöÑÊ†πËäÇÁÇπÔºåÁªìÊûúÂä†‰∏äËæπ„ÄÇ ÈáçÂ§ç‰∏äÈù¢‰∏§Ê≠•ÔºåÁõ¥Âà∞ËøûÊé•N-1Êù°ËæπÔºåÂõ†‰∏∫N‰∏™È°∂ÁÇπË¶ÅN-1Êù°ËæπÂ∞±ËÉΩËøûÊé•Ëµ∑Êù•„ÄÇ ÂØπ‰∫éËøô‰∏™ÂõæÔºåÈ¶ñÂÖàÂ∞±ÊâæÂà∞Ôºà2Ôºå3 ÔºâËøôÊù°ËæπËøûËµ∑Êù•ÔºåÁÑ∂ÂêéÂ∞±ÊòØÔºà4 5ÔºâÔºåÁÑ∂ÂêéÔºà0 2ÔºâÔºåËøôÊó∂ÂÄôÊúâ2Ê£µÊ†ë Ôºà0 2 3 ÔºâÂíåÔºà4 5ÔºâÁÑ∂ÂêéÊé•ÁùÄËøû Ôºà2 5ÔºâÔºà5 6 ÔºâÔºà1 4ÔºâÂ∞±ÂÖ®ÈÉ®ËøûÊé•‰∏ä‰∫Ü ‰ª£Á†Å 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxv=1e3+25; //ÊúÄÂ§ßÈ°∂ÁÇπÊï∞const int maxm=1e6+25; //ÊúÄÂ§ßËæπÊï∞const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int V,m; //È°∂ÁÇπÊï∞ÁõÆÔºõstruct edge &#123; int u,v,cost; //ËäÇÁÇπÁî®Êù• ‰øùÂ≠òÊØè‰∏™ËæπÁöÑÊÉÖÂÜµ&#125;;bool cmp(const edge &amp; a,const edge &amp; b) &#123; return a.cost&lt;b.cost; //Áî®‰∫éÊéíÂ∫èÔºåÁõ∏ÂΩì‰∫éÈáçËΩΩÂ∞è‰∫éÂè∑„ÄÇ&#125;edge es[maxm];int par[maxv]; // par[i]==j. i ÁöÑ Ê†πËäÇÁÇπ‰∏∫ j;int find(int x) &#123; //ÂØªÊâæÊ†πËäÇÁÇπ if(x==par[x])return x; //Â¶ÇÊûúÊ†πËäÇÁÇπÂ∞±ÊòØËá™Â∑±Áõ¥Êé•ËøîÂõûËá™Â∑± else return par[x]=find(par[x]); //Â¶ÇÊûúÊ†πËäÇÁÇπ‰∏çÊòØËá™Â∑±ÔºåÁªßÁª≠ÂØªÊâæËá™Â∑±‰∏ä‰∏Ä‰∏™ËäÇÁÇπÁöÑÊ†πËäÇÁÇπ„ÄÇ&#125;void unit(int x,int y) &#123; x=find(x); //ÊâæÂà∞ x ÁöÑÊ†πËäÇÁÇπ y=find(y); par[x]=y; //Êää x ÁöÑÊ†πËäÇÁÇπ ËøûÊé•‰∏ä y.&#125;void init(int n) &#123; for(int i=0; i&lt;=n; i++)par[i]=i; //ÂàùÂßãÂåñÁöÑÊó∂ÂÄôÊ†πËäÇÁÇπÈÉΩÊòØËá™Â∑±Ôºõ&#125;int Kruskal() &#123; sort(es,es+m,cmp); //Êåâ ËæπÁöÑÊùÉÂÄºÊéíÂ∫èÔºõ init(V); int res=0,se=0; //se ‰øùÂ≠òËæπÊï∞„ÄÇ for(int i= 0; i&lt;m; i++) &#123; edge e =es[i]; if(find(e.u)!=find(e.v)) &#123; //Â¶ÇÊûúÊ†πËäÇÁÇπ‰∏çÁõ∏ÂêåÂ∞±ËøûÊé• unit(e.u,e.v); res+=e.cost; if(++se==V-1)return res; //Â¶ÇÊûúËøû‰∫ÜV-1Êù°ËæπÂ∞±Ë∑≥Âá∫Ôºõ &#125; &#125; return res;&#125;int main() &#123; scanf(&quot;%d%d&quot;,&amp;V,&amp;m); //ËæìÂÖ•È°∂ÁÇπÊï∞ÂíåËæπÊï∞„ÄÇ Ê≥®ÊÑèÂÆöÁÇπÊòØ‰ªé 0 Âà∞V-1„ÄÇ for(int i=0; i&lt;m; i++) &#123; int u,v,w; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); es[i].u=u; es[i].v=v; es[i].cost=w; &#125; printf(&quot;%d\n&quot;,Kruskal()); // POJ 1285 AC ‰∏ªÁ®ãÂ∫è‰ª£Á†Å /* while(cin&gt;&gt;V) &#123; int k=0; for(int i=0; i&lt;V; i++) &#123; for(int j=0; j&lt;V; j++) &#123; cin&gt;&gt;es[k].cost; es[k].u=i; es[k].v=j; k++; &#125; &#125; m=k; printf(&quot;%d\n&quot;,Kruskal()); &#125;*/ return 0;&#125;]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÁâõÂÆ¢ÁªÉ‰π†Ëµõ19]]></title>
    <url>%2F2018%2F06%2F04%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B19%2F</url>
    <content type="text"><![CDATA[ÈìæÊé•Ôºöhttps://www.nowcoder.com/acm/contest/111/AÊù•Ê∫êÔºöÁâõÂÆ¢ÁΩë Êó∂Èó¥ÈôêÂà∂ÔºöC/C++ 1ÁßíÔºåÂÖ∂‰ªñËØ≠Ë®Ä2ÁßíÁ©∫Èó¥ÈôêÂà∂ÔºöC/C++ 524288KÔºåÂÖ∂‰ªñËØ≠Ë®Ä1048576K64bit IO Format: %lld È¢òÁõÆÊèèËø∞ ‰Ωú‰∏∫ÊïÖ‰∫ã‰∏ªËßíÁöÑÊâòÁ±≥ÊòØ‰∏ÄÂêçËÄÅÂ∏à„ÄÇ ‰∏ÄÂ§©Ôºå‰ªñÊ≠£Âú®‰∏∫Ëß£ÊûêÁÆóÊúØË°®ËææÂºèÁöÑËØæÁ®ãÂáÜÂ§áËØæ‰ª∂„ÄÇ Âú®ËØæÁ®ãÁöÑÁ¨¨‰∏ÄÈÉ®ÂàÜÔºå‰ªñÂè™ÊÉ≥‰∏ìÊ≥®‰∫éËß£ÊûêÊã¨Âè∑„ÄÇ ‰ªñ‰∏∫‰ªñÁöÑÂ≠¶ÁîüÂèëÊòé‰∫Ü‰∏Ä‰∏™ÊúâË∂£ÁöÑÊ≠£Á°ÆÊã¨Âè∑Â∫èÂàóÁöÑÂá†‰ΩïË°®Á§∫ÔºåÂ¶Ç‰∏ãÂõæÊâÄÁ§∫: Âá†‰ΩïË°®Á§∫ÁöÑÂÆö‰πâÔºö 1. ÂØπ‰∫é‰∏Ä‰∏™Êã¨Âè∑Â∫èÂàóAÔºåÊàë‰ª¨ÂÆö‰πâg(A)ÊòØAÁöÑÂá†‰ΩïË°®Á§∫ÂΩ¢Âºè,Âàô ‚Äú()‚ÄùÁöÑË°®Á§∫ÊòØ‰∏Ä‰∏™1*1ÁöÑÊñπÂùóÔºåÈ´òÂ∫¶‰∏∫1; 2.ÂØπ‰∫é‰∏Ä‰∏™Êã¨Âè∑Â∫èÂàóAÔºå‚Äù(A)‚ÄùÁöÑË°®Á§∫ÊòØÁî±‰∏Ä‰∏™ÊØîg(A)ÂÆΩ2‰∏™Âçï‰ΩçÈ´ò1‰∏™Âçï‰ΩçÁöÑÁü©ÂΩ¢ÂåÖÂõ¥g(A)ÔºåÂÆÉÁöÑÈ´òÂ∫¶‰∏∫A+1;3.ÂØπ‰∫é‰∏§‰∏™Êã¨Âè∑Â∫èÂàóAÂíåBÔºåA+BÁöÑÂá†‰ΩïË°®Á§∫ÂΩ¢Âºè‰∏∫Êääg(B)ÊîæÁΩÆÂú®g(A)Âè≥ËæπÁöÑ‰∏Ä‰∏™Âçï‰ΩçÔºå‰∏îÈ´òÂ∫¶‰∏∫AÂíåBÁöÑÈ´òÂ∫¶ÁöÑËæÉÂ§ßÂÄº„ÄÇÂÖ∂‰∏≠+ÊåáÁöÑÊòØÂ≠óÁ¨¶‰∏≤ÁöÑËøûÊé•Á¨¶„ÄÇ Âú®ÂÆåÊàêËØæ‰ª∂ÂêéÔºåÊâòÁ±≥ËÄÅÂ∏àÂºÄÂßãÁé©‰ªñÂÅöÂ•ΩÁöÑÂõæÁâá„ÄÇ ‰ªñÂ∞ÜÂõæÂÉèÁöÑÊúâÈôêÂå∫Âüü‰∫§ÊõøÂú∞Ê∂ÇÊàêÈªëËâ≤ÂíåÁôΩËâ≤Ôºå‰ΩøÊúÄÂ§ñÈù¢ÁöÑÂå∫ÂüüÂÖ®ÈÉ®Ê∂ÇÊàêÈªëËâ≤„ÄÇ ÂØπ‰∫é‰∏äÈù¢ÁöÑ‰æãÂ≠êÔºåËøô‰∏™ÁùÄËâ≤Â¶Ç‰∏ãÊâÄÁ§∫Ôºö Áé∞Âú®Áªô‰Ω†‰∏Ä‰∏™ÂêàÊ≥ïÁöÑÊã¨Âè∑Â∫èÂàó„ÄÇ ËØ∑ËÆ°ÁÆóÈ¢úËâ≤‰∏∫ÈªëËâ≤ÁöÑÂå∫ÂüüÁöÑÈù¢ÁßØ„ÄÇ ËæìÂÖ•ÊèèËø∞: ËæìÂÖ•ÁöÑÁ¨¨‰∏ÄË°åÂåÖÂê´‰∏Ä‰∏™Êï¥Êï∞TÔºåË°®Á§∫ÊåáÂÆöÊµãËØïÁî®‰æãÁöÑÊï∞Èáè„ÄÇÊØè‰∏™ÊµãËØïÁî®‰æãÂâçÈù¢ÈÉΩÊúâ‰∏Ä‰∏™Á©∫ÁôΩË°å„ÄÇÊØè‰∏™ÊµãËØïÁî®‰æãÁî±‰∏Ä‰∏™ÂêàÊ≥ïÊã¨Âè∑Â∫èÂàóÁªÑÊàê„ÄÇ ÊØèË°åÂè™ÂåÖÂê´Â≠óÁ¨¶‚Äô(‚ÄòÂíå‚Äô)‚Äô„ÄÇ ËæìÂá∫ÊèèËø∞: ÂØπ‰∫éÊØè‰∏™ÊµãËØïÁî®‰æãÔºåËæìÂá∫‰∏ÄË°åÂåÖÂê´‰∏Ä‰∏™Êï¥Êï∞,Ë°®Á§∫Áõ∏Â∫îÂá†‰ΩïË°®Á§∫ÁöÑÈªëËâ≤ÈÉ®ÂàÜÁöÑÈù¢ÁßØ„ÄÇ Á§∫‰æã1 ËæìÂÖ• Â§çÂà∂ 2 ((())) (())(()(())) ËæìÂá∫ Â§çÂà∂ 10 20 ËØ¥Êòé Á¨¨‰∫å‰∏™ÊµãËØïÊ°à‰æãÊòØ‰∏äÂõæ‰∏≠ÊòæÁ§∫ÁöÑÊ°à‰æã„ÄÇ Â§áÊ≥®: 1‚â§T‚â§10 ‰∏Ä‰∏™ÂêàÊ≥ïÊã¨Âè∑Â∫èÂàóÈïøÂ∫¶‚â§4 x 105 ËøôÈ¢ò‰∏ªË¶ÅÊòØÂ§ÑÁêÜ‰∏â‰∏™ÈóÆÈ¢ò ‰∏Ä‰∏™ÊòØÈïøÊñπ‰ΩìÁöÑÈ´òÂ∫¶Ôºå‰∏Ä‰∏™ÈïøÂ∫¶ÔºåÁôΩËâ≤ËøòÊòØÈªëËâ≤„ÄÇ È¶ñÂÖàÈ¢ÑÂ§ÑÁêÜÔºåÈ¢úËâ≤ÔºåÂíåÈ´òÂ∫¶ È¢úËâ≤ÔºåÂà§Êñ≠ÊòØÁ¨¨Âá†‰∏™Â•áÂÅ∂Â∞±Ë°å‰∫ÜÔºåÁ¨¨‰∏Ä‰∏™ËÇØÂÆöÊòØÈªëËâ≤ÔºåÁ¨¨‰∫å‰∏™Â∞±ÊòØÁôΩËâ≤„ÄÇ Ê≥®ÊÑèÂ§ÑÁêÜÁöÑÊó∂ÂÄôÊØèÂåπÈÖç‰∏Ä‰∏™‚Äô)‚Äô Êï∞ÈáèÂ∞±Ë¶ÅÂáè1Ôºõ ÈïøÊñπ‰ΩìÁöÑÈ´òÔºåÁî®‰∏ÄÊ£µÊ†ëÂ∞±Ë°å‰∫ÜÔºåÁÑ∂ÂêéÊØè‰∏™‚ÄòÔºà‚ÄôÁöÑÂ∫¶Â∞±ÊòØÊØè‰∏™ÈïøÊñπÂΩ¢ÁöÑÈ´òÂ∫¶„ÄÇ ÈïøÂ∫¶ÂÆπÊòìÂ§ÑÁêÜ Áõ¥Êé•ÊâæÂà∞ÂåπÈÖçÁöÑÊã¨Âè∑Áõ¥Êé•Ë∑ùÁ¶ª -1 Â∞±ÊòØÈïøÊñπ‰ΩìÈïøÂ∫¶ ÊàëÁî®Ê†àÊù•‰øùÂ≠ò ‚ÄòÔºà‚ÄôÁöÑ‰ΩçÁΩÆ„ÄÇ ÈÅáËßÅ‚Äô(‚ÄôÂéãÂÖ•Ê†à ÔºåÈÅáËßÅ‚Äò)‚ÄôÂºπÂá∫ ÔºåËÆ°ÁÆóË∑ùÁ¶ª„ÄÇÂ¶ÇÊûúÊòØÁôΩËâ≤Â∞±ÊòØÂáèÂéªËøô‰∏™ÈïøÊñπÂΩ¢ÁöÑÈù¢ÁßØÔºåÈªëËâ≤Â∞±Âä†‰∏ä„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxn=1e7+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int a[maxn];int p[maxn],b[maxn];char ch[maxn];int n;stack&lt;int&gt; s;int main() &#123; scanf(&quot;%d&quot;,&amp;n); while(n--) &#123; scanf(&quot;%s&quot;,ch); int l=strlen(ch); a[0]=1; int x=1,y=0; p[0]=-1; b[0]=1; int k=0; for(int i=1; i&lt;l; i++) &#123; if(ch[i]==&apos;(&apos;) &#123; a[i]=a[i-1]+1; p[i]=k; k=i; b[k]=1; &#125; else &#123; b[p[k]]=max(b[p[k]],b[k]+1); k=p[k]; a[i]=a[i-1]-1; &#125; &#125;// for(int i=0;i&lt;l;i++)// printf(&quot;%d%c&quot;,b[i],i+1==l?&apos;\n&apos;:&apos; &apos;); long long flag=1,sum=0; for(int i=0; i&lt;l; i++) &#123; if(ch[i]==&apos;(&apos;) &#123; s.push(i); &#125; else &#123; int k=s.top(); s.pop(); if(a[k]%2==1)sum=sum+(i-k)*(b[k]); else sum-=(i-k)*(b[k]); &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125; DÔºö ÈìæÊé•Ôºöhttps://www.nowcoder.com/acm/contest/111/DÊù•Ê∫êÔºöÁâõÂÆ¢ÁΩë Êó∂Èó¥ÈôêÂà∂ÔºöC/C++ 1ÁßíÔºåÂÖ∂‰ªñËØ≠Ë®Ä2ÁßíÁ©∫Èó¥ÈôêÂà∂ÔºöC/C++ 524288KÔºåÂÖ∂‰ªñËØ≠Ë®Ä1048576K 64bit IO Format: %lld È¢òÁõÆÊèèËø∞ Ê≠§Êó∂ÁöÑÊâòÁ±≥ËÄÅÂ∏àÂ∑≤ÁªèÂá∫‰ªªCEOÔºåËøéÂ®∂ÁôΩÂØåÁæéÔºåËµ∞Âêë‰∫Ü‰∫∫ÁîüÂ∑ÖÂ≥∞ÔºÅ‰∫éÊòØËøô‰∏™ÊöëÂÅáÔºåÊâòÁ±≥ËÄÅÂ∏àÊâìÁÆóÂú®Âåó‰∫¨‰∏Ä‰∏™ÂÅèÂÉªÁöÑÂ∞èÂÜúÊùëÈáåÂ∫¶Ëøá‰ªñÁöÑÂÅáÊúü„ÄÇ Áî±‰∫éËøôÈáå‰ªÄ‰πàÈÉΩÊ≤°ÊúâÔºå‰∫éÊòØ‰ªñÂéªË∂ÖÂ∏ÇÈÄâ‰∫ÜÂæàÂ§öÁîüÊ¥ªÁî®ÂìÅÔºåÊõ¥Â§öÁöÑÊòØÂêÉÁöÑÔºåÁÑ∂ÂêéÊé®ÁùÄÂ†ÜÊª°Èõ∂È£üÁöÑË¥≠Áâ©ËΩ¶Âà∞ÊüúÂè∞Á≠âÂæÖÁªìË¥¶„ÄÇ ÂΩìÁÑ∂ÔºåÊàë‰ª¨ÈÉΩÁü•ÈÅì‰ªñÁöÑÈí±ÂåÖÈáåÊúâÂæàÂ§öÈí±„ÄÇ‰ΩÜÊòØÔºå‰Ωú‰∏∫‰∏ÄÂêç‰∏∫ÁîüÊ¥ªÁ≤æÊâìÁªÜÁÆóÁöÑÁî∑Â≠©Â≠êÔºå‰ªñÊõ¥ÊÑøÊÑè‰ΩøÁî®ÂÖ∂‰ªñÊîØ‰ªòÊñπÂºèÂ¶ÇÔºöÈ•≠Âà∏ÔºåÁ§ºÂà∏Ôºå‰∏çÂêåÁ±ªÂûãÁöÑ‰ºòÊÉ†Âà∏Á≠â„ÄÇ‰ΩÜÊòØÈ•≠Âà∏Âè™ËÉΩÁî®‰∫éË¥≠‰π∞È£üÁâ©ÔºåËÄåÁ§ºÂà∏ÈÄöÂ∏∏Âè™Èôê‰∫éÊüêÁßçÁ±ªÂûãÁöÑÁ§ºÁâ©„ÄÇ Áé∞Âú®Áªô‰Ω†ÊâòÁ±≥Ë¥≠Áâ©ËΩ¶‰∏≠Áâ©ÂìÅÁöÑÊï∞ÈáèNÂíåÊØè‰ª∂Áâ©ÂìÅÁöÑ‰ª∑Ê†º„ÄÇ‰πü‰ºöÁªôÂá∫‰ªñÈí±ÂåÖ‰∏≠ÁöÑ‰ª£ÈáëÂà∏Êï∞ÈáèM‰ª•ÂèäÂÖÅËÆ∏‰ΩøÁî®ÁöÑ‰ø°ÊÅØ „ÄÇ Âú®‰∏∫‰ªñÁöÑË¥≠Áâ©‰ªòÊ¨æÊó∂ÔºåÊâòÁ±≥ÂèØËÉΩ‰ΩøÁî®‰ª£ÈáëÂà∏ÁöÑÈáëÈ¢ùË∂ÖËøá‰ªñÊâÄË¥≠Áâ©ÂìÅÁöÑÊàêÊú¨„ÄÇ‰πüÂèØ‰ª•Âú®Â§öÂº†‰ª£ÈáëÂà∏‰πãÈó¥ÊãÜÂàÜÂïÜÂìÅÁöÑÊàêÊú¨ÔºåÂπ∂‰ΩøÁî®‰ª£ÈáëÂà∏ÊîØ‰ªòÂ§ö‰ª∂ÂïÜÂìÅ„ÄÇ ËØ∑‰Ω†ËÆ°ÁÆóÊâòÁ±≥ÈúÄË¶Å‰∏∫Ë¥≠Áâ©ÊîØ‰ªòÁöÑÈ¢ùÂ§ñÁé∞ÈáëÁöÑÊúÄÂ∞èÈáëÈ¢ù„ÄÇ ËæìÂÖ•ÊèèËø∞:1ËæìÂÖ•ÁöÑÁ¨¨‰∏ÄË°åÂåÖÂê´‰∏Ä‰∏™Êï¥Êï∞TÔºåÁî®‰∫éÊåáÂÆöÊµãËØïÁî®‰æãÁöÑÊï∞Èáè„ÄÇ ÊØè‰∏™ÊµãËØïÁî®‰æãÂâçÈù¢ÈÉΩÊúâ‰∏Ä‰∏™Á©∫ÁôΩË°å„ÄÇ ÊØè‰∏™ÊµãËØïÁî®‰æã‰ªéÂåÖÂê´‰∏§‰∏™Ê≠£Êï¥Êï∞N(Áâ©ÂìÅÊï∞Èáè)ÂíåM(Âà∏Êï∞Èáè)ÁöÑË°åÂºÄÂßã„ÄÇ Êé•‰∏ãÊù•‰∏ÄË°åÂåÖÂê´N‰∏™Êï∞Â≠óÔºåÁ¨¨i‰∏™Êï∞Â≠óË°®Á§∫ÊâòÁ±≥Ë¥≠Áâ©ËΩ¶ÈáåÁ¨¨i‰ª∂Áâ©ÂìÅÁöÑ‰ª∑Ê†º„ÄÇ Êé•‰∏ãÊù•‰∏ÄË°åÂåÖÂê´M‰∏™Êï∞Â≠óÔºåÁ¨¨i‰∏™Êï∞Â≠óË°®Á§∫Á¨¨iÂº†Âà∏ÁöÑÈáëÈ¢ù„ÄÇ Êé•‰∏ãÊù•ÊúâMË°åÔºåÂΩì‰∏≠ÁöÑÁ¨¨ i Ë°åÊèèËø∞Á¨¨ i Âº†Âç∑ÂèØ‰ª•‰π∞Âì™‰∫õÂïÜÂìÅ„ÄÇÊØèË°åÁöÑÁ¨¨‰∏Ä‰∏™Êï∞Â≠óÊòØ K,‰ª£Ë°®Á¨¨ i Âº†Âç∑ÂèØ‰ª•‰∏∫ K ‰ª∂ÂïÜÂìÅ‰ªòÊ¨æÔºåÊé•‰∏ãÊù•ËøòÊúâ K ‰∏™Êï∞ÔºåÊòØËøô K ‰ª∂ÂïÜÂìÅÁöÑÁºñÂè∑ ËæìÂá∫ÊèèËø∞:1ÂØπ‰∫éÊØè‰∏™ÊµãËØïÁî®‰æãËæìÂá∫Êï∞Â≠óÔºåË°®Á§∫ÊâòÁ±≥ÈúÄË¶ÅÊîØ‰ªòÂ§öÂ∞ëÁé∞Èáë„ÄÇ ÊúÄÂ§ßÊµÅÊ®°ÊùøÈ¢ò 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxn=2e2+25;const int maxm=4e3+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,m,T;int a[maxn],b[maxm];struct edge &#123; int to,cap,rev;&#125;;vector &lt;edge&gt; G[maxn+maxm];bool used[maxn+maxm];int level[maxn+maxm];int iter[maxn+maxm];void bfs(int s) &#123; memset(level,-1,sizeof(level)); queue&lt;int&gt; que; level[s]=0; que.push(s); while(!que.empty()) &#123; int v= que.front(); que.pop(); for(int i=0; i&lt;G[v].size(); i++) &#123; edge &amp; e=G[v][i]; if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0) &#123; level[e.to]=level[v] + 1; que.push(e.to); &#125; &#125; &#125;&#125;void add(int from,int to,int cap) &#123; edge eg; eg.to=to; eg.cap=cap; eg.rev=G[to].size(); G[from].push_back(eg); eg.to=from; eg.cap=0; eg.rev=G[from].size()-1; G[to].push_back(eg);&#125;//int dfs(int v,int t,int f) &#123;// if(v == t)return f;// used[v]=true;// for(int i = 0; i &lt; G[v].size(); i++) &#123;// edge &amp;e=G[v][i];// if(!used[e.to]&amp;&amp;e.cap&gt;0) &#123;// int d=dfs(e.to,t,min(f,e.cap));// if(d&gt;0) &#123;// e.cap-=d;// G[e.to][e.rev].cap+=d;// return d;// &#125;// &#125;// &#125;// return 0;//&#125;int dfs(int v,int t,int f) &#123; if(v == t)return f; for(int &amp;i = iter[v]; i &lt; G[v].size(); i++) &#123; edge &amp;e=G[v][i]; if(e.cap&gt;0 &amp;&amp; level[v]&lt;level[e.to]) &#123; int d=dfs(e.to,t,min(f,e.cap)); if(d&gt;0) &#123; e.cap-=d; G[e.to][e.rev].cap+=d; return d; &#125; &#125; &#125; return 0;&#125;/*int maxflow(int s,int t) &#123; int flow=0; for(;;) &#123; memset(used,0,sizeof(used)); int f=dfs(s,t,INF); if(f==0)return flow; flow += f; &#125;&#125;*/int maxflow(int s,int t) &#123; int flow=0; for(;;) &#123; bfs(s); if(level[t]&lt;0)return flow; memset(iter,0,sizeof(iter)); int f; while((f = dfs(s,t,INF))&gt;0) &#123; flow +=f; &#125; &#125;&#125;int main() &#123; scanf(&quot;%d&quot;,&amp;T); while(T--) &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int sum=0; for(int i=0;i&lt;=m+n+1;i++)G[i].clear(); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); sum+=a[i]; add(i,n+m+1,a[i]); &#125; for(int j=1; j&lt;=m; j++) &#123; scanf(&quot;%d&quot;,&amp;b[j]); add(0,n+j,b[j]); &#125; for(int i=1; i&lt;=m; i++) &#123; int k; scanf(&quot;%d&quot;,&amp;k); for(int j=0; j&lt;k; j++) &#123; int x; scanf(&quot;%d&quot;,&amp;x); add(n+i,x,a[x]); &#125; &#125; cout&lt;&lt;sum-maxflow(0,n+m+1)&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP]]></title>
    <url>%2F2018%2F05%2F23%2FKMP%2F</url>
    <content type="text"><![CDATA[KMPÁÆóÊ≥ïÔºåÂàöÊé•Ëß¶Âà∞Ëøô‰∏™ÁÆóÊ≥ïÊú¨Êù•‰∏ÄÁúãÊòØÁúã‰∏ÄÁúºÂ∞±‰ºö‰∫ÜÔºå‰ΩÜÊòØËøá‰∫Ü‰∏ÄÊÆµÊó∂Èó¥ÂèçËÄå‰∏ç‰ºö‰∫ÜÔºåÊêûÂæóÊàëÂèàÈáçÊñ∞ÂõûÊù•Â≠¶‰∫Ü‰∏ÄÊ¨°„ÄÇ ÂÖ∂ÂÆûKMPÁÆóÊ≥ïÊå∫ÁÆÄÂçïÁöÑÔºåËøô‰∏™ÁÆóÊ≥ïÁöÑÊ†∏ÂøÉÊàëÊÑüËßâÂ∞±ÊòØÂú®Â§ÑÁêÜnext Êï∞ÁªÑ‰∏ä„ÄÇ ÊàëÂÖàËÆ≤‰∏Ä‰∏ã‰∏ÄÁßçÂ§ÑÁêÜÊñπÂºèÂêßÔºå next [0]=-1,Ëøô‰∏™‰∏çÁî®Â§öËØ¥ÔºåÁ¨¨‰∏Ä‰∏™ËÇØÂÆöÊòØÊ≤°ÊúâÂåπÈÖçÂ•ΩÁöÑ„ÄÇ k=-1; ,i=0‰∏§‰∏™ÂàùÂßãÂåñ Ôºåk,Ë°®Á§∫ÁöÑÊòØÂåπÈÖçÂà∞ÁöÑ‰ΩçÁΩÆ ÔºåiÔºåË°®Á§∫ÁöÑÊòØ‰Ω†Ê≠£Âú®‰∏∫ÈÇ£‰∏™‰ΩçÁΩÆÊ†áËÆ∞next„ÄÇ 123456789101112131415161718192021222324252627282930313233343536 #include&lt;bits/stdc++.h&gt;using namespace std; void getnext(const char * str,int * next) &#123; next[0]=-1; int i=0,k=-1; while(str[i]!=&apos;\0&apos;) &#123; while(k!=-1&amp;&amp;str[i]!=str[k])k=next[k];// Âú®‰Ω†ÂåπÈÖçËøô‰∏™ i ‰πãÂâçÈ¶ñÂÖàÂØªÊâæÂà∞ÂâçÈù¢‰∏Ä‰∏™ÊúÄÂ§ßÂåπÈÖç‰ΩçÁΩÆÔºå //Â¶ÇÊûú ‰∏çÂåπÈÖçÂ∞±‰∏ÄÁõ¥ÂæÄÂâçÈù¢ÂõûÊ∫ØÔºåÁõ¥Âà∞ËÉΩÂ§üÂåπÈÖç„ÄÇ i++; k++; if(str[i]==str[k])next[i]=next[k]; //ÂΩìÂâç‰ΩçÁΩÆÊòØÁõ∏Á≠âÁöÑ Ëøô‰∏™‰∏çÂåπÈÖç ÂêåÊ†∑ KÁöÑ‰ΩçÁΩÆ‰πüÊ≤°Ê≥ïÂåπÈÖçÔºåÊâÄ‰ª• next [i]ÂèØ‰ª•Áõ¥Êé•Á≠â‰∫énext[k]. else next[i]=k; &#125;&#125;int kmp(const char *s,const char * c)&#123; int lc=strlen(c),ls=strlen(s); int *next=new int[lc+1]; getnext(c,next); int j=0,i=0; while(i&lt;ls) &#123; while(j!=-1&amp;&amp;s[i]!=c[j])j=next[j]; i++,j++; if(j==lc)return 1; &#125; return 0;&#125; int main() &#123; int next[1000]; char ch[]=&quot;abaabc&quot;,s[]=&quot;ababaababcb&quot;; cout&lt;&lt;kmp(s,ch)&lt;&lt;endl;&#125;]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DPÂ≠¶‰π†Á¨îËÆ∞ÔºåÈ¢òÁõÆ Traveling by Stagecoach POJ 2686 È¢òËß£]]></title>
    <url>%2F2018%2F05%2F19%2FDP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8C%E9%A2%98%E7%9B%AE%20Traveling%20by%20Stagecoach%20POJ%20%202686%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Traveling by Stagecoach POJ 2686ÔºåÈ¢òËß£„ÄÇ ‰Ωú‰∏∫‰∏ÄÂêçËèúÈ∏üÔºåËØ¥Áä∂ÂéãDPÔºåËøòÊòØÊúâÁÇπÂãâÂº∫ÔºåÈ°∂Â§öÂÅö‰∏™Â≠¶‰π†Á¨îËÆ∞„ÄÇ È¶ñÂÖàÔºå‰ªÄ‰πàÊòØDPÔºåÁä∂ÊÄÅËΩ¨ÁßªÔºåÂÖ∂ÂÆûÂ∞±ÊòØ‰ªéÂ∑≤ÁªèÁ°ÆÂÆöÁöÑÁä∂ÊÄÅÔºåÂà∞‰∏Ä‰∏™Áä∂ÊÄÅ„ÄÇ Áä∂ÂéãDPÔºåÊàëÁêÜËß£ÁöÑÂ∞±ÊòØ Áî® ‰∏Ä‰∏™Êï∞ÁöÑ‰∫åËøõÂà∂Ë°®ËææÁä∂ÊÄÅ„ÄÇ 1ÔºåË°®Á§∫ Êúâ Ôºå0 Ë°®Á§∫Êó† ÊØîÂ¶Ç 4ËÄåËøõÂà∂Ë°®Á§∫ 100 Ôºå ËØ¥Êòé 3Âè∑ ‰ΩçÁΩÆË°®Á§∫ Êúâ ÔºåÂÖ∂ÂÆÉÁöÑÈÉΩË°®Á§∫Ê≤°Êúâ„ÄÇ È¢òÁõÆ Traveling by Stagecoach POJ 2686 ÂºÄ‰∏Ä‰∏™DP„ÄêS„Äë[M]. S ÊòØÁ•®ÁöÑ‰ΩøÁî®Áä∂ÂÜµ Ôºå MÔºåÊòØÂú®Âì™‰∏Ä‰∏™ÂüéÂ∏Ç„ÄÇÂÄºÂ∞±ÊòØÊúÄÂ∞èËä±Ë¥π„ÄÇ Êää‰∏Ä‰∏™Á•®ÈÉΩÊ≤°ÊúâÁî®ÁöÑÔºåËµ∑ÁÇπ Ê†áËÆ∞‰∏∫0,‰πüÂ∞±ÊòØ DP[1&lt;&lt;n-1][a]==0. Êö¥ÂäõÊûö‰∏æ ÊâÄÊúâ ÂèØ‰ª•Áî®ÁöÑÁ•® Ôºå(S&gt;&gt;i)&amp;1 Ë°®Á§∫Á¨¨ I Âº†Á•®ÂèØ‰∏çÂèØ‰ª•Áî®„ÄÇ ÂÜçÊö¥ÂäõÊûö‰∏æ ÂΩìÂâçËøô‰∏™S‰∏ãÊâÄÊúâÁöÑ ÂèØ‰ª•Âà∞ÁöÑÂüéÂ∏ÇÔºådp[S][v]!=INFÔºåÂΩìÂâçS‰∏ãvËøô‰∏™ÂüéÂ∏ÇÂèØ‰∏çÂèØ‰ª•Âà∞Ëææ„ÄÇ ÁÑ∂ÂêéÂÜçÊö¥ÂäõÊâÄÊúâ vÔºå Ëøô‰∏™ÂüéÂ∏ÇÊâÄÊúâÁöÑË∑ØÔºåÁÑ∂Âêé‰ΩøÁî®Á¨¨ iÂº†Á•®„ÄÇd[v][u]&gt;=0„ÄÇV Âíåu‰∏≠Èó¥ÁöÑË∑Ø„ÄÇ ÁÑ∂Â¶ÇÊûúÁî®ËøôÂº†Á•®ÔºåËµ∞ËøôÊù°Ë∑Ø Âà∞ÁõÆÁöÑÂú∞ÁöÑÂÄºÂ∞èÂ∞±Ë¶ÜÁõñÂâçÈù¢ÁöÑÂÄºS&amp;~(1&lt;&lt;i)‰ΩøÁî®Á¨¨iÂº†Á•®ÂêéÁöÑÁä∂ÊÄÅÔºåd[v][u],‰ªé vÂüéÂ∏ÇÂà∞uÂüéÂ∏ÇÁöÑË∑Ø„ÄÇ dp[S&amp;~(1&lt;&lt;i)][u]=min(dp[S&amp;~(1&lt;&lt;i)][u],dp[S][v]+(double)d[v][u]*1.0/t[i])„ÄÇ AC‰ª£Á†ÅÔºö 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;stdio.h&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const long long mod=1e9+7;const int maxn=9;const int maxm=31;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int n,m,a,b,p,u,v,c;int t[maxn];int d[maxm][maxm];double dp[1&lt;&lt;maxn][maxm];int main() &#123; ios_base::sync_with_stdio(false); cin.tie(0);// freopen(&quot;123.txt&quot;,&quot;r&quot;,stdin); while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;p&gt;&gt;a&gt;&gt;b) &#123; int k=(1&lt;&lt;n)-1; if(n==0&amp;&amp;m==0&amp;&amp;p==0&amp;&amp;a==0&amp;&amp;b==0)return 0; for(int i=0; i&lt;n; i++)cin&gt;&gt;t[i]; memset(d,-1,sizeof(d)); while(p--) &#123; cin&gt;&gt;u&gt;&gt;v&gt;&gt;c; d[u][v]=c; d[v][u]=c; &#125; for(int i=0; i&lt;=k; i++)fill(dp[i],dp[i]+m+1,INF); dp[k][a]=0; double res=INF; for(int S=k; S&gt;=0; S--) &#123; res=min(res,dp[S][b]); for(int i=0; i&lt;n; i++) &#123; if((S&gt;&gt;i)&amp;1) &#123; for(v =1; v&lt;=m; v++) &#123; if(dp[S][v]!=INF) &#123; for(u=1; u&lt;=m; u++) &#123; if(d[v][u]&gt;=0) &#123; dp[S&amp;~(1&lt;&lt;i)][u]=min(dp[S&amp;~(1&lt;&lt;i)][u],dp[S][v]+(double)d[v][u]*1.0/t[i]); &#125; &#125; &#125; &#125; &#125; &#125; &#125; if(res==INF) &#123; printf(&quot;Impossible\n&quot;); &#125; else &#123; printf(&quot;%.3f\n&quot;,res); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 ÊπòÊΩ≠ÈÇÄËØ∑Ëµõ ÈÉ®ÂàÜÈ¢òËß£]]></title>
    <url>%2F2018%2F05%2F14%2F2018%20%E6%B9%98%E6%BD%AD%E9%82%80%E8%AF%B7%E8%B5%9B%20%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[2018 ÊπòÊΩ≠ÈÇÄËØ∑Ëµõ È¢òËß£ A C F G K .ÂÖ∂ÂÆÉÈ¢òËß£ÔºåÂêéÁª≠Ê∑ªÂä† A È¢ò Ê≤°Âï•Â•ΩËÆ≤ÁöÑÔºåÁ≠æÂà∞È¢ò ‰ªéÂêéÈù¢ÂæÄÂâçÈù¢Êï∞ÔºåÂ§ß‰∫é‰∏™Êï∞ÁöÑÊó∂ÂÄôÁõ¥Êé•ËæìÂá∫Â∞±Ë°å‰∫Ü„ÄÇ AC‰ª£Á†ÅÔºö 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;const long long mod=1e9+7;const int maxn=2e5+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int main() &#123; int n,a[maxn]; long long sum=0; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) &#123; sum=0; for(int i=0; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; for(int i=n; i&gt;=0; i--) &#123; sum+=a[i]; if(sum&gt;=i) &#123; printf(&quot;%d\n&quot;,i); break; &#125; &#125; &#125; return 0;&#125; CÈ¢ò È¢òÁõÆÁöÑÊÑèÊÄùÂ∞±ÊòØÊâæ‰∏Ä‰∏™Âå∫Èó¥ÊØî ‰∏Ä‰∏™Êï∞Â§ßÁöÑÊï∞ÁöÑ‰∏™Êï∞Ë¶Å‰∏çÂ∞è‰∫éËøô‰∏™Êï∞„ÄÇÊ±ÇËøô‰∏™Êï∞ÊúÄÂ§ßÊòØÂ§öÂ∞ë„ÄÇ Ëøô‰∏ÄÈ¢òÂ∞±ÊòØ‰∏Ä‰∏™Âå∫ÂüüÊ†ëÔºàÂ§ß‰Ω¨‰ª¨ÂëäËØâÊàë‰πüÂè´‰∏ªÂ∏≠Ê†ëÔºåÁÑ∂ËÄåÊàëËøô‰∏™ËèúÈ∏°‰∏çÁü•ÈÅìÂï•ÊòØ‰∏ªÂ∏≠Ê†ëÔºâÔºå‰∏ÄËà¨Á∫øÊÆµÊ†ëÁª¥Êä§ÁöÑÊòØ‰∏Ä‰∏™ÂÄº„ÄÇËøôÈ¢òÊØè‰∏™ËäÇÁÇπÁª¥Êä§ÁöÑÊòØ‰∏Ä‰∏™Êï∞ÁªÑÔºåËøô‰∏™È¢òÊ≤°Êúâ‰øÆÊîπÂè™ÊúâÊü•ËØ¢„ÄÇ ÊØèÊ¨°Êü•ËØ¢Âú®ÂåÖÂê´Ëøô‰∏™Âå∫Èó¥Â∞±‰∫åÂàÜÊü•ÊâæÂ§ß‰∫éËøô‰∏™Êï∞ÁöÑ‰∏™Êï∞Ôºå Â¶ÇÊûú ‰∏çÂåÖÂê´ËøîÂõûÈõ∂„ÄÇ Â¶ÇÊûúÊúâ‰∏ÄÈÉ®ÂàÜÂú®Ëøô‰∏™Âå∫Èó¥Â∞±ÁªßÁª≠ÂæÄ‰∏ãÊâæÔºåÁÑ∂ÂêéËøîÂõû‰∏§‰∏™ÂÑøÂ≠êÁöÑ‰∏™Êï∞Âíå„ÄÇ Â§çÊùÇÂ∫¶ÊòØÔºànlogn+m log^3 nÔºâ; AC‰ª£Á†ÅÔºö 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;const long long mod=1e9+7;const int maxn=1e7+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;const int sz=(1&lt;&lt;18)-1;int n,m;int a[maxn];vector&lt;int&gt; dat[sz];void init(int k,int l,int r) &#123; dat[k].clear(); if(r-l==1)dat[k].push_back(a[l]); else &#123; int lch=k*2+1,rch=k*2+2,md=(l+r)/2; init(lch,l,md); init(rch,md,r); dat[k].resize(r-l); merge(dat[lch].begin(),dat[lch].end(),dat[rch].begin(),dat[rch].end(),dat[k].begin()); &#125;&#125;int query(int i,int j,int x,int k,int l,int r) &#123; if(j&lt;=l||r&lt;=i)return 0; else if(i&lt;=l&amp;&amp;r&lt;=j) &#123; return dat[k].end()-lower_bound(dat[k].begin(),dat[k].end(),x); &#125; else &#123; int lch=2*k+1,rch=2*k+2,md=(l+r)/2; return query(i,j,x,lch,l,md)+query(i,j,x,rch,md,r); &#125;&#125;int main() &#123; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)) &#123; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; init(0,0,n); int l,r,R,L,x; for(int i=0; i&lt;m; i++) &#123; scanf(&quot;%d%d&quot;,&amp;l,&amp;r); l--; L=1; R=n; while(R-L&gt;1) &#123; x=(R+L)/2; int c=query(l,r,x,0,0,n); if(c&gt;=x)L=x; else R=x; &#125; printf(&quot;%d\n&quot;,L); &#125; &#125; return 0;&#125; FÈ¢ò ‰∏Ä‰∏™sort Â∞±Ëøá‰∫ÜÊ≤°Âï•ÈöæÁöÑÔºåÂ∞±ÊòØÊ≥®ÊÑèÂÄºÁàÜ‰∫Üdouble Ë¶ÅÁî®long double„ÄÇ AC‰ª£Á†ÅÔºö 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;const long long mod=1e9+7;const int maxn=1e3+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;struct two &#123; long double val; int id;&#125; k[maxn];bool cmp(two &amp; a,two &amp;b) &#123; if(a.val==b.val)return a.id&lt;b.id; return a.val&lt;b.val;&#125;int main() &#123; int n; long long a,b,c,d; while(~scanf(&quot;%lld&quot;,&amp;n)) &#123; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c); long double t=0; t=a*1.0; t+=b*1.0; t=t/(t+c*1.0); k[i].id=i; k[i].val=t; &#125; sort(k,k+n,cmp); for(int i=0; i&lt;n; i++) &#123; printf(&quot;%d%c&quot;,k[i].id+1,i+1==n?&apos;\n&apos;:&apos; &apos;); &#125; &#125; return 0;&#125; GÈ¢ò ÊâæËßÑÂæãÔºåËøô‰∏™ÂèòÂåñÂèØ‰ª•‰øùËØÅ ‰∏§‰∏™a,b‰∏ÄÂÆöÂèØ‰ª•Ê∂àÂéªÔºåa,b,ÁöÑ‰ΩçÁΩÆÂèØ‰ª•‰∫§Êç¢ÔºåÊâÄ‰ª•È¢òÁõÆÂ∞±ÂèòÊàê‰∫ÜÊâæ‰∏§‰∏™Â≠óÁ¨¶‰∏≤ÂØπÂ∫îÁöÑÔºåc ,Â∑¶Âè≥‰∏§ËæπÁöÑa,bÂ•áÂÅ∂ÊòØ‰∏çÊòØ‰∏ÄÊ†∑ÁöÑ„ÄÇ Â¶ÇÊûúc‰∏™Êï∞‰∏çÁõ∏Á≠âÁõ¥Êé•ËæìÂá∫noÔºõ Áõ∏Á≠â Âà§Êñ≠ Ôºå‰ª•c‰∏∫ÂàÜÈöîÁ¨¶ÁöÑÂå∫Èó¥ a,b,ÁöÑÂ•áÂÅ∂Áõ∏‰∏çÁõ∏Á≠â„ÄÇ AC‰ª£Á†ÅÔºö 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;const long long mod=1e9+7;const int maxn=1e4+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;struct two &#123; int x,y;&#125; k[maxn],k2[maxn];int main() &#123; char a[maxn],b[maxn]; int flag,c; while(~scanf(&quot;%s%s&quot;,&amp;a,&amp;b)) &#123; int la=strlen(a),lb=strlen(b); memset(k,0,sizeof(k)); memset(k2,0,sizeof(k2)); c=0; flag=1; int pa,pb; pa=pb=0; for(int i=0; i&lt;la; i++) &#123; if(a[i]==&apos;a&apos;) &#123; k[pa].x=(k[pa].x+1)%2; &#125; if(a[i]==&apos;b&apos;) &#123; k[pa].y=(k[pa].y+1)%2; &#125; if(a[i]==&apos;c&apos;) &#123; pa++; c++; &#125; &#125; for(int i=0; i&lt;lb; i++) &#123; if(b[i]==&apos;a&apos;) &#123; k2[pb].x=(k2[pb].x+1)%2; &#125; if(b[i]==&apos;b&apos;) &#123; k2[pb].y=(k2[pb].y+1)%2; &#125; if(b[i]==&apos;c&apos;) &#123; pb++; c--; &#125; &#125; int l=max(pa,pb); if(c!=0)flag=0; for(int i=0; i&lt;=l; i++) &#123; if(k[i].x!=k2[i].x||k[i].y!=k2[i].y) &#123; flag=0; &#125; if(!flag)break; &#125; if(flag)printf(&quot;Yes\n&quot;); else printf(&quot;No\n&quot;); &#125; return 0;&#125; KÈ¢ò Â∞±ÊòØ‰∏Ä‰∏™ÊâæÂõ†Â≠êÁöÑÈ¢ò 2018 Âõ†Â≠ê 1 Ôºå2018 Ôºå2 Ôºå1009Ôºõ ÊâÄ‰ª• ÊâÄÊúâÁöÑ Â•áÊï∞ÂèØ‰ª•ÂíåÊâÄÊúâÁöÑ 2018ÁöÑÂÄçÊï∞ÂåπÈÖç„ÄÇ 2018 ÂèØ‰ª•ÂíåÊâÄÊúâÁöÑÊï∞ÂåπÈÖçÔºå ÂÅ∂Êï∞ ÂèØ‰ª•ÂíåÊâÄÊúâ 1009 ÁöÑÂÄçÊï∞ÂåπÈÖç 1009 ÂèØ‰ª•ÂíåÊâÄÊúâ ÂÅ∂Êï∞ÂåπÈÖçÔºõ Ê≥®ÊÑè‰∏Ä‰∏ãÔºåÂÖ∂‰∏≠ÈáçÂ§çÁÆóÁöÑÂ∞±Ë°å„ÄÇ AC‰ª£Á†ÅÔºö 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;typedef long long LL;typedef unsigned long long uLL;const long long mod=1e9+7;const int maxn=2e5+25;const int INF=0x7fffffff;const int inf=0x3f3f3f3f;const double eps=1e-8;int main() &#123; long long sum=0,a,b,c,d; while(scanf(&quot;%lld%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c,&amp;d)!=EOF) &#123; sum=0; long long x1,x2,x1009,x2018,y1,y2,y1009,y2018; x2=x1=(b-a+1)/2; if((b-a)%2==0) &#123; if(a&amp;1)x1++; else x2++; &#125; x1009=(a%1009==0)+b/1009-a/1009; x2018=(a%2018==0)+b/2018-a/2018; y2=y1=(d-c+1)/2; if((d-c)%2==0) &#123; if(c&amp;1)y1++; else y2++; &#125; y1009=(c%1009==0)+d/1009-c/1009; y2018=(c%2018==0)+d/2018-c/2018; sum+=(x1-x1009+x2018)*y2018; sum+=x2018*(y1+y2); sum+=(x2-x2018)*(y1009); sum+=(x1009-x2018)*y2; printf(&quot;%lld\n&quot;,sum); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bit ‰ΩçÔºåÊ†ëÁä∂Êï∞ÁªÑÂ≠¶‰π†Á¨îËÆ∞„ÄÇ]]></title>
    <url>%2F2018%2F04%2F25%2Fbit%20%E4%BD%8D%EF%BC%8C%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%82%2F</url>
    <content type="text"><![CDATA[Áªô‰∏Ä‰∏™ÂàùÂßãÂÄºÂÖ®‰∏∫0ÁöÑÊï∞Âàóa1,a2,‚Ä¶,an. ÁªôÂÆö iÔºåÊ±Ça1+a2+..+ai. ÁªôÂÆöi,x ÊâßË°åai+x; Âõæ‰∏çÂ•ΩÁúãËßÅË∞ÖÔºö Â¶ÇÂõæÊâÄÁ§∫Ôºå1ËäÇÁÇπÁª¥Êä§ÁöÑÊòØa1Êú¨Ë∫´ÁöÑÂíå 2ËäÇÁÇπÁª¥Êä§ÁöÑÊòØ a1Âà∞a2 ÁöÑÂíå 3ËäÇÁÇπÁª¥Êä§ÁöÑÊòØa3ÁöÑÂíå 4ËäÇÁÇπÁª¥Êä§ÁöÑÊòØa1Âà∞a4 ÁöÑÂíå ‰∏∫Âï•‰ºöÊúâ‰∫õËäÇÁÇπÁª¥Êä§ÁöÑÂÄºÁöÑ‰∏™Êï∞‰∏çÂêåÂë¢Ôºü ÂæàÁÆÄÂçï ÔºåÂ∞±ÊòØÁúãÊúÄÂêé‰∏Ä‰∏™1ÁöÑ‰ΩçÁΩÆÔºå2Ôºö‰∫åËøõÂà∂0010 ÊúÄÂêé‰∏Ä‰∏™1ÊòØÁ¨¨2‰∏™‰ΩçÁΩÆÊâÄ‰ª•Áª¥Êä§2ÁöÑ2-1Ê¨°Êñπ‰∏™ÂÄº„ÄÇ4Ôºö0100Áª¥Êä§2ÁöÑ3-1Ê¨°Êñπ‰∏™ÂÄº„ÄÇ Âä†Ê≥ïÔºåÊääÊúâÁª¥Êä§Ëá™Â∑±ÁöÑÂÄºÈÉΩÂä†‰∏äXÂ∞±Ë°å‰∫Ü Âä†Ê≥ïÔºö‰æãÂ≠êÂú®a3‰∏ä+XÂ∞±ÊòØÂú®3ËäÇÁÇπ‰∏ä+XÔºå4ËäÇÁÇπ+XÔºå8ËäÇÁÇπ+X„ÄÇÁúã‰∏ÄÁúº‰∏äÂõæÔºåÂ∞±Áü•ÈÅìÔºåÂ∞±ÊòØÊåâÁÆ≠Â§¥‰∏Ä‰∏™‰∏™Âêë‰∏äËäÇÁÇπËΩ¨Áßª„ÄÇ ÊÄé‰πàÂÆûÁé∞ËøôÁßçËΩ¨ÁßªÂë¢Ôºü 3ÁöÑ‰∫åËøõÂà∂ÊòØ0011.4ÊòØ 0100Ôºå8ÊòØ1000. Â∞±ÊòØÊääÂä†‰∏äÊúÄÂêé‰∏Ä‰∏™1ÊâÄÂú®‰ΩçÁΩÆÁöÑÂÄºÔºå0011 +0001ÔºàÊúÄÂêé‰∏Ä‰∏™‰ΩçÁΩÆÊòØÊúÄÂêé‰∏Ä‰∏™Ôºâ=0100Ôºõ 0100+0100ÔºàÊúÄÂêé‰∏Ä‰∏™1‰ΩçÁΩÆÊòØÁ¨¨3‰∏™Ôºâ=1000Ôºõ ‰ª•Ê≠§Á±ªÊé®ÔºåÂú®a5‰πüÊòØ‰∏ÄÊ†∑,0101+0001=0110(6); 0110+0010=1000(8); ÊÄé‰πàÂÆûÁé∞ÔºåÂ∞±ÊòØi+=i&amp;-i; i&amp;-iÂèØ‰ª•ÊääËá™Â∑±ÊúÄÂêé‰∏Ä‰∏™1ÁöÑ‰ΩçÁΩÆÁÆóÂá∫Êù•ÔºåÊÄé‰πàÊù•ÁöÑÂ∞±Ëá™Â∑±ÂéªÁôæÂ∫¶Âêß„ÄÇ Ê±ÇÂíåÔºöÊØîÂ¶Ç Ââç5‰∏™ÁöÑÂíåÔºåÂ∞±ÊòØÔºà1Âà∞4Ôºâ+5 ‰πüÂ∞±ÊòØ4ËäÇÁÇπÂä†5ËäÇÁÇπÁöÑÂíå„ÄÇ Ââç7‰∏™ÁöÑÂíåÂ∞±ÊòØ7+Ôºà5Âà∞6Ôºâ+Ôºà1Âà∞4ÔºâÁöÑÂíåÔºå‰πüÂ∞±ÊòØ4ËäÇÁÇπÂä†6ËäÇÁÇπÂä†7ËäÇÁÇπÁöÑÂíå„ÄÇ Ëá≥‰∫éÊÄé‰πàÂÆûÁé∞Âë¢Â¶ÇÊûúÁªÜÂøÉÁöÑËØù‰∏çÈöæÂèëÁé∞ÔºåÂÖ∂ÂÆûÂ∞±ÊòØ‰ªéÊúÄÂêé‰∏Ä‰∏™1ÊÖ¢ÊÖ¢‰∏Ä‰∏™‰∏™ÂèòÊàê0ÁöÑËäÇÁÇπÂÖ®Âä†‰∏ä Â¶Ç 7ÁöÑ‰∫åËøõÂà∂ÊòØ0111 Ââç7‰∏™ÁöÑÂíåÂ∞±ÊòØ 0111+ 0110+0100 Ââç 5Ôºà0101Ôºâ‰∏™ÁöÑÂíå 0101 +0100 Êåâ‰ΩçËøêÁÆóÂ∞±ÊòØ i-=i&amp;-i. ‰ª£Á†ÅÈùûÂ∏∏ÁÆÄÂçï„ÄÇ Â§çÊùÇÂ∫¶ OÔºàlog NÔºâ; includeusing namespace std;const int maxn=1&lt;0) { s +=bit[i]; i-=i&amp;-i; } return s;}void add(int i,int x){ while(i&lt;=n) { bit[i]+=x; i+=i&amp;-i; }}]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GITÂü∫Êú¨Êìç‰ΩúÔºåÂíåÂà´‰∫∫‰∏ÄËµ∑ÂÅöÈ°πÁõÆ]]></title>
    <url>%2F2018%2F04%2F16%2FGIT%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%92%8C%E5%88%AB%E4%BA%BA%E4%B8%80%E8%B5%B7%E5%81%9A%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[GitÂü∫Êú¨Êìç‰Ωú GITÊïôÁ®ãÔºöhttps://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 GIT‰∏ãËΩΩÔºö Âú®Ëá™Â∑±ÁöÑÁîµËÑë‰∏äÔºåÂÆâË£ÖGit‰∏ãËΩΩÈ°µÈù¢Ôºöhttps://git-scm.com/downloads‰∏ãËΩΩÂÆâË£ÖÔºå‰∏ÄË∑Ø‰∏ã‰∏ÄÊ≠•Âç≥ÂèØ„ÄÇ GitHub Desktop‰∏ãËΩΩÂú∞ÂùÄÔºöhttps://desktop.github.com GIT ÁÆÄÂçïÁöÑ‰ΩøÁî®Ôºö 1„ÄÅ Ê≥®ÂÜåÁ†Å‰∫ëÔºö Á†Å‰∫ëÊ≥®ÂÜåÈ°µÈù¢Ôºöhttps://gitee.com/signup Â∫îËØ•‰∏çÈúÄË¶ÅÊàëÂ§öËØ¥ 2„ÄÅ‰Ω†ÈúÄË¶ÅËÆøÈóÆ‰ªìÂ∫ìÔºàÊòØ‰∏™ÁΩëÂùÄÔºâÔºö Â¶ÇÊûú‰Ω†ÈúÄË¶ÅÂàõÂª∫Ëá™Â∑±Êúâ‰∏Ä‰∏™‰∏ìÈó®ÁöÑÂàÜÊîØËøòÈúÄË¶ÅforkÔºõ ÁÇπÂáªfork Âêé‰ºöËÆ©‰Ω†ÈÄâÊã©Ëá™Â∑±ÔºåÁÑ∂Âêé ÁÇπÂáªÁ°ÆÂÆö ÔºåÂ∑¶‰∏äËßíÂèòÊàê‰Ω†Ëá™Â∑±ÁöÑÂêçÂ≠óÂ∞±ÂØπ‰∫Ü„ÄÇ Â∑¶‰∏äËßíÂèòÊàê‰Ω†Ëá™Â∑±ÁöÑÂêçÂ≠óÂ∞±ÂØπ‰∫Ü Â∑¶‰∏äËßíÂèòÊàê‰Ω†Ëá™Â∑±ÁöÑÂêçÂ≠óÂ∞±ÂØπ‰∫Ü Â∑¶‰∏äËßíÂèòÊàê‰Ω†Ëá™Â∑±ÁöÑÂêçÂ≠óÂ∞±ÂØπ‰∫Ü ‰∏ÄÂÆöË¶ÅËÆ∞‰Ωè ÔºåÈÇ£‰∏™Á∫¢ÂúàÈáåÈù¢ÊòØËá™Â∑±ÁöÑÁ†Å‰∫ëÊòµÁß∞„ÄÇ‰∏çÁÑ∂‰Ω†Â∞±Á≠âÁùÄ‰∏ÄÁõ¥ËÆ§ËØÅÂ§±Ë¥•Âêß„ÄÇ ÁÇπÂáªÁöÑ„ÄêÂÖãÈöÜ/‰∏ãËΩΩ„ÄëÔºåÁÇπÂáª„ÄêÂ§çÂà∂„ÄëÊåâÈíÆÂ§çÂà∂‰∏ãÈù¢ÁöÑËøûÊé•ÔºåÊàë‰ª¨ÊääËøô‰∏™ËøûÊé•Áß∞‰∏∫„ÄêËøûÊé•‚ë†„Äë 3„ÄÅÂºÄÂßãclone Ôºö Á¨¨‰∏ÄÁßçÔºö Ë¶ÅÊâìÂºÄÁöÑÊòØGit Bash Here ‰∏çÊòØ Git GUI here ‰∏äÂõæÊåáÈîô‰∫Ü ÁÑ∂ÂêéÂºÄÂßãÂÖãÈöÜÂ∞±Ë°å‰∫ÜÔºåËæìÂÖ• ÂëΩ‰ª§ git clone ÂÅöÂÆåËøô‰∫õ‰Ω†Â∞±‰ºöÂèëÁé∞‰Ω†ÂΩìÂâçÊñá‰ª∂Â§π‰∏ãÈù¢Â§ö‰∫Ü‰Ω†cloneÂá∫Êù•ÁöÑÊñá‰ª∂Â§πÔºå‰πüÂ∞±ÊòØ‰Ω†ÁöÑÊú¨Âú∞‰ªì‰∫Ü„ÄÇ Á¨¨‰∫åÁßçÔºö ÊâìÂºÄcmdÁ™óÂè£ ÊåâWinÈîÆ+RÔºåËæìÂÖ•cmdÔºåÊåâ„ÄêÁ°ÆÂÆö„Äë 1Âú®cmdÁ™óÂè£‰∏≠ÂàáÊç¢Êñá‰ª∂Â§π Èöè‰æøÊâæ‰∏Ä‰∏™Êñá‰ª∂Â§π ÊØîÂ¶ÇdÁõò‰∏≠123Êñá‰ª∂Â§πÔºåÈÇ£‰πàËæìÂÖ•D: Êï≤ÂõûËΩ¶Ôºåcd 123 Êï≤ÂõûËΩ¶Âç≥ÂèØÂàáÊç¢ 1Ëøô‰∏™ÊòØËΩ¨Êç¢Âà∞‰Ω†Ë¶ÅËΩ¨Êç¢Âà∞‰Ω†Ë¶ÅcloneÁöÑÁõÆÂΩï‰∏ã ÁÑ∂ÂêéËæìÂÖ• 12 1git config --global user.name &quot;Ê≥®ÂÜåÁ†Å‰∫ëÊó∂Áî®ÁöÑÊòµÁß∞&quot; 12 1git config --global user.email &quot;Ê≥®ÂÜåÁ†Å‰∫ëÊó∂Áî®ÁöÑÈÇÆÁÆ±&quot; Ëøô‰∏™ÊòØÁôªÂΩï ÁâπÂà´ÊèêÈÜíÔºöËΩ¨Âà∞ÁöÑÁõÆÂΩïÊòØ‰ªìÂ∫ì‰∏ãÔºå‰∏çÊòØ‰Ω†ÂéüÊú¨cloneÁöÑÁõÆÂΩï‰∏ãÔºåÊòØÂà∞cloneÂá∫Êù•ÁöÑÈÇ£‰∏™Êñá‰ª∂Â§πÁõÆÂΩï‰∏ã„ÄÇÂà´ÂíåÂâçÈù¢cloneÁöÑÁõÆÂΩï‰∏ÄÊ†∑„ÄÇ ÁâπÂà´ÊèêÈÜíÔºöËΩ¨Âà∞ÁöÑÁõÆÂΩïÊòØ‰ªìÂ∫ì‰∏ãÔºå‰∏çÊòØ‰Ω†ÂéüÊú¨cloneÁöÑÁõÆÂΩï‰∏ãÔºåÊòØÂà∞cloneÂá∫Êù•ÁöÑÈÇ£‰∏™Êñá‰ª∂Â§πÁõÆÂΩï‰∏ã„ÄÇÂà´ÂíåÂâçÈù¢cloneÁöÑÁõÆÂΩï‰∏ÄÊ†∑„ÄÇ ÁâπÂà´ÊèêÈÜíÔºöËΩ¨Âà∞ÁöÑÁõÆÂΩïÊòØ‰ªìÂ∫ì‰∏ãÔºå‰∏çÊòØ‰Ω†ÂéüÊú¨cloneÁöÑÁõÆÂΩï‰∏ãÔºåÊòØÂà∞cloneÂá∫Êù•ÁöÑÈÇ£‰∏™Êñá‰ª∂Â§πÁõÆÂΩï‰∏ã„ÄÇÂà´ÂíåÂâçÈù¢cloneÁöÑÁõÆÂΩï‰∏ÄÊ†∑„ÄÇ ÂíåÁ¨¨‰∏ÄÁßçÁöÑÂå∫Âà´ÊòØÁî®ÁöÑÊòØËá™Â∑±ÁîµËÑëÂ∏¶ÁöÑÂëΩ‰ª§Ë°å„ÄÇ‰∏çÊòØgitÁªôÁöÑ„ÄÇ 4.‰∏ä‰º† ‰∏äÂéª ‰∏ÄÊ†∑ÁöÑÊúâ‰∏§ÁßçÊìç‰ΩúÊàëÂ∞±‰πãËØ¥‰∏ÄÁßçÔºåÂè¶‰∏ÄÁßçËá™Â∑±ÁÖßÁùÄ‰∏äÈù¢‰∏§ÁßçËøõË°åÊìç‰Ωú„ÄÇ ÂÖàËøõË°å‰øÆÊîπ ‰øÆÊîπÂêé ËøõÂÖ•ÂëΩ‰ª§Ë°å Êìç‰Ωú ËΩ¨Âà∞‰ªìÂ∫ì‰ΩçÁΩÆ‰πüÂ∞±ÊòØ‰Ω†cloneÂá∫Êù•ÁöÑÊñá‰ª∂Â§π„ÄÇËøô‰∏™ÊòØcloneÂá∫Êù•ÁöÑÊñá‰ª∂Â§π‰ΩçÁΩÆÔºàÊú¨Âú∞‰ªìÁöÑ‰ΩçÁΩÆÔºâÔºå‰∏çÊòØcloneÂà∞ÁöÑ‰ΩçÁΩÆ„ÄÇgit add -A .git commit -m ‚ÄúÂßìÂêç‚Äùgit push Á¨¨‰∏ÄÊ¨°push ÈúÄË¶ÅÁôªÈôÜ ÔºåËæìÂÖ•ÂØÜÁ†ÅÁöÑÊó∂ÂÄô ËæìÂÖ•‰ªÄ‰πàÈÉΩÁúã‰∏çËßÅ‰∏çÁî®ÁÆ°Ôºå‰πüÊúâÂèØËÉΩÂºπÂá∫‰∏Ä‰∏™Á™óÂè£ËÆ©‰Ω†ÁôªÈôÜ„ÄÇ ÂëäËØâÂ§ßÂÆ∂‰∏ÄÁßçÁî®GitHub Desktop Ëøô‰∏™‰∏úË•øËøõË°åÁÆÄÂçïÊìç‰ΩúÔºõ ‰∏ãËΩΩÂú∞ÂùÄhttps://desktop.github.com ÁÑ∂ÂêéÂÆâË£ÖÂ•ΩÂ∞±Ë°å„ÄÇ ÂÆâË£ÖÂ•ΩÂêé Áõ¥Êé•ÁôªÈôÜÔºåÊ∑ªÂä†‰ªìÂ∫ì ÁÑ∂ÂêéÈÄâ‰∏≠ ‰Ω†ÂéüÊú¨clone ÁöÑÊñá‰ª∂Â§πÂ∞±ÂèØ‰ª•‰∫ÜÔºå Â¶ÇÊûú ‰Ω†Êèê‰∫§ÁöÑÊòØËá™Â∑±ÁöÑÔºåËØ∑Ê≥®ÊÑè ÈÇ£‰∏™ÂàÜÊîØË¶ÅÊèê‰∫§ÂØπ‰∫Ü // Ê≥®ÊÑèÁ¨¨‰∏ÄÊ¨°Êèê‰∫§ Ë¶ÅÁôªÈôÜ ÔºåÁôªÈôÜÁöÑÁî®Êà∑ÂêçÊòØÈÇ£‰∏™‰∏™‰∫∫‰∏ªÈ°µ ÂêçÁß∞‰∏ãÈù¢ÁöÑÈÇ£Âá†‰∏™Ëã±Êñá„ÄÇ Êèê‰∫§Pull Request Âà∞‰ªìÂ∫ì ÁÑ∂ÂêéÂ∞±OK‰∫ÜÔºåËøôÊ†∑Â∞±ÂèØ‰ª•ÊÑâÂø´ÁöÑÂíåÂà´‰∫∫‰∏ÄËµ∑ÂÅöÈ°πÁõÆ‰∫Ü]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018ÊπñÂçóÂ§öÊ†°Á¨¨‰∏âÂú∫]]></title>
    <url>%2F2018%2F04%2F16%2F2018%E6%B9%96%E5%8D%97%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%89%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[2018 ‰∏≠ÂçóÂ§öÊ†° Á¨¨‰∏âÂú∫ A(2063): Good Versus Evil SubmitPage Summary TimeLimit: 5 Sec MemoryLimit: 512 Mb Submitted: 85 Solved: 15 Description Middle Earth is about to go to war. The forces of goodwill have many battles with the forces of evil. Different races will certainlybe involved. Each race has a certain ‚Äòworth‚Äô when battling against others. Onthe side of good we have the following races, with their associated worth: Hobbits - 1 Men - 2 Elves - 3 Dwarves - 3 Eagles - 4 Wizards - 10 On the side of evil we have: Orcs - 1 Men - 2 Wargs - 2 Goblins - 2 Uruk Hai - 3 Trolls - 5 Wizards - 11 Although weather, location, supplies and valor play apart in any battle, if you add up the worth of the side of good and compare itwith the worth of the side of evil, the side with the larger worth will tend towin. Thus, given the count of each of the races on the side of good, followedby the count of each of the races on the side of evil, determine which sidewins. Input The first line of input will contain an integer greaterthan 0 signifying the number of battles to process. Information for each battlewill consist of two lines of data as follows. First, there will be a linecontaining the count of each race on the side of good. Each entry will beseparated by a single space. The values will be ordered as follows: Hobbits,Men, Elves, Dwarves, Eagles, Wizards. The next line will contain the count ofeach race on the side of evil in the following order: Orcs, Men, Wargs, Goblins,Uruk Hai, Trolls, Wizards. All values are non-negative integers. The resultingsum of the worth for each side will not exceed the limit of a 32-bit integer. Output For each battle, print ‚ÄúBattle‚Äù followed by a singlespace, followed by the battle number starting at 1, followed by a ‚Äú:‚Äù, followedby a single space. Then print ‚ÄúGood triumphs over Evil‚Äù if good wins. Print‚ÄúEvil eradicates all trace of Good‚Äù if evil wins. If there is a tie, then print‚ÄúNo victor on this battle field‚Äù. Sample Input 3 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 10 0 1 1 1 1 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 Sample Output Battle 1: Evileradicates all trace of Good Battle 2: Goodtriumphs over Evil Battle 3: Novictor on this battle field ËøôÁßçÁÆÄÂçïÈ¢òÂè™Ë¶ÅÁúãÊáÇÈ¢òÂ∞±ËÉΩÂÜôÂá∫Êù•ÔºåÈô§‰∫ÜÈ¢òÈù¢‰∏äÊòØ7‰∏™Êï∞ÁöÑÈÇ£‰∏™ ÊùÉÂÄº 11 ÂÆûÈôÖ‰∏äÊòØ 10„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; int a[]= &#123;1,2,3,3,4,10&#125;,b[]= &#123;1,2,2,2,3,5,10&#125;; long long n,x; long sum1,sum2; cin&gt;&gt;n; for(int j=1; j&lt;=n; j++) &#123; sum1=sum2=0; for(int i=0; i&lt;6; i++) &#123; cin&gt;&gt;x; sum1+=x*a[i]; &#125; for(int i=0; i&lt;7; i++) &#123; cin&gt;&gt;x; sum2+=x*b[i]; &#125; printf(&quot;Battle %d: &quot;,j); if(sum1&gt;sum2) &#123; cout&lt;&lt;&quot;Good triumphs over Evil\n&quot;; &#125; else if(sum1&lt;sum2) &#123; cout&lt;&lt;&quot;Evil eradicates all trace of Good\n&quot;; &#125; else &#123; cout&lt;&lt;&quot;No victor on this battle field\n&quot;; &#125; &#125; return 0;&#125; B(2064): Magic Multiple SubmitPage Summary TimeLimit: 5 Sec MemoryLimit: 512 Mb Submitted: 28 Solved: 18 Description The Elvish races of Middle Earth believed that certainnumbers were more significant than others. When using a particular quantity nof metal to forge a particular sword, they believed that sword would be mostpowerful if the thickness k were chosen according to the following rule: Givena nonnegative integer n, what is the smallest k such that the decimalrepresentations of the integers in the sequence: n, 2n, 3n, 4n, 5n, ‚Ä¶, kncontain all ten digits (0 through 9) at least once? Lord Elrond of Rivendell hascommissioned you with the task to develop an algorithm to find the optimalthickness (k) for any given quantity of metal (n). Input Input will consist of a single integer n per line. Theend of input will be signaled by end of file. The input integer will be between1 and 200,000,000, inclusive. Output The output will consist of a single integer per line,indicating the value of k needed such that every digit from 0 through 9 is seenat least once. Sample Input 1 10 123456789 3141592 Sample Output 10 9 3 5 ‰∏Ä‰∏™Êï∞ÁöÑ1 Âà∞ KÂÄç‰∏≠ 0-9ÂÖ®ÈÉ®Âá∫Áé∞ËøáÔºåÊö¥ÂäõKÂÄçÂ∞±Ë°å‰∫Ü„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int a[10];int l;void check(long long x)&#123; while(x&gt;0) &#123; if(a[x%10]==0) &#123; l++; a[x%10]=1; &#125; x/=10; &#125;&#125; int main()&#123; long long n; long sum1,sum2; while (cin&gt;&gt;n) &#123; l=0; memset(a,0,sizeof(a)); int i=1; for (; l!=10; i++) &#123; check(i*n); &#125; cout&lt;&lt;i-1&lt;&lt;endl; &#125; return 0;&#125; DescriptionSaruman‚Äôs army of orcs andother dark minions continuously mine and harvest lumber out of the landsurrounding his mighty tower for N continuous days. On day number i, Sarumaneither chooses to spend resources on mining coal and harvesting more lumber, oron raising the level (i.e., height) of his tower. He levels up his tower by oneunit only on days where the binary representation of i contains a total numberof 1‚Äôs that is an exact multiple of 3. Assume that the initial level of histower on day 0 is zero. For example, Saruman will level up his tower on day 7(binary 111), next on day 11 (binary 1011) and then day 13, day 14, day 19, andso on. Saruman would like to forecast the level of his tower after N days. Canyou write a program to help? InputThe input file will containmultiple input test cases, each on a single line. Each test case consists of apositive integer N &lt; 1016, as described above. The input ends on end offile. OutputFor each test case, outputone line: ‚ÄúDay N: Level = L‚Äù, where N is the input N, and L is the number oflevels after N days. Sample Input12 119 164 Sample Output1Day 2: Level = 0 1Day 19: Level = 5 1Day 64: Level = 21 Ëøô‰∏ÄÈ¢òÂ∞±ÊòØ‰ªé2ËøõÂà∂ Á¨¨‰∏Ä‰∏™ÊâæÔºå‰∏Ä‰∏™‰∏™ÂæÄ‰∏ãÊâæÔºåÊâæÂÖ∂‰∏≠ 1 ÁöÑ‰∏™Êï∞ÊòØ3ÁöÑÂÄçÊï∞Â∞±Ë°å‰∫Ü„ÄÇ ËøòÊúâ‰∏ÄÁßçÊú¨Ë∫´Â∞±ÊòØ 3ÁöÑÂÄçÊï∞Ë¶ÅÈ¢ùÂ§ñÂä†‰∏ÄÂâçÈù¢Âè™ÊòØÂ§ÑÁêÜÊâÄÊúâÊØîNÂ∞èÁöÑÊï∞„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int l;long long gcd(long long a,long long b)&#123; return (b==0)?a:gcd(b,a%b);&#125;long long C(long long n,long long m)&#123; long long x=1,y=1; if(n-m&lt;m)m=n-m; for(int i=0; i&lt;m; i++) &#123; x*=(n-i); y*=1+i; int t=gcd(x,y); x/=t; y/=t; &#125; return x/y;&#125; int main()&#123; int a[1000]; long long n,k,sum; while (cin&gt;&gt;n) &#123; sum=0; k=n; long long l=1,t=0; while(n&gt;0) &#123; a[l++]=(n&amp;1); n&gt;&gt;=1; &#125; for(int i=l-1; i&gt;0; i--) &#123; if(a[i]) //Â¶ÇÊûúÂΩìÂâç‰Ωç‰∏∫1 &#123; for(int j=3; j-t&lt;=i-1;j+=3) //ÂΩìÂâç‰ΩçÊï∞Âáè1,ËøòËÉΩÊâæÂá∫ÊòØ3ÁöÑÂÄçÊï∞‰∏™ 1 if(j-t&gt;=0)sum+=C(i-1,j-t); t++; &#125; &#125; if(t&gt;0&amp;&amp;t%3==0)sum+=1; //Â§ÑÁêÜÊú¨Ë∫´Â∞±ÊòØ3ÁöÑÂÄçÊï∞ÊÉÖÂÜµ„ÄÇ printf(&quot;Day %lld: Level = %lld\n&quot;,k,sum); &#125; return 0;&#125; H(2070): Seating Chart SubmitPage Summary TimeLimit: 10 Sec MemoryLimit: 512 Mb Submitted: 41 Solved: 15 Description Bilbo‚Äôs birthday is coming up, and Frodo and Sam are incharge of all the party planning! They have invited all the hobbits of MiddleEarth to the party, and everyone will be sitting in a single row at anextremely long dining table. However, due to poor communication, Frodo and Samhave each independently put together a seating chart for all the hobbits at thedining table. Help Frodo and Sam find out how similar their seating charts areby counting the total number of distinct pairs of hobbits who appear indifferent orders in the two charts. Input The input filewill contain multiple test cases. Each test case begins with a single linecontaining an integer N(1‚â§N‚â§100,000)N(1‚â§N‚â§100,000)indicating thenumber of hobbits. The next two lines represent Frodo‚Äôs and Sam‚Äôs seatingcharts, respectively. Each seating chart is specified as a single line of Nunique alphabetical strings; the set of strings in each line are guaranteed tobe identical. The end-of-input is denoted by a line containing the number 0. Output For each input test case, output a single integerdenoting, out of the N choose 2 distinct pairs of hobbits, how many pairsappear in different orders in Frodo‚Äôs and Sam‚Äôs seating arrangements. Sample Input 3 Frodo Sam Bilbo Sam Frodo Bilbo 5 A B C D E B A D E C 0 Sample Output 1 3 Ëøô‰∏ÄÈ¢òÂ∞±ÊòØ‰∏ÄÈÅìÊ±ÇÈÄÜÂ∫èÊï∞ÔºåÈÄÜÂ∫èÊï∞ÊÄé‰πàÊ±ÇÂ∞±Ëá™Â∑±ÊâæÊ®°ÊùøÂêßÔºåÂè¶Â§ñËøô‰∏™È¢òË∂Ö‰∫Üint Ë¶ÅÁî®longlong„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;map&gt;using namespace std;const int maxn=1e6+5;int a[maxn];map&lt;string,int&gt;m;long long n=0;//ÂÖ®Â±ÄÂèòÈáèÔºåÁî®‰∫éÁªüËÆ°ÈÄÜÂ∫èÂØπÊï∞void merge(int a[],int first,int mid,intlast)&#123; int *temp = new int[last-first+1];//‰∏¥Êó∂Êï∞ÁªÑÔºåÁî®‰∫é‰∏¥Êó∂Â≠òÊîæÊØîËæÉÂêéÁöÑÊï∞Â≠ó int i=first,j=mid+1,k=0; while(i&lt;=mid&amp;&amp;j&lt;=last)//ÈÅçÂéÜÊØîËæÉÂ∑¶Âè≥‰∏§‰∏™ÈÉ®ÂàÜ &#123; if(a[i]&lt;=a[j]) temp[k++] = a[i++]; //Â∑¶ÂçäÈÉ®ÂàÜÂÖÉÁ¥†Â∞è‰∫éÂè≥ÂçäÈÉ®ÂàÜÁöÑÂÖÉÁ¥†ÔºåÂ∞ÜÂ∑¶ËæπËØ•ÂÖÉÁ¥†Â≠òÂÖ•‰∏¥Êó∂Êï∞ÁªÑ else &#123; temp[k++] = a[j++]; n=n+(mid-i+1);//ÁªüËÆ°Â∑¶ÂçäËæπËÉΩÂíåÂè≥ÂçäËæπËØ•ÂÖÉÁ¥†ÊûÑÊàêÁöÑÈÄÜÂ∫èÂØπÊï∞ &#125; &#125; while(i&lt;=mid) temp[k++]=a[i++]; while(j&lt;=last) temp[k++]=a[j++]; for(i=0; i &lt; k; i++) a[first + i] = temp[i];//‰ªé‰∏¥Êó∂Êï∞ÁªÑÂèñÂá∫ÊîæÂõûÂéüÊï∞ÁªÑ&#125;void mergesort(int a[],int first,int last)&#123; if(first &lt; last) &#123; int mid = (first+last)/2; mergesort(a,first,mid);//ÈÄíÂΩíÊéíÂ∫èÂ∑¶ÂçäÈÉ®ÂàÜ mergesort(a,mid+1,last);//ÈÄíÂΩíÊéíÂ∫èÂè≥ÂçäÈÉ®ÂàÜ merge(a,first,mid,last);//Â∞ÜÂ§ÑÁêÜÂêéÁöÑ‰∏§‰∏™ÈÉ®ÂàÜÂêàÂπ∂ &#125;&#125;int main()&#123; int N; string k; while (cin&gt;&gt;N&amp;&amp;N) &#123; m.clear(); for(int i=0;i&lt;N;i++) &#123; cin&gt;&gt;k; m[k]=i; &#125; for(int i=0;i&lt;N;i++) &#123; cin&gt;&gt;k; a[i]=m[k]; &#125; mergesort(a,0,N-1); cout&lt;&lt;n&lt;&lt;endl; n=0; &#125; return 0;&#125; J(2072): Temple Build SubmitPage Summary TimeLimit: 10 Sec MemoryLimit: 512 Mb Submitted: 8 Solved: 1 Description The Dwarves of Middle Earth are renowned for theirdelving and smithy ability, but they are also master builders. During the timeof the dragons, the dwarves found that above ground the buildings that weremost resistant to attack were truncated square pyramids (a square pyramid thatdoes not go all the way up to a point, but instead has a flat square on top).The dwarves knew what the ideal building shape should be based on the heightthey wanted and the size of the square base at the top and bottom. Theytypically had three different sizes of cubic bricks with which to work. Theirgoal was to maximize the volume of such a building based on the followingrules: The building is constructed of layers; each layer is asingle square of bricks of a single size. No part of any brick may extend outfrom the ideal shape, either to the sides or at the top. The resultingstructure will have jagged sides and may be shorter than the ideal shape, butit must fit completely within the ideal design. The picture at the right is avertical cross section of one such tower. There is no limit on how many bricksof each type can be used. Input Each line of input will contain six entries, eachseparated by a single space. The entries represent the ideal temple height, thesize of the square base at the bottom, the size of the square base at the top(all three as non-negative integers less than or equal to one million), thenthree sizes of cubic bricks (all three as non-negative integers less than orequal to ten thousand). Input is terminated upon reaching end of file. Output For each line of input, output the maximum possiblevolume based on the given rules, one output per line. Sample Input 500000 800000300000 6931 11315 5000 Sample Output 160293750000000000 Ëøô‰∏ÄÈ¢òÂ∞±ÊòØ‰∏Ä‰∏™ÔºådpÔºådp[0]=0.dp[i]=max(dp[i-a[j]]+V[a[j]])(0&lt;=j&lt;3); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt; using namespace std;const int maxn=1e7+5;long long dp[maxn];int main()&#123; long long h,d,t,a[3],ans; while(cin&gt;&gt;h&gt;&gt;d&gt;&gt;t&gt;&gt;a[0]&gt;&gt;a[1]&gt;&gt;a[2]) &#123; ans=0; memset(dp,-1,sizeof(dp)); dp[0]=0; for(int i=0;i&lt;=h;i++) &#123; if(dp[i]!=-1) &#123; for(int j=0;j&lt;3;j++) &#123; if(i+a[j]&lt;=h) &#123; doubleb=1.0*d-1.0*(i+a[j])/h*(d-t); int cnt=floor(b/a[j]); long longv=cnt*cnt*pow(a[j],3); if(dp[i+a[j]]==-1)dp[i+a[j]]=dp[i]+v; elsedp[i+a[j]]=max(dp[i+a[j]],dp[i]+v); // ÊàëÊòØ‰ªé‰∏Ä‰∏™Áä∂ÊÄÅË∑≥ÊâÄÊúâÂÆÉÂèØ‰ª•Ë∑≥Âà∞ÁöÑÁä∂ÊÄÅ„ÄÇ ans=max(ans,dp[i+a[j]]); &#125; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; L(2074): Tongues SubmitPage Summary TimeLimit: 5 Sec MemoryLimit: 512 Mb Submitted: 44 Solved: 18 Description Gandalf‚Äôs writings have long been available for study,but no one has yet figured out what language they are written in. Recently, dueto programming work by a hacker known only by the code name ROT13, it has beendiscovered that Gandalf used nothing but a simple letter substitution scheme,and further, that it is its own inverse‚Äîthe same operation scrambles themessage as unscrambles it. This operation is performed by replacing vowels inthe sequence (a i y e o u) with the vowel three advanced, cyclicly, whilepreserving case (i.e., lower or upper). Similarly, consonants are replaced fromthe sequence (b k x z n h d c w g p v j q t s r l m f) by advancing tenletters. So for instance the phrase One ring to rule them all. translates toIta dotf ni dyca nsaw ecc. The fascinating thing about this transformation isthat the resulting language yields pronounceable words. For this problem, youwill write code to translate Gandalf‚Äôs manuscripts into plain text. Input The input file will contain multiple test cases. Eachtest case consists of a single line containing up to 100 characters,representing some text written by Gandalf. All characters will be plain ASCII,in the range space (32) to tilde (126), plus a newline terminating each line.The end of the input is denoted by the end-of-file. Output For each input test case, print its translation intoplaintext. The output should contain exactly the same number of lines andcharacters as the input. Sample Input Ita dotf ni dycansaw ecc. Sample Output One ring to rulethem all. Â≠óÁ¨¶‰∏≤ÊõøÊç¢ÔºåXJBÊö¥ÂäõÂ∞±Ë°å,Â∞±ÊòØËÄóÁ•û„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt; using namespace std;const int maxn=1e2+5;char s[maxn];int main()&#123;//b k x z n h d c w g //p v j q t s r l m f char c1[]=&#123;&quot;bkxznhdcwg&quot;&#125;; char c2[]=&#123;&quot;pvjqtsrlmf&quot;&#125;; char a[500]=&#123;0&#125;; for(int i=0;i&lt;strlen(c1);i++) &#123; a[c1[i]]=c2[i]; a[c1[i]-(&apos;a&apos;-&apos;A&apos;)]=c2[i]-(&apos;a&apos;-&apos;A&apos;); &#125; for(int i=0;i&lt;strlen(c1);i++) &#123; a[c2[i]]=c1[i]; a[c2[i]-(&apos;a&apos;-&apos;A&apos;)]=c1[i]-(&apos;a&apos;-&apos;A&apos;); &#125; strcpy(c1,&quot;aiy&quot;); strcpy(c2,&quot;eou&quot;); for(int i=0;i&lt;strlen(c1);i++) &#123; a[c1[i]]=c2[i]; a[c1[i]-(&apos;a&apos;-&apos;A&apos;)]=c2[i]-(&apos;a&apos;-&apos;A&apos;); &#125; for(int i=0;i&lt;strlen(c1);i++) &#123; a[c2[i]]=c1[i]; a[c2[i]-(&apos;a&apos;-&apos;A&apos;)]=c1[i]-(&apos;a&apos;-&apos;A&apos;); &#125; while(~scanf(&quot;%c&quot;,&amp;s[0])) &#123; int i=0; while(s[i++]!=&apos;\n&apos;) &#123; scanf(&quot;%c&quot;,&amp;s[i]); &#125; i=0; do &#123; if(a[s[i]]==0) &#123; printf(&quot;%c&quot;,s[i]); &#125; else printf(&quot;%c&quot;,a[s[i]]); &#125;while(s[i++]!=&apos;\n&apos;); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ë¥™ÂøÉ]]></title>
    <url>%2F2018%2F03%2F17%2F%E8%B4%AA%E5%BF%83%2F</url>
    <content type="text"><![CDATA[Problem B: Ê¥óË°£ Time Limit: 2 Sec Memory Limit: 128 MBSubmit: 148 Solved: 26 [Submit][Status][Web Board] Description durongÊúâN‰ª∂Ë°£ÊúçË¶ÅÊ¥óÔºå ‰ΩÜÊòØ‰ªñÁöÑÁ¨¨i‰ª∂Ë°£ÊúçÂøÖÈ°ªÂú®[st, en) Êó∂Èó¥Ê¥óÔºå Âêå‰∏ÄÊ¥óË°£Êú∫‰∏çËÉΩÂêåÊó∂Ê¥óÂ§ö‰ª∂Ë°£ÊúçÔºå‰ªñÊÉ≥ÔºåË¶ÅÊ¥óÂÆåN‰ª∂Ë°£ÊúçÔºåËá≥Â∞ëÈúÄË¶ÅÂ§öÂ∞ë‰∏™Ê¥óË°£Êú∫Âë¢Ôºü Input Â§öÁªÑËæìÂÖ• Á¨¨‰∏ÄË°å‰∏Ä‰∏™Êï¥Êï∞nÔºàn &lt;= 100000Ôºâ, ‰ª£Ë°®Ë°£ÊúçÁöÑ‰∏™Êï∞ Êé•‰∏ãÊù•nË°å, ÊØèË°å‰∏§‰∏™Êï¥Êï∞st, enÔºà1 &lt;= st &lt; en &lt;= 1000000000ÔºâÔºå‰ª£Ë°®Á¨¨i‰ª∂Ë°£ÊúçÂú®stÂºÄÂßãÊ¥óÔºåenÊ¥óÂÆå Output ËæìÂá∫‰∏Ä‰∏™Êï¥Êï∞ÂíåÊç¢Ë°åÁ¨¶Ôºå‰ª£Ë°®Ëá≥Â∞ëÈúÄË¶ÅÁöÑÊ¥óË°£Êú∫‰∏™Êï∞ Sample Input1234 31 23 42 8 Sample Output12 Ë¥™ÂøÉÔºåÂÖàÊéíÂ∫èÔºåÁÑ∂ÂêéÂà∞‰∏Ä‰∏™Êó∂Èó¥ÁÇπËÉΩÂä†Â∞±Âä†ÔºåÂ¶ÇÊûúËøá‰∫Ü‰∏Ä‰∏™ÂáèÂéª‰∏Ä‰∏™Â∞±Ë°å‰∫ÜÔºåÊØèÊ¨°Ë∑≥Ë∑É‰∏Ä‰ª∂Ë°£ÊúçÁöÑÊó∂Èó¥ÈïøÂ∫¶Â∞±Ë°å‰∫ÜÔºåÂ§çÊùÇÂ∫¶Âè™ÊúâÊéíÂ∫èÁöÑÂ§çÊùÇÂ∫¶NlogN #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;queue&gt; using namespace std; const int maxn=1e5+10; int n; int main() { ` int`st[maxn],en[maxn],sz,ez,ans,cou; ` while`( scanf ( &quot;%d&quot; ,&amp;n)!=EOF) ` {` ` for`( int i=0;i&lt;n;i++){ ` scanf`( &quot;%d%d&quot; ,&amp;st[i],&amp;en[i]); ` }` ` sort(st,st+n);` ` sort(en,en+n);` ` ans=cou=ez=0;` ` for`( int i=0;i&lt;n;i++) ` {` ` cou++;` ` while`(en[ez]&lt;=st[i]) ` {` ` ez++;` ` cou‚Äî;` ` }` ` if`(cou&gt;ans)ans=cou; ` }` ` printf`( &quot;%d\n&quot; ,ans); ` }` ` return`0; }]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÊúÄÂ§ßÁîüÊàêÊ†ë]]></title>
    <url>%2F2018%2F03%2F17%2F%E6%9C%80%E5%A4%A7%E7%94%9F%E6%88%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Problem A: ÁÅæÂå∫ÈáçÂª∫Time Limit: 3 Sec Memory Limit: 128 MBSubmit: 123 Solved: 32[Submit][Status][Web Board] DescriptionÂú®‰∏ÄÂú∫Âú∞Èúá‰πãÂêéÔºåÂéüÊú¨Áæé‰∏ΩÁöÑCÂõΩÂèòÊàê‰∫Ü‰∏ÄÁâáÂ∫üÂ¢üÔºå‰ΩÜÊòØËøôÂπ∂Ê≤°ÊúâÂáªÂûÆ‰∫∫‰ª¨ÁöÑÊÑèÂøóÔºåÂú®ÂêÑÊñπÁöÑÊîØÊåÅ‰∏ãÊïëÊè¥ÈòüÈ©¨‰∏äÂºÄÂßã‰∫ÜÁÅæÂå∫ÈáçÂª∫„ÄÇÂ∑≤Áü•CÂõΩ‰∏ÄÂÖ±Áî±N‰∏™ÂüéÂ∏ÇÔºàÁºñÂè∑‰ªé1~NÔºâÁªÑÊàêÔºåÂú®ËøôN‰∏™ÂüéÂ∏Ç‰πãÈó¥ÊúâMÊù°ÈÅìË∑ØËøûÈÄöÁùÄÂêÑ‰∏™ÂüéÂ∏ÇÔºåÁé∞Âú®Ë¶ÅÂ∞ÜÁâ©ËµÑËøêÂæÄÂêÑ‰∏™ÂüéÂ∏ÇÔºå‰ΩÜÊòØÊØèÊù°ÈÅìË∑ØÈÉΩÊúâÂÖ∂ÊúÄÂ§ßÊâøÈáçÈáèWÔºå‰πüÂ∞±ÊòØËØ¥Â¶ÇÊûú‰∏ÄËæÜËΩ¶ÊâÄËøêËΩΩÁöÑË¥ßÁâ©ÈáçÈáèÂ§ß‰∫éWÁöÑËØùÊòØÊó†Ê≥ïÈÄöËøáËøôÊù°Ë∑ØÁöÑ„ÄÇ‰∏∫‰∫ÜÈò≤Ê≠¢ÈÅìË∑ØÂ¥©Â°åÂêåÊó∂ÊèêÈ´òÊïàÁéáÔºåÊàë‰ª¨ÈÉΩ‰ºöÂéªËµ∞ÊâøÈáçÈáèÂ∞ΩÂèØËÉΩÂ§ßÁöÑÈÅìË∑ØÔºåÁé∞Âú®ÊïëÊè¥ÈòüÁöÑÈòüÈïøÊÉ≥Áü•ÈÅìÂ¶ÇÊûúË¶ÅÂ∞ÜË¥ßÁâ©‰ªé‰ªªÊÑè‰∏Ä‰∏™ÂüéÂ∏ÇËøêÂæÄÂÖ∂‰ªñN-1‰∏™ÂüéÂ∏ÇÔºå‰∏ÄÊ¨°ÊâÄËÉΩËøêËæìÁöÑÊúÄÂ§ßÈáçÈáèÊòØÂ§öÂ∞ëÔºå‰Ω†ËÉΩÂëäËØâ‰ªñÂêóÔºü InputËæìÂÖ•Á¨¨‰∏ÄË°å‰∏∫‰∏Ä‰∏™Êï¥Êï∞T(T&lt;=10ÔºâÔºåË°®Á§∫ÊúâTÁªÑÊ†∑‰æãÔºõ Á¨¨‰∫åË°å‰∏∫‰∏§‰∏™Êï¥Êï∞N(N&lt;=10^5)ÂíåM(M&lt;=10^6)ÔºåÂàÜÂà´Ë°®Á§∫ÂüéÂ∏ÇÁöÑÊï∞ÈáèÂíåÈÅìË∑ØÁöÑÊï∞ÈáèÔºõ Êé•‰∏ãÊù•MË°åÊØèË°åÊúâ‰∏â‰∏™Êï¥Êï∞,u,v,wÔºåÔºàu,v&lt;=NÔºåw&lt;=10^9Ôºâ Ë°®Á§∫uÂíåv‰πãÈó¥Êúâ‰∏ÄÊù°ÊâøÈáçÈáè‰∏∫wÁöÑÈÅìË∑ØÔºàÈÅìË∑ØÊòØÂèåÂêëÁöÑÔºåÂç≥ÂèØ‰ª•‰ªéuËµ∞Âà∞vÔºå‰πüÂèØ‰ª•‰ªévËµ∞Âà∞uÔºåÂêåÊó∂Êï∞ÊçÆ‰øùËØÅ‰ªªÊÑè‰∏§‰∏™ÂüéÂ∏Ç‰πãÈó¥Ëá≥Â§öÂè™‰ºöÊúâ‰∏ÄÊù°ÈÅìË∑ØÔºâ„ÄÇ OutputÊØèÁªÑÊ†∑‰æãËæìÂá∫‰∏ÄË°å Case #X: YÔºåXË°®Á§∫Á¨¨Âá†ÁªÑÊ†∑‰æãÔºåY‰æøÊòØÊâÄË¶ÅÊ±ÇÁöÑÁ≠îÊ°à„ÄÇ Sample Input11 4 6 1 2 2 1 3 1 1 4 9 2 4 8 2 3 10 3 4 4 Sample Output1Case #1: 8 HINTÊ†∑‰æãËß£ÈáäÔºö Â¶ÇÊûúË¶ÅÂ∞ÜÁâ©ËµÑ‰ªé1ËøêËæìÂà∞2ÔºåÈÇ£‰πàËµ∞1-4-2ËøôÊù°Ë∑ØÂæÑÊâÄÂç≥ËÉΩËøêËæìÁöÑÊúÄÂ§ßÈáçÈáè‰∏∫8Ôºõ Â¶ÇÊûúË¶ÅÂ∞ÜÁâ©ËµÑ‰ªé1ËøêËæìÂà∞3ÔºåÈÇ£‰πàËµ∞1-4-2-3ËøôÊù°Ë∑ØÂæÑÂç≥ÊâÄËÉΩËøêËæìÁöÑÊúÄÂ§ßÈáçÈáè‰∏∫8Ôºõ Â¶ÇÊûúË¶ÅÂ∞ÜÁâ©ËµÑ‰ªé1ËøêËæìÂà∞4ÔºåÈÇ£‰πàËµ∞1-4ËøôÊù°Ë∑ØÂæÑÂç≥ÊâÄËÉΩËøêËæìÁöÑÊúÄÂ§ßÈáçÈáè‰∏∫9Ôºõ Â¶ÇÊûúË¶ÅÂ∞ÜÁâ©ËµÑ‰ªé2ËøêËæìÂà∞3ÔºåÈÇ£‰πàËµ∞2-3ËøôÊù°Ë∑ØÂæÑÂç≥ÊâÄËÉΩËøêËæìÁöÑÊúÄÂ§ßÈáçÈáè‰∏∫10Ôºõ Â¶ÇÊûúË¶ÅÂ∞ÜÁâ©ËµÑ‰ªé2ËøêËæìÂà∞4ÔºåÈÇ£‰πàËµ∞2-4ËøôÊù°Ë∑ØÂæÑÂç≥ÊâÄËÉΩËøêËæìÁöÑÊúÄÂ§ßÈáçÈáè‰∏∫8Ôºõ Â¶ÇÊûúË¶ÅÂ∞ÜÁâ©ËµÑ‰ªé3ËøêËæìÂà∞4ÔºåÈÇ£‰πàËµ∞3-2-4ËøôÊù°Ë∑ØÂæÑÂç≥ÊâÄËÉΩËøêËæìÁöÑÊúÄÂ§ßÈáçÈáè‰∏∫8Ôºõ ÊïÖÁ≠îÊ°à‰∏∫8„ÄÇ ÂæàË£∏ÁöÑ‰∏ÄÈÅìÊúÄÂ§ßÁîüÊàêÊ†ëÔºåÊ±ÇÊúÄÂ§ßÁîüÊàêÊ†ëÁöÑÊúÄÂ§ßÊùÉËæπÔºåÊ≥®ÊÑèË∑≥Âá∫Â∞±‰∏ç‰ºöË∂ÖÊó∂„ÄÇ #include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;int t,n,m,i,j;using namespace std; struct s{` int`a,b,c;}k[1000005]; const int maxn=1000005; bool bmp(s a, s b){` return`a.c&gt;b.c;} int par[maxn];void init(){` for`( int i=0;i&lt;=n;i++){` par[i]=i;` }}int find( int x){` if`(par[x]==x) return x;` else`{` return`par[x]=find(par[x]);` }`}void unite( int x, int y){` x=find(x);` y=find(y);` if`(x==y) return ;` else`{` par[y]=x;` }} int main(){` scanf`( &quot;%d&quot; ,&amp;t);` for`(i=0;i&lt;t;i++)` {` scanf ( &quot;%d%d&quot; ,&amp;n,&amp;m);` init();` for (j=0;j&lt;m;j++)` scanf`( &quot;%d%d%d&quot; ,&amp;k[j].a,&amp;k[j].b,&amp;k[j].c);` sort(k,k+m,bmp);` int res=0,l=0;` for`(j=0;j&lt;m;j++)` {` if (find(k[j].a)!=find(k[j].b))` {` unite(k[j].a,k[j].b);` res=k[j].c;` if (++l==n-1) break ;` }` if (l==n-1) break ;` }` printf ( &quot;Case #%d: %d\n&quot; ,i+1,res);` }` return 0;}]]></content>
      <tags>
        <tag>CSDNËøÅÁßª</tag>
      </tags>
  </entry>
</search>

<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css?v=1.0.2">























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false,"dimmer":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="为了方便查看最终源码，我将代码放到了我的github上。后面会把前面lab的也会添加进去。lab4有很多细节，所以有些东西我会分一下测试程序。 Lab 4: Preemptive Multitasking PartA:  为JOS增添多处理器支持特性。  实现round-robin scheduling循环调度。  添加一个基本的环境（进程）管理系统调用（创建和销毁环境，分配和映射内存）。 Par">
<meta name="keywords" content="MIT6.828">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT6.828(四)Lab4:Preemptive Multitasking">
<meta property="og:url" content="https://etbubble.github.io/2020/02/18/MIT-6.828-(四)-Lab-4-Preemptive-Multitasking/index.html">
<meta property="og:site_name" content="ET_BUBBLE 的博客">
<meta property="og:description" content="为了方便查看最终源码，我将代码放到了我的github上。后面会把前面lab的也会添加进去。lab4有很多细节，所以有些东西我会分一下测试程序。 Lab 4: Preemptive Multitasking PartA:  为JOS增添多处理器支持特性。  实现round-robin scheduling循环调度。  添加一个基本的环境（进程）管理系统调用（创建和销毁环境，分配和映射内存）。 Par">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-02-18T14:02:10.730Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MIT6.828(四)Lab4:Preemptive Multitasking">
<meta name="twitter:description" content="为了方便查看最终源码，我将代码放到了我的github上。后面会把前面lab的也会添加进去。lab4有很多细节，所以有些东西我会分一下测试程序。 Lab 4: Preemptive Multitasking PartA:  为JOS增添多处理器支持特性。  实现round-robin scheduling循环调度。  添加一个基本的环境（进程）管理系统调用（创建和销毁环境，分配和映射内存）。 Par">



  <link rel="alternate" href="/atom.xml" title="ET_BUBBLE 的博客" type="application/atom+xml">




  <link rel="canonical" href="https://etbubble.github.io/2020/02/18/MIT-6.828-(四)-Lab-4-Preemptive-Multitasking/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>MIT6.828(四)Lab4:Preemptive Multitasking | ET_BUBBLE 的博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ET_BUBBLE 的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">两件事一定不能停 学习和运动</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://etbubble.github.io/2020/02/18/MIT-6.828-(四)-Lab-4-Preemptive-Multitasking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="尘">
      <meta itemprop="description" content="做自己不会做的事被称之为学习">
      <meta itemprop="image" content="/images/tou.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ET_BUBBLE 的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">MIT6.828(四)Lab4:Preemptive Multitasking

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-18 21:41:21 / 修改时间：22:02:10" itemprop="dateCreated datePublished" datetime="2020-02-18T21:41:21+08:00">2020-02-18</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/操作系统/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/操作系统/MIT6-828/" itemprop="url" rel="index"><span itemprop="name">MIT6.828</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">69k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1:03</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>为了方便查看最终源码，我将代码放到了我的<a href="https://github.com/ETBUBBLE/MIT6.828" target="_blank" rel="noopener">github</a>上。后面会把前面<code>lab</code>的也会添加进去。<code>lab4</code>有很多细节，所以有些东西我会分一下测试程序。</p>
<h1 id="Lab-4-Preemptive-Multitasking"><a href="#Lab-4-Preemptive-Multitasking" class="headerlink" title="Lab 4: Preemptive Multitasking"></a><a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab4/" target="_blank" rel="noopener">Lab 4: Preemptive Multitasking</a></h1><ul>
<li>PartA:<br>  为<code>JOS</code>增添多处理器支持特性。<br>  实现<code>round-robin scheduling</code>循环调度。<br>  添加一个基本的环境（进程）管理系统调用（创建和销毁环境，分配和映射内存）。</li>
<li>PartB:<br>  实现一个类<code>Unix</code>的<code>fork()</code>,其允许一个用户模式的环境能创建一份它自身的拷贝。</li>
<li><p>PartC:</p>
<p>  支持进程间通信（<code>inter-process communication</code>, <code>IPC</code>）<br>  支持硬件时钟中断和抢占</p>
</li>
</ul>
<p>做个大致介绍让你明白要做啥。<br>然后就让你切换到<code>lab4</code>，每个<code>lab</code> 必须做的事情，然后会多出来一些文件。每个文件的作用看翻译应该就能明白，在我的<code>github</code>每个文件最前面也有注释。</p>
<h1 id="Part-A-Multiprocessor-Support-and-Cooperative-Multitasking"><a href="#Part-A-Multiprocessor-Support-and-Cooperative-Multitasking" class="headerlink" title="Part A: Multiprocessor Support and Cooperative Multitasking"></a>Part A: Multiprocessor Support and Cooperative Multitasking</h1><p>先是一堆介绍，就是告诉你要实现轮转调度。后面会为你实现抢占式调度。还有要多<code>CPU</code> 支持。</p>
<h2 id="Multiprocessor-Support"><a href="#Multiprocessor-Support" class="headerlink" title="Multiprocessor Support"></a>Multiprocessor Support</h2><p>我们将让 JOS 支持对称多处理器（<code>symmetric multiprocessing</code>，<code>SMP</code>），具体是什么东西自己去看讲操作系统的书。CPU功能基本都是一样的，但是在引导过程中可以分为两类：</p>
<ul>
<li>引导处理器（BSP）：负责初始化系统和引导操作系统;</li>
<li>应用程序处理器（AP）：只有在操作系统启动并运行后，BSP才会激活应用程序处理器。</li>
</ul>
<p>在我们前面所做过的所有实验都是在<code>BSP</code>上面，现在我们要做的就是在<code>BSP</code>上启动<code>AP</code>。对于哪一个CPU是<code>BSP</code>是硬件决定的。<br>每个CPU都有自己的<a href="https://baike.baidu.com/item/APIC/9329652?fr=aladdin" target="_blank" rel="noopener">APIC</a>，也就是<code>LAPIC</code>。APIC 一句话来说就是可编程中断。</p>
<ul>
<li>根据<code>LAPIC</code>识别码<code>(APIC ID)</code>区别我们的代码运行在哪个CPU上。（<code>cpunum()</code>）</li>
<li>从BSP向APs发送<code>STARTUP</code>处理器间中断（<code>IPI</code>）去唤醒其他的CPU。（<code>lapic_startap()</code>）</li>
<li>在<code>Part C</code>，我们编写LAPIC的内置定时器来触发时钟中断，以支持抢占式多任务（<code>pic_init()</code>）。</li>
</ul>
<p>对于这些我们来看看这个文件<code>kern/lapic.c</code>，一如既往，我们不用知道具体实现，知道一些重要的东西就行。</p>
<h3 id="lapic-c"><a href="#lapic-c" class="headerlink" title="lapic.c"></a>lapic.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The local APIC manages internal (non-I/O) interrupts.</span></span><br><span class="line"><span class="comment">// See Chapter 8 &amp; Appendix C of Intel processor manual volume 3.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Kernel code driving the local APIC unit in each processor</span></span><br><span class="line"><span class="comment">内核代码 用来读取每个处理器地方APIC单元。不知道是用来干啥的 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/memlayout.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/trap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/mmu.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/x86.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;kern/pmap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;kern/cpu.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Local APIC registers, divided by 4 for use as uint32_t[] indices. // LAPIC 寄存器 用4分成一个个索引。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ID      (0x0020/4)   <span class="comment">// ID</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER     (0x0030/4)   <span class="comment">// Version</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TPR     (0x0080/4)   <span class="comment">// Task Priority</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EOI     (0x00B0/4)   <span class="comment">// EOI</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SVR     (0x00F0/4)   <span class="comment">// Spurious Interrupt Vector 伪中断向量</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> ENABLE     0x00000100   <span class="comment">// Unit Enable  单元可用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ESR     (0x0280/4)   <span class="comment">// Error Status   错误信息</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ICRLO   (0x0300/4)   <span class="comment">// Interrupt Command</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> INIT       0x00000500   <span class="comment">// INIT/RESET  初始化</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> STARTUP    0x00000600   <span class="comment">// Startup IPI 开始IPI</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> DELIVS     0x00001000   <span class="comment">// Delivery status</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> ASSERT     0x00004000   <span class="comment">// Assert interrupt (vs deassert)</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> DEASSERT   0x00000000</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> LEVEL      0x00008000   <span class="comment">// Level triggered</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> BCAST      0x00080000   <span class="comment">// Send to all APICs, including self.</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> OTHERS     0x000C0000   <span class="comment">// Send to all APICs, excluding self.</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> BUSY       0x00001000</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> FIXED      0x00000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ICRHI   (0x0310/4)   <span class="comment">// Interrupt Command [63:32]</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER   (0x0320/4)   <span class="comment">// Local Vector Table 0 (TIMER)</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> X1         0x0000000B   <span class="comment">// divide counts by 1</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> PERIODIC   0x00020000   <span class="comment">// Periodic</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCINT   (0x0340/4)   <span class="comment">// Performance Counter LVT</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINT0   (0x0350/4)   <span class="comment">// Local Vector Table 1 (LINT0)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINT1   (0x0360/4)   <span class="comment">// Local Vector Table 2 (LINT1)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR   (0x0370/4)   <span class="comment">// Local Vector Table 3 (ERROR)</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> MASKED     0x00010000   <span class="comment">// Interrupt masked</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TICR    (0x0380/4)   <span class="comment">// Timer Initial Count</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCCR    (0x0390/4)   <span class="comment">// Timer Current Count</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TDCR    (0x03E0/4)   <span class="comment">// Timer Divide Configuration</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">physaddr_t</span> lapicaddr;        <span class="comment">// Initialized in mpconfig.c</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">uint32_t</span> *lapic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">lapicw(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">	lapic[index] = value;</span><br><span class="line">	lapic[ID];  <span class="comment">// wait for write to finish, by reading</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">lapic_init(<span class="keyword">void</span>) <span class="comment">//这个到很part C 才会用到，用于抢占式调度</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!lapicaddr)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// lapicaddr is the physical address of the LAPIC's 4K MMIO //映射这个地址能让我用虚拟地址访问</span></span><br><span class="line">	<span class="comment">// region.  Map it in to virtual memory so we can access it.</span></span><br><span class="line">	lapic = mmio_map_region(lapicaddr, <span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Enable local APIC; set spurious interrupt vector. 开启 伪中断</span></span><br><span class="line">	lapicw(SVR, ENABLE | (IRQ_OFFSET + IRQ_SPURIOUS));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The timer repeatedly counts down at bus frequency</span></span><br><span class="line">	<span class="comment">// from lapic[TICR] and then issues an interrupt.  </span></span><br><span class="line">	<span class="comment">// If we cared more about precise timekeeping, //重负时间中断，可以用外面时钟来校准</span></span><br><span class="line">	<span class="comment">// TICR would be calibrated using an external time source.</span></span><br><span class="line">	lapicw(TDCR, X1);</span><br><span class="line">	lapicw(TIMER, PERIODIC | (IRQ_OFFSET + IRQ_TIMER));</span><br><span class="line">	lapicw(TICR, <span class="number">10000000</span>); </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Leave LINT0 of the BSP enabled so that it can get</span></span><br><span class="line">	<span class="comment">// interrupts from the 8259A chip.</span></span><br><span class="line">	<span class="comment">//不懂啥意思</span></span><br><span class="line">	<span class="comment">// According to Intel MP Specification, the BIOS should initialize</span></span><br><span class="line">	<span class="comment">// BSP's local APIC in Virtual Wire Mode, in which 8259A's</span></span><br><span class="line">	<span class="comment">// INTR is virtually connected to BSP's LINTIN0. In this mode,</span></span><br><span class="line">	<span class="comment">// we do not need to program the IOAPIC.</span></span><br><span class="line">	<span class="keyword">if</span> (thiscpu != bootcpu)</span><br><span class="line">		lapicw(LINT0, MASKED);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Disable NMI (LINT1) on all CPUs 这个也不知道</span></span><br><span class="line">	lapicw(LINT1, MASKED);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Disable performance counter overflow interrupts</span></span><br><span class="line">	<span class="comment">// on machines that provide that interrupt entry.</span></span><br><span class="line">	<span class="keyword">if</span> (((lapic[VER]&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0xFF</span>) &gt;= <span class="number">4</span>)</span><br><span class="line">		lapicw(PCINT, MASKED);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Map error interrupt to IRQ_ERROR. 映射错误中断</span></span><br><span class="line">	lapicw(ERROR, IRQ_OFFSET + IRQ_ERROR);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Clear error status register (requires back-to-back writes). 清楚寄存器</span></span><br><span class="line">	lapicw(ESR, <span class="number">0</span>);</span><br><span class="line">	lapicw(ESR, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ack any outstanding interrupts.</span></span><br><span class="line">	lapicw(EOI, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Send an Init Level De-Assert to synchronize arbitration ID's.</span></span><br><span class="line">	lapicw(ICRHI, <span class="number">0</span>);</span><br><span class="line">	lapicw(ICRLO, BCAST | INIT | LEVEL);</span><br><span class="line">	<span class="keyword">while</span>(lapic[ICRLO] &amp; DELIVS)</span><br><span class="line">		;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Enable interrupts on the APIC (but not on the processor).启用 中断</span></span><br><span class="line">	lapicw(TPR, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">cpunum(<span class="keyword">void</span>) <span class="comment">//这个用到的非常多，返回当前CPU是第几个</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (lapic)</span><br><span class="line">		<span class="keyword">return</span> lapic[ID] &gt;&gt; <span class="number">24</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Acknowledge interrupt. 确认中断，没怎么用到</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">lapic_eoi(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (lapic)</span><br><span class="line">		lapicw(EOI, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Spin for a given number of microseconds.</span></span><br><span class="line"><span class="comment">// On real hardware would want to tune this dynamically.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">microdelay(<span class="keyword">int</span> us)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IO_RTC  0x70</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Start additional processor running entry code at addr. 启动额外处理器 后面就会用到</span></span><br><span class="line"><span class="comment">// See Appendix B of MultiProcessor Specification.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">lapic_startap(<span class="keyword">uint8_t</span> apicid, <span class="keyword">uint32_t</span> addr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">uint16_t</span> *wrv;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// "The BSP must initialize CMOS shutdown code to 0AH</span></span><br><span class="line">	<span class="comment">// and the warm reset vector (DWORD based at 40:67) to point at</span></span><br><span class="line">	<span class="comment">// the AP startup code prior to the [universal startup algorithm]."</span></span><br><span class="line">	outb(IO_RTC, <span class="number">0xF</span>);  <span class="comment">// offset 0xF is shutdown code</span></span><br><span class="line">	outb(IO_RTC+<span class="number">1</span>, <span class="number">0x0A</span>);</span><br><span class="line">	wrv = (<span class="keyword">uint16_t</span> *)KADDR((<span class="number">0x40</span> &lt;&lt; <span class="number">4</span> | <span class="number">0x67</span>));  <span class="comment">// Warm reset vector</span></span><br><span class="line">	wrv[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	wrv[<span class="number">1</span>] = addr &gt;&gt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// "Universal startup algorithm."</span></span><br><span class="line">	<span class="comment">// Send INIT (level-triggered) interrupt to reset other CPU.</span></span><br><span class="line">	lapicw(ICRHI, apicid &lt;&lt; <span class="number">24</span>);</span><br><span class="line">	lapicw(ICRLO, INIT | LEVEL | ASSERT);</span><br><span class="line">	microdelay(<span class="number">200</span>);</span><br><span class="line">	lapicw(ICRLO, INIT | LEVEL);</span><br><span class="line">	microdelay(<span class="number">100</span>);    <span class="comment">// should be 10ms, but too slow in Bochs!</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Send startup IPI (twice!) to enter code.</span></span><br><span class="line">	<span class="comment">// Regular hardware is supposed to only accept a STARTUP</span></span><br><span class="line">	<span class="comment">// when it is in the halted state due to an INIT.  So the second</span></span><br><span class="line">	<span class="comment">// should be ignored, but it is part of the official Intel algorithm.</span></span><br><span class="line">	<span class="comment">// Bochs complains about the second one.  Too bad for Bochs.</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">		lapicw(ICRHI, apicid &lt;&lt; <span class="number">24</span>);</span><br><span class="line">		lapicw(ICRLO, STARTUP | (addr &gt;&gt; <span class="number">12</span>));</span><br><span class="line">		microdelay(<span class="number">200</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">lapic_ipi(<span class="keyword">int</span> <span class="built_in">vector</span>)</span><br><span class="line">&#123;</span><br><span class="line">	lapicw(ICRLO, OTHERS | FIXED | <span class="built_in">vector</span>);</span><br><span class="line">	<span class="keyword">while</span> (lapic[ICRLO] &amp; DELIVS)</span><br><span class="line">		;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看了上面的，其实啥都不知道，就耽误了下时间。。。。<br><code>LAPIC</code>的 <code>hole</code> 开始于物理地址<code>0xFE000000</code>(<code>4GB</code>之下的<code>32MB</code>)，但是这地址太高我们无法访问通过过去的直接映射(虚拟地址<code>0xF0000000</code>映射<code>0x0</code>，即只有<code>256MB</code>)。但是<code>JOS</code>虚拟地址映射预留了<code>4MB</code>空间在<code>MMIOBASE</code>处，我们需要分配映射空间。<br><code>练习 1</code> 要我们实现 <code>kern/pmap.c</code> 里的<code>mmio_map_region</code>，刚才我们上面那个文件有一句<code>lapic = mmio_map_region(lapicaddr, 4096);</code>。和我们实现过的<code>boot_map_region</code>很像，照着来就行了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Reserve size bytes in the MMIO region and map [pa,pa+size) at this</span></span><br><span class="line"><span class="comment">// location.  Return the base of the reserved region.  size does *not*</span></span><br><span class="line"><span class="comment">// have to be multiple of PGSIZE.</span></span><br><span class="line"><span class="comment">// 映射 size 大小的 空间，必须页对齐。</span></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">mmio_map_region(<span class="keyword">physaddr_t</span> pa, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Where to start the next region.  Initially, this is the</span></span><br><span class="line">	<span class="comment">// beginning of the MMIO region.  Because this is static, its</span></span><br><span class="line">	<span class="comment">// value will be preserved between calls to mmio_map_region</span></span><br><span class="line">	<span class="comment">// (just like nextfree in boot_alloc). //这个和boot_alloc 是一样的，下一次进入这个函数地址就是上一个地址 的后面</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">uintptr_t</span> base = MMIOBASE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Reserve size bytes of virtual memory starting at base and</span></span><br><span class="line">	<span class="comment">// map physical pages [pa,pa+size) to virtual addresses 映射pa 到base</span></span><br><span class="line">	<span class="comment">// [base,base+size).  Since this is device memory and not 因为不是DRAM 内存</span></span><br><span class="line">	<span class="comment">// regular DRAM, you'll have to tell the CPU that it isn't 你不许告诉CPU是不安全的去高速缓存直接访问这个内存。</span></span><br><span class="line">	<span class="comment">// safe to cache access to this memory.  Luckily, the page  幸运的是 页表提供这种模板</span></span><br><span class="line">	<span class="comment">// tables provide bits for this purpose; simply create the 简单的用了两个标志位PTE_PCD|PTE_PWT</span></span><br><span class="line">	<span class="comment">// mapping with PTE_PCD|PTE_PWT (cache-disable and</span></span><br><span class="line">	<span class="comment">// write-through) in addition to PTE_W.  (If you're interested</span></span><br><span class="line">	<span class="comment">// in more details on this, see section 10.5 of IA32 volume</span></span><br><span class="line">	<span class="comment">// 3A.)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Be sure to round size up to a multiple of PGSIZE and to //确保也对其 没有溢出 MMIOLIM 不然就是 panic</span></span><br><span class="line">	<span class="comment">// handle if this reservation would overflow MMIOLIM (it's</span></span><br><span class="line">	<span class="comment">// okay to simply panic if this happens).</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Hint: The staff solution uses boot_map_region.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Your code here:</span></span><br><span class="line">    size = ROUNDUP(size, PGSIZE);<span class="comment">//页对齐然后映射  后面这个标志位，就是前面设定的  </span></span><br><span class="line">    <span class="comment">//个人感觉如果这个地方溢出了应该要判断一下，但是好像并没有这个测试所以好像没啥问题。</span></span><br><span class="line">    boot_map_region(kern_pgdir, base, size, pa, PTE_W | PTE_PWT | PTE_PCD);</span><br><span class="line">    base += size;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)base-size;</span><br><span class="line">    <span class="comment">//github 上面和这个不一样但是差距也不大。</span></span><br><span class="line">	<span class="comment">//panic("mmio_map_region not implemented");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Application-Processor-Bootstrap"><a href="#Application-Processor-Bootstrap" class="headerlink" title="Application Processor Bootstrap"></a>Application Processor Bootstrap</h2><p>在我们启动APs之前BSP需要收集他们的信息。比如数量，APICID 和他们映射的地址。<code>kern/mpconfig.c</code>里面的<code>mp_init</code>就是干这个的。我们去看看他在哪调用的，这些东西肯定是在初始化函数里面。</p>
<h3 id="i386-init"><a href="#i386-init" class="headerlink" title="i386_init"></a>i386_init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">i386_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Initialize the console.</span></span><br><span class="line">	<span class="comment">// Can't call cprintf until after we do this!</span></span><br><span class="line">	cons_init();</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">"6828 decimal is %o octal!\n"</span>, <span class="number">6828</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Lab 2 memory management initialization functions</span></span><br><span class="line">	mem_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Lab 3 user environment initialization functions</span></span><br><span class="line">	env_init();</span><br><span class="line">	trap_init();</span><br><span class="line">	<span class="comment">//在这之前都是没有变的。</span></span><br><span class="line">	<span class="comment">// Lab 4 multiprocessor initialization functions</span></span><br><span class="line">	mp_init(); <span class="comment">//这个就是收集信息。</span></span><br><span class="line">	lapic_init();<span class="comment">//初始化自己lapic  这个时候其他CPU还没有启动，此时还是BSP</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Lab 4 multitasking initialization functions</span></span><br><span class="line">	pic_init();  <span class="comment">//多作业初始化，等会要看看</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Acquire the big kernel lock before waking up APs</span></span><br><span class="line">	<span class="comment">// Your code here:</span></span><br><span class="line">	lock_kernel();  <span class="comment">//这个是我写的，是后面的，不用着急。</span></span><br><span class="line">	<span class="comment">// Starting non-boot CPUs</span></span><br><span class="line">	boot_aps();  <span class="comment">//这个地方就是引导程序了。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(TEST)</span></span><br><span class="line">	<span class="comment">// Don't touch -- used by grading script!</span></span><br><span class="line">	ENV_CREATE(TEST, ENV_TYPE_USER);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="comment">// Touch all you want.</span></span><br><span class="line">	ENV_CREATE(user_primes, ENV_TYPE_USER);  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// TEST*</span></span></span><br><span class="line">	<span class="comment">// Schedule and run the first user environment!开始调度</span></span><br><span class="line">	sched_yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看完后我们去看看<code>mp_init()</code>。并没有要我们实现，过一眼就行了，由于注释太少，所以没看懂。知道他把所有CPU信息收集完就行了。<br><code>boot_aps()</code> 是引导其他CPU启动的。他和<code>bootloader</code> 差不多。所以他也是从实模式开始的。我们将<code>kern/mpentry.S</code>加载到<code>0x7000</code>，<del>很眼熟…</del>,好像只要是没有用的页对齐的低于640的地址都可以。<br>然后欧美就去看看他做了啥。</p>
<h3 id="boot-aps"><a href="#boot-aps" class="headerlink" title="boot_aps"></a>boot_aps</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start the non-boot (AP) processors.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">boot_aps(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> mpentry_start[], mpentry_end[]; <span class="comment">//那段代码的开始和结束</span></span><br><span class="line">	<span class="keyword">void</span> *code;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">CpuInfo</span> *<span class="title">c</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Write entry code to unused memory at MPENTRY_PADDR #define MPENTRY_PADDR	0x7000</span></span><br><span class="line">	code = KADDR(MPENTRY_PADDR); <span class="comment">//找到这个地址 在memlayout 里面宏定义了。</span></span><br><span class="line">	memmove(code, mpentry_start, mpentry_end - mpentry_start);<span class="comment">//把代码复制进去</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Boot each AP one at a time</span></span><br><span class="line">	<span class="keyword">for</span> (c = cpus; c &lt; cpus + ncpu; c++) &#123; <span class="comment">//CPUS 是啥 NCPU 是啥？？？ 就是前面那个我们没有讲的文件里面收集的，cpus 是 所有CPUS的数组，ncpu 是个数</span></span><br><span class="line">		<span class="keyword">if</span> (c == cpus + cpunum())  <span class="comment">// We've started already.  不是自己这个CPU</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Tell mpentry.S what stack to use 这个是每个CPU的栈，现在还没有映射，等会要做的就是这个</span></span><br><span class="line">		mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;</span><br><span class="line">		<span class="comment">// Start the CPU at mpentry_start</span></span><br><span class="line">		lapic_startap(c-&gt;cpu_id, PADDR(code)); <span class="comment">//这个就是开始启动CPUS4了</span></span><br><span class="line">		<span class="comment">// Wait for the CPU to finish some basic setup in mp_main()</span></span><br><span class="line">		<span class="keyword">while</span>(c-&gt;cpu_status != CPU_STARTED) <span class="comment">//等待这个CPU启动玩 </span></span><br><span class="line">			;</span><br><span class="line">		<span class="comment">//在 mp_main里有这么一行 xchg(&amp;thiscpu-&gt;cpu_status, CPU_STARTED); // tell boot_aps() we're up</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们去看看<code>mp_main()</code>在哪进入的。我们能够看出<code>boot_aps</code>,让我慢慢跑去了<code>mpentry_start</code>。</p>
<h3 id="mpentry-start"><a href="#mpentry-start" class="headerlink" title="mpentry_start"></a>mpentry_start</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* See COPYRIGHT for copyright information. */</span></span><br><span class="line"><span class="comment">/*Assembly-language entry code for non-boot CPUs   汇编代码启动 非引导CPU  应该不会要动，这种东西一般都是固定的*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/mmu.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/memlayout.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">###################################################################</span><br><span class="line"><span class="meta"># entry point for APs</span></span><br><span class="line">###################################################################</span><br><span class="line"></span><br><span class="line"># Each non-<span class="function">boot <span class="title">CPU</span> <span class="params">(<span class="string">"AP"</span>)</span> is started up in response to a STARTUP</span></span><br><span class="line"># IPI from the boot CPU.  Section B.4.2 of the Multi-Processor</span><br><span class="line"># Specification says that the AP will start in real mode with CS:IP</span><br><span class="line"><span class="meta"># set to XY00:0000, where XY is an 8-bit value sent with the</span></span><br><span class="line"># STARTUP. Thus <span class="keyword">this</span> code must start at a <span class="number">4096</span>-byte boundary.</span><br><span class="line"># 代码必须从<span class="number">4096</span>开始运行，和那个bootloader 没多大差距，除了我们能控制在哪运行</span><br><span class="line"># Because <span class="keyword">this</span> code sets DS to zero, it must run from an address in</span><br><span class="line"><span class="meta"># the low 2^16 bytes of physical memory.</span></span><br><span class="line">#</span><br><span class="line"># boot_aps() (in init.c) <span class="function">copies <span class="keyword">this</span> code to <span class="title">MPENTRY_PADDR</span> <span class="params">(which</span></span></span><br><span class="line"># satisfies the above restrictions).  Then, for each AP, it stores the</span><br><span class="line"><span class="meta"># address of the pre-allocated per-core stack in mpentry_kstack, sends</span></span><br><span class="line"><span class="meta"># the STARTUP IPI, and waits for this code to acknowledge that it has</span></span><br><span class="line"><span class="meta"># started (which happens in mp_main in init.c).</span></span><br><span class="line">#</span><br><span class="line"># This code is similar to boot/boot.S except that</span><br><span class="line">#    - it does <span class="keyword">not</span> need to enable A20</span><br><span class="line">#    - it uses MPBOOTPHYS to calculate absolute addresses of its</span><br><span class="line"><span class="meta">#      symbols, rather than relying on the linker to fill them</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RELOC(x) ((x) - KERNBASE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPBOOTPHYS(s) ((s) - mpentry_start + MPENTRY_PADDR) <span class="comment">//这个是因为BSP已经是在保护模式下了没法直接访问，当前CPU又在实模式，是不能访问呢 1M以上的内存，所以要映射一下。</span></span></span><br><span class="line"></span><br><span class="line">.<span class="built_in">set</span> PROT_MODE_CSEG, <span class="number">0x8</span>	<span class="meta"># kernel code segment selector</span></span><br><span class="line">.<span class="built_in">set</span> PROT_MODE_DSEG, <span class="number">0x10</span>	<span class="meta"># kernel data segment selector</span></span><br><span class="line"></span><br><span class="line">.code16           </span><br><span class="line">.globl mpentry_start</span><br><span class="line">mpentry_start:</span><br><span class="line">	cli            </span><br><span class="line"></span><br><span class="line">	xorw    %ax, %ax</span><br><span class="line">	movw    %ax, %ds</span><br><span class="line">	movw    %ax, %es</span><br><span class="line">	movw    %ax, %ss</span><br><span class="line"></span><br><span class="line">	<span class="function">lgdt    <span class="title">MPBOOTPHYS</span><span class="params">(gdtdesc)</span></span></span><br><span class="line">	movl    %cr0, %eax</span><br><span class="line">	orl     $CR0_PE, %eax</span><br><span class="line">	movl    %eax, %cr0</span><br><span class="line"></span><br><span class="line">	ljmpl   $(PROT_MODE_CSEG), $(MPBOOTPHYS(start32))</span><br><span class="line"></span><br><span class="line">.code32</span><br><span class="line">start32:</span><br><span class="line">	movw    $(PROT_MODE_DSEG), %ax</span><br><span class="line">	movw    %ax, %ds</span><br><span class="line">	movw    %ax, %es</span><br><span class="line">	movw    %ax, %ss</span><br><span class="line">	movw    $<span class="number">0</span>, %ax</span><br><span class="line">	movw    %ax, %fs</span><br><span class="line">	movw    %ax, %gs</span><br><span class="line"></span><br><span class="line">	# Set up initial page table. We cannot use kern_pgdir yet because</span><br><span class="line">	<span class="meta"># we are still running at a low EIP.</span></span><br><span class="line">	movl    $(RELOC(entry_pgdir)), %eax</span><br><span class="line">	movl    %eax, %cr3</span><br><span class="line">	# Turn on paging.</span><br><span class="line">	movl    %cr0, %eax</span><br><span class="line">	orl     $(CR0_PE|CR0_PG|CR0_WP), %eax</span><br><span class="line">	movl    %eax, %cr0</span><br><span class="line"></span><br><span class="line">	# Switch to the per-<span class="function">cpu <span class="built_in">stack</span> allocated in <span class="title">boot_aps</span><span class="params">()</span></span></span><br><span class="line">	movl    mpentry_kstack, %esp</span><br><span class="line">	movl    $<span class="number">0x0</span>, %ebp       <span class="meta"># nuke frame pointer</span></span><br><span class="line"></span><br><span class="line">	# Call mp_main().  (Exercise for the reader: why the indirect call?) 在这个地方我们跑去了 mp_main</span><br><span class="line">	movl    $mp_main, %eax</span><br><span class="line">	call    *%eax  </span><br><span class="line"></span><br><span class="line">	# If mp_main returns (it shouldn't), loop.</span><br><span class="line">spin:</span><br><span class="line">	jmp     spin</span><br><span class="line"></span><br><span class="line"># Bootstrap GDT</span><br><span class="line">.p2align <span class="number">2</span>					<span class="meta"># force 4 byte alignment</span></span><br><span class="line">gdt:</span><br><span class="line">	SEG_NULL				<span class="meta"># null seg</span></span><br><span class="line">	SEG(STA_X|STA_R, <span class="number">0x0</span>, <span class="number">0xffffffff</span>)	<span class="meta"># code seg</span></span><br><span class="line">	SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xffffffff</span>)		<span class="meta"># data seg</span></span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">	.word   <span class="number">0x17</span>				<span class="meta"># sizeof(gdt) - 1</span></span><br><span class="line">	.<span class="function"><span class="keyword">long</span>   <span class="title">MPBOOTPHYS</span><span class="params">(gdt)</span>			<span class="meta"># address gdt</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">.globl mpentry_end</span><br><span class="line">mpentry_end:</span><br><span class="line">	nop</span><br></pre></td></tr></table></figure>
<p>再看看<code>mp_main</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Setup code for APs</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">mp_main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// We are in high EIP now, safe to switch to kern_pgdir </span></span><br><span class="line">	lcr3(PADDR(kern_pgdir));  <span class="comment">//加载内核页</span></span><br><span class="line">	cprintf(<span class="string">"SMP: CPU %d starting\n"</span>, cpunum());</span><br><span class="line"></span><br><span class="line">	lapic_init();<span class="comment">//这三个初始化一些东西，应该看的出初始化了啥。</span></span><br><span class="line">	env_init_percpu();</span><br><span class="line">	trap_init_percpu();</span><br><span class="line">	xchg(&amp;thiscpu-&gt;cpu_status, CPU_STARTED); <span class="comment">// tell boot_aps() we're up</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now that we have finished some basic setup, call sched_yield()</span></span><br><span class="line">	<span class="comment">// to start running processes on this CPU.  But make sure that</span></span><br><span class="line">	<span class="comment">// only one CPU can enter the scheduler at a time!</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Your code here:</span></span><br><span class="line">	lock_kernel();<span class="comment">//这个是内核锁，后面会讲的。</span></span><br><span class="line">	<span class="comment">// Remove this after you finish Exercise 6</span></span><br><span class="line">	<span class="comment">//for (;;);</span></span><br><span class="line">	sched_yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们<code>练习2</code>让我们再开一些内存给他启动用。这个地方我在思考，运行完之后难道不用把这块内存重新加入内存空闲列表吗？？在我们<code>page_init</code> 后面继续添加几行就可以了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LAB 4:</span></span><br><span class="line"><span class="comment">// Change your code to mark the physical page at MPENTRY_PADDR</span></span><br><span class="line"><span class="comment">// as in use</span></span><br><span class="line"><span class="comment">// 把MPENTRY_PADDR这块地址也在空闲列表里面删除。</span></span><br><span class="line"><span class="keyword">uint32_t</span> range_mpentry = PGNUM(MPENTRY_PADDR);</span><br><span class="line">pages[range_mpentry+<span class="number">1</span>].pp_link=pages[range_mpentry].pp_link;</span><br><span class="line">pages[range_mpentry].pp_link=<span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><ol>
<li>boot.S中，由于尚没有启用分页机制，所以我们能够指定程序开始执行的地方以及程序加载的地址；但是，在mpentry.S的时候，由于主CPU已经处于保护模式下了，因此是不能直接指定物理地址的，给定线性地址，映射到相应的物理地址是允许的。</li>
</ol>
<h2 id="Per-CPU-State-and-Initialization"><a href="#Per-CPU-State-and-Initialization" class="headerlink" title="Per-CPU State and Initialization"></a>Per-CPU State and Initialization</h2><p>在多处理器CPU中，知道自己是哪个CPU十分重要。前面我们已经分析过怎么获取所有CPU的信息 <del>(假装我们知道过程)</del>。<code>kern/cpu.h</code>里面定义了各种我们想要的信息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Kernel-private definitions for multiprocessor support</span></span><br><span class="line"><span class="comment">多处理器支持的私有内核定义</span></span><br><span class="line"><span class="comment">应该是 定义了 多处理器的一些操作 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> JOS_INC_CPU_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JOS_INC_CPU_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/memlayout.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/mmu.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/env.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Maximum number of CPUs</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NCPU  8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Values of status in struct Cpu</span></span><br><span class="line"><span class="keyword">enum</span> &#123;			<span class="comment">//这个是CPU状态</span></span><br><span class="line">	CPU_UNUSED = <span class="number">0</span>,</span><br><span class="line">	CPU_STARTED,</span><br><span class="line">	CPU_HALTED,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-CPU state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CpuInfo</span> &#123;</span>	<span class="comment">//CPU信息</span></span><br><span class="line">	<span class="keyword">uint8_t</span> cpu_id;                 <span class="comment">// Local APIC ID; index into cpus[] below 第几个CPU</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">unsigned</span> cpu_status;   <span class="comment">// The status of the CPU 状态</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">cpu_env</span>;</span>            <span class="comment">// The currently-running environment. 当前运行的环境</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Taskstate</span> <span class="title">cpu_ts</span>;</span>        <span class="comment">// Used by x86 to find stack for interrupt cpu中断栈</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialized in mpconfig.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">CpuInfo</span> <span class="title">cpus</span>[<span class="title">NCPU</span>];</span>	<span class="comment">//这几个就是收集到的信息...</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> ncpu;                    <span class="comment">// Total number of CPUs in the system 数量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">CpuInfo</span> *<span class="title">bootcpu</span>;</span>     <span class="comment">// The boot-strap processor (BSP) BSP的信息</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">physaddr_t</span> lapicaddr;        <span class="comment">// Physical MMIO address of the local APIC 物理地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-CPU kernel stacks</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> percpu_kstacks[NCPU][KSTKSIZE]; <span class="comment">///每个CPU的内核栈 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cpunum</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">//获取自己这个CPU的id</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> thiscpu (&amp;cpus[cpunum()]) <span class="comment">//指向自己这个CPU</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mp_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;	<span class="comment">//收集所有CPU信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lapic_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//中断初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lapic_startap</span><span class="params">(<span class="keyword">uint8_t</span> apicid, <span class="keyword">uint32_t</span> addr)</span></span>;<span class="comment">//CPU启动</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lapic_eoi</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//Acknowledge interrupt.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lapic_ipi</span><span class="params">(<span class="keyword">int</span> <span class="built_in">vector</span>)</span></span>;<span class="comment">//不知道是啥</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>每个CPU独有的属性：</p>
<ul>
<li><code>Per-CPU kernel stack</code>，因为不同的CPU可能同时陷入到内核，因此每个CPU需要有不同的内核栈防止彼此之间的干扰。数组<code>percpu_kstacks[NCPU][KSTKSIZE]</code>给NCPU个CPU保留了内核栈的空间。在lab2中，将物理地址bootstack映射到BSP的内核栈的虚拟地址<code>KSTACKTOP-KSTKSIZE</code>。相似的，在本次实验中，你将映射每个CPU的内核栈到这个区域，并且每个栈之间相隔一个<code>guard pages</code>作为缓冲。CPU0的栈将从<code>KSTACKTOP</code>向下增长，CPU 1的栈将在CPU 0的栈增长方向的底部之后的<code>KSTKGAP</code>字节开始。</li>
<li><code>Per-CPU TSS and TSS descriptor</code>，每个CPU的都需要任务状态段用以区分不同的CPU内核栈的位置。CPU i的<code>TSS</code>在<code>cpus[i].cpu_ts</code>中存储，相应的<code>TSS</code>描述符在<code>GDT</code>表项<code>gdt[(GD_TSS0 &gt;&gt; 3) + i]</code>中。定义在<code>kern/trap</code>全局变量<code>ts</code>将不会再使用。</li>
<li><code>Per-CPU current environment pointer</code>，由于每个CPU可以同时运行不同的用户环境，我们定义符号<code>curenv</code>表示<code>cpus[cpunum()].cpu_env</code>(或者是<code>thiscpu-&gt;cpu_env</code>)，指向正在当前CPU上运行的用户环境。</li>
<li><code>Per-CPU system registers</code>，包括系统寄存器在内的所有寄存器对每个CPU来说都是私有的。因此，初始化这些寄存器的指令，如<code>lcr3(), ltr(), lgdt(), lidt()</code>等等必须在每个CPU上执行一次。函数<code>env_init_percpu()</code>和<code>trap_init_percpu()</code>就是为了实现这个功能。</li>
<li></li>
</ul>
<p><code>练习3</code> 让我实现内存每个CPU的栈分配，在<code>kern/pmap.c</code>中的<code>mem_init_mp()</code>。</p>
<h3 id="mem-init-mp"><a href="#mem-init-mp" class="headerlink" title="mem_init_mp"></a>mem_init_mp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Modify mappings in kern_pgdir to support SMP</span></span><br><span class="line"><span class="comment">//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line"><span class="comment">//映射去支持SMP 映射地址是 [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">mem_init_mp(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Map per-CPU stacks starting at KSTACKTOP, for up to 'NCPU' CPUs.</span></span><br><span class="line">	<span class="comment">//映射地址从 KSTACKTOP 开始</span></span><br><span class="line">	<span class="comment">// For CPU i, use the physical memory that 'percpu_kstacks[i]' refers 每个CPU i 的物理地址是 'percpu_kstacks[i]</span></span><br><span class="line">	<span class="comment">// to as its kernel stack. CPU i's kernel stack grows down from virtual</span></span><br><span class="line">	<span class="comment">// address kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP), and is 开始地址是 kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP)</span></span><br><span class="line">	<span class="comment">// divided into two pieces, just like the single stack you set up in</span></span><br><span class="line">	<span class="comment">// mem_init:  这个是不是很眼熟，和前面单CPU是一样的  有一块是不用映射的，这样如果栈溢出，就直接RE</span></span><br><span class="line">	<span class="comment">//     * [kstacktop_i - KSTKSIZE, kstacktop_i)</span></span><br><span class="line">	<span class="comment">//          -- backed by physical memory</span></span><br><span class="line">	<span class="comment">//     * [kstacktop_i - (KSTKSIZE + KSTKGAP), kstacktop_i - KSTKSIZE)</span></span><br><span class="line">	<span class="comment">//          -- not backed; so if the kernel overflows its stack,</span></span><br><span class="line">	<span class="comment">//             it will fault rather than overwrite another CPU's stack.</span></span><br><span class="line">	<span class="comment">//             Known as a "guard page".</span></span><br><span class="line">	<span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// LAB 4: Your code here:</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; NCPU; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* code   直接映射即可 */</span></span><br><span class="line">		boot_map_region(kern_pgdir,KSTACKTOP-i*(KSTKSIZE+KSTKGAP)-KSTKSIZE,KSTKSIZE,PADDR(percpu_kstacks[i]),PTE_W);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>练习 4</code> 让我们实现每个CPU的中断初始化，在 <code>kern/trap.c</code>中的<code>trap_init_percpu()</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize and load the per-CPU TSS and IDT 初始化每个CPU的TSS 和IDT</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">trap_init_percpu(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// The example code here sets up the Task State Segment (TSS) and</span></span><br><span class="line">	<span class="comment">// the TSS descriptor for CPU 0. But it is incorrect if we are</span></span><br><span class="line">	<span class="comment">// running on other CPUs because each CPU has its own kernel stack.</span></span><br><span class="line">	<span class="comment">// Fix the code so that it works for all CPUs.</span></span><br><span class="line">	<span class="comment">//已经有了一个TSS描述关于CPU 0，但是我们需要初始化多个CPU的</span></span><br><span class="line">	<span class="comment">// Hints:</span></span><br><span class="line">	<span class="comment">//   - The macro "thiscpu" always refers to the current CPU's</span></span><br><span class="line">	<span class="comment">//     struct CpuInfo; 用thiscpu 指向当前CPU 的CPUinfo</span></span><br><span class="line">	<span class="comment">//   - The ID of the current CPU is given by cpunum() or</span></span><br><span class="line">	<span class="comment">//     thiscpu-&gt;cpu_id; 获取ID</span></span><br><span class="line">	<span class="comment">//   - Use "thiscpu-&gt;cpu_ts" as the TSS for the current CPU,</span></span><br><span class="line">	<span class="comment">//     rather than the global "ts" variable;  获取ts</span></span><br><span class="line">	<span class="comment">//   - Use gdt[(GD_TSS0 &gt;&gt; 3) + i] for CPU i's TSS descriptor;获取 TSS 描述</span></span><br><span class="line">	<span class="comment">//   - You mapped the per-CPU kernel stacks in mem_init_mp() 映射的堆栈</span></span><br><span class="line">	<span class="comment">//   - Initialize cpu_ts.ts_iomb to prevent unauthorized environments</span></span><br><span class="line">	<span class="comment">//     from doing IO (0 is not the correct value!)  初始化 cpu_ts.ts_iomb</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// ltr sets a 'busy' flag in the TSS selector, so if you</span></span><br><span class="line">	<span class="comment">// accidentally load the same TSS on more than one CPU, you'll 每个CPU的TSS 不一样</span></span><br><span class="line">	<span class="comment">// get a triple fault.  If you set up an individual CPU's TSS 如果相同的TSS 就会报错</span></span><br><span class="line">	<span class="comment">// wrong, you may not get a fault until you try to return from</span></span><br><span class="line">	<span class="comment">// user space on that CPU.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// LAB 4: Your code here</span></span><br><span class="line">	<span class="keyword">int</span> i=thiscpu-&gt;cpu_id;<span class="comment">//直接把 ts 改成thiscpu-&gt;cpu_ts</span></span><br><span class="line">	thiscpu-&gt;cpu_ts.ts_esp0=KSTACKTOP-i*(KSTKSIZE+KSTKGAP);<span class="comment">//地址要变</span></span><br><span class="line">	thiscpu-&gt;cpu_ts.ts_ss0=GD_KD;</span><br><span class="line">	thiscpu-&gt;cpu_ts.ts_iomb = <span class="keyword">sizeof</span>(struct Taskstate);</span><br><span class="line">	<span class="comment">//初始化gdt 根据前面的来就行了</span></span><br><span class="line">	gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + i] = SEG16(STS_T32A, (<span class="keyword">uint32_t</span>) (&amp;(thiscpu-&gt;cpu_ts)),</span><br><span class="line">					<span class="keyword">sizeof</span>(struct Taskstate) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + i].sd_s = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// // Setup a TSS so that we get the right stack</span></span><br><span class="line">	<span class="comment">// // when we trap to the kernel.</span></span><br><span class="line">	<span class="comment">// ts.ts_esp0 = KSTACKTOP;</span></span><br><span class="line">	<span class="comment">// ts.ts_ss0 = GD_KD;</span></span><br><span class="line">	<span class="comment">// ts.ts_iomb = sizeof(struct Taskstate);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// // Initialize the TSS slot of the gdt.</span></span><br><span class="line">	<span class="comment">// gdt[GD_TSS0 &gt;&gt; 3] = SEG16(STS_T32A, (uint32_t) (&amp;ts),</span></span><br><span class="line">	<span class="comment">// 				sizeof(struct Taskstate) - 1, 0);</span></span><br><span class="line">	<span class="comment">// gdt[GD_TSS0 &gt;&gt; 3].sd_s = 0;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Load the TSS selector (like other segment selectors, the</span></span><br><span class="line">	<span class="comment">// bottom three bits are special; we leave them 0)</span></span><br><span class="line">	ltr(GD_TSS0+<span class="number">8</span>*i); <span class="comment">//每个占3位  也就是 1&lt;&lt;3=8</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Load the IDT</span></span><br><span class="line">	lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行<code>make qemu CPUS=4</code>就会出现官网上的那些东西。</p>
<h2 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h2><p>大内核锁，简单来讲，就是当一个CPU进入内核的时候，内核锁住，因为多个CPU同是在内核里面运行可能出错。可以自行百度一下。<br>在<code>kern/spinlock.h</code>定义了那些锁。我们去看看。</p>
<h3 id="kern-spinlock-c"><a href="#kern-spinlock-c" class="headerlink" title="kern/spinlock.c"></a>kern/spinlock.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mutual exclusion spin locks.</span></span><br><span class="line"><span class="comment">/* 头文件 介绍过了 ，这个也不用多说了吧*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/x86.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/memlayout.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;kern/cpu.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;kern/spinlock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;kern/kdebug.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The big kernel lock</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">kernel_lock</span> = &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG_SPINLOCK</span></span><br><span class="line">	.name = <span class="string">"kernel_lock"</span></span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG_SPINLOCK</span></span><br><span class="line"><span class="comment">// Record the current call stack in pcs[] by following the %ebp chain. 这个不知道用来噶啥的没用熬过 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">get_caller_pcs(<span class="keyword">uint32_t</span> pcs[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> *ebp;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	ebp = (<span class="keyword">uint32_t</span> *)read_ebp();</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (ebp == <span class="number">0</span> || ebp &lt; (<span class="keyword">uint32_t</span> *)ULIM)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		pcs[i] = ebp[<span class="number">1</span>];          <span class="comment">// saved %eip</span></span><br><span class="line">		ebp = (<span class="keyword">uint32_t</span> *)ebp[<span class="number">0</span>]; <span class="comment">// saved %ebp</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		pcs[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check whether this CPU is holding the lock. 检查当前CPU是否有锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">holding(struct spinlock *lock)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> lock-&gt;locked &amp;&amp; lock-&gt;cpu == thiscpu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">__spin_initlock(struct spinlock *lk, <span class="keyword">char</span> *name)<span class="comment">//初始化锁的样子</span></span><br><span class="line">&#123;</span><br><span class="line">	lk-&gt;locked = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG_SPINLOCK</span></span><br><span class="line">	lk-&gt;name = name;</span><br><span class="line">	lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Acquire the lock.</span></span><br><span class="line"><span class="comment">// Loops (spins) until the lock is acquired.</span></span><br><span class="line"><span class="comment">// Holding a lock for a long time may cause</span></span><br><span class="line"><span class="comment">// other CPUs to waste time spinning to acquire it.//锁住内核</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">spin_lock(struct spinlock *lk)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG_SPINLOCK</span></span><br><span class="line">	<span class="keyword">if</span> (holding(lk))</span><br><span class="line">		panic(<span class="string">"CPU %d cannot acquire %s: already holding"</span>, cpunum(), lk-&gt;name);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The xchg is atomic.</span></span><br><span class="line">	<span class="comment">// It also serializes, so that reads after acquire are not</span></span><br><span class="line">	<span class="comment">// reordered before it. </span></span><br><span class="line">	<span class="keyword">while</span> (xchg(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>) <span class="comment">//如果是已经锁住的，就一直等待</span></span><br><span class="line">		<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"pause"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Record info about lock acquisition for debugging.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG_SPINLOCK</span></span><br><span class="line">	lk-&gt;cpu = thiscpu; <span class="comment">//锁住的CPU变成自己</span></span><br><span class="line">	get_caller_pcs(lk-&gt;pcs);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Release the lock.  解除锁</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">spin_unlock(struct spinlock *lk)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG_SPINLOCK</span></span><br><span class="line">	<span class="keyword">if</span> (!holding(lk)) &#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">uint32_t</span> pcs[<span class="number">10</span>];</span><br><span class="line">		<span class="comment">// Nab the acquiring EIP chain before it gets released</span></span><br><span class="line">		memmove(pcs, lk-&gt;pcs, <span class="keyword">sizeof</span> pcs);</span><br><span class="line">		cprintf(<span class="string">"CPU %d cannot release %s: held by CPU %d\nAcquired at:"</span>, </span><br><span class="line">			cpunum(), lk-&gt;name, lk-&gt;cpu-&gt;cpu_id);</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span> &amp;&amp; pcs[i]; i++) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line">			<span class="keyword">if</span> (debuginfo_eip(pcs[i], &amp;info) &gt;= <span class="number">0</span>)</span><br><span class="line">				cprintf(<span class="string">"  %08x %s:%d: %.*s+%x\n"</span>, pcs[i],</span><br><span class="line">					info.eip_file, info.eip_line,</span><br><span class="line">					info.eip_fn_namelen, info.eip_fn_name,</span><br><span class="line">					pcs[i] - info.eip_fn_addr);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				cprintf(<span class="string">"  %08x\n"</span>, pcs[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		panic(<span class="string">"spin_unlock"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lk-&gt;pcs[<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">	lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The xchg instruction is atomic (i.e. uses the "lock" prefix) with</span></span><br><span class="line">	<span class="comment">// respect to any other instruction which references the same memory.</span></span><br><span class="line">	<span class="comment">// x86 CPUs will not reorder loads/stores across locked instructions</span></span><br><span class="line">	<span class="comment">// (vol 3, 8.2.2). Because xchg() is implemented using asm volatile,</span></span><br><span class="line">	<span class="comment">// gcc will not reorder C statements across the xchg.</span></span><br><span class="line">	xchg(&amp;lk-&gt;locked, <span class="number">0</span>);<span class="comment">//释放内核</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面用的上的函数，也就两个<code>spin_lock</code>和<code>spin_unlock</code>，他们在<code>spinlock.h</code>里面用<code>lock_kernel</code>和<code>unlock_kernel</code>调用。<br>在代码中总共有4处使用了大内核锁：</p>
<ul>
<li>在<code>i386_init()</code>函数中，BSP先获得大内核锁然后再启动其余的CPU</li>
<li>在<code>mp_main()</code>函数中，在初始化AP后获得大内核锁，然后调用<code>sched_yield()</code>开始在这个AP上运行用户环境。</li>
<li>在<code>trap()</code>函数中，从用户态陷入到内核态必须获得大内核锁，通过检查<code>tf_cs</code>的低位确定这个陷入发生在用户态还是在内核态</li>
<li>在<code>env_run()</code>函数中，在切换到用户态之前释放大内核锁，不要太早也不要太晚，否则就会体验一把竞争或者死锁的情况。</li>
</ul>
<p><code>练习5</code>就是让我们在这几个地方调用。<br>第一个 <code>i386_init</code> 里面<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Acquire the big kernel lock before waking up APs</span></span><br><span class="line"><span class="comment">// Your code here:</span></span><br><span class="line">lock_kernel();</span><br><span class="line"><span class="comment">// Starting non-boot CPUs 在这个启动之前调用lock_kernel();</span></span><br><span class="line">boot_aps();</span><br></pre></td></tr></table></figure></p>
<p>第二个 <code>mp_main</code>里面<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Now that we have finished some basic setup, call sched_yield()</span></span><br><span class="line"><span class="comment">// to start running processes on this CPU.  But make sure that</span></span><br><span class="line"><span class="comment">// only one CPU can enter the scheduler at a time!</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Your code here:</span></span><br><span class="line">lock_kernel();<span class="comment">//锁住内核</span></span><br><span class="line"><span class="comment">// Remove this after you finish Exercise 6</span></span><br><span class="line"><span class="comment">//for (;;); 这个可以注释掉了，虽然说是练习 6，等会注释也是一样的 后面是调度程序</span></span><br><span class="line">sched_yield();</span><br></pre></td></tr></table></figure></p>
<p>第三个<code>trap</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="number">3</span>) == <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="comment">// Trapped from user mode. 如果是从用户模式过来就锁住内核。</span></span><br><span class="line">		<span class="comment">// Acquire the big kernel lock before doing any</span></span><br><span class="line">		<span class="comment">// serious kernel work.</span></span><br><span class="line">		<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">		lock_kernel();</span><br></pre></td></tr></table></figure></p>
<p>第4个<code>env_run()</code> 这个函数跑用户态去了，所以要释放内核。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unlock_kernel(); <span class="comment">//在转移之前释放内核</span></span><br><span class="line">env_pop_tf(&amp;curenv-&gt;env_tf);</span><br></pre></td></tr></table></figure></p>
<p>其实还用很多锁住内核，和释放内核，但是我们实验并没有让我们实现。</p>
<h3 id="Question-2"><a href="#Question-2" class="headerlink" title="Question 2"></a>Question 2</h3><p>没解决告辞。</p>
<h2 id="Round-Robin-Scheduling"><a href="#Round-Robin-Scheduling" class="headerlink" title="Round-Robin Scheduling"></a>Round-Robin Scheduling</h2><p>实现轮转调度。</p>
<ul>
<li><code>kern/sched.c</code>中的<code>sched_yield()</code>函数负责选取一个新用户环境运行。从刚刚运行的用户环境开始以循环的方式依次搜索<code>envs[]</code>数组（如果之前没有运行过的用户环境，就从数组的第一个元素开始），选择发现的第一个状态为<code>ENV_RUNNABLE</code>的用户环境，然后调用<code>env_run()</code>跳转到选中的用户环境上运行。</li>
<li><code>sched_yield()</code>不能同时在两个CPU上运行相同的用户环境。通过判断用户环境的状态就可以确定该环境是否正在运行</li>
<li>我们已经实现了一个新的系统调用<code>sys_yield()</code>，用户环境可以调用以执行内核态的<code>sched_yield()</code>实现以自动放弃CPU的控制权。</li>
</ul>
<p><code>练习6</code> 让我们实现这个调度程序。</p>
<h3 id="sched-yield"><a href="#sched-yield" class="headerlink" title="sched_yield"></a>sched_yield</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Choose a user environment to run and run it. 选择一个环境去运行他</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">sched_yield(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">idle</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Implement simple round-robin scheduling.</span></span><br><span class="line">	<span class="comment">// 实现简单的轮转调度</span></span><br><span class="line">	<span class="comment">// Search through 'envs' for an ENV_RUNNABLE environment in</span></span><br><span class="line">	<span class="comment">// circular fashion starting just after the env this CPU was</span></span><br><span class="line">	<span class="comment">// last running.  Switch to the first such environment found.</span></span><br><span class="line">	<span class="comment">//  从当前运行环境开始 找到下面第一个环境。</span></span><br><span class="line">	<span class="comment">// If no envs are runnable, but the environment previously</span></span><br><span class="line">	<span class="comment">// running on this CPU is still ENV_RUNNING, it's okay to</span></span><br><span class="line">	<span class="comment">// choose that environment.</span></span><br><span class="line">	<span class="comment">//如果没有其他程序是 就绪状态 就继续运行自己</span></span><br><span class="line">	<span class="comment">// Never choose an environment that's currently running on</span></span><br><span class="line">	<span class="comment">// another CPU (env_status == ENV_RUNNING). If there are</span></span><br><span class="line">	<span class="comment">// no runnable environments, simply drop through to the code</span></span><br><span class="line">	<span class="comment">// below to halt the cpu. //永远不会运行其他CPU 上正在运行的环境，如果没有可以运行的CPU 就是停止 这个CPU</span></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="keyword">int</span> i, nxenvid;</span><br><span class="line">    <span class="keyword">if</span> (curenv)</span><br><span class="line">        nxenvid = ENVX(curenv-&gt;env_id); </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        nxenvid = <span class="number">0</span>; <span class="comment">//如果是第一调度是 0</span></span><br><span class="line">	<span class="comment">//枚举所有进程，看有没有能够运行的，有的运行。</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NENV; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (envs[(nxenvid + i) % NENV].env_status == ENV_RUNNABLE)&#123;</span><br><span class="line">			envs[(nxenvid + i) % NENV].env_cpunum=cpunum();</span><br><span class="line">			env_run(&amp;envs[(nxenvid + i) % NENV]);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)&#123;<span class="comment">//没有其他的就运行当前的环境</span></span><br><span class="line">		curenv-&gt;env_cpunum=cpunum();</span><br><span class="line">		env_run(curenv);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// sched_halt never returns 当前环境如果都不可运行了就直接 停止CPU</span></span><br><span class="line">	sched_halt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现了<code>sched_yield</code>我们还需要在系统调用里面使用他，不然就不会从一个环境里面出来。<br>在<code>syscall.c</code> 里面定义了一个调用他的<code>syscall</code>。然后我们需要使用他。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Deschedule current environment and pick a different one to run.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">sys_yield(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	sched_yield();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在syscall()里面加入 SYS_yield</span></span><br><span class="line">    <span class="keyword">switch</span> (syscallno) &#123;</span><br><span class="line">        <span class="keyword">case</span> (SYS_cputs):</span><br><span class="line">            sys_cputs((<span class="keyword">const</span> <span class="keyword">char</span> *)a1, a2);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> (SYS_cgetc):</span><br><span class="line">            <span class="keyword">return</span> sys_cgetc();</span><br><span class="line">        <span class="keyword">case</span> (SYS_getenvid):</span><br><span class="line">            <span class="keyword">return</span> sys_getenvid();</span><br><span class="line">        <span class="keyword">case</span> (SYS_env_destroy):</span><br><span class="line">            <span class="keyword">return</span> sys_env_destroy(a1);</span><br><span class="line">		<span class="keyword">case</span> (SYS_yield):<span class="comment">//多加入这一行</span></span><br><span class="line">			sys_yield();</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>再在<code>mp_main</code>最后调用一下注释掉无线循环。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Remove this after you finish Exercise 6</span></span><br><span class="line"><span class="comment">//for (;;);</span></span><br><span class="line">sched_yield();</span><br></pre></td></tr></table></figure></p>
<p>然后我们需要验证一下，要在<code>init</code>里面添加测试样例。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(TEST)</span></span><br><span class="line">	<span class="comment">// Don't touch -- used by grading script!</span></span><br><span class="line">	ENV_CREATE(TEST, ENV_TYPE_USER);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="comment">// Touch all you want.</span></span><br><span class="line">	<span class="comment">// ENV_CREATE(user_primes, ENV_TYPE_USER);//把这个歌注释掉，添加下面 3个进程</span></span><br><span class="line">	ENV_CREATE(user_yield, ENV_TYPE_USER);</span><br><span class="line">	ENV_CREATE(user_yield, ENV_TYPE_USER);</span><br><span class="line">	ENV_CREATE(user_yield, ENV_TYPE_USER);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// TEST*</span></span></span><br></pre></td></tr></table></figure></p>
<p>然后运行<code>make qemu CPUS=2</code>可以看到和官网上说的一样的结果。<br>为什么会出现这种结果可以查看<code>user/yield.c</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// yield the processor to other environments</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">umain(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">"Hello, I am environment %08x.\n"</span>, thisenv-&gt;env_id);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">		sys_yield();</span><br><span class="line">		cprintf(<span class="string">"Back in environment %08x, iteration %d.\n"</span>,</span><br><span class="line">			thisenv-&gt;env_id, i);</span><br><span class="line">	&#125;</span><br><span class="line">	cprintf(<span class="string">"All done in environment %08x.\n"</span>, thisenv-&gt;env_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Question-3"><a href="#Question-3" class="headerlink" title="Question 3"></a>Question 3</h3><p>这个问题是，为什么<code>lrc3</code>切换了页表但是，对于进程的<code>e</code>指针还是不用变，因为<code>[UENVS， UENVS+PTSIZE)</code>的映射物理地址都是一样的。</p>
<h3 id="Question-4"><a href="#Question-4" class="headerlink" title="Question 4"></a>Question 4</h3><p>为什么要保存，寄存器的状态。特么还要问么。告辞。因为不保存下来就无法正确地恢复到原来的环境。</p>
<h2 id="System-Calls-for-Environment-Creation"><a href="#System-Calls-for-Environment-Creation" class="headerlink" title="System Calls for Environment Creation"></a>System Calls for Environment Creation</h2><p>现在我们的系统已经能够环境运行了但是还是不能用户创建进程，在<code>unix</code>中我们用的<code>fork</code>函数创建进程，所以我们现在要实现一个简单<code>fork</code>函数。<br>为了实现这个函数，我们需要下面这些系统调用。</p>
<ul>
<li><code>sys_exofork</code>：这个系统调用将创建一个新的空白用户环境，没有映射的用户空间且无法运行。在调用函数时新用户环境的寄存器状态与父进程相同。在父用户环境中，会返回子用户环境的<code>envid_t</code>（如果用户环境分配失败，返回一个负值的错误码）。而子用户环境中，会返回0。（由于子用户环境开始标记为不可运行，<code>sys_exofork</code>实际上是不会返回到子用户环境直到父用户环境标记子用户环境可以运行…）</li>
<li><code>sys_env_set_status</code>：这个系统调用将特定用户环境的状态设置为<code>ENV_RUNNABLE</code>或者<code>ENV_NOT_RUNNABLE</code>。一旦一个新的用户环境的地址空间和所有寄存器都完全初始化，这个系统调用用来标记这个用户环境准备运行。</li>
<li><code>sys_page_alloc</code>：分配一个页的物理内存，并将其映射到给定用户环境地址空间的给定虚拟地址。</li>
<li><code>sys_page_map</code>：从一个用户环境拷贝一个页的映射到另外一个用户环境，这样就完成了内存共享，使新旧的映射都是指同一页的物理内存。<br>  <code>sys_page_unmap</code>：取消给定用户环境给定虚拟地址的映射。</li>
</ul>
<p>以上所有的系统调用都接收用户环境ID，JOS内核支持将0作为当前运行的用户环境的ID的惯例，这个惯例通过<code>kern/env.c</code>中的<code>envid2env()</code>实现。<br>我们需要实现<code>fork</code> 来通过 <code>user/dumbfork.c</code>。我们先去看看这个程序做了啥。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ping-pong a counter between two processes.</span></span><br><span class="line"><span class="comment">// Only need to start one of these -- splits into two, crudely.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">envid_t</span> dumbfork(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">umain(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">envid_t</span> who;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// fork a child process</span></span><br><span class="line">	who = dumbfork();<span class="comment">//可以简单认为这就是个fork 函数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// print a message and yield to the other a few times</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (who ? <span class="number">10</span> : <span class="number">20</span>); i++) &#123;</span><br><span class="line">		cprintf(<span class="string">"%d: I am the %s!\n"</span>, i, who ? <span class="string">"parent"</span> : <span class="string">"child"</span>);</span><br><span class="line">		sys_yield();<span class="comment">//输出完后就调度</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">duppage(<span class="keyword">envid_t</span> dstenv, <span class="keyword">void</span> *addr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This is NOT what you should do in your fork.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_alloc(dstenv, addr, PTE_P|PTE_U|PTE_W)) &lt; <span class="number">0</span>)<span class="comment">//开辟了一个空间</span></span><br><span class="line">		panic(<span class="string">"sys_page_alloc: %e"</span>, r);</span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_map(dstenv, addr, <span class="number">0</span>, UTEMP, PTE_P|PTE_U|PTE_W)) &lt; <span class="number">0</span>)<span class="comment">//映射了空间 </span></span><br><span class="line">		panic(<span class="string">"sys_page_map: %e"</span>, r);</span><br><span class="line">	memmove(UTEMP, addr, PGSIZE);<span class="comment">//复制一份</span></span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_unmap(<span class="number">0</span>, UTEMP)) &lt; <span class="number">0</span>)<span class="comment">//取消映射。</span></span><br><span class="line">		panic(<span class="string">"sys_page_unmap: %e"</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">envid_t</span></span><br><span class="line">dumbfork(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">envid_t</span> envid;</span><br><span class="line">	<span class="keyword">uint8_t</span> *addr;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> end[];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate a new child environment.</span></span><br><span class="line">	<span class="comment">// The kernel will initialize it with a copy of our register state,</span></span><br><span class="line">	<span class="comment">// so that the child will appear to have called sys_exofork() too -</span></span><br><span class="line">	<span class="comment">// except that in the child, this "fake" call to sys_exofork()</span></span><br><span class="line">	<span class="comment">// will return 0 instead of the envid of the child.</span></span><br><span class="line">	envid = sys_exofork();</span><br><span class="line">	<span class="keyword">if</span> (envid &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">"sys_exofork: %e"</span>, envid);</span><br><span class="line">	<span class="keyword">if</span> (envid == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// We're the child.</span></span><br><span class="line">		<span class="comment">// The copied value of the global variable 'thisenv'</span></span><br><span class="line">		<span class="comment">// is no longer valid (it refers to the parent!).</span></span><br><span class="line">		<span class="comment">// Fix it and return 0.</span></span><br><span class="line">		thisenv = &amp;envs[ENVX(sys_getenvid())];<span class="comment">//如果是儿子就把新环境重新指向一下</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We're the parent.</span></span><br><span class="line">	<span class="comment">// Eagerly copy our entire address space into the child.</span></span><br><span class="line">	<span class="comment">// This is NOT what you should do in your fork implementation.</span></span><br><span class="line">	<span class="keyword">for</span> (addr = (<span class="keyword">uint8_t</span>*) UTEXT; addr &lt; end; addr += PGSIZE)<span class="comment">//如果是父亲我们需要拷贝一份地址</span></span><br><span class="line">		duppage(envid, addr);<span class="comment">//这个韩式自己看一下</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Also copy the stack we are currently running on.</span></span><br><span class="line">	duppage(envid, ROUNDDOWN(&amp;addr, PGSIZE));<span class="comment">//复制栈</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start the child environment running</span></span><br><span class="line">	<span class="keyword">if</span> ((r = sys_env_set_status(envid, ENV_RUNNABLE)) &lt; <span class="number">0</span>)<span class="comment">//唤醒儿子</span></span><br><span class="line">		panic(<span class="string">"sys_env_set_status: %e"</span>, r);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> envid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简单来讲解释写了一个简单的<code>fork</code>程序通过系统调用把内存复制了一份（这个时候还没有写时复制，所以是直接copy内存的），然后输出了一些值。<br>在我们写系统调用<code>fork</code>之前需要看看<code>envid2env</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Converts an envid to an env pointer. 把id 转换成env</span></span><br><span class="line"><span class="comment">// If checkperm is set, the specified environment must be either the</span></span><br><span class="line"><span class="comment">// current environment or an immediate child of the current environment.</span></span><br><span class="line"><span class="comment">//需不需要判断是当前进程或者子进程</span></span><br><span class="line"><span class="comment">// RETURNS</span></span><br><span class="line"><span class="comment">//   0 on success, -E_BAD_ENV on error. //0成功其他出错</span></span><br><span class="line"><span class="comment">//   On success, sets *env_store to the environment. //成功设置环境</span></span><br><span class="line"><span class="comment">//   On error, sets *env_store to NULL.//不成功保存NULL</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">envid2env(<span class="keyword">envid_t</span> envid, struct Env **env_store, <span class="keyword">bool</span> checkperm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	<span class="comment">//如果id是 0直接返回当前环境</span></span><br><span class="line">	<span class="comment">// If envid is zero, return the current environment.</span></span><br><span class="line">	<span class="keyword">if</span> (envid == <span class="number">0</span>) &#123;</span><br><span class="line">		*env_store = curenv;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Look up the Env structure via the index part of the envid,</span></span><br><span class="line">	<span class="comment">// then check the env_id field in that struct Env</span></span><br><span class="line">	<span class="comment">// to ensure that the envid is not stale</span></span><br><span class="line">	<span class="comment">// (i.e., does not refer to a _previous_ environment</span></span><br><span class="line">	<span class="comment">// that used the same slot in the envs[] array).</span></span><br><span class="line">	e = &amp;envs[ENVX(envid)];</span><br><span class="line">	<span class="keyword">if</span> (e-&gt;env_status == ENV_FREE || e-&gt;env_id != envid) &#123;<span class="comment">//如果进程已经释放，就GG</span></span><br><span class="line">		*env_store = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check that the calling environment has legitimate permission</span></span><br><span class="line">	<span class="comment">// to manipulate the specified environment.</span></span><br><span class="line">	<span class="comment">// If checkperm is set, the specified environment</span></span><br><span class="line">	<span class="comment">// must be either the current environment</span></span><br><span class="line">	<span class="comment">// or an immediate child of the current environment.//判断是不是自己或者子进程</span></span><br><span class="line">	<span class="keyword">if</span> (checkperm &amp;&amp; e != curenv &amp;&amp; e-&gt;env_parent_id != curenv-&gt;env_id) &#123;</span><br><span class="line">		*env_store = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*env_store = e;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以说说上面就是判断一下进程是不是可用的。如果<code>chekperm</code>是<code>1</code>还需要检查是不是当前进程是不是当前进程或子进程。<br><code>练习7</code>实现前面说额那几个函数了。<br>第一个<code>sys_exofork</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a new environment. 分配一个新的进程，你可以理解成PCB</span></span><br><span class="line"><span class="comment">// Returns envid of new environment, or &lt; 0 on error.  Errors are: </span></span><br><span class="line"><span class="comment">//	-E_NO_FREE_ENV if no free environment is available. 没有进程可以用了返回</span></span><br><span class="line"><span class="comment">//	-E_NO_MEM on memory exhaustion. 没有内存了返回</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">envid_t</span></span><br><span class="line">sys_exofork(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Create the new environment with env_alloc(), from kern/env.c.用env_alloc分配进程</span></span><br><span class="line">	<span class="comment">// It should be left as env_alloc created it, except that 设置成ENV_NOT_RUNNABLE</span></span><br><span class="line">	<span class="comment">// status is set to ENV_NOT_RUNNABLE, and the register set is copied //寄存器复制当前环境</span></span><br><span class="line">	<span class="comment">// from the current environment -- but tweaked so sys_exofork</span></span><br><span class="line">	<span class="comment">// will appear to return 0.  需要把返回值设置成0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>*<span class="title">child</span>=<span class="title">NULL</span>;</span></span><br><span class="line">	<span class="keyword">int</span> r=env_alloc(&amp;child,curenv-&gt;env_id);</span><br><span class="line">	<span class="keyword">if</span>(r!=<span class="number">0</span>)<span class="keyword">return</span> r;</span><br><span class="line">	child-&gt;env_tf=curenv-&gt;env_tf; <span class="comment">//复制tf，这个tf当前运行的位置应该是fork 之后的第一条语句</span></span><br><span class="line">	child-&gt;env_status=ENV_NOT_RUNNABLE; <span class="comment">//设置环境</span></span><br><span class="line">	<span class="comment">//cprintf("status:%d\n",child-&gt;env_status);</span></span><br><span class="line">	child-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;<span class="comment">//返回值变成0</span></span><br><span class="line">	<span class="keyword">return</span> child-&gt;env_id; <span class="comment">//父亲返回的是儿子的id</span></span><br><span class="line">	<span class="comment">//panic("sys_exofork not implemented");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面就是<code>sys_env_set_status</code>更改进程状态。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set envid's env_status to status, which must be ENV_RUNNABLE</span></span><br><span class="line"><span class="comment">// or ENV_NOT_RUNNABLE. 更改的状态必须是 ENV_RUNNABLE 和ENV_NOT_RUNNABLE</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors are: 失败返回&lt;0</span></span><br><span class="line"><span class="comment">//	-E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//		or the caller doesn't have permission to change envid. //如果环境不存在或者进程错误</span></span><br><span class="line"><span class="comment">//	-E_INVAL if status is not a valid status for an environment. 如果值错了</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_status(<span class="keyword">envid_t</span> envid, <span class="keyword">int</span> status)</span><br><span class="line">&#123;	</span><br><span class="line">	<span class="comment">// Hint: Use the 'envid2env' function from kern/env.c to translate an</span></span><br><span class="line">	<span class="comment">// envid to a struct Env. 用envid2env来检查进程</span></span><br><span class="line">	<span class="comment">// You should set envid2env's third argument to 1, which will</span></span><br><span class="line">	<span class="comment">// check whether the current environment has permission to set</span></span><br><span class="line">	<span class="comment">// envid's status. //我们讲检查当前环境是否正确</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> * <span class="title">env</span>=<span class="title">NULL</span>;</span></span><br><span class="line">	<span class="keyword">int</span> r=envid2env(envid,&amp;env,<span class="number">1</span>);<span class="comment">//检查进程id是不是对的</span></span><br><span class="line">	<span class="keyword">if</span>(r&lt;<span class="number">0</span>)<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(status!=ENV_NOT_RUNNABLE&amp;&amp;status!=ENV_RUNNABLE)<span class="keyword">return</span> -E_INVAL;<span class="comment">//检查环境值是不是对的</span></span><br><span class="line">		env-&gt;env_status=status;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//panic("sys_env_set_status not implemented");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后就是关于内存的<code>sys_page_alloc</code>，<code>sys_page_map</code>,<code>sys_page_unmap</code>，都差不多。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a page of memory and map it at 'va' with permission</span></span><br><span class="line"><span class="comment">// 'perm' in the address space of 'envid'. 分配一个页的内存映射 envid</span></span><br><span class="line"><span class="comment">// The page's contents are set to 0. 页面内容设置为 0，也就是初始化为0</span></span><br><span class="line"><span class="comment">// If a page is already mapped at 'va', that page is unmapped as a</span></span><br><span class="line"><span class="comment">// side effect. 如果va是已经映射的就需要，取消映射</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// perm -- PTE_U | PTE_P must be set, PTE_AVAIL | PTE_W may or may not be set,  PTE_U | PTE_P权限必须设置  PTE_AVAIL | PTE_W 可以不设置</span></span><br><span class="line"><span class="comment">//         but no other bits may be set.  See PTE_SYSCALL in inc/mmu.h.</span></span><br><span class="line"><span class="comment">// 其他权限 PTE_SYSCALL 也许可以被设置，意味着超过这个权限都是错的。</span></span><br><span class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are: 失败返回 负数</span></span><br><span class="line"><span class="comment">//	-E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//		or the caller doesn't have permission to change envid.//环境id错误</span></span><br><span class="line"><span class="comment">//	-E_INVAL if va &gt;= UTOP, or va is not page-aligned.//地址不在用户状态或者不是页对齐</span></span><br><span class="line"><span class="comment">//	-E_INVAL if perm is inappropriate (see above). 权限错误</span></span><br><span class="line"><span class="comment">//	-E_NO_MEM if there's no memory to allocate the new page,//没有内存了</span></span><br><span class="line"><span class="comment">//		or to allocate any necessary page tables.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_alloc(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Hint: This function is a wrapper around page_alloc() and</span></span><br><span class="line">	<span class="comment">//   page_insert() from kern/pmap.c. 可以使用page_alloc和page_insert</span></span><br><span class="line">	<span class="comment">//   Most of the new code you write should be to check the</span></span><br><span class="line">	<span class="comment">//   parameters for correctness.</span></span><br><span class="line">	<span class="comment">//   If page_insert() fails, remember to free the page you</span></span><br><span class="line">	<span class="comment">//   allocated!//如果插入失败记得释放内存</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here. 后面就照着提示一个个判断就行了</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> * <span class="title">env</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(envid2env(envid,&amp;env,<span class="number">1</span>)&lt;<span class="number">0</span>)<span class="keyword">return</span> -E_BAD_ENV;<span class="comment">//判断进程</span></span><br><span class="line">	<span class="keyword">if</span>((<span class="keyword">uintptr_t</span>)va&gt;=UTOP||PGOFF(va))<span class="keyword">return</span>  -E_INVAL;<span class="comment">//判断地址</span></span><br><span class="line">	<span class="keyword">int</span> flag=PTE_U | PTE_P;</span><br><span class="line">	<span class="keyword">if</span>((perm &amp; ~(PTE_SYSCALL))!=<span class="number">0</span>||(perm&amp;flag)!=flag)<span class="keyword">return</span> -E_INVAL;<span class="comment">//判断权限</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">pi</span>=<span class="title">page_alloc</span>(1);</span><span class="comment">//分配一个页</span></span><br><span class="line">	<span class="keyword">if</span>(pi==<span class="literal">NULL</span>)<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	<span class="keyword">if</span>(page_insert(env-&gt;env_pgdir,pi,va,perm)&lt;<span class="number">0</span>)&#123;<span class="comment">//映射上去</span></span><br><span class="line">		page_free(pi);</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//panic("sys_page_alloc not implemented");</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map the page of memory at 'srcva' in srcenvid's address space</span></span><br><span class="line"><span class="comment">// at 'dstva' in dstenvid's address space with permission 'perm'.</span></span><br><span class="line"><span class="comment">// Perm has the same restrictions as in sys_page_alloc, except</span></span><br><span class="line"><span class="comment">// that it also must not grant write access to a read-only</span></span><br><span class="line"><span class="comment">// page.</span></span><br><span class="line"><span class="comment">//这个是把 源 虚拟地址映射到 目的 虚拟地址 </span></span><br><span class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are://一堆错误提示</span></span><br><span class="line"><span class="comment">//	-E_BAD_ENV if srcenvid and/or dstenvid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//		or the caller doesn't have permission to change one of them.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if srcva &gt;= UTOP or srcva is not page-aligned,</span></span><br><span class="line"><span class="comment">//		or dstva &gt;= UTOP or dstva is not page-aligned.</span></span><br><span class="line"><span class="comment">//	-E_INVAL is srcva is not mapped in srcenvid's address space.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if perm is inappropriate (see sys_page_alloc).</span></span><br><span class="line"><span class="comment">//	-E_INVAL if (perm &amp; PTE_W), but srcva is read-only in srcenvid's</span></span><br><span class="line"><span class="comment">//		address space.</span></span><br><span class="line"><span class="comment">//	-E_NO_MEM if there's no memory to allocate any necessary page tables.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_map(<span class="keyword">envid_t</span> srcenvid, <span class="keyword">void</span> *srcva,</span><br><span class="line">	     <span class="keyword">envid_t</span> dstenvid, <span class="keyword">void</span> *dstva, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Hint: This function is a wrapper around page_lookup() and</span></span><br><span class="line">	<span class="comment">//   page_insert() from kern/pmap.c.</span></span><br><span class="line">	<span class="comment">//   Again, most of the new code you write should be to check the</span></span><br><span class="line">	<span class="comment">//   parameters for correctness.</span></span><br><span class="line">	<span class="comment">//   Use the third argument to page_lookup() to</span></span><br><span class="line">	<span class="comment">//   check the current permissions on the page.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> * <span class="title">srccur</span>=<span class="title">NULL</span>,*<span class="title">dstcur</span>=<span class="title">NULL</span>;</span></span><br><span class="line">	r=envid2env(srcenvid,&amp;srccur,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(r&lt;<span class="number">0</span>)<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	r=envid2env(dstenvid,&amp;dstcur,<span class="number">1</span>);<span class="comment">//判断两个进程</span></span><br><span class="line">	<span class="keyword">if</span>(r&lt;<span class="number">0</span>)<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	<span class="keyword">if</span>((<span class="keyword">uintptr_t</span>)srcva &gt;= UTOP||(<span class="keyword">uintptr_t</span>)dstva &gt;= UTOP||PGOFF(srcva)|| PGOFF(dstva))<span class="keyword">return</span> -E_INVAL;<span class="comment">//判断页地址和目的地址</span></span><br><span class="line">	<span class="keyword">pte_t</span> * store=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">pg</span>=<span class="title">NULL</span>;</span></span><br><span class="line">	<span class="keyword">if</span>((pg=page_lookup(srccur-&gt;env_pgdir,srcva,&amp;store))==<span class="literal">NULL</span>)<span class="keyword">return</span> -E_INVAL;<span class="comment">//查看一个页</span></span><br><span class="line">	<span class="keyword">int</span> flag=PTE_U | PTE_P;</span><br><span class="line">	<span class="keyword">if</span>((perm &amp; ~(PTE_SYSCALL))!=<span class="number">0</span>||(perm&amp;flag)!=flag)<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	<span class="keyword">if</span>((perm&amp;PTE_W)&amp;&amp;!(*store&amp;PTE_W))<span class="keyword">return</span> E_INVAL;<span class="comment">//判断权限</span></span><br><span class="line">	<span class="keyword">if</span> (page_insert(dstcur-&gt;env_pgdir, pg, dstva, perm) &lt; <span class="number">0</span>) <span class="comment">//插入到一个页</span></span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//panic("sys_page_map not implemented");</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unmap the page of memory at 'va' in the address space of 'envid'.</span></span><br><span class="line"><span class="comment">// If no page is mapped, the function silently succeeds.</span></span><br><span class="line"><span class="comment">//取消一个进程  对va 的映射。</span></span><br><span class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//	-E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//		or the caller doesn't have permission to change envid.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if va &gt;= UTOP, or va is not page-aligned.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_unmap(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Hint: This function is a wrapper around page_remove().</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">	<span class="keyword">int</span> r=envid2env(envid,&amp;env,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(r&lt;<span class="number">0</span>)<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	<span class="keyword">if</span>((<span class="keyword">uintptr_t</span>)va&gt;=UTOP||PGOFF(va))<span class="keyword">return</span>  -E_INVAL;</span><br><span class="line">	page_remove(env-&gt;env_pgdir,va);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//panic("sys_page_unmap not implemented");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后就可以运行了。<br>最后不要忘记把他填到<code>syscall</code>里面。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SYS_exofork:</span><br><span class="line">         	<span class="keyword">return</span> sys_exofork();</span><br><span class="line"><span class="keyword">case</span> SYS_env_set_status:</span><br><span class="line">         	<span class="keyword">return</span> sys_env_set_status((<span class="keyword">envid_t</span>)a1, (<span class="keyword">int</span>)a2);</span><br><span class="line"><span class="keyword">case</span> SYS_page_alloc:</span><br><span class="line">         	<span class="keyword">return</span> sys_page_alloc((<span class="keyword">envid_t</span>)a1, (<span class="keyword">void</span> *)a2, (<span class="keyword">int</span>)a3);</span><br><span class="line">     	<span class="keyword">case</span> SYS_page_map:</span><br><span class="line">         	<span class="keyword">return</span> sys_page_map((<span class="keyword">envid_t</span>)a1, (<span class="keyword">void</span> *)a2, (<span class="keyword">envid_t</span>)a3, (<span class="keyword">void</span> *)a4, (<span class="keyword">int</span>)a5);</span><br><span class="line">     	<span class="keyword">case</span> SYS_page_unmap:</span><br><span class="line">         	<span class="keyword">return</span> sys_page_unmap((<span class="keyword">envid_t</span>)a1, (<span class="keyword">void</span> *)a2);</span><br></pre></td></tr></table></figure></p>
<p>然后就完成了<code>PART A</code>了。</p>
<h1 id="Part-B-Copy-on-Write-Fork"><a href="#Part-B-Copy-on-Write-Fork" class="headerlink" title="Part B: Copy-on-Write Fork"></a>Part B: Copy-on-Write Fork</h1><p>写时复制，对于这个机制应该都很清楚。大部分程序<code>fork</code>之后就调用了<code>exec</code>所以，我门，并没有复制内存，也就是少了<code>dumbfork</code>里面的<code>memmove(UTEMP, addr, PGSIZE);</code>。但是这样做就有了个缺陷，如果没有调用<code>exec</code>，子进程又访问了就要进行缺页中断。所以这次我我们的任务就是实现这些东西。</p>
<h2 id="User-level-page-fault-handling"><a href="#User-level-page-fault-handling" class="headerlink" title="User-level page fault handling"></a>User-level page fault handling</h2><p>一个用户级写时拷贝的fork函数需要知道哪些page fault是在写保护页时触发的，写时复制只是用户级缺页中断处理的一种。<br>通常建立地址空间以便page fault提示何时需要执行某些操作。例如大多数Unix内核初始只给新进程的栈映射一个页，以后栈增长会导致page fault从而映射新的页。一个典型的Unix内核必须记录在进程地址空间的不同区域发生page fault时，应该执行什么操作。例如栈上缺页，会实际分配和映射新的物理内存。BSS区域缺页会分配新的物理页，填充0，然后映射。这种设计在定义他们的内存区域的时候具有极大的灵活度。</p>
<h2 id="Setting-the-Page-Fault-Handler"><a href="#Setting-the-Page-Fault-Handler" class="headerlink" title="Setting the Page Fault Handler"></a>Setting the Page Fault Handler</h2><p>为了处理自己的缺页中断，用户环境需要在JOS内核中注册缺页中断处理程序的入口。用户环境通过<code>sys_env_set_pgfault_upcall</code>系统调用注册它的缺页中断入口。我们在Env结构体中增加了一个新成员<code>env_pgfault_upcall</code>来记录这一信息。<br><code>练习8</code>就是让你实现缺页中断的入口，就是你用写时复制，如果修改了该怎么处理，调用哪个程序去处理。我们需要去实现这个<code>sys_env_set_pgfault_upcall</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set the page fault upcall for 'envid' by modifying the corresponding struct</span></span><br><span class="line"><span class="comment">// Env's 'env_pgfault_upcall' field.  When 'envid' causes a page fault, the</span></span><br><span class="line"><span class="comment">// kernel will push a fault record onto the exception stack, then branch to</span></span><br><span class="line"><span class="comment">// 'func'.</span></span><br><span class="line"><span class="comment">//参数传进去一个函数指针，直接把处理缺页中断的变量指向就可以了</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//	-E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//		or the caller doesn't have permission to change envid.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_pgfault_upcall(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *func)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> * <span class="title">env</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(envid2env(envid,&amp;env,<span class="number">1</span>)&lt;<span class="number">0</span>)<span class="keyword">return</span> -E_BAD_ENV;<span class="comment">//先判断进程可不可以用</span></span><br><span class="line">	env-&gt;env_pgfault_upcall=func;<span class="comment">//意思就是处理中断的时候用func 这个函数。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//panic("sys_env_set_pgfault_upcall not implemented");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>千万别忘记把这个添进<code>syscall</code>，我这个地方忘记添加了，找了半天不知道为啥。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SYS_env_set_pgfault_upcall:</span><br><span class="line">	<span class="keyword">return</span> sys_env_set_pgfault_upcall(a1,(<span class="keyword">void</span> *)a2);</span><br></pre></td></tr></table></figure></p>
<h2 id="Normal-and-Exception-Stacks-in-User-Environments"><a href="#Normal-and-Exception-Stacks-in-User-Environments" class="headerlink" title="Normal and Exception Stacks in User Environments"></a>Normal and Exception Stacks in User Environments</h2><p>在正常运行期间，用户进程运行在用户栈上，开始运行时栈顶寄存器<code>ESP</code>指向<code>USTACKTOP</code>，压入堆栈的数据位于<code>[USTACKTOP-PGSIZE ~ USTACKTOP-1]</code>之间的页。当一个页错误出现在用户模式下，内核重启用户环境让其在用户异常栈上运行指定的用户级缺页处理程序。我们将使JOS代替用户环境实现自动的“栈切换”，就如同x86处理器代替JOS内核实现从用户模式到内核模式的栈切换。</p>
<p>JOS的用户异常栈的大小为一个页，初始栈顶定义在<code>UXSTACKTOP</code>。因此有效的用户异常栈的区间是<code>[UXSTACKTOP-PGSIZE ~ UXSTACKTOP-1]</code>。运行在异常栈上的用户级的页错误处理程序可以使用JOS的常规的系统调用，来映射新的页或者调整映射，来修复导致页错误的问题。然后用户级别页错误处理程序通过一个汇编语言stub返回到原始栈的错误代码处。</p>
<p>每一个想要支持用户级别页错误处理的用户环境都需要为自己的异常栈分配内存，这就用到了在<code>part A</code>中引入的<code>sys_page_alloc()</code>系统调用函数。<br>这个时候我们就需要一个新的栈，叫做用户异常栈。</p>
<h2 id="Invoking-the-User-Page-Fault-Handler"><a href="#Invoking-the-User-Page-Fault-Handler" class="headerlink" title="Invoking the User Page Fault Handler"></a>Invoking the User Page Fault Handler</h2><p>我们现在需要修改<code>kern/trap.c</code>里面的用户模式的缺页错误，因为现在我们有了用户的缺页处理函数。现在我们如果设置了，缺页处理函数，就调用缺页处理函数，没有我们就销毁这个进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_fault_handler(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> fault_va;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Read processor's CR2 register to find the faulting address</span></span><br><span class="line">	fault_va = rcr2();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Handle kernel-mode page faults.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="keyword">if</span>(tf-&gt;tf_cs &amp;&amp; <span class="number">0x01</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">"page_fault in kernel mode, fault address %d\n"</span>, fault_va);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We've already handled kernel-mode exceptions, so if we get here,</span></span><br><span class="line">	<span class="comment">// the page fault happened in user mode.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Call the environment's page fault upcall, if one exists.  Set up a</span></span><br><span class="line">	<span class="comment">// page fault stack frame on the user exception stack (below</span></span><br><span class="line">	<span class="comment">// UXSTACKTOP), then branch to curenv-&gt;env_pgfault_upcall.</span></span><br><span class="line">	<span class="comment">// 建立一个用户异常栈 在 UXSTACKTOP 然后跳转到 curenv-&gt;env_pgfault_upcall 运行</span></span><br><span class="line">	<span class="comment">// The page fault upcall might cause another page fault, in which case</span></span><br><span class="line">	<span class="comment">// we branch to the page fault upcall recursively, pushing another</span></span><br><span class="line">	<span class="comment">// page fault stack frame on top of the user exception stack.</span></span><br><span class="line">	<span class="comment">// 可能出现多级中断 </span></span><br><span class="line">	<span class="comment">// It is convenient for our code which returns from a page fault</span></span><br><span class="line">	<span class="comment">// (lib/pfentry.S) to have one word of scratch space at the top of the</span></span><br><span class="line">	<span class="comment">// trap-time stack; it allows us to more easily restore the eip/esp. In</span></span><br><span class="line">	<span class="comment">// the non-recursive case, we don't have to worry about this because</span></span><br><span class="line">	<span class="comment">// the top of the regular user stack is free.  In the recursive case,</span></span><br><span class="line">	<span class="comment">// this means we have to leave an extra word between the current top of</span></span><br><span class="line">	<span class="comment">// the exception stack and the new stack frame because the exception</span></span><br><span class="line">	<span class="comment">// stack _is_ the trap-time stack.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// If there's no page fault upcall, the environment didn't allocate a</span></span><br><span class="line">	<span class="comment">// page for its exception stack or can't write to it, or the exception</span></span><br><span class="line">	<span class="comment">// stack overflows, then destroy the environment that caused the fault.</span></span><br><span class="line">	<span class="comment">// Note that the grade script assumes you will first check for the page</span></span><br><span class="line">	<span class="comment">// fault upcall and print the "user fault va" message below if there is</span></span><br><span class="line">	<span class="comment">// none.  The remaining three checks can be combined into a single test.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Hints:</span></span><br><span class="line">	<span class="comment">//   user_mem_assert() and env_run() are useful here.</span></span><br><span class="line">	<span class="comment">//   To change what the user environment runs, modify 'curenv-&gt;env_tf'</span></span><br><span class="line">	<span class="comment">//   (the 'tf' variable points at 'curenv-&gt;env_tf').</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	   <span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span> *<span class="title">utf</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (curenv-&gt;env_pgfault_upcall) &#123;</span><br><span class="line">	<span class="comment">//如果已经有了异常栈，我们就直接在后面添加一个UTrapframe，否则就先把跳到异常栈。 这是为了处理多级中断</span></span><br><span class="line">		<span class="keyword">if</span> (tf-&gt;tf_esp &gt;= UXSTACKTOP-PGSIZE &amp;&amp; tf-&gt;tf_esp &lt; UXSTACKTOP) &#123;</span><br><span class="line">			<span class="comment">// 异常模式下陷入</span></span><br><span class="line">			utf = (struct UTrapframe *)(tf-&gt;tf_esp - <span class="keyword">sizeof</span>(struct UTrapframe) - <span class="number">4</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 非异常模式下陷入</span></span><br><span class="line">			utf = (struct UTrapframe *)(UXSTACKTOP - <span class="keyword">sizeof</span>(struct UTrapframe));	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 检查异常栈是否溢出</span></span><br><span class="line">		user_mem_assert(curenv, (<span class="keyword">const</span> <span class="keyword">void</span> *) utf, <span class="keyword">sizeof</span>(struct UTrapframe), PTE_P|PTE_W);</span><br><span class="line">			</span><br><span class="line">		utf-&gt;utf_fault_va = fault_va;</span><br><span class="line">		utf-&gt;utf_err      = tf-&gt;tf_trapno;</span><br><span class="line">		utf-&gt;utf_regs     = tf-&gt;tf_regs;</span><br><span class="line">		utf-&gt;utf_eflags   = tf-&gt;tf_eflags;</span><br><span class="line">		<span class="comment">// 保存陷入时现场，用于返回</span></span><br><span class="line">		utf-&gt;utf_eip      = tf-&gt;tf_eip;</span><br><span class="line">		utf-&gt;utf_esp      = tf-&gt;tf_esp;</span><br><span class="line">		<span class="comment">// 再次转向执行</span></span><br><span class="line">		curenv-&gt;env_tf.tf_eip        = (<span class="keyword">uint32_t</span>) curenv-&gt;env_pgfault_upcall;</span><br><span class="line">		<span class="comment">// 异常栈</span></span><br><span class="line">		curenv-&gt;env_tf.tf_esp        = (<span class="keyword">uint32_t</span>) utf;</span><br><span class="line">		env_run(curenv);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Destroy the environment that caused the fault. 没有定义就直接销毁</span></span><br><span class="line">		cprintf(<span class="string">"[%08x] user fault va %08x ip %08x\n"</span>,</span><br><span class="line">			curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">		print_trapframe(tf);</span><br><span class="line">		env_destroy(curenv);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="User-mode-Page-Fault-Entrypoint"><a href="#User-mode-Page-Fault-Entrypoint" class="headerlink" title="User-mode Page Fault Entrypoint"></a>User-mode Page Fault Entrypoint</h2><p>接下来，就需要实现汇编例程负责调用C的缺页异常处理程序并恢复执行原来出错的指令。这个汇编例程（<code>lib/pfentry.S</code>中的<code>_pgfault_upcall</code>）就是需要使用<code>sys_env_set_pgfault_upcall()</code>系统调用注册到内核的处理程序。<br>这个练习我没看懂。所以我就直接 贴别人的代码了<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">// Struct PushRegs size = 32 </span></span><br><span class="line"> addl $<span class="number">8</span>, %esp                 <span class="comment">// esp+8 -&gt; PushRegs   over utf_fault_va utf_err</span></span><br><span class="line">movl <span class="number">0x20</span>(%esp), %eax         <span class="comment">// eax = (esp+0x20 -&gt; utf_eip )</span></span><br><span class="line">subl $<span class="number">4</span>, <span class="number">0x28</span>(%esp)           <span class="comment">// for trap time eip 保留32bit,   esp+48 = utf_esp</span></span><br><span class="line">movl <span class="number">0x28</span>(%esp), %edx         <span class="comment">// %edx = utf_esp-4  </span></span><br><span class="line">movl %eax, (%edx)             <span class="comment">// %eax = eip ----&gt; esp-4  以至于ret可以直接读取其继续执行的地址</span></span><br><span class="line"></span><br><span class="line">popal              <span class="comment">// after popal esp-&gt;utf_eip</span></span><br><span class="line"></span><br><span class="line">addl $<span class="number">4</span>, %esp      <span class="comment">// esp+4 -&gt; utf_eflags</span></span><br><span class="line">popfl</span><br><span class="line"></span><br><span class="line">popl %esp</span><br><span class="line"></span><br><span class="line">ret                   <span class="comment">// 这里十分巧妙， ret会读取esp指向的第一个内容， 也就是我们第一步写入的eip</span></span><br></pre></td></tr></table></figure></p>
<p><code>练习11</code> 就是让你实现<code>lib/pgfault.c.</code>里面的<code>set_pgfault_handler。</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Set the page fault handler function. 设置那个缺页处理</span></span><br><span class="line"><span class="comment">// If there isn't one yet, _pgfault_handler will be 0.</span></span><br><span class="line"><span class="comment">// The first time we register a handler, we need to</span></span><br><span class="line"><span class="comment">// allocate an exception stack (one page of memory with its top</span></span><br><span class="line"><span class="comment">// at UXSTACKTOP), and tell the kernel to call the assembly-language</span></span><br><span class="line"><span class="comment">// _pgfault_upcall routine when a page fault occurs. 如果是第一次分配页我们需要分配一个异常栈。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">set_pgfault_handler(<span class="keyword">void</span> (*handler)(struct UTrapframe *utf))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (_pgfault_handler == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// First time through!</span></span><br><span class="line">		<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">		<span class="keyword">if</span> ((r = sys_page_alloc(thisenv-&gt;env_id, (<span class="keyword">void</span> *)(UXSTACKTOP - PGSIZE), PTE_P | PTE_W | PTE_U)) &lt; <span class="number">0</span>) </span><br><span class="line">           	panic(<span class="string">"set_pgfault_handler: %e"</span>, r);</span><br><span class="line">        sys_env_set_pgfault_upcall(thisenv-&gt;env_id, _pgfault_upcall);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Save handler pointer for assembly to call.</span></span><br><span class="line">	_pgfault_handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Implementing-Copy-on-Write-Fork"><a href="#Implementing-Copy-on-Write-Fork" class="headerlink" title="Implementing Copy-on-Write Fork"></a>Implementing Copy-on-Write Fork</h2><p>最后就是实现写时复制了。<br>前面我们有一个测试程序，<code>user/dumbfork</code>，这个里面已经有了模板，我们现在要做的就是实现一个差不多的<code>fork</code>。<br>他的基本流程是：</p>
<ol>
<li>父进程将<code>pgfault()</code>函数作为C语言实现的页错误处理，会用到上面的实现的<code>set_pgfault_handler()</code>函数进行设置。父进程调用<code>sys_exofork()</code>创建一个子进程环境。</li>
<li>在<code>UTOP</code>之下的在地址空间里的每一个可写或<code>copy-on-write</code>的页，父进程就会调用<code>duppage</code>，它会将<code>copy-on-write</code>页映射到子进程的地址空间，然后重新映射<code>copy-on-write</code>页到自己的地址空间。[注意这里的顺序十分重要！先将子进程的页标记为<code>COW</code>，然后将父进程的页标记为<code>COW</code>。知道为什么吗？你可以尝试思考将该顺序弄反会是造成怎样的麻烦]。<code>duppage</code>将<code>COW</code>的页的<code>PTEs</code>设置为不能写的，然后在<code>PTE</code>的<code>avail</code>域设置<code>PTE_COW</code>来区别 <code>copy-on-write pages</code>及真正的只读页</li>
<li>异常栈并不是如上重新映射，在子进程中需要为异常栈分配一个新的页。由于缺页异常处理程序将执行实际的拷贝,而且缺页异常处理程序在异常栈上运行,异常栈不应该被设置为<code>cow</code>。<code>fork()</code>同样要解决在内存中的页，但页既不可写也不是<code>copy-on-write</code>。</li>
<li>父进程为子进程设置用户页错误入口。</li>
<li>子进程现在可以运行，然后父进程将其标记为可运行。</li>
</ol>
<p>每次这两进程中的一个向一个尚未写过的<code>copy-on-write</code>页写时，就会产生一个页错误。下面是用户页错误处理的控制流：</p>
<ol>
<li>内核传播页错误到<code>_pgfault_upcall</code>，调用<code>fork()</code>的<code>pgfault()</code>处理流程。</li>
<li><code>pgfault()</code>检查错误代码中的<code>FEC_WR</code>（即是写导致的），以及页对应的<code>PTE</code>标记为<code>PTE_COW</code>。没有的话，<code>panic</code>。</li>
<li><code>pgfault()</code>分配一个映射在一个临时位置的新的页，然后将错误页中的内容复制进去。然后页错误处理程序映射新的页到引起<code>page fault</code>的虚拟地址，并设置<code>PTE</code>具有读写权限。</li>
</ol>
<p>用户级的<code>lib/fork.c</code>必须访问用户环境的页表完成以上的几个操作(例如将一个页对应的<code>PTE</code>标记为<code>PTE_COW</code>)。内核映射用户环境的页表到虚拟地址<code>UVPT</code>的用意就在于此。它使用了一种聪明的手段让用户代码很方便的检索<code>PTE</code>。<code>lib/entry.S</code>设置<code>uvpt</code>和<code>uvpd</code>使得<code>lib/fork.c</code>中的用户代码能够轻松地检索页表信息。<br><code>练习12</code>就是让我们实现<code>fork.c</code>里面的<code>fork</code>, <code>duppage</code> 和 <code>pgfault</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implement fork from user space</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PTE_COW marks copy-on-write page table entries.</span></span><br><span class="line"><span class="comment">// It is one of the bits explicitly allocated to user processes (PTE_AVAIL).</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_COW		0x800</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Custom page fault handler - if faulting page is copy-on-write,</span></span><br><span class="line"><span class="comment">// map in our own private writable copy.</span></span><br><span class="line"><span class="comment">// 用户处理缺页</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">pgfault(struct UTrapframe *utf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> *addr = (<span class="keyword">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line">	<span class="keyword">uint32_t</span> err = utf-&gt;utf_err;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check that the faulting access was (1) a write, and (2) to a</span></span><br><span class="line">	<span class="comment">// copy-on-write page.  If not, panic.</span></span><br><span class="line">	<span class="comment">// Hint: 检查是不是因为因为写入导致的错误，不是就paic</span></span><br><span class="line">	<span class="comment">//   Use the read-only page table mappings at uvpt</span></span><br><span class="line">	<span class="comment">//   (see &lt;inc/memlayout.h&gt;).  uvpt 和uvpd 在memlayout 这个里面有定义，很久之前我们就看过了。 一个页目录一个是页表的。</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span> (!(</span><br><span class="line">        (err &amp; FEC_WR) &amp;&amp; (uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp;</span><br><span class="line">        (uvpt[PGNUM(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_COW)</span><br><span class="line">	)) panic(<span class="string">"Neither the fault is a write nor copy-on-write page.\n"</span>);<span class="comment">//如果不是因为这个原因 就panic</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate a new page, map it at a temporary location (PFTEMP),</span></span><br><span class="line">	<span class="comment">// copy the data from the old page to the new page, then move the new</span></span><br><span class="line">	<span class="comment">// page to the old page's address.</span></span><br><span class="line">	<span class="comment">// Hint: 分配一个页面给他，然后复制一份就这样</span></span><br><span class="line">	<span class="comment">//   You should make three system calls.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span>((r = sys_page_alloc(<span class="number">0</span>, PFTEMP, PTE_U | PTE_P | PTE_W)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		 panic(<span class="string">"sys_page_alloc: %e\n"</span>, r);<span class="comment">//分配了一个页</span></span><br><span class="line">	&#125;</span><br><span class="line">	addr = ROUNDDOWN(addr, PGSIZE);<span class="comment">//页对齐</span></span><br><span class="line">	<span class="built_in">memcpy</span>((<span class="keyword">void</span> *)PFTEMP, addr, PGSIZE);<span class="comment">//把这个写时复制的页内容复制一遍</span></span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span> *)PFTEMP, <span class="number">0</span>, addr, PTE_P | PTE_U | PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"sys_page_map: %e\n"</span>, r);<span class="comment">//把当前映射的 地址 指向PFTEMP 新分配的页</span></span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_unmap(<span class="number">0</span>, (<span class="keyword">void</span> *)PFTEMP)) &lt; <span class="number">0</span>) <span class="comment">//取消PFTEMP 的映射，这样就把虚拟地址指向了一个新的页。</span></span><br><span class="line">        panic(<span class="string">"sys_page_unmap: %e\n"</span>, r);</span><br><span class="line">	<span class="comment">//panic("pgfault not implemented");</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Map our virtual page pn (address pn*PGSIZE) into the target envid</span></span><br><span class="line"><span class="comment">// at the same virtual address.  If the page is writable or copy-on-write,</span></span><br><span class="line"><span class="comment">// the new mapping must be created copy-on-write, and then our mapping must be</span></span><br><span class="line"><span class="comment">// marked copy-on-write as well.  (Exercise: Why do we need to mark ours</span></span><br><span class="line"><span class="comment">// copy-on-write again if it was already copy-on-write at the beginning of</span></span><br><span class="line"><span class="comment">// this function?)</span></span><br><span class="line"><span class="comment">//把 我们虚拟页 pn*PGSIZE映射到 相同的虚拟地址，如果原本就是写时复制那么新的也要标记成 写时复制</span></span><br><span class="line"><span class="comment">// Returns: 0 on success, &lt; 0 on error.</span></span><br><span class="line"><span class="comment">// It is also OK to panic on error.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">duppage(<span class="keyword">envid_t</span> envid, <span class="keyword">unsigned</span> pn)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="keyword">void</span>* vaddr=(<span class="keyword">void</span>*)(pn*PGSIZE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((uvpt[pn] &amp; PTE_W) || (uvpt[pn] &amp; PTE_COW))&#123;</span><br><span class="line">		<span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, vaddr, envid, vaddr, PTE_P | PTE_U | PTE_COW)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> r;<span class="comment">//映射当前页为写时符合</span></span><br><span class="line">        <span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, vaddr, <span class="number">0</span>, vaddr, PTE_P | PTE_U | PTE_COW)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> r;<span class="comment">//把自己当前页页标记成写时复制。</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>((r = sys_page_map(<span class="number">0</span>, vaddr, envid, vaddr, PTE_P | PTE_U)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;<span class="comment">//如果当前页已经是写时复制  就不需要更改了</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//panic("duppage not implemented");</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// User-level fork with copy-on-write.　写时复制</span></span><br><span class="line"><span class="comment">// Set up our page fault handler appropriately.设置缺页处理</span></span><br><span class="line"><span class="comment">// Create a child. 创建一个儿子</span></span><br><span class="line"><span class="comment">// Copy our address space and page fault handler setup to the child. 复制空间和设置缺页处理</span></span><br><span class="line"><span class="comment">// Then mark the child as runnable and return. 标记儿子为 runable</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns: child's envid to the parent, 0 to the child, &lt; 0 on error.</span></span><br><span class="line"><span class="comment">// It is also OK to panic on error. 父亲返回 儿子id  儿子返回 0 返回 &lt;0 出错</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//   Use uvpd, uvpt, and duppage. 使用 uvpd, uvpt, 和 duppage</span></span><br><span class="line"><span class="comment">//   Remember to fix "thisenv" in the child process.</span></span><br><span class="line"><span class="comment">//   Neither user exception stack should ever be marked copy-on-write,</span></span><br><span class="line"><span class="comment">//   so you must allocate a new page for the child's user exception stack.</span></span><br><span class="line"><span class="comment">// 不用把异常栈标记为写时复制  所以必须分配新的一页给儿子</span></span><br><span class="line"><span class="keyword">envid_t</span></span><br><span class="line">fork(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="keyword">envid_t</span> cenvid;</span><br><span class="line">    <span class="keyword">unsigned</span> pn;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">	set_pgfault_handler(pgfault); <span class="comment">//设置 缺页处理</span></span><br><span class="line">	<span class="keyword">if</span> ((cenvid = sys_exofork()) &lt; <span class="number">0</span>)&#123; <span class="comment">//创建了一个进程。</span></span><br><span class="line">		panic(<span class="string">"sys_exofork failed"</span>);</span><br><span class="line">		<span class="keyword">return</span> cenvid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cenvid&gt;<span class="number">0</span>)&#123;<span class="comment">//如果是 父亲进程</span></span><br><span class="line">		<span class="keyword">for</span> (pn=PGNUM(UTEXT); pn&lt;PGNUM(USTACKTOP); pn++)&#123; <span class="comment">//复制UTEXT 到USTACKTOP的页</span></span><br><span class="line">            <span class="keyword">if</span> ((uvpd[pn &gt;&gt; <span class="number">10</span>] &amp; PTE_P) &amp;&amp; (uvpt[pn] &amp; PTE_P))</span><br><span class="line">                <span class="keyword">if</span> ((r = duppage(cenvid, pn)) &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ((r = sys_page_alloc(cenvid, (<span class="keyword">void</span> *)(UXSTACKTOP-PGSIZE), PTE_U | PTE_P | PTE_W)) &lt; <span class="number">0</span>)  <span class="comment">//分配一个新的页</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">		<span class="keyword">extern</span> <span class="keyword">void</span> _pgfault_upcall(<span class="keyword">void</span>); <span class="comment">//缺页处理</span></span><br><span class="line">		<span class="keyword">if</span> ((r = sys_env_set_pgfault_upcall(cenvid, _pgfault_upcall)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> r; <span class="comment">//为儿子设置一个缺页处理分支</span></span><br><span class="line">		<span class="keyword">if</span> ((r = sys_env_set_status(cenvid, ENV_RUNNABLE)) &lt; <span class="number">0</span>)<span class="comment">//设置成可运行</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">return</span> cenvid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		thisenv = &amp;envs[ENVX(sys_getenvid())];<span class="comment">//如果是儿子就直接运行。</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//panic("fork not implemented");</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Challenge!</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">sfork(<span class="keyword">void</span>)</span><br><span class="line">&#123;	<span class="comment">//这个挑战的内容，我没看懂要做什么。</span></span><br><span class="line">	panic(<span class="string">"sfork not implemented"</span>);</span><br><span class="line">	<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Part-C-Preemptive-Multitasking-and-Inter-Process-communication-IPC"><a href="#Part-C-Preemptive-Multitasking-and-Inter-Process-communication-IPC" class="headerlink" title="Part C: Preemptive Multitasking and Inter-Process communication (IPC)"></a>Part C: Preemptive Multitasking and Inter-Process communication (IPC)</h1><p>现在我们要实现抢占式调度和进程间通信。 </p>
<h2 id="Clock-Interrupts-and-Preemption"><a href="#Clock-Interrupts-and-Preemption" class="headerlink" title="Clock Interrupts and Preemption"></a>Clock Interrupts and Preemption</h2><p>运行<code>user/spin</code>会死循环。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Test preemption by forking off a child process that just spins forever.</span></span><br><span class="line"><span class="comment">// Let it run for a couple time slices, then kill it.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">umain(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">envid_t</span> env;</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">"I am the parent.  Forking the child...\n"</span>);</span><br><span class="line">	<span class="keyword">if</span> ((env = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">		cprintf(<span class="string">"I am the child.  Spinning...\n"</span>);</span><br><span class="line">		<span class="keyword">while</span> <span class="comment">//(1) 在这个地方死循环了</span></span><br><span class="line">			<span class="comment">/* do nothing */</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">"I am the parent.  Running the child...\n"</span>);</span><br><span class="line">	sys_yield();</span><br><span class="line">	sys_yield();</span><br><span class="line">	sys_yield();</span><br><span class="line">	sys_yield();</span><br><span class="line">	sys_yield();</span><br><span class="line">	sys_yield();</span><br><span class="line">	sys_yield();</span><br><span class="line">	sys_yield();</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">"I am the parent.  Killing the child...\n"</span>);</span><br><span class="line">	sys_env_destroy(env);<span class="comment">//如果是抢占式 就会在这个地方给毁了子进程。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现抢占式，必须要有硬件的支持。</p>
<h2 id="Interrupt-discipline"><a href="#Interrupt-discipline" class="headerlink" title="Interrupt discipline"></a>Interrupt discipline</h2><p>外部中断（即，设备中断）被称为<code>IRQ</code>。有16个可能的IRQ，编号从0到15.IRQ编号到IDT表项的映射不是固定的。<code>picirq.c</code>中的<code>pic_init</code>将0~15的IRQ编号映射到IDT表项 ，<code>[IRQ_OFFSET ~ IRQ_OFFSET +15]</code>。</p>
<p>在<code>inc/trap.h</code>中，<code>IRQ_OFFSET</code>的值是32.因此IDT表项<code>[32~ 47]</code>对应<code>0~15</code>的IRQ编号。例如，时钟中断是IRQ 0，因此<code>IDT[32]</code>包含内核中的时钟中断处理例程的地址。<code>IRQ_OFFSET</code>的选择主要是为了设备中断不与处理器异常重叠。</p>
<p>在JOS中，对比<code>xv6 Unix</code>，我们做了关键的简化。在内核中的时候，外部设备中断基本上是关闭的（像xv6一样，在用户空间打开）。外部设备中断由<code>%eflags</code>寄存器上的<code>FL_IF</code>标志位控制。当这个位置位，外部中断使能。这个位可以通过几种途径修改，由于我们的简化，我们仅通过在进入内核时候保存<code>%eflags</code>寄存器，退出内核时恢复<code>%eflags</code>寄存器这个过程来修改<code>FL_IF</code>标志位。</p>
<p>应该确保在用户态<code>FL_IF</code>标志位是置位的，这样中断才能传递给处理器，并最终被中断代码处理。否则，中断被屏蔽或忽略，直到重新启用中断。<code>Bootloader</code>最初几条指令就屏蔽了中断，到目前为止，我们从来没有重新启用它们。<br><code>练习 13</code> 要我像当初实现内部中断一样，实现这几个外部中断。<br>一样的没啥区别。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">TRAPHANDLER_NOEC(IRQ0, IRQ_OFFSET)</span><br><span class="line">TRAPHANDLER_NOEC(IRQ1, IRQ_OFFSET+<span class="number">1</span>)</span><br><span class="line">TRAPHANDLER_NOEC(IRQ2, IRQ_OFFSET+<span class="number">2</span>)</span><br><span class="line">TRAPHANDLER_NOEC(IRQ3, IRQ_OFFSET+<span class="number">3</span>)</span><br><span class="line">TRAPHANDLER_NOEC(IRQ4, IRQ_OFFSET+<span class="number">4</span>)</span><br><span class="line">TRAPHANDLER_NOEC(IRQ5, IRQ_OFFSET+<span class="number">5</span>)</span><br><span class="line">TRAPHANDLER_NOEC(IRQ6, IRQ_OFFSET+<span class="number">6</span>)</span><br><span class="line">TRAPHANDLER_NOEC(IRQ7, IRQ_OFFSET+<span class="number">7</span>)</span><br><span class="line">TRAPHANDLER_NOEC(IRQ8, IRQ_OFFSET+<span class="number">8</span>)</span><br><span class="line">TRAPHANDLER_NOEC(IRQ9, IRQ_OFFSET+<span class="number">9</span>)</span><br><span class="line">TRAPHANDLER_NOEC(IRQ10, IRQ_OFFSET+<span class="number">10</span>)</span><br><span class="line">TRAPHANDLER_NOEC(IRQ11, IRQ_OFFSET+<span class="number">11</span>)</span><br><span class="line">TRAPHANDLER_NOEC(IRQ12, IRQ_OFFSET+<span class="number">12</span>)</span><br><span class="line">TRAPHANDLER_NOEC(IRQ13, IRQ_OFFSET+<span class="number">13</span>)</span><br><span class="line">TRAPHANDLER_NOEC(IRQ14, IRQ_OFFSET+<span class="number">14</span>)</span><br><span class="line">TRAPHANDLER_NOEC(IRQ15, IRQ_OFFSET+<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IRQ0</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IRQ1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IRQ2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IRQ3</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IRQ4</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IRQ5</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IRQ6</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IRQ7</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IRQ8</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IRQ9</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IRQ10</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IRQ11</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IRQ12</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IRQ13</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IRQ14</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IRQ15</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// trap_init</span></span><br><span class="line">	SETGATE(idt[IRQ_OFFSET], <span class="number">0</span>, GD_KT, IRQ0, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET+<span class="number">1</span>], <span class="number">0</span>, GD_KT, IRQ1, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET+<span class="number">2</span>], <span class="number">0</span>, GD_KT, IRQ2, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET+<span class="number">3</span>], <span class="number">0</span>, GD_KT, IRQ3, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET+<span class="number">4</span>], <span class="number">0</span>, GD_KT, IRQ4, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET+<span class="number">5</span>], <span class="number">0</span>, GD_KT, IRQ5, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET+<span class="number">6</span>], <span class="number">0</span>, GD_KT, IRQ6, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET+<span class="number">7</span>], <span class="number">0</span>, GD_KT, IRQ7, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET+<span class="number">8</span>], <span class="number">0</span>, GD_KT, IRQ8, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET+<span class="number">9</span>], <span class="number">0</span>, GD_KT, IRQ9, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET+<span class="number">10</span>], <span class="number">0</span>, GD_KT, IRQ10, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET+<span class="number">11</span>], <span class="number">0</span>, GD_KT, IRQ11, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET+<span class="number">12</span>], <span class="number">0</span>, GD_KT, IRQ12, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET+<span class="number">13</span>], <span class="number">0</span>, GD_KT, IRQ13, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET+<span class="number">14</span>], <span class="number">0</span>, GD_KT, IRQ14, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET+<span class="number">15</span>], <span class="number">0</span>, GD_KT, IRQ15, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// Per-CPU setup</span></span><br></pre></td></tr></table></figure></p>
<p>还需要开启这个中断，在<code>env_alloc</code>里面。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enable interrupts while in user mode.</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">e-&gt;env_tf.tf_eflags |= FL_IF;</span><br></pre></td></tr></table></figure></p>
<h2 id="Handling-Clock-Interrupts"><a href="#Handling-Clock-Interrupts" class="headerlink" title="Handling Clock Interrupts"></a>Handling Clock Interrupts</h2><p>在<code>user/spin</code>程序中，子进程开始运行之后就进入死循环，内核不会再获取控制权。我们现在需要对硬件编程以每隔一定的时间生成时钟中断，这样会强制将控制权返回给内核，内核可以切换到不同的用户环境上运行。</p>
<p><code>i386_init()</code>函数调用<code>lapic_init</code>和<code>pic_init</code>，设置时钟以及中断控制器生成中断，现在需要编写代码处理这些中断。<br>这个时候材质 <code>lapic_init</code> 和<code>pic_init</code> 是用来干啥的。<br>后来发现<code>lapicw(TICR, 10000000);</code>这个是设置中断时间具体细节就不知道了，应该和嵌入式有关。<br><code>练习 14</code>让我们<code>trap_dispatch</code>里面实现调度，也就是抢占式调度。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:&#123;</span><br><span class="line">			lapic_eoi();</span><br><span class="line">			sched_yield();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Inter-Process-communication-IPC"><a href="#Inter-Process-communication-IPC" class="headerlink" title="Inter-Process communication (IPC)"></a>Inter-Process communication (IPC)</h2><p>最后一个就是进程通信。我们到目前为止，都是假装一个电脑就只有一个进程，现在我们要开始烤炉两个进程之间的相互影响。我们需要实现一个简单的进程通信。</p>
<h2 id="IPC-in-JOS"><a href="#IPC-in-JOS" class="headerlink" title="IPC in JOS"></a>IPC in JOS</h2><p>我们需要实现两个系统调用<code>sys_ipc_recv</code> 和 <code>sys_ipc_try_send</code>并且我们已经用<code>ipc_recv</code>和<code>ipc_send</code>封装好了他(C语言里面有封装的概念？？)，我们发送的信息是一个32位的值和可选的一个单页映射。<br>允许用户环境在消息中传递页面映射提供了一种传输更多的数据的有效的方法，而不仅仅是单个32位整数，并且还允许用户环境轻松地建立共享内存布局。</p>
<h2 id="Sending-and-Receiving-Messages"><a href="#Sending-and-Receiving-Messages" class="headerlink" title="Sending and Receiving Messages"></a>Sending and Receiving Messages</h2><p>用户环境调用<code>sys_ipc_recv</code>接收消息。此系统调用会调度当前环境，使得在收到消息之前不再运行它。当用户环境等待接收消息时，任何其他用户环境都可以向其发送消息– 而不仅仅是特定的环境，而不仅仅是与接收消息的用户环境具有的父/子关系的用户环境。换而言之，在PartA中实现的权限检查不再适用于IPC，因为IPC系统调用是精心设计的，以便是“安全的”：用户环境不能仅仅通过发送消息而导致另一个环境故障（除非目标环境也是错误的）。</p>
<p>用户环境以接收消息的用户环境的id以及待发送的值为参数调用<code>sys_ipc_try_send</code>发送一个值。如果接收消息的用户环境是否正在接收消息（该用户环境调用<code>sys_ipc_recv</code>系统调用，但还没有接收到值），<code>sys_ipc_try_send</code>系统调用传送消息并返回0，否则返回<code>-E_IPC_NOT_RECV</code>表示目标环境当前不希望接收到一个值。</p>
<p>用户空间的库函数<code>ipc_recv</code>负责调用<code>sys_ipc_recv</code>,然后在当前环境的<code>struct Env</code>中查找有关接收到的值的信息。</p>
<p>类似的，用户空间的库函数<code>ipc_send</code>否则反复调用<code>sys_ipc_try_send</code>直到消息发送成功。</p>
<h2 id="Transferring-Pages"><a href="#Transferring-Pages" class="headerlink" title="Transferring Pages"></a>Transferring Pages</h2><p>当用户环境使用有效的<code>dstva</code>参数（低于<code>UTOP</code>）调用<code>sys_ipc_recv</code>时，环境表示它愿意接收页面映射。如果发送者发送一个页面，那么该页面应该在接收者的地址空间中的<code>dstva</code>映射。如果接收者已经在<code>dstva</code>上映射了一个页面，那么之前的页映射被取消。</p>
<p>当用户环境以有效的<code>srcva</code>（在<code>UTO</code>P下面）以及权限<code>perm</code>为参数调用<code>sys_ipc_try_send</code>时，这意味着发送者想要将当前映射到<code>srcva</code>的页面发送给接收者。在成功的<code>IPC</code>之后，发送方在其地址空间中的<code>srcva</code>保持页面的原始映射，但是接收方在其地址空间最初指定的<code>dstva</code>处获得了与发送者同一物理页的映射。因此，该页面在发送者和接收者之间共享。</p>
<p>如果发送者或接收者没有指示一个页面应该被传送，那么没有页面被传送。在任何<code>IPC</code>之后，内核将接收者的<code>Env</code>结构中的新字段<code>env_ipc_perm</code>设置为接收到的页面的权限，如果没有接收到页面，则为零。</p>
<h2 id="Implementing-IPC"><a href="#Implementing-IPC" class="headerlink" title="Implementing IPC"></a>Implementing IPC</h2><p>介绍了这么多东西其实也就是为了最后这个。<br><code>练习15</code> 实现<code>sys_ipc_recv</code>和<code>sys_ipc_recv</code>。</p>
<h3 id="sys-ipc-recv"><a href="#sys-ipc-recv" class="headerlink" title="sys_ipc_recv"></a>sys_ipc_recv</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Try to send 'value' to the target env 'envid'.</span></span><br><span class="line"><span class="comment">// If srcva &lt; UTOP, then also send page currently mapped at 'srcva',</span></span><br><span class="line"><span class="comment">// so that receiver gets a duplicate mapping of the same page.</span></span><br><span class="line"><span class="comment">// 发过  srcva &lt; UTOP 把他对应的物理页送过去</span></span><br><span class="line"><span class="comment">// The send fails with a return value of -E_IPC_NOT_RECV if the</span></span><br><span class="line"><span class="comment">// target is not blocked, waiting for an IPC.</span></span><br><span class="line"><span class="comment">// 失败返回 E_IPC_NOT_RECV 如果目标是不堵塞的就等待IPC</span></span><br><span class="line"><span class="comment">// The send also can fail for the other reasons listed below.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Otherwise, the send succeeds, and the target's ipc fields are</span></span><br><span class="line"><span class="comment">// updated as follows: //如果发送成功更新下面这些东西</span></span><br><span class="line"><span class="comment">//    env_ipc_recving is set to 0 to block future sends; 设置 0来阻塞</span></span><br><span class="line"><span class="comment">//    env_ipc_from is set to the sending envid;//设置发送的ID</span></span><br><span class="line"><span class="comment">//    env_ipc_value is set to the 'value' parameter; 设置值</span></span><br><span class="line"><span class="comment">//    env_ipc_perm is set to 'perm' if a page was transferred, 0 otherwise.设置发送页面权限</span></span><br><span class="line"><span class="comment">// The target environment is marked runnable again, returning 0 标记目标环境为runnable</span></span><br><span class="line"><span class="comment">// from the paused sys_ipc_recv system call.  (Hint: does the</span></span><br><span class="line"><span class="comment">// sys_ipc_recv function ever actually return?)暂停sys_ipc_recv</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the sender wants to send a page but the receiver isn't asking for one,</span></span><br><span class="line"><span class="comment">// then no page mapping is transferred, but no error occurs.</span></span><br><span class="line"><span class="comment">// The ipc only happens when no errors occur.</span></span><br><span class="line"><span class="comment">// 如果当前进程发送了一个页，但是 目标进程没有要求一个页，然后没有 页会被发送，不会产生错误。</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.</span></span><br><span class="line"><span class="comment">// Errors are:</span></span><br><span class="line"><span class="comment">//	-E_BAD_ENV if environment envid doesn't currently exist.</span></span><br><span class="line"><span class="comment">//		(No need to check permissions.)//如果进程错误</span></span><br><span class="line"><span class="comment">//	-E_IPC_NOT_RECV if envid is not currently blocked in sys_ipc_recv,</span></span><br><span class="line"><span class="comment">//		or another environment managed to send first.//目标没有接受</span></span><br><span class="line"><span class="comment">//	-E_INVAL if srcva &lt; UTOP but srcva is not page-aligned.//页地址错误</span></span><br><span class="line"><span class="comment">//	-E_INVAL if srcva &lt; UTOP and perm is inappropriate//页权限错误</span></span><br><span class="line"><span class="comment">//		(see sys_page_alloc).</span></span><br><span class="line"><span class="comment">//	-E_INVAL if srcva &lt; UTOP but srcva is not mapped in the caller's</span></span><br><span class="line"><span class="comment">//		address space.//页没有映射</span></span><br><span class="line"><span class="comment">//	-E_INVAL if (perm &amp; PTE_W), but srcva is read-only in the</span></span><br><span class="line"><span class="comment">//		current environment's address space.//页只读</span></span><br><span class="line"><span class="comment">//	-E_NO_MEM if there's not enough memory to map srcva in envid's</span></span><br><span class="line"><span class="comment">//		address space.//没有足够的空间</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_ipc_try_send(<span class="keyword">envid_t</span> envid, <span class="keyword">uint32_t</span> value, <span class="keyword">void</span> *srcva, <span class="keyword">unsigned</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">env</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(envid2env(envid,&amp;env,<span class="number">0</span>)&lt;<span class="number">0</span>)<span class="keyword">return</span> -E_BAD_ENV;<span class="comment">//环境</span></span><br><span class="line">	<span class="keyword">if</span>(env-&gt;env_ipc_recving==<span class="number">0</span>)<span class="keyword">return</span> -E_IPC_NOT_RECV;<span class="comment">//是否阻塞</span></span><br><span class="line">	env-&gt;env_ipc_perm = <span class="number">0</span>;<span class="comment">//权限</span></span><br><span class="line">	<span class="keyword">unsigned</span> flag= PTE_P | PTE_U;</span><br><span class="line">	<span class="keyword">if</span>((<span class="keyword">uintptr_t</span>)srcva&lt;UTOP)&#123;<span class="comment">//页地址小于UTOP</span></span><br><span class="line">		<span class="keyword">if</span>(PGOFF(srcva))<span class="keyword">return</span> -E_INVAL;<span class="comment">//不是页对齐</span></span><br><span class="line">		<span class="keyword">if</span> ((perm &amp; ~(PTE_SYSCALL)) || ((perm &amp; flag) != flag))<span class="keyword">return</span> -E_INVAL;<span class="comment">//权限错误</span></span><br><span class="line">		<span class="keyword">if</span> (user_mem_check(curenv, (<span class="keyword">const</span> <span class="keyword">void</span> *)srcva, PGSIZE, PTE_U) &lt; <span class="number">0</span>)<span class="comment">//页不存在</span></span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		<span class="keyword">if</span> (perm&amp; PTE_W&amp;&amp;user_mem_check(curenv, (<span class="keyword">const</span> <span class="keyword">void</span> *)srcva, PGSIZE, PTE_U |PTE_W) &lt; <span class="number">0</span>)<span class="comment">//页权限错误</span></span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		<span class="keyword">if</span>((<span class="keyword">uintptr_t</span>)(env-&gt;env_ipc_dstva)&lt;UTOP)&#123;<span class="comment">//接受页的地址</span></span><br><span class="line">			env-&gt;env_ipc_perm=perm;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pi</span> = <span class="title">page_lookup</span>(<span class="title">curenv</span>-&gt;<span class="title">env_pgdir</span>, <span class="title">srcva</span>, 0);</span></span><br><span class="line">			<span class="keyword">if</span> (page_insert(env-&gt;env_pgdir, pi, env-&gt;env_ipc_dstva,  perm) &lt; <span class="number">0</span>)<span class="comment">//映射一下，映射失败返回没有内存了。</span></span><br><span class="line">                <span class="keyword">return</span> -E_NO_MEM; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置一下值</span></span><br><span class="line">	env-&gt;env_ipc_recving = <span class="literal">false</span>;</span><br><span class="line">    env-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">    env-&gt;env_ipc_value = value;</span><br><span class="line">    env-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">    env-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//panic("sys_ipc_try_send not implemented");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sys-ipc-recv-1"><a href="#sys-ipc-recv-1" class="headerlink" title="sys_ipc_recv"></a>sys_ipc_recv</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Block until a value is ready.  Record that you want to receive</span></span><br><span class="line"><span class="comment">// using the env_ipc_recving and env_ipc_dstva fields of struct Env,</span></span><br><span class="line"><span class="comment">// mark yourself not runnable, and then give up the CPU.</span></span><br><span class="line"><span class="comment">// 在等到接受之前一直 阻塞，释放CPU</span></span><br><span class="line"><span class="comment">// If 'dstva' is &lt; UTOP, then you are willing to receive a page of data.</span></span><br><span class="line"><span class="comment">// 'dstva' is the virtual address at which the sent page should be mapped.</span></span><br><span class="line"><span class="comment">//如果 dstva &lt;UTOP  标示你愿意接受一个页。送过来的页将映射到dstva</span></span><br><span class="line"><span class="comment">// This function only returns on error, but the system call will eventually</span></span><br><span class="line"><span class="comment">// return 0 on success.</span></span><br><span class="line"><span class="comment">// Return &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//	-E_INVAL if dstva &lt; UTOP but dstva is not page-aligned.//只有这样会保存</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_ipc_recv(<span class="keyword">void</span> *dstva)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span>((dstva &lt; (<span class="keyword">void</span> *)UTOP) &amp;&amp; PGOFF(dstva))<span class="comment">//报错</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	curenv-&gt;env_ipc_recving = <span class="literal">true</span>; </span><br><span class="line">    curenv-&gt;env_ipc_dstva = dstva;</span><br><span class="line">    curenv-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    sched_yield();</span><br><span class="line">	<span class="comment">//panic("sys_ipc_recv not implemented");</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后别忘了，<code>syscall</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SYS_ipc_try_send:                                                                                          </span><br><span class="line">	<span class="keyword">return</span> sys_ipc_try_send((<span class="keyword">envid_t</span>)a1, (<span class="keyword">uint32_t</span>)a2, (<span class="keyword">void</span> *)a3, (<span class="keyword">unsigned</span>)a4);                               </span><br><span class="line"><span class="keyword">case</span> SYS_ipc_recv:                                                                                              </span><br><span class="line">	<span class="keyword">return</span> sys_ipc_recv((<span class="keyword">void</span> *)a1);</span><br><span class="line">      <span class="keyword">default</span>:</span><br></pre></td></tr></table></figure></p>
<p>然后让我们实现<code>lib/ipc.c</code>里面的<code>ipc_recv</code>和<code>ipc_send</code>。</p>
<h3 id="ipc-c"><a href="#ipc-c" class="headerlink" title="ipc.c"></a>ipc.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User-level IPC library routines</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Receive a value via IPC and return it. 接受一个IPC</span></span><br><span class="line"><span class="comment">// If 'pg' is nonnull, then any page sent by the sender will be mapped at</span></span><br><span class="line"><span class="comment">//	that address. 如果pg非空会发送他</span></span><br><span class="line"><span class="comment">// If 'from_env_store' is nonnull, then store the IPC sender's envid in</span></span><br><span class="line"><span class="comment">//	*from_env_store. 如果from_env_store非空就会把发送进程的id 放到 from_env_store</span></span><br><span class="line"><span class="comment">// If 'perm_store' is nonnull, then store the IPC sender's page permission</span></span><br><span class="line"><span class="comment">//	in *perm_store (this is nonzero iff a page was successfully</span></span><br><span class="line"><span class="comment">//	transferred to 'pg'). 如果perm_store非空就会储存页权限在这</span></span><br><span class="line"><span class="comment">// If the system call fails, then store 0 in *fromenv and *perm (if</span></span><br><span class="line"><span class="comment">//	they're nonnull) and return the error. 如果错了就会把0存到fromenv和perm如果他们非空。</span></span><br><span class="line"><span class="comment">// Otherwise, return the value sent by the sender 否则返回值</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//   Use 'thisenv' to discover the value and who sent it. 用thisenv发现是谁送的</span></span><br><span class="line"><span class="comment">//   If 'pg' is null, pass sys_ipc_recv a value that it will understand</span></span><br><span class="line"><span class="comment">//   as meaning "no page".  (Zero is not the right value, since that's</span></span><br><span class="line"><span class="comment">//   a perfectly valid place to map a page.)</span></span><br><span class="line"><span class="keyword">int32_t</span></span><br><span class="line">ipc_recv(<span class="keyword">envid_t</span> *from_env_store, <span class="keyword">void</span> *pg, <span class="keyword">int</span> *perm_store)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	pg = (pg == <span class="literal">NULL</span> ? (<span class="keyword">void</span> *)UTOP : pg);</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_ipc_recv(pg)) &lt; <span class="number">0</span>) &#123;<span class="comment">//UTOP 相当于没有地址会返回0</span></span><br><span class="line">        <span class="keyword">if</span> (from_env_store != <span class="literal">NULL</span>)</span><br><span class="line">            *from_env_store = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (perm_store != <span class="literal">NULL</span>)</span><br><span class="line">            *perm_store = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果pg==NULL 后面这两个值都毫无意义</span></span><br><span class="line">    <span class="keyword">if</span> (from_env_store != <span class="literal">NULL</span>)</span><br><span class="line">        *from_env_store = thisenv-&gt;env_ipc_from;</span><br><span class="line">    <span class="keyword">if</span> (perm_store != <span class="literal">NULL</span>)</span><br><span class="line">        *perm_store = thisenv-&gt;env_ipc_perm;</span><br><span class="line">    <span class="keyword">return</span> thisenv-&gt;env_ipc_value;</span><br><span class="line">	<span class="comment">//panic("ipc_recv not implemented");</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send 'val' (and 'pg' with 'perm', if 'pg' is nonnull) to 'toenv'.</span></span><br><span class="line"><span class="comment">// This function keeps trying until it succeeds.</span></span><br><span class="line"><span class="comment">// It should panic() on any error other than -E_IPC_NOT_RECV.</span></span><br><span class="line"><span class="comment">// 如果不是 E_IPC_NOT_RECV 就报错。</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//   Use sys_yield() to be CPU-friendly.</span></span><br><span class="line"><span class="comment">//   If 'pg' is null, pass sys_ipc_try_send a value that it will understand</span></span><br><span class="line"><span class="comment">//   as meaning "no page".  (Zero is not the right value.) </span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ipc_send(<span class="keyword">envid_t</span> to_env, <span class="keyword">uint32_t</span> val, <span class="keyword">void</span> *pg, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="keyword">while</span>((r=sys_ipc_try_send(to_env,val, (pg == <span class="literal">NULL</span> ? (<span class="keyword">void</span> *)UTOP : pg),perm))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(r!=-E_IPC_NOT_RECV)panic(<span class="string">"sys_ipc_try_send: %e\n"</span>, r);</span><br><span class="line">		sys_yield();<span class="comment">//释放CPU</span></span><br><span class="line">	&#125;<span class="comment">//一直发送直到成功...</span></span><br><span class="line">	<span class="comment">//panic("ipc_send not implemented");</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find the first environment of the given type.  We'll use this to</span></span><br><span class="line"><span class="comment">// find special environments.</span></span><br><span class="line"><span class="comment">// Returns 0 if no such environment exists.</span></span><br><span class="line"><span class="keyword">envid_t</span></span><br><span class="line">ipc_find_env(<span class="keyword">enum</span> EnvType type)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NENV; i++)</span><br><span class="line">		<span class="keyword">if</span> (envs[i].env_type == type)</span><br><span class="line">			<span class="keyword">return</span> envs[i].env_id;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/MIT6-828/" rel="tag"># MIT6.828</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div class="social_share">
            
            
              <div id="needsharebutton-postbottom">
                <span class="btn">
                  <i class="fa fa-share-alt" aria-hidden="true"></i>
                </span>
              </div>
            
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/02/18/MIT-6.828-(三)-Lab-3-User-Environments/" rel="next" title="MIT6.828(三)Lab3:User Environments">
                <i class="fa fa-chevron-left"></i> MIT6.828(三)Lab3:User Environments
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/02/18/MIT-6.828-(五)-Lab-5-File-system,-Spawn-and-Shell/" rel="prev" title="MIT6.828 (五)Lab5:File system, Spawn and Shell">
                MIT6.828 (五)Lab5:File system, Spawn and Shell <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      
        <div id="gitment-container"></div>
      
    </div>

  




        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/tou.jpeg" alt="尘">
            
              <p class="site-author-name" itemprop="name">尘</p>
              <p class="site-description motion-element" itemprop="description">做自己不会做的事被称之为学习</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">123</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">56</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/ETBUBBLE" title="GitHub &rarr; https://github.com/ETBUBBLE" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/qq_40871466" title="https://blog.csdn.net/qq_40871466" rel="noopener" target="_blank">csdn</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=549159342&auto=1&height=66"></iframe>
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab-4-Preemptive-Multitasking"><span class="nav-number">1.</span> <span class="nav-text">Lab 4: Preemptive Multitasking</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Part-A-Multiprocessor-Support-and-Cooperative-Multitasking"><span class="nav-number">2.</span> <span class="nav-text">Part A: Multiprocessor Support and Cooperative Multitasking</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Multiprocessor-Support"><span class="nav-number">2.1.</span> <span class="nav-text">Multiprocessor Support</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#lapic-c"><span class="nav-number">2.1.1.</span> <span class="nav-text">lapic.c</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Application-Processor-Bootstrap"><span class="nav-number">2.2.</span> <span class="nav-text">Application Processor Bootstrap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#i386-init"><span class="nav-number">2.2.1.</span> <span class="nav-text">i386_init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#boot-aps"><span class="nav-number">2.2.2.</span> <span class="nav-text">boot_aps</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mpentry-start"><span class="nav-number">2.2.3.</span> <span class="nav-text">mpentry_start</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Question"><span class="nav-number">2.2.4.</span> <span class="nav-text">Question</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Per-CPU-State-and-Initialization"><span class="nav-number">2.3.</span> <span class="nav-text">Per-CPU State and Initialization</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mem-init-mp"><span class="nav-number">2.3.1.</span> <span class="nav-text">mem_init_mp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Locking"><span class="nav-number">2.4.</span> <span class="nav-text">Locking</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#kern-spinlock-c"><span class="nav-number">2.4.1.</span> <span class="nav-text">kern/spinlock.c</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Question-2"><span class="nav-number">2.4.2.</span> <span class="nav-text">Question 2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Round-Robin-Scheduling"><span class="nav-number">2.5.</span> <span class="nav-text">Round-Robin Scheduling</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sched-yield"><span class="nav-number">2.5.1.</span> <span class="nav-text">sched_yield</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Question-3"><span class="nav-number">2.5.2.</span> <span class="nav-text">Question 3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Question-4"><span class="nav-number">2.5.3.</span> <span class="nav-text">Question 4</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#System-Calls-for-Environment-Creation"><span class="nav-number">2.6.</span> <span class="nav-text">System Calls for Environment Creation</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Part-B-Copy-on-Write-Fork"><span class="nav-number">3.</span> <span class="nav-text">Part B: Copy-on-Write Fork</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#User-level-page-fault-handling"><span class="nav-number">3.1.</span> <span class="nav-text">User-level page fault handling</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Setting-the-Page-Fault-Handler"><span class="nav-number">3.2.</span> <span class="nav-text">Setting the Page Fault Handler</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Normal-and-Exception-Stacks-in-User-Environments"><span class="nav-number">3.3.</span> <span class="nav-text">Normal and Exception Stacks in User Environments</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Invoking-the-User-Page-Fault-Handler"><span class="nav-number">3.4.</span> <span class="nav-text">Invoking the User Page Fault Handler</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#User-mode-Page-Fault-Entrypoint"><span class="nav-number">3.5.</span> <span class="nav-text">User-mode Page Fault Entrypoint</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Implementing-Copy-on-Write-Fork"><span class="nav-number">3.6.</span> <span class="nav-text">Implementing Copy-on-Write Fork</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Part-C-Preemptive-Multitasking-and-Inter-Process-communication-IPC"><span class="nav-number">4.</span> <span class="nav-text">Part C: Preemptive Multitasking and Inter-Process communication (IPC)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Clock-Interrupts-and-Preemption"><span class="nav-number">4.1.</span> <span class="nav-text">Clock Interrupts and Preemption</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Interrupt-discipline"><span class="nav-number">4.2.</span> <span class="nav-text">Interrupt discipline</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Handling-Clock-Interrupts"><span class="nav-number">4.3.</span> <span class="nav-text">Handling Clock Interrupts</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Inter-Process-communication-IPC"><span class="nav-number">4.4.</span> <span class="nav-text">Inter-Process communication (IPC)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IPC-in-JOS"><span class="nav-number">4.5.</span> <span class="nav-text">IPC in JOS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sending-and-Receiving-Messages"><span class="nav-number">4.6.</span> <span class="nav-text">Sending and Receiving Messages</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Transferring-Pages"><span class="nav-number">4.7.</span> <span class="nav-text">Transferring Pages</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Implementing-IPC"><span class="nav-number">4.8.</span> <span class="nav-text">Implementing IPC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sys-ipc-recv"><span class="nav-number">4.8.1.</span> <span class="nav-text">sys_ipc_recv</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sys-ipc-recv-1"><span class="nav-number">4.8.2.</span> <span class="nav-text">sys_ipc_recv</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ipc-c"><span class="nav-number">4.8.3.</span> <span class="nav-text">ipc.c</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <link rel="stylesheet" href="/live2d/css/live2d.css">
      <div id="landlord">
          <div class="message" style="opacity:0"></div>
          <canvas id="live2d" width="280" height="250" class="live2d"></canvas>
          <div class="hide-button">隐藏</div>
      </div>
      <script type="text/javascript" src="https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
      <script type="text/javascript">
          var message_Path = '/live2d/'
          var home_Path = 'https://your.com/'
      </script>
      <script type="text/javascript" src="/live2d/js/live2d.js"></script>
      <script type="text/javascript" src="/live2d/js/message.js"></script>
      <script type="text/javascript">
          loadlive2d("live2d", "/live2d/model/tia/model.json");
      </script>
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">尘</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">810k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">12:16</span>
  
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.0.0</div>
-->



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
      <div id="needsharebutton-float">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.0"></script>

  <script src="/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.0"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.0"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.0"></script>
<script src="/js/src/post-details.js?v=7.0.0"></script>



  


  <script src="/js/src/bootstrap.js?v=7.0.0"></script>


  
  


  
    <!-- LOCAL: You can save these files to your site and update links -->

  
     <!-- <script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js"></script> -->
<script src="https://billts.site/js/gitment.js"></script>

<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css"/> -->
<link rel="stylesheet" href="https://billts.site/extra_css/gitment.css">

<!-- END LOCAL -->

<style>
#gitment-container a {
  border-bottom: none;
}

</style>

<script>
  function renderGitment() {

    var gitment = new Gitment({
      id: '1582033281000',
      owner: 'ETBUBBLE',
      repo: 'ETBUBBLE.github.io',
      
      oauth: {
      
      
        client_secret: '0fd4f83bc7834795c0575404ee5c7a2c82067749',
      
        client_id: '008c7d3ffa7d973b8437'
      }
    });
    gitment.render('gitment-container');
  }

  
    renderGitment();
  
</script>

  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  
    
      <script type="text/x-mathjax-config">
  

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });
  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') { next = next.nextSibling }
        if (next && next.nodeName.toLowerCase() === 'br') { next.parentNode.removeChild(next) }
      }
    });
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
      for (i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<style>
.MathJax_Display {
  overflow-x: scroll;
  overflow-y: hidden;
}
</style>

    
  


  

  

  

  
  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>
  <script>
    
      pbOptions = {};
      
        pbOptions.iconStyle = "box";
      
        pbOptions.boxForm = "horizontal";
      
        pbOptions.position = "bottomCenter";
      
        pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
      flOptions = {};
      
        flOptions.iconStyle = "box";
      
        flOptions.boxForm = "horizontal";
      
        flOptions.position = "middleRight";
      
        flOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script>


  

  

  

  

  

  

</body>
</html>

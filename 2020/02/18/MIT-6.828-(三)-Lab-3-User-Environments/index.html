<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css?v=1.0.2">























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false,"dimmer":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="(最近有点事，做的比较慢。哦，不，抄的比较慢。。。) Lab 3: User EnvironmentsIntroduction在这个实验中，我们将实现操作系统的一些基本功能，来实现用户环境下的进程的正常运行。你将会加强JOS内核的功能，为它增添一些重要的数据结构，用来记录用户进程环境的一些信息；创建一个单一的用户环境，并且加载一个程序运行它。你也可以让JOS内核能够完成用户环境所作出的任何系统调用">
<meta name="keywords" content="MIT6.828">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT6.828(三)Lab3:User Environments">
<meta property="og:url" content="https://etbubble.github.io/2020/02/18/MIT-6.828-(三)-Lab-3-User-Environments/index.html">
<meta property="og:site_name" content="ET_BUBBLE 的博客">
<meta property="og:description" content="(最近有点事，做的比较慢。哦，不，抄的比较慢。。。) Lab 3: User EnvironmentsIntroduction在这个实验中，我们将实现操作系统的一些基本功能，来实现用户环境下的进程的正常运行。你将会加强JOS内核的功能，为它增添一些重要的数据结构，用来记录用户进程环境的一些信息；创建一个单一的用户环境，并且加载一个程序运行它。你也可以让JOS内核能够完成用户环境所作出的任何系统调用">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200118111948542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODcxNDY2,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200114110147510.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200114110425770.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200114110902276.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200114115306654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODcxNDY2,size_16,color_FFFFFF,t_70">
<meta property="og:updated_time" content="2020-02-18T14:03:15.716Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MIT6.828(三)Lab3:User Environments">
<meta name="twitter:description" content="(最近有点事，做的比较慢。哦，不，抄的比较慢。。。) Lab 3: User EnvironmentsIntroduction在这个实验中，我们将实现操作系统的一些基本功能，来实现用户环境下的进程的正常运行。你将会加强JOS内核的功能，为它增添一些重要的数据结构，用来记录用户进程环境的一些信息；创建一个单一的用户环境，并且加载一个程序运行它。你也可以让JOS内核能够完成用户环境所作出的任何系统调用">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20200118111948542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODcxNDY2,size_16,color_FFFFFF,t_70">



  <link rel="alternate" href="/atom.xml" title="ET_BUBBLE 的博客" type="application/atom+xml">




  <link rel="canonical" href="https://etbubble.github.io/2020/02/18/MIT-6.828-(三)-Lab-3-User-Environments/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>MIT6.828(三)Lab3:User Environments | ET_BUBBLE 的博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ET_BUBBLE 的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">两件事一定不能停 学习和运动</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://etbubble.github.io/2020/02/18/MIT-6.828-(三)-Lab-3-User-Environments/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="尘">
      <meta itemprop="description" content="做自己不会做的事被称之为学习">
      <meta itemprop="image" content="/images/tou.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ET_BUBBLE 的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">MIT6.828(三)Lab3:User Environments

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-18 21:40:21 / 修改时间：22:03:15" itemprop="dateCreated datePublished" datetime="2020-02-18T21:40:21+08:00">2020-02-18</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/操作系统/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/操作系统/MIT6-828/" itemprop="url" rel="index"><span itemprop="name">MIT6.828</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">50k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">45 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><del>(最近有点事，做的比较慢。哦，不，抄的比较慢。。。)</del></p>
<h1 id="Lab-3-User-Environments"><a href="#Lab-3-User-Environments" class="headerlink" title="Lab 3: User Environments"></a><a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab3/" target="_blank" rel="noopener">Lab 3: User Environments</a></h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在这个实验中，我们将实现操作系统的一些基本功能，来实现用户环境下的进程的正常运行。你将会加强JOS内核的功能，为它增添一些重要的数据结构，用来记录用户进程环境的一些信息；创建一个单一的用户环境，并且加载一个程序运行它。你也可以让JOS内核能够完成用户环境所作出的任何系统调用，以及处理用户环境产生的各种异常。</p>
<h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><p>照着官网上做就行了。<br>然后会多出他说的那些文件，后面用到的时候再说。</p>
<h2 id="Part-A-User-Environments-and-Exception-Handling"><a href="#Part-A-User-Environments-and-Exception-Handling" class="headerlink" title="Part A: User Environments and Exception Handling"></a>Part A: User Environments and Exception Handling</h2><p>让我们看看<code>inc/env.h</code>的文件，里面有用户环境的一些基本定义。我们直接分析分析一下。内核使用Env数据结构来跟踪每个用户环境。 在本实验中，最初只会创建一个环境，但您需要设计JOS内核以支持多个环境; <code>lab4</code>将通过允许用户环境<code>fork</code>其他环境来利用此功能。</p>
<h3 id="env-h"><a href="#env-h" class="headerlink" title="env.h"></a>env.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* See COPYRIGHT for copyright information. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> JOS_INC_ENV_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JOS_INC_ENV_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/trap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/memlayout.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int32_t</span> <span class="keyword">envid_t</span>; <span class="comment">//用户环境ID 变量，32位的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// An environment ID 'envid_t' has three parts:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// +1+---------------21-----------------+--------10--------+</span></span><br><span class="line"><span class="comment">// |0|          Uniqueifier             |   Environment    |</span></span><br><span class="line"><span class="comment">// | |                                  |      Index       |</span></span><br><span class="line"><span class="comment">// +------------------------------------+------------------+</span></span><br><span class="line"><span class="comment">//                                       \--- ENVX(eid) --/</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The environment index ENVX(eid) equals the environment's index in the</span></span><br><span class="line"><span class="comment">// 'envs[]' array.  The uniqueifier distinguishes environments that were</span></span><br><span class="line"><span class="comment">// created at different times, but share the same environment index.</span></span><br><span class="line"><span class="comment">// 这个ENV(eid) 可以获取在envs 数组里面的第几个。</span></span><br><span class="line"><span class="comment">// All real environments are greater than 0 (so the sign bit is zero).</span></span><br><span class="line"><span class="comment">// envid_ts less than 0 signify errors.  The envid_t == 0 is special, and</span></span><br><span class="line"><span class="comment">// stands for the current environment.  所有的 环境是大于0 的，envid_ts小于0是错误的 ，envid_t == 0 标示当前正在运行</span></span><br><span class="line"><span class="comment">//最大能支持同时活跃的进程数量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG2NENV		10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NENV			(1 &lt;&lt; LOG2NENV)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENVX(envid)		((envid) &amp; (NENV - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Values of env_status in struct Env</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">	ENV_FREE = <span class="number">0</span>,<span class="comment">//空闲</span></span><br><span class="line">	ENV_DYING,<span class="comment">//僵尸进程</span></span><br><span class="line">	ENV_RUNNABLE,<span class="comment">//准备就绪</span></span><br><span class="line">	ENV_RUNNING,<span class="comment">//运行态</span></span><br><span class="line">	ENV_NOT_RUNNABLE<span class="comment">//阻塞状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Special environment types 环境的特殊类型</span></span><br><span class="line"><span class="keyword">enum</span> EnvType &#123;</span><br><span class="line">	ENV_TYPE_USER = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 环境结构体   就是一个PCB 对这个有兴趣的同志可以看看我 的剖析 linux1.0 源码，这个就是简化版的那个东西。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span>	<span class="comment">// Saved registers  储存寄存器，用于恢复状态</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_link</span>;</span>	    <span class="comment">// Next free Env    下一个空闲结构体</span></span><br><span class="line">	<span class="keyword">envid_t</span> env_id;			    <span class="comment">// Unique environment identifier 独立的标识符</span></span><br><span class="line">	<span class="keyword">envid_t</span> env_parent_id;	    <span class="comment">// env_id of this env's parent   父亲标识符</span></span><br><span class="line">	<span class="keyword">enum</span> EnvType env_type;	    <span class="comment">// Indicates special system environments 用于区别出来某特定的用户环境</span></span><br><span class="line">	<span class="keyword">unsigned</span> env_status;	   <span class="comment">// Status of the environment  前面定义的那几个状态</span></span><br><span class="line">	<span class="keyword">uint32_t</span> env_runs;		  <span class="comment">// Number of times environment has run 运行的次数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Address space</span></span><br><span class="line">	<span class="keyword">pde_t</span> *env_pgdir;		<span class="comment">// Kernel virtual address of page dir 这个变量存放着这个环境的页目录的虚拟地址</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !JOS_INC_ENV_H</span></span></span><br></pre></td></tr></table></figure>
<p>分析完后，就去看 <code>kern/env.c</code>。<br>这个文件先不看完，就看看他定义了什么东西。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">envs</span> = <span class="title">NULL</span>;</span>		<span class="comment">// All environments 所有的环境</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">curenv</span> = <span class="title">NULL</span>;</span>		<span class="comment">// The current env	当前环境</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_free_list</span>;</span>	<span class="comment">// Free environment list 空闲环境列表</span></span><br></pre></td></tr></table></figure></p>
<p>后面有一大堆介绍。<code>Trapframe</code>这个里面具体有啥，我们后面用到的时候再看。</p>
<h3 id="Allocating-the-Environments-Array"><a href="#Allocating-the-Environments-Array" class="headerlink" title="Allocating the Environments Array"></a>Allocating the Environments Array</h3><p>前两个 结构体，在<code>kern/env.h</code> 里面有进行扩展，现在练习让我们，为他分配一个空间并映射，就是像上次为<code>kern_pages</code>分配空间一样，并进行映射。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Make 'envs' point to an array of size 'NENV' of 'struct Env'.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">envs=(struct Env*)boot_alloc(NENV*<span class="keyword">sizeof</span>(struct Env));</span><br><span class="line"><span class="built_in">memset</span>(envs,<span class="number">0</span>,NENV*<span class="keyword">sizeof</span>(struct Env));</span><br></pre></td></tr></table></figure></p>
<p>这个  和，上次实验是一样的，和分配<code>kern_pgdir</code>是一模一样的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Map the 'envs' array read-only by the user at linear address UENVS</span></span><br><span class="line"><span class="comment">// (ie. perm = PTE_U | PTE_P).</span></span><br><span class="line"><span class="comment">// Permissions:</span></span><br><span class="line"><span class="comment">//    - the new image at UENVS  -- kernel R, user R</span></span><br><span class="line"><span class="comment">//    - envs itself -- kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U);</span><br></pre></td></tr></table></figure></p>
<p>另外再复习一下上节课的内存分配 <del>(下面又是盗的图，哈哈~ )</del>。<br><img src="https://img-blog.csdnimg.cn/20200118111948542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODcxNDY2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<hr>
<h3 id="Creating-and-Running-Environments"><a href="#Creating-and-Running-Environments" class="headerlink" title="Creating and Running Environments"></a>Creating and Running Environments</h3><p>现在你需要去编写 <code>kern/env.c</code> 文件来运行一个用户环境了。由于你现在没有文件系统，所以必须把内核设置成能够加载内核中的静态二进制程序映像文件。<br><code>Lab3</code> 里面的 <code>GNUmakefile</code> 文件在<code>obj/user/</code>目录下面生成了一系列的二进制映像文件。如果你看一下 <code>kern/Makefrag</code> 文件，你会发现一些奇妙的地方，这些地方把二进制文件直接链接到内核可执行文件中，只要这些文件是<code>.o</code>文件。其中在链接器命令行中的<code>-b binary</code> 选项会使这些文件被当做二进制执行文件链接到内核之后。<br>在<code>kern/ini.c</code>中的<code>i386_init()</code>,你会看到代码运行的环境中，这些二进制图像之一。然而，关键的功能设置用户环境是不完整的;您需要填写他们进来。<br>我们照着他的意思去看看，发现相较于前几次实验，多了几行。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// Lab 3 user environment initialization functions</span></span><br><span class="line">	env_init();</span><br><span class="line">	trap_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(TEST)</span></span><br><span class="line">	<span class="comment">// Don't touch -- used by grading script!  这些不要碰，是从来测试的</span></span><br><span class="line">	ENV_CREATE(TEST, ENV_TYPE_USER);  <span class="comment">//env_create</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="comment">// Touch all you want.</span></span><br><span class="line">	ENV_CREATE(user_hello, ENV_TYPE_USER);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// TEST*</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// We only have one user environment for now, so just run it.</span></span><br><span class="line">	env_run(&amp;envs[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></p>
<p>在 <code>kern/env.h</code> 里面可以看见这个宏的原型，就当他运行了几个不同的测试吧。我没找到这几个在哪。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENV_PASTE3(x, y, z) x ## y ## z</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENV_CREATE(x, type)						\</span></span><br><span class="line">	<span class="keyword">do</span> &#123;								\</span><br><span class="line">		extern uint8_t ENV_PASTE3(_binary_obj_, x, _start)[];	\</span><br><span class="line">		env_create(ENV_PASTE3(_binary_obj_, x, _start),		\</span><br><span class="line">			   type);					\</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>不出意外，我们的任务 就是补充多出来的这几个函数了。</p>
<ul>
<li>env_init():     初始化所有的在envs数组中的 Env结构体，并把它们加入到 env_free_list中。 还要调用 env_init_percpu，这个函数要配置段式内存管理系统，让它所管理的段，可能具有两种访问优先级其中的一种，一个是内核运行时的0优先级，以及用户运行时的3优先级。</li>
<li>env_setup_vm(): 为一个新的用户环境分配一个页目录表，并且初始化这个用户环境的地址空间中的和内核相关的部分。</li>
<li>region_alloc(): 为用户环境分配物理地址空间</li>
<li>load_icode(): 分析一个ELF文件，类似于boot loader做的那样，我们可以把它的内容加载到用户环境下。</li>
<li>env_create(): 利用env_alloc函数和load_icode函数，加载一个ELF文件到用户环境中</li>
<li>env_run(): 在用户模式下，开始运行一个用户环境。</li>
</ul>
<p>现在开始，补充<code>kern/env.c</code>,</p>
<h3 id="env-init"><a href="#env-init" class="headerlink" title="env_init()"></a>env_init()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mark all environments in 'envs' as free, set their env_ids to 0,</span></span><br><span class="line"><span class="comment">// and insert them into the env_free_list. 把所有env 加入 空闲列表，然后设置 id=0</span></span><br><span class="line"><span class="comment">// Make sure the environments are in the free list in the same order</span></span><br><span class="line"><span class="comment">// they are in the envs array (i.e., so that the first call to</span></span><br><span class="line"><span class="comment">// env_alloc() returns envs[0]). 就是顺序从 0 递增 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">env_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Set up envs array</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="comment">//上面分析过 要从0 开始，所以我们倒着遍历。</span></span><br><span class="line">	env_free_list=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span>	(<span class="keyword">size_t</span> i=NENV<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		envs[i]-&gt;env_id=<span class="number">0</span>;</span><br><span class="line">		envs[i]-&gt;env_status=ENV_FREE;</span><br><span class="line">		envs[i]-&gt;env_link=env_free_list;</span><br><span class="line">		env_free_list=&amp;envs[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Per-CPU part of the initialization</span></span><br><span class="line">	env_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>env_init()</code> 中调用了<code>env_init_percpu()</code> 不知道这个是干啥的。根据注释，是初始化了GDT和段描述符。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Load GDT and segment descriptors.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">env_init_percpu(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	lgdt(&amp;gdt_pd);</span><br><span class="line">	<span class="comment">// The kernel never uses GS or FS, so we leave those set to</span></span><br><span class="line">	<span class="comment">// the user data segment.</span></span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"movw %%ax,%%gs"</span> : : <span class="string">"a"</span> (GD_UD|<span class="number">3</span>))</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"movw %%ax,%%fs"</span> : : <span class="string">"a"</span> (GD_UD|<span class="number">3</span>))</span></span>;</span><br><span class="line">	<span class="comment">// The kernel does use ES, DS, and SS.  We'll change between</span></span><br><span class="line">	<span class="comment">// the kernel and user data segments as needed.</span></span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"movw %%ax,%%es"</span> : : <span class="string">"a"</span> (GD_KD))</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"movw %%ax,%%ds"</span> : : <span class="string">"a"</span> (GD_KD))</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"movw %%ax,%%ss"</span> : : <span class="string">"a"</span> (GD_KD))</span></span>;</span><br><span class="line">	<span class="comment">// Load the kernel text segment into CS.</span></span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"ljmp %0,$1f\n 1:\n"</span> : : <span class="string">"i"</span> (GD_KT))</span></span>;</span><br><span class="line">	<span class="comment">// For good measure, clear the local descriptor table (LDT),</span></span><br><span class="line">	<span class="comment">// since we don't use it.</span></span><br><span class="line">	lldt(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="env-setup-vm"><a href="#env-setup-vm" class="headerlink" title="env_setup_vm()"></a>env_setup_vm()</h3><p>初始化完 之后，因为<code>trap()</code>是下一个的暂时不用管，所以我们直接跳到<code>create_env</code>，创建这个第一个要干的肯定是分配内存,最开始要做的是分配一个页目录。这个页目录，肯定是要复制内核的一部分，因为内核那一部分，你是绝对不能动的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Initialize the kernel virtual memory layout for environment e. 初始化内核虚拟布局</span></span><br><span class="line"><span class="comment">// Allocate a page directory, set e-&gt;env_pgdir accordingly, 分配一个页目录给e-&gt;env_pgdir</span></span><br><span class="line"><span class="comment">// and initialize the kernel portion of the new environment's address space</span></span><br><span class="line"><span class="comment">// Do NOT (yet) map anything into the user portion</span></span><br><span class="line"><span class="comment">// of the environment's virtual address space.</span></span><br><span class="line"><span class="comment">//初始化内核部分，不用映射 用户部分。</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors include:</span></span><br><span class="line"><span class="comment">//	-E_NO_MEM if page directory or table could not be allocated.</span></span><br><span class="line"><span class="comment">//成功返回 0 否则返回 -E_NO_MEM</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">env_setup_vm(struct Env *e)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate a page for the page directory 分配了一个页目录</span></span><br><span class="line">	<span class="keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now, set e-&gt;env_pgdir and initialize the page directory.</span></span><br><span class="line">	<span class="comment">//现在设置 e-&gt;env_pgdir 然后初始化页面目录</span></span><br><span class="line">	<span class="comment">// Hint:</span></span><br><span class="line">	<span class="comment">//    - The VA space of all envs is identical above UTOP</span></span><br><span class="line">	<span class="comment">//	(except at UVPT, which we've set below).va 所有 envs 的虚拟地址 都是相同的在UTOP上面</span></span><br><span class="line">	<span class="comment">//	See inc/memlayout.h for permissions and layout.</span></span><br><span class="line">	<span class="comment">//	Can you use kern_pgdir as a template?  Hint: Yes. 可以用kern_pgdir做一个模板</span></span><br><span class="line">	<span class="comment">//	(Make sure you got the permissions right in Lab 2.) </span></span><br><span class="line">	<span class="comment">//    - The initial VA below UTOP is empty. 初始化 虚拟地址在 UTOP 是空的</span></span><br><span class="line">	<span class="comment">//    - You do not need to make any more calls to page_alloc. 你不需要去做任何的page_alloc</span></span><br><span class="line">	<span class="comment">//    - Note: In general, pp_ref is not maintained for </span></span><br><span class="line">	<span class="comment">//	physical pages mapped only above UTOP, but env_pgdir </span></span><br><span class="line">	<span class="comment">//	is an exception -- you need to increment env_pgdir's</span></span><br><span class="line">	<span class="comment">//	pp_ref for env_free to work correctly.</span></span><br><span class="line">	<span class="comment">//    - The functions in kern/pmap.h are handy. </span></span><br><span class="line">	<span class="comment">// 自己翻译吧，只可意会不可言传</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	p-&gt;pp_ref++;</span><br><span class="line">	e-&gt;env_pgdir=(<span class="keyword">pde_t</span> *)page2kva(p);</span><br><span class="line">	<span class="built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// UVPT maps the env's own page table read-only.  </span></span><br><span class="line">	<span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">	e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="region-alloc"><a href="#region-alloc" class="headerlink" title="region_alloc"></a>region_alloc</h3><p>分配完页目录，然后就是要给用户创建空间。只有一个页目录，肯定是不行的，你必须要给用户程序使用的空间。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Allocate len bytes of physical memory for environment env,</span></span><br><span class="line"><span class="comment">// and map it at virtual address va in the environment's address space.</span></span><br><span class="line"><span class="comment">// Does not zero or otherwise initialize the mapped pages in any way.</span></span><br><span class="line"><span class="comment">// Pages should be writable by user and kernel.</span></span><br><span class="line"><span class="comment">// Panic if any allocation attempt fails.</span></span><br><span class="line"><span class="comment">//分配len 字节的 物理空间给 用户环境env，映射他的虚拟地址在环境的地址空间，不要用任何方式初始化页面。权限是内核用户可写，出错就 panic</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">region_alloc(struct Env *e, <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="comment">// (But only if you need it for load_icode.)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Hint: It is easier to use region_alloc if the caller can pass</span></span><br><span class="line">	<span class="comment">//   'va' and 'len' values that are not page-aligned.</span></span><br><span class="line">	<span class="comment">//   You should round va down, and round (va + len) up.</span></span><br><span class="line">	<span class="comment">//   (Watch out for corner-cases!)</span></span><br><span class="line">	<span class="keyword">void</span> *start=ROUNDDOWN(va,PGSIZE),*end=ROUNDUP(va+len,PGSIZE);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">void</span> * addr=start;addr&lt;end;addr+=PGSIZE)&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">p</span>=<span class="title">page_alloc</span>(0);</span></span><br><span class="line">		<span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">			panic(<span class="string">"region alloc failed: No more page to be allocated.\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(page_insert(e-&gt;env_pgdir,p,addr, PTE_U | PTE_W)==-E_NO_MEM)&#123;</span><br><span class="line">				panic(<span class="string">"region alloc failed: page table couldn't be allocated.\n"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>写个函数之前，我们先去看看<code>trap.h</code></p>
<h3 id="load-icode"><a href="#load-icode" class="headerlink" title="load_icode"></a>load_icode</h3><p>因为目前并没有文件系统，所以我们要需要分配的堆栈，并不是来自文件加载出来的。为了方便实验，<code>JOS</code>让我们像加载操作系统一样加载这些文件。这个里面用到了<code>Trapframe</code>,我去看了看这个东西，对于某个字段是干啥的完全没有注释所以我也不知道该分析。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Set up the initial program binary, stack, and processor flags</span></span><br><span class="line"><span class="comment">// for a user process. 初始化进程的 二进制 栈 和 处理器</span></span><br><span class="line"><span class="comment">// This function is ONLY called during kernel initialization,</span></span><br><span class="line"><span class="comment">// before running the first user-mode environment.</span></span><br><span class="line"><span class="comment">//这个程序只能调用在内核初始化，在运行第一个用户模式环境</span></span><br><span class="line"><span class="comment">// This function loads all loadable segments from the ELF binary image</span></span><br><span class="line"><span class="comment">// into the environment's user memory, starting at the appropriate</span></span><br><span class="line"><span class="comment">// virtual addresses indicated in the ELF program header. 加载所有的 可装载程序 从 ELF二进制映象文件到内存，开始在适当的虚拟地址在ELF 的头部</span></span><br><span class="line"><span class="comment">// At the same time it clears to zero any portions of these segments 段中任何部分初始化为0</span></span><br><span class="line"><span class="comment">// that are marked in the program header as being mapped</span></span><br><span class="line"><span class="comment">// but not actually present in the ELF file - i.e., the program's bss section.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// All this is very similar to what our boot loader does, except the boot</span></span><br><span class="line"><span class="comment">// loader also needs to read the code from disk.  Take a look at</span></span><br><span class="line"><span class="comment">// boot/main.c to get ideas.  很像boot loader 做的，可以参考</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Finally, this function maps one page for the program's initial stack.</span></span><br><span class="line"><span class="comment">//这个函数映射一个页为了初始化堆栈</span></span><br><span class="line"><span class="comment">// load_icode panics if it encounters problems.</span></span><br><span class="line"><span class="comment">//  - How might load_icode fail?  What might be wrong with the given input?</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">load_icode(struct Env *e, <span class="keyword">uint8_t</span> *binary)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Hints:</span></span><br><span class="line">	<span class="comment">//  Load each program segment into virtual memory </span></span><br><span class="line">	<span class="comment">//  at the address specified in the ELF segment header.加载每个程序段到虚拟内存 在 具体的ELF 头文件</span></span><br><span class="line">	<span class="comment">//  You should only load segments with ph-&gt;p_type == ELF_PROG_LOAD. 只需要加载ph-&gt;p_type == ELF_PROG_LOAD</span></span><br><span class="line">	<span class="comment">//  Each segment's virtual address can be found in ph-&gt;p_va 每个段的虚拟地址可以在ph-&gt;p_va找到</span></span><br><span class="line">	<span class="comment">//  and its size in memory can be found in ph-&gt;p_memsz. 大小是 ph-&gt;p_memsz</span></span><br><span class="line">	<span class="comment">//  The ph-&gt;p_filesz bytes from the ELF binary, starting at 文件开始在binary + ph-&gt;p_offset，应该被复制到 虚拟地址 ph-&gt;p_va。</span></span><br><span class="line">	<span class="comment">//  'binary + ph-&gt;p_offset', should be copied to virtual address</span></span><br><span class="line">	<span class="comment">//  ph-&gt;p_va.  Any remaining memory bytes should be cleared to zero.其他剩下的空间初始化为0</span></span><br><span class="line">	<span class="comment">//  (The ELF header should have ph-&gt;p_filesz &lt;= ph-&gt;p_memsz.) 头部文件应该 ph-&gt;p_filesz &lt;= ph-&gt;p_memsz</span></span><br><span class="line">	<span class="comment">//  Use functions from the previous lab to allocate and map pages.</span></span><br><span class="line">	<span class="comment">//使用这个前面所写的函数</span></span><br><span class="line">	<span class="comment">//  All page protection bits should be user read/write for now. 所有页都是用户可读写的</span></span><br><span class="line">	<span class="comment">//  ELF segments are not necessarily page-aligned, but you can ELF 段可能不是页对齐。</span></span><br><span class="line">	<span class="comment">//  assume for this function that no two segments will touch</span></span><br><span class="line">	<span class="comment">//  the same virtual page.假设这个函数 不会两个段在同一个虚拟页</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//  You may find a function like region_alloc useful. 你可以发现 region_alloc是有用的</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//  Loading the segments is much simpler if you can move data</span></span><br><span class="line">	<span class="comment">//  directly into the virtual addresses stored in the ELF binary.</span></span><br><span class="line">	<span class="comment">//  So which page directory should be in force during</span></span><br><span class="line">	<span class="comment">//  this function? 如果你可以直接移动数据存到ELF 序列里面 架子段就很容易，所以 页目录应当使用在这个函数</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//  You must also do something with the program's entry point,</span></span><br><span class="line">	<span class="comment">//  to make sure that the environment starts executing there.</span></span><br><span class="line">	<span class="comment">//  What?  (See env_run() and env_pop_tf() below.)</span></span><br><span class="line">	<span class="comment">// 你必须对程序入口指针做点什么 确保 后面用的上。</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="comment">//根据，分析 首先需要做的一件事 应该是讲binary 转换成 ELF，参照bootmain。</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> * <span class="title">ELF</span>=(<span class="title">struct</span> <span class="title">Elf</span> *)<span class="title">binary</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC)panic(<span class="string">"The loaded file is not ELF format!\n"</span>);</span><br><span class="line">	ph = (struct Proghdr *) ((<span class="keyword">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">	eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">	<span class="comment">//装载 用户目录</span></span><br><span class="line">	lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line">	<span class="comment">//第二部应该是加载段到内存</span></span><br><span class="line">	<span class="keyword">for</span>(;ph&lt;eph;ph++)&#123;</span><br><span class="line">		<span class="comment">//加载条件是  ph-&gt;p_type == ELF_PROG_LOAD，地址是 ph-&gt;p_va 大小ph-&gt;p_memsz</span></span><br><span class="line">		<span class="keyword">if</span>(ph-&gt;p_type == ELF_PROG_LOAD)&#123;</span><br><span class="line">			<span class="keyword">if</span> (ph-&gt;p_filesz &gt; ph-&gt;p_memsz)</span><br><span class="line">                panic(<span class="string">"load_icode failed: p_memsz &lt; p_filesz.\n"</span>);</span><br><span class="line">			region_alloc(e, ph-&gt;p_va,ph-&gt;p_memsz);</span><br><span class="line">			<span class="comment">//复制ph-&gt;p_filesz bytes ，其他的补0</span></span><br><span class="line">			<span class="built_in">memset</span>(ph-&gt;p_va,<span class="number">0</span>,ph-&gt;p_memsz);</span><br><span class="line">			<span class="built_in">memcpy</span>(ph-&gt;p_va,binary + ph-&gt;p_offset,ph-&gt;p_filesz);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	 lcr3(PADDR(kern_pgdir));</span><br><span class="line">	<span class="comment">//最后是入口地址  这个实在 inc/trap.h 里面定义的</span></span><br><span class="line">	 e-&gt;env_tf.tf_eip = ELFHDR-&gt;e_entry;</span><br><span class="line">	<span class="comment">// Now map one page for the program's initial stack</span></span><br><span class="line">	<span class="comment">// at virtual address USTACKTOP - PGSIZE.  这个函数刚写过</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// LAB 3: Your code here. </span></span><br><span class="line">	gion_alloc(e, (<span class="keyword">void</span> *)(USTACKTOP - PGSIZE), PGSIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在写<code>enc_creat</code>之前，我们先来分析一下，我们并不需要写 <code>env_alloc</code>，这个函数你可以理解为初始化一个<code>env</code>。 我们不需要知道过分的细节，但是需要了解他做了什么。</p>
<h3 id="env-alloc"><a href="#env-alloc" class="headerlink" title="env_alloc"></a>env_alloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Allocates and initializes a new environment.</span></span><br><span class="line"><span class="comment">// On success, the new environment is stored in *newenv_store.</span></span><br><span class="line"><span class="comment">// 分配了一个新的 环境，成功 就存在了 *newenv_store</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on failure.  Errors include: 失败返回两种</span></span><br><span class="line"><span class="comment">//	-E_NO_FREE_ENV if all NENV environments are allocated</span></span><br><span class="line"><span class="comment">//	-E_NO_MEM on memory exhaustion</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">env_alloc(struct Env **newenv_store, <span class="keyword">envid_t</span> parent_id)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int32_t</span> generation;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	<span class="comment">//首先判断空闲 环境</span></span><br><span class="line">	<span class="keyword">if</span> (!(e = env_free_list))</span><br><span class="line">		<span class="keyword">return</span> -E_NO_FREE_ENV;</span><br><span class="line">	<span class="comment">//设置页目录</span></span><br><span class="line">	<span class="comment">// Allocate and set up the page directory for this environment.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = env_setup_vm(e)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Generate an env_id for this environment. 设置  env_id </span></span><br><span class="line">	generation = (e-&gt;env_id + (<span class="number">1</span> &lt;&lt; ENVGENSHIFT)) &amp; ~(NENV - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (generation &lt;= <span class="number">0</span>)	<span class="comment">// Don't create a negative env_id.</span></span><br><span class="line">		generation = <span class="number">1</span> &lt;&lt; ENVGENSHIFT;</span><br><span class="line">	e-&gt;env_id = generation | (e - envs);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set the basic status variables. 设置基础信息</span></span><br><span class="line">	e-&gt;env_parent_id = parent_id;</span><br><span class="line">	e-&gt;env_type = ENV_TYPE_USER;</span><br><span class="line">	e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">	e-&gt;env_runs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Clear out all the saved register state,</span></span><br><span class="line">	<span class="comment">// to prevent the register values</span></span><br><span class="line">	<span class="comment">// of a prior environment inhabiting this Env structure</span></span><br><span class="line">	<span class="comment">// from "leaking" into our new environment. 清空寄存器状态</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;e-&gt;env_tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(e-&gt;env_tf));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set up appropriate initial values for the segment registers.</span></span><br><span class="line">	<span class="comment">// GD_UD is the user data segment selector in the GDT, and</span></span><br><span class="line">	<span class="comment">// GD_UT is the user text segment selector (see inc/memlayout.h).</span></span><br><span class="line">	<span class="comment">// The low 2 bits of each segment register contains the</span></span><br><span class="line">	<span class="comment">// Requestor Privilege Level (RPL); 3 means user mode.  When</span></span><br><span class="line">	<span class="comment">// we switch privilege levels, the hardware does various</span></span><br><span class="line">	<span class="comment">// checks involving the RPL and the Descriptor Privilege Level</span></span><br><span class="line">	<span class="comment">// (DPL) stored in the descriptors themselves. 设置初始值</span></span><br><span class="line">	e-&gt;env_tf.tf_ds = GD_UD | <span class="number">3</span>;</span><br><span class="line">	e-&gt;env_tf.tf_es = GD_UD | <span class="number">3</span>;</span><br><span class="line">	e-&gt;env_tf.tf_ss = GD_UD | <span class="number">3</span>;</span><br><span class="line">	e-&gt;env_tf.tf_esp = USTACKTOP;</span><br><span class="line">	e-&gt;env_tf.tf_cs = GD_UT | <span class="number">3</span>;</span><br><span class="line">	<span class="comment">// You will set e-&gt;env_tf.tf_eip later.  这个很眼熟吧，就是上个函数用的，这个就是入口地址</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// commit the allocation 空闲环境 指向另一个。</span></span><br><span class="line">	env_free_list = e-&gt;env_link;</span><br><span class="line">	*newenv_store = e;</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">"[%08x] new env %08x\n"</span>, curenv ? curenv-&gt;env_id : <span class="number">0</span>, e-&gt;env_id);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="env-create"><a href="#env-create" class="headerlink" title="env_create"></a>env_create</h3><p>函数作用就是根据<code>binary</code> 创建一个<code>env</code> 。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Allocates a new env with env_alloc, loads the named elf</span></span><br><span class="line"><span class="comment">// binary into it with load_icode, and sets its env_type.</span></span><br><span class="line"><span class="comment">// This function is ONLY called during kernel initialization,</span></span><br><span class="line"><span class="comment">// before running the first user-mode environment.</span></span><br><span class="line"><span class="comment">// The new env's parent ID is set to 0.</span></span><br><span class="line"><span class="comment">// 分配一个新的env 通过env_alloc 加载elf，设置他的its env_type 这个函数只在内核初始化抵用，在跑第一个用户环境，父亲设置为  0</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">env_create(<span class="keyword">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> * <span class="title">e</span>;</span></span><br><span class="line">	<span class="keyword">int</span> r=env_alloc(&amp;e,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(r!=<span class="number">0</span>)&#123;</span><br><span class="line">		cprintf(<span class="string">"%e\n"</span>,r);</span><br><span class="line">		panic(<span class="string">"env_create:error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	load_icode(e,binary);</span><br><span class="line">	e-&gt;env_type=type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="env-run"><a href="#env-run" class="headerlink" title="env_run"></a>env_run</h3><p>这个就是真正的用户环境运行了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line"><span class="comment">// Context switch from curenv to env e. 上下文切换到 e</span></span><br><span class="line"><span class="comment">// Note: if this is the first call to env_run, curenv is NULL.</span></span><br><span class="line"><span class="comment">//如果第一个调用 curenv 是空的</span></span><br><span class="line"><span class="comment">// This function does not return.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">env_run(struct Env *e)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Step 1: If this is a context switch (a new environment is running): 如果有上下文切换</span></span><br><span class="line">	<span class="comment">//	   1. Set the current environment (if any) back to 第一步当前环境 就绪状态</span></span><br><span class="line">	<span class="comment">//	      ENV_RUNNABLE if it is ENV_RUNNING (think about</span></span><br><span class="line">	<span class="comment">//	      what other states it can be in),</span></span><br><span class="line">	<span class="comment">//	   2. Set 'curenv' to the new environment, 当前运行变成 新的环境</span></span><br><span class="line">	<span class="comment">//	   3. Set its status to ENV_RUNNING,  设置他的状态为 运行</span></span><br><span class="line">	<span class="comment">//	   4. Update its 'env_runs' counter, 更新计数</span></span><br><span class="line">	<span class="comment">//	   5. Use lcr3() to switch to its address space. 修改地址空间</span></span><br><span class="line">	<span class="comment">// Step 2: Use env_pop_tf() to restore the environment's 第二部 使用那个啥恢复环境</span></span><br><span class="line">	<span class="comment">//	   registers and drop into user mode in the</span></span><br><span class="line">	<span class="comment">//	   environment.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Hint: This function loads the new environment's state from 这个函数重新加载 新的用户转台 从啥</span></span><br><span class="line">	<span class="comment">//	e-&gt;env_tf.  Go back through the code you wrote above</span></span><br><span class="line">	<span class="comment">//	and make sure you have set the relevant parts of</span></span><br><span class="line">	<span class="comment">//	e-&gt;env_tf to sensible values. 确保 那个哈是个真确的值</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span>(curenv!=<span class="literal">NULL</span>&amp;&amp;curenv-&gt;env_status==ENV_RUNNING)&#123;</span><br><span class="line">		curenv-&gt;env_status=ENV_RUNNABLE;</span><br><span class="line">	&#125;</span><br><span class="line">	curenv=e;</span><br><span class="line">	<span class="comment">// if(&amp;curenv-&gt;env_tf==NULL)cprintf("***");</span></span><br><span class="line">	e-&gt;env_status=ENV_RUNNING;</span><br><span class="line">	e-&gt;env_runs++;</span><br><span class="line">	lcr3(PADDR(curenv-&gt;env_pgdir));</span><br><span class="line">	cprintf(<span class="string">"%x\n"</span>,curenv-&gt;env_tf.tf_eip);</span><br><span class="line">	env_pop_tf(&amp;curenv-&gt;env_tf);</span><br><span class="line">	panic(<span class="string">"env_run not yet implemented"</span>);<span class="comment">//这个注释不注释没啥影响，因为我们现在就运行了一个 env，上面那个函数已经转移了，等他再来运行这一行，说明整个操作系统已经结束了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再分析分析这个文件里面一些其他的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Frees env e and all memory it uses.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">env_free(struct Env *e)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">pte_t</span> *pt;</span><br><span class="line">	<span class="keyword">uint32_t</span> pdeno, pteno;</span><br><span class="line">	<span class="keyword">physaddr_t</span> pa;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If freeing the current environment, switch to kern_pgdir</span></span><br><span class="line">	<span class="comment">// before freeing the page directory, just in case the page</span></span><br><span class="line">	<span class="comment">// gets reused.</span></span><br><span class="line">	<span class="keyword">if</span> (e == curenv)</span><br><span class="line">		lcr3(PADDR(kern_pgdir));  <span class="comment">//切换到内核</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Note the environment's demise.</span></span><br><span class="line">	cprintf(<span class="string">"[%08x] free env %08x\n"</span>, curenv ? curenv-&gt;env_id : <span class="number">0</span>, e-&gt;env_id);</span><br><span class="line"><span class="comment">//打印信息</span></span><br><span class="line">	<span class="comment">// Flush all mapped pages in the user portion of the address space</span></span><br><span class="line">	<span class="keyword">static_assert</span>(UTOP % PTSIZE == <span class="number">0</span>); <span class="comment">//刷新所有映射</span></span><br><span class="line">	<span class="keyword">for</span> (pdeno = <span class="number">0</span>; pdeno &lt; PDX(UTOP); pdeno++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// only look at mapped page tables</span></span><br><span class="line">		<span class="keyword">if</span> (!(e-&gt;env_pgdir[pdeno] &amp; PTE_P))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// find the pa and va of the page table</span></span><br><span class="line">		pa = PTE_ADDR(e-&gt;env_pgdir[pdeno]);</span><br><span class="line">		pt = (<span class="keyword">pte_t</span>*) KADDR(pa);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// unmap all PTEs in this page table 取消所有映射</span></span><br><span class="line">		<span class="keyword">for</span> (pteno = <span class="number">0</span>; pteno &lt;= PTX(~<span class="number">0</span>); pteno++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pt[pteno] &amp; PTE_P)</span><br><span class="line">				page_remove(e-&gt;env_pgdir, PGADDR(pdeno, pteno, <span class="number">0</span>));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// free the page table itself</span></span><br><span class="line">		e-&gt;env_pgdir[pdeno] = <span class="number">0</span>;</span><br><span class="line">		page_decref(pa2page(pa));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// free the page directory 把页目录删掉</span></span><br><span class="line">	pa = PADDR(e-&gt;env_pgdir);</span><br><span class="line">	e-&gt;env_pgdir = <span class="number">0</span>;</span><br><span class="line">	page_decref(pa2page(pa));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// return the environment to the free list</span></span><br><span class="line">	e-&gt;env_status = ENV_FREE;</span><br><span class="line">	e-&gt;env_link = env_free_list;</span><br><span class="line">	env_free_list = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Frees environment e.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">env_destroy(struct Env *e)</span><br><span class="line">&#123;</span><br><span class="line">	env_free(e);</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">"Destroyed the only environment - nothing more to do!\n"</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">		monitor(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Restores the register values in the Trapframe with the 'iret' instruction.</span></span><br><span class="line"><span class="comment">// This exits the kernel and starts executing some environment's code.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This function does not return. </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">env_pop_tf(struct Trapframe *tf) <span class="comment">//这个就是跳转，</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="string">"\tmovl %0,%%esp\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="string">"\tpopal\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="string">"\tpopl %%es\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="string">"\tpopl %%ds\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="string">"\taddl $0x8,%%esp\n"</span> <span class="comment">/* skip tf_trapno and tf_errcode */</span></span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="string">"\tiret\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">		: : <span class="string">"g"</span> (tf) : <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">	panic(<span class="string">"iret failed"</span>);  <span class="comment">/* mostly to placate the compiler */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦你完成上述子函数的代码，并且在QEMU下编译运行，系统会进入用户空间，并且开始执行hello程序，直到它做出一个系统调用指令int。但是这个系统调用指令不能成功运行，因为到目前为止，JOS还没有设置相关硬件来实现从用户态向内核态的转换功能。当CPU发现，它没有被设置成能够处理这种系统调用中断时，它会触发一个保护异常，然后发现这个保护异常也无法处理，从而又产生一个错误异常，然后又发现仍旧无法解决问题，所以最后放弃，我们把这个叫做”triple fault”。通常来说，接下来CPU会复位，系统会重启。</p>
<p>　　所以我们马上要来解决这个问题，不过解决之前我们可以使用调试器来检查一下程序要进入用户模式时做了什么。使用<code>make qemu-gdb</code> 并且在 <code>env_pop_tf</code> 处设置断点，这条指令应该是即将进入用户模式之前的最后一条指令。然后进行单步调试，处理会在执行完<code>iret</code> 指令后进入用户模式。然后依旧可以看到进入用户态后执行的第一条指令了，该指令是一个<code>cmp</code>指令，开始于文件 <code>lib/entry.S</code> 中。 现在使用 <code>b *0x...</code> 设置一个断点在<code>hello</code>文件<code>（obj/user/hello.asm）</code>中的<code>sys_cputs</code>函数中的 <code>int $0x30</code> 指令处。这个<code>int</code>指令是一个系统调用，用来展示一个字符到控制台。如果你的程序运行不到这个<code>int</code>指令，说明有错误。<br>其实不用上面那么麻烦，直接运行<code>make qemu-gdb</code> 然后输入<code>c</code>指令，最终<code>make gdb</code> 会停在 <code>int $0x30</code>,然后<code>qemu</code> 会显示错误”triple fault”。</p>
<p><del>(后面大部分都是理论文字，大部分都是翻译过来的，所以直接照搬了大佬门博客里面的。英语水平不好，怕翻译了看不懂)</del></p>
<h2 id="Handling-Interrupts-and-Exceptions"><a href="#Handling-Interrupts-and-Exceptions" class="headerlink" title="Handling Interrupts and Exceptions"></a>Handling Interrupts and Exceptions</h2><p>　　到目前为止，当程序运行到第一个系统调用<code>int $0x30</code> 时，就会进入错误的状态，因为现在系统无法从用户态切换到内核态。所以你需要实现一个基本的异常/系统调用处理机制，使得内核可以从用户态转换为内核态。你应该先熟悉一下X86的异常中断机制。</p>
<h2 id="Basics-of-Protected-Control-Transfer"><a href="#Basics-of-Protected-Control-Transfer" class="headerlink" title="Basics of Protected Control Transfer"></a>Basics of Protected Control Transfer</h2><p>&emsp;异常(Exception)和中断(Interrupts)都是“受到保护的控制转移方法”，都会使处理器从用户态转移为内核态。在Intel的术语中，一个中断指的是由外部异步事件引起的处理器控制权转移，比如外部IO设备发送来的中断信号。一个异常则是由于当前正在运行的指令所带来的同步的处理器控制权的转移，比如除零溢出异常。</p>
<p>&emsp;为了能够确保这些控制的转移能够真正被保护起来，处理器的中断/异常机制通常被设计为：用户态的代码无权选择内核中的代码从哪里开始执行。处理器可以确保只有在某些条件下，才能进入内核态。在<code>X86</code>上，有两种机制配合工作来提供这种保护：</p>
<ol>
<li><p>中断向量表：处理器保证中断和异常只能够引起内核进入到一些特定的，被事先定义好的程序入口点，而不是由触发中断的程序来决定中断程序入口点。<br> &emsp;X86允许多达256个不同的中断和异常，每一个都配备一个独一无二的中断向量。一个向量指的就是0到255中的一个数。一个中断向量的值是根据中断源来决定的：不同设备，错误条件，以及对内核的请求都会产生出不同的中断和中断向量的组合。CPU将使用这个向量作为这个中断在中断向量表中的索引，这个表是由内核设置的，放在内核空间中，和<code>GDT</code>很像。通过这个表中的任意一个表项，处理器可以知道：<br><em>需要加载到<code>EIP</code>寄存器中的值，这个值指向了处理这个中断的中断处理程序的位置。
</em>需要加载到<code>CS</code>寄存器中的值，里面还包含了这个中断处理程序的运行特权级。（即这个程序是在用户态还是内核态下运行。）</p>
</li>
<li><p>任务状态段:处理器还需要一个地方来存放，当异常/中断发生时，处理器的状态，比如EIP和CS寄存器的值。这样的话，中断处理程序一会可以重新返回到原来的程序中。这段内存自然也要保护起来，不能被用户态的程序所篡改。<br>　　　　正因为如此，当一个x86处理器要处理一个中断，异常并且使运行特权级从用户态转为内核态时，它也会把它的堆栈切换到内核空间中。一个叫做 “任务状态段（TSS）”的数据结构将会详细记录这个堆栈所在的段的段描述符和地址。处理器会把<code>SS</code>，<code>ESP</code>，<code>EFLAGS</code>，<code>CS</code>，<code>EIP</code>以及一个可选错误码等等这些值压入到这个堆栈上。然后加载中断处理程序的<code>CS</code>，<code>EIP</code>值，并且设置<code>ESP</code>，<code>SS</code>寄存器指向新的堆栈。<br>　　　　尽管<code>TSS</code>非常大，并且还有很多其他的功能，但是<code>JOS</code>仅仅使用它来定义处理器从用户态转向内核态所采用的内核堆栈，由于<code>JOS</code>中的内核态指的就是特权级0，所以处理器用TSS中的<code>ESP0</code>，<code>SS0</code>字段来指明这个内核堆栈的位置，大小。</p>
<h2 id="Types-of-Exceptions-and-Interrupts"><a href="#Types-of-Exceptions-and-Interrupts" class="headerlink" title="Types of Exceptions and Interrupts　"></a>Types of Exceptions and Interrupts　</h2><p>&emsp;所有的由<code>X86</code>处理器内部产生的异常的向量值是<code>0</code>到<code>31</code>之间的整数。比如，页表错所对应的向量值是<code>14.</code>而大于<code>31</code>号的中断向量对应的是软件中断，由<code>int</code>指令生成；或者是外部中断，由外部设备生成。<br>&emsp;在这一章，我们将扩展<code>JOS</code>的功能，使它能够处理<code>0~31</code>号内部异常。在下一章会让<code>JOS</code>能够处理<code>48</code>号软件中断，主要被用来做系统调用。在<code>Lab 4</code>中会继续扩展<code>JOS</code>使它能够处理外部硬件中断，比如时钟中断。</p>
</li>
</ol>
<h2 id="An-Example"><a href="#An-Example" class="headerlink" title="An Example"></a>An Example</h2><p>让我们试一下<code>除0</code></p>
<ol>
<li>处理器会首先切换自己的堆栈，切换到由<code>TSS</code>的<code>SS0</code>，<code>ESP0</code>字段所指定的内核堆栈区，这两个字段分别存放着<code>GD_KD</code>和<code>KSTACKTOP</code>的值。</li>
<li>处理器把异常参数压入到内核堆栈中，起始于地址KSTACKTOP：<img src="https://img-blog.csdnimg.cn/20200114110147510.png" alt="在这里插入图片描述"></li>
<li>因为我们要处理的是除零异常，它的中断向量是0，处理器会读取<code>IDT</code>表中的0号表项，并且把<code>CS:EIP</code>的值设置为0号中断处理函数的地址值。 </li>
<li>中断处理函数开始执行处理中断。</li>
</ol>
<p>对于某些特定类型的x86异常，除了上面图中要保存5五个字之外，还要再压入一个字，叫做错误码。比如页错误，就是其中一个实例。当压入错误码之后，内核堆栈的状态如下：<br><img src="https://img-blog.csdnimg.cn/20200114110425770.png" alt="在这里插入图片描述"></p>
<h2 id="Nested-Exceptions-and-Interrupts"><a href="#Nested-Exceptions-and-Interrupts" class="headerlink" title="Nested Exceptions and Interrupts"></a>Nested Exceptions and Interrupts</h2><p>处理器在用户态下和内核态下都可以处理异常或中断。只有当处理器从用户态切换到内核态时，才会自动地切换堆栈，并且把一些寄存器中的原来的值压入到堆栈上，并且调用IDT指定的合适的异常处理程序。但如果处理器已经由于正在处理中断而处在内核态下时（<code>CS</code>寄存器的低两位已经都是0），此时<code>CPU</code>只会向内核堆栈压入更多的值。通过这种方式，内核就可处理嵌套中断。</p>
<p>如果处理器已经在内核态下并且遇到嵌套中断，因为它不需要切换堆栈，所以它不需要存储原来的<code>SS</code>，<code>ESP</code>寄存器的值。如果这个异常类型不压入错误码，此时内核堆栈的就像下面这个样子：<br><img src="https://img-blog.csdnimg.cn/20200114110902276.png" alt="在这里插入图片描述"><br>这里有一个重要的警告,如果处理器在内核态下接受一个异常，而且由于一些原因，比如堆栈空间不足，不能把当前的状态信息（寄存器的值）压入到内核堆栈中时，那么处理器是无法恢复到原来的状态了，它会自动重启。</p>
<h2 id="Setting-Up-the-IDT"><a href="#Setting-Up-the-IDT" class="headerlink" title="Setting Up the IDT"></a>Setting Up the IDT</h2><p><del>(又要准备干活了)</del></p>
<p>你现在应该有了建立IDT表以及JOS处理异常的基本信息。我们现在只需要开始建立表就行了。<br>是否记得<code>lab 2</code>里面的内存分布，最低的那一页就是存这个的。<br>然后我们去看看<code>inc/trap.h</code>,那个<code>kern/trap.h</code>自己看看就行了。<br><a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/s09_08.htm" target="_blank" rel="noopener">如果想知道各个中断具体是啥看这个。</a></p>
<h2 id="trap-h"><a href="#trap-h" class="headerlink" title="trap.h"></a>trap.h</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> JOS_INC_TRAP_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JOS_INC_TRAP_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Trap numbers</span></span><br><span class="line"><span class="comment">// These are processor defined:  这是各种中断  对于这些建议大家学学嵌入式，手写个CPU（我的github 上有个简单的...） 下面各种错误还是大家自行百度，我解释几个常用的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_DIVIDE     0		<span class="comment">// divide error 除0</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_DEBUG      1		<span class="comment">// debug exception </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_NMI        2		<span class="comment">// non-maskable interrupt 非屏蔽中断？？？</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_BRKPT      3		<span class="comment">// breakpoint	断点</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_OFLOW      4		<span class="comment">// overflow		溢出</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_BOUND      5		<span class="comment">// bounds check	边界检查？</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_ILLOP      6		<span class="comment">// illegal opcode	非法操作码  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_DEVICE     7		<span class="comment">// device not available 	设备不可用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_DBLFLT     8		<span class="comment">// double fault </span></span></span><br><span class="line"><span class="comment">/* #define T_COPROC  9 */</span>	<span class="comment">// reserved (not generated by recent processors)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_TSS       10		<span class="comment">// invalid task switch segment 无效任务段切换</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_SEGNP     11		<span class="comment">// segment not present 段不存在</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_STACK     12		<span class="comment">// stack exception 栈异常</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_GPFLT     13		<span class="comment">// general protection fault</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_PGFLT     14		<span class="comment">// page fault 页错误</span></span></span><br><span class="line"><span class="comment">/* #define T_RES    15 */</span>	<span class="comment">// reserved</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_FPERR     16		<span class="comment">// floating point error  浮点错误</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_ALIGN     17		<span class="comment">// aligment check 对齐检查</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_MCHK      18		<span class="comment">// machine check  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_SIMDERR   19		<span class="comment">// SIMD floating point error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// These are arbitrarily chosen, but with care not to overlap  下面可以任意选择，但是不要重叠</span></span><br><span class="line"><span class="comment">// processor defined exceptions or interrupt vectors. 应该就是 自定义 异常</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_SYSCALL   48		<span class="comment">// system call</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_DEFAULT   500		<span class="comment">// catchall</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQ_OFFSET	32	<span class="comment">// IRQ 0 corresponds to int IRQ_OFFSET 	 外部中断</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Hardware IRQ numbers. We receive these as (IRQ_OFFSET+IRQ_WHATEVER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQ_TIMER        0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQ_KBD          1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQ_SERIAL       4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQ_SPURIOUS     7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQ_IDE         14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQ_ERROR       19</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ASSEMBLER__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/types.h&gt;</span></span></span><br><span class="line"><span class="comment">//保存通用寄存器的值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PushRegs</span> &#123;</span></span><br><span class="line">	<span class="comment">/* registers as pushed by pusha */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> reg_edi;</span><br><span class="line">	<span class="keyword">uint32_t</span> reg_esi;</span><br><span class="line">	<span class="keyword">uint32_t</span> reg_ebp;</span><br><span class="line">	<span class="keyword">uint32_t</span> reg_oesp;		<span class="comment">/* Useless */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> reg_ebx;</span><br><span class="line">	<span class="keyword">uint32_t</span> reg_edx;</span><br><span class="line">	<span class="keyword">uint32_t</span> reg_ecx;</span><br><span class="line">	<span class="keyword">uint32_t</span> reg_eax;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"><span class="comment">//任务段</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PushRegs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line">	<span class="keyword">uint16_t</span> tf_es;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_padding1;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_ds;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_padding2;</span><br><span class="line">	<span class="keyword">uint32_t</span> tf_trapno;</span><br><span class="line">	<span class="comment">/* below here defined by x86 hardware   下面是x86 硬件定义的 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> tf_err;</span><br><span class="line">	<span class="keyword">uintptr_t</span> tf_eip;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_cs;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_padding3;</span><br><span class="line">	<span class="keyword">uint32_t</span> tf_eflags;</span><br><span class="line">	<span class="comment">/* below here only when crossing rings, such as from user to kernel 不知道是啥*/</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> tf_esp;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_ss;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_padding4;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !__ASSEMBLER__ */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !JOS_INC_TRAP_H */</span></span></span><br></pre></td></tr></table></figure>
<p>最后你要实现的控制流的效果如下：<br><img src="https://img-blog.csdnimg.cn/20200114115306654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODcxNDY2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">每一个中断或异常都有相应定义在<code>trapentry.S</code>中中断处理程序,<code>trap_init()</code>将用这些中断处理程序的地址初始化<code>IDT</code>。每一个处理程序都应该在堆栈上构建一个结构体<code>struct Trapframe</code>，并且调用<code>trap()</code>函数指向这个结构体，<code>trap()</code>然后处理异常/中断，给他分配一个中断处理函数。</p>
<p><code>练习4</code> 要你编辑上面说这些东西。我们跟着他走，<code>TRAPHANDLER_NOEC</code>和<code>TRAPHANDLER_NOEC</code>，我们看看是啥。</p>
<h3 id="TRAPHANDLER-NOEC和TRAPHANDLER-NOEC"><a href="#TRAPHANDLER-NOEC和TRAPHANDLER-NOEC" class="headerlink" title="TRAPHANDLER_NOEC和TRAPHANDLER_NOEC"></a>TRAPHANDLER_NOEC和TRAPHANDLER_NOEC</h3><p>在这个文件里面，也就是为每个中断创建一个函数，然后调用<code>trap()</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">###################################################################</span><br><span class="line"><span class="meta"># exceptions/interrupts</span></span><br><span class="line">###################################################################</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TRAPHANDLER defines a globally-visible function for handling a trap. 定义了一个全局可见的函数，用来处理trap</span></span><br><span class="line"><span class="comment"> * It pushes a trap number onto the stack, then jumps to _alltraps.</span></span><br><span class="line"><span class="comment"> * Use TRAPHANDLER for traps where the CPU automatically pushes an error code.</span></span><br><span class="line"><span class="comment"> * 他会把 陷阱号自推入堆栈，然后跳转 _alltraps，使用这个可以自动推入 错误码。</span></span><br><span class="line"><span class="comment"> * You shouldn't call a TRAPHANDLER function from C, but you may</span></span><br><span class="line"><span class="comment"> * need to _declare_ one in C (for instance, to get a function pointer</span></span><br><span class="line"><span class="comment"> * during IDT setup).  You can declare the function with</span></span><br><span class="line"><span class="comment"> *   void NAME();  如果你想在C里面用要声明一下</span></span><br><span class="line"><span class="comment"> * where NAME is the argument passed to TRAPHANDLER.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*  翻译过来 就是创建了一个 函数，name ，然后做了下面这些事*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRAPHANDLER(name, num)						\</span></span><br><span class="line">	.globl name;		<span class="comment">/* define global symbol for 'name' 第一全局符号name */</span>	\</span><br><span class="line">	.type name, @function;	<span class="comment">/* symbol type is function  符号类型是函数*/</span>		\</span><br><span class="line">	.align <span class="number">2</span>;		<span class="comment">/* align function definition 对齐函数定义 */</span>		\</span><br><span class="line">	name:			<span class="comment">/* function starts here 函数定义 */</span>		\</span><br><span class="line">	pushl $(num);							\</span><br><span class="line">	jmp _alltraps</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Use TRAPHANDLER_NOEC for traps where the CPU doesn't push an error code.</span></span><br><span class="line"><span class="comment"> * It pushes a 0 in place of the error code, so the trap frame has the same</span></span><br><span class="line"><span class="comment"> * format in either case.  这个 和上面的区别就是不会 压入  错误码，用0来替代了？？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRAPHANDLER_NOEC(name, num)					\</span></span><br><span class="line">	.globl name;							\</span><br><span class="line">	.type name, @function;						\</span><br><span class="line">	.align <span class="number">2</span>;							\</span><br><span class="line">	name:								\</span><br><span class="line">	pushl $<span class="number">0</span>;							\</span><br><span class="line">	pushl $(num);							\</span><br><span class="line">	jmp _alltraps</span><br></pre></td></tr></table></figure></p>
<p><code>inc/trap.h</code>已经分析过了。然后他说 我们需要实现<code>_alltraps</code>。还需要在<code>trap_init()</code> 里面实现初始化入口定义。然后<code>SETGATE</code>会帮助我们。所以我们去看看<code>STEGATE</code>干了啥.<br>由于我并不知道他在哪，所以我们用<code>grep</code>搜一下。发现在<code>mmu.h</code>里面，上次我们分析了一部分，因为后面的没有用上，我就注释了一部分。如果已经知道的了就直接跳过。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up a normal interrupt/trap gate descriptor. 设置一个正常中断陷阱入口 描述符</span></span><br><span class="line"><span class="comment">// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate. 1是trap 0是interrupt</span></span><br><span class="line">    <span class="comment">//   see section 9.6.1.3 of the i386 reference: "The difference between //看看那个啥</span></span><br><span class="line">    <span class="comment">//   an interrupt gate and a trap gate is in the effect on IF (the  //中断门和陷阱门有啥不一样在IF（中断允许的标志）上面</span></span><br><span class="line">    <span class="comment">//   interrupt-enable flag). An interrupt that vectors through an//中断向量通过 中断门重置 IF 从而组织其他中断中断当前中断。 </span></span><br><span class="line">    <span class="comment">//   interrupt gate resets IF, thereby preventing other interrupts from</span></span><br><span class="line">    <span class="comment">//   interfering with the current interrupt handler. A subsequent IRET</span></span><br><span class="line">	<span class="comment">// 然后然后用IRET 恢复。</span></span><br><span class="line">    <span class="comment">//   instruction restores IF to the value in the EFLAGS image on the</span></span><br><span class="line">    <span class="comment">//   stack. An interrupt through a trap gate does not change IF."</span></span><br><span class="line">    <span class="comment">//说的简单点，中断不能再次中断，trap 可以被中断。</span></span><br><span class="line"><span class="comment">// - sel: Code segment selector for interrupt/trap handler 代码段地址</span></span><br><span class="line"><span class="comment">// - off: Offset in code segment for interrupt/trap handler //代码段偏移</span></span><br><span class="line"><span class="comment">// - dpl: Descriptor Privilege Level - 特权等级</span></span><br><span class="line"><span class="comment">//	  the privilege level required for software to invoke //软件等级</span></span><br><span class="line"><span class="comment">//	  this interrupt/trap gate explicitly using an int instruction.//int 指令调用？</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETGATE(gate, istrap, sel, off, dpl)			\</span></span><br><span class="line">&#123;								\</span><br><span class="line">	(gate).gd_off_15_0 = (<span class="keyword">uint32_t</span>) (off) &amp; <span class="number">0xffff</span>;		\</span><br><span class="line">	(gate).gd_sel = (sel);					\</span><br><span class="line">	(gate).gd_args = <span class="number">0</span>;					\</span><br><span class="line">	(gate).gd_rsv1 = <span class="number">0</span>;					\</span><br><span class="line">	(gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;	\</span><br><span class="line">	(gate).gd_s = <span class="number">0</span>;					\</span><br><span class="line">	(gate).gd_dpl = (dpl);					\</span><br><span class="line">	(gate).gd_p = <span class="number">1</span>;					\</span><br><span class="line">	(gate).gd_off_31_16 = (<span class="keyword">uint32_t</span>) (off) &gt;&gt; <span class="number">16</span>;		\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set up a call gate descriptor.  //建立呼叫门描述？？？ 和上面好像没啥差距，就是少了个istrap</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETCALLGATE(gate, sel, off, dpl)           	        \</span></span><br><span class="line">&#123;								\</span><br><span class="line">	(gate).gd_off_15_0 = (<span class="keyword">uint32_t</span>) (off) &amp; <span class="number">0xffff</span>;		\</span><br><span class="line">	(gate).gd_sel = (sel);					\</span><br><span class="line">	(gate).gd_args = <span class="number">0</span>;					\</span><br><span class="line">	(gate).gd_rsv1 = <span class="number">0</span>;					\</span><br><span class="line">	(gate).gd_type = STS_CG32;				\</span><br><span class="line">	(gate).gd_s = <span class="number">0</span>;					\</span><br><span class="line">	(gate).gd_dpl = (dpl);					\</span><br><span class="line">	(gate).gd_p = <span class="number">1</span>;					\</span><br><span class="line">	(gate).gd_off_31_16 = (<span class="keyword">uint32_t</span>) (off) &gt;&gt; <span class="number">16</span>;		\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面就是告诉你<code>_alltraps</code> 要实现啥。我们还是先实现第一个<code>trapentry.S</code>.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lab 3: Your code here for generating entry points for the different traps.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/* 我现在也不知道为啥这个是这个  那个是那个*/</span></span><br><span class="line">TRAPHANDLER_NOEC(t_divide, T_DIVIDE)</span><br><span class="line">TRAPHANDLER_NOEC(t_debug, T_DEBUG)</span><br><span class="line">TRAPHANDLER_NOEC(t_nmi, T_NMI)</span><br><span class="line">TRAPHANDLER_NOEC(t_brkpt, T_BRKPT)</span><br><span class="line">TRAPHANDLER_NOEC(t_oflow, T_OFLOW)</span><br><span class="line">TRAPHANDLER_NOEC(t_bound, T_BOUND)</span><br><span class="line">TRAPHANDLER_NOEC(t_illop, T_ILLOP)</span><br><span class="line">TRAPHANDLER_NOEC(t_device, T_DEVICE)</span><br><span class="line">TRAPHANDLER(t_dblflt, T_DBLFLT)</span><br><span class="line">TRAPHANDLER(t_tss, T_TSS)</span><br><span class="line">TRAPHANDLER(t_segnp, T_SEGNP)</span><br><span class="line">TRAPHANDLER(t_stack, T_STACK)</span><br><span class="line">TRAPHANDLER(t_gpflt, T_GPFLT)</span><br><span class="line">TRAPHANDLER(t_pgflt, T_PGFLT)</span><br><span class="line">TRAPHANDLER_NOEC(t_fperr, T_FPERR)</span><br><span class="line">TRAPHANDLER(t_align, T_ALIGN)</span><br><span class="line">TRAPHANDLER_NOEC(t_mchk, T_MCHK)</span><br><span class="line">TRAPHANDLER_NOEC(t_simderr, T_SIMDERR)</span><br><span class="line"></span><br><span class="line">TRAPHANDLER_NOEC(t_syscall, T_SYSCALL)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lab 3: Your code here for _alltraps</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> _alltraps:</span><br><span class="line"> 	pushl %ds</span><br><span class="line">	pushl %es</span><br><span class="line">	pushal <span class="comment">/* push all general registers */</span></span><br><span class="line"></span><br><span class="line">	movl $GD_KD, %eax</span><br><span class="line">	movw %ax, %ds</span><br><span class="line">	movw %ax, %es</span><br><span class="line"></span><br><span class="line">	push %esp</span><br><span class="line">	call trap</span><br></pre></td></tr></table></figure></p>
<p>然后 <code>trap_init()</code>；<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_divide</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_debug</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_nmi</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_brkpt</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_oflow</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_bound</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_illop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_device</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_dblflt</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_tss</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_segnp</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_stack</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_gpflt</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_pgflt</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_fperr</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_align</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_mchk</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_simderr</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_syscall</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">trap_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Segdesc</span> <span class="title">gdt</span>[];</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	SETGATE(idt[T_DIVIDE], <span class="number">0</span>, GD_KT, t_divide, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_DEBUG], <span class="number">0</span>, GD_KT, t_debug, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_NMI], <span class="number">0</span>, GD_KT, t_nmi, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_BRKPT], <span class="number">0</span>, GD_KT, t_brkpt, <span class="number">3</span>);</span><br><span class="line">	SETGATE(idt[T_OFLOW], <span class="number">0</span>, GD_KT, t_oflow, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_BOUND], <span class="number">0</span>, GD_KT, t_bound, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_ILLOP], <span class="number">0</span>, GD_KT, t_illop, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_DEVICE], <span class="number">0</span>, GD_KT, t_device, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_DBLFLT], <span class="number">0</span>, GD_KT, t_dblflt, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_TSS], <span class="number">0</span>, GD_KT, t_tss, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_SEGNP], <span class="number">0</span>, GD_KT, t_segnp, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_STACK], <span class="number">0</span>, GD_KT, t_stack, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_GPFLT], <span class="number">0</span>, GD_KT, t_gpflt, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_PGFLT], <span class="number">0</span>, GD_KT, t_pgflt, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_FPERR], <span class="number">0</span>, GD_KT, t_fperr, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_ALIGN], <span class="number">0</span>, GD_KT, t_align, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_MCHK], <span class="number">0</span>, GD_KT, t_mchk, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_SIMDERR], <span class="number">0</span>, GD_KT, t_simderr, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_SYSCALL], <span class="number">0</span>, GD_KT, t_syscall, <span class="number">3</span>);</span><br><span class="line">	<span class="comment">// Per-CPU setup </span></span><br><span class="line">	trap_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用这个可以过了，但是我看到一个非常骚的操作，也就是<code>挑战</code>.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRAPHANDLER(name, num, ec, user)						\</span></span><br><span class="line">.text;                                          \</span><br><span class="line">	.globl name;		<span class="comment">/* define global symbol for 'name' */</span>	\</span><br><span class="line">	.type name, @function;	<span class="comment">/* symbol type is function */</span>		\</span><br><span class="line">	.align <span class="number">2</span>;		<span class="comment">/* align function definition */</span>		\</span><br><span class="line">	name:			<span class="comment">/* function starts here */</span>		\</span><br><span class="line">    .<span class="keyword">if</span> ec==<span class="number">0</span>;                              \</span><br><span class="line">        pushl $<span class="number">0</span>;                           \</span><br><span class="line">    .endif;                                \</span><br><span class="line">	pushl $(num);							\</span><br><span class="line">	jmp _alltraps;                          \</span><br><span class="line">.data;                                       \</span><br><span class="line">    .<span class="keyword">long</span> num, name, user</span><br><span class="line">.data </span><br><span class="line">    .globl trapEntry</span><br><span class="line">    trapEntry:</span><br><span class="line">.text</span><br><span class="line">TRAPHANDLER(trapEntry0, T_DIVIDE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">TRAPHANDLER(trapEntry1, T_DEBUG, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">TRAPHANDLER(trapEntry2, T_NMI, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">TRAPHANDLER(trapEntry3, T_BRKPT, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">TRAPHANDLER(trapEntry4, T_OFLOW, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">TRAPHANDLER(trapEntry5, T_BOUND, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">TRAPHANDLER(trapEntry6, T_ILLOP, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">TRAPHANDLER(trapEntry7, T_DEVICE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">TRAPHANDLER(trapEntry8, T_DBLFLT, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">TRAPHANDLER(trapEntry10, T_TSS, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">TRAPHANDLER(trapEntry11, T_SEGNP, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">TRAPHANDLER(trapEntry12, T_STACK, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">TRAPHANDLER(trapEntry13, T_GPFLT, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">TRAPHANDLER(trapEntry14, T_PGFLT, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">TRAPHANDLER(trapEntry16, T_FPERR, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">TRAPHANDLER(trapEntry17, T_ALIGN, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">TRAPHANDLER(trapEntry18, T_MCHK, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">TRAPHANDLER(trapEntry19, T_SIMDERR, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//TRAPHANDLER(trapEntry20, T_SYSCALL, 1, 3);</span></span><br><span class="line">.data</span><br><span class="line">    .<span class="keyword">long</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lab 3: Your code here for _alltraps</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.text</span><br><span class="line">_alltraps:</span><br><span class="line">    pushl %ds</span><br><span class="line">    pushl %es</span><br><span class="line">    pushal   <span class="comment">/* push all general registers */</span></span><br><span class="line">    movw $GD_KD, %ax</span><br><span class="line">    movw %ax, %ds </span><br><span class="line">    movw %ax, %es</span><br><span class="line">    pushl %esp</span><br><span class="line">    call trap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">trap_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Segdesc</span> <span class="title">gdt</span>[];</span></span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">long</span> trapEntry[][<span class="number">3</span>];</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// trapEntry[][0]: interrupt/exception vector</span></span><br><span class="line">    <span class="comment">// trapEntry[][1]: interrupt/exception handler trapEntry point</span></span><br><span class="line">    <span class="comment">// trapEntry[][2]: DPL</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; trapEntry[i][<span class="number">1</span>] != <span class="number">0</span>; i++ )</span><br><span class="line">		SETGATE(idt[trapEntry[i][<span class="number">0</span>]], <span class="number">0</span>, GD_KT, trapEntry[i][<span class="number">1</span>], trapEntry[i][<span class="number">2</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Per-CPU setup </span></span><br><span class="line">	trap_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>神仙写法，看不懂，但是大致能理解啥意思。<br>骚不过，骚不过，真的骚不过。</p>
<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>第一个没有必要回答了吧。不同中断处理不同。<br>第二个问题，好像问<code>user/softint</code>为啥会产生 <code>trap 13</code> 中断。<br>查看<code>user/softint.c</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// buggy program - causes an illegal software interrupt</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">umain(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"int $14"</span>)</span></span>;	<span class="comment">// page fault</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用<code>int $14</code>产生了一个软中断。当异常或中断是由<code>int n</code>,<code>int 3</code>,<code>int</code> 0指令产生时，处理器才会检查中断或陷阱门的<code>DPL</code>。此时<code>CPL</code>数值上必须小于或等于<code>DPL</code>。这个限制可以防止特权级为3的应用程序使用软件中断访问重要的异常处理过程。当用户级使用软件中断时会引发一个<code>General Protection Exception</code>，即<code>trap 13</code>。</p>
<h2 id="Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls"><a href="#Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls" class="headerlink" title="Part B: Page Faults, Breakpoints Exceptions, and System Calls"></a>Part B: Page Faults, Breakpoints Exceptions, and System Calls</h2><p>我们现在已经有了处理一部分中断的能力了，然我们来看看他做了啥。在中断最后一个函数<code>_alltraps</code>调用了<code>trap()</code>,然后我们去了<code>kern/trap()</code>里面。我们来分析分析。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">trap(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// The environment may have set DF and some versions</span></span><br><span class="line">	<span class="comment">// of GCC rely on DF being clear CLD 清除DF 复位 干啥的也不知道</span></span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"cld"</span> ::: <span class="string">"cc"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check that interrupts are disabled.  If this assertion</span></span><br><span class="line">	<span class="comment">// fails, DO NOT be tempted to fix it by inserting a "cli" in</span></span><br><span class="line">	<span class="comment">// the interrupt path. 看中断有没有关了</span></span><br><span class="line">	assert(!(read_eflags() &amp; FL_IF));<span class="comment">//检查EFLAGS寄存器的IF标志位是否置0，即忽略可屏蔽的外部中断</span></span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">"Incoming TRAP frame at %p\n"</span>, tf);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="number">3</span>) == <span class="number">3</span>) &#123;<span class="comment">//if语句判断TrapFrame中的cs寄存器的CPL是否等于3，即是否是从用户态触发的中断</span></span><br><span class="line">		<span class="comment">//如果从用户态触发的中断，检查当前进程是否存在，这个应该是检查monitor下是不能出现中断的，然后更新当前进程的env_tf域，并最终将tf指针更新为进程的env_tf域的指针，这么做的原因会在下一篇文章[启动用户进程，产生中断、系统调用的过程分析]中说明</span></span><br><span class="line">		<span class="comment">// Trapped from user mode.</span></span><br><span class="line">		assert(curenv);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Copy trap frame (which is currently on the stack)</span></span><br><span class="line">		<span class="comment">// into 'curenv-&gt;env_tf', so that running the environment</span></span><br><span class="line">		<span class="comment">// will restart at the trap point.</span></span><br><span class="line">		curenv-&gt;env_tf = *tf;</span><br><span class="line">		<span class="comment">// The trapframe on the stack should be ignored from here on.</span></span><br><span class="line">		tf = &amp;curenv-&gt;env_tf;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Record that tf is the last real trapframe so</span></span><br><span class="line">	<span class="comment">// print_trapframe can print some additional information.</span></span><br><span class="line">	<span class="comment">//更新last_tf</span></span><br><span class="line">	last_tf = tf;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Dispatch based on what type of trap occurred</span></span><br><span class="line">	<span class="comment">//于发生的中断的类型进行分发。</span></span><br><span class="line">	trap_dispatch(tf);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Return to the current environment, which should be running.</span></span><br><span class="line">	<span class="comment">//回到进程的用户态</span></span><br><span class="line">	assert(curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING);</span><br><span class="line">	env_run(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是说 ，我们在 <code>trap_dispatch()</code>对中断进行了分配。</p>
<h3 id="Handling-Page-Faults"><a href="#Handling-Page-Faults" class="headerlink" title="Handling Page Faults"></a>Handling Page Faults</h3><p>缺页故障的中断向量为<code>14(T_PGFLT)</code>是一个很重要的异常，因为我们在后续的实验中，非常依赖于能够处理缺页中断的能力。当缺页中断发生时，系统会把引起中断的线性地址存放到控制寄存器<code>CR2</code>中。在<code>trap.c</code>中，已经提供了一个能够处理这种缺页异常的函数<code>page_fault_handler()</code>。<br>所以我们就要分配到这个函数。这个<code>if else</code> 或者<code>switch</code> 判断一下就行，没啥说的不需要先做任何操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(tf-&gt;tf_trapno) &#123;</span><br><span class="line">    <span class="keyword">case</span> (T_PGFLT):</span><br><span class="line">        page_fault_handler(tf);</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p>
<p>就这样就行了。接着我们去看看 <code>page_fault_handler()</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_fault_handler(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> fault_va;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read processor's CR2 register to find the faulting address</span></span><br><span class="line">    fault_va = rcr2();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle kernel-mode page faults.</span></span><br><span class="line">        <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="keyword">if</span>(tf-&gt;tf_cs &amp;&amp; <span class="number">0x01</span> == <span class="number">0</span>) &#123; <span class="comment">//发生在内核态 就报错，因为如果是内核态出错，说明内核出问题了</span></span><br><span class="line">        panic(<span class="string">"page_fault in kernel mode, fault address %d\n"</span>, fault_va);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// We've already handled kernel-mode exceptions, so if we get here,</span></span><br><span class="line">    <span class="comment">// the page fault happened in user mode.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destroy the environment that caused the fault.</span></span><br><span class="line">    <span class="comment">//如果是用户态，就删除这个进程</span></span><br><span class="line">    cprintf(<span class="string">"用户态内存出错 ：[%08x] user fault va %08x ip %08x\n"</span>,</span><br><span class="line">        curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">    print_trapframe(tf);</span><br><span class="line">    env_destroy(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>后面还会继续完善，当我们完成系统调用</p>
<h3 id="The-Breakpoint-Exception"><a href="#The-Breakpoint-Exception" class="headerlink" title="The Breakpoint Exception"></a>The Breakpoint Exception</h3><p>断点异常的中断向量为<code>3(T_BRKPT)</code>，这个异常可以让调试器能够给程序加上断点。加断点的基本原理就是把要加断点的语句用一个<code>1</code>字节的<code>INT 3</code>软件中断指令替换，执行到<code>INT 3</code>时，会触发软中断。在<code>JOS</code>中，我们将通过把这个异常转换成一个伪系统调用，这样的话任何用户环境都可以使用这个伪系统调用来触发<code>JOS</code> <code>kernel monitor</code>。如果将<code>JOS</code> <code>kernel monitor</code>当做原始的调试器的话，断点异常的这种用法实际上是合理的。<code>lib/panic.c</code>中<code>panic()</code>函数的用户态实现就是在展示<code>panic</code>信息之后，调用<code>int 3</code>。</p>
<p>这个我也每个搞懂，为啥是调用<code>monitor</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> (T_BRKPT):</span><br><span class="line">    monitor(tf);        </span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>后面的挑战，是要我们实现，单步调试啥的。我不会告辞。</p>
<h2 id="Question-1"><a href="#Question-1" class="headerlink" title="Question"></a>Question</h2><ol>
<li>问你为啥运行<code>breakpoint</code>(怎么运行这个，前面有个练习是说了 <code>run-name</code>)可以是<code>General Protection</code>  也可以是是<code>Breakpoint</code>.这个是由<code>trap_init</code> 初始化的时候做的。和练习二是一样的问题。<code>SETGATE(idt[T_BRKPT], 0, GD_KT, t_brkpt, 3);</code>把最后这个<code>3</code> 换成<code>0</code>，你再跑一下就知道为啥了。<code>DPL</code>字段代表的含义是段描述符优先级<code>（Descriptor Privileged Level）</code>，如果我们想要当前执行的程序能够跳转到这个描述符所指向的程序哪里继续执行的话，有个要求，就是要求当前运行程序的<code>CPL</code>，<code>RPL</code>的最大值需要小于等于<code>DPL</code>，否则就会出现优先级低的代码试图去访问优先级高的代码的情况，就会触发<code>general protection exception</code>。那么我们的测试程序首先运行于用户态，它的<code>CPL</code>为<code>3</code>，当异常发生时，它希望去执行 <code>int 3</code>指令，这是一个系统级别的指令，用户态命令的<code>CPL</code>一定大于 <code>int 3</code> 的<code>DPL</code>，所以就会触发<code>general protection exception</code>，但是如果把<code>IDT</code>这个表项的<code>DPL</code>设置为3时，就不会出现这样的现象了，这时如果再出现异常，肯定是因为我们还没有编写处理<code>break point exception</code>的程序所引起的，所以是<code>break point exception</code>。   简单来说，就是<code>breakpoint</code>假如设置在内核态，用户态就需要保护一下，进入内核态。</li>
<li>这个和上面差不多。<h2 id="System-calls"><a href="#System-calls" class="headerlink" title="System calls"></a>System calls</h2>用户程序通过系统调用让内核帮它做事。当用户程序触发系统调用，处理器进入内核态。处理器和内核合作保存该用户程序当前的状态，然后由内核将执行相应的代码完成系统调用，最终回到用户程序继续执行。而用户程序到底是如何引起内核的注意，以及它如何说明它希望操作系统做什么事情的方法是有很多不同的实现方式的。</li>
</ol>
<p>在<code>JOS</code>内核中，我们会采用<code>int</code>指令触发一个处理器的中断。特别的，我们用<code>int $0x30</code>来代表系统调用中断。注意，中断<code>0x30</code>不是通过硬件产生的，应该允许用户代码能够产生<code>0x30</code>中断。</p>
<p>应用程序会把系统调用号以及系统调用的参数放到寄存器中。通过这种方法，内核就不需要去查询用户程序的堆栈或指令流了。系统调用号存放到<code>%eax</code>中，参数则存放在<code>%edx</code>,<code>%ecx</code>,<code>%ebx</code>,<code>%edi</code>, 和 <code>%esi</code> 中。内核会把返回值送到<code>%eax</code>中。在<code>lib/syscall.c</code>中的<code>syscall()</code>函数就是触发一个系统调用的代码。不用说了，我们先去看看。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// System call stubs.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 来自一个大佬</span></span><br><span class="line"><span class="comment">* 在JOS中所有系统调用通过syscall这个函数进行：执行int T_SYSCALL，把函数参数存入若干指定的寄存器</span></span><br><span class="line"><span class="comment">* 并指定函数返回值返回到寄存器ax中</span></span><br><span class="line"><span class="comment">* 用第一个参数num来确定到底是哪个系统调用</span></span><br><span class="line"><span class="comment">* 参数num == SYS_cputs，check == 0，a1 == b-&gt;buf， a2 == b-&gt;idx，剩下a3、a4、a5都为0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int32_t</span></span><br><span class="line">syscall(<span class="keyword">int</span> num, <span class="keyword">int</span> check, <span class="keyword">uint32_t</span> a1, <span class="keyword">uint32_t</span> a2, <span class="keyword">uint32_t</span> a3, <span class="keyword">uint32_t</span> a4, <span class="keyword">uint32_t</span> a5)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> ret;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"int %1\n"</span>            <span class="comment">//汇编指令模板，%1是占位符，对应后面的T_SYSCALL</span></span></span></span><br><span class="line"><span class="function"><span class="params">                 : <span class="string">"=a"</span> (ret)          <span class="comment">//=表示在汇编里只能改变该C变量的值，而不能取它的值</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="comment">//ret值与%ax相联系，即指令执行完后ax的值存入变量ret</span></span></span></span><br><span class="line"><span class="function"><span class="params">                 : <span class="string">"i"</span> (T_SYSCALL),    <span class="comment">//中断向量T_SYSCALL，是立即数</span></span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="string">"a"</span> (num),          <span class="comment">//输入参数num，指令执行前先将num变量的值存入%ax</span></span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="string">"d"</span> (a1),           <span class="comment">//输入参数a1，指令执行前先将a1变量的值存入%dx</span></span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="string">"c"</span> (a2),           <span class="comment">//参数a2存入%cx</span></span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="string">"b"</span> (a3),           <span class="comment">//参数a3存入%bx</span></span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="string">"D"</span> (a4),           <span class="comment">//参数a4存入%di</span></span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="string">"S"</span> (a5),           <span class="comment">//参数a5存入%si</span></span></span></span><br><span class="line"><span class="function"><span class="params">                 : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;    <span class="comment">//向gcc声明在这条汇编语言执行后，标志寄存器eflags和内存可能发生改变</span></span><br><span class="line">                                       <span class="comment">//加入“memory”，告诉GCC内存已经被修改，GCC得知这个信息后， </span></span><br><span class="line">                                       <span class="comment">//就会在这段指令之前，插入必要的指令将前面因为优化缓存到寄存器中</span></span><br><span class="line">                                       <span class="comment">//的变量值先写回内存，如果以后又要使用这些变量再重新读取。</span></span><br><span class="line">    <span class="keyword">if</span>(check &amp;&amp; ret &gt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"syscall %d returned %d (&gt; 0)"</span>, num, ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面是各个函数。 </span></span><br><span class="line"><span class="comment">//输出？？ 在控制台输入输出 是要进入内核态的</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">sys_cputs(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	syscall(SYS_cputs, <span class="number">0</span>, (<span class="keyword">uint32_t</span>)s, len, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取？？？</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">sys_cgetc(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> syscall(SYS_cgetc, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除？？？</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">sys_env_destroy(<span class="keyword">envid_t</span> envid)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> syscall(SYS_env_destroy, <span class="number">1</span>, envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取id？？？</span></span><br><span class="line"><span class="keyword">envid_t</span></span><br><span class="line">sys_getenvid(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	 <span class="keyword">return</span> syscall(SYS_getenvid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看完之后来做<code>练习7</code>，那个啥，让我们去把这个加入异常，我们原本就已经加入进去了，不用管。后面我就看不懂了…，我发现系统内核里面还有个<code>kern/syscall.c</code>这个是干啥的。到底调用哪个。。。别人说<code>kern/syscall.c</code>是外壳，但是我个人感觉<code>inc/syscall.c</code>才是。我觉得应该是<code>inc/syscall.c</code>调用了<code>kern/syscal.c</code>不知道对不对，我单步调试，并查看<code>hello.asm</code>文件其中调用了<code>sys_getenvid</code> 。将断点打到<code>0x800b15</code>可以看见。<br>要在<code>lib/libmain.c</code>里面调用<code>sys_getenvid</code>。先不用管这个是啥，下个实验会讲，先把这个添进去调试。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">libmain(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// set thisenv to point at our Env structure in envs[].</span></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    thisenv = &amp;envs[ENVX(sys_getenvid())];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save the name of the program so that panic() can use it</span></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">0</span>)</span><br><span class="line">        binaryname = argv[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call user main routine</span></span><br><span class="line">    umain(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exit gracefully</span></span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">800b</span>15:	<span class="number">55</span>                   	push   %ebp</span><br><span class="line"> <span class="number">800b</span>16:	<span class="number">89</span> e5                	mov    %esp,%ebp</span><br><span class="line"> <span class="number">800b</span>18:	<span class="number">57</span>                   	push   %edi</span><br><span class="line"> <span class="number">800b</span>19:	<span class="number">56</span>                   	push   %esi</span><br><span class="line"> <span class="number">800b</span>1a:	<span class="number">53</span>                   	push   %ebx</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The last clause tells the assembler that this can</span></span><br><span class="line"><span class="comment">// potentially change the condition codes and arbitrary</span></span><br><span class="line"><span class="comment">// memory locations.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"int %1\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">800b</span>1b:	ba <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%edx</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">800b</span>20:	b8 <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x2</span>,%eax</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">800b</span>25:	<span class="number">89</span> d1                	mov    %edx,%ecx</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">800b</span>27:	<span class="number">89</span> d3                	mov    %edx,%ebx</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">800b</span>29:	<span class="number">89</span> d7                	mov    %edx,%edi</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">800b</span>2b:	<span class="number">89</span> d6                	mov    %edx,%esi</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">800b</span>2d:	cd <span class="number">30</span>                	<span class="keyword">int</span>    $<span class="number">0x30</span></span></span></span><br></pre></td></tr></table></figure>
<p>能够明显的看见调用额 <code>int30</code>,所以应该是 用户通过<code>inc/syscall.c</code>进行系统调用。<br>后面就比较简单了。<br>前面也已经提示你了，所以我们直接调用就可以了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> (T_SYSCALL):</span><br><span class="line">    ret_code = syscall(</span><br><span class="line">            tf-&gt;tf_regs.reg_eax,</span><br><span class="line">            tf-&gt;tf_regs.reg_edx,</span><br><span class="line">            tf-&gt;tf_regs.reg_ecx,</span><br><span class="line">            tf-&gt;tf_regs.reg_ebx,</span><br><span class="line">            tf-&gt;tf_regs.reg_edi,</span><br><span class="line">            tf-&gt;tf_regs.reg_esi);</span><br><span class="line">    tf-&gt;tf_regs.reg_eax = ret_code;</span><br></pre></td></tr></table></figure></p>
<p>在<code>sysycall</code>里面判断信号,分别调用哪几个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatches to the correct kernel function, passing the arguments.</span></span><br><span class="line"><span class="keyword">int32_t</span></span><br><span class="line">syscall(<span class="keyword">uint32_t</span> syscallno, <span class="keyword">uint32_t</span> a1, <span class="keyword">uint32_t</span> a2, <span class="keyword">uint32_t</span> a3, <span class="keyword">uint32_t</span> a4, <span class="keyword">uint32_t</span> a5)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Call the function corresponding to the 'syscallno' parameter.</span></span><br><span class="line">    <span class="comment">// Return any appropriate return value.</span></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//    panic("syscall not implemented");</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (syscallno) &#123;</span><br><span class="line">        <span class="keyword">case</span> (SYS_cputs):</span><br><span class="line">            sys_cputs((<span class="keyword">const</span> <span class="keyword">char</span> *)a1, a2);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> (SYS_cgetc):</span><br><span class="line">            <span class="keyword">return</span> sys_cgetc();</span><br><span class="line">        <span class="keyword">case</span> (SYS_getenvid):</span><br><span class="line">            <span class="keyword">return</span> sys_getenvid();</span><br><span class="line">        <span class="keyword">case</span> (SYS_env_destroy):</span><br><span class="line">            <span class="keyword">return</span> sys_env_destroy(a1);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家多用<code>gdb</code> 调试自己查看程序运行过程，这样可以理解更快。</p>
<p>挑战我就不看了，一般都是做不出来的，主要是没时间查看相关资料。</p>
<h2 id="User-mode-startup"><a href="#User-mode-startup" class="headerlink" title="User-mode startup"></a>User-mode startup</h2><p>上一个实验已经把代码给了，最后那一块如果好好理解了的话，这个基本上就能直接过了。<br>用户程序真正开始运行的地方是在<code>lib/entry.S</code>文件中。该文件中，首先会进行一些设置，然后就会调用<code>lib/libmain.c</code> 文件中的 <code>libmain()</code> 函数。你首先要修改一下 <code>libmain()</code> 函数，使它能够初始化全局指针 <code>thisenv</code>，让它指向当前用户环境的 Env 结构体。<br>然后 <code>libmain()</code> 函数就会调用 <code>umain</code>，这个 <code>umain</code> 程序恰好是 <code>user/hello.c</code> 中被调用的函数。在之前的实验中我们发现，<code>hello.c</code>程序只会打印 <code>hello, world</code> 这句话，然后就会报出 <code>page fault</code> 异常，原因就是 <code>thisenv-&gt;env_id</code> 这条语句。现在你已经正确初始化了这个 <code>thisenv</code>的值，再次运行就应该不会报错了。</p>
<p>不理解的可以继续单步调试。断点打在<code>f0103003</code></p>
<h2 id="Page-faults-and-memory-protection"><a href="#Page-faults-and-memory-protection" class="headerlink" title="Page faults and memory protection"></a>Page faults and memory protection</h2><p>这个练习，我们已经做了一点了，前那个函数分配<code>page_fault_handler</code>的时候我已经把<code>page_fault_handler</code> 完善了。这里就是告诉你 内核如果缺页，说明内核出问题了，不能继续运行了，必须报错panic。如果是用户能解决就解决，解决不了就删除。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_fault_handler(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> fault_va;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read processor's CR2 register to find the faulting address</span></span><br><span class="line">    fault_va = rcr2();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle kernel-mode page faults.</span></span><br><span class="line">        <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="keyword">if</span>(tf-&gt;tf_cs &amp;&amp; <span class="number">0x01</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">"page_fault in kernel mode, fault address %d\n"</span>, fault_va);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// We've already handled kernel-mode exceptions, so if we get here,</span></span><br><span class="line">    <span class="comment">// the page fault happened in user mode.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destroy the environment that caused the fault.</span></span><br><span class="line">    cprintf(<span class="string">"[%08x] user fault va %08x ip %08x\n"</span>,</span><br><span class="line">        curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">    print_trapframe(tf);</span><br><span class="line">    env_destroy(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后根据题目的要求，我们还要继续完善 kern/pmap.c 文件中的 user_mem_assert , user_mem_check 函数，通过观察 user_mem_assert 函数我们发现，它调用了 user_mem_check 函数。而 user_mem_check 函数的功能是检查一下当前用户态程序是否有对虚拟地址空间 [va, va+len] 的 perm| PTE_P 访问权限。<br>自然我们要做的事情应该是，先找到这个虚拟地址范围对应于当前用户态程序的页表中的页表项，然后再去看一下这个页表项中有关访问权限的字段，是否包含 perm | PTE_P，只要有一个页表项是不包含的，就代表程序对这个范围的虚拟地址没有 perm|PTE_P 的访问权限。以上就是这段代码的大致思想。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个函数分析 先挖个坑，做下个实验之前，来填一下。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Check that an environment is allowed to access the range of memory</span></span><br><span class="line"><span class="comment">// [va, va+len) with permissions 'perm | PTE_P'. 检查内存权限</span></span><br><span class="line"><span class="comment">// Normally 'perm' will contain PTE_U at least, but this is not required. 权限至少是PTE_u</span></span><br><span class="line"><span class="comment">// 'va' and 'len' need not be page-aligned; you must test every page that</span></span><br><span class="line"><span class="comment">// contains any of that range.  You will test either 'len/PGSIZE',</span></span><br><span class="line"><span class="comment">// 'len/PGSIZE + 1', or 'len/PGSIZE + 2' pages.</span></span><br><span class="line"><span class="comment">// 这个地方告诉你 ，va 和len 肯能不是页对齐的， 需要你搞一下。</span></span><br><span class="line"><span class="comment">// A user program can access a virtual address if (1) the address is below</span></span><br><span class="line"><span class="comment">// ULIM, and (2) the page table gives it permission.  These are exactly</span></span><br><span class="line"><span class="comment">// the tests you should implement here.</span></span><br><span class="line"><span class="comment">// 地址 应该在ULIM之下 权限应该对</span></span><br><span class="line"><span class="comment">// If there is an error, set the 'user_mem_check_addr' variable to the first</span></span><br><span class="line"><span class="comment">// erroneous virtual address.  如果出错了 把  user_mem_check_addr地址指向第一个出错的</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 if the user program can access this range of addresses,</span></span><br><span class="line"><span class="comment">// and -E_FAULT otherwise.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">user_mem_check(struct Env *env, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="keyword">char</span> * end = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> * start = <span class="literal">NULL</span>;</span><br><span class="line">    start = ROUNDDOWN((<span class="keyword">char</span> *)va, PGSIZE);   <span class="comment">//这个地方是页对齐</span></span><br><span class="line">    end = ROUNDUP((<span class="keyword">char</span> *)(va + len), PGSIZE);</span><br><span class="line">    <span class="keyword">pte_t</span> *cur = <span class="literal">NULL</span>; <span class="comment">//虚拟地址对应的 物理地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(; start &lt; end; start += PGSIZE) &#123;</span><br><span class="line">        cur = pgdir_walk(env-&gt;env_pgdir, (<span class="keyword">void</span> *)start, <span class="number">0</span>);  <span class="comment">//遍历这个虚拟地址</span></span><br><span class="line">        <span class="comment">//检查地址位置 ，权限</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">int</span>)start &gt; ULIM || cur == <span class="literal">NULL</span> || ((<span class="keyword">uint32_t</span>)(*cur) &amp; perm) != perm) &#123;</span><br><span class="line">              <span class="keyword">if</span>(start == ROUNDDOWN((<span class="keyword">char</span> *)va, PGSIZE)) &#123; <span class="comment">//这个的意思是如果一开场就错了说明出错在va</span></span><br><span class="line">                    user_mem_check_addr = (<span class="keyword">uintptr_t</span>)va;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                      user_mem_check_addr = (<span class="keyword">uintptr_t</span>)start;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> -E_FAULT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Print a string to the system console.</span></span><br><span class="line"><span class="comment">// The string is exactly 'len' characters long.</span></span><br><span class="line"><span class="comment">// Destroys the environment on memory errors.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">sys_cputs(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Check that the user has permission to read memory [s, s+len).</span></span><br><span class="line">    <span class="comment">// Destroy the environment if not:.</span></span><br><span class="line">	<span class="comment">//刚才我们已经写过了检查的函数，调用就可以了。</span></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    user_mem_assert(curenv, s, len, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Print the string supplied by the user.</span></span><br><span class="line">    cprintf(<span class="string">"%.*s"</span>, len, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的<code>trap_dispatch</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">trap_dispatch(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Handle processor exceptions.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="comment">// Unexpected trap: The user process or the kernel has a bug.</span></span><br><span class="line">	<span class="keyword">switch</span>(tf-&gt;tf_trapno) &#123;</span><br><span class="line">        <span class="keyword">case</span> (T_PGFLT):</span><br><span class="line">            page_fault_handler(tf);</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> (T_BRKPT):</span><br><span class="line">            monitor(tf);        </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> (T_SYSCALL):</span><br><span class="line">    <span class="comment">//        print_trapframe(tf);</span></span><br><span class="line">            <span class="keyword">int32_t</span> ret_code = syscall(</span><br><span class="line">                    tf-&gt;tf_regs.reg_eax,</span><br><span class="line">                    tf-&gt;tf_regs.reg_edx,</span><br><span class="line">                    tf-&gt;tf_regs.reg_ecx,</span><br><span class="line">                    tf-&gt;tf_regs.reg_ebx,</span><br><span class="line">                    tf-&gt;tf_regs.reg_edi,</span><br><span class="line">                    tf-&gt;tf_regs.reg_esi);</span><br><span class="line">            tf-&gt;tf_regs.reg_eax = ret_code;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// Unexpected trap: The user process or the kernel has a bug.</span></span><br><span class="line">            print_trapframe(tf);</span><br><span class="line">            <span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT)</span><br><span class="line">                panic(<span class="string">"unhandled trap in kernel"</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                env_destroy(curenv);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><del>如果文章有错误或者看不懂，缺了啥的可以留言。</del></p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/MIT6-828/" rel="tag"># MIT6.828</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div class="social_share">
            
            
              <div id="needsharebutton-postbottom">
                <span class="btn">
                  <i class="fa fa-share-alt" aria-hidden="true"></i>
                </span>
              </div>
            
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/02/18/MIT-6.828-(二)-Lab-2-Memory-management/" rel="next" title="MIT6.828(二)Lab2:Memory management">
                <i class="fa fa-chevron-left"></i> MIT6.828(二)Lab2:Memory management
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/02/18/MIT-6.828-(四)-Lab-4-Preemptive-Multitasking/" rel="prev" title="MIT6.828(四)Lab4:Preemptive Multitasking">
                MIT6.828(四)Lab4:Preemptive Multitasking <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      
        <div id="gitment-container"></div>
      
    </div>

  




        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/tou.jpeg" alt="尘">
            
              <p class="site-author-name" itemprop="name">尘</p>
              <p class="site-description motion-element" itemprop="description">做自己不会做的事被称之为学习</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">121</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">23</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">54</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/ETBUBBLE" title="GitHub &rarr; https://github.com/ETBUBBLE" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/qq_40871466" title="https://blog.csdn.net/qq_40871466" rel="noopener" target="_blank">csdn</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=549159342&auto=1&height=66"></iframe>
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab-3-User-Environments"><span class="nav-number">1.</span> <span class="nav-text">Lab 3: User Environments</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Introduction"><span class="nav-number">1.1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Getting-Started"><span class="nav-number">1.2.</span> <span class="nav-text">Getting Started</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-A-User-Environments-and-Exception-Handling"><span class="nav-number">1.3.</span> <span class="nav-text">Part A: User Environments and Exception Handling</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#env-h"><span class="nav-number">1.3.1.</span> <span class="nav-text">env.h</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Allocating-the-Environments-Array"><span class="nav-number">1.3.2.</span> <span class="nav-text">Allocating the Environments Array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Creating-and-Running-Environments"><span class="nav-number">1.3.3.</span> <span class="nav-text">Creating and Running Environments</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#env-init"><span class="nav-number">1.3.4.</span> <span class="nav-text">env_init()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#env-setup-vm"><span class="nav-number">1.3.5.</span> <span class="nav-text">env_setup_vm()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#region-alloc"><span class="nav-number">1.3.6.</span> <span class="nav-text">region_alloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#load-icode"><span class="nav-number">1.3.7.</span> <span class="nav-text">load_icode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#env-alloc"><span class="nav-number">1.3.8.</span> <span class="nav-text">env_alloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#env-create"><span class="nav-number">1.3.9.</span> <span class="nav-text">env_create</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#env-run"><span class="nav-number">1.3.10.</span> <span class="nav-text">env_run</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Handling-Interrupts-and-Exceptions"><span class="nav-number">1.4.</span> <span class="nav-text">Handling Interrupts and Exceptions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Basics-of-Protected-Control-Transfer"><span class="nav-number">1.5.</span> <span class="nav-text">Basics of Protected Control Transfer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Types-of-Exceptions-and-Interrupts"><span class="nav-number">1.6.</span> <span class="nav-text">Types of Exceptions and Interrupts　</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#An-Example"><span class="nav-number">1.7.</span> <span class="nav-text">An Example</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nested-Exceptions-and-Interrupts"><span class="nav-number">1.8.</span> <span class="nav-text">Nested Exceptions and Interrupts</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Setting-Up-the-IDT"><span class="nav-number">1.9.</span> <span class="nav-text">Setting Up the IDT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#trap-h"><span class="nav-number">1.10.</span> <span class="nav-text">trap.h</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TRAPHANDLER-NOEC和TRAPHANDLER-NOEC"><span class="nav-number">1.10.1.</span> <span class="nav-text">TRAPHANDLER_NOEC和TRAPHANDLER_NOEC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Question"><span class="nav-number">1.11.</span> <span class="nav-text">Question</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls"><span class="nav-number">1.12.</span> <span class="nav-text">Part B: Page Faults, Breakpoints Exceptions, and System Calls</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Handling-Page-Faults"><span class="nav-number">1.12.1.</span> <span class="nav-text">Handling Page Faults</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Breakpoint-Exception"><span class="nav-number">1.12.2.</span> <span class="nav-text">The Breakpoint Exception</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Question-1"><span class="nav-number">1.13.</span> <span class="nav-text">Question</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#System-calls"><span class="nav-number">1.14.</span> <span class="nav-text">System calls</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#User-mode-startup"><span class="nav-number">1.15.</span> <span class="nav-text">User-mode startup</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Page-faults-and-memory-protection"><span class="nav-number">1.16.</span> <span class="nav-text">Page faults and memory protection</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <link rel="stylesheet" href="/live2d/css/live2d.css">
      <div id="landlord">
          <div class="message" style="opacity:0"></div>
          <canvas id="live2d" width="280" height="250" class="live2d"></canvas>
          <div class="hide-button">隐藏</div>
      </div>
      <script type="text/javascript" src="https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
      <script type="text/javascript">
          var message_Path = '/live2d/'
          var home_Path = 'https://your.com/'
      </script>
      <script type="text/javascript" src="/live2d/js/live2d.js"></script>
      <script type="text/javascript" src="/live2d/js/message.js"></script>
      <script type="text/javascript">
          loadlive2d("live2d", "/live2d/model/tia/model.json");
      </script>
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">尘</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">806k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">12:13</span>
  
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.0.0</div>
-->



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
      <div id="needsharebutton-float">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.0"></script>

  <script src="/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.0"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.0"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.0"></script>
<script src="/js/src/post-details.js?v=7.0.0"></script>



  


  <script src="/js/src/bootstrap.js?v=7.0.0"></script>


  
  


  
    <!-- LOCAL: You can save these files to your site and update links -->

  
     <!-- <script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js"></script> -->
<script src="https://billts.site/js/gitment.js"></script>

<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css"/> -->
<link rel="stylesheet" href="https://billts.site/extra_css/gitment.css">

<!-- END LOCAL -->

<style>
#gitment-container a {
  border-bottom: none;
}

</style>

<script>
  function renderGitment() {

    var gitment = new Gitment({
      id: '1582033221000',
      owner: 'ETBUBBLE',
      repo: 'ETBUBBLE.github.io',
      
      oauth: {
      
      
        client_secret: '0fd4f83bc7834795c0575404ee5c7a2c82067749',
      
        client_id: '008c7d3ffa7d973b8437'
      }
    });
    gitment.render('gitment-container');
  }

  
    renderGitment();
  
</script>

  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  
    
      <script type="text/x-mathjax-config">
  

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });
  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') { next = next.nextSibling }
        if (next && next.nodeName.toLowerCase() === 'br') { next.parentNode.removeChild(next) }
      }
    });
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
      for (i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<style>
.MathJax_Display {
  overflow-x: scroll;
  overflow-y: hidden;
}
</style>

    
  


  

  

  

  
  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>
  <script>
    
      pbOptions = {};
      
        pbOptions.iconStyle = "box";
      
        pbOptions.boxForm = "horizontal";
      
        pbOptions.position = "bottomCenter";
      
        pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
      flOptions = {};
      
        flOptions.iconStyle = "box";
      
        flOptions.boxForm = "horizontal";
      
        flOptions.position = "middleRight";
      
        flOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script>


  

  

  

  

  

  

</body>
</html>

<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css?v=1.0.2">























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false,"dimmer":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="重要的前面基本上已经做了，现在就剩下lab5了。对于这个实验本身要你写的代码不多，但是要自己去看的贼他妈的多。原谅我复制粘贴别人的。 Lab 5: File system, Spawn and Shell在本实验中，我们将实现spawn库调用用以加载和运行磁盘上的可执行文件。然后，JOS内核和库构成的操作系统将足以在控制台上运行shell了。这些功能需要一个文件系统，本实验将介绍了一个简单的读/写">
<meta name="keywords" content="MIT6.828">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT6.828 (五)Lab5:File system, Spawn and Shell">
<meta property="og:url" content="https://etbubble.github.io/2020/02/18/MIT-6.828-(五)-Lab-5-File-system,-Spawn-and-Shell/index.html">
<meta property="og:site_name" content="ET_BUBBLE 的博客">
<meta property="og:description" content="重要的前面基本上已经做了，现在就剩下lab5了。对于这个实验本身要你写的代码不多，但是要自己去看的贼他妈的多。原谅我复制粘贴别人的。 Lab 5: File system, Spawn and Shell在本实验中，我们将实现spawn库调用用以加载和运行磁盘上的可执行文件。然后，JOS内核和库构成的操作系统将足以在控制台上运行shell了。这些功能需要一个文件系统，本实验将介绍了一个简单的读/写">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200201131800139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODcxNDY2,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200201131829616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODcxNDY2,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200202094236753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODcxNDY2,size_16,color_FFFFFF,t_70">
<meta property="og:updated_time" content="2020-02-18T14:02:38.955Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MIT6.828 (五)Lab5:File system, Spawn and Shell">
<meta name="twitter:description" content="重要的前面基本上已经做了，现在就剩下lab5了。对于这个实验本身要你写的代码不多，但是要自己去看的贼他妈的多。原谅我复制粘贴别人的。 Lab 5: File system, Spawn and Shell在本实验中，我们将实现spawn库调用用以加载和运行磁盘上的可执行文件。然后，JOS内核和库构成的操作系统将足以在控制台上运行shell了。这些功能需要一个文件系统，本实验将介绍了一个简单的读/写">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20200201131800139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODcxNDY2,size_16,color_FFFFFF,t_70">



  <link rel="alternate" href="/atom.xml" title="ET_BUBBLE 的博客" type="application/atom+xml">




  <link rel="canonical" href="https://etbubble.github.io/2020/02/18/MIT-6.828-(五)-Lab-5-File-system,-Spawn-and-Shell/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>MIT6.828 (五)Lab5:File system, Spawn and Shell | ET_BUBBLE 的博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ET_BUBBLE 的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">两件事一定不能停 学习和运动</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://etbubble.github.io/2020/02/18/MIT-6.828-(五)-Lab-5-File-system,-Spawn-and-Shell/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="尘">
      <meta itemprop="description" content="做自己不会做的事被称之为学习">
      <meta itemprop="image" content="/images/tou.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ET_BUBBLE 的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">MIT6.828 (五)Lab5:File system, Spawn and Shell

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-18 21:44:26 / 修改时间：22:02:38" itemprop="dateCreated datePublished" datetime="2020-02-18T21:44:26+08:00">2020-02-18</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/操作系统/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/操作系统/MIT6-828/" itemprop="url" rel="index"><span itemprop="name">MIT6.828</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">53k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">48 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>重要的前面基本上已经做了，现在就剩下<code>lab5</code>了。对于这个实验本身要你写的代码不多，但是要自己去看的贼他妈的多。原谅我复制粘贴别人的。</p>
<h1 id="Lab-5-File-system-Spawn-and-Shell"><a href="#Lab-5-File-system-Spawn-and-Shell" class="headerlink" title="Lab 5: File system, Spawn and Shell"></a><a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab5/" target="_blank" rel="noopener">Lab 5: File system, Spawn and Shell</a></h1><p>在本实验中，我们将实现<code>spawn</code>库调用用以加载和运行磁盘上的可执行文件。然后，JOS内核和库构成的操作系统将足以在控制台上运行<code>shell</code>了。这些功能需要一个文件系统，本实验将介绍了一个简单的<code>读/写文件系统</code>。</p>
<p>切换一下分支，会多出来几个文件，文件干啥的好好看看。</p>
<ul>
<li><code>fs/fs.c</code> 操作文件系统在磁盘上的结构，理解成文件储存结构</li>
<li><code>fs/bc.c</code> 基于用户级页错误处理机制的块缓存。</li>
<li><code>fs/ide.c</code> 最小化的基于PIO（非中断驱动的）的IDE磁盘驱动。磁盘驱动知道怎么调用就行</li>
<li><code>fs/serv.c</code> 文件系统服务端代码，客户端用户环境通过IPC与之交互，你就当做内核进行系统调用吧</li>
<li><code>lib/fd.c</code> 实现通常的UNIX风格的文件描述符接口。</li>
<li><code>lib/file.c</code> 磁盘文件类型的驱动，实现为文件系统IPC客户端。</li>
<li><code>lib/console.c</code> 控制台I/O文件类型的驱动</li>
<li><code>lib/spawn.c</code> spawn库调用实现</li>
</ul>
<p>这些文件后面都会要看一看的不用慌。</p>
<p>开场让我先试试水，还能不能运行<code>lab4</code>的<code>pingpong</code>,<code>primes</code>,<code>forktree</code>，要先把<code>kern/init.c</code>中的<code>ENV_CREATE(fs_fs)</code>和<code>lib/exit.c</code>的<code>close_all()</code>注释掉。我们去看看他做了啥。<br>我们先看看<code>init.c</code>里面的初始化函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">i386_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Initialize the console.</span></span><br><span class="line">	<span class="comment">// Can't call cprintf until after we do this!</span></span><br><span class="line">	cons_init();</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">"6828 decimal is %o octal!\n"</span>, <span class="number">6828</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Lab 2 memory management initialization functions</span></span><br><span class="line">	mem_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Lab 3 user environment initialization functions</span></span><br><span class="line">	env_init();</span><br><span class="line">	trap_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Lab 4 multiprocessor initialization functions</span></span><br><span class="line">	mp_init();</span><br><span class="line">	lapic_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Lab 4 multitasking initialization functions</span></span><br><span class="line">	pic_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Acquire the big kernel lock before waking up APs</span></span><br><span class="line">	<span class="comment">// Your code here:</span></span><br><span class="line">	lock_kernel();</span><br><span class="line">	<span class="comment">// Starting non-boot CPUs</span></span><br><span class="line">	boot_aps();</span><br><span class="line">	<span class="comment">//上个实验都是一样的，后面才开始不同</span></span><br><span class="line">	<span class="comment">// Start fs.</span></span><br><span class="line">	ENV_CREATE(fs_fs, ENV_TYPE_FS);<span class="comment">//这肯定是运行了一个 程序是啥呢？看不出来，但是根据输出</span></span><br><span class="line">	<span class="comment">//最后推断出来是 fs/serv.c 里面的umain</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(TEST)</span></span><br><span class="line">	<span class="comment">// Don't touch -- used by grading script!</span></span><br><span class="line">	ENV_CREATE(TEST, ENV_TYPE_USER);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="comment">// Touch all you want.</span></span><br><span class="line">	ENV_CREATE(user_icode, ENV_TYPE_USER);<span class="comment">//这个后面再说</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// TEST*</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Should not be necessary - drains keyboard because interrupt has given up.</span></span><br><span class="line">	kbd_intr();<span class="comment">//不用管。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Schedule and run the first user environment!</span></span><br><span class="line">	sched_yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看完之后，发现就是多了一个进程而已，其他都没怎么变。那个进程应该是运行了<code>serv.c</code>，我们简单看一下<code>main</code>函数，具体做了啥，后面再说。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">umain(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(struct File) == <span class="number">256</span>);<span class="comment">//检查结构</span></span><br><span class="line">	binaryname = <span class="string">"fs"</span>;</span><br><span class="line">	cprintf(<span class="string">"FS is running\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check that we are able to do I/O</span></span><br><span class="line">	outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</span><br><span class="line">	cprintf(<span class="string">"FS can do I/O\n"</span>);<span class="comment">//检查一下FS</span></span><br><span class="line"></span><br><span class="line">	serve_init();<span class="comment">//服务初始化</span></span><br><span class="line">	fs_init();<span class="comment">//fs初始化</span></span><br><span class="line">        fs_test();<span class="comment">//测试</span></span><br><span class="line">	serve();<span class="comment">//运行服务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="closeall"><a href="#closeall" class="headerlink" title="closeall()"></a>closeall()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">close(<span class="keyword">int</span> fdnum)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> fd_close(fd, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">close_all(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXFD; i++)</span><br><span class="line">		close(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应该就是关闭所有文件的意思。把这两行注释掉，就可以正常运行<code>lab4</code>的测试。</p>
<p>后面是一大堆理论慢慢看。</p>
<h2 id="File-system-preliminaries"><a href="#File-system-preliminaries" class="headerlink" title="File system preliminaries"></a>File system preliminaries</h2><p>我们将要实现的文件系统虽然比真实的文件系统简单的多，但是也足以提供一些基本的特性：创建、读、写、删除组织在目录结构层次中的文件。</p>
<p>我们现在（目前为止）只开发单用户操作系统，它提供足够的保护来捕捉错误，但不能保护可疑的用户程序之间的干扰。因此，我们的文件系统不支持文件所有权或权限的UNIX概念。我们的文件系统目前还不支持像大多数UNIX文件系统那样的硬链接，符号链接，时间戳或特殊的设备文件。</p>
<h2 id="On-Disk-File-System-Structure"><a href="#On-Disk-File-System-Structure" class="headerlink" title="On-Disk File System Structure"></a>On-Disk File System Structure</h2><p>大多数UNIX文件系统将可用磁盘空间分为两种主要类型的区域：<code>inode</code>区域和数据区域。 UNIX文件系统为文件系统中的每个文件分配一个<code>inode</code>;文件的<code>inode</code>保存关于文件的关键元数据，例如其stat属性和指向其数据块的指针。数据区域被划分成更大（通常为<code>8KB</code>或更多）的数据块，文件系统在其中存储文件数据和目录元数据。目录条目包含文件名和指向<code>inode</code>的指针;如果文件系统中的多个目录条目引用该文件的<code>inode</code>，则文件被称为硬链接。由于我们的文件系统不支持硬链接，所以我们不需要这种级别的重定向，因此可以方便的简化：我们的文件系统根本不会使用<code>inode</code>，而只是在（唯一）的目录条目中存储所有的文件（或子目录）的元数据。</p>
<p>文件和目录逻辑上都是由一系列数据块组成的，这些数据块可能散布在整个磁盘上，就像用户环境的虚拟地址空间的页面可以分散在整个物理内存中一样。文件系统环境隐藏数据块布局的细节，仅呈现在文件任意偏移量处读/写字节序列的接口。文件系统环境将对目录的所有修改作为文件创建和删除等操作内部处理的一部分。我们的文件系统允许用户环境直接读取目录元数据（例如，<code>read</code>），这意味着用户环境可以自己执行目录扫描操作（例如，实现<code>ls</code>程序），而不必依赖额外特殊的对文件系统的调用。对目录扫描方法的缺点，以及大多数现代<code>UNIX</code>变体阻止它的原因在于它使应用程序依赖于目录元数据的格式，使得在不更改或至少重新编译应用程序的情况下难以更改文件系统的内部布局。</p>
<p><strong>简单来讲，我们文件系统就只有一个数据结构保存文件，没有索引。</strong></p>
<h2 id="Sectors-and-Blocks"><a href="#Sectors-and-Blocks" class="headerlink" title="Sectors and Blocks"></a>Sectors and Blocks</h2><p>大多数磁盘不能以字节粒度执行读取和写入，而是以扇区为单位执行读取和写入操作。在JOS中，扇区为<code>512</code>字节。文件系统实际上以块为单位分配和使用磁盘存储。请注意两个术语之间的区别：扇区大小是磁盘硬件的属性，而块大小是操作系统使用磁盘的一个方面。文件系统的块大小必须是底层磁盘扇区大小的倍数。</p>
<p>UNIX xv6文件系统使用<code>512</code>字节的块大小，与底层磁盘的扇区大小相同。然而，大多数现代文件系统使用更大的块大小，因为存储空间已经变得更便宜，并且以更大的粒度来管理存储效率更高。我们的文件系统将使用<code>4096</code>字节的块大小，方便地匹配处理器的页面大小。</p>
<p><strong>简单来讲，磁盘默认512字节是一个扇区，我们系统<code>4096</code>字节一个块，也就是8个扇区一个块。</strong></p>
<h2 id="Superblocks"><a href="#Superblocks" class="headerlink" title="Superblocks"></a>Superblocks</h2><p>文件系统通常将某些磁盘块保留在磁盘上的“易于查找”位置（例如起始或最后），以保存描述整个文件系统属性的元数据，例如块大小，磁盘大小，找到根目录所需的任何元数据，文件系统上次挂载的时间，文件系统上次检查错误的时间等等。这些特殊块称为超级块。</p>
<p>我们的文件系统将只有一个超级块，它将始终位于磁盘上的块1。它的布局由<code>struct Super</code>在<code>inc/fs.h</code>中定义。块0通常保留用于保存引导加载程序和分区表，因此文件系统通常不使用第一个磁盘块。许多“真正的”文件系统具有多个超级块，这几个副本在磁盘的几个广泛间隔的区域，以便如果其中一个被损坏或磁盘在该区域中产生媒体错误，则仍然可以找到其他超级块，并将其用于访问文件系统。</p>
<p><img src="https://img-blog.csdnimg.cn/20200201131800139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODcxNDY2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>简单来讲，块0我们用了，在前面讲过，块1就是保存了一些磁盘布局，尤其是根目录。中间可能会有一些块用于磁盘恢复，还有位图。</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Super</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> s_magic;		<span class="comment">// Magic number: FS_MAGIC   啥编号</span></span><br><span class="line">	<span class="keyword">uint32_t</span> s_nblocks;		<span class="comment">// Total number of blocks on disk  总共块数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">s_root</span>;</span>		<span class="comment">// Root directory node 根目录</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="File-Meta-data"><a href="#File-Meta-data" class="headerlink" title="File Meta-data"></a>File Meta-data</h2><p>描述文件系统中的文件的元数据的布局由<code>inc/fs.h</code>中的<code>struct File</code>定义。该元数据包括文件的名称，大小，类型（常规文件或目录）以及指向包含该文件的块的指针。如上所述，我们没有<code>inode</code>，所以元数据存储在磁盘上的目录条目中。与大多数“真实”文件系统不同，为简单起见，我们将使用这个<code>struct File</code>来表示在磁盘和内存中出现的文件元数据。</p>
<p><code>struct File</code>中的<code>f_direc</code>t数组包含存储文件前10个（<code>NDIRECT</code>）块的块号的空间，这前10个块被称之为文件的<code>直接块</code>。对于大小为<code>10 * 4096 = 40KB</code>的小文件，这意味着所有文件块的块号将直接适用于<code>struct File</code>本身。然而，对于较大的文件，我们需要一个地方来保存文件的其他块号。因此，对于大于40KB的任何文件，我们分配一个额外的磁盘块，称为文件的<code>间接块</code>，最多容纳<code>4096/4 = 1024</code>个附加块号。因此，我们的文件系统允许文件的大小可达<code>1034</code>个块，或者刚刚超过四兆字节大小。为了支持更大的文件，“真实”文件系统通常也支持双重和三重间接块。<br><img src="https://img-blog.csdnimg.cn/20200201131829616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODcxNDY2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>简单来讲，储存文件我们用 struct File，小于10个块我们直接储存，超过10个块开一个间接块标记那几个块</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> f_name[MAXNAMELEN];	<span class="comment">// filename  文件名</span></span><br><span class="line">	<span class="keyword">off_t</span> f_size;			<span class="comment">// file size in bytes 文件大小</span></span><br><span class="line">	<span class="keyword">uint32_t</span> f_type;		<span class="comment">// file type 文件类型</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Block pointers.</span></span><br><span class="line">	<span class="comment">// A block is allocated iff its value is != 0.</span></span><br><span class="line">	<span class="keyword">uint32_t</span> f_direct[NDIRECT];	<span class="comment">// direct blocks 直接块</span></span><br><span class="line">	<span class="keyword">uint32_t</span> f_indirect;		<span class="comment">// indirect block 间接块</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pad out to 256 bytes; must do arithmetic in case we're compiling</span></span><br><span class="line">	<span class="comment">// fsformat on a 64-bit machine. //填满256字节，能够 64位机上运行 sizeof(struct File)刚好256.</span></span><br><span class="line">	<span class="keyword">uint8_t</span> f_pad[<span class="number">256</span> - MAXNAMELEN - <span class="number">8</span> - <span class="number">4</span>*NDIRECT - <span class="number">4</span>];</span><br><span class="line">&#125; __attribute__((packed));	<span class="comment">// required only on some 64-bit machines</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Directories-versus-Regular-Files"><a href="#Directories-versus-Regular-Files" class="headerlink" title="Directories versus Regular Files"></a>Directories versus Regular Files</h2><p>我们的文件系统中的<code>struct File</code>可以表示常规文件或目录;这两种类型的“文件”通过<code>struct File</code>中的类型字段进行区分。文件系统以完全相同的方式管理常规文件和目录文件，除了它不解释与常规文件相关联的数据块的内容，而文件系统将目录文件的内容解释为一系列描述目录中的文件和子目录的<code>struct File</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File types</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTYPE_REG	0	<span class="comment">// Regular file 文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTYPE_DIR	1	<span class="comment">// Directory 目录</span></span></span><br></pre></td></tr></table></figure></p>
<p>我们的文件系统中的超级块包含一个<code>struct File</code>（其实<code>struct Super</code>中的根字段），它保存文件系统根目录的元数据。根目录文件的内容是描述位于文件系统根目录下的文件和目录的<code>struct File</code>序列。根目录中的任何子目录可以依次包含表示子子目录的更多的<code>struct File</code>，依此类推。</p>
<p><strong>简单来讲，没啥可讲，够简单了</strong></p>
<h2 id="The-File-System"><a href="#The-File-System" class="headerlink" title="The File System"></a>The File System</h2><p>本<code>lab</code>的目标不是实现整个文件系统，而是仅实现某些关键组件。特别是，需要实现将<code>块读入块高速缓存</code>并将其<code>刷新回磁盘</code>;<code>分配磁盘块</code>;<code>将文件偏移映射到磁盘块</code>;<code>并在IPC接口中中实现读，写和打开</code>。因为你不会自己实现所有的文件系统，所以你需要熟悉提供的代码和各种文件系统接口。<br>看到那几个打出标记的了么，重点要考的。</p>
<h2 id="Disk-Access"><a href="#Disk-Access" class="headerlink" title="Disk Access"></a>Disk Access</h2><p>我们操作系统中的文件系统环境需要能够访问磁盘，但是我们还没有在内核中实现任何磁盘访问功能。而不是采取传统的单内核操作系统的策略将IDE磁盘驱动器添加到内核中，允许文件系统以系统调用访问它，而是将IDE磁盘驱动器作为用户级文件系统的一部分。我们仍然需要稍微修改内核，以便设置文件系统环境具有实现磁盘访问所需的权限。<br><strong>用人话来讲，我们是把磁盘访问放在用户环境，让用户能访问磁盘，但是还需要改一改内核</strong></p>
<p>只要我们依靠轮询，基于“<code>可编程I/O</code>”（<code>programmed I/O</code>, <code>PIO</code>）的磁盘访问并且不使用磁盘中断，就很容易在用户空间中实现磁盘访问。也可以在用户态下实现中断驱动的设备驱动（例如，L3和L4内核），但是由于内核必须<code>field</code>设备中断并将其分配到正确的用户态环境，所以更为困难。</p>
<p>x86处理器使用<code>EFLAGS</code>寄存器中的<code>IOPL</code>位来确定是否允许保护模式代码执行特殊的设备I/O指令，如IN和OUT指令。由于我们需要访问的所有IDE磁盘寄存器位于x86的I/O空间中，而不是内存映射，因此为文件系统环境提供“I/O特权”是我们唯一需要做的，以便允许文件系统访问这些寄存器。实际上，<code>EFLAGS</code>寄存器中的<code>IOPL</code>位为内核提供了一种简单的“全或无”方法来控制用户态代码能否访问I/O空间。在我们的实现中，我们希望文件系统环境能够访问I/O空间，但是我们不希望任何其他环境能够访问<code>I/O</code>空间。<br><strong>用人话来讲，设置 EFLAGS 中的IOPL 可以让用户访问 I/O</strong></p>
<p> <code>练习1</code>让我们实现上述问题。我们只需要添加一句话。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_create(<span class="keyword">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> * <span class="title">e</span>;</span></span><br><span class="line">	<span class="keyword">int</span> r=env_alloc(&amp;e,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(r!=<span class="number">0</span>)&#123;</span><br><span class="line">		cprintf(<span class="string">"%e\n"</span>,r);</span><br><span class="line">		panic(<span class="string">"env_create:error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	load_icode(e,binary);</span><br><span class="line">	e-&gt;env_type=type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.</span></span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span>(type==ENV_TYPE_FS)e-&gt;env_tf.tf_eflags|=FL_IOPL_MASK; <span class="comment">//添加这一句即可。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Question-1"><a href="#Question-1" class="headerlink" title="Question 1"></a>Question 1</h3><p>要不要，考虑切换用户进程的权限问题。不需要，用户环境切换的时候，<code>eflags</code>寄存器的状态有CPU压入内核栈，最后由<code>env_pop_tf</code>的<code>iret</code>指令恢复<code>eflags</code>寄存器状态。</p>
<p>后面告诉你两个指令可以恢复初始化。</p>
<h2 id="The-Block-Cache"><a href="#The-Block-Cache" class="headerlink" title="The Block Cache"></a>The Block Cache</h2><p>在我们的文件系统中，我们将在处理器的虚拟内存系统的帮助下实现一个简单的“<code>缓冲区缓存</code>”（实际上只是<code>块缓存</code>）。<code>块缓存</code>的代码在<code>fs/bc.c</code>中。</p>
<p>我们的文件系统将限于处理大小为<code>3GB</code>或更小的磁盘。我们保留一个大的，固定的<code>3GB</code>区域的文件系统环境的地址空间，从<code>0x10000000</code>（<code>DISKMAP</code>）~<code>0xD0000000</code>（<code>DISKMAP</code> + <code>DISKMAX</code>），作为磁盘的“内存映射”版本。例如，磁盘块0映射为虚拟地址<code>0x10000000</code>，磁盘块1映射到虚拟地址<code>0x10001000</code>，依此类推。<code>fs/bc.c</code>中的<code>diskaddr</code>函数实现了从磁盘块号到虚拟地址的转换（以及一些理性检查）。</p>
<p>由于我们的文件系统环境具有独立于系统中所有其他环境的虚拟地址空间的虚拟地址空间，文件系统环境唯一需要做的就是实现文件访问，因此保留大部分文件系统环境的这个地址空间。由于现代磁盘大于<code>3GB</code>，因此在<code>32</code>位计算机上这样实现真正的文件系统将会很尴尬。这样的缓冲区高速缓存管理方法在具有<code>64</code>位地址空间的机器上仍然是合理的。</p>
<p>当然，将整个磁盘读入内存需要很长时间，因此我们将实现一种按需分页的形式，其中我们只在磁盘映射区域中分配页面，并从磁盘读取相应的块，以响应这个区域的页面错误。这样，我们可以假装整个磁盘都在内存中。</p>
<p><strong>简单来讲，我们保留了一个3GB 的内存用来做磁盘映射，因为读取整个磁盘要很长的时间，所以我们就用分页形式。</strong></p>
<p><code>练习2</code>让我实现在<code>fs/bc.c</code>里面的<code>bc_pgfault</code>和<code>flush_block</code>。<br>都在一个文件里面，我们直接看看文件。<br>在看这个文件之前我们先看看<code>ide.c</code></p>
<h2 id="ide-c"><a href="#ide-c" class="headerlink" title="ide.c"></a>ide.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Minimal PIO-based (non-interrupt-driven) IDE driver code.</span></span><br><span class="line"><span class="comment"> * For information about what all this IDE/ATA magic means,</span></span><br><span class="line"><span class="comment"> * see the materials available on the class references page.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//最小化的基于PIO（非中断驱动的）的IDE磁盘驱动。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fs.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/x86.h&gt;</span></span></span><br><span class="line"><span class="comment">//下面这没有注释也不知道干啥的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDE_BSY		0x80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDE_DRDY	0x40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDE_DF		0x20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDE_ERR		0x01</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> diskno = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">ide_wait_ready(<span class="keyword">bool</span> check_error)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (((r = inb(<span class="number">0x1F7</span>)) &amp; (IDE_BSY|IDE_DRDY)) != IDE_DRDY)</span><br><span class="line">		<span class="comment">/* do nothing */</span>;</span><br><span class="line">	<span class="comment">//这个应该是检查磁盘是不是准备好的</span></span><br><span class="line">	<span class="keyword">if</span> (check_error &amp;&amp; (r &amp; (IDE_DF|IDE_ERR)) != <span class="number">0</span>)<span class="comment">//检查是否出错？</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span></span><br><span class="line">ide_probe_disk1(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> r, x;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// wait for Device 0 to be ready</span></span><br><span class="line">	ide_wait_ready(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// switch to Device 1</span></span><br><span class="line">	outb(<span class="number">0x1F6</span>, <span class="number">0xE0</span> | (<span class="number">1</span>&lt;&lt;<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// check for Device 1 to be ready for a while</span></span><br><span class="line">	<span class="keyword">for</span> (x = <span class="number">0</span>;</span><br><span class="line">	     x &lt; <span class="number">1000</span> &amp;&amp; ((r = inb(<span class="number">0x1F7</span>)) &amp; (IDE_BSY|IDE_DF|IDE_ERR)) != <span class="number">0</span>;</span><br><span class="line">	     x++)</span><br><span class="line">		<span class="comment">/* do nothing */</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// switch back to Device 0</span></span><br><span class="line">	outb(<span class="number">0x1F6</span>, <span class="number">0xE0</span> | (<span class="number">0</span>&lt;&lt;<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">"Device 1 presence: %d\n"</span>, (x &lt; <span class="number">1000</span>));</span><br><span class="line">	<span class="keyword">return</span> (x &lt; <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ide_set_disk(<span class="keyword">int</span> d)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (d != <span class="number">0</span> &amp;&amp; d != <span class="number">1</span>)</span><br><span class="line">		panic(<span class="string">"bad disk number"</span>);</span><br><span class="line">	diskno = d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前面也不知道是啥，不过不重要重要的是下面两个函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">ide_read(<span class="keyword">uint32_t</span> secno, <span class="keyword">void</span> *dst, <span class="keyword">size_t</span> nsecs) <span class="comment">//参数三个，扇区号，虚拟地址，已经读取扇区个数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	assert(nsecs &lt;= <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">	ide_wait_ready(<span class="number">0</span>);<span class="comment">//判断是不是等待</span></span><br><span class="line"><span class="comment">//后面看不懂了</span></span><br><span class="line">	outb(<span class="number">0x1F2</span>, nsecs);</span><br><span class="line">	outb(<span class="number">0x1F3</span>, secno &amp; <span class="number">0xFF</span>);</span><br><span class="line">	outb(<span class="number">0x1F4</span>, (secno &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">	outb(<span class="number">0x1F5</span>, (secno &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">	outb(<span class="number">0x1F6</span>, <span class="number">0xE0</span> | ((diskno&amp;<span class="number">1</span>)&lt;&lt;<span class="number">4</span>) | ((secno&gt;&gt;<span class="number">24</span>)&amp;<span class="number">0x0F</span>));</span><br><span class="line">	outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);	<span class="comment">// CMD 0x20 means read sector</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (; nsecs &gt; <span class="number">0</span>; nsecs--, dst += SECTSIZE) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((r = ide_wait_ready(<span class="number">1</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		insl(<span class="number">0x1F0</span>, dst, SECTSIZE/<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">ide_write(<span class="keyword">uint32_t</span> secno, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> nsecs)<span class="comment">//写入扇区，写入内容，写入扇区个数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	assert(nsecs &lt;= <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">	ide_wait_ready(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	outb(<span class="number">0x1F2</span>, nsecs);</span><br><span class="line">	outb(<span class="number">0x1F3</span>, secno &amp; <span class="number">0xFF</span>);</span><br><span class="line">	outb(<span class="number">0x1F4</span>, (secno &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">	outb(<span class="number">0x1F5</span>, (secno &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">	outb(<span class="number">0x1F6</span>, <span class="number">0xE0</span> | ((diskno&amp;<span class="number">1</span>)&lt;&lt;<span class="number">4</span>) | ((secno&gt;&gt;<span class="number">24</span>)&amp;<span class="number">0x0F</span>));</span><br><span class="line">	outb(<span class="number">0x1F7</span>, <span class="number">0x30</span>);	<span class="comment">// CMD 0x30 means write sector</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (; nsecs &gt; <span class="number">0</span>; nsecs--, src += SECTSIZE) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((r = ide_wait_ready(<span class="number">1</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		outsl(<span class="number">0x1F0</span>, src, SECTSIZE/<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看完这个文件，主要要记住的就是那两个函数后面用的上。<br><code>int ide_read(uint32_t secno, void *dst, size_t nsecs)</code><br><code>int ide_write(uint32_t secno, const void *src, size_t nsecs)</code></p>
<h3 id="bc"><a href="#bc" class="headerlink" title="bc"></a>bc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fs.h"</span></span></span><br><span class="line"><span class="comment">// 基于用户级页错误处理机制的块缓存。</span></span><br><span class="line"><span class="comment">// Return the virtual address of this disk block.</span></span><br><span class="line"><span class="keyword">void</span>*</span><br><span class="line">diskaddr(<span class="keyword">uint32_t</span> blockno) <span class="comment">//看的出来是返回对应块号的虚拟地址</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (blockno == <span class="number">0</span> || (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks))</span><br><span class="line">		panic(<span class="string">"bad block number %08x in diskaddr"</span>, blockno);</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">char</span>*) (DISKMAP + blockno * BLKSIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Is this virtual address mapped?</span></span><br><span class="line"><span class="keyword">bool</span></span><br><span class="line">va_is_mapped(<span class="keyword">void</span> *va)<span class="comment">//这个应该是判断这个页有没有映射</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (uvpd[PDX(va)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(va)] &amp; PTE_P);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Is this virtual address dirty?</span></span><br><span class="line"><span class="keyword">bool</span></span><br><span class="line">va_is_dirty(<span class="keyword">void</span> *va)<span class="comment">//这个虚拟地址是不是修改了</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (uvpt[PGNUM(va)] &amp; PTE_D) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fault any disk block that is read in to memory by</span></span><br><span class="line"><span class="comment">// loading it from disk. 这个应该就是缺页处理了</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">bc_pgfault(struct UTrapframe *utf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> *addr = (<span class="keyword">void</span> *) utf-&gt;utf_fault_va;<span class="comment">//获取缺页地址</span></span><br><span class="line">	<span class="keyword">uint32_t</span> blockno = ((<span class="keyword">uint32_t</span>)addr - DISKMAP) / BLKSIZE;<span class="comment">//对应块号</span></span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check that the fault was within the block cache region判断地址合不合法</span></span><br><span class="line">	<span class="keyword">if</span> (addr &lt; (<span class="keyword">void</span>*)DISKMAP || addr &gt;= (<span class="keyword">void</span>*)(DISKMAP + DISKSIZE))</span><br><span class="line">		panic(<span class="string">"page fault in FS: eip %08x, va %08x, err %04x"</span>,</span><br><span class="line">		      utf-&gt;utf_eip, addr, utf-&gt;utf_err);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sanity check the block number. 检查块号合不合法</span></span><br><span class="line">	<span class="keyword">if</span> (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks)</span><br><span class="line">		panic(<span class="string">"reading non-existent block %08x\n"</span>, blockno);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate a page in the disk map region, read the contents</span></span><br><span class="line">	<span class="comment">// of the block from the disk into that page.</span></span><br><span class="line">	<span class="comment">// Hint: first round addr to page boundary. fs/ide.c has code to read</span></span><br><span class="line">	<span class="comment">// the disk. fs/ide.c 有代码去读取硬盘</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">// LAB 5: you code here:</span></span><br><span class="line">	<span class="comment">//经过练习的提示，我们应该要页对齐然后再分配内存</span></span><br><span class="line">	addr=ROUNDDOWN(addr,PGSIZE);</span><br><span class="line">	<span class="keyword">if</span>(sys_page_alloc(<span class="number">0</span>,addr,PTE_SYSCALL)&lt;<span class="number">0</span>)panic(<span class="string">"error page alloc"</span>); <span class="comment">//分配一个页</span></span><br><span class="line">	<span class="comment">//分配完页之后，我们需要把磁盘里面的内容读出来，练习提示了我们 函数是按扇区来的</span></span><br><span class="line">	<span class="comment">//而我们是按块来的，还有页，第blockno*8 个扇区，读8个扇区</span></span><br><span class="line">	ide_read(blockno*<span class="number">8</span>,addr,<span class="number">8</span>);<span class="comment">//把页磁盘里面的值读出来 </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Clear the dirty bit for the disk block page since we just read the</span></span><br><span class="line">	<span class="comment">// block from disk  刚加入的还没有修改，所以还是干净的</span></span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">"in bc_pgfault, sys_page_map: %e"</span>, r);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check that the block we read was allocated. (exercise for</span></span><br><span class="line">	<span class="comment">// the reader: why do we do this *after* reading the block</span></span><br><span class="line">	<span class="comment">// in?) 检查这个是不是已经分配了</span></span><br><span class="line">	<span class="keyword">if</span> (bitmap &amp;&amp; block_is_free(blockno))</span><br><span class="line">		panic(<span class="string">"reading free block %08x\n"</span>, blockno);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Flush the contents of the block containing VA out to disk if</span></span><br><span class="line"><span class="comment">// necessary, then clear the PTE_D bit using sys_page_map.</span></span><br><span class="line"><span class="comment">// If the block is not in the block cache or is not dirty, does</span></span><br><span class="line"><span class="comment">// nothing.  把VA地址的内容写到磁盘，如果没有修改就什么都不要做</span></span><br><span class="line"><span class="comment">// Hint: Use va_is_mapped, va_is_dirty, and ide_write. 这三个是可以用的</span></span><br><span class="line"><span class="comment">// Hint: Use the PTE_SYSCALL constant when calling sys_page_map. 用 sys_page_map清楚 修改位</span></span><br><span class="line"><span class="comment">// Hint: Don't forget to round addr down.不要忘记页对齐</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">flush_block(<span class="keyword">void</span> *addr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> blockno = ((<span class="keyword">uint32_t</span>)addr - DISKMAP) / BLKSIZE;<span class="comment">//获取块号</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (addr &lt; (<span class="keyword">void</span>*)DISKMAP || addr &gt;= (<span class="keyword">void</span>*)(DISKMAP + DISKSIZE))<span class="comment">//检查地址</span></span><br><span class="line">		panic(<span class="string">"flush_block of bad va %08x"</span>, addr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">	addr=ROUNDDOWN(addr,PGSIZE);<span class="comment">//页对齐</span></span><br><span class="line">	<span class="keyword">if</span>(!va_is_mapped(addr)||!va_is_dirty(addr))<span class="keyword">return</span> ;<span class="comment">//检查地址是不是已经映射了和修改  如果没有映射，或者是修改说明没有做任何改变，那么什么都不用做</span></span><br><span class="line">	ide_write(blockno*<span class="number">8</span>,addr,<span class="number">8</span>); <span class="comment">//修改了就要写入</span></span><br><span class="line">	sys_page_map(<span class="number">0</span>,addr,<span class="number">0</span>,addr,PTE_SYSCALL);<span class="comment">// 清楚修改标志</span></span><br><span class="line">	<span class="comment">//panic("flush_block not implemented");</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test that the block cache works, by smashing the superblock and</span></span><br><span class="line"><span class="comment">// reading it back.  测试缓存是不是工作。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">check_bc(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Super</span> <span class="title">backup</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// back up super block</span></span><br><span class="line">	memmove(&amp;backup, diskaddr(<span class="number">1</span>), <span class="keyword">sizeof</span> backup);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// smash it</span></span><br><span class="line">	<span class="built_in">strcpy</span>(diskaddr(<span class="number">1</span>), <span class="string">"OOPS!\n"</span>);</span><br><span class="line">	flush_block(diskaddr(<span class="number">1</span>));</span><br><span class="line">	assert(va_is_mapped(diskaddr(<span class="number">1</span>)));</span><br><span class="line">	assert(!va_is_dirty(diskaddr(<span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// clear it out</span></span><br><span class="line">	sys_page_unmap(<span class="number">0</span>, diskaddr(<span class="number">1</span>));</span><br><span class="line">	assert(!va_is_mapped(diskaddr(<span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// read it back in</span></span><br><span class="line">	assert(<span class="built_in">strcmp</span>(diskaddr(<span class="number">1</span>), <span class="string">"OOPS!\n"</span>) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// fix it</span></span><br><span class="line">	memmove(diskaddr(<span class="number">1</span>), &amp;backup, <span class="keyword">sizeof</span> backup);</span><br><span class="line">	flush_block(diskaddr(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now repeat the same experiment, but pass an unaligned address to</span></span><br><span class="line">	<span class="comment">// flush_block.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// back up super block</span></span><br><span class="line">	memmove(&amp;backup, diskaddr(<span class="number">1</span>), <span class="keyword">sizeof</span> backup);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// smash it</span></span><br><span class="line">	<span class="built_in">strcpy</span>(diskaddr(<span class="number">1</span>), <span class="string">"OOPS!\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pass an unaligned address to flush_block.</span></span><br><span class="line">	flush_block(diskaddr(<span class="number">1</span>) + <span class="number">20</span>);</span><br><span class="line">	assert(va_is_mapped(diskaddr(<span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Skip the !va_is_dirty() check because it makes the bug somewhat</span></span><br><span class="line">	<span class="comment">// obscure and hence harder to debug.</span></span><br><span class="line">	<span class="comment">//assert(!va_is_dirty(diskaddr(1)));</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// clear it out</span></span><br><span class="line">	sys_page_unmap(<span class="number">0</span>, diskaddr(<span class="number">1</span>));</span><br><span class="line">	assert(!va_is_mapped(diskaddr(<span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// read it back in</span></span><br><span class="line">	assert(<span class="built_in">strcmp</span>(diskaddr(<span class="number">1</span>), <span class="string">"OOPS!\n"</span>) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// fix it</span></span><br><span class="line">	memmove(diskaddr(<span class="number">1</span>), &amp;backup, <span class="keyword">sizeof</span> backup);</span><br><span class="line">	flush_block(diskaddr(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">"block cache is good\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">bc_init(<span class="keyword">void</span>)<span class="comment">//初始化磁盘</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Super</span> <span class="title">super</span>;</span></span><br><span class="line">	set_pgfault_handler(bc_pgfault);<span class="comment">//设置缺页处理手段</span></span><br><span class="line">	check_bc();<span class="comment">//检查磁盘缓冲</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// cache the super block by reading it once 第一次加载，在这个时候把根目录取到内存了，在这之后我们就可以通过super 访问磁盘状态了</span></span><br><span class="line">	memmove(&amp;super, diskaddr(<span class="number">1</span>), <span class="keyword">sizeof</span> super)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们现在就有缺页处理，和刷新缓存的功能了。</p>
<p><code>fs/fs.c</code>中的<code>fs_init</code>函数是如何使用块缓存的主要示例。在初始化块缓存之后，它将指针存储在<code>super</code>全局变量的磁盘映射区域中。此后，我们可以简单地从<code>struct Super</code>中读取，就像它们在内存中一样，我们的页面错误处理程序将根据需要从磁盘读取它们。<br>我们看看<code>fs_init()</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize the file system</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">fs_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(struct File) == <span class="number">256</span>);<span class="comment">//检查File 对不对</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find a JOS disk.  Use the second IDE disk (number 1) if available</span></span><br><span class="line">	<span class="keyword">if</span> (ide_probe_disk1()) <span class="comment">//这个是找盘？看注释是看有没有1号盘，有就用1号没有0号？</span></span><br><span class="line">		ide_set_disk(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ide_set_disk(<span class="number">0</span>);</span><br><span class="line">	bc_init();<span class="comment">//这个讲过了</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set "super" to point to the super block.</span></span><br><span class="line">	super = diskaddr(<span class="number">1</span>);<span class="comment">//在bc_init里面实际上已经有了 也不知道这两个有啥区别</span></span><br><span class="line">	check_super();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set "bitmap" to the beginning of the first bitmap block.</span></span><br><span class="line">	bitmap = diskaddr(<span class="number">2</span>);<span class="comment">//位图 我们接下来就要讲了</span></span><br><span class="line">	check_bitmap();</span><br></pre></td></tr></table></figure></p>
<h2 id="The-Block-Bitmap"><a href="#The-Block-Bitmap" class="headerlink" title="The Block Bitmap"></a>The Block Bitmap</h2><p>在<code>fs_init</code>设置位图指针之后，我们可以将位图视为一个打包数组的位，每一个位对应于磁盘上的每个块。参见例如<code>block_is_free</code>，它在位图中检查给定的块是否被标记为空闲。<br><code>练习3</code>实现<code>fs/fs.c</code>里面的<code>alloc_block</code>。<br>我们简单看看相关函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Super block</span></span><br><span class="line"><span class="comment">// --------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Validate the file system super-block.  检查super是否正常</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">check_super(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (super-&gt;s_magic != FS_MAGIC)<span class="comment">//不知道干啥的</span></span><br><span class="line">		panic(<span class="string">"bad file system magic number"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (super-&gt;s_nblocks &gt; DISKSIZE/BLKSIZE)<span class="comment">//检查文件系统是不是正常大小</span></span><br><span class="line">		panic(<span class="string">"file system is too large"</span>);</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">"superblock is good\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Free block bitmap</span></span><br><span class="line"><span class="comment">// --------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Check to see if the block bitmap indicates that block 'blockno' is free.</span></span><br><span class="line"><span class="comment">// Return 1 if the block is free, 0 if not. 看的出来是检查一个块号是不是空闲额，1空闲0不空闲</span></span><br><span class="line"><span class="keyword">bool</span></span><br><span class="line">block_is_free(<span class="keyword">uint32_t</span> blockno)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (super == <span class="number">0</span> || blockno &gt;= super-&gt;s_nblocks)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (bitmap[blockno / <span class="number">32</span>] &amp; (<span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>)))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mark a block free in the bitmap //把一个块号释放掉</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">free_block(<span class="keyword">uint32_t</span> blockno)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Blockno zero is the null pointer of block numbers.</span></span><br><span class="line">	<span class="keyword">if</span> (blockno == <span class="number">0</span>) <span class="comment">//记住0是不能用的</span></span><br><span class="line">		panic(<span class="string">"attempt to free zero block"</span>);</span><br><span class="line">	<span class="comment">//uint32_t *bitmap; bitmap 定义是 32位，每位代表一个块</span></span><br><span class="line">	bitmap[blockno/<span class="number">32</span>] |= <span class="number">1</span>&lt;&lt;(blockno%<span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Search the bitmap for a free block and allocate it.  When you</span></span><br><span class="line"><span class="comment">// allocate a block, immediately flush the changed bitmap block</span></span><br><span class="line"><span class="comment">// to disk.</span></span><br><span class="line"><span class="comment">// 暴力搜索第一个块号然后分配。</span></span><br><span class="line"><span class="comment">// Return block number allocated on success,</span></span><br><span class="line"><span class="comment">// -E_NO_DISK if we are out of blocks.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: use free_block as an example for manipulating the bitmap. 使用free_block 作为一个列子</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">alloc_block(<span class="keyword">void</span>)<span class="comment">//看了上面那个这个实现就简单额。</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// The bitmap consists of one or more blocks.  A single bitmap block</span></span><br><span class="line">	<span class="comment">// contains the in-use bits for BLKBITSIZE blocks.  There are</span></span><br><span class="line">	<span class="comment">// super-&gt;s_nblocks blocks in the disk altogether.</span></span><br><span class="line">	<span class="comment">//告诉你总共有 super-&gt;s_nblocks 这么多个块</span></span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;super-&gt;s_nblocks;i++)&#123;<span class="comment">//直接暴力所有块</span></span><br><span class="line">		<span class="keyword">if</span>(block_is_free(i))&#123; <span class="comment">//检查是不是空闲</span></span><br><span class="line">			bitmap[i/<span class="number">32</span>] ^= (<span class="number">1</span>&lt;&lt;(i%<span class="number">32</span>)); <span class="comment">//不懂异或 的可以用  bitmap[i/32]&amp;=~(1&lt;&lt;(i%32); 代替</span></span><br><span class="line">			flush_block(diskaddr(i));<span class="comment">//刷新缓存。</span></span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//panic("alloc_block not implemented");</span></span><br><span class="line">	<span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Validate the file system bitmap.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Check that all reserved blocks -- 0, 1, and the bitmap blocks themselves --</span></span><br><span class="line"><span class="comment">// are all marked as in-use.  检查位图，没有我们需要操作的地方，看一下就行</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">check_bitmap(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Make sure all bitmap blocks are marked in-use 检查位图块都被使用了</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i * BLKBITSIZE &lt; super-&gt;s_nblocks; i++)</span><br><span class="line">		assert(!block_is_free(<span class="number">2</span>+i));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Make sure the reserved and root blocks are marked in-use.</span></span><br><span class="line">	assert(!block_is_free(<span class="number">0</span>));</span><br><span class="line">	assert(!block_is_free(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">"bitmap is good\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="File-Operations"><a href="#File-Operations" class="headerlink" title="File Operations"></a>File Operations</h2><p>我们在<code>fs/fs.c</code>中提供了各种函数，以实现解释和管理<code>struct File</code>，扫描和管理目录条目所需的基本功能，并从文件系统的根目录开始遍历以解析绝对路径名。阅读<code>fs/fs.c</code>中的所有代码，并确保您了解每个函数执行的操作。<br>刚才我们已经看了一部分了，然后还是短短的一部分。<br><code>练习4</code> 我们需要实现<code>file_block_walk</code> 和 <code>file_get_block</code>，这两个功能十分重要。<code>file_block_walk</code>这个是找到<strong>文件里面第<code>filebno</code>块号地址，是指向块号的地址，并不是块的具体地址</strong>，<code>file_get_block</code>功能是找到 <strong><code>filebno</code>对应的块号是多少，并返回块号地址，这个是具体地址</strong><br>基本上所有文件操作都要通过上述两个函数。</p>
<h3 id="file-block-walk和file-get-block"><a href="#file-block-walk和file-get-block" class="headerlink" title="file_block_walk和file_get_block"></a>file_block_walk和file_get_block</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Find the disk block number slot for the 'filebno'th block in file 'f'.</span></span><br><span class="line"><span class="comment">// Set '*ppdiskbno' to point to that slot. </span></span><br><span class="line"><span class="comment">// The slot will be one of the f-&gt;f_direct[] entries,</span></span><br><span class="line"><span class="comment">// or an entry in the indirect block.</span></span><br><span class="line"><span class="comment">// When 'alloc' is set, this function will allocate an indirect block</span></span><br><span class="line"><span class="comment">// if necessary.</span></span><br><span class="line"><span class="comment">//在f 文件里面找到第 filebno 块对应的地址，储存到*ppdiskbno，可能在 f-&gt;f_direct[] 里面</span></span><br><span class="line"><span class="comment">//或者 间接块里面，如果我们 分配位置设置了，就分配一个</span></span><br><span class="line"><span class="comment">// Returns:</span></span><br><span class="line"><span class="comment">// *ppdiskbno 储存的是块号</span></span><br><span class="line"><span class="comment">//	0 on success (but note thatppdiskbno might equal 0).分配冲个返回0</span></span><br><span class="line"><span class="comment">//	-E_NOT_FOUND if the function needed to allocate an indirect block, but</span></span><br><span class="line"><span class="comment">//		alloc was 0. 没有找到 且没有设置分配位</span></span><br><span class="line"><span class="comment">//	-E_NO_DISK if there's no space on the disk for an indirect block.没空间了</span></span><br><span class="line"><span class="comment">//	-E_INVAL if filebno is out of range (it's &gt;= NDIRECT + NINDIRECT).</span></span><br><span class="line"><span class="comment">//超出范围</span></span><br><span class="line"><span class="comment">// Analogy: This is like pgdir_walk for files.和pgdir_walk很像</span></span><br><span class="line"><span class="comment">// Hint: Don't forget to clear any block you allocate.不要忘记清楚你分配的块</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">file_block_walk(struct File *f, <span class="keyword">uint32_t</span> filebno, <span class="keyword">uint32_t</span> **ppdiskbno, <span class="keyword">bool</span> alloc)<span class="comment">//f 文件   fileno文件中的第几块   ppdiskbno储存地址 alloc是否可以分配间接块</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">       <span class="comment">//NDIRECT NINDIRECT 两个在fs.h 里面有定义</span></span><br><span class="line">	   <span class="keyword">if</span>(filebno&gt;=NDIRECT+NINDIRECT)<span class="keyword">return</span> -E_INVAL;<span class="comment">//文件块数超出了最大值</span></span><br><span class="line">	   <span class="keyword">if</span>(filebno&lt;NDIRECT)&#123;<span class="comment">//如果在直接块里面 ，就直接返回地址</span></span><br><span class="line">		   <span class="keyword">if</span>(ppdiskbno)&#123;</span><br><span class="line">			   *ppdiskbno=&amp;f-&gt;f_direct[filebno];</span><br><span class="line">		   &#125;</span><br><span class="line">		   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	   &#125;</span><br><span class="line">	   <span class="comment">//如果没有在直接块里面，那么就只能在间接块里，然后我们怎么判断有没有间接块呢？？？</span></span><br><span class="line">	   <span class="comment">//在这个文件里面搜索 `f_indirectf`，发现在 file_truncate_blocks函数的前面</span></span><br><span class="line">	   <span class="comment">//有说明 f-&gt;f_indirect != 0代表没有 特么这个函数不告诉我，别问我经历了什么</span></span><br><span class="line">	   <span class="keyword">if</span>((f-&gt;f_indirect)==<span class="number">0</span>)&#123;<span class="comment">//判断没有间接块</span></span><br><span class="line">		   <span class="keyword">if</span>(alloc==<span class="number">0</span>)<span class="keyword">return</span> -E_NOT_FOUND;<span class="comment">//没有设置分配位，就返回没有找到</span></span><br><span class="line">		   <span class="keyword">int</span> r=alloc_block();<span class="comment">//分配一个块</span></span><br><span class="line">		   <span class="keyword">if</span>(r&lt;=<span class="number">0</span>)<span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">		   f-&gt;f_indirect=r;<span class="comment">//间接快块号</span></span><br><span class="line">		   <span class="built_in">memset</span>(diskaddr(f-&gt;f_indirect), <span class="number">0</span>, BLKSIZE);<span class="comment">//出事化为0</span></span><br><span class="line">		   flush_block(diskaddr(f-&gt;f_indirect));<span class="comment">//刷新缓存</span></span><br><span class="line">	   &#125;</span><br><span class="line">		<span class="keyword">if</span> (ppdiskbno)<span class="comment">//只是返回地址，没有具体的值。</span></span><br><span class="line">            *ppdiskbno = &amp;((<span class="keyword">uint32_t</span> *)diskaddr(f-&gt;f_indirect))[filebno-NDIRECT];<span class="comment">//此时 *ppdiskbno 是块号</span></span><br><span class="line">	   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//panic("file_block_walk not implemented");</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set *blk to the address in memory where the filebno'th</span></span><br><span class="line"><span class="comment">// block of file 'f' would be mapped.</span></span><br><span class="line"><span class="comment">//设置 *blk 为 在 f 文件连 的第 fileno 的地址。明显是要用到上一个函数。</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors are:返回0成功</span></span><br><span class="line"><span class="comment">//	-E_NO_DISK if a block needed to be allocated but the disk is full. 没有空间了返回 </span></span><br><span class="line"><span class="comment">//	-E_INVAL if filebno is out of range. 超出范围</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: Use file_block_walk and alloc_block. 使用这两个函数</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">file_get_block(struct File *f, <span class="keyword">uint32_t</span> filebno, <span class="keyword">char</span> **blk)</span><br><span class="line">&#123;</span><br><span class="line">       <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">       	<span class="keyword">uint32_t</span> *ppdiskbno,blockno；</span><br><span class="line">	   	<span class="keyword">int</span> r=<span class="number">0</span>; <span class="comment">//首先得知道对应磁盘中的块号是多少，</span></span><br><span class="line">	   	<span class="comment">//通过这个函数 ppdiskbno 就是指向对应磁盘块号的地址，也就是 *ppdiskbno 存的是块号。</span></span><br><span class="line">		<span class="keyword">if</span> ((r = file_block_walk(f, filebno, &amp;ppdiskbno, <span class="literal">true</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">if</span> ((*ppdiskbno)==<span class="number">0</span>) &#123;<span class="comment">//块号是 0 说明还没有分配块</span></span><br><span class="line">        	<span class="keyword">if</span> ((r = alloc_block()) &lt; <span class="number">0</span>)<span class="comment">//分配一个块</span></span><br><span class="line">            	<span class="keyword">return</span> r;</span><br><span class="line">            blockno = r;</span><br><span class="line">            *ppdiskbno = blockno;<span class="comment">//指向那个块</span></span><br><span class="line">            flush_block(diskaddr(*ppdiskbno));<span class="comment">//刷新缓存</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (blk)</span><br><span class="line">        	*blk = (<span class="keyword">char</span> *)diskaddr(*ppdiskbno);<span class="comment">//块号在磁盘中的地址 是 *blk存的是虚拟地址指针</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	   <span class="comment">//panic("file_get_block not implemented");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看懂上面两个函数，其他的就都简单了。我们来看看其他函数。</p>
<h3 id="fs-c"><a href="#fs-c" class="headerlink" title="fs.c"></a>fs.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Try to find a file named "name" in dir.  If so, set *file to it.</span></span><br><span class="line"><span class="comment">// 在目录里面找一个name 的文件</span></span><br><span class="line"><span class="comment">// Returns 0 and sets *file on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//	-E_NOT_FOUND if the file is not found 没找到</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">dir_lookup(struct File *dir, <span class="keyword">const</span> <span class="keyword">char</span> *name, struct File **file)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="keyword">uint32_t</span> i, j, nblock;</span><br><span class="line">	<span class="keyword">char</span> *blk;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Search dir for name.</span></span><br><span class="line">	<span class="comment">// We maintain the invariant that the size of a directory-file</span></span><br><span class="line">	<span class="comment">// is always a multiple of the file system's block size.</span></span><br><span class="line">	assert((dir-&gt;f_size % BLKSIZE) == <span class="number">0</span>);</span><br><span class="line">	nblock = dir-&gt;f_size / BLKSIZE;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nblock; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((r = file_get_block(dir, i, &amp;blk)) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		f = (struct File*) blk;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BLKFILES; j++)<span class="comment">//就是简单的一个个比较</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strcmp</span>(f[j].f_name, name) == <span class="number">0</span>) &#123;</span><br><span class="line">				*file = &amp;f[j];</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set *file to point at a free File structure in dir.  The caller is</span></span><br><span class="line"><span class="comment">// responsible for filling in the File fields. 在目录里面添加一个文件</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">dir_alloc_file(struct File *dir, struct File **file)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="keyword">uint32_t</span> nblock, i, j;</span><br><span class="line">	<span class="keyword">char</span> *blk;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">	assert((dir-&gt;f_size % BLKSIZE) == <span class="number">0</span>);</span><br><span class="line">	nblock = dir-&gt;f_size / BLKSIZE;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nblock; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((r = file_get_block(dir, i, &amp;blk)) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		f = (struct File*) blk;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BLKFILES; j++)</span><br><span class="line">			<span class="keyword">if</span> (f[j].f_name[<span class="number">0</span>] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">				*file = &amp;f[j];<span class="comment">//找到第一个能放 文件描述符的位置</span></span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dir-&gt;f_size += BLKSIZE;<span class="comment">//文件大小增加</span></span><br><span class="line">	<span class="keyword">if</span> ((r = file_get_block(dir, i, &amp;blk)) &lt; <span class="number">0</span>)<span class="comment">//不知道为啥还要在找一次</span></span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	f = (struct File*) blk;</span><br><span class="line">	*file = &amp;f[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Skip over slashes.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="comment">//跳过斜杠的第一个字符</span></span><br><span class="line">skip_slash(<span class="keyword">const</span> <span class="keyword">char</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (*p == <span class="string">'/'</span>)</span><br><span class="line">		p++;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Evaluate a path name, starting at the root. 一个路径 从根目录开始</span></span><br><span class="line"><span class="comment">// On success, set *pf to the file we found 成功设置文件指针pf 和 路径指针pdir</span></span><br><span class="line"><span class="comment">// and set *pdir to the directory the file is in.</span></span><br><span class="line"><span class="comment">// If we cannot find the file but find the directory </span></span><br><span class="line"><span class="comment">// it should be in, set *pdir and copy the final path</span></span><br><span class="line"><span class="comment">// element into lastelem.如果我们没有找到一个文件但是找到了路径，那么就把路径指过去，再复制最后一个元素</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">walk_path(<span class="keyword">const</span> <span class="keyword">char</span> *path, struct File **pdir, struct File **pf, <span class="keyword">char</span> *lastelem)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *p;</span><br><span class="line">	<span class="keyword">char</span> name[MAXNAMELEN];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">dir</span>, *<span class="title">f</span>;</span></span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// if (*path != '/')</span></span><br><span class="line">	<span class="comment">//	return -E_BAD_PATH;</span></span><br><span class="line">	path = skip_slash(path);</span><br><span class="line">	f = &amp;super-&gt;s_root;</span><br><span class="line">	dir = <span class="number">0</span>;</span><br><span class="line">	name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pdir)</span><br><span class="line">		*pdir = <span class="number">0</span>;</span><br><span class="line">	*pf = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (*path != <span class="string">'\0'</span>) &#123;</span><br><span class="line">		dir = f;</span><br><span class="line">		p = path;</span><br><span class="line">		<span class="keyword">while</span> (*path != <span class="string">'/'</span> &amp;&amp; *path != <span class="string">'\0'</span>)</span><br><span class="line">			path++;</span><br><span class="line">		<span class="keyword">if</span> (path - p &gt;= MAXNAMELEN)</span><br><span class="line">			<span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">		memmove(name, p, path - p);</span><br><span class="line">		name[path - p] = <span class="string">'\0'</span>;</span><br><span class="line">		path = skip_slash(path);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (dir-&gt;f_type != FTYPE_DIR)</span><br><span class="line">			<span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((r = dir_lookup(dir, name, &amp;f)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (r == -E_NOT_FOUND &amp;&amp; *path == <span class="string">'\0'</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (pdir)</span><br><span class="line">					*pdir = dir;</span><br><span class="line">				<span class="keyword">if</span> (lastelem)</span><br><span class="line">					<span class="built_in">strcpy</span>(lastelem, name);</span><br><span class="line">				*pf = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pdir)</span><br><span class="line">		*pdir = dir;</span><br><span class="line">	*pf = f;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// File operations</span></span><br><span class="line"><span class="comment">// --------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create "path".  On success set *pf to point at the file and return 0.</span></span><br><span class="line"><span class="comment">// On error return &lt; 0. 在path 创建文件，*pf指向文件？？？？</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">file_create(<span class="keyword">const</span> <span class="keyword">char</span> *path, struct File **pf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> name[MAXNAMELEN];</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">dir</span>, *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = walk_path(path, &amp;dir, &amp;f, name)) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -E_FILE_EXISTS;</span><br><span class="line">	<span class="keyword">if</span> (r != -E_NOT_FOUND || dir == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	<span class="keyword">if</span> ((r = dir_alloc_file(dir, &amp;f)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcpy</span>(f-&gt;f_name, name);</span><br><span class="line">	*pf = f;</span><br><span class="line">	file_flush(dir);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Open "path".  On success set *pf to point at the file and return 0.</span></span><br><span class="line"><span class="comment">// On error return &lt; 0. 打开文件，pf 指向文件</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">file_open(<span class="keyword">const</span> <span class="keyword">char</span> *path, struct File **pf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> walk_path(path, <span class="number">0</span>, pf, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read count bytes from f into buf, starting from seek position</span></span><br><span class="line"><span class="comment">// offset.  This meant to mimic the standard pread function.</span></span><br><span class="line"><span class="comment">// Returns the number of bytes read, &lt; 0 on error.</span></span><br><span class="line"><span class="comment">//这个函数要看懂，其实就是在 f 里面读 count 个文件到buf里面，offset 你可以理解成光标</span></span><br><span class="line"><span class="keyword">ssize_t</span></span><br><span class="line">file_read(struct File *f, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count, <span class="keyword">off_t</span> offset)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> r, bn;</span><br><span class="line">	<span class="keyword">off_t</span> pos;</span><br><span class="line">	<span class="keyword">char</span> *blk;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (offset &gt;= f-&gt;f_size)<span class="comment">//判断光标是不是文件尾</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	count = MIN(count, f-&gt;f_size - offset);<span class="comment">//最多能写这么多个</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (pos = offset; pos &lt; offset + count; ) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((r = file_get_block(f, pos / BLKSIZE, &amp;blk)) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		bn = MIN(BLKSIZE - pos % BLKSIZE, offset + count - pos);</span><br><span class="line">		memmove(buf, blk + pos % BLKSIZE, bn);<span class="comment">//读取</span></span><br><span class="line">		pos += bn;</span><br><span class="line">		buf += bn;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Write count bytes from buf into f, starting at seek position</span></span><br><span class="line"><span class="comment">// offset.  This is meant to mimic the standard pwrite function.</span></span><br><span class="line"><span class="comment">// Extends the file if necessary.</span></span><br><span class="line"><span class="comment">// Returns the number of bytes written, &lt; 0 on error.</span></span><br><span class="line"><span class="comment">//在光标后面写 count 个文件</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">file_write(struct File *f, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count, <span class="keyword">off_t</span> offset)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> r, bn;</span><br><span class="line">	<span class="keyword">off_t</span> pos;</span><br><span class="line">	<span class="keyword">char</span> *blk;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Extend file if necessary</span></span><br><span class="line">	<span class="keyword">if</span> (offset + count &gt; f-&gt;f_size)<span class="comment">//判断需不需要扩大文件</span></span><br><span class="line">		<span class="keyword">if</span> ((r = file_set_size(f, offset + count)) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (pos = offset; pos &lt; offset + count; ) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((r = file_get_block(f, pos / BLKSIZE, &amp;blk)) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		bn = MIN(BLKSIZE - pos % BLKSIZE, offset + count - pos);</span><br><span class="line">		memmove(blk + pos % BLKSIZE, buf, bn);<span class="comment">//复制 这个时候写完其实还是在内存里面，并没有写到磁盘</span></span><br><span class="line">		pos += bn;</span><br><span class="line">		buf += bn;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove a block from file f.  If it's not there, just silently succeed.</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error. 从f 里面删除块 第filebno</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">file_free_block(struct File *f, <span class="keyword">uint32_t</span> filebno)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="keyword">uint32_t</span> *ptr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = file_block_walk(f, filebno, &amp;ptr, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	<span class="keyword">if</span> (*ptr) &#123;</span><br><span class="line">		free_block(*ptr);</span><br><span class="line">		*ptr = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove any blocks currently used by file 'f',</span></span><br><span class="line"><span class="comment">// but not necessary for a file of size 'newsize'.</span></span><br><span class="line"><span class="comment">// For both the old and new sizes, figure out the number of blocks required,</span></span><br><span class="line"><span class="comment">// and then clear the blocks from new_nblocks to old_nblocks.</span></span><br><span class="line"><span class="comment">// If the new_nblocks is no more than NDIRECT, and the indirect block has</span></span><br><span class="line"><span class="comment">// been allocated (f-&gt;f_indirect != 0), then free the indirect block too.</span></span><br><span class="line"><span class="comment">// (Remember to clear the f-&gt;f_indirect pointer so you'll know</span></span><br><span class="line"><span class="comment">// whether it's valid!)</span></span><br><span class="line"><span class="comment">// Do not change f-&gt;f_size.</span></span><br><span class="line"><span class="comment">//把新大小到 旧的大小之间的块全部删除。如果不需要间接块了，把他也删了，不用修改文件大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">file_truncate_blocks(struct File *f, <span class="keyword">off_t</span> newsize)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="keyword">uint32_t</span> bno, old_nblocks, new_nblocks;</span><br><span class="line"></span><br><span class="line">	old_nblocks = (f-&gt;f_size + BLKSIZE - <span class="number">1</span>) / BLKSIZE;</span><br><span class="line">	new_nblocks = (newsize + BLKSIZE - <span class="number">1</span>) / BLKSIZE;</span><br><span class="line">	<span class="keyword">for</span> (bno = new_nblocks; bno &lt; old_nblocks; bno++)</span><br><span class="line">		<span class="keyword">if</span> ((r = file_free_block(f, bno)) &lt; <span class="number">0</span>)</span><br><span class="line">			cprintf(<span class="string">"warning: file_free_block: %e"</span>, r);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (new_nblocks &lt;= NDIRECT &amp;&amp; f-&gt;f_indirect) &#123;</span><br><span class="line">		free_block(f-&gt;f_indirect);</span><br><span class="line">		f-&gt;f_indirect = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the size of file f, truncating or extending as necessary. 设置文件大小</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">file_set_size(struct File *f, <span class="keyword">off_t</span> newsize)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (f-&gt;f_size &gt; newsize)</span><br><span class="line">		file_truncate_blocks(f, newsize);</span><br><span class="line">	f-&gt;f_size = newsize;</span><br><span class="line">	flush_block(f);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Flush the contents and metadata of file f out to disk.</span></span><br><span class="line"><span class="comment">// Loop over all the blocks in file.</span></span><br><span class="line"><span class="comment">// Translate the file block number into a disk block number</span></span><br><span class="line"><span class="comment">// and then check whether that disk block is dirty.  If so, write it out.</span></span><br><span class="line"><span class="comment">//刷新文件 写入到磁盘了</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">file_flush(struct File *f)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">uint32_t</span> *pdiskbno;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (f-&gt;f_size + BLKSIZE - <span class="number">1</span>) / BLKSIZE; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (file_block_walk(f, i, &amp;pdiskbno, <span class="number">0</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">		    pdiskbno == <span class="literal">NULL</span> || *pdiskbno == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		flush_block(diskaddr(*pdiskbno));</span><br><span class="line">	&#125;</span><br><span class="line">	flush_block(f);</span><br><span class="line">	<span class="keyword">if</span> (f-&gt;f_indirect)</span><br><span class="line">		flush_block(diskaddr(f-&gt;f_indirect));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sync the entire file system.  A big hammer. 刷新 整个文件系统</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">fs_sync(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; super-&gt;s_nblocks; i++)</span><br><span class="line">		flush_block(diskaddr(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终于看完了。看完之后告诉你，实际上没啥卵用。</p>
<h2 id="The-file-system-interface"><a href="#The-file-system-interface" class="headerlink" title="The file system interface"></a>The file system interface</h2><p>现在我们的文件系统环境已经具有必要的功能，我们必须让其他希望使用文件系统的用户环境可以访问文件系统。由于其他用户环境不能直接调用文件系统环境中的函数，因此我们将通过远程过程调用（RPC）即在JOS的IPC机制上封装构建的对文件系统环境的访问接口。如下图所示，对文件系统服务器的调用（比如说，read）：</p>
<center><table><tbody><tr><td>
<pre>      Regular env           FS env
   +---------------+   +---------------+
   |      read     |   |   file_read   |
   |   (lib/fd.c)  |   |   (fs/fs.c)   |
...|.......|.......|...|.......^.......|...............
   |       v       |   |       |       | RPC mechanism
   |  devfile_read |   |  serve_read   |
   |  (lib/file.c) |   |  (fs/serv.c)  |
   |       |       |   |       ^       |
   |       v       |   |       |       |
   |     fsipc     |   |     serve     |
   |  (lib/file.c) |   |  (fs/serv.c)  |
   |       |       |   |       ^       |
   |       v       |   |       |       |
   |   ipc_send    |   |   ipc_recv    |
   |       |       |   |       ^       |
   +-------|-------+   +-------|-------+
           |                   |
           +-------------------+
</pre>
</td></tr></tbody></table></center>

<p><strong>简单来讲，就是我要访问磁盘，先通过IPC发给另一个进程，然后另一个进程帮我访问，就是这样了</strong></p>
<p>虚线以下的所有内容都只是从常规用户环境到文件系统环境的读取请求的机制。从最开始，<code>read</code>适用于任何文件描述符，并且简单地分发到适当的设备读取函数，在这种情况下为<code>devfile_read</code>我们可以有更多的设备类型，如管道。<code>devfile_read</code>专门实现为读取磁盘文件。<code>lib/file.c</code>中的<code>devfile_read</code>和其他<code>devfile_*</code>函数实现了客户端<code>FS</code>操作，并且都以大致相同的方式工作，在<code>request</code>结构体中封装参数，调用<code>fsipc</code>发送<code>IPC</code>请求，并解包和返回结果。 <code>fsipc</code>函数简单地处理向服务器发送请求并接收回复的常见细节。</p>
<p>文件系统服务器代码可以在<code>fs/serv.c</code>中找到。它在<code>serve</code>函数中循环，无休止地通过<code>IPC</code>接收请求，将该请求分发到适当的处理函数，并通过IPC发送结果。在<code>read</code>示例中，<code>serve</code>函数将请求分发到<code>serve_read</code>，它将处理<code>read</code>请求指定的<code>IPC</code>细节，例如解包<code>request</code>结构体，最后调用<code>file_read</code>来实际执行文件读取。</p>
<p>回想一下，<code>JOS</code>的<code>IPC</code>机制允许用户环境发送一个32位数字，并且可选地共享一个页面。要从客户端发送请求到服务器，我们使用32位数字作为请求类型（文件系统服务器<code>RPC</code>也是像系统调用编号那样编号），并将参数存储在通过<code>IPC</code>共享页面的<code>Fsipc</code>联合类型中的<code>request</code>结构体中。在客户端，我们总是在<code>fsipcbuf</code>共享页面;在服务器端，我们将传入请求页映射到<code>fsreq</code>（<code>0x0ffff000</code>）。<br><strong>简单来说，32位作为请求类型，页放到fsreq，并且储存到request`结构体中</strong><br><img src="https://img-blog.csdnimg.cn/20200202094236753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODcxNDY2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>服务器还通过<code>IPC</code>发回响应。我们使用<code>32</code>位数字作为函数的返回码。对于大多数<code>RPC</code>，这些是他们返回的全部内容。<code>FSREQ_READ</code>和<code>FSREQ_STAT</code>也返回数据，它们只是将数据写入客户端发送请求的页面。无需在响应<code>IPC</code>中发送此页面，因为客户端首先与文件系统服务器共享。此外，在其回复中，<code>FSREQ_OPEN</code>与客户端共享一个新的<code>Fd page</code>。我们将很快返回到文件描述符页面。<br><code>练习5</code>和<code>练习6</code> 让我们实现<code>serve_read</code>和<code>serve_write</code>，<code>devfile_write</code>，我们直接一起看了。<br>在做之前了解一下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The file system server maintains three structures</span></span><br><span class="line"><span class="comment">// for each open file.</span></span><br><span class="line"><span class="comment">//服务器的三层 结构</span></span><br><span class="line"><span class="comment">// 1. The on-disk 'struct File' is mapped into the part of memory</span></span><br><span class="line"><span class="comment">//    that maps the disk.  This memory is kept private to the file</span></span><br><span class="line"><span class="comment">//    server.  //磁盘文件层  就是  struct File，前面我已经看过了</span></span><br><span class="line"><span class="comment">// 2. Each open file has a 'struct Fd' as well, which sort of</span></span><br><span class="line"><span class="comment">//    corresponds to a Unix file descriptor.  This 'struct Fd' is kept</span></span><br><span class="line"><span class="comment">//    on *its own page* in memory, and it is shared with any</span></span><br><span class="line"><span class="comment">//    environments that have the file open. </span></span><br><span class="line"><span class="comment">//	  每个开放的文件都有他自己的 描述 struct Fd，供所有环境使用</span></span><br><span class="line"><span class="comment">// 3. 'struct OpenFile' links these other two structures, and is kept</span></span><br><span class="line"><span class="comment">//    private to the file server.  The server maintains an array of</span></span><br><span class="line"><span class="comment">//    all open files, indexed by "file ID".  (There can be at most</span></span><br><span class="line"><span class="comment">//    MAXOPEN files open concurrently.)  The client uses file IDs to</span></span><br><span class="line"><span class="comment">//    communicate with the server.  File IDs are a lot like</span></span><br><span class="line"><span class="comment">//    environment IDs in the kernel.  Use openfile_lookup to translate</span></span><br><span class="line"><span class="comment">//    file IDs to struct OpenFile. struct OpenFile' 将两者联系起来，并保持私有</span></span><br><span class="line"><span class="comment">//    客服端通过id与 服务器通信，就像进程ID，使用 openfile_lookup 可以获得对应OpenFile</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> o_fileid;	<span class="comment">// file id</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">o_file</span>;</span>	<span class="comment">// mapped descriptor for open file</span></span><br><span class="line">	<span class="keyword">int</span> o_mode;		<span class="comment">// open mode</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">o_fd</span>;</span>	<span class="comment">// Fd page</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们先看看<code>read</code>是怎么执行的吧。</p>
<h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><p><code>read</code>一开始在<code>file.c</code> 里面调用<code>devfile_read</code>，我们看看怎么实现的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read at most 'n' bytes from 'fd' at the current position into 'buf'.</span></span><br><span class="line"><span class="comment">//cong fd 读n 个字节到buf 里面。</span></span><br><span class="line"><span class="comment">// Returns:</span></span><br><span class="line"><span class="comment">// 	The number of bytes successfully read.</span></span><br><span class="line"><span class="comment">// 	&lt; 0 on error.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span><br><span class="line">devfile_read(struct Fd *fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;	<span class="comment">// fd 应该是打开的文件，buf，保存读出来的值，n是读的大小  返回了读了几个值</span></span><br><span class="line">	<span class="comment">// Make an FSREQ_READ request to the file system server after</span></span><br><span class="line">	<span class="comment">// filling fsipcbuf.read with the request arguments.  The</span></span><br><span class="line">	<span class="comment">// bytes read will be written back to fsipcbuf by the file</span></span><br><span class="line">	<span class="comment">// system server.</span></span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	fsipcbuf.read.req_fileid = fd-&gt;fd_file.id; <span class="comment">//fsipcbuf 作为信息传递</span></span><br><span class="line">	fsipcbuf.read.req_n = n;</span><br><span class="line">	<span class="keyword">if</span> ((r = fsipc(FSREQ_READ, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)<span class="comment">//fsipc 就是分配函数</span></span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	assert(r &lt;= n);</span><br><span class="line">	assert(r &lt;= PGSIZE);</span><br><span class="line">	memmove(buf, fsipcbuf.readRet.ret_buf, r);<span class="comment">//返回的值在ret_buf 里面</span></span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">fsipc(<span class="keyword">unsigned</span> type, <span class="keyword">void</span> *dstva) <span class="comment">//这个时候dstva 应该是空</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">envid_t</span> fsenv;</span><br><span class="line">	<span class="keyword">if</span> (fsenv == <span class="number">0</span>)</span><br><span class="line">		fsenv = ipc_find_env(ENV_TYPE_FS);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(fsipcbuf) == PGSIZE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (debug)</span><br><span class="line">		cprintf(<span class="string">"[%08x] fsipc %d %08x\n"</span>, thisenv-&gt;env_id, type, *(<span class="keyword">uint32_t</span> *)&amp;fsipcbuf);</span><br><span class="line"></span><br><span class="line">	ipc_send(fsenv, type, &amp;fsipcbuf, PTE_P | PTE_W | PTE_U);</span><br><span class="line">	<span class="keyword">return</span> ipc_recv(<span class="literal">NULL</span>, dstva, <span class="literal">NULL</span>);<span class="comment">//目前来说 这个dstva 是个空值，所以实际上没啥返回值。 写回是通过共享页面实现的。共享了这个fsipcbuf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后就发送到了我们原本说的<code>serv.c</code>里面去了。<code>serv.c</code>最终运行了<code>serve</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">serve(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> req, whom;</span><br><span class="line">	<span class="keyword">int</span> perm, r;</span><br><span class="line">	<span class="keyword">void</span> *pg;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">//明显是个无限循环，所以这个进程值在这运行</span></span><br><span class="line">		perm = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//在这等待接收，我们现在这种情况，就是接收到了 刚才发送的那个</span></span><br><span class="line">		req = ipc_recv((<span class="keyword">int32_t</span> *) &amp;whom, fsreq, &amp;perm); </span><br><span class="line">		<span class="keyword">if</span> (debug)</span><br><span class="line">			cprintf(<span class="string">"fs req %d from %08x [page %08x: %s]\n"</span>,</span><br><span class="line">				req, whom, uvpt[PGNUM(fsreq)], fsreq);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// All requests must contain an argument page</span></span><br><span class="line">		<span class="keyword">if</span> (!(perm &amp; PTE_P)) &#123;</span><br><span class="line">			cprintf(<span class="string">"Invalid request from %08x: no argument page\n"</span>,</span><br><span class="line">				whom);</span><br><span class="line">			<span class="keyword">continue</span>; <span class="comment">// just leave it hanging...</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pg = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span> (req == FSREQ_OPEN) &#123;</span><br><span class="line">			r = serve_open(whom, (struct Fsreq_open*)fsreq, &amp;pg, &amp;perm);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (req &lt; ARRAY_SIZE(handlers) &amp;&amp; handlers[req]) &#123;</span><br><span class="line">		<span class="comment">//这个写法非常骚气，</span></span><br><span class="line">			r = handlers[req](whom, fsreq);<span class="comment">//这个时候根据req分配了函数。我们现在也就是serve_read</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			cprintf(<span class="string">"Invalid request code %d from %08x\n"</span>, req, whom);</span><br><span class="line">			r = -E_INVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		ipc_send(whom, r, pg, perm);</span><br><span class="line">		sys_page_unmap(<span class="number">0</span>, fsreq);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 所以我们就跑到了这个函数</span></span><br><span class="line"><span class="comment">// Read at most ipc-&gt;read.req_n bytes from the current seek position</span></span><br><span class="line"><span class="comment">// in ipc-&gt;read.req_fileid.  Return the bytes read from the file to</span></span><br><span class="line"><span class="comment">// the caller in ipc-&gt;readRet, then update the seek position.  Returns</span></span><br><span class="line"><span class="comment">// the number of bytes successfully read, or &lt; 0 on error.</span></span><br><span class="line"><span class="comment">//Fsipc 里面存了我们所需要的东西。</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">serve_read(<span class="keyword">envid_t</span> envid, <span class="keyword">union</span> Fsipc *ipc)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_read</span> *<span class="title">req</span> = &amp;<span class="title">ipc</span>-&gt;<span class="title">read</span>;</span><span class="comment">//请求</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsret_read</span> *<span class="title">ret</span> = &amp;<span class="title">ipc</span>-&gt;<span class="title">readRet</span>;</span><span class="comment">//返回的结果</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (debug)</span><br><span class="line">		cprintf(<span class="string">"serve_read %08x %08x %08x\n"</span>, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Lab 5: Your code here:</span></span><br><span class="line">	<span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> *<span class="title">o</span>;</span></span><br><span class="line">	<span class="comment">//openfile_lookup这个函数是查找 打开的文件</span></span><br><span class="line">	<span class="keyword">if</span> ((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;o)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	r=file_read(o-&gt;o_file,ret,req-&gt;req_n,o-&gt;o_fd-&gt;fd_offset);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;=<span class="number">0</span>)o-&gt;o_fd-&gt;fd_offset+=r;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><p>看完<code>read</code>，<code>write</code>也是一样的照搬就行了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write at most 'n' bytes from 'buf' to 'fd' at the current seek position.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns:</span></span><br><span class="line"><span class="comment">//	 The number of bytes successfully written.</span></span><br><span class="line"><span class="comment">//	 &lt; 0 on error.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span><br><span class="line">devfile_write(struct Fd *fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Make an FSREQ_WRITE request to the file system server.  Be</span></span><br><span class="line">	<span class="comment">// careful: fsipcbuf.write.req_buf is only so large, but</span></span><br><span class="line">	<span class="comment">// remember that write is always allowed to write *fewer*</span></span><br><span class="line">	<span class="comment">// bytes than requested.</span></span><br><span class="line">	<span class="comment">// LAB 5: Your code here</span></span><br><span class="line">	<span class="keyword">if</span> ( n &gt; <span class="keyword">sizeof</span> (fsipcbuf.write.req_buf)) </span><br><span class="line">		n = <span class="keyword">sizeof</span> (fsipcbuf.write.req_buf);</span><br><span class="line">	fsipcbuf.write.req_fileid = fd-&gt;fd_file.id;</span><br><span class="line">	fsipcbuf.write.req_n = n;</span><br><span class="line">	memmove(fsipcbuf.write.req_buf, buf, n); <span class="comment">//先把写的内容复制</span></span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_WRITE, <span class="literal">NULL</span>);<span class="comment">//然后发送过去</span></span><br><span class="line">	<span class="comment">//panic("devfile_write not implemented");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write req-&gt;req_n bytes from req-&gt;req_buf to req_fileid, starting at</span></span><br><span class="line"><span class="comment">// the current seek position, and update the seek position</span></span><br><span class="line"><span class="comment">// accordingly.  Extend the file if necessary.  Returns the number of</span></span><br><span class="line"><span class="comment">// bytes written, or &lt; 0 on error.</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">serve_write(<span class="keyword">envid_t</span> envid, struct Fsreq_write *req)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (debug)</span><br><span class="line">		cprintf(<span class="string">"serve_write %08x %08x %08x\n"</span>, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">	<span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> *<span class="title">o</span>;</span></span><br><span class="line">	<span class="keyword">if</span> ((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;o)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">		<span class="comment">//前面肯定一样的</span></span><br><span class="line">	r=file_write(o-&gt;o_file,req-&gt;req_buf,req-&gt;req_n,o-&gt;o_fd-&gt;fd_offset);<span class="comment">//不同的就只有这，这调用的是file_write</span></span><br><span class="line">	<span class="keyword">if</span>(r&gt;=<span class="number">0</span>)o-&gt;o_fd-&gt;fd_offset+=r;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">	<span class="comment">//panic("serve_write not implemented");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他函数的调用过程自行分析了。</p>
<h2 id="Spawning-Processes"><a href="#Spawning-Processes" class="headerlink" title="Spawning Processes"></a>Spawning Processes</h2><p>我们已经给你提供了生成一个新的用户环境<code>spawn</code>的代码（参见<code>lib/spawn.c</code>），将文件系统中的程序镜像加载到用户环境中，然后启动运行此程序的子环境。然后，父进程继续独立于该子进程运行。<code>spawn</code>函数就像<code>UNIX</code>中<code>fork</code>后面紧接着在子进程中执行<code>exec</code>。</p>
<p>我们实现了<code>spawn</code>而不是一个UNIX风格的<code>exe</code>c，因为在<code>exkernel</code>方式下，在用户空间不借助内核的特殊帮助中更容易实现<code>spawn</code>。想想你在用户空间实现<code>exec</code>时必须做什么，并确保你明白为什么更难。<br><code>练习7</code> 只要我们实现<code>sys_env_set_trapframe</code>。<br>我们先看看<code>spawn</code> 做了啥<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Spawn a child process from a program image loaded from the file system. </span></span><br><span class="line"><span class="comment">// 从文件加载了一个子进程</span></span><br><span class="line"><span class="comment">// prog: the pathname of the program to run. 文件路径</span></span><br><span class="line"><span class="comment">// argv: pointer to null-terminated array of pointers to strings, 参数</span></span><br><span class="line"><span class="comment">// 	 which will be passed to the child as its command-line arguments.</span></span><br><span class="line"><span class="comment">// Returns child envid on success, &lt; 0 on failure.</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">spawn(<span class="keyword">const</span> <span class="keyword">char</span> *prog, <span class="keyword">const</span> <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> elf_buf[<span class="number">512</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">child_tf</span>;</span></span><br><span class="line">	<span class="keyword">envid_t</span> child;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> fd, i, r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> *<span class="title">elf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>;</span></span><br><span class="line">	<span class="keyword">int</span> perm;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This code follows this procedure:</span></span><br><span class="line">	<span class="comment">//	后面虽然有一大堆，但是大部分没啥用</span></span><br><span class="line">	<span class="comment">//   - Open the program file.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//   - Read the ELF header, as you have before, and sanity check its</span></span><br><span class="line">	<span class="comment">//     magic number.  (Check out your load_icode!)</span></span><br><span class="line">	<span class="comment">//		读取ELF</span></span><br><span class="line">	<span class="comment">//   - Use sys_exofork() to create a new environment.</span></span><br><span class="line">	<span class="comment">//		创建进程</span></span><br><span class="line">	<span class="comment">//   - Set child_tf to an initial struct Trapframe for the child.</span></span><br><span class="line">	<span class="comment">//		设置tf</span></span><br><span class="line">	<span class="comment">//   - Call the init_stack() function above to set up</span></span><br><span class="line">	<span class="comment">//     the initial stack page for the child environment.</span></span><br><span class="line">	<span class="comment">//		初始化堆栈，有兴趣的自己看看看  后面都是写细节了</span></span><br><span class="line">	<span class="comment">//   - Map all of the program's segments that are of p_type</span></span><br><span class="line">	<span class="comment">//     ELF_PROG_LOAD into the new environment's address space.</span></span><br><span class="line">	<span class="comment">//     Use the p_flags field in the Proghdr for each segment</span></span><br><span class="line">	<span class="comment">//     to determine how to map the segment:</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//	* If the ELF flags do not include ELF_PROG_FLAG_WRITE,</span></span><br><span class="line">	<span class="comment">//	  then the segment contains text and read-only data.</span></span><br><span class="line">	<span class="comment">//	  Use read_map() to read the contents of this segment,</span></span><br><span class="line">	<span class="comment">//	  and map the pages it returns directly into the child</span></span><br><span class="line">	<span class="comment">//        so that multiple instances of the same program</span></span><br><span class="line">	<span class="comment">//	  will share the same copy of the program text.</span></span><br><span class="line">	<span class="comment">//        Be sure to map the program text read-only in the child.</span></span><br><span class="line">	<span class="comment">//        Read_map is like read but returns a pointer to the data in</span></span><br><span class="line">	<span class="comment">//        *blk rather than copying the data into another buffer.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//	* If the ELF segment flags DO include ELF_PROG_FLAG_WRITE,</span></span><br><span class="line">	<span class="comment">//	  then the segment contains read/write data and bss.</span></span><br><span class="line">	<span class="comment">//	  As with load_icode() in Lab 3, such an ELF segment</span></span><br><span class="line">	<span class="comment">//	  occupies p_memsz bytes in memory, but only the FIRST</span></span><br><span class="line">	<span class="comment">//	  p_filesz bytes of the segment are actually loaded</span></span><br><span class="line">	<span class="comment">//	  from the executable file - you must clear the rest to zero.</span></span><br><span class="line">	<span class="comment">//        For each page to be mapped for a read/write segment,</span></span><br><span class="line">	<span class="comment">//        allocate a page in the parent temporarily at UTEMP,</span></span><br><span class="line">	<span class="comment">//        read() the appropriate portion of the file into that page</span></span><br><span class="line">	<span class="comment">//	  and/or use memset() to zero non-loaded portions.</span></span><br><span class="line">	<span class="comment">//	  (You can avoid calling memset(), if you like, if</span></span><br><span class="line">	<span class="comment">//	  page_alloc() returns zeroed pages already.)</span></span><br><span class="line">	<span class="comment">//        Then insert the page mapping into the child.</span></span><br><span class="line">	<span class="comment">//        Look at init_stack() for inspiration.</span></span><br><span class="line">	<span class="comment">//        Be sure you understand why you can't use read_map() here.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//     Note: None of the segment addresses or lengths above</span></span><br><span class="line">	<span class="comment">//     are guaranteed to be page-aligned, so you must deal with</span></span><br><span class="line">	<span class="comment">//     these non-page-aligned values appropriately.</span></span><br><span class="line">	<span class="comment">//     The ELF linker does, however, guarantee that no two segments</span></span><br><span class="line">	<span class="comment">//     will overlap on the same page; and it guarantees that</span></span><br><span class="line">	<span class="comment">//     PGOFF(ph-&gt;p_offset) == PGOFF(ph-&gt;p_va).</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//   - Call sys_env_set_trapframe(child, &amp;child_tf) to set up the</span></span><br><span class="line">	<span class="comment">//     correct initial eip and esp values in the child.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//   - Start the child process running with sys_env_set_status().</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = open(prog, O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	fd = r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Read elf header</span></span><br><span class="line">	elf = (struct Elf*) elf_buf;</span><br><span class="line">	<span class="comment">//readn 在fd.c里面 可以看看底层调用了 dev_read 应该就是前面实现的那个函数</span></span><br><span class="line">	<span class="keyword">if</span> (readn(fd, elf_buf, <span class="keyword">sizeof</span>(elf_buf)) != <span class="keyword">sizeof</span>(elf_buf)<span class="comment">//读取elf 头部</span></span><br><span class="line">	    || elf-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">		close(fd);</span><br><span class="line">		cprintf(<span class="string">"elf magic %08x want %08x\n"</span>, elf-&gt;e_magic, ELF_MAGIC);</span><br><span class="line">		<span class="keyword">return</span> -E_NOT_EXEC;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create new child environment</span></span><br><span class="line">	<span class="keyword">if</span> ((r = sys_exofork()) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	child = r;</span><br><span class="line">	<span class="comment">//复制进程</span></span><br><span class="line">	<span class="comment">// Set up trap frame, including initial stack.初始化tf</span></span><br><span class="line">	child_tf = envs[ENVX(child)].env_tf;</span><br><span class="line">	child_tf.tf_eip = elf-&gt;e_entry;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = init_stack(child, argv, &amp;child_tf.tf_esp)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set up program segments as defined in ELF header. 这个很眼熟吧</span></span><br><span class="line">	ph = (struct Proghdr*) (elf_buf + elf-&gt;e_phoff);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elf-&gt;e_phnum; i++, ph++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ph-&gt;p_type != ELF_PROG_LOAD)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		perm = PTE_P | PTE_U;</span><br><span class="line">		<span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PROG_FLAG_WRITE)</span><br><span class="line">			perm |= PTE_W;</span><br><span class="line">		<span class="keyword">if</span> ((r = map_segment(child, ph-&gt;p_va, ph-&gt;p_memsz,</span><br><span class="line">				     fd, ph-&gt;p_filesz, ph-&gt;p_offset, perm)) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> error;</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line">	fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Copy shared library state.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = copy_shared_pages(child)) &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">"copy_shared_pages: %e"</span>, r);</span><br><span class="line"></span><br><span class="line">	child_tf.tf_eflags |= FL_IOPL_3;   <span class="comment">// devious: see user/faultio.c</span></span><br><span class="line">	<span class="keyword">if</span> ((r = sys_env_set_trapframe(child, &amp;child_tf)) &lt; <span class="number">0</span>)<span class="comment">//在这个地方调用了sys_env_set_trapframe 我们可以看到 child_tf 前面已经帮我们设置好了。</span></span><br><span class="line">		panic(<span class="string">"sys_env_set_trapframe: %e"</span>, r);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = sys_env_set_status(child, ENV_RUNNABLE)) &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">"sys_env_set_status: %e"</span>, r);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> child;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">	sys_env_destroy(child);</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为传进来的<code>tf</code>已经设置好了，所以我们直接改就行了<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set envid's trap frame to 'tf'.</span></span><br><span class="line"><span class="comment">// tf is modified to make sure that user environments always run at code</span></span><br><span class="line"><span class="comment">// protection level 3 (CPL 3), interrupts enabled, and IOPL of 0.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//	-E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//		or the caller doesn't have permission to change envid.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_trapframe(<span class="keyword">envid_t</span> envid, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">	<span class="comment">// Remember to check whether the user has supplied us with a good</span></span><br><span class="line">	<span class="comment">// address!</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">child</span>;</span></span><br><span class="line">	<span class="keyword">if</span>((envid2env(envid,&amp;child,<span class="number">1</span>))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	&#125;<span class="comment">//判断进程id 是不是有效的</span></span><br><span class="line">	child-&gt;env_tf=*tf;<span class="comment">//直接指过去</span></span><br><span class="line">	child-&gt;env_tf.tf_cs |= <span class="number">0x3</span>; <span class="comment">//修改一下提示要求的值</span></span><br><span class="line">	child-&gt;env_tf.tf_eflags &amp;=  (~FL_IOPL_MASK);</span><br><span class="line">	child-&gt;env_tf.tf_eflags |= FL_IF;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//panic("sys_env_set_trapframe not implemented");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>设置完后记得添加<code>syscall</code>.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">case</span> SYS_env_set_trapframe:</span><br><span class="line"><span class="keyword">return</span> sys_env_set_trapframe((<span class="keyword">envid_t</span>)a1,(struct Trapframe*)a2);</span><br></pre></td></tr></table></figure></p>
<p>说一下我测试的时候发现，测试文件里面有一个单词和代码不一样。<br>在<code>grade-lab5</code>里面有一个<code>environments</code>单词和代码里面差了一个<code>a</code>,我修改了一下，如果没错的话，当我没说。<code>environments</code>和<code>environmeants</code>搜了一下单词意思好像是一样的。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@test(<span class="number">10</span>, <span class="string">"spawn via spawnhello"</span>)</span><br><span class="line">def test_spawn():</span><br><span class="line">    r.user_test(<span class="string">"spawnhello"</span>)</span><br><span class="line">    r.match('i am parent environment 00001001',</span><br><span class="line">            'hello, world',</span><br><span class="line">            'i am environment 00001002',</span><br><span class="line">            'No runnable environmeants in the system!')</span><br></pre></td></tr></table></figure></p>
<h2 id="Sharing-library-state-across-fork-and-spawn"><a href="#Sharing-library-state-across-fork-and-spawn" class="headerlink" title="Sharing library state across fork and spawn"></a>Sharing library state across fork and spawn</h2><p>UNIX文件描述符是一个普遍的概念，它包括管道，控制台I/O等。在JOS中，每一个这样的设备类型的都具有相应的<code>struct Dev</code>，该结构体中有指向实现该设备类型读/写等操作的函数指针。<code>lib/fd.c</code>在<code>struct Dev</code>之上实现了一般的类UNIX文件描述符接口。每个<code>struct Fd</code>表示其设备类型，并且<code>lib/fd.c</code>中的大多数函数简单地将操作分发到合适的<code>struct Dev</code>中的函数。</p>
<p><code>lib/fd.c</code>还在每个应用程序环境的地址空间虚拟地址<code>FDTABLE</code>开始中处护文件描述符表区域。该区域为应用程序可以一次能最多打开<code>MAXFD</code>（当前为32）个文件描述符的每个文件描述符保留一个页面（4KB）大小的地址空间。在任何时候，当且仅当相应的文件描述符被使用时，文件描述符表页会被映射。每个文件描述符还有一个在<code>FILEDATA</code>开始的区域可选的“数据页”，如果选择了数据区域，设备就可以使用该区域。</p>
<p>我们想在<code>fork</code>和<code>spawn</code>之间共享文件描述符状态，但文件描述符状态保存在用户空间内存中。现在，<code>fork</code>完成之后，内存将被标记为<code>copy-on-write</code>，所以状态将被重复而不是共享。 （这意味着环境将无法在他们没有打开自己的文件中查找，并且管道将在<code>fork</code>之后也不能运行。）<code>spawn</code>完成之后，内存将被丢弃，完全不会被复制。（有效地，<code>spawn</code>的用户环境在没有打开的文件描述符状态下开始运行。）</p>
<p>我们将更改<code>fork</code>，让<code>fork</code>时了解某些区域的内存是由“库操作系统”使用，应始终共享。而不是在某个地方硬编码一个区域列表，我们将在页表项中设置一个未使用的位（就像我们在<code>fork</code>中使用<code>PTE_COW</code>位一样）来确定共享区域。</p>
<p>我们已经在<code>inc/lib.h</code>中定义了一个新的<code>PTE_SHARE</code>位。该位是Intel和AMD手册中标记为“可用于软件使用”的三个PTE位之一。我们约定，如果一个页表项中该位置位，应该在<code>fork</code>和<code>spawn</code>中直接将该PTE从父对象复制到子环境。请注意，这不同于标记PTE为copy-on-write：如第一段所述，我们要确保共享页面更新。<br><strong>简单来说，就是我们定义了一个PTE_SHARE位，表示分享这个页，分享的这个页不用写时复制。</strong><br><code>练习8</code> 就是修改了这些东西。添加一个<code>if</code>就行了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">duppage(<span class="keyword">envid_t</span> envid, <span class="keyword">unsigned</span> pn)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="keyword">void</span>* vaddr=(<span class="keyword">void</span>*)(pn*PGSIZE);</span><br><span class="line">	<span class="keyword">if</span>(uvpt[pn]&amp;PTE_SHARE)&#123;<span class="comment">//多添加这个if就行了</span></span><br><span class="line">		<span class="keyword">if</span>((r=sys_page_map(<span class="number">0</span>,vaddr,envid,vaddr,uvpt[pn]&amp;PTE_SYSCALL))&lt;<span class="number">0</span>)<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>((uvpt[pn] &amp; PTE_W) || (uvpt[pn] &amp; PTE_COW))&#123;</span><br><span class="line">		<span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, vaddr, envid, vaddr, PTE_P | PTE_U | PTE_COW)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, vaddr, <span class="number">0</span>, vaddr, PTE_P | PTE_U | PTE_COW)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>((r = sys_page_map(<span class="number">0</span>, vaddr, envid, vaddr, PTE_P | PTE_U)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//panic("duppage not implemented");</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外一个直接暴力找就行了没啥太大的区别。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Copy the mappings for shared pages into the child address space.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">copy_shared_pages(<span class="keyword">envid_t</span> child)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">	<span class="keyword">int</span> r=<span class="number">0</span>,pn=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (pn=PGNUM(UTEXT); pn&lt;PGNUM(USTACKTOP); pn++)&#123;</span><br><span class="line">        <span class="keyword">if</span> ((uvpd[pn &gt;&gt; <span class="number">10</span>] &amp; PTE_P) &amp;&amp;uvpt[pn] &amp; PTE_SHARE)</span><br><span class="line">            <span class="keyword">if</span> ( (r = sys_page_map(thisenv-&gt;env_id, (<span class="keyword">void</span> *)(pn*PGSIZE), child, (<span class="keyword">void</span> *)(pn*PGSIZE), uvpt[pn] &amp; PTE_SYSCALL )) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="The-keyboard-interface"><a href="#The-keyboard-interface" class="headerlink" title="The keyboard interface"></a>The keyboard interface</h2><p>倒着之后，实验让我们做的东西非常简单，但是又有好多东西还没搞清楚。</p>
<p>为了使<code>shell</code>工作，我们需要一种方法在<code>shell</code>中输入。 QEMU一直在显示我们在CGA显示器和串行端口的输出内容，但到目前为止，我们只能在内核监视器中输入。在QEMU中，在图形窗口中的输入显示为从键盘输入到JOS，从控制台的输入显示为串行端口上的字符。<code>kern/console.c</code>包含键盘和串行驱动程序，从<code>lab1</code>开始内核监视器就一直在使用，但现在你需要将它们附加到系统的其余部分。<br><code>练习9</code>让我们添加<code>kbd_intr</code>处理<code>IRQ_OFFSET+IRQ_KBD</code>和 <code>serial_intr</code>处理<code>IRQ_OFFSET+IRQ_SERIAL</code>。<br>直接在<code>trap_dispatch</code>添加就行了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> IRQ_OFFSET+IRQ_KBD:&#123;</span><br><span class="line">	lapic_eoi();</span><br><span class="line">	kbd_intr();</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> IRQ_OFFSET+IRQ_SERIAL:&#123;</span><br><span class="line">	lapic_eoi();</span><br><span class="line">	serial_intr();</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们在<code>lib/console.c</code>中为你实现了控制台输入/输出文件类型。<code>kbd_intr</code>和<code>serial_intr</code>用最近读取的输入填充缓冲区，控制台文件类型清空缓冲区（默认情况下，控制台文件类型用于<code>stdin/stdout</code>，除非用户重定向它们）。</p>
<h2 id="The-Shell"><a href="#The-Shell" class="headerlink" title="The Shell"></a>The Shell</h2><p>运行<code>make run-icode</code>或<code>make run-icode-nox</code>命令。这将运行您的内核并启动<code>user/icode</code>。<code>icode spawn init</code>，它将控制台设置为文件描述符0和1（标准输入和标准输出）。然后<code>spawn sh</code>，<code>shell</code>程序。你应该能够运行以下命令：</p>
<p>echo hello world | cat<br>cat lorem |cat<br>cat lorem |num<br>cat lorem |num |num |num |num |num<br>lsfd</p>
<p>请注意，用户库例程<code>cprintf</code>直接打印到控制台，而不使用文件描述符代码。这适用于调试，但不适合与其他程序进行管道通信。要将输出打印到特定文件描述符（例如，<code>1</code>，标准输出），请使用<code>fprintf（1，“...”，...）</code>。 <code>printf（“...”，...）</code>是打印到<code>FD 1</code>的快捷方式。有关示例，请参阅<code>user/lsfd.c</code>。<br><code>练习10</code> 让我们实现<code>user/sh.c</code>里面的<code>&lt;</code>重定向,里面就有<code>&gt;</code>的重定向，复制一下就没了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LAB 5: Your code here.</span></span><br><span class="line"><span class="keyword">if</span> ((fd = open(t, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	cprintf(<span class="string">"open %s for write: %e"</span>, t, fd);</span><br><span class="line">	<span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (fd != <span class="number">1</span>) &#123;</span><br><span class="line">	dup(fd, <span class="number">0</span>);</span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里我们就做完了所有练习了。<br>然而我并不知道后面发生了什么。<br>所以我们来分析用户文件。<br>直接<code>make qemu</code>,会输出下面这些东西。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*在这之前的一大堆 都是 内核，和文件系统造成的*/</span></span><br><span class="line">icode: read /motd</span><br><span class="line">This is /motd, the message of the day.</span><br><span class="line"></span><br><span class="line">Welcome to the JOS kernel, now with a file system!</span><br><span class="line"></span><br><span class="line">icode: close /motd</span><br><span class="line">icode: spawn /init</span><br><span class="line">icode: exiting</span><br><span class="line">init: running</span><br><span class="line">init: data seems okay</span><br><span class="line">init: bss seems okay</span><br><span class="line">init: args: 'init' 'initarg1' 'initarg2'</span><br><span class="line">init: running sh</span><br><span class="line">init: starting sh</span><br></pre></td></tr></table></figure></p>
<p>我们首先进入了<code>user/icode.c</code>这个文件里面的<code>umain</code>，也就是内核里面的那个环境创建运行的那个。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">umain(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> fd, n, r;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">512</span>+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	binaryname = <span class="string">"icode"</span>;</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">"icode startup\n"</span>);</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">"icode: open /motd\n"</span>);<span class="comment">//这几个值都看到了</span></span><br><span class="line">	<span class="keyword">if</span> ((fd = open(<span class="string">"/motd"</span>, O_RDONLY)) &lt; <span class="number">0</span>)<span class="comment">//打开根目录下的/motd</span></span><br><span class="line">		panic(<span class="string">"icode: open /motd: %e"</span>, fd);</span><br><span class="line">	<span class="comment">//我门可以找到find 找到motd 文件在 ./fs/ 目录下，所以fs 就是我们的根目录</span></span><br><span class="line">	cprintf(<span class="string">"icode: read /motd\n"</span>);</span><br><span class="line">	<span class="keyword">while</span> ((n = read(fd, buf, <span class="keyword">sizeof</span> buf<span class="number">-1</span>)) &gt; <span class="number">0</span>)<span class="comment">//读取了buf 个字符</span></span><br><span class="line">		sys_cputs(buf, n);<span class="comment">//输出了他</span></span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">"icode: close /motd\n"</span>);</span><br><span class="line">	close(fd);</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">"icode: spawn /init\n"</span>);</span><br><span class="line">	<span class="keyword">if</span> ((r = spawnl(<span class="string">"/init"</span>, <span class="string">"init"</span>, <span class="string">"initarg1"</span>, <span class="string">"initarg2"</span>, (<span class="keyword">char</span>*)<span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">"icode: spawn /init: %e"</span>, r);</span><br><span class="line">	<span class="comment">//用spawnl创建了init ，所以接下来我们去了init</span></span><br><span class="line">	cprintf(<span class="string">"icode: exiting\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> msg1[<span class="number">5000</span>];</span><br><span class="line">	<span class="keyword">char</span> msg2[<span class="number">1000</span>];</span><br><span class="line">&#125; data = &#123;</span><br><span class="line">	<span class="string">"this is initialized data"</span>,</span><br><span class="line">	<span class="string">"so is this"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> bss[<span class="number">6000</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">sum(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i, tot = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		tot ^= i * s[i];</span><br><span class="line">	<span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">umain(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i, r, x, want;</span><br><span class="line">	<span class="keyword">char</span> args[<span class="number">256</span>];</span><br><span class="line">	<span class="comment">//前面一大堆是初始化用的</span></span><br><span class="line">	cprintf(<span class="string">"init: running\n"</span>);</span><br><span class="line"></span><br><span class="line">	want = <span class="number">0xf989e</span>;</span><br><span class="line">	<span class="keyword">if</span> ((x = sum((<span class="keyword">char</span>*)&amp;data, <span class="keyword">sizeof</span> data)) != want)</span><br><span class="line">		cprintf(<span class="string">"init: data is not initialized: got sum %08x wanted %08x\n"</span>,</span><br><span class="line">			x, want);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cprintf(<span class="string">"init: data seems okay\n"</span>);</span><br><span class="line">	<span class="keyword">if</span> ((x = sum(bss, <span class="keyword">sizeof</span> bss)) != <span class="number">0</span>)</span><br><span class="line">		cprintf(<span class="string">"bss is not initialized: wanted sum 0 got %08x\n"</span>, x);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cprintf(<span class="string">"init: bss seems okay\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// output in one syscall per line to avoid output interleaving </span></span><br><span class="line">	<span class="built_in">strcat</span>(args, <span class="string">"init: args:"</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">		<span class="built_in">strcat</span>(args, <span class="string">" '"</span>);</span><br><span class="line">		<span class="built_in">strcat</span>(args, argv[i]);</span><br><span class="line">		<span class="built_in">strcat</span>(args, <span class="string">"'"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cprintf(<span class="string">"%s\n"</span>, args);</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">"init: running sh\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// being run directly from kernel, so no file descriptors open yet</span></span><br><span class="line">	close(<span class="number">0</span>);<span class="comment">//因为根目录是在内二上，所以没有文件打开。</span></span><br><span class="line">	<span class="keyword">if</span> ((r = opencons()) &lt; <span class="number">0</span>)<span class="comment">//打开控制台？？</span></span><br><span class="line">		panic(<span class="string">"opencons: %e"</span>, r);</span><br><span class="line">	<span class="keyword">if</span> (r != <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">"first opencons used fd %d"</span>, r);</span><br><span class="line">	<span class="keyword">if</span> ((r = dup(<span class="number">0</span>, <span class="number">1</span>)) &lt; <span class="number">0</span>)<span class="comment">//把0复制到了 1</span></span><br><span class="line">		panic(<span class="string">"dup: %e"</span>, r);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		cprintf(<span class="string">"init: starting sh\n"</span>);</span><br><span class="line">		r = spawnl(<span class="string">"/sh"</span>, <span class="string">"sh"</span>, (<span class="keyword">char</span>*)<span class="number">0</span>);<span class="comment">//这个时候又跑了sh</span></span><br><span class="line">		<span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			cprintf(<span class="string">"init: spawn sh: %e\n"</span>, r);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		wait(r);<span class="comment">//然后无线循环这个程序</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sh</code>里面就是我们的<code>shell</code>了，告辞。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/MIT6-828/" rel="tag"># MIT6.828</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div class="social_share">
            
            
              <div id="needsharebutton-postbottom">
                <span class="btn">
                  <i class="fa fa-share-alt" aria-hidden="true"></i>
                </span>
              </div>
            
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/02/18/MIT-6.828-(四)-Lab-4-Preemptive-Multitasking/" rel="next" title="MIT6.828(四)Lab4:Preemptive Multitasking">
                <i class="fa fa-chevron-left"></i> MIT6.828(四)Lab4:Preemptive Multitasking
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/02/18/MIT-6.828-(六)-Lab-6-Network-Driver-(default-final-project)/" rel="prev" title="MIT6.828(六)Lab6:Network Driver(default final project)">
                MIT6.828(六)Lab6:Network Driver(default final project) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      
        <div id="gitment-container"></div>
      
    </div>

  




        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/tou.jpeg" alt="尘">
            
              <p class="site-author-name" itemprop="name">尘</p>
              <p class="site-description motion-element" itemprop="description">做自己不会做的事被称之为学习</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">123</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">56</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/ETBUBBLE" title="GitHub &rarr; https://github.com/ETBUBBLE" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/qq_40871466" title="https://blog.csdn.net/qq_40871466" rel="noopener" target="_blank">csdn</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=549159342&auto=1&height=66"></iframe>
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab-5-File-system-Spawn-and-Shell"><span class="nav-number">1.</span> <span class="nav-text">Lab 5: File system, Spawn and Shell</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#closeall"><span class="nav-number">1.0.1.</span> <span class="nav-text">closeall()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#File-system-preliminaries"><span class="nav-number">1.1.</span> <span class="nav-text">File system preliminaries</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#On-Disk-File-System-Structure"><span class="nav-number">1.2.</span> <span class="nav-text">On-Disk File System Structure</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sectors-and-Blocks"><span class="nav-number">1.3.</span> <span class="nav-text">Sectors and Blocks</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Superblocks"><span class="nav-number">1.4.</span> <span class="nav-text">Superblocks</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#File-Meta-data"><span class="nav-number">1.5.</span> <span class="nav-text">File Meta-data</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Directories-versus-Regular-Files"><span class="nav-number">1.6.</span> <span class="nav-text">Directories versus Regular Files</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-File-System"><span class="nav-number">1.7.</span> <span class="nav-text">The File System</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Disk-Access"><span class="nav-number">1.8.</span> <span class="nav-text">Disk Access</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Question-1"><span class="nav-number">1.8.1.</span> <span class="nav-text">Question 1</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Block-Cache"><span class="nav-number">1.9.</span> <span class="nav-text">The Block Cache</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ide-c"><span class="nav-number">1.10.</span> <span class="nav-text">ide.c</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bc"><span class="nav-number">1.10.1.</span> <span class="nav-text">bc</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Block-Bitmap"><span class="nav-number">1.11.</span> <span class="nav-text">The Block Bitmap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#File-Operations"><span class="nav-number">1.12.</span> <span class="nav-text">File Operations</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#file-block-walk和file-get-block"><span class="nav-number">1.12.1.</span> <span class="nav-text">file_block_walk和file_get_block</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fs-c"><span class="nav-number">1.12.2.</span> <span class="nav-text">fs.c</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-file-system-interface"><span class="nav-number">1.13.</span> <span class="nav-text">The file system interface</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#read"><span class="nav-number">1.13.1.</span> <span class="nav-text">read</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#write"><span class="nav-number">1.13.2.</span> <span class="nav-text">write</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spawning-Processes"><span class="nav-number">1.14.</span> <span class="nav-text">Spawning Processes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sharing-library-state-across-fork-and-spawn"><span class="nav-number">1.15.</span> <span class="nav-text">Sharing library state across fork and spawn</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-keyboard-interface"><span class="nav-number">1.16.</span> <span class="nav-text">The keyboard interface</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Shell"><span class="nav-number">1.17.</span> <span class="nav-text">The Shell</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <link rel="stylesheet" href="/live2d/css/live2d.css">
      <div id="landlord">
          <div class="message" style="opacity:0"></div>
          <canvas id="live2d" width="280" height="250" class="live2d"></canvas>
          <div class="hide-button">隐藏</div>
      </div>
      <script type="text/javascript" src="https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
      <script type="text/javascript">
          var message_Path = '/live2d/'
          var home_Path = 'https://your.com/'
      </script>
      <script type="text/javascript" src="/live2d/js/live2d.js"></script>
      <script type="text/javascript" src="/live2d/js/message.js"></script>
      <script type="text/javascript">
          loadlive2d("live2d", "/live2d/model/tia/model.json");
      </script>
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">尘</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">810k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">12:16</span>
  
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.0.0</div>
-->



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
      <div id="needsharebutton-float">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.0"></script>

  <script src="/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.0"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.0"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.0"></script>
<script src="/js/src/post-details.js?v=7.0.0"></script>



  


  <script src="/js/src/bootstrap.js?v=7.0.0"></script>


  
  


  
    <!-- LOCAL: You can save these files to your site and update links -->

  
     <!-- <script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js"></script> -->
<script src="https://billts.site/js/gitment.js"></script>

<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css"/> -->
<link rel="stylesheet" href="https://billts.site/extra_css/gitment.css">

<!-- END LOCAL -->

<style>
#gitment-container a {
  border-bottom: none;
}

</style>

<script>
  function renderGitment() {

    var gitment = new Gitment({
      id: '1582033466000',
      owner: 'ETBUBBLE',
      repo: 'ETBUBBLE.github.io',
      
      oauth: {
      
      
        client_secret: '0fd4f83bc7834795c0575404ee5c7a2c82067749',
      
        client_id: '008c7d3ffa7d973b8437'
      }
    });
    gitment.render('gitment-container');
  }

  
    renderGitment();
  
</script>

  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  
    
      <script type="text/x-mathjax-config">
  

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });
  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') { next = next.nextSibling }
        if (next && next.nodeName.toLowerCase() === 'br') { next.parentNode.removeChild(next) }
      }
    });
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
      for (i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<style>
.MathJax_Display {
  overflow-x: scroll;
  overflow-y: hidden;
}
</style>

    
  


  

  

  

  
  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>
  <script>
    
      pbOptions = {};
      
        pbOptions.iconStyle = "box";
      
        pbOptions.boxForm = "horizontal";
      
        pbOptions.position = "bottomCenter";
      
        pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
      flOptions = {};
      
        flOptions.iconStyle = "box";
      
        flOptions.boxForm = "horizontal";
      
        flOptions.position = "middleRight";
      
        flOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script>


  

  

  

  

  

  

</body>
</html>

---
title: CCPC2018中国大学生程序设计竞赛 - 网络选拔赛
date: 2018-08-27 08:49:07
tags: CSDN迁移
---
  [HDU 6438](http://acm.hdu.edu.cn/showproblem.php?pid=6438)

 
# 1001 Buy and Resell

 **Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others)  
 Total Submission(s): 2282 Accepted Submission(s): 359**  
  
 

 **Problem Description**

 The Power Cube is used as a stash of Exotic Power. There are n cities numbered 1,2,…,n where allowed to trade it. The trading price of the Power Cube in the i-th city is ai dollars per cube. Noswal is a foxy businessman and wants to quietly make a fortune by buying and reselling Power Cubes. To avoid being discovered by the police, Noswal will go to the i-th city and choose exactly one of the following three options on the i-th day:  
  
 1. spend ai dollars to buy a Power Cube  
 2. resell a Power Cube and get ai dollars if he has at least one Power Cube  
 3. do nothing  
  
 Obviously, Noswal can own more than one Power Cubes at the same time. After going to the n cities, he will go back home and stay away from the cops. He wants to know the maximum profit he can earn. In the meanwhile, to lower the risks, he wants to minimize the times of trading (include buy and sell) to get the maximum profit. Noswal is a foxy and successful businessman so you can assume that he has infinity money at the beginning.

 

 

 **Input**

 There are multiple test cases. The first line of input contains a positive integer T (T≤250), indicating the number of test cases. For each test case:  
 The first line has an integer n. (1≤n≤105)  
 The second line has n integers a1,a2,…,an where ai means the trading price (buy or sell) of the Power Cube in the i-th city. (1≤ai≤109)  
 It is guaranteed that the sum of all n is no more than 5×105.

 

 

 **Output**

 For each case, print one line with two integers —— the maximum profit and the minimum times of trading to get the maximum profit.

 

 

 **Sample Input**

 
```
  
```
 3 4 1 2 10 9 5 9 5 9 10 5 2 2 1

 

 

 **Sample Output**

 
```
  
```
 16 4 5 2 0 0

 **_Hint_**

 In the first case, he will buy in 1, 2 and resell in 3, 4. _profit = - 1 - 2 + 10 + 9 = 16_ In the second case, he will buy in 2 and resell in 4. _profit = - 5 + 10 = 5_ In the third case, he will do nothing and earn nothing. _profit = 0_

 贪心，每次保留买，和卖两种状态，如果一种买了，说明后面有一定有可以卖的，从前往后扫每次取前面最小的，如果遇见能从卖了的里面取，总次数不用+2，如果是从买了的里面取，总交易次数+2；

 用，0，1分别代表买和卖。

 
```
 #include<iostream>
#include<algorithm>
#include<cstring>
#include<string>
#include<vector>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<queue>
#include<map>
#include<set>
#include<stack>

using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> P;

#define bug printf("*********\n");
#define debug(x) cout<<"["<<x<<"]" <<endl;
#define mid (l+r)/2
#define chl 2*k+1
#define chr 2*k+2
#define lson l,mid,chl
#define rson mid,r,chr
#define pb push_back
#define mem(a,b) memset(a,b,sizeof(a));

const long long mod=1e9+7;
const int maxn=5e5+5;
const int INF=0x7fffffff;
const int inf=0x3f3f3f3f;
const double eps=1e-8;
int a[maxn];
int n;
priority_queue<P>q;
ll sum=0,ans=0;
int main() {
    int t;
    cin>>t;
    while(t--) {
        sum=0;
        ans=0;
        scanf("%d",&n);
        while(q.size())q.pop();
        for(int i=0; i<n; i++) {
            scanf("%d",&a[i]);
            q.push(P(-a[i],0));
            q.push(P(-a[i],1));
            int temp=a[i]+q.top().first;
            if(q.top().second==0) {
                ans+=2;
            }
            q.pop();
            sum+=temp;
        }
        printf("%lld %lld\n",sum,ans);
    }
    return 0;
}
```
 [HDU 6441 ](http://acm.hdu.edu.cn/showproblem.php?pid=6441)

 
# 1004 Find Integer

 更具费马大定理，n>2 和等于 0误解，n=1，直接输出 1 a+1;

 n=2 的时候，就是一个勾股定理，a^2=c*c-b*b = (c-b)*(c+b) 如果A为偶数 c-b=2 c+b=a*a/2 ,如果a为奇数 c-b=1 c+b=a*a

 解个方程就行了。

 
```
 #include<iostream>
#include<algorithm>
#include<cstring>
#include<string>
#include<vector>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<queue>
#include<map>
#include<set>
#include<stack>

using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> P;

#define bug printf("*********\n");
#define debug(x) cout<<"["<<x<<"]" <<endl;
#define mid (l+r)/2
#define chl 2*k+1
#define chr 2*k+2
#define lson l,mid,chl
#define rson mid,r,chr
#define pb push_back
#define mem(a,b) memset(a,b,sizeof(a));

const long long mod=1e9+7;
const int maxn=5e5+5;
const int INF=0x7fffffff;
const int inf=0x3f3f3f3f;
const double eps=1e-8;


int main() {
    int t;
    cin>>t;
    while(t--) {
        ll n,k;
        scanf("%lld%lld",&k,&n);
        if(k==0||k>2)puts("-1 -1");
        else if(k==1) {
            if(n==1e9)puts("-1 -1");
            else printf("%lld %lld\n",1,n+1);
        } else {
            ll temp=n;
            if(n==1||n==2)puts("-1 -1");
            else if(n&1) {
                ll c=(temp*temp+1)/2;
                ll b=c-1;
                if(c>1e9)puts("-1 -1");
                else {
                    printf("%lld %lld\n",b,c);
                }
            } else {
                ll c=n*n/4+1,b=c-2;
                if(c>1e9)puts("-1 -1");
                else  printf("%lld %lld\n",b,c);
            }
        }
    }
    return 0;
}

```
 [HDU 6446](http://acm.hdu.edu.cn/showproblem.php?pid=6446)

 
# 1009 Tree and Permutation

 直接算一条边左右两边点的个数，全排列种，每条边经过的次数等于 ，2*C,(n-m)*(m)*(n-1)！次，一个DFS求出他根节点的数量为m，前一条边 权值为C,求一下所有数的和，预处理阶乘。

 
```
 #include<iostream>
#include<algorithm>
#include<cstring>
#include<string>
#include<vector>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<queue>
#include<map>
#include<set>
#include<stack>

using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> P;

#define bug printf("*********\n");
#define debug(x) cout<<"["<<x<<"]" <<endl;
#define mid (l+r)/2
#define chl 2*k+1
#define chr 2*k+2
#define lson l,mid,chl
#define rson mid,r,chr
#define pb push_back
#define mem(a,b) memset(a,b,sizeof(a));

const long long mod=1e9+7;
const int maxn=5e5+5;
const int INF=0x7fffffff;
const int inf=0x3f3f3f3f;
const double eps=1e-8;
int n;
struct edge {
    int to,cost,next;
} eg[maxn];
int head[maxn],tot;
void init() {
    mem(head,-1);
    tot=0;
}
void add(int u,int v,int c) {
    eg[tot].to=v;
    eg[tot].cost=c;
    eg[tot].next=head[u];
    head[u]=tot++;
}
ll k[maxn];
ll c[maxn],num[maxn];
int dfs(int r,int p,int v) {
    c[r]=v%mod;
    int ans=1;
    for(int i=head[r]; i!=-1; i=eg[i].next) {
        if(eg[i].to!=p) {
            ans+=dfs(eg[i].to,r,eg[i].cost);
        }
    }
    num[r]=ans%mod;
    return ans;
}
int main() {
    k[1]=1;
    for(int i=2; i<=1e5; i++) {
        k[i]=k[i-1]*i%mod;
    }
    while(~scanf("%d",&n)) {
        init();
        for(int i=1; i<n; i++) {
            int u,v,c;
            scanf("%d%d%d",&u,&v,&c);
            add(u,v,c);
            add(v,u,c);
        }
        dfs(1,-1,0);
        ll sum=0;
        for(int i=2; i<=n; i++) {
            sum+=2*c[i]*num[i]%mod*(n-num[i])%mod*k[n-1]%mod;
            sum%=mod;
        }
        cout<<sum<<endl;
    }
    return 0;
}
```
 

   
 